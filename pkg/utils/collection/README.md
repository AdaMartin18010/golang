# é›†åˆå·¥å…·

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-11-11
**é€‚ç”¨äºŽ**: Go 1.25.3

---

## ðŸ“‹ ç›®å½•

- [é›†åˆå·¥å…·](#é›†åˆå·¥å…·)
  - [ðŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. åŠŸèƒ½ç‰¹æ€§](#2-åŠŸèƒ½ç‰¹æ€§)
  - [3. ä½¿ç”¨ç¤ºä¾‹](#3-ä½¿ç”¨ç¤ºä¾‹)

---

## 1. æ¦‚è¿°

é›†åˆå·¥å…·æä¾›äº†ä¸°å¯Œçš„åˆ‡ç‰‡ï¼ˆsliceï¼‰å’Œæ˜ å°„ï¼ˆmapï¼‰æ“ä½œå‡½æ•°ï¼Œç®€åŒ–å¸¸è§çš„æ•°æ®é›†åˆå¤„ç†ä»»åŠ¡ã€‚

---

## 2. åŠŸèƒ½ç‰¹æ€§

### 2.1 åˆ‡ç‰‡æŸ¥æ‰¾å’Œæ“ä½œ

- `Contains`: æ£€æŸ¥åˆ‡ç‰‡æ˜¯å¦åŒ…å«æŒ‡å®šå…ƒç´ 
- `Index`: è¿”å›žå…ƒç´ åœ¨åˆ‡ç‰‡ä¸­çš„ç´¢å¼•
- `Remove`: ä»Žåˆ‡ç‰‡ä¸­ç§»é™¤æŒ‡å®šå…ƒç´ 
- `RemoveAll`: ä»Žåˆ‡ç‰‡ä¸­ç§»é™¤æ‰€æœ‰åŒ¹é…çš„å…ƒç´ 
- `Unique`: åŽ»é™¤åˆ‡ç‰‡ä¸­çš„é‡å¤å…ƒç´ 

### 2.2 åˆ‡ç‰‡è½¬æ¢

- `Filter`: è¿‡æ»¤åˆ‡ç‰‡ï¼Œä¿ç•™æ»¡è¶³æ¡ä»¶çš„å…ƒç´ 
- `Map`: å¯¹åˆ‡ç‰‡ä¸­çš„æ¯ä¸ªå…ƒç´ åº”ç”¨å‡½æ•°
- `Reduce`: å¯¹åˆ‡ç‰‡è¿›è¡Œå½’çº¦æ“ä½œ
- `ForEach`: å¯¹åˆ‡ç‰‡ä¸­çš„æ¯ä¸ªå…ƒç´ æ‰§è¡Œå‡½æ•°
- `Chunk`: å°†åˆ‡ç‰‡åˆ†å‰²æˆæŒ‡å®šå¤§å°çš„å—
- `Flatten`: å±•å¹³äºŒç»´åˆ‡ç‰‡
- `Reverse`: åè½¬åˆ‡ç‰‡

### 2.3 åˆ‡ç‰‡æŽ’åº

- `Sort`: æŽ’åºåˆ‡ç‰‡ï¼ˆå‡åºï¼‰
- `SortBy`: ä½¿ç”¨è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°æŽ’åºåˆ‡ç‰‡
- `SortDesc`: é™åºæŽ’åºåˆ‡ç‰‡

### 2.4 åˆ‡ç‰‡è®¿é—®

- `First`: è¿”å›žåˆ‡ç‰‡çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
- `Last`: è¿”å›žåˆ‡ç‰‡çš„æœ€åŽä¸€ä¸ªå…ƒç´ 
- `Take`: è¿”å›žåˆ‡ç‰‡çš„å‰nä¸ªå…ƒç´ 
- `Drop`: è¿”å›žåˆ‡ç‰‡åŽ»æŽ‰å‰nä¸ªå…ƒç´ åŽçš„å‰©ä½™éƒ¨åˆ†
- `TakeWhile`: è¿”å›žæ»¡è¶³æ¡ä»¶çš„å‰ç¼€å…ƒç´ 
- `DropWhile`: è·³è¿‡æ»¡è¶³æ¡ä»¶çš„å‰ç¼€å…ƒç´ 

### 2.5 åˆ‡ç‰‡åˆ†ç»„å’Œåˆ†åŒº

- `Partition`: å°†åˆ‡ç‰‡åˆ†å‰²æˆä¸¤éƒ¨åˆ†
- `GroupBy`: æ ¹æ®é”®å‡½æ•°å¯¹åˆ‡ç‰‡è¿›è¡Œåˆ†ç»„

### 2.6 åˆ‡ç‰‡ç»Ÿè®¡

- `Count`: ç»Ÿè®¡æ»¡è¶³æ¡ä»¶çš„å…ƒç´ æ•°é‡
- `Any`: æ£€æŸ¥æ˜¯å¦æœ‰å…ƒç´ æ»¡è¶³æ¡ä»¶
- `All`: æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å…ƒç´ éƒ½æ»¡è¶³æ¡ä»¶
- `Sum`: è®¡ç®—æ•°å€¼åˆ‡ç‰‡çš„å’Œ
- `Max`: è¿”å›žåˆ‡ç‰‡ä¸­çš„æœ€å¤§å€¼
- `Min`: è¿”å›žåˆ‡ç‰‡ä¸­çš„æœ€å°å€¼
- `Average`: è®¡ç®—æ•°å€¼åˆ‡ç‰‡çš„å¹³å‡å€¼

### 2.7 åˆ‡ç‰‡é›†åˆè¿ç®—

- `Intersect`: è¿”å›žä¸¤ä¸ªåˆ‡ç‰‡çš„äº¤é›†
- `Union`: è¿”å›žä¸¤ä¸ªåˆ‡ç‰‡çš„å¹¶é›†
- `Difference`: è¿”å›žä¸¤ä¸ªåˆ‡ç‰‡çš„å·®é›†
- `Zip`: å°†ä¸¤ä¸ªåˆ‡ç‰‡ç»„åˆæˆé”®å€¼å¯¹åˆ‡ç‰‡

### 2.8 æ˜ å°„æ“ä½œ

- `MapKeys`: èŽ·å–mapçš„æ‰€æœ‰é”®
- `MapValues`: èŽ·å–mapçš„æ‰€æœ‰å€¼
- `MapContains`: æ£€æŸ¥mapæ˜¯å¦åŒ…å«æŒ‡å®šé”®
- `MapGet`: èŽ·å–mapçš„å€¼ï¼Œå¦‚æžœä¸å­˜åœ¨è¿”å›žé»˜è®¤å€¼
- `MapFilter`: è¿‡æ»¤mapï¼Œä¿ç•™æ»¡è¶³æ¡ä»¶çš„é”®å€¼å¯¹
- `MapMap`: å¯¹mapä¸­çš„æ¯ä¸ªé”®å€¼å¯¹åº”ç”¨å‡½æ•°

---

## 3. ä½¿ç”¨ç¤ºä¾‹

### 3.1 åˆ‡ç‰‡æŸ¥æ‰¾å’Œæ“ä½œ

```go
import "github.com/yourusername/golang/pkg/utils/collection"

// æ£€æŸ¥æ˜¯å¦åŒ…å«å…ƒç´ 
if collection.Contains([]int{1, 2, 3}, 2) {
    // åŒ…å«å…ƒç´ 
}

// èŽ·å–å…ƒç´ ç´¢å¼•
index := collection.Index([]int{1, 2, 3}, 2) // è¿”å›ž 1

// ç§»é™¤å…ƒç´ 
result := collection.Remove([]int{1, 2, 3, 2}, 2) // [1, 3, 2]

// åŽ»é‡
unique := collection.Unique([]int{1, 2, 2, 3, 3}) // [1, 2, 3]
```

### 3.2 åˆ‡ç‰‡è½¬æ¢

```go
// è¿‡æ»¤
even := collection.Filter([]int{1, 2, 3, 4, 5}, func(x int) bool {
    return x%2 == 0
}) // [2, 4]

// æ˜ å°„
doubled := collection.Map([]int{1, 2, 3}, func(x int) int {
    return x * 2
}) // [2, 4, 6]

// å½’çº¦
sum := collection.Reduce([]int{1, 2, 3}, 0, func(acc, x int) int {
    return acc + x
}) // 6

// åˆ†å—
chunks := collection.Chunk([]int{1, 2, 3, 4, 5}, 2) // [[1, 2], [3, 4], [5]]
```

### 3.3 åˆ‡ç‰‡æŽ’åº

```go
// å‡åºæŽ’åº
sorted := collection.Sort([]int{3, 1, 2}) // [1, 2, 3]

// é™åºæŽ’åº
desc := collection.SortDesc([]int{3, 1, 2}) // [3, 2, 1]

// è‡ªå®šä¹‰æŽ’åº
custom := collection.SortBy([]string{"a", "aa", "aaa"}, func(a, b string) int {
    return len(a) - len(b)
})
```

### 3.4 åˆ‡ç‰‡è®¿é—®

```go
// èŽ·å–ç¬¬ä¸€ä¸ªå…ƒç´ 
first, ok := collection.First([]int{1, 2, 3}) // (1, true)

// èŽ·å–æœ€åŽä¸€ä¸ªå…ƒç´ 
last, ok := collection.Last([]int{1, 2, 3}) // (3, true)

// èŽ·å–å‰nä¸ªå…ƒç´ 
top3 := collection.Take([]int{1, 2, 3, 4, 5}, 3) // [1, 2, 3]

// è·³è¿‡å‰nä¸ªå…ƒç´ 
rest := collection.Drop([]int{1, 2, 3, 4, 5}, 2) // [3, 4, 5]
```

### 3.5 åˆ‡ç‰‡åˆ†ç»„

```go
// åˆ†åŒº
even, odd := collection.Partition([]int{1, 2, 3, 4, 5}, func(x int) bool {
    return x%2 == 0
}) // even: [2, 4], odd: [1, 3, 5]

// åˆ†ç»„
groups := collection.GroupBy([]int{1, 2, 3, 4, 5}, func(x int) string {
    if x%2 == 0 {
        return "even"
    }
    return "odd"
}) // map[string][]int{"even": [2, 4], "odd": [1, 3, 5]}
```

### 3.6 åˆ‡ç‰‡ç»Ÿè®¡

```go
// ç»Ÿè®¡
count := collection.Count([]int{1, 2, 3, 4, 5}, func(x int) bool {
    return x > 3
}) // 2

// æ£€æŸ¥æ˜¯å¦æœ‰å…ƒç´ æ»¡è¶³æ¡ä»¶
hasLarge := collection.Any([]int{1, 2, 3}, func(x int) bool {
    return x > 2
}) // true

// æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å…ƒç´ éƒ½æ»¡è¶³æ¡ä»¶
allPositive := collection.All([]int{1, 2, 3}, func(x int) bool {
    return x > 0
}) // true

// æ±‚å’Œ
sum := collection.Sum([]int{1, 2, 3, 4, 5}) // 15

// æœ€å¤§å€¼
max, ok := collection.Max([]int{1, 5, 3, 2}) // (5, true)

// æœ€å°å€¼
min, ok := collection.Min([]int{1, 5, 3, 2}) // (1, true)

// å¹³å‡å€¼
avg, ok := collection.Average([]int{1, 2, 3, 4, 5}) // (3.0, true)
```

### 3.7 åˆ‡ç‰‡é›†åˆè¿ç®—

```go
// äº¤é›†
intersect := collection.Intersect([]int{1, 2, 3}, []int{2, 3, 4}) // [2, 3]

// å¹¶é›†
union := collection.Union([]int{1, 2, 3}, []int{3, 4, 5}) // [1, 2, 3, 4, 5]

// å·®é›†
diff := collection.Difference([]int{1, 2, 3, 4}, []int{3, 4}) // [1, 2]

// ç»„åˆ
pairs := collection.Zip([]int{1, 2, 3}, []string{"a", "b", "c"})
```

### 3.8 æ˜ å°„æ“ä½œ

```go
m := map[string]int{"a": 1, "b": 2, "c": 3}

// èŽ·å–æ‰€æœ‰é”®
keys := collection.MapKeys(m) // ["a", "b", "c"]

// èŽ·å–æ‰€æœ‰å€¼
values := collection.MapValues(m) // [1, 2, 3]

// æ£€æŸ¥æ˜¯å¦åŒ…å«é”®
if collection.MapContains(m, "a") {
    // åŒ…å«é”®
}

// èŽ·å–å€¼ï¼ˆå¸¦é»˜è®¤å€¼ï¼‰
value := collection.MapGet(m, "d", 0) // 0

// è¿‡æ»¤
filtered := collection.MapFilter(m, func(k string, v int) bool {
    return v > 1
}) // map[string]int{"b": 2, "c": 3}
```

---

**æ›´æ–°æ—¥æœŸ**: 2025-11-11
