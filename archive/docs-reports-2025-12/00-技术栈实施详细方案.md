# Go 1.25.3 æŠ€æœ¯æ ˆå®æ–½è¯¦ç»†æ–¹æ¡ˆ

> **ç‰ˆæœ¬**: v1.0
> **æ—¥æœŸ**: 2025-01-XX
> **ç”¨é€”**: è¯¦ç»†çš„æŠ€æœ¯å®æ–½æ­¥éª¤å’Œä»£ç æ–¹æ¡ˆ

---

## ğŸ“‹ ç›®å½•

- [1. NATS å®æ–½è¯¦ç»†æ–¹æ¡ˆ](#1-nats-å®æ–½è¯¦ç»†æ–¹æ¡ˆ)
- [2. gRPC å®æ–½è¯¦ç»†æ–¹æ¡ˆ](#2-grpc-å®æ–½è¯¦ç»†æ–¹æ¡ˆ)
- [3. ä»£ç ç”Ÿæˆå·¥å…·é“¾æ–¹æ¡ˆ](#3-ä»£ç ç”Ÿæˆå·¥å…·é“¾æ–¹æ¡ˆ)
- [4. æ–‡æ¡£å’Œç¤ºä¾‹æ–¹æ¡ˆ](#4-æ–‡æ¡£å’Œç¤ºä¾‹æ–¹æ¡ˆ)

---

## 1. NATS å®æ–½è¯¦ç»†æ–¹æ¡ˆ

### 1.1 é¡¹ç›®ç»“æ„

```text
internal/infrastructure/messaging/nats/
â”œâ”€â”€ client.go          # NATS å®¢æˆ·ç«¯å®ç°
â”œâ”€â”€ config.go          # NATS é…ç½®å®šä¹‰
â”œâ”€â”€ client_test.go     # å•å…ƒæµ‹è¯•
â””â”€â”€ README.md          # ä½¿ç”¨æ–‡æ¡£
```

### 1.2 å®æ–½æ­¥éª¤

#### Step 1: åˆ›å»ºé¡¹ç›®ç»“æ„

```bash
# åˆ›å»ºç›®å½•
mkdir -p internal/infrastructure/messaging/nats

# åˆ›å»ºæ–‡ä»¶
touch internal/infrastructure/messaging/nats/client.go
touch internal/infrastructure/messaging/nats/config.go
touch internal/infrastructure/messaging/nats/client_test.go
touch internal/infrastructure/messaging/nats/README.md
```

#### Step 2: å®ç°é…ç½®å®šä¹‰

**æ–‡ä»¶**: `config.go`

```go
package nats

import "time"

// Config NATS å®¢æˆ·ç«¯é…ç½®
type Config struct {
    URL            string        // NATS æœåŠ¡å™¨åœ°å€ï¼Œä¾‹å¦‚: "nats://localhost:4222"
    MaxReconnects  int           // æœ€å¤§é‡è¿æ¬¡æ•°ï¼Œ-1 è¡¨ç¤ºæ— é™é‡è¿
    ReconnectWait  time.Duration // é‡è¿ç­‰å¾…æ—¶é—´
    Timeout        time.Duration // è¿æ¥è¶…æ—¶
    Name           string        // å®¢æˆ·ç«¯åç§°
    Token          string        // è®¤è¯ Tokenï¼ˆå¯é€‰ï¼‰
    Username       string        // ç”¨æˆ·åï¼ˆå¯é€‰ï¼‰
    Password       string        // å¯†ç ï¼ˆå¯é€‰ï¼‰
}

// DefaultConfig è¿”å›é»˜è®¤é…ç½®
func DefaultConfig() Config {
    return Config{
        URL:           "nats://localhost:4222",
        MaxReconnects: -1,
        ReconnectWait: 2 * time.Second,
        Timeout:       5 * time.Second,
    }
}
```

#### Step 3: å®ç°å®¢æˆ·ç«¯æ ¸å¿ƒåŠŸèƒ½

**æ–‡ä»¶**: `client.go`

```go
package nats

import (
    "context"
    "encoding/json"
    "fmt"
    "time"

    "github.com/nats-io/nats.go"
)

// Client NATS å®¢æˆ·ç«¯å°è£…
type Client struct {
    conn *nats.Conn
}

// NewClient åˆ›å»º NATS å®¢æˆ·ç«¯
func NewClient(cfg Config) (*Client, error) {
    opts := []nats.Option{
        nats.Name(cfg.Name),
        nats.MaxReconnects(cfg.MaxReconnects),
        nats.ReconnectWait(cfg.ReconnectWait),
        nats.Timeout(cfg.Timeout),
        nats.DisconnectErrHandler(func(nc *nats.Conn, err error) {
            // è®°å½•æ–­å¼€è¿æ¥é”™è¯¯
        }),
        nats.ReconnectHandler(func(nc *nats.Conn) {
            // è®°å½•é‡è¿æˆåŠŸ
        }),
    }

    // è®¤è¯é…ç½®
    if cfg.Token != "" {
        opts = append(opts, nats.Token(cfg.Token))
    } else if cfg.Username != "" && cfg.Password != "" {
        opts = append(opts, nats.UserInfo(cfg.Username, cfg.Password))
    }

    conn, err := nats.Connect(cfg.URL, opts...)
    if err != nil {
        return nil, fmt.Errorf("failed to connect to NATS: %w", err)
    }

    return &Client{conn: conn}, nil
}

// Publish å‘å¸ƒæ¶ˆæ¯
func (c *Client) Publish(subject string, data interface{}) error {
    var payload []byte
    var err error

    switch v := data.(type) {
    case []byte:
        payload = v
    case string:
        payload = []byte(v)
    default:
        payload, err = json.Marshal(data)
        if err != nil {
            return fmt.Errorf("failed to marshal message: %w", err)
        }
    }

    return c.conn.Publish(subject, payload)
}

// Subscribe è®¢é˜…ä¸»é¢˜
func (c *Client) Subscribe(subject string, handler func(*nats.Msg)) (*nats.Subscription, error) {
    return c.conn.Subscribe(subject, handler)
}

// QueueSubscribe é˜Ÿåˆ—è®¢é˜…ï¼ˆè´Ÿè½½å‡è¡¡ï¼‰
func (c *Client) QueueSubscribe(subject, queue string, handler func(*nats.Msg)) (*nats.Subscription, error) {
    return c.conn.QueueSubscribe(subject, queue, handler)
}

// Request å‘é€è¯·æ±‚å¹¶ç­‰å¾…å“åº”
func (c *Client) Request(subject string, data interface{}, timeout time.Duration) (*nats.Msg, error) {
    var payload []byte
    var err error

    switch v := data.(type) {
    case []byte:
        payload = v
    case string:
        payload = []byte(v)
    default:
        payload, err = json.Marshal(data)
        if err != nil {
            return nil, fmt.Errorf("failed to marshal message: %w", err)
        }
    }

    msg, err := c.conn.Request(subject, payload, timeout)
    if err != nil {
        return nil, fmt.Errorf("failed to send request: %w", err)
    }

    return msg, nil
}

// Close å…³é—­è¿æ¥
func (c *Client) Close() {
    c.conn.Close()
}

// IsConnected æ£€æŸ¥è¿æ¥çŠ¶æ€
func (c *Client) IsConnected() bool {
    return c.conn.IsConnected()
}

// Stats è·å–è¿æ¥ç»Ÿè®¡ä¿¡æ¯
func (c *Client) Stats() nats.Stats {
    return c.conn.Stats()
}
```

#### Step 4: æ·»åŠ ä¾èµ–

**æ›´æ–°**: `go.mod`

```bash
go get github.com/nats-io/nats.go@v1.35.0
```

#### Step 5: ç¼–å†™æµ‹è¯•

**æ–‡ä»¶**: `client_test.go`

```go
package nats

import (
    "testing"
    "time"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestNewClient(t *testing.T) {
    // éœ€è¦ NATS æœåŠ¡å™¨è¿è¡Œ
    cfg := DefaultConfig()
    client, err := NewClient(cfg)

    if err != nil {
        t.Skip("NATS server not available")
        return
    }

    require.NoError(t, err)
    assert.NotNil(t, client)
    assert.True(t, client.IsConnected())

    defer client.Close()
}

func TestPublishSubscribe(t *testing.T) {
    cfg := DefaultConfig()
    client, err := NewClient(cfg)

    if err != nil {
        t.Skip("NATS server not available")
        return
    }

    require.NoError(t, err)
    defer client.Close()

    // è®¢é˜…
    received := make(chan bool, 1)
    sub, err := client.Subscribe("test.subject", func(msg *nats.Msg) {
        assert.Equal(t, "test.payload", string(msg.Data))
        received <- true
    })
    require.NoError(t, err)
    defer sub.Unsubscribe()

    // å‘å¸ƒ
    err = client.Publish("test.subject", "test.payload")
    require.NoError(t, err)

    // ç­‰å¾…æ¥æ”¶
    select {
    case <-received:
        // æˆåŠŸ
    case <-time.After(1 * time.Second):
        t.Fatal("message not received")
    }
}
```

#### Step 6: ç¼–å†™æ–‡æ¡£

**æ–‡ä»¶**: `README.md`

```markdown
# NATS å®¢æˆ·ç«¯

NATS å®¢æˆ·ç«¯å®ç°ï¼Œæ”¯æŒå‘å¸ƒ/è®¢é˜…ã€Request/Reply ç­‰æ¨¡å¼ã€‚

## ä½¿ç”¨ç¤ºä¾‹

### åŸºæœ¬ä½¿ç”¨

\`\`\`go
import "github.com/yourusername/golang/internal/infrastructure/messaging/nats"

// åˆ›å»ºå®¢æˆ·ç«¯
client, err := nats.NewClient(nats.DefaultConfig())
if err != nil {
    log.Fatal(err)
}
defer client.Close()

// å‘å¸ƒæ¶ˆæ¯
err = client.Publish("user.created", map[string]interface{}{
    "user_id": 123,
    "name":    "Alice",
})

// è®¢é˜…æ¶ˆæ¯
sub, err := client.Subscribe("user.created", func(msg *nats.Msg) {
    var data map[string]interface{}
    json.Unmarshal(msg.Data, &data)
    log.Printf("Received: %+v", data)
})
defer sub.Unsubscribe()
\`\`\`
```

---

## 2. gRPC å®æ–½è¯¦ç»†æ–¹æ¡ˆ

### 2.1 é¡¹ç›®ç»“æ„

```text
internal/interfaces/grpc/
â”œâ”€â”€ proto/
â”‚   â”œâ”€â”€ user.proto
â”‚   â”œâ”€â”€ health.proto
â”‚   â””â”€â”€ common.proto
â”œâ”€â”€ handlers/
â”‚   â”œâ”€â”€ user_handler.go
â”‚   â””â”€â”€ health_handler.go
â”œâ”€â”€ interceptors/
â”‚   â”œâ”€â”€ logging.go
â”‚   â”œâ”€â”€ tracing.go
â”‚   â””â”€â”€ auth.go
â””â”€â”€ server.go
```

### 2.2 å®æ–½æ­¥éª¤

#### Step 1: åˆ›å»º Proto æ–‡ä»¶

**æ–‡ä»¶**: `proto/user.proto`

```protobuf
syntax = "proto3";

package user.v1;

option go_package = "github.com/yourusername/golang/internal/interfaces/grpc/proto/userpb";

import "google/protobuf/timestamp.proto";

service UserService {
  rpc GetUser(GetUserRequest) returns (GetUserResponse);
  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);
}

message User {
  string id = 1;
  string name = 2;
  string email = 3;
  google.protobuf.Timestamp created_at = 4;
}

message GetUserRequest {
  string id = 1;
}

message GetUserResponse {
  User user = 1;
}

message CreateUserRequest {
  string name = 1;
  string email = 2;
}

message CreateUserResponse {
  User user = 1;
}
```

**æ–‡ä»¶**: `proto/health.proto`

```protobuf
syntax = "proto3";

package health.v1;

option go_package = "github.com/yourusername/golang/internal/interfaces/grpc/proto/healthpb";

import "google/protobuf/empty.proto";

service HealthService {
  rpc Check(google.protobuf.Empty) returns (HealthResponse);
}

message HealthResponse {
  enum Status {
    UNKNOWN = 0;
    SERVING = 1;
    NOT_SERVING = 2;
  }
  Status status = 1;
}
```

#### Step 2: åˆ›å»ºä»£ç ç”Ÿæˆè„šæœ¬

**æ–‡ä»¶**: `scripts/grpc/generate.sh`

```bash
#!/bin/bash

set -e

PROTO_DIR="internal/interfaces/grpc/proto"
OUTPUT_DIR="internal/interfaces/grpc/proto"

# ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
mkdir -p "$OUTPUT_DIR"

# ç”Ÿæˆ Go ä»£ç 
protoc \
  --go_out="$OUTPUT_DIR" \
  --go_opt=paths=source_relative \
  --go-grpc_out="$OUTPUT_DIR" \
  --go-grpc_opt=paths=source_relative \
  -I="$PROTO_DIR" \
  "$PROTO_DIR"/*.proto

echo "gRPC code generation completed"
```

**æ›´æ–°**: `Makefile`

```makefile
.PHONY: generate-grpc
generate-grpc:
 @echo "Generating gRPC code..."
 @bash scripts/grpc/generate.sh
```

#### Step 3: å®ç° Handler

**æ–‡ä»¶**: `handlers/user_handler.go`

```go
package handlers

import (
    "context"

    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"

    "github.com/yourusername/golang/internal/application/user"
    userpb "github.com/yourusername/golang/internal/interfaces/grpc/proto/userpb"
    "google.golang.org/protobuf/types/known/timestamppb"
)

type UserHandler struct {
    userpb.UnimplementedUserServiceServer
    service *user.Service
}

func NewUserHandler(service *user.Service) *UserHandler {
    return &UserHandler{
        service: service,
    }
}

func (h *UserHandler) GetUser(ctx context.Context, req *userpb.GetUserRequest) (*userpb.GetUserResponse, error) {
    u, err := h.service.GetByID(ctx, req.Id)
    if err != nil {
        return nil, status.Error(codes.NotFound, err.Error())
    }

    return &userpb.GetUserResponse{
        User: toProtoUser(u),
    }, nil
}

func (h *UserHandler) CreateUser(ctx context.Context, req *userpb.CreateUserRequest) (*userpb.CreateUserResponse, error) {
    u, err := h.service.Create(ctx, req.Name, req.Email)
    if err != nil {
        return nil, status.Error(codes.Internal, err.Error())
    }

    return &userpb.CreateUserResponse{
        User: toProtoUser(u),
    }, nil
}

func toProtoUser(u *user.User) *userpb.User {
    return &userpb.User{
        Id:        u.ID,
        Name:      u.Name,
        Email:     u.Email,
        CreatedAt: timestamppb.New(u.CreatedAt),
    }
}
```

#### Step 4: å®ç°æ‹¦æˆªå™¨

**æ–‡ä»¶**: `interceptors/logging.go`

```go
package interceptors

import (
    "context"
    "log/slog"

    "google.golang.org/grpc"
)

func LoggingUnaryInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
    slog.Info("gRPC request",
        "method", info.FullMethod,
        "request", req,
    )

    resp, err := handler(ctx, req)

    if err != nil {
        slog.Error("gRPC error",
            "method", info.FullMethod,
            "error", err,
        )
    } else {
        slog.Info("gRPC response",
            "method", info.FullMethod,
        )
    }

    return resp, err
}
```

**æ–‡ä»¶**: `interceptors/tracing.go`

```go
package interceptors

import (
    "context"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
    "google.golang.org/grpc"
    "google.golang.org/grpc/status"
)

func TracingUnaryInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
    tracer := otel.Tracer("grpc")
    ctx, span := tracer.Start(ctx, info.FullMethod,
        trace.WithSpanKind(trace.SpanKindServer),
    )
    defer span.End()

    resp, err := handler(ctx, req)

    if err != nil {
        s, _ := status.FromError(err)
        span.SetStatus(codes.Error, s.Message())
        span.RecordError(err)
    } else {
        span.SetStatus(codes.Ok, "success")
    }

    span.SetAttributes(
        attribute.String("grpc.method", info.FullMethod),
        attribute.String("grpc.status", status.Code(err).String()),
    )

    return resp, err
}
```

#### Step 5: æ›´æ–°æœåŠ¡å™¨ä»£ç 

**æ–‡ä»¶**: `cmd/grpc-server/main.go`

```go
// ... existing code ...

import (
    "github.com/yourusername/golang/internal/interfaces/grpc/handlers"
    "github.com/yourusername/golang/internal/interfaces/grpc/interceptors"
    userpb "github.com/yourusername/golang/internal/interfaces/grpc/proto/userpb"
    healthpb "github.com/yourusername/golang/internal/interfaces/grpc/proto/healthpb"
)

// ... existing code ...

// åˆ›å»º gRPC æœåŠ¡å™¨ï¼ˆå¸¦æ‹¦æˆªå™¨ï¼‰
grpcServer := grpc.NewServer(
    grpc.UnaryInterceptor(
        interceptors.LoggingUnaryInterceptor,
        interceptors.TracingUnaryInterceptor,
    ),
)

// æ³¨å†ŒæœåŠ¡
userHandler := handlers.NewUserHandler(userService)
userpb.RegisterUserServiceServer(grpcServer, userHandler)

healthpb.RegisterHealthServiceServer(grpcServer, handlers.NewHealthHandler())

// ... existing code ...
```

---

## 3. ä»£ç ç”Ÿæˆå·¥å…·é“¾æ–¹æ¡ˆ

### 3.1 OpenAPI ä»£ç ç”Ÿæˆ

#### Step 1: å®‰è£…å·¥å…·

```bash
go install github.com/deepmap/oapi-codegen/v2/cmd/oapi-codegen@latest
```

#### Step 2: åˆ›å»ºç”Ÿæˆè„šæœ¬

**æ–‡ä»¶**: `scripts/api/generate-openapi.sh`

```bash
#!/bin/bash

set -e

OPENAPI_SPEC="api/openapi/openapi.yaml"
OUTPUT_DIR="internal/interfaces/http/openapi"

# ç”Ÿæˆä»£ç 
oapi-codegen \
  -generate types,server,chi-server,spec \
  -package openapi \
  -o "${OUTPUT_DIR}/server.gen.go" \
  "${OPENAPI_SPEC}"

echo "OpenAPI code generation completed"
```

#### Step 3: æ›´æ–° Makefile

```makefile
.PHONY: generate-openapi
generate-openapi:
 @echo "Generating OpenAPI code..."
 @bash scripts/api/generate-openapi.sh

.PHONY: generate-all
generate-all: generate-grpc generate-openapi
 @echo "All code generation completed"
```

### 3.2 GraphQL ä»£ç ç”Ÿæˆï¼ˆå¯é€‰ï¼‰

#### 3.2.1 Step 1: å®‰è£…å·¥å…·

```bash
go install github.com/99designs/gqlgen@latest
```

#### Step 2: åˆå§‹åŒ–é…ç½®

```bash
cd internal/interfaces/graphql
gqlgen init
```

#### Step 3: é…ç½® gqlgen.yml

```yaml
schema:
  - api/graphql/schema.graphql

exec:
  filename: resolver.go
  package: graphql

model:
  filename: models_gen.go
  package: graphql
```

---

## 4. æ–‡æ¡£å’Œç¤ºä¾‹æ–¹æ¡ˆ

### 4.1 æ–‡æ¡£ç»“æ„

```text
docs/
â”œâ”€â”€ messaging/
â”‚   â””â”€â”€ nats.md          # NATS ä½¿ç”¨æ–‡æ¡£
â”œâ”€â”€ grpc/
â”‚   â””â”€â”€ grpc.md          # gRPC ä½¿ç”¨æ–‡æ¡£
â””â”€â”€ codegen/
    â””â”€â”€ codegen.md       # ä»£ç ç”Ÿæˆå·¥å…·é“¾æ–‡æ¡£
```

### 4.2 ç¤ºä¾‹ç»“æ„

```text
examples/
â”œâ”€â”€ messaging/
â”‚   â””â”€â”€ nats/
â”‚       â”œâ”€â”€ publish_subscribe.go
â”‚       â””â”€â”€ request_reply.go
â””â”€â”€ grpc/
    â”œâ”€â”€ client.go
    â””â”€â”€ server.go
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [å®æ–½æ€»ä½“è§„åˆ’](00-æŠ€æœ¯æ ˆå®æ–½æ€»ä½“è§„åˆ’.md)
- [é¡¹ç›®é‡æ–°å®šä½](00-é¡¹ç›®é‡æ–°å®šä½ä¸è½»é‡çº§æ¶æ„è®¡åˆ’.md)

---

**æœ€åæ›´æ–°**: 2025-01-XX
