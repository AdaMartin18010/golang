package api

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

// Pattern 并发模式
type Pattern struct {
	Name        string         `json:"name"`
	Category    string         `json:"category"` // classic, sync, control, dataflow, advanced
	Description string         `json:"description"`
	CSP         string         `json:"csp"`
	Safety      []string       `json:"safety"`
	Parameters  []PatternParam `json:"parameters"`
	Example     string         `json:"example,omitempty"`
}

// PatternParam 模式参数
type PatternParam struct {
	Name        string `json:"name"`
	Type        string `json:"type"` // int, string, bool
	Required    bool   `json:"required"`
	Default     string `json:"default,omitempty"`
	Description string `json:"description"`
}

// GenerateRequest 生成请求
type GenerateRequest struct {
	Pattern    string            `json:"pattern" binding:"required"`
	Parameters map[string]string `json:"parameters"`
	Options    map[string]bool   `json:"options"`
}

// GenerateResponse 生成响应
type GenerateResponse struct {
	Success bool   `json:"success"`
	Code    string `json:"code,omitempty"`
	Error   string `json:"error,omitempty"`
	Time    string `json:"time"`
}

// ListPatterns 列出所有并发模式
func ListPatterns(c *gin.Context) {
	category := c.Query("category")

	patterns := []Pattern{
		{
			Name:        "worker-pool",
			Category:    "classic",
			Description: "A pool of worker goroutines processing tasks from a queue",
			CSP:         "POOL = (task? → WORKER_SELECT → process → POOL)",
			Safety:      []string{"No deadlock", "Bounded wait time", "Starvation-free"},
			Parameters: []PatternParam{
				{Name: "workers", Type: "int", Required: true, Default: "10", Description: "Number of worker goroutines"},
				{Name: "bufferSize", Type: "int", Required: false, Default: "100", Description: "Task queue buffer size"},
			},
		},
		{
			Name:        "pipeline",
			Category:    "classic",
			Description: "Chain of processing stages connected by channels",
			CSP:         "PIPE = (input? → stage1! → stage2! → output!)",
			Safety:      []string{"No deadlock", "Backpressure support"},
			Parameters: []PatternParam{
				{Name: "stages", Type: "int", Required: true, Default: "3", Description: "Number of pipeline stages"},
			},
		},
		{
			Name:        "context-cancel",
			Category:    "control",
			Description: "Graceful cancellation using context",
			CSP:         "CANCEL = (work | cancel → cleanup → STOP)",
			Safety:      []string{"Graceful shutdown", "Resource cleanup guaranteed"},
			Parameters: []PatternParam{
				{Name: "timeout", Type: "string", Required: false, Default: "30s", Description: "Cancellation timeout"},
			},
		},
		// 添加更多模式...
	}

	// 根据category过滤
	if category != "" {
		filtered := []Pattern{}
		for _, p := range patterns {
			if p.Category == category {
				filtered = append(filtered, p)
			}
		}
		patterns = filtered
	}

	c.JSON(http.StatusOK, AnalysisResponse{
		Success: true,
		Data:    patterns,
		Time:    getCurrentTime(),
	})
}

// GetPattern 获取特定模式详情
func GetPattern(c *gin.Context) {
	name := c.Param("name")

	// TODO: 从pattern generator获取实际数据
	// 当前返回模拟数据
	if name == "worker-pool" {
		pattern := Pattern{
			Name:        "worker-pool",
			Category:    "classic",
			Description: "A pool of worker goroutines processing tasks from a queue",
			CSP:         "POOL = (task? → WORKER_SELECT → process → POOL)",
			Safety:      []string{"No deadlock", "Bounded wait time", "Starvation-free"},
			Parameters: []PatternParam{
				{Name: "workers", Type: "int", Required: true, Default: "10", Description: "Number of worker goroutines"},
				{Name: "bufferSize", Type: "int", Required: false, Default: "100", Description: "Task queue buffer size"},
			},
			Example: `package main

import (
	"fmt"
	"sync"
)

func WorkerPool(workers int, tasks <-chan Task) {
	var wg sync.WaitGroup
	for i := 0; i < workers; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			for task := range tasks {
				fmt.Printf("Worker %d processing task %v\n", id, task)
			}
		}(i)
	}
	wg.Wait()
}`,
		}

		c.JSON(http.StatusOK, AnalysisResponse{
			Success: true,
			Data:    pattern,
			Time:    getCurrentTime(),
		})
		return
	}

	c.JSON(http.StatusNotFound, AnalysisResponse{
		Success: false,
		Error:   "Pattern not found",
		Time:    getCurrentTime(),
	})
}

// GeneratePattern 生成并发模式代码
func GeneratePattern(c *gin.Context) {
	var req GenerateRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, GenerateResponse{
			Success: false,
			Error:   err.Error(),
			Time:    getCurrentTime(),
		})
		return
	}

	// TODO: 调用pattern generator生成实际代码
	// 当前返回模拟代码
	code := `package main

import (
	"fmt"
	"sync"
)

// Generated by Go Formal Verification Framework
// Pattern: ` + req.Pattern + `
// CSP: POOL = (task? → WORKER_SELECT → process → POOL)

type Task struct {
	ID   int
	Data interface{}
}

func WorkerPool(workers int, tasks <-chan Task) {
	var wg sync.WaitGroup
	for i := 0; i < workers; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			for task := range tasks {
				// Process task
				fmt.Printf("Worker %d processing task %d\n", id, task.ID)
			}
		}(i)
	}
	wg.Wait()
}

func main() {
	tasks := make(chan Task, 100)
	go WorkerPool(10, tasks)
	
	// Submit tasks
	for i := 0; i < 50; i++ {
		tasks <- Task{ID: i, Data: fmt.Sprintf("task-%d", i)}
	}
	close(tasks)
}
`

	c.JSON(http.StatusOK, GenerateResponse{
		Success: true,
		Code:    code,
		Time:    getCurrentTime(),
	})
}
