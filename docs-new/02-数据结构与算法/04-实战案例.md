# 04-å®æˆ˜æ¡ˆä¾‹

> Goè¯­è¨€ç®—æ³•å®æˆ˜ï¼šLeetCodeç»å…¸é¢˜ç›®è§£æ

---

## ğŸ“š ç›®å½•

- [04-å®æˆ˜æ¡ˆä¾‹](#04-å®æˆ˜æ¡ˆä¾‹)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [ğŸ“š ç« èŠ‚æ¦‚è§ˆ](#-ç« èŠ‚æ¦‚è§ˆ)
  - [1. æ•°ç»„é—®é¢˜ (Array)](#1-æ•°ç»„é—®é¢˜-array)
    - [1.1 ä¸¤æ•°ä¹‹å’Œ](#11-ä¸¤æ•°ä¹‹å’Œ)
    - [1.2 ä¸‰æ•°ä¹‹å’Œ](#12-ä¸‰æ•°ä¹‹å’Œ)
    - [1.3 ç››æœ€å¤šæ°´çš„å®¹å™¨](#13-ç››æœ€å¤šæ°´çš„å®¹å™¨)
  - [2. é“¾è¡¨é—®é¢˜ (Linked List)](#2-é“¾è¡¨é—®é¢˜-linked-list)
    - [2.1 åè½¬é“¾è¡¨](#21-åè½¬é“¾è¡¨)
    - [2.2 åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](#22-åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨)
    - [2.3 ç¯å½¢é“¾è¡¨II](#23-ç¯å½¢é“¾è¡¨ii)
  - [3. å­—ç¬¦ä¸²é—®é¢˜ (String)](#3-å­—ç¬¦ä¸²é—®é¢˜-string)
    - [3.1 æœ€é•¿å›æ–‡å­ä¸²](#31-æœ€é•¿å›æ–‡å­ä¸²)
    - [3.2 å­—ç¬¦ä¸²ç›¸ä¹˜](#32-å­—ç¬¦ä¸²ç›¸ä¹˜)
    - [3.3 æœ‰æ•ˆçš„æ‹¬å·](#33-æœ‰æ•ˆçš„æ‹¬å·)
  - [4. æ ‘é—®é¢˜ (Tree)](#4-æ ‘é—®é¢˜-tree)
    - [4.1 äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](#41-äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦)
    - [4.2 éªŒè¯äºŒå‰æœç´¢æ ‘](#42-éªŒè¯äºŒå‰æœç´¢æ ‘)
    - [4.3 äºŒå‰æ ‘çš„å³è§†å›¾](#43-äºŒå‰æ ‘çš„å³è§†å›¾)
  - [5. åŠ¨æ€è§„åˆ’ (DP)](#5-åŠ¨æ€è§„åˆ’-dp)
    - [5.1 æœ€å¤§å­æ•°ç»„å’Œ](#51-æœ€å¤§å­æ•°ç»„å’Œ)
    - [5.2 çˆ¬æ¥¼æ¢¯](#52-çˆ¬æ¥¼æ¢¯)
    - [5.3 é›¶é’±å…‘æ¢](#53-é›¶é’±å…‘æ¢)
  - [6. å›æº¯é—®é¢˜ (Backtracking)](#6-å›æº¯é—®é¢˜-backtracking)
    - [6.1 å…¨æ’åˆ—](#61-å…¨æ’åˆ—)
    - [6.2 å­é›†](#62-å­é›†)
    - [6.3 ç»„åˆæ€»å’Œ](#63-ç»„åˆæ€»å’Œ)
  - [ğŸ’¡ è§£é¢˜æŠ€å·§æ€»ç»“](#-è§£é¢˜æŠ€å·§æ€»ç»“)
    - [1. æ—¶é—´å¤æ‚åº¦é€ŸæŸ¥](#1-æ—¶é—´å¤æ‚åº¦é€ŸæŸ¥)
    - [2. ç©ºé—´ä¼˜åŒ–æŠ€å·§](#2-ç©ºé—´ä¼˜åŒ–æŠ€å·§)
    - [3. å¸¸è§é™·é˜±](#3-å¸¸è§é™·é˜±)
    - [4. è°ƒè¯•æŠ€å·§](#4-è°ƒè¯•æŠ€å·§)
  - [ğŸ”— ç›¸å…³ç« èŠ‚](#-ç›¸å…³ç« èŠ‚)

## ğŸ“š ç« èŠ‚æ¦‚è§ˆ

æœ¬ç« ç²¾é€‰LeetCodeç»å…¸é¢˜ç›®ï¼Œæä¾›è¯¦ç»†çš„Goè¯­è¨€è§£æ³•å’Œè§£é¢˜æ€è·¯ï¼Œå¸®åŠ©ä½ å¿«é€ŸæŒæ¡ç®—æ³•é¢è¯•æŠ€å·§ã€‚

---

## 1. æ•°ç»„é—®é¢˜ (Array)

### 1.1 ä¸¤æ•°ä¹‹å’Œ

**LeetCode 1. Two Sum** | éš¾åº¦ï¼šç®€å•

**é—®é¢˜æè¿°**:
ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼ `target`ï¼Œæ‰¾å‡ºæ•°ç»„ä¸­å’Œä¸ºç›®æ ‡å€¼çš„ä¸¤ä¸ªæ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚

```go
package main

import "fmt"

// æ–¹æ³•1: å“ˆå¸Œè¡¨ - O(n) æ—¶é—´ï¼ŒO(n) ç©ºé—´
func twoSum(nums []int, target int) []int {
    hashMap := make(map[int]int)
    
    for i, num := range nums {
        complement := target - num
        if index, found := hashMap[complement]; found {
            return []int{index, i}
        }
        hashMap[num] = i
    }
    
    return nil
}

func main() {
    nums := []int{2, 7, 11, 15}
    target := 9
    result := twoSum(nums, target)
    fmt.Printf("ç´¢å¼•: %v\n", result) // [0, 1]
}
```

**æ€è·¯**:

1. ä½¿ç”¨å“ˆå¸Œè¡¨å­˜å‚¨å·²éå†çš„æ•°å­—å’Œç´¢å¼•
2. å¯¹æ¯ä¸ªæ•°å­—ï¼ŒæŸ¥æ‰¾ `target - num` æ˜¯å¦åœ¨å“ˆå¸Œè¡¨ä¸­
3. æ‰¾åˆ°åˆ™è¿”å›ä¸¤ä¸ªç´¢å¼•

---

### 1.2 ä¸‰æ•°ä¹‹å’Œ

**LeetCode 15. 3Sum** | éš¾åº¦ï¼šä¸­ç­‰

**é—®é¢˜æè¿°**:
ç»™å®šä¸€ä¸ªæ•°ç»„ `nums`ï¼Œæ‰¾å‡ºæ‰€æœ‰å’Œä¸º 0 çš„ä¸‰å…ƒç»„ã€‚

```go
package main

import (
    "fmt"
    "sort"
)

// æ’åº + åŒæŒ‡é’ˆ - O(nÂ²) æ—¶é—´ï¼ŒO(1) ç©ºé—´
func threeSum(nums []int) [][]int {
    var result [][]int
    n := len(nums)
    
    if n < 3 {
        return result
    }
    
    // æ’åº
    sort.Ints(nums)
    
    for i := 0; i < n-2; i++ {
        // è·³è¿‡é‡å¤å…ƒç´ 
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        
        // å‰ªæï¼šå¦‚æœæœ€å°çš„ä¸‰ä¸ªæ•°ä¹‹å’Œå¤§äº0ï¼Œåé¢ä¸å¯èƒ½æœ‰è§£
        if nums[i] > 0 {
            break
        }
        
        // åŒæŒ‡é’ˆ
        left, right := i+1, n-1
        target := -nums[i]
        
        for left < right {
            sum := nums[left] + nums[right]
            
            if sum == target {
                result = append(result, []int{nums[i], nums[left], nums[right]})
                
                // è·³è¿‡é‡å¤å…ƒç´ 
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                
                left++
                right--
            } else if sum < target {
                left++
            } else {
                right--
            }
        }
    }
    
    return result
}

func main() {
    nums := []int{-1, 0, 1, 2, -1, -4}
    result := threeSum(nums)
    fmt.Println("ä¸‰æ•°ä¹‹å’Œ:", result)
}
```

**æ€è·¯**:

1. æ’åºæ•°ç»„
2. å›ºå®šç¬¬ä¸€ä¸ªæ•°ï¼Œç”¨åŒæŒ‡é’ˆæ‰¾å¦å¤–ä¸¤ä¸ªæ•°
3. æ³¨æ„å»é‡

---

### 1.3 ç››æœ€å¤šæ°´çš„å®¹å™¨

**LeetCode 11. Container With Most Water** | éš¾åº¦ï¼šä¸­ç­‰

```go
package main

import "fmt"

// åŒæŒ‡é’ˆ - O(n) æ—¶é—´ï¼ŒO(1) ç©ºé—´
func maxArea(height []int) int {
    left, right := 0, len(height)-1
    maxArea := 0
    
    for left < right {
        // è®¡ç®—å½“å‰é¢ç§¯
        h := min(height[left], height[right])
        width := right - left
        area := h * width
        maxArea = max(maxArea, area)
        
        // ç§»åŠ¨è¾ƒçŸ­çš„é‚£è¾¹
        if height[left] < height[right] {
            left++
        } else {
            right--
        }
    }
    
    return maxArea
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    height := []int{1, 8, 6, 2, 5, 4, 8, 3, 7}
    result := maxArea(height)
    fmt.Println("æœ€å¤§é¢ç§¯:", result) // 49
}
```

---

## 2. é“¾è¡¨é—®é¢˜ (Linked List)

### 2.1 åè½¬é“¾è¡¨

**LeetCode 206. Reverse Linked List** | éš¾åº¦ï¼šç®€å•

```go
package main

type ListNode struct {
    Val  int
    Next *ListNode
}

// è¿­ä»£æ³• - O(n) æ—¶é—´ï¼ŒO(1) ç©ºé—´
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    curr := head
    
    for curr != nil {
        next := curr.Next
        curr.Next = prev
        prev = curr
        curr = next
    }
    
    return prev
}

// é€’å½’æ³• - O(n) æ—¶é—´ï¼ŒO(n) ç©ºé—´
func reverseListRecursive(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    
    newHead := reverseListRecursive(head.Next)
    head.Next.Next = head
    head.Next = nil
    
    return newHead
}
```

---

### 2.2 åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨

**LeetCode 21. Merge Two Sorted Lists** | éš¾åº¦ï¼šç®€å•

```go
// è¿­ä»£æ³•
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy
    
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            current.Next = l1
            l1 = l1.Next
        } else {
            current.Next = l2
            l2 = l2.Next
        }
        current = current.Next
    }
    
    if l1 != nil {
        current.Next = l1
    }
    if l2 != nil {
        current.Next = l2
    }
    
    return dummy.Next
}

// é€’å½’æ³•
func mergeTwoListsRecursive(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    
    if l1.Val < l2.Val {
        l1.Next = mergeTwoListsRecursive(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoListsRecursive(l1, l2.Next)
        return l2
    }
}
```

---

### 2.3 ç¯å½¢é“¾è¡¨II

**LeetCode 142. Linked List Cycle II** | éš¾åº¦ï¼šä¸­ç­‰

```go
// å¿«æ…¢æŒ‡é’ˆ - O(n) æ—¶é—´ï¼ŒO(1) ç©ºé—´
func detectCycle(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return nil
    }
    
    // ç¬¬ä¸€æ­¥ï¼šåˆ¤æ–­æ˜¯å¦æœ‰ç¯
    slow, fast := head, head
    hasCycle := false
    
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        
        if slow == fast {
            hasCycle = true
            break
        }
    }
    
    if !hasCycle {
        return nil
    }
    
    // ç¬¬äºŒæ­¥ï¼šæ‰¾åˆ°ç¯çš„å…¥å£
    slow = head
    for slow != fast {
        slow = slow.Next
        fast = fast.Next
    }
    
    return slow
}
```

---

## 3. å­—ç¬¦ä¸²é—®é¢˜ (String)

### 3.1 æœ€é•¿å›æ–‡å­ä¸²

**LeetCode 5. Longest Palindromic Substring** | éš¾åº¦ï¼šä¸­ç­‰

```go
package main

import "fmt"

// ä¸­å¿ƒæ‰©å±•æ³• - O(nÂ²) æ—¶é—´ï¼ŒO(1) ç©ºé—´
func longestPalindrome(s string) string {
    if len(s) < 2 {
        return s
    }
    
    start, maxLen := 0, 1
    
    // è¾…åŠ©å‡½æ•°ï¼šä»ä¸­å¿ƒå‘ä¸¤è¾¹æ‰©å±•
    expandAroundCenter := func(left, right int) int {
        for left >= 0 && right < len(s) && s[left] == s[right] {
            left--
            right++
        }
        return right - left - 1
    }
    
    for i := 0; i < len(s); i++ {
        // å¥‡æ•°é•¿åº¦å›æ–‡
        len1 := expandAroundCenter(i, i)
        // å¶æ•°é•¿åº¦å›æ–‡
        len2 := expandAroundCenter(i, i+1)
        
        length := max(len1, len2)
        
        if length > maxLen {
            start = i - (length-1)/2
            maxLen = length
        }
    }
    
    return s[start : start+maxLen]
}

func main() {
    s := "babad"
    fmt.Println("æœ€é•¿å›æ–‡å­ä¸²:", longestPalindrome(s)) // "bab" or "aba"
}
```

---

### 3.2 å­—ç¬¦ä¸²ç›¸ä¹˜

**LeetCode 43. Multiply Strings** | éš¾åº¦ï¼šä¸­ç­‰

```go
package main

import (
    "fmt"
    "strings"
)

func multiply(num1 string, num2 string) string {
    if num1 == "0" || num2 == "0" {
        return "0"
    }
    
    m, n := len(num1), len(num2)
    result := make([]int, m+n)
    
    // ä»åå¾€å‰éå†
    for i := m - 1; i >= 0; i-- {
        for j := n - 1; j >= 0; j-- {
            mul := int(num1[i]-'0') * int(num2[j]-'0')
            p1, p2 := i+j, i+j+1
            sum := mul + result[p2]
            
            result[p2] = sum % 10
            result[p1] += sum / 10
        }
    }
    
    // è½¬æ¢ä¸ºå­—ç¬¦ä¸²
    var sb strings.Builder
    for i, digit := range result {
        if i == 0 && digit == 0 {
            continue
        }
        sb.WriteByte(byte(digit + '0'))
    }
    
    return sb.String()
}

func main() {
    fmt.Println(multiply("123", "456")) // "56088"
}
```

---

### 3.3 æœ‰æ•ˆçš„æ‹¬å·

**LeetCode 20. Valid Parentheses** | éš¾åº¦ï¼šç®€å•

```go
package main

import "fmt"

func isValid(s string) bool {
    stack := []rune{}
    pairs := map[rune]rune{
        ')': '(',
        ']': '[',
        '}': '{',
    }
    
    for _, char := range s {
        if char == '(' || char == '[' || char == '{' {
            // å·¦æ‹¬å·å…¥æ ˆ
            stack = append(stack, char)
        } else {
            // å³æ‹¬å·
            if len(stack) == 0 {
                return false
            }
            
            top := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            
            if pairs[char] != top {
                return false
            }
        }
    }
    
    return len(stack) == 0
}

func main() {
    fmt.Println(isValid("()[]{}"))   // true
    fmt.Println(isValid("([)]"))     // false
    fmt.Println(isValid("{[]}"))     // true
}
```

---

## 4. æ ‘é—®é¢˜ (Tree)

### 4.1 äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

**LeetCode 104. Maximum Depth of Binary Tree** | éš¾åº¦ï¼šç®€å•

```go
package main

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

// é€’å½’æ³• - O(n) æ—¶é—´ï¼ŒO(h) ç©ºé—´
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    
    leftDepth := maxDepth(root.Left)
    rightDepth := maxDepth(root.Right)
    
    return max(leftDepth, rightDepth) + 1
}

// BFSæ³•
func maxDepthBFS(root *TreeNode) int {
    if root == nil {
        return 0
    }
    
    queue := []*TreeNode{root}
    depth := 0
    
    for len(queue) > 0 {
        size := len(queue)
        for i := 0; i < size; i++ {
            node := queue[0]
            queue = queue[1:]
            
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
        depth++
    }
    
    return depth
}
```

---

### 4.2 éªŒè¯äºŒå‰æœç´¢æ ‘

**LeetCode 98. Validate Binary Search Tree** | éš¾åº¦ï¼šä¸­ç­‰

```go
package main

import "math"

// é€’å½’æ³• - O(n) æ—¶é—´ï¼ŒO(h) ç©ºé—´
func isValidBST(root *TreeNode) bool {
    return validate(root, math.MinInt64, math.MaxInt64)
}

func validate(node *TreeNode, min, max int) bool {
    if node == nil {
        return true
    }
    
    if node.Val <= min || node.Val >= max {
        return false
    }
    
    return validate(node.Left, min, node.Val) && 
           validate(node.Right, node.Val, max)
}

// ä¸­åºéå†æ³•
func isValidBSTInorder(root *TreeNode) bool {
    var inorder func(*TreeNode) []int
    inorder = func(node *TreeNode) []int {
        if node == nil {
            return []int{}
        }
        
        result := inorder(node.Left)
        result = append(result, node.Val)
        result = append(result, inorder(node.Right)...)
        
        return result
    }
    
    values := inorder(root)
    for i := 1; i < len(values); i++ {
        if values[i] <= values[i-1] {
            return false
        }
    }
    
    return true
}
```

---

### 4.3 äºŒå‰æ ‘çš„å³è§†å›¾

**LeetCode 199. Binary Tree Right Side View** | éš¾åº¦ï¼šä¸­ç­‰

```go
// BFSå±‚åºéå† - O(n) æ—¶é—´ï¼ŒO(w) ç©ºé—´ï¼ˆwä¸ºæ ‘çš„å®½åº¦ï¼‰
func rightSideView(root *TreeNode) []int {
    if root == nil {
        return []int{}
    }
    
    var result []int
    queue := []*TreeNode{root}
    
    for len(queue) > 0 {
        size := len(queue)
        
        for i := 0; i < size; i++ {
            node := queue[0]
            queue = queue[1:]
            
            // æ¯å±‚çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹
            if i == size-1 {
                result = append(result, node.Val)
            }
            
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
    }
    
    return result
}
```

---

## 5. åŠ¨æ€è§„åˆ’ (DP)

### 5.1 æœ€å¤§å­æ•°ç»„å’Œ

**LeetCode 53. Maximum Subarray** | éš¾åº¦ï¼šä¸­ç­‰

```go
package main

import "fmt"

// åŠ¨æ€è§„åˆ’ - O(n) æ—¶é—´ï¼ŒO(1) ç©ºé—´
func maxSubArray(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    
    maxSum := nums[0]
    currentSum := nums[0]
    
    for i := 1; i < len(nums); i++ {
        // å½“å‰å’Œå°äº0å°±é‡æ–°å¼€å§‹
        currentSum = max(nums[i], currentSum+nums[i])
        maxSum = max(maxSum, currentSum)
    }
    
    return maxSum
}

func main() {
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    fmt.Println("æœ€å¤§å­æ•°ç»„å’Œ:", maxSubArray(nums)) // 6
}
```

---

### 5.2 çˆ¬æ¥¼æ¢¯

**LeetCode 70. Climbing Stairs** | éš¾åº¦ï¼šç®€å•

```go
// åŠ¨æ€è§„åˆ’ - O(n) æ—¶é—´ï¼ŒO(1) ç©ºé—´
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }
    
    prev2, prev1 := 1, 2
    
    for i := 3; i <= n; i++ {
        current := prev1 + prev2
        prev2 = prev1
        prev1 = current
    }
    
    return prev1
}
```

---

### 5.3 é›¶é’±å…‘æ¢

**LeetCode 322. Coin Change** | éš¾åº¦ï¼šä¸­ç­‰

```go
package main

import (
    "fmt"
    "math"
)

// åŠ¨æ€è§„åˆ’ - O(amount * n) æ—¶é—´ï¼ŒO(amount) ç©ºé—´
func coinChange(coins []int, amount int) int {
    dp := make([]int, amount+1)
    
    // åˆå§‹åŒ–
    for i := 1; i <= amount; i++ {
        dp[i] = math.MaxInt32
    }
    dp[0] = 0
    
    // çŠ¶æ€è½¬ç§»
    for i := 1; i <= amount; i++ {
        for _, coin := range coins {
            if i >= coin && dp[i-coin] != math.MaxInt32 {
                dp[i] = min(dp[i], dp[i-coin]+1)
            }
        }
    }
    
    if dp[amount] == math.MaxInt32 {
        return -1
    }
    return dp[amount]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func main() {
    coins := []int{1, 2, 5}
    amount := 11
    fmt.Println("æœ€å°‘ç¡¬å¸æ•°:", coinChange(coins, amount)) // 3 (11 = 5 + 5 + 1)
}
```

---

## 6. å›æº¯é—®é¢˜ (Backtracking)

### 6.1 å…¨æ’åˆ—

**LeetCode 46. Permutations** | éš¾åº¦ï¼šä¸­ç­‰

```go
package main

import "fmt"

func permute(nums []int) [][]int {
    var result [][]int
    var backtrack func([]int)
    
    backtrack = func(path []int) {
        if len(path) == len(nums) {
            temp := make([]int, len(path))
            copy(temp, path)
            result = append(result, temp)
            return
        }
        
        for _, num := range nums {
            if contains(path, num) {
                continue
            }
            
            path = append(path, num)
            backtrack(path)
            path = path[:len(path)-1]
        }
    }
    
    backtrack([]int{})
    return result
}

func contains(arr []int, target int) bool {
    for _, v := range arr {
        if v == target {
            return true
        }
    }
    return false
}

func main() {
    nums := []int{1, 2, 3}
    result := permute(nums)
    fmt.Println("å…¨æ’åˆ—:", result)
}
```

---

### 6.2 å­é›†

**LeetCode 78. Subsets** | éš¾åº¦ï¼šä¸­ç­‰

```go
func subsets(nums []int) [][]int {
    var result [][]int
    var backtrack func(int, []int)
    
    backtrack = func(start int, path []int) {
        // æ¯æ¬¡éƒ½æ˜¯ä¸€ä¸ªæœ‰æ•ˆå­é›†
        temp := make([]int, len(path))
        copy(temp, path)
        result = append(result, temp)
        
        for i := start; i < len(nums); i++ {
            path = append(path, nums[i])
            backtrack(i+1, path)
            path = path[:len(path)-1]
        }
    }
    
    backtrack(0, []int{})
    return result
}
```

---

### 6.3 ç»„åˆæ€»å’Œ

**LeetCode 39. Combination Sum** | éš¾åº¦ï¼šä¸­ç­‰

```go
func combinationSum(candidates []int, target int) [][]int {
    var result [][]int
    var backtrack func(int, int, []int)
    
    backtrack = func(start, remain int, path []int) {
        if remain < 0 {
            return
        }
        
        if remain == 0 {
            temp := make([]int, len(path))
            copy(temp, path)
            result = append(result, temp)
            return
        }
        
        for i := start; i < len(candidates); i++ {
            path = append(path, candidates[i])
            // å› ä¸ºå¯ä»¥é‡å¤ä½¿ç”¨ï¼Œæ‰€ä»¥è¿˜æ˜¯ä»iå¼€å§‹
            backtrack(i, remain-candidates[i], path)
            path = path[:len(path)-1]
        }
    }
    
    backtrack(0, target, []int{})
    return result
}
```

---

## ğŸ’¡ è§£é¢˜æŠ€å·§æ€»ç»“

### 1. æ—¶é—´å¤æ‚åº¦é€ŸæŸ¥

| é—®é¢˜ç±»å‹ | å¸¸è§å¤æ‚åº¦ | ç®—æ³• |
|---------|-----------|------|
| æ•°ç»„éå† | O(n) | åŒæŒ‡é’ˆã€æ»‘åŠ¨çª—å£ |
| æ’åºç›¸å…³ | O(n log n) | å¿«æ’ã€å½’å¹¶ |
| äºŒåˆ†æŸ¥æ‰¾ | O(log n) | äºŒåˆ† |
| é€’å½’æ ‘ | O(2^n) | å›æº¯ã€DFS |
| åŠ¨æ€è§„åˆ’ | O(nÂ²) | DPè¡¨ |

### 2. ç©ºé—´ä¼˜åŒ–æŠ€å·§

- âœ… åŸåœ°ä¿®æ”¹ï¼ˆç››æ°´å®¹å™¨ã€åˆ é™¤å…ƒç´ ï¼‰
- âœ… æ»šåŠ¨æ•°ç»„ï¼ˆçˆ¬æ¥¼æ¢¯ã€æ–æ³¢é‚£å¥‘ï¼‰
- âœ… çŠ¶æ€å‹ç¼©ï¼ˆèƒŒåŒ…é—®é¢˜ï¼‰

### 3. å¸¸è§é™·é˜±

- âš ï¸ æ•°ç»„è¶Šç•Œ
- âš ï¸ æ•´æ•°æº¢å‡º
- âš ï¸ ç©ºæŒ‡é’ˆ
- âš ï¸ é‡å¤å…ƒç´ å¤„ç†

### 4. è°ƒè¯•æŠ€å·§

```go
// æ‰“å°è°ƒè¯•ä¿¡æ¯
fmt.Printf("Debug: i=%d, j=%d, sum=%d\n", i, j, sum)

// è¾¹ç•Œæµ‹è¯•
// ç©ºæ•°ç»„: []
// å•å…ƒç´ : [1]
// é‡å¤å…ƒç´ : [1,1,1]
// è´Ÿæ•°: [-1,-2,-3]
```

---

## ğŸ”— ç›¸å…³ç« èŠ‚

- [01-åŸºç¡€æ•°æ®ç»“æ„](01-åŸºç¡€æ•°æ®ç»“æ„.md)
- [02-å¸¸ç”¨ç®—æ³•](02-å¸¸ç”¨ç®—æ³•.md)
- [03-ç®—æ³•æ¨¡å¼](03-ç®—æ³•æ¨¡å¼.md)

---

**ç»´æŠ¤è€…**: Documentation Team  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22  
**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
