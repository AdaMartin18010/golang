# 04-实战案例

> Go语言算法实战：LeetCode经典题目解析

---

## 📚 目录

- [04-实战案例](#04-实战案例)
  - [📚 目录](#-目录)
  - [📚 章节概览](#-章节概览)
  - [1. 数组问题 (Array)](#1-数组问题-array)
    - [1.1 两数之和](#11-两数之和)
    - [1.2 三数之和](#12-三数之和)
    - [1.3 盛最多水的容器](#13-盛最多水的容器)
  - [2. 链表问题 (Linked List)](#2-链表问题-linked-list)
    - [2.1 反转链表](#21-反转链表)
    - [2.2 合并两个有序链表](#22-合并两个有序链表)
    - [2.3 环形链表II](#23-环形链表ii)
  - [3. 字符串问题 (String)](#3-字符串问题-string)
    - [3.1 最长回文子串](#31-最长回文子串)
    - [3.2 字符串相乘](#32-字符串相乘)
    - [3.3 有效的括号](#33-有效的括号)
  - [4. 树问题 (Tree)](#4-树问题-tree)
    - [4.1 二叉树的最大深度](#41-二叉树的最大深度)
    - [4.2 验证二叉搜索树](#42-验证二叉搜索树)
    - [4.3 二叉树的右视图](#43-二叉树的右视图)
  - [5. 动态规划 (DP)](#5-动态规划-dp)
    - [5.1 最大子数组和](#51-最大子数组和)
    - [5.2 爬楼梯](#52-爬楼梯)
    - [5.3 零钱兑换](#53-零钱兑换)
  - [6. 回溯问题 (Backtracking)](#6-回溯问题-backtracking)
    - [6.1 全排列](#61-全排列)
    - [6.2 子集](#62-子集)
    - [6.3 组合总和](#63-组合总和)
  - [💡 解题技巧总结](#-解题技巧总结)
    - [1. 时间复杂度速查](#1-时间复杂度速查)
    - [2. 空间优化技巧](#2-空间优化技巧)
    - [3. 常见陷阱](#3-常见陷阱)
    - [4. 调试技巧](#4-调试技巧)
  - [🔗 相关章节](#-相关章节)

## 📚 章节概览

本章精选LeetCode经典题目，提供详细的Go语言解法和解题思路，帮助你快速掌握算法面试技巧。

---

## 1. 数组问题 (Array)

### 1.1 两数之和

**LeetCode 1. Two Sum** | 难度：简单

**问题描述**:
给定一个整数数组 `nums` 和一个整数目标值 `target`，找出数组中和为目标值的两个整数，并返回它们的数组下标。

```go
package main

import "fmt"

// 方法1: 哈希表 - O(n) 时间，O(n) 空间
func twoSum(nums []int, target int) []int {
    hashMap := make(map[int]int)
    
    for i, num := range nums {
        complement := target - num
        if index, found := hashMap[complement]; found {
            return []int{index, i}
        }
        hashMap[num] = i
    }
    
    return nil
}

func main() {
    nums := []int{2, 7, 11, 15}
    target := 9
    result := twoSum(nums, target)
    fmt.Printf("索引: %v\n", result) // [0, 1]
}
```

**思路**:

1. 使用哈希表存储已遍历的数字和索引
2. 对每个数字，查找 `target - num` 是否在哈希表中
3. 找到则返回两个索引

---

### 1.2 三数之和

**LeetCode 15. 3Sum** | 难度：中等

**问题描述**:
给定一个数组 `nums`，找出所有和为 0 的三元组。

```go
package main

import (
    "fmt"
    "sort"
)

// 排序 + 双指针 - O(n²) 时间，O(1) 空间
func threeSum(nums []int) [][]int {
    var result [][]int
    n := len(nums)
    
    if n < 3 {
        return result
    }
    
    // 排序
    sort.Ints(nums)
    
    for i := 0; i < n-2; i++ {
        // 跳过重复元素
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        
        // 剪枝：如果最小的三个数之和大于0，后面不可能有解
        if nums[i] > 0 {
            break
        }
        
        // 双指针
        left, right := i+1, n-1
        target := -nums[i]
        
        for left < right {
            sum := nums[left] + nums[right]
            
            if sum == target {
                result = append(result, []int{nums[i], nums[left], nums[right]})
                
                // 跳过重复元素
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                
                left++
                right--
            } else if sum < target {
                left++
            } else {
                right--
            }
        }
    }
    
    return result
}

func main() {
    nums := []int{-1, 0, 1, 2, -1, -4}
    result := threeSum(nums)
    fmt.Println("三数之和:", result)
}
```

**思路**:

1. 排序数组
2. 固定第一个数，用双指针找另外两个数
3. 注意去重

---

### 1.3 盛最多水的容器

**LeetCode 11. Container With Most Water** | 难度：中等

```go
package main

import "fmt"

// 双指针 - O(n) 时间，O(1) 空间
func maxArea(height []int) int {
    left, right := 0, len(height)-1
    maxArea := 0
    
    for left < right {
        // 计算当前面积
        h := min(height[left], height[right])
        width := right - left
        area := h * width
        maxArea = max(maxArea, area)
        
        // 移动较短的那边
        if height[left] < height[right] {
            left++
        } else {
            right--
        }
    }
    
    return maxArea
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    height := []int{1, 8, 6, 2, 5, 4, 8, 3, 7}
    result := maxArea(height)
    fmt.Println("最大面积:", result) // 49
}
```

---

## 2. 链表问题 (Linked List)

### 2.1 反转链表

**LeetCode 206. Reverse Linked List** | 难度：简单

```go
package main

type ListNode struct {
    Val  int
    Next *ListNode
}

// 迭代法 - O(n) 时间，O(1) 空间
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    curr := head
    
    for curr != nil {
        next := curr.Next
        curr.Next = prev
        prev = curr
        curr = next
    }
    
    return prev
}

// 递归法 - O(n) 时间，O(n) 空间
func reverseListRecursive(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    
    newHead := reverseListRecursive(head.Next)
    head.Next.Next = head
    head.Next = nil
    
    return newHead
}
```

---

### 2.2 合并两个有序链表

**LeetCode 21. Merge Two Sorted Lists** | 难度：简单

```go
// 迭代法
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy
    
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            current.Next = l1
            l1 = l1.Next
        } else {
            current.Next = l2
            l2 = l2.Next
        }
        current = current.Next
    }
    
    if l1 != nil {
        current.Next = l1
    }
    if l2 != nil {
        current.Next = l2
    }
    
    return dummy.Next
}

// 递归法
func mergeTwoListsRecursive(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    
    if l1.Val < l2.Val {
        l1.Next = mergeTwoListsRecursive(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoListsRecursive(l1, l2.Next)
        return l2
    }
}
```

---

### 2.3 环形链表II

**LeetCode 142. Linked List Cycle II** | 难度：中等

```go
// 快慢指针 - O(n) 时间，O(1) 空间
func detectCycle(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return nil
    }
    
    // 第一步：判断是否有环
    slow, fast := head, head
    hasCycle := false
    
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        
        if slow == fast {
            hasCycle = true
            break
        }
    }
    
    if !hasCycle {
        return nil
    }
    
    // 第二步：找到环的入口
    slow = head
    for slow != fast {
        slow = slow.Next
        fast = fast.Next
    }
    
    return slow
}
```

---

## 3. 字符串问题 (String)

### 3.1 最长回文子串

**LeetCode 5. Longest Palindromic Substring** | 难度：中等

```go
package main

import "fmt"

// 中心扩展法 - O(n²) 时间，O(1) 空间
func longestPalindrome(s string) string {
    if len(s) < 2 {
        return s
    }
    
    start, maxLen := 0, 1
    
    // 辅助函数：从中心向两边扩展
    expandAroundCenter := func(left, right int) int {
        for left >= 0 && right < len(s) && s[left] == s[right] {
            left--
            right++
        }
        return right - left - 1
    }
    
    for i := 0; i < len(s); i++ {
        // 奇数长度回文
        len1 := expandAroundCenter(i, i)
        // 偶数长度回文
        len2 := expandAroundCenter(i, i+1)
        
        length := max(len1, len2)
        
        if length > maxLen {
            start = i - (length-1)/2
            maxLen = length
        }
    }
    
    return s[start : start+maxLen]
}

func main() {
    s := "babad"
    fmt.Println("最长回文子串:", longestPalindrome(s)) // "bab" or "aba"
}
```

---

### 3.2 字符串相乘

**LeetCode 43. Multiply Strings** | 难度：中等

```go
package main

import (
    "fmt"
    "strings"
)

func multiply(num1 string, num2 string) string {
    if num1 == "0" || num2 == "0" {
        return "0"
    }
    
    m, n := len(num1), len(num2)
    result := make([]int, m+n)
    
    // 从后往前遍历
    for i := m - 1; i >= 0; i-- {
        for j := n - 1; j >= 0; j-- {
            mul := int(num1[i]-'0') * int(num2[j]-'0')
            p1, p2 := i+j, i+j+1
            sum := mul + result[p2]
            
            result[p2] = sum % 10
            result[p1] += sum / 10
        }
    }
    
    // 转换为字符串
    var sb strings.Builder
    for i, digit := range result {
        if i == 0 && digit == 0 {
            continue
        }
        sb.WriteByte(byte(digit + '0'))
    }
    
    return sb.String()
}

func main() {
    fmt.Println(multiply("123", "456")) // "56088"
}
```

---

### 3.3 有效的括号

**LeetCode 20. Valid Parentheses** | 难度：简单

```go
package main

import "fmt"

func isValid(s string) bool {
    stack := []rune{}
    pairs := map[rune]rune{
        ')': '(',
        ']': '[',
        '}': '{',
    }
    
    for _, char := range s {
        if char == '(' || char == '[' || char == '{' {
            // 左括号入栈
            stack = append(stack, char)
        } else {
            // 右括号
            if len(stack) == 0 {
                return false
            }
            
            top := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            
            if pairs[char] != top {
                return false
            }
        }
    }
    
    return len(stack) == 0
}

func main() {
    fmt.Println(isValid("()[]{}"))   // true
    fmt.Println(isValid("([)]"))     // false
    fmt.Println(isValid("{[]}"))     // true
}
```

---

## 4. 树问题 (Tree)

### 4.1 二叉树的最大深度

**LeetCode 104. Maximum Depth of Binary Tree** | 难度：简单

```go
package main

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

// 递归法 - O(n) 时间，O(h) 空间
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    
    leftDepth := maxDepth(root.Left)
    rightDepth := maxDepth(root.Right)
    
    return max(leftDepth, rightDepth) + 1
}

// BFS法
func maxDepthBFS(root *TreeNode) int {
    if root == nil {
        return 0
    }
    
    queue := []*TreeNode{root}
    depth := 0
    
    for len(queue) > 0 {
        size := len(queue)
        for i := 0; i < size; i++ {
            node := queue[0]
            queue = queue[1:]
            
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
        depth++
    }
    
    return depth
}
```

---

### 4.2 验证二叉搜索树

**LeetCode 98. Validate Binary Search Tree** | 难度：中等

```go
package main

import "math"

// 递归法 - O(n) 时间，O(h) 空间
func isValidBST(root *TreeNode) bool {
    return validate(root, math.MinInt64, math.MaxInt64)
}

func validate(node *TreeNode, min, max int) bool {
    if node == nil {
        return true
    }
    
    if node.Val <= min || node.Val >= max {
        return false
    }
    
    return validate(node.Left, min, node.Val) && 
           validate(node.Right, node.Val, max)
}

// 中序遍历法
func isValidBSTInorder(root *TreeNode) bool {
    var inorder func(*TreeNode) []int
    inorder = func(node *TreeNode) []int {
        if node == nil {
            return []int{}
        }
        
        result := inorder(node.Left)
        result = append(result, node.Val)
        result = append(result, inorder(node.Right)...)
        
        return result
    }
    
    values := inorder(root)
    for i := 1; i < len(values); i++ {
        if values[i] <= values[i-1] {
            return false
        }
    }
    
    return true
}
```

---

### 4.3 二叉树的右视图

**LeetCode 199. Binary Tree Right Side View** | 难度：中等

```go
// BFS层序遍历 - O(n) 时间，O(w) 空间（w为树的宽度）
func rightSideView(root *TreeNode) []int {
    if root == nil {
        return []int{}
    }
    
    var result []int
    queue := []*TreeNode{root}
    
    for len(queue) > 0 {
        size := len(queue)
        
        for i := 0; i < size; i++ {
            node := queue[0]
            queue = queue[1:]
            
            // 每层的最后一个节点
            if i == size-1 {
                result = append(result, node.Val)
            }
            
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
    }
    
    return result
}
```

---

## 5. 动态规划 (DP)

### 5.1 最大子数组和

**LeetCode 53. Maximum Subarray** | 难度：中等

```go
package main

import "fmt"

// 动态规划 - O(n) 时间，O(1) 空间
func maxSubArray(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    
    maxSum := nums[0]
    currentSum := nums[0]
    
    for i := 1; i < len(nums); i++ {
        // 当前和小于0就重新开始
        currentSum = max(nums[i], currentSum+nums[i])
        maxSum = max(maxSum, currentSum)
    }
    
    return maxSum
}

func main() {
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    fmt.Println("最大子数组和:", maxSubArray(nums)) // 6
}
```

---

### 5.2 爬楼梯

**LeetCode 70. Climbing Stairs** | 难度：简单

```go
// 动态规划 - O(n) 时间，O(1) 空间
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }
    
    prev2, prev1 := 1, 2
    
    for i := 3; i <= n; i++ {
        current := prev1 + prev2
        prev2 = prev1
        prev1 = current
    }
    
    return prev1
}
```

---

### 5.3 零钱兑换

**LeetCode 322. Coin Change** | 难度：中等

```go
package main

import (
    "fmt"
    "math"
)

// 动态规划 - O(amount * n) 时间，O(amount) 空间
func coinChange(coins []int, amount int) int {
    dp := make([]int, amount+1)
    
    // 初始化
    for i := 1; i <= amount; i++ {
        dp[i] = math.MaxInt32
    }
    dp[0] = 0
    
    // 状态转移
    for i := 1; i <= amount; i++ {
        for _, coin := range coins {
            if i >= coin && dp[i-coin] != math.MaxInt32 {
                dp[i] = min(dp[i], dp[i-coin]+1)
            }
        }
    }
    
    if dp[amount] == math.MaxInt32 {
        return -1
    }
    return dp[amount]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func main() {
    coins := []int{1, 2, 5}
    amount := 11
    fmt.Println("最少硬币数:", coinChange(coins, amount)) // 3 (11 = 5 + 5 + 1)
}
```

---

## 6. 回溯问题 (Backtracking)

### 6.1 全排列

**LeetCode 46. Permutations** | 难度：中等

```go
package main

import "fmt"

func permute(nums []int) [][]int {
    var result [][]int
    var backtrack func([]int)
    
    backtrack = func(path []int) {
        if len(path) == len(nums) {
            temp := make([]int, len(path))
            copy(temp, path)
            result = append(result, temp)
            return
        }
        
        for _, num := range nums {
            if contains(path, num) {
                continue
            }
            
            path = append(path, num)
            backtrack(path)
            path = path[:len(path)-1]
        }
    }
    
    backtrack([]int{})
    return result
}

func contains(arr []int, target int) bool {
    for _, v := range arr {
        if v == target {
            return true
        }
    }
    return false
}

func main() {
    nums := []int{1, 2, 3}
    result := permute(nums)
    fmt.Println("全排列:", result)
}
```

---

### 6.2 子集

**LeetCode 78. Subsets** | 难度：中等

```go
func subsets(nums []int) [][]int {
    var result [][]int
    var backtrack func(int, []int)
    
    backtrack = func(start int, path []int) {
        // 每次都是一个有效子集
        temp := make([]int, len(path))
        copy(temp, path)
        result = append(result, temp)
        
        for i := start; i < len(nums); i++ {
            path = append(path, nums[i])
            backtrack(i+1, path)
            path = path[:len(path)-1]
        }
    }
    
    backtrack(0, []int{})
    return result
}
```

---

### 6.3 组合总和

**LeetCode 39. Combination Sum** | 难度：中等

```go
func combinationSum(candidates []int, target int) [][]int {
    var result [][]int
    var backtrack func(int, int, []int)
    
    backtrack = func(start, remain int, path []int) {
        if remain < 0 {
            return
        }
        
        if remain == 0 {
            temp := make([]int, len(path))
            copy(temp, path)
            result = append(result, temp)
            return
        }
        
        for i := start; i < len(candidates); i++ {
            path = append(path, candidates[i])
            // 因为可以重复使用，所以还是从i开始
            backtrack(i, remain-candidates[i], path)
            path = path[:len(path)-1]
        }
    }
    
    backtrack(0, target, []int{})
    return result
}
```

---

## 💡 解题技巧总结

### 1. 时间复杂度速查

| 问题类型 | 常见复杂度 | 算法 |
|---------|-----------|------|
| 数组遍历 | O(n) | 双指针、滑动窗口 |
| 排序相关 | O(n log n) | 快排、归并 |
| 二分查找 | O(log n) | 二分 |
| 递归树 | O(2^n) | 回溯、DFS |
| 动态规划 | O(n²) | DP表 |

### 2. 空间优化技巧

- ✅ 原地修改（盛水容器、删除元素）
- ✅ 滚动数组（爬楼梯、斐波那契）
- ✅ 状态压缩（背包问题）

### 3. 常见陷阱

- ⚠️ 数组越界
- ⚠️ 整数溢出
- ⚠️ 空指针
- ⚠️ 重复元素处理

### 4. 调试技巧

```go
// 打印调试信息
fmt.Printf("Debug: i=%d, j=%d, sum=%d\n", i, j, sum)

// 边界测试
// 空数组: []
// 单元素: [1]
// 重复元素: [1,1,1]
// 负数: [-1,-2,-3]
```

---

## 🔗 相关章节

- [01-基础数据结构](01-基础数据结构.md)
- [02-常用算法](02-常用算法.md)
- [03-算法模式](03-算法模式.md)

---

**维护者**: Documentation Team  
**创建日期**: 2025-10-22  
**最后更新**: 2025-10-22  
**文档状态**: ✅ 完成
