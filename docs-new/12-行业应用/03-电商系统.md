# 03-ç”µå•†ç³»ç»Ÿ

> Goè¯­è¨€ç”µå•†ç³»ç»Ÿæ¶æ„ä¸å®æˆ˜

---

## ğŸ“š ç›®å½•

- [03-ç”µå•†ç³»ç»Ÿ](#03-ç”µå•†ç³»ç»Ÿ)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [ğŸ“š ç³»ç»Ÿæ¦‚è§ˆ](#-ç³»ç»Ÿæ¦‚è§ˆ)
  - [1. ç³»ç»Ÿæ¶æ„](#1-ç³»ç»Ÿæ¶æ„)
    - [1.1 æ•´ä½“æ¶æ„](#11-æ•´ä½“æ¶æ„)
  - [2. æ ¸å¿ƒæ¨¡å—å®ç°](#2-æ ¸å¿ƒæ¨¡å—å®ç°)
    - [2.1 ç”¨æˆ·æœåŠ¡](#21-ç”¨æˆ·æœåŠ¡)
    - [2.2 å•†å“æœåŠ¡](#22-å•†å“æœåŠ¡)
    - [2.3 è®¢å•æœåŠ¡](#23-è®¢å•æœåŠ¡)
    - [2.4 æ”¯ä»˜æœåŠ¡](#24-æ”¯ä»˜æœåŠ¡)
    - [2.5 ç§’æ€æœåŠ¡](#25-ç§’æ€æœåŠ¡)
  - [3. APIæ¥å£è®¾è®¡](#3-apiæ¥å£è®¾è®¡)
    - [3.1 ç”¨æˆ·ç›¸å…³](#31-ç”¨æˆ·ç›¸å…³)
    - [3.2 å•†å“ç›¸å…³](#32-å•†å“ç›¸å…³)
    - [3.3 è®¢å•ç›¸å…³](#33-è®¢å•ç›¸å…³)
  - [4. æ€§èƒ½ä¼˜åŒ–](#4-æ€§èƒ½ä¼˜åŒ–)
    - [4.1 ç¼“å­˜ç­–ç•¥](#41-ç¼“å­˜ç­–ç•¥)
    - [4.2 æ•°æ®åº“ä¼˜åŒ–](#42-æ•°æ®åº“ä¼˜åŒ–)
    - [4.3 ç§’æ€ä¼˜åŒ–](#43-ç§’æ€ä¼˜åŒ–)
  - [ğŸ’¡ æ€»ç»“](#-æ€»ç»“)
    - [å…³é”®æŠ€æœ¯ç‚¹](#å…³é”®æŠ€æœ¯ç‚¹)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [ğŸ”— ç›¸å…³ç« èŠ‚](#-ç›¸å…³ç« èŠ‚)

## ğŸ“š ç³»ç»Ÿæ¦‚è§ˆ

æœ¬æ–‡ä»‹ç»å¦‚ä½•ä½¿ç”¨Goè¯­è¨€æ„å»ºä¸€ä¸ªå®Œæ•´çš„ç”µå•†ç³»ç»Ÿï¼ŒåŒ…æ‹¬ç”¨æˆ·ç®¡ç†ã€å•†å“ç®¡ç†ã€è®¢å•ç³»ç»Ÿã€æ”¯ä»˜ç³»ç»Ÿå’Œç§’æ€ç³»ç»Ÿç­‰æ ¸å¿ƒæ¨¡å—ã€‚

---

## 1. ç³»ç»Ÿæ¶æ„

### 1.1 æ•´ä½“æ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           è´Ÿè½½å‡è¡¡ (Nginx)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                     â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”
â”‚ APIç½‘å…³ â”‚          â”‚  CDN   â”‚
â”‚(Gin)   â”‚          â”‚        â”‚
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
    â”‚      â”‚      â”‚      â”‚      â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”â”Œâ”€â”€â–¼â”€â”€â”â”Œâ”€â”€â–¼â”€â”€â”â”Œâ”€â”€â–¼â”€â”€â”â”Œâ”€â–¼â”€â”€â”
â”‚ç”¨æˆ·  â”‚â”‚å•†å“ â”‚â”‚è®¢å• â”‚â”‚æ”¯ä»˜ â”‚â”‚ç§’æ€â”‚
â”‚æœåŠ¡  â”‚â”‚æœåŠ¡ â”‚â”‚æœåŠ¡ â”‚â”‚æœåŠ¡ â”‚â”‚æœåŠ¡â”‚
â””â”€â”€â”€â”¬â”€â”€â”˜â””â”€â”€â”¬â”€â”€â”˜â””â”€â”€â”¬â”€â”€â”˜â””â”€â”€â”¬â”€â”€â”˜â””â”€â”¬â”€â”€â”˜
    â”‚      â”‚      â”‚      â”‚     â”‚
    â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
           â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
    â”‚             â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
â”‚MySQL â”‚    â”‚  Redis  â”‚
â””â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. æ ¸å¿ƒæ¨¡å—å®ç°

### 2.1 ç”¨æˆ·æœåŠ¡

```go
package user

import (
    "context"
    "errors"
    "golang.org/x/crypto/bcrypt"
)

// User ç”¨æˆ·æ¨¡å‹
type User struct {
    ID        int64  `json:"id"`
    Username  string `json:"username"`
    Email     string `json:"email"`
    Password  string `json:"-"` // ä¸è¿”å›å¯†ç 
    Phone     string `json:"phone"`
    Avatar    string `json:"avatar"`
    CreatedAt int64  `json:"created_at"`
}

// UserService ç”¨æˆ·æœåŠ¡
type UserService struct {
    repo UserRepository
}

// Register ç”¨æˆ·æ³¨å†Œ
func (s *UserService) Register(ctx context.Context, username, email, password string) (*User, error) {
    // 1. éªŒè¯ç”¨æˆ·æ˜¯å¦å­˜åœ¨
    exists, err := s.repo.ExistsByUsername(ctx, username)
    if err != nil {
        return nil, err
    }
    if exists {
        return nil, errors.New("username already exists")
    }
    
    // 2. åŠ å¯†å¯†ç 
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return nil, err
    }
    
    // 3. åˆ›å»ºç”¨æˆ·
    user := &User{
        Username: username,
        Email:    email,
        Password: string(hashedPassword),
    }
    
    if err := s.repo.Create(ctx, user); err != nil {
        return nil, err
    }
    
    return user, nil
}

// Login ç”¨æˆ·ç™»å½•
func (s *UserService) Login(ctx context.Context, username, password string) (string, error) {
    // 1. æŸ¥æ‰¾ç”¨æˆ·
    user, err := s.repo.FindByUsername(ctx, username)
    if err != nil {
        return "", errors.New("invalid username or password")
    }
    
    // 2. éªŒè¯å¯†ç 
    if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password)); err != nil {
        return "", errors.New("invalid username or password")
    }
    
    // 3. ç”ŸæˆJWT token
    token, err := generateJWT(user.ID)
    if err != nil {
        return "", err
    }
    
    return token, nil
}
```

### 2.2 å•†å“æœåŠ¡

```go
package product

import (
    "context"
    "errors"
)

// Product å•†å“æ¨¡å‹
type Product struct {
    ID          int64   `json:"id"`
    Name        string  `json:"name"`
    Description string  `json:"description"`
    Price       float64 `json:"price"`
    Stock       int     `json:"stock"`
    Category    string  `json:"category"`
    Images      []string `json:"images"`
    Status      int     `json:"status"` // 1-ä¸Šæ¶, 2-ä¸‹æ¶
    CreatedAt   int64   `json:"created_at"`
}

// ProductService å•†å“æœåŠ¡
type ProductService struct {
    repo  ProductRepository
    cache CacheService
}

// GetProduct è·å–å•†å“è¯¦æƒ…ï¼ˆå¸¦ç¼“å­˜ï¼‰
func (s *ProductService) GetProduct(ctx context.Context, id int64) (*Product, error) {
    // 1. å°è¯•ä»ç¼“å­˜è·å–
    product, err := s.cache.Get(ctx, productCacheKey(id))
    if err == nil {
        return product, nil
    }
    
    // 2. ä»æ•°æ®åº“æŸ¥è¯¢
    product, err = s.repo.FindByID(ctx, id)
    if err != nil {
        return nil, err
    }
    
    // 3. å†™å…¥ç¼“å­˜
    _ = s.cache.Set(ctx, productCacheKey(id), product, 3600)
    
    return product, nil
}

// ListProducts å•†å“åˆ—è¡¨ï¼ˆåˆ†é¡µ+ç­›é€‰ï¼‰
func (s *ProductService) ListProducts(ctx context.Context, req *ListProductsRequest) (*ListProductsResponse, error) {
    products, total, err := s.repo.List(ctx, req)
    if err != nil {
        return nil, err
    }
    
    return &ListProductsResponse{
        Products: products,
        Total:    total,
        Page:     req.Page,
        PageSize: req.PageSize,
    }, nil
}

// DeductStock æ‰£å‡åº“å­˜ï¼ˆåŸå­æ“ä½œï¼‰
func (s *ProductService) DeductStock(ctx context.Context, productID int64, quantity int) error {
    affected, err := s.repo.DeductStock(ctx, productID, quantity)
    if err != nil {
        return err
    }
    
    if affected == 0 {
        return errors.New("insufficient stock")
    }
    
    // åˆ é™¤ç¼“å­˜
    _ = s.cache.Delete(ctx, productCacheKey(productID))
    
    return nil
}
```

### 2.3 è®¢å•æœåŠ¡

```go
package order

import (
    "context"
    "errors"
    "fmt"
    "time"
)

// Order è®¢å•æ¨¡å‹
type Order struct {
    ID         int64        `json:"id"`
    OrderNo    string       `json:"order_no"`
    UserID     int64        `json:"user_id"`
    TotalPrice float64      `json:"total_price"`
    Status     int          `json:"status"` // 1-å¾…æ”¯ä»˜, 2-å·²æ”¯ä»˜, 3-å·²å‘è´§, 4-å·²å®Œæˆ, 5-å·²å–æ¶ˆ
    Items      []OrderItem  `json:"items"`
    CreatedAt  int64        `json:"created_at"`
}

// OrderItem è®¢å•é¡¹
type OrderItem struct {
    ProductID   int64   `json:"product_id"`
    ProductName string  `json:"product_name"`
    Price       float64 `json:"price"`
    Quantity    int     `json:"quantity"`
}

// OrderService è®¢å•æœåŠ¡
type OrderService struct {
    repo           OrderRepository
    productService *ProductService
    paymentService *PaymentService
}

// CreateOrder åˆ›å»ºè®¢å•
func (s *OrderService) CreateOrder(ctx context.Context, userID int64, items []OrderItem) (*Order, error) {
    // 1. éªŒè¯å•†å“å’Œåº“å­˜
    var totalPrice float64
    for i := range items {
        product, err := s.productService.GetProduct(ctx, items[i].ProductID)
        if err != nil {
            return nil, err
        }
        
        if product.Stock < items[i].Quantity {
            return nil, fmt.Errorf("product %s stock insufficient", product.Name)
        }
        
        items[i].ProductName = product.Name
        items[i].Price = product.Price
        totalPrice += product.Price * float64(items[i].Quantity)
    }
    
    // 2. åˆ›å»ºè®¢å•
    order := &Order{
        OrderNo:    generateOrderNo(),
        UserID:     userID,
        TotalPrice: totalPrice,
        Status:     OrderStatusPending,
        Items:      items,
        CreatedAt:  time.Now().Unix(),
    }
    
    // 3. ä½¿ç”¨äº‹åŠ¡
    tx, err := s.repo.BeginTx(ctx)
    if err != nil {
        return nil, err
    }
    defer tx.Rollback()
    
    // 4. ä¿å­˜è®¢å•
    if err := s.repo.CreateWithTx(ctx, tx, order); err != nil {
        return nil, err
    }
    
    // 5. æ‰£å‡åº“å­˜
    for _, item := range items {
        if err := s.productService.DeductStock(ctx, item.ProductID, item.Quantity); err != nil {
            return nil, err
        }
    }
    
    // 6. æäº¤äº‹åŠ¡
    if err := tx.Commit(); err != nil {
        return nil, err
    }
    
    return order, nil
}

// ç”Ÿæˆè®¢å•å·
func generateOrderNo() string {
    return fmt.Sprintf("ORD%d", time.Now().UnixNano())
}
```

### 2.4 æ”¯ä»˜æœåŠ¡

```go
package payment

import (
    "context"
    "crypto/md5"
    "encoding/hex"
    "fmt"
)

// Payment æ”¯ä»˜è®°å½•
type Payment struct {
    ID          int64   `json:"id"`
    OrderID     int64   `json:"order_id"`
    Amount      float64 `json:"amount"`
    Method      string  `json:"method"` // alipay, wechat
    Status      int     `json:"status"` // 1-å¾…æ”¯ä»˜, 2-æ”¯ä»˜æˆåŠŸ, 3-æ”¯ä»˜å¤±è´¥
    TradeNo     string  `json:"trade_no"`
    CreatedAt   int64   `json:"created_at"`
}

// PaymentService æ”¯ä»˜æœåŠ¡
type PaymentService struct {
    repo         PaymentRepository
    orderService *OrderService
}

// CreatePayment åˆ›å»ºæ”¯ä»˜
func (s *PaymentService) CreatePayment(ctx context.Context, orderID int64, method string) (*Payment, error) {
    // 1. è·å–è®¢å•ä¿¡æ¯
    order, err := s.orderService.GetOrder(ctx, orderID)
    if err != nil {
        return nil, err
    }
    
    if order.Status != OrderStatusPending {
        return nil, errors.New("order status invalid")
    }
    
    // 2. åˆ›å»ºæ”¯ä»˜è®°å½•
    payment := &Payment{
        OrderID:   orderID,
        Amount:    order.TotalPrice,
        Method:    method,
        Status:    PaymentStatusPending,
        CreatedAt: time.Now().Unix(),
    }
    
    if err := s.repo.Create(ctx, payment); err != nil {
        return nil, err
    }
    
    return payment, nil
}

// ProcessCallback å¤„ç†æ”¯ä»˜å›è°ƒ
func (s *PaymentService) ProcessCallback(ctx context.Context, tradeNo string, status int) error {
    // 1. éªŒè¯ç­¾å
    if !s.verifySign(tradeNo) {
        return errors.New("invalid sign")
    }
    
    // 2. æ›´æ–°æ”¯ä»˜çŠ¶æ€
    payment, err := s.repo.FindByTradeNo(ctx, tradeNo)
    if err != nil {
        return err
    }
    
    if err := s.repo.UpdateStatus(ctx, payment.ID, status); err != nil {
        return err
    }
    
    // 3. æ›´æ–°è®¢å•çŠ¶æ€
    if status == PaymentStatusSuccess {
        return s.orderService.UpdateStatus(ctx, payment.OrderID, OrderStatusPaid)
    }
    
    return nil
}

// éªŒè¯ç­¾å
func (s *PaymentService) verifySign(tradeNo string) bool {
    // å®é™…å®ç°ä¸­éœ€è¦éªŒè¯ç¬¬ä¸‰æ–¹æ”¯ä»˜å¹³å°çš„ç­¾å
    return true
}
```

### 2.5 ç§’æ€æœåŠ¡

```go
package seckill

import (
    "context"
    "errors"
    "fmt"
    "time"
    
    "github.com/go-redis/redis/v8"
)

// SeckillService ç§’æ€æœåŠ¡
type SeckillService struct {
    redis          *redis.Client
    productService *ProductService
    orderService   *OrderService
}

// StartSeckill å¼€å§‹ç§’æ€
func (s *SeckillService) StartSeckill(ctx context.Context, productID int64, userID int64) error {
    // 1. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²ç»å‚ä¸
    participateKey := fmt.Sprintf("seckill:participate:%d:%d", productID, userID)
    exists, err := s.redis.Exists(ctx, participateKey).Result()
    if err != nil {
        return err
    }
    if exists > 0 {
        return errors.New("already participated")
    }
    
    // 2. ä½¿ç”¨Luaè„šæœ¬ä¿è¯åŸå­æ€§
    script := `
        local stock = redis.call('GET', KEYS[1])
        if not stock then
            return -1
        end
        if tonumber(stock) <= 0 then
            return 0
        end
        redis.call('DECR', KEYS[1])
        return 1
    `
    
    stockKey := fmt.Sprintf("seckill:stock:%d", productID)
    result, err := s.redis.Eval(ctx, script, []string{stockKey}).Int()
    if err != nil {
        return err
    }
    
    switch result {
    case -1:
        return errors.New("product not found")
    case 0:
        return errors.New("sold out")
    case 1:
        // 3. æ ‡è®°ç”¨æˆ·å·²å‚ä¸
        s.redis.SetEX(ctx, participateKey, 1, 24*time.Hour)
        
        // 4. å¼‚æ­¥åˆ›å»ºè®¢å•
        go s.createSeckillOrder(productID, userID)
        
        return nil
    default:
        return errors.New("unknown error")
    }
}

// åˆ›å»ºç§’æ€è®¢å•
func (s *SeckillService) createSeckillOrder(productID, userID int64) {
    ctx := context.Background()
    
    items := []OrderItem{
        {
            ProductID: productID,
            Quantity:  1,
        },
    }
    
    _, err := s.orderService.CreateOrder(ctx, userID, items)
    if err != nil {
        // è®°å½•æ—¥å¿—ï¼Œå›æ»šåº“å­˜
        fmt.Printf("create seckill order failed: %v\n", err)
    }
}
```

---

## 3. APIæ¥å£è®¾è®¡

### 3.1 ç”¨æˆ·ç›¸å…³

```go
package api

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

// ç”¨æˆ·æ³¨å†Œ
// POST /api/v1/users/register
func (h *UserHandler) Register(c *gin.Context) {
    var req RegisterRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, ErrorResponse(err))
        return
    }
    
    user, err := h.service.Register(c.Request.Context(), req.Username, req.Email, req.Password)
    if err != nil {
        c.JSON(http.StatusInternalServerError, ErrorResponse(err))
        return
    }
    
    c.JSON(http.StatusOK, SuccessResponse(user))
}

// ç”¨æˆ·ç™»å½•
// POST /api/v1/users/login
func (h *UserHandler) Login(c *gin.Context) {
    var req LoginRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, ErrorResponse(err))
        return
    }
    
    token, err := h.service.Login(c.Request.Context(), req.Username, req.Password)
    if err != nil {
        c.JSON(http.StatusUnauthorized, ErrorResponse(err))
        return
    }
    
    c.JSON(http.StatusOK, SuccessResponse(gin.H{"token": token}))
}
```

### 3.2 å•†å“ç›¸å…³

```go
// å•†å“åˆ—è¡¨
// GET /api/v1/products
func (h *ProductHandler) List(c *gin.Context) {
    var req ListProductsRequest
    if err := c.ShouldBindQuery(&req); err != nil {
        c.JSON(http.StatusBadRequest, ErrorResponse(err))
        return
    }
    
    resp, err := h.service.ListProducts(c.Request.Context(), &req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, ErrorResponse(err))
        return
    }
    
    c.JSON(http.StatusOK, SuccessResponse(resp))
}

// å•†å“è¯¦æƒ…
// GET /api/v1/products/:id
func (h *ProductHandler) GetDetail(c *gin.Context) {
    id := c.Param("id")
    productID, err := strconv.ParseInt(id, 10, 64)
    if err != nil {
        c.JSON(http.StatusBadRequest, ErrorResponse(err))
        return
    }
    
    product, err := h.service.GetProduct(c.Request.Context(), productID)
    if err != nil {
        c.JSON(http.StatusNotFound, ErrorResponse(err))
        return
    }
    
    c.JSON(http.StatusOK, SuccessResponse(product))
}
```

### 3.3 è®¢å•ç›¸å…³

```go
// åˆ›å»ºè®¢å•
// POST /api/v1/orders
func (h *OrderHandler) Create(c *gin.Context) {
    var req CreateOrderRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, ErrorResponse(err))
        return
    }
    
    userID := c.GetInt64("user_id") // ä»JWTä¸­è·å–
    
    order, err := h.service.CreateOrder(c.Request.Context(), userID, req.Items)
    if err != nil {
        c.JSON(http.StatusInternalServerError, ErrorResponse(err))
        return
    }
    
    c.JSON(http.StatusOK, SuccessResponse(order))
}

// è®¢å•åˆ—è¡¨
// GET /api/v1/orders
func (h *OrderHandler) List(c *gin.Context) {
    userID := c.GetInt64("user_id")
    
    orders, err := h.service.ListOrders(c.Request.Context(), userID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, ErrorResponse(err))
        return
    }
    
    c.JSON(http.StatusOK, SuccessResponse(orders))
}
```

---

## 4. æ€§èƒ½ä¼˜åŒ–

### 4.1 ç¼“å­˜ç­–ç•¥

- **å•†å“ä¿¡æ¯**: Redisç¼“å­˜ï¼Œè¿‡æœŸæ—¶é—´1å°æ—¶
- **ç”¨æˆ·ä¿¡æ¯**: Redisç¼“å­˜ï¼Œè¿‡æœŸæ—¶é—´30åˆ†é’Ÿ
- **çƒ­ç‚¹å•†å“**: æœ¬åœ°ç¼“å­˜+RedisäºŒçº§ç¼“å­˜

### 4.2 æ•°æ®åº“ä¼˜åŒ–

- **è¯»å†™åˆ†ç¦»**: ä¸»ä»å¤åˆ¶ï¼Œè¯»æ“ä½œèµ°ä»åº“
- **åˆ†åº“åˆ†è¡¨**: è®¢å•è¡¨æŒ‰ç”¨æˆ·IDåˆ†ç‰‡
- **ç´¢å¼•ä¼˜åŒ–**: åˆç†åˆ›å»ºç´¢å¼•ï¼Œé¿å…å…¨è¡¨æ‰«æ

### 4.3 ç§’æ€ä¼˜åŒ–

- **Redisé¢„å‡åº“å­˜**: å‡å°‘æ•°æ®åº“å‹åŠ›
- **æ¶ˆæ¯é˜Ÿåˆ—å¼‚æ­¥ä¸‹å•**: å‰Šå³°å¡«è°·
- **é™æµ**: ä»¤ç‰Œæ¡¶ç®—æ³•é™åˆ¶è¯·æ±‚é€Ÿç‡

---

## ğŸ’¡ æ€»ç»“

### å…³é”®æŠ€æœ¯ç‚¹

| æŠ€æœ¯ | åº”ç”¨åœºæ™¯ |
|------|---------|
| Gin | APIæ¡†æ¶ |
| MySQL | æŒä¹…åŒ–å­˜å‚¨ |
| Redis | ç¼“å­˜+ç§’æ€ |
| JWT | ç”¨æˆ·è®¤è¯ |
| åˆ†å¸ƒå¼é” | åº“å­˜æ‰£å‡ |
| æ¶ˆæ¯é˜Ÿåˆ— | å¼‚æ­¥å¤„ç† |

### æœ€ä½³å®è·µ

1. âœ… ä½¿ç”¨äº‹åŠ¡ä¿è¯æ•°æ®ä¸€è‡´æ€§
2. âœ… åˆç†ä½¿ç”¨ç¼“å­˜æå‡æ€§èƒ½
3. âœ… å¼‚æ­¥å¤„ç†éæ ¸å¿ƒæµç¨‹
4. âœ… åšå¥½é™æµå’Œé™çº§
5. âœ… å®Œå–„çš„ç›‘æ§å’Œæ—¥å¿—

---

## ğŸ”— ç›¸å…³ç« èŠ‚

- [01-é‡‘èç§‘æŠ€-FinTech](01-é‡‘èç§‘æŠ€-FinTech.md)
- [02-æ¸¸æˆå¼€å‘](02-æ¸¸æˆå¼€å‘.md)
- [03-Webå¼€å‘](../03-Webå¼€å‘/README.md)
- [05-å¾®æœåŠ¡æ¶æ„](../05-å¾®æœåŠ¡æ¶æ„/README.md)

---

**ç»´æŠ¤è€…**: Documentation Team  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22  
**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
