# 03-电商系统

> Go语言电商系统架构与实战

---

## 📚 目录

- [03-电商系统](#03-电商系统)
  - [📚 目录](#-目录)
  - [📚 系统概览](#-系统概览)
  - [1. 系统架构](#1-系统架构)
    - [1.1 整体架构](#11-整体架构)
  - [2. 核心模块实现](#2-核心模块实现)
    - [2.1 用户服务](#21-用户服务)
    - [2.2 商品服务](#22-商品服务)
    - [2.3 订单服务](#23-订单服务)
    - [2.4 支付服务](#24-支付服务)
    - [2.5 秒杀服务](#25-秒杀服务)
  - [3. API接口设计](#3-api接口设计)
    - [3.1 用户相关](#31-用户相关)
    - [3.2 商品相关](#32-商品相关)
    - [3.3 订单相关](#33-订单相关)
  - [4. 性能优化](#4-性能优化)
    - [4.1 缓存策略](#41-缓存策略)
    - [4.2 数据库优化](#42-数据库优化)
    - [4.3 秒杀优化](#43-秒杀优化)
  - [💡 总结](#-总结)
    - [关键技术点](#关键技术点)
    - [最佳实践](#最佳实践)
  - [🔗 相关章节](#-相关章节)

## 📚 系统概览

本文介绍如何使用Go语言构建一个完整的电商系统，包括用户管理、商品管理、订单系统、支付系统和秒杀系统等核心模块。

---

## 1. 系统架构

### 1.1 整体架构

```text
┌─────────────────────────────────────────┐
│           负载均衡 (Nginx)               │
└──────────────┬──────────────────────────┘
               │
    ┌──────────┴──────────┐
    │                     │
┌───▼────┐           ┌───▼────┐
│ API网关 │          │  CDN   │
│(Gin)   │          │        │
└───┬────┘          └────────┘
    │
    ├──────┬──────┬──────┬──────┐
    │      │      │      │      │
┌───▼──┐┌──▼──┐┌──▼──┐┌──▼──┐┌─▼──┐
│用户  ││商品 ││订单 ││支付 ││秒杀│
│服务  ││服务 ││服务 ││服务 ││服务│
└───┬──┘└──┬──┘└──┬──┘└──┬──┘└─┬──┘
    │      │      │      │     │
    └──────┴──────┴──────┴─────┘
           │
    ┌──────┴──────┐
    │             │
┌───▼──┐    ┌────▼────┐
│MySQL │    │  Redis  │
└──────┘    └─────────┘
```

---

## 2. 核心模块实现

### 2.1 用户服务

```go
package user

import (
    "context"
    "errors"
    "golang.org/x/crypto/bcrypt"
)

// User 用户模型
type User struct {
    ID        int64  `json:"id"`
    Username  string `json:"username"`
    Email     string `json:"email"`
    Password  string `json:"-"` // 不返回密码
    Phone     string `json:"phone"`
    Avatar    string `json:"avatar"`
    CreatedAt int64  `json:"created_at"`
}

// UserService 用户服务
type UserService struct {
    repo UserRepository
}

// Register 用户注册
func (s *UserService) Register(ctx context.Context, username, email, password string) (*User, error) {
    // 1. 验证用户是否存在
    exists, err := s.repo.ExistsByUsername(ctx, username)
    if err != nil {
        return nil, err
    }
    if exists {
        return nil, errors.New("username already exists")
    }
    
    // 2. 加密密码
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return nil, err
    }
    
    // 3. 创建用户
    user := &User{
        Username: username,
        Email:    email,
        Password: string(hashedPassword),
    }
    
    if err := s.repo.Create(ctx, user); err != nil {
        return nil, err
    }
    
    return user, nil
}

// Login 用户登录
func (s *UserService) Login(ctx context.Context, username, password string) (string, error) {
    // 1. 查找用户
    user, err := s.repo.FindByUsername(ctx, username)
    if err != nil {
        return "", errors.New("invalid username or password")
    }
    
    // 2. 验证密码
    if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password)); err != nil {
        return "", errors.New("invalid username or password")
    }
    
    // 3. 生成JWT token
    token, err := generateJWT(user.ID)
    if err != nil {
        return "", err
    }
    
    return token, nil
}
```

### 2.2 商品服务

```go
package product

import (
    "context"
    "errors"
)

// Product 商品模型
type Product struct {
    ID          int64   `json:"id"`
    Name        string  `json:"name"`
    Description string  `json:"description"`
    Price       float64 `json:"price"`
    Stock       int     `json:"stock"`
    Category    string  `json:"category"`
    Images      []string `json:"images"`
    Status      int     `json:"status"` // 1-上架, 2-下架
    CreatedAt   int64   `json:"created_at"`
}

// ProductService 商品服务
type ProductService struct {
    repo  ProductRepository
    cache CacheService
}

// GetProduct 获取商品详情（带缓存）
func (s *ProductService) GetProduct(ctx context.Context, id int64) (*Product, error) {
    // 1. 尝试从缓存获取
    product, err := s.cache.Get(ctx, productCacheKey(id))
    if err == nil {
        return product, nil
    }
    
    // 2. 从数据库查询
    product, err = s.repo.FindByID(ctx, id)
    if err != nil {
        return nil, err
    }
    
    // 3. 写入缓存
    _ = s.cache.Set(ctx, productCacheKey(id), product, 3600)
    
    return product, nil
}

// ListProducts 商品列表（分页+筛选）
func (s *ProductService) ListProducts(ctx context.Context, req *ListProductsRequest) (*ListProductsResponse, error) {
    products, total, err := s.repo.List(ctx, req)
    if err != nil {
        return nil, err
    }
    
    return &ListProductsResponse{
        Products: products,
        Total:    total,
        Page:     req.Page,
        PageSize: req.PageSize,
    }, nil
}

// DeductStock 扣减库存（原子操作）
func (s *ProductService) DeductStock(ctx context.Context, productID int64, quantity int) error {
    affected, err := s.repo.DeductStock(ctx, productID, quantity)
    if err != nil {
        return err
    }
    
    if affected == 0 {
        return errors.New("insufficient stock")
    }
    
    // 删除缓存
    _ = s.cache.Delete(ctx, productCacheKey(productID))
    
    return nil
}
```

### 2.3 订单服务

```go
package order

import (
    "context"
    "errors"
    "fmt"
    "time"
)

// Order 订单模型
type Order struct {
    ID         int64        `json:"id"`
    OrderNo    string       `json:"order_no"`
    UserID     int64        `json:"user_id"`
    TotalPrice float64      `json:"total_price"`
    Status     int          `json:"status"` // 1-待支付, 2-已支付, 3-已发货, 4-已完成, 5-已取消
    Items      []OrderItem  `json:"items"`
    CreatedAt  int64        `json:"created_at"`
}

// OrderItem 订单项
type OrderItem struct {
    ProductID   int64   `json:"product_id"`
    ProductName string  `json:"product_name"`
    Price       float64 `json:"price"`
    Quantity    int     `json:"quantity"`
}

// OrderService 订单服务
type OrderService struct {
    repo           OrderRepository
    productService *ProductService
    paymentService *PaymentService
}

// CreateOrder 创建订单
func (s *OrderService) CreateOrder(ctx context.Context, userID int64, items []OrderItem) (*Order, error) {
    // 1. 验证商品和库存
    var totalPrice float64
    for i := range items {
        product, err := s.productService.GetProduct(ctx, items[i].ProductID)
        if err != nil {
            return nil, err
        }
        
        if product.Stock < items[i].Quantity {
            return nil, fmt.Errorf("product %s stock insufficient", product.Name)
        }
        
        items[i].ProductName = product.Name
        items[i].Price = product.Price
        totalPrice += product.Price * float64(items[i].Quantity)
    }
    
    // 2. 创建订单
    order := &Order{
        OrderNo:    generateOrderNo(),
        UserID:     userID,
        TotalPrice: totalPrice,
        Status:     OrderStatusPending,
        Items:      items,
        CreatedAt:  time.Now().Unix(),
    }
    
    // 3. 使用事务
    tx, err := s.repo.BeginTx(ctx)
    if err != nil {
        return nil, err
    }
    defer tx.Rollback()
    
    // 4. 保存订单
    if err := s.repo.CreateWithTx(ctx, tx, order); err != nil {
        return nil, err
    }
    
    // 5. 扣减库存
    for _, item := range items {
        if err := s.productService.DeductStock(ctx, item.ProductID, item.Quantity); err != nil {
            return nil, err
        }
    }
    
    // 6. 提交事务
    if err := tx.Commit(); err != nil {
        return nil, err
    }
    
    return order, nil
}

// 生成订单号
func generateOrderNo() string {
    return fmt.Sprintf("ORD%d", time.Now().UnixNano())
}
```

### 2.4 支付服务

```go
package payment

import (
    "context"
    "crypto/md5"
    "encoding/hex"
    "fmt"
)

// Payment 支付记录
type Payment struct {
    ID          int64   `json:"id"`
    OrderID     int64   `json:"order_id"`
    Amount      float64 `json:"amount"`
    Method      string  `json:"method"` // alipay, wechat
    Status      int     `json:"status"` // 1-待支付, 2-支付成功, 3-支付失败
    TradeNo     string  `json:"trade_no"`
    CreatedAt   int64   `json:"created_at"`
}

// PaymentService 支付服务
type PaymentService struct {
    repo         PaymentRepository
    orderService *OrderService
}

// CreatePayment 创建支付
func (s *PaymentService) CreatePayment(ctx context.Context, orderID int64, method string) (*Payment, error) {
    // 1. 获取订单信息
    order, err := s.orderService.GetOrder(ctx, orderID)
    if err != nil {
        return nil, err
    }
    
    if order.Status != OrderStatusPending {
        return nil, errors.New("order status invalid")
    }
    
    // 2. 创建支付记录
    payment := &Payment{
        OrderID:   orderID,
        Amount:    order.TotalPrice,
        Method:    method,
        Status:    PaymentStatusPending,
        CreatedAt: time.Now().Unix(),
    }
    
    if err := s.repo.Create(ctx, payment); err != nil {
        return nil, err
    }
    
    return payment, nil
}

// ProcessCallback 处理支付回调
func (s *PaymentService) ProcessCallback(ctx context.Context, tradeNo string, status int) error {
    // 1. 验证签名
    if !s.verifySign(tradeNo) {
        return errors.New("invalid sign")
    }
    
    // 2. 更新支付状态
    payment, err := s.repo.FindByTradeNo(ctx, tradeNo)
    if err != nil {
        return err
    }
    
    if err := s.repo.UpdateStatus(ctx, payment.ID, status); err != nil {
        return err
    }
    
    // 3. 更新订单状态
    if status == PaymentStatusSuccess {
        return s.orderService.UpdateStatus(ctx, payment.OrderID, OrderStatusPaid)
    }
    
    return nil
}

// 验证签名
func (s *PaymentService) verifySign(tradeNo string) bool {
    // 实际实现中需要验证第三方支付平台的签名
    return true
}
```

### 2.5 秒杀服务

```go
package seckill

import (
    "context"
    "errors"
    "fmt"
    "time"
    
    "github.com/go-redis/redis/v8"
)

// SeckillService 秒杀服务
type SeckillService struct {
    redis          *redis.Client
    productService *ProductService
    orderService   *OrderService
}

// StartSeckill 开始秒杀
func (s *SeckillService) StartSeckill(ctx context.Context, productID int64, userID int64) error {
    // 1. 检查用户是否已经参与
    participateKey := fmt.Sprintf("seckill:participate:%d:%d", productID, userID)
    exists, err := s.redis.Exists(ctx, participateKey).Result()
    if err != nil {
        return err
    }
    if exists > 0 {
        return errors.New("already participated")
    }
    
    // 2. 使用Lua脚本保证原子性
    script := `
        local stock = redis.call('GET', KEYS[1])
        if not stock then
            return -1
        end
        if tonumber(stock) <= 0 then
            return 0
        end
        redis.call('DECR', KEYS[1])
        return 1
    `
    
    stockKey := fmt.Sprintf("seckill:stock:%d", productID)
    result, err := s.redis.Eval(ctx, script, []string{stockKey}).Int()
    if err != nil {
        return err
    }
    
    switch result {
    case -1:
        return errors.New("product not found")
    case 0:
        return errors.New("sold out")
    case 1:
        // 3. 标记用户已参与
        s.redis.SetEX(ctx, participateKey, 1, 24*time.Hour)
        
        // 4. 异步创建订单
        go s.createSeckillOrder(productID, userID)
        
        return nil
    default:
        return errors.New("unknown error")
    }
}

// 创建秒杀订单
func (s *SeckillService) createSeckillOrder(productID, userID int64) {
    ctx := context.Background()
    
    items := []OrderItem{
        {
            ProductID: productID,
            Quantity:  1,
        },
    }
    
    _, err := s.orderService.CreateOrder(ctx, userID, items)
    if err != nil {
        // 记录日志，回滚库存
        fmt.Printf("create seckill order failed: %v\n", err)
    }
}
```

---

## 3. API接口设计

### 3.1 用户相关

```go
package api

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

// 用户注册
// POST /api/v1/users/register
func (h *UserHandler) Register(c *gin.Context) {
    var req RegisterRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, ErrorResponse(err))
        return
    }
    
    user, err := h.service.Register(c.Request.Context(), req.Username, req.Email, req.Password)
    if err != nil {
        c.JSON(http.StatusInternalServerError, ErrorResponse(err))
        return
    }
    
    c.JSON(http.StatusOK, SuccessResponse(user))
}

// 用户登录
// POST /api/v1/users/login
func (h *UserHandler) Login(c *gin.Context) {
    var req LoginRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, ErrorResponse(err))
        return
    }
    
    token, err := h.service.Login(c.Request.Context(), req.Username, req.Password)
    if err != nil {
        c.JSON(http.StatusUnauthorized, ErrorResponse(err))
        return
    }
    
    c.JSON(http.StatusOK, SuccessResponse(gin.H{"token": token}))
}
```

### 3.2 商品相关

```go
// 商品列表
// GET /api/v1/products
func (h *ProductHandler) List(c *gin.Context) {
    var req ListProductsRequest
    if err := c.ShouldBindQuery(&req); err != nil {
        c.JSON(http.StatusBadRequest, ErrorResponse(err))
        return
    }
    
    resp, err := h.service.ListProducts(c.Request.Context(), &req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, ErrorResponse(err))
        return
    }
    
    c.JSON(http.StatusOK, SuccessResponse(resp))
}

// 商品详情
// GET /api/v1/products/:id
func (h *ProductHandler) GetDetail(c *gin.Context) {
    id := c.Param("id")
    productID, err := strconv.ParseInt(id, 10, 64)
    if err != nil {
        c.JSON(http.StatusBadRequest, ErrorResponse(err))
        return
    }
    
    product, err := h.service.GetProduct(c.Request.Context(), productID)
    if err != nil {
        c.JSON(http.StatusNotFound, ErrorResponse(err))
        return
    }
    
    c.JSON(http.StatusOK, SuccessResponse(product))
}
```

### 3.3 订单相关

```go
// 创建订单
// POST /api/v1/orders
func (h *OrderHandler) Create(c *gin.Context) {
    var req CreateOrderRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, ErrorResponse(err))
        return
    }
    
    userID := c.GetInt64("user_id") // 从JWT中获取
    
    order, err := h.service.CreateOrder(c.Request.Context(), userID, req.Items)
    if err != nil {
        c.JSON(http.StatusInternalServerError, ErrorResponse(err))
        return
    }
    
    c.JSON(http.StatusOK, SuccessResponse(order))
}

// 订单列表
// GET /api/v1/orders
func (h *OrderHandler) List(c *gin.Context) {
    userID := c.GetInt64("user_id")
    
    orders, err := h.service.ListOrders(c.Request.Context(), userID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, ErrorResponse(err))
        return
    }
    
    c.JSON(http.StatusOK, SuccessResponse(orders))
}
```

---

## 4. 性能优化

### 4.1 缓存策略

- **商品信息**: Redis缓存，过期时间1小时
- **用户信息**: Redis缓存，过期时间30分钟
- **热点商品**: 本地缓存+Redis二级缓存

### 4.2 数据库优化

- **读写分离**: 主从复制，读操作走从库
- **分库分表**: 订单表按用户ID分片
- **索引优化**: 合理创建索引，避免全表扫描

### 4.3 秒杀优化

- **Redis预减库存**: 减少数据库压力
- **消息队列异步下单**: 削峰填谷
- **限流**: 令牌桶算法限制请求速率

---

## 💡 总结

### 关键技术点

| 技术 | 应用场景 |
|------|---------|
| Gin | API框架 |
| MySQL | 持久化存储 |
| Redis | 缓存+秒杀 |
| JWT | 用户认证 |
| 分布式锁 | 库存扣减 |
| 消息队列 | 异步处理 |

### 最佳实践

1. ✅ 使用事务保证数据一致性
2. ✅ 合理使用缓存提升性能
3. ✅ 异步处理非核心流程
4. ✅ 做好限流和降级
5. ✅ 完善的监控和日志

---

## 🔗 相关章节

- [01-金融科技-FinTech](01-金融科技-FinTech.md)
- [02-游戏开发](02-游戏开发.md)
- [03-Web开发](../03-Web开发/README.md)
- [05-微服务架构](../05-微服务架构/README.md)

---

**维护者**: Documentation Team  
**创建日期**: 2025-10-22  
**最后更新**: 2025-10-22  
**文档状态**: ✅ 完成
