# é‡‘èç³»ç»Ÿ - Go è¯­è¨€å®æˆ˜

> ä½¿ç”¨ Go è¯­è¨€æ„å»ºé«˜æ€§èƒ½ã€é«˜å¯ç”¨çš„é‡‘èäº¤æ˜“ç³»ç»Ÿ

---

## ğŸ“‹ ç›®å½•

- [é‡‘èç³»ç»Ÿ - Go è¯­è¨€å®æˆ˜](#é‡‘èç³»ç»Ÿ---go-è¯­è¨€å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ç³»ç»Ÿæ¦‚è¿°](#ç³»ç»Ÿæ¦‚è¿°)
    - [ä¸šåŠ¡åœºæ™¯](#ä¸šåŠ¡åœºæ™¯)
    - [Go è¯­è¨€ä¼˜åŠ¿](#go-è¯­è¨€ä¼˜åŠ¿)
  - [æ ¸å¿ƒä¸šåŠ¡æ¨¡å—](#æ ¸å¿ƒä¸šåŠ¡æ¨¡å—)
    - [ç³»ç»Ÿæ¶æ„å›¾](#ç³»ç»Ÿæ¶æ„å›¾)
      - [é‡‘èç³»ç»Ÿæ¶æ„å¯è§†åŒ–](#é‡‘èç³»ç»Ÿæ¶æ„å¯è§†åŒ–)
      - [äº¤æ˜“æµç¨‹æ—¶åºå›¾](#äº¤æ˜“æµç¨‹æ—¶åºå›¾)
  - [è´¦æˆ·ç®¡ç†ç³»ç»Ÿ](#è´¦æˆ·ç®¡ç†ç³»ç»Ÿ)
    - [è´¦æˆ·æ•°æ®æ¨¡å‹](#è´¦æˆ·æ•°æ®æ¨¡å‹)
    - [è´¦æˆ·æœåŠ¡å®ç°](#è´¦æˆ·æœåŠ¡å®ç°)
  - [äº¤æ˜“ç³»ç»Ÿ](#äº¤æ˜“ç³»ç»Ÿ)
    - [è®¢å•æ¨¡å‹](#è®¢å•æ¨¡å‹)
    - [æ’®åˆå¼•æ“](#æ’®åˆå¼•æ“)
  - [æ”¯ä»˜æ¸…ç®—ç³»ç»Ÿ](#æ”¯ä»˜æ¸…ç®—ç³»ç»Ÿ)
    - [æ”¯ä»˜æœåŠ¡](#æ”¯ä»˜æœåŠ¡)
  - [é£æ§ç³»ç»Ÿ](#é£æ§ç³»ç»Ÿ)
    - [é£æ§è§„åˆ™å¼•æ“](#é£æ§è§„åˆ™å¼•æ“)
  - [å®æ—¶è¡Œæƒ…ç³»ç»Ÿ](#å®æ—¶è¡Œæƒ…ç³»ç»Ÿ)
    - [è¡Œæƒ…æ•°æ®æ¨é€](#è¡Œæƒ…æ•°æ®æ¨é€)
  - [æ•°æ®ä¸€è‡´æ€§ä¿è¯](#æ•°æ®ä¸€è‡´æ€§ä¿è¯)
    - [åˆ†å¸ƒå¼äº‹åŠ¡ - Saga æ¨¡å¼](#åˆ†å¸ƒå¼äº‹åŠ¡---saga-æ¨¡å¼)
  - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
    - [æ•°æ®åº“ä¼˜åŒ–](#æ•°æ®åº“ä¼˜åŒ–)
    - [Redis ç¼“å­˜ç­–ç•¥](#redis-ç¼“å­˜ç­–ç•¥)
  - [å®‰å…¨åŠ å›º](#å®‰å…¨åŠ å›º)
    - [åŠ å¯†å­˜å‚¨](#åŠ å¯†å­˜å‚¨)
  - [ç›‘æ§ä¸è¿ç»´](#ç›‘æ§ä¸è¿ç»´)
    - [Prometheus ç›‘æ§](#prometheus-ç›‘æ§)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [1. é‡‘é¢å¤„ç†](#1-é‡‘é¢å¤„ç†)
    - [2. å¹‚ç­‰æ€§è®¾è®¡](#2-å¹‚ç­‰æ€§è®¾è®¡)
    - [3. æ•°æ®åº“äº‹åŠ¡](#3-æ•°æ®åº“äº‹åŠ¡)
  - [æ€»ç»“](#æ€»ç»“)

---

## ç³»ç»Ÿæ¦‚è¿°

### ä¸šåŠ¡åœºæ™¯

é‡‘èç³»ç»Ÿæ˜¯å¯¹æ€§èƒ½ã€å®‰å…¨æ€§ã€å¯é æ€§è¦æ±‚æé«˜çš„ç³»ç»Ÿï¼Œä¸»è¦åŒ…æ‹¬ï¼š

- **è¯åˆ¸äº¤æ˜“ç³»ç»Ÿ**: è‚¡ç¥¨ã€åŸºé‡‘ã€æœŸè´§äº¤æ˜“
- **é“¶è¡Œç³»ç»Ÿ**: å­˜æ¬¾ã€è´·æ¬¾ã€è½¬è´¦ã€æ”¯ä»˜
- **æ”¯ä»˜ç³»ç»Ÿ**: ç¬¬ä¸‰æ–¹æ”¯ä»˜ã€æ¸…ç®—ç»“ç®—
- **é£æ§ç³»ç»Ÿ**: åæ¬ºè¯ˆã€åæ´—é’±ã€ä¿¡ç”¨è¯„ä¼°

### Go è¯­è¨€ä¼˜åŠ¿

```text
âœ… é«˜å¹¶å‘å¤„ç†èƒ½åŠ› (goroutine)
âœ… å‡ºè‰²çš„æ€§èƒ½è¡¨ç°
âœ… å†…ç½®å¹¶å‘å®‰å…¨æœºåˆ¶
âœ… ç®€æ´çš„é”™è¯¯å¤„ç†
âœ… ä¸°å¯Œçš„æ ‡å‡†åº“
âœ… å¿«é€Ÿçš„ç¼–è¯‘éƒ¨ç½²
```

---

## æ ¸å¿ƒä¸šåŠ¡æ¨¡å—

### ç³»ç»Ÿæ¶æ„å›¾

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    API Gateway (ç½‘å…³å±‚)                  â”‚
â”‚              èº«ä»½è®¤è¯ | é™æµ | è·¯ç”± | æ—¥å¿—                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â†“                 â†“                 â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   è´¦æˆ·ç®¡ç†æœåŠ¡    â”‚ â”‚  äº¤æ˜“æœåŠ¡     â”‚ â”‚  æ”¯ä»˜æœåŠ¡     â”‚
â”‚  - å¼€æˆ·/é”€æˆ·     â”‚ â”‚  - ä¸‹å•       â”‚ â”‚  - å……å€¼/æç°  â”‚
â”‚  - å®åè®¤è¯      â”‚ â”‚  - æ’®åˆ       â”‚ â”‚  - è½¬è´¦       â”‚
â”‚  - èµ„é‡‘æŸ¥è¯¢      â”‚ â”‚  - æˆäº¤       â”‚ â”‚  - æ¸…ç®—       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                 â”‚                 â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚   é£æ§æœåŠ¡      â”‚
                   â”‚  - å®æ—¶ç›‘æ§     â”‚
                   â”‚  - é£é™©è¯„ä¼°     â”‚
                   â”‚  - å¼‚å¸¸æ‹¦æˆª     â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â†“                 â†“                 â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   MySQL é›†ç¾¤     â”‚ â”‚  Redis é›†ç¾¤   â”‚ â”‚  Kafka é›†ç¾¤   â”‚
â”‚  - è´¦æˆ·æ•°æ®      â”‚ â”‚  - ç¼“å­˜       â”‚ â”‚  - æ¶ˆæ¯é˜Ÿåˆ—   â”‚
â”‚  - äº¤æ˜“è®°å½•      â”‚ â”‚  - åˆ†å¸ƒå¼é”   â”‚ â”‚  - äº‹ä»¶æº¯æº   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### é‡‘èç³»ç»Ÿæ¶æ„å¯è§†åŒ–

```mermaid
graph TB
    subgraph "ç”¨æˆ·å±‚"
        Web[ğŸ’» Webç«¯]
        Mobile[ğŸ“± ç§»åŠ¨ç«¯]
        API_Client[ğŸ”Œ APIå®¢æˆ·ç«¯]
    end
    
    subgraph "ç½‘å…³å±‚"
        Gateway[ğŸŒ API Gateway<br/>JWTè®¤è¯ + é™æµ + è·¯ç”±]
    end
    
    subgraph "ä¸šåŠ¡æœåŠ¡å±‚"
        AccountSvc[ğŸ‘¤ è´¦æˆ·ç®¡ç†æœåŠ¡<br/>å¼€æˆ·/é”€æˆ·/å®åè®¤è¯]
        TradeSvc[ğŸ“ˆ äº¤æ˜“æœåŠ¡<br/>ä¸‹å•/æ’®åˆ/æˆäº¤]
        PaymentSvc[ğŸ’³ æ”¯ä»˜æœåŠ¡<br/>å……å€¼/æç°/è½¬è´¦]
    end
    
    subgraph "é£æ§å±‚"
        RiskSvc[ğŸ›¡ï¸ é£æ§æœåŠ¡<br/>å®æ—¶ç›‘æ§/é£é™©è¯„ä¼°/å¼‚å¸¸æ‹¦æˆª]
    end
    
    subgraph "æ•°æ®å­˜å‚¨å±‚"
        MySQL[(ğŸ—„ï¸ MySQLé›†ç¾¤<br/>è´¦æˆ·/äº¤æ˜“æ•°æ®)]
        Redis[(âš¡ Redisé›†ç¾¤<br/>ç¼“å­˜/åˆ†å¸ƒå¼é”)]
        Kafka[(ğŸ“Š Kafkaé›†ç¾¤<br/>æ¶ˆæ¯é˜Ÿåˆ—/äº‹ä»¶æº¯æº)]
    end
    
    subgraph "ç›‘æ§å±‚"
        Prometheus[ğŸ“ˆ Prometheus]
        Grafana[ğŸ“Š Grafana]
    end
    
    Web --> Gateway
    Mobile --> Gateway
    API_Client --> Gateway
    
    Gateway --> AccountSvc
    Gateway --> TradeSvc
    Gateway --> PaymentSvc
    
    AccountSvc -.é£æ§æ£€æŸ¥.-> RiskSvc
    TradeSvc -.é£æ§æ£€æŸ¥.-> RiskSvc
    PaymentSvc -.é£æ§æ£€æŸ¥.-> RiskSvc
    
    AccountSvc --> MySQL
    TradeSvc --> MySQL
    PaymentSvc --> MySQL
    
    AccountSvc --> Redis
    TradeSvc --> Redis
    PaymentSvc --> Redis
    
    TradeSvc --> Kafka
    PaymentSvc --> Kafka
    
    AccountSvc -.æŒ‡æ ‡.-> Prometheus
    TradeSvc -.æŒ‡æ ‡.-> Prometheus
    PaymentSvc -.æŒ‡æ ‡.-> Prometheus
    RiskSvc -.æŒ‡æ ‡.-> Prometheus
    
    Prometheus --> Grafana
    
    style Gateway fill:#ffe1e1
    style AccountSvc fill:#e1ffe1
    style TradeSvc fill:#e1ffe1
    style PaymentSvc fill:#e1ffe1
    style RiskSvc fill:#fff4e1
    style MySQL fill:#e1f5ff
    style Redis fill:#e1f5ff
    style Kafka fill:#e1f5ff
    style Prometheus fill:#f5e1ff
```

#### äº¤æ˜“æµç¨‹æ—¶åºå›¾

```mermaid
sequenceDiagram
    participant User as ğŸ‘¤ ç”¨æˆ·
    participant GW as ğŸŒ API Gateway
    participant Trade as ğŸ“ˆ äº¤æ˜“æœåŠ¡
    participant Risk as ğŸ›¡ï¸ é£æ§æœåŠ¡
    participant Account as ğŸ‘¤ è´¦æˆ·æœåŠ¡
    participant DB as ğŸ—„ï¸ MySQL
    participant Cache as âš¡ Redis
    participant MQ as ğŸ“Š Kafka
    
    Note over User,MQ: è‚¡ç¥¨äº¤æ˜“å®Œæ•´æµç¨‹
    
    User->>GW: æäº¤ä¹°å•<br/>(è‚¡ç¥¨ä»£ç /æ•°é‡/ä»·æ ¼)
    GW->>GW: JWTéªŒè¯
    GW->>GW: é™æµæ£€æŸ¥
    
    GW->>Trade: åˆ›å»ºè®¢å•
    
    rect rgb(250, 230, 220)
        Note over Trade,Risk: é£æ§æ£€æŸ¥
        Trade->>Risk: é£é™©è¯„ä¼°è¯·æ±‚
        Risk->>Risk: æ£€æŸ¥ç”¨æˆ·ä¿¡ç”¨
        Risk->>Risk: æ£€æŸ¥äº¤æ˜“é™é¢
        Risk->>Risk: å¼‚å¸¸è¡Œä¸ºæ£€æµ‹
        Risk-->>Trade: é£æ§é€šè¿‡
    end
    
    rect rgb(220, 230, 250)
        Note over Trade,Account: èµ„é‡‘å†»ç»“
        Trade->>Account: å†»ç»“èµ„é‡‘
        Account->>DB: æ›´æ–°è´¦æˆ·ä½™é¢
        Account->>Cache: æ›´æ–°ç¼“å­˜
        Account-->>Trade: å†»ç»“æˆåŠŸ
    end
    
    Trade->>Trade: è®¢å•æ’®åˆå¼•æ“
    Trade->>DB: ä¿å­˜è®¢å•è®°å½•
    Trade->>MQ: å‘å¸ƒè®¢å•äº‹ä»¶
    
    Trade-->>GW: è®¢å•åˆ›å»ºæˆåŠŸ
    GW-->>User: è¿”å›è®¢å•ID
    
    Note over MQ: å¼‚æ­¥å¤„ç†:<br/>è¡Œæƒ…æ¨é€/æ¸…ç®—/å¯¹è´¦
```

---

## è´¦æˆ·ç®¡ç†ç³»ç»Ÿ

### è´¦æˆ·æ•°æ®æ¨¡å‹

```go
package account

import (
    "time"
    "github.com/shopspring/decimal"
)

// Account è´¦æˆ·å®ä½“
type Account struct {
    ID            int64           `json:"id" db:"id"`
    UserID        int64           `json:"user_id" db:"user_id"`
    AccountNo     string          `json:"account_no" db:"account_no"`      // è´¦å·
    AccountType   AccountType     `json:"account_type" db:"account_type"`  // è´¦æˆ·ç±»å‹
    Currency      string          `json:"currency" db:"currency"`          // å¸ç§
    Balance       decimal.Decimal `json:"balance" db:"balance"`            // ä½™é¢
    FrozenAmount  decimal.Decimal `json:"frozen_amount" db:"frozen_amount"` // å†»ç»“é‡‘é¢
    Status        AccountStatus   `json:"status" db:"status"`
    CreatedAt     time.Time       `json:"created_at" db:"created_at"`
    UpdatedAt     time.Time       `json:"updated_at" db:"updated_at"`
}

// AccountType è´¦æˆ·ç±»å‹
type AccountType int

const (
    AccountTypeSavings   AccountType = 1 // å‚¨è“„è´¦æˆ·
    AccountTypeChecking  AccountType = 2 // æ”¯ç¥¨è´¦æˆ·
    AccountTypeInvestment AccountType = 3 // æŠ•èµ„è´¦æˆ·
)

// AccountStatus è´¦æˆ·çŠ¶æ€
type AccountStatus int

const (
    AccountStatusActive   AccountStatus = 1 // æ­£å¸¸
    AccountStatusFrozen   AccountStatus = 2 // å†»ç»“
    AccountStatusClosed   AccountStatus = 3 // å…³é—­
)

// BalanceChange ä½™é¢å˜åŠ¨è®°å½•
type BalanceChange struct {
    ID            int64           `json:"id" db:"id"`
    AccountID     int64           `json:"account_id" db:"account_id"`
    TransactionID string          `json:"transaction_id" db:"transaction_id"`
    ChangeType    ChangeType      `json:"change_type" db:"change_type"`
    Amount        decimal.Decimal `json:"amount" db:"amount"`
    BalanceBefore decimal.Decimal `json:"balance_before" db:"balance_before"`
    BalanceAfter  decimal.Decimal `json:"balance_after" db:"balance_after"`
    Remark        string          `json:"remark" db:"remark"`
    CreatedAt     time.Time       `json:"created_at" db:"created_at"`
}

// ChangeType å˜åŠ¨ç±»å‹
type ChangeType int

const (
    ChangeTypeDeposit    ChangeType = 1  // å­˜å…¥
    ChangeTypeWithdraw   ChangeType = 2  // å–å‡º
    ChangeTypeFreeze     ChangeType = 3  // å†»ç»“
    ChangeTypeUnfreeze   ChangeType = 4  // è§£å†»
    ChangeTypeTransferIn ChangeType = 5  // è½¬å…¥
    ChangeTypeTransferOut ChangeType = 6 // è½¬å‡º
)
```

### è´¦æˆ·æœåŠ¡å®ç°

```go
package account

import (
    "context"
    "database/sql"
    "errors"
    "github.com/shopspring/decimal"
)

var (
    ErrAccountNotFound     = errors.New("è´¦æˆ·ä¸å­˜åœ¨")
    ErrInsufficientBalance = errors.New("ä½™é¢ä¸è¶³")
    ErrAccountFrozen       = errors.New("è´¦æˆ·å·²å†»ç»“")
)

// Service è´¦æˆ·æœåŠ¡
type Service struct {
    db *sql.DB
}

// NewService åˆ›å»ºè´¦æˆ·æœåŠ¡
func NewService(db *sql.DB) *Service {
    return &Service{db: db}
}

// CreateAccount åˆ›å»ºè´¦æˆ·
func (s *Service) CreateAccount(ctx context.Context, userID int64, accountType AccountType, currency string) (*Account, error) {
    // ç”Ÿæˆè´¦å·
    accountNo := generateAccountNo()
    
    account := &Account{
        UserID:      userID,
        AccountNo:   accountNo,
        AccountType: accountType,
        Currency:    currency,
        Balance:     decimal.Zero,
        FrozenAmount: decimal.Zero,
        Status:      AccountStatusActive,
    }
    
    query := `
        INSERT INTO accounts (user_id, account_no, account_type, currency, balance, frozen_amount, status, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
    `
    
    result, err := s.db.ExecContext(ctx, query,
        account.UserID, account.AccountNo, account.AccountType, account.Currency,
        account.Balance, account.FrozenAmount, account.Status,
    )
    if err != nil {
        return nil, err
    }
    
    id, _ := result.LastInsertId()
    account.ID = id
    
    return account, nil
}

// GetBalance è·å–è´¦æˆ·ä½™é¢
func (s *Service) GetBalance(ctx context.Context, accountID int64) (decimal.Decimal, error) {
    var balance decimal.Decimal
    
    query := `SELECT balance FROM accounts WHERE id = ? AND status = ?`
    err := s.db.QueryRowContext(ctx, query, accountID, AccountStatusActive).Scan(&balance)
    if err == sql.ErrNoRows {
        return decimal.Zero, ErrAccountNotFound
    }
    if err != nil {
        return decimal.Zero, err
    }
    
    return balance, nil
}

// Deposit å­˜æ¬¾
func (s *Service) Deposit(ctx context.Context, accountID int64, amount decimal.Decimal, transactionID, remark string) error {
    if amount.LessThanOrEqual(decimal.Zero) {
        return errors.New("é‡‘é¢å¿…é¡»å¤§äº0")
    }
    
    // å¼€å¯äº‹åŠ¡
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    // é”å®šè´¦æˆ·è®°å½•
    var account Account
    query := `SELECT id, balance, status FROM accounts WHERE id = ? FOR UPDATE`
    err = tx.QueryRowContext(ctx, query, accountID).Scan(&account.ID, &account.Balance, &account.Status)
    if err == sql.ErrNoRows {
        return ErrAccountNotFound
    }
    if err != nil {
        return err
    }
    
    // æ£€æŸ¥è´¦æˆ·çŠ¶æ€
    if account.Status != AccountStatusActive {
        return ErrAccountFrozen
    }
    
    // æ›´æ–°ä½™é¢
    newBalance := account.Balance.Add(amount)
    updateQuery := `UPDATE accounts SET balance = ?, updated_at = NOW() WHERE id = ?`
    _, err = tx.ExecContext(ctx, updateQuery, newBalance, accountID)
    if err != nil {
        return err
    }
    
    // è®°å½•ä½™é¢å˜åŠ¨
    changeQuery := `
        INSERT INTO balance_changes (account_id, transaction_id, change_type, amount, balance_before, balance_after, remark, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, NOW())
    `
    _, err = tx.ExecContext(ctx, changeQuery,
        accountID, transactionID, ChangeTypeDeposit, amount, account.Balance, newBalance, remark,
    )
    if err != nil {
        return err
    }
    
    return tx.Commit()
}

// Withdraw å–æ¬¾
func (s *Service) Withdraw(ctx context.Context, accountID int64, amount decimal.Decimal, transactionID, remark string) error {
    if amount.LessThanOrEqual(decimal.Zero) {
        return errors.New("é‡‘é¢å¿…é¡»å¤§äº0")
    }
    
    // å¼€å¯äº‹åŠ¡
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    // é”å®šè´¦æˆ·è®°å½•
    var account Account
    query := `SELECT id, balance, frozen_amount, status FROM accounts WHERE id = ? FOR UPDATE`
    err = tx.QueryRowContext(ctx, query, accountID).Scan(&account.ID, &account.Balance, &account.FrozenAmount, &account.Status)
    if err == sql.ErrNoRows {
        return ErrAccountNotFound
    }
    if err != nil {
        return err
    }
    
    // æ£€æŸ¥è´¦æˆ·çŠ¶æ€
    if account.Status != AccountStatusActive {
        return ErrAccountFrozen
    }
    
    // æ£€æŸ¥å¯ç”¨ä½™é¢
    availableBalance := account.Balance.Sub(account.FrozenAmount)
    if availableBalance.LessThan(amount) {
        return ErrInsufficientBalance
    }
    
    // æ›´æ–°ä½™é¢
    newBalance := account.Balance.Sub(amount)
    updateQuery := `UPDATE accounts SET balance = ?, updated_at = NOW() WHERE id = ?`
    _, err = tx.ExecContext(ctx, updateQuery, newBalance, accountID)
    if err != nil {
        return err
    }
    
    // è®°å½•ä½™é¢å˜åŠ¨
    changeQuery := `
        INSERT INTO balance_changes (account_id, transaction_id, change_type, amount, balance_before, balance_after, remark, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, NOW())
    `
    _, err = tx.ExecContext(ctx, changeQuery,
        accountID, transactionID, ChangeTypeWithdraw, amount, account.Balance, newBalance, remark,
    )
    if err != nil {
        return err
    }
    
    return tx.Commit()
}

// Transfer è½¬è´¦
func (s *Service) Transfer(ctx context.Context, fromAccountID, toAccountID int64, amount decimal.Decimal, transactionID, remark string) error {
    if amount.LessThanOrEqual(decimal.Zero) {
        return errors.New("é‡‘é¢å¿…é¡»å¤§äº0")
    }
    
    if fromAccountID == toAccountID {
        return errors.New("ä¸èƒ½å‘è‡ªå·±è½¬è´¦")
    }
    
    // å¼€å¯äº‹åŠ¡
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    // é”å®šä¸¤ä¸ªè´¦æˆ·ï¼ˆæŒ‰IDé¡ºåºé”å®šï¼Œé¿å…æ­»é”ï¼‰
    ids := []int64{fromAccountID, toAccountID}
    if ids[0] > ids[1] {
        ids[0], ids[1] = ids[1], ids[0]
    }
    
    accounts := make(map[int64]*Account)
    for _, id := range ids {
        var account Account
        query := `SELECT id, balance, frozen_amount, status FROM accounts WHERE id = ? FOR UPDATE`
        err = tx.QueryRowContext(ctx, query, id).Scan(&account.ID, &account.Balance, &account.FrozenAmount, &account.Status)
        if err == sql.ErrNoRows {
            return ErrAccountNotFound
        }
        if err != nil {
            return err
        }
        accounts[id] = &account
    }
    
    fromAccount := accounts[fromAccountID]
    toAccount := accounts[toAccountID]
    
    // æ£€æŸ¥è´¦æˆ·çŠ¶æ€
    if fromAccount.Status != AccountStatusActive || toAccount.Status != AccountStatusActive {
        return ErrAccountFrozen
    }
    
    // æ£€æŸ¥ä»˜æ¬¾æ–¹å¯ç”¨ä½™é¢
    availableBalance := fromAccount.Balance.Sub(fromAccount.FrozenAmount)
    if availableBalance.LessThan(amount) {
        return ErrInsufficientBalance
    }
    
    // æ›´æ–°ä»˜æ¬¾æ–¹ä½™é¢
    fromNewBalance := fromAccount.Balance.Sub(amount)
    updateQuery := `UPDATE accounts SET balance = ?, updated_at = NOW() WHERE id = ?`
    _, err = tx.ExecContext(ctx, updateQuery, fromNewBalance, fromAccountID)
    if err != nil {
        return err
    }
    
    // æ›´æ–°æ”¶æ¬¾æ–¹ä½™é¢
    toNewBalance := toAccount.Balance.Add(amount)
    _, err = tx.ExecContext(ctx, updateQuery, toNewBalance, toAccountID)
    if err != nil {
        return err
    }
    
    // è®°å½•ä»˜æ¬¾æ–¹ä½™é¢å˜åŠ¨
    changeQuery := `
        INSERT INTO balance_changes (account_id, transaction_id, change_type, amount, balance_before, balance_after, remark, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, NOW())
    `
    _, err = tx.ExecContext(ctx, changeQuery,
        fromAccountID, transactionID, ChangeTypeTransferOut, amount, fromAccount.Balance, fromNewBalance, remark,
    )
    if err != nil {
        return err
    }
    
    // è®°å½•æ”¶æ¬¾æ–¹ä½™é¢å˜åŠ¨
    _, err = tx.ExecContext(ctx, changeQuery,
        toAccountID, transactionID, ChangeTypeTransferIn, amount, toAccount.Balance, toNewBalance, remark,
    )
    if err != nil {
        return err
    }
    
    return tx.Commit()
}

// generateAccountNo ç”Ÿæˆè´¦å·
func generateAccountNo() string {
    // å®é™…åº”ç”¨ä¸­åº”ä½¿ç”¨æ›´å¤æ‚çš„è§„åˆ™
    // ä¾‹å¦‚ï¼šé“¶è¡Œä»£ç (4ä½) + åˆ†è¡Œä»£ç (4ä½) + é¡ºåºå·(8ä½) + æ ¡éªŒä½(1ä½)
    return "6222" + "0001" + "12345678" + "9"
}
```

---

## äº¤æ˜“ç³»ç»Ÿ

### è®¢å•æ¨¡å‹

```go
package trading

import (
    "time"
    "github.com/shopspring/decimal"
)

// Order è®¢å•
type Order struct {
    ID            int64           `json:"id" db:"id"`
    OrderNo       string          `json:"order_no" db:"order_no"`
    UserID        int64           `json:"user_id" db:"user_id"`
    Symbol        string          `json:"symbol" db:"symbol"`          // äº¤æ˜“å¯¹ å¦‚: BTCUSDT
    OrderType     OrderType       `json:"order_type" db:"order_type"`  // è®¢å•ç±»å‹
    Side          OrderSide       `json:"side" db:"side"`              // ä¹°å–æ–¹å‘
    Price         decimal.Decimal `json:"price" db:"price"`            // ä»·æ ¼
    Quantity      decimal.Decimal `json:"quantity" db:"quantity"`      // æ•°é‡
    FilledQty     decimal.Decimal `json:"filled_qty" db:"filled_qty"`  // å·²æˆäº¤æ•°é‡
    Amount        decimal.Decimal `json:"amount" db:"amount"`          // é‡‘é¢
    Status        OrderStatus     `json:"status" db:"status"`
    CreatedAt     time.Time       `json:"created_at" db:"created_at"`
    UpdatedAt     time.Time       `json:"updated_at" db:"updated_at"`
}

// OrderType è®¢å•ç±»å‹
type OrderType int

const (
    OrderTypeLimit  OrderType = 1 // é™ä»·å•
    OrderTypeMarket OrderType = 2 // å¸‚ä»·å•
)

// OrderSide ä¹°å–æ–¹å‘
type OrderSide int

const (
    OrderSideBuy  OrderSide = 1 // ä¹°å…¥
    OrderSideSell OrderSide = 2 // å–å‡º
)

// OrderStatus è®¢å•çŠ¶æ€
type OrderStatus int

const (
    OrderStatusPending   OrderStatus = 1 // å¾…æˆäº¤
    OrderStatusPartial   OrderStatus = 2 // éƒ¨åˆ†æˆäº¤
    OrderStatusFilled    OrderStatus = 3 // å®Œå…¨æˆäº¤
    OrderStatusCancelled OrderStatus = 4 // å·²å–æ¶ˆ
)

// Trade æˆäº¤è®°å½•
type Trade struct {
    ID          int64           `json:"id" db:"id"`
    TradeNo     string          `json:"trade_no" db:"trade_no"`
    BuyOrderID  int64           `json:"buy_order_id" db:"buy_order_id"`
    SellOrderID int64           `json:"sell_order_id" db:"sell_order_id"`
    Symbol      string          `json:"symbol" db:"symbol"`
    Price       decimal.Decimal `json:"price" db:"price"`
    Quantity    decimal.Decimal `json:"quantity" db:"quantity"`
    Amount      decimal.Decimal `json:"amount" db:"amount"`
    CreatedAt   time.Time       `json:"created_at" db:"created_at"`
}
```

### æ’®åˆå¼•æ“

```go
package matching

import (
    "container/heap"
    "sync"
    "github.com/shopspring/decimal"
)

// MatchingEngine æ’®åˆå¼•æ“
type MatchingEngine struct {
    symbol    string
    buyBook   *OrderBook  // ä¹°å•ç°¿
    sellBook  *OrderBook  // å–å•ç°¿
    mu        sync.RWMutex
    tradeChan chan *Trade // æˆäº¤é€šçŸ¥
}

// NewMatchingEngine åˆ›å»ºæ’®åˆå¼•æ“
func NewMatchingEngine(symbol string) *MatchingEngine {
    return &MatchingEngine{
        symbol:    symbol,
        buyBook:   NewOrderBook(true),  // ä¹°å•æŒ‰ä»·æ ¼ä»é«˜åˆ°ä½
        sellBook:  NewOrderBook(false), // å–å•æŒ‰ä»·æ ¼ä»ä½åˆ°é«˜
        tradeChan: make(chan *Trade, 100),
    }
}

// AddOrder æ·»åŠ è®¢å•
func (e *MatchingEngine) AddOrder(order *Order) []*Trade {
    e.mu.Lock()
    defer e.mu.Unlock()
    
    var trades []*Trade
    
    // å¸‚ä»·å•ç«‹å³æ’®åˆ
    if order.OrderType == OrderTypeMarket {
        trades = e.matchMarketOrder(order)
        return trades
    }
    
    // é™ä»·å•å°è¯•æ’®åˆ
    trades = e.matchLimitOrder(order)
    
    // æœªå®Œå…¨æˆäº¤çš„é™ä»·å•åŠ å…¥è®¢å•ç°¿
    if order.FilledQty.LessThan(order.Quantity) {
        if order.Side == OrderSideBuy {
            e.buyBook.Add(order)
        } else {
            e.sellBook.Add(order)
        }
    }
    
    return trades
}

// matchLimitOrder æ’®åˆé™ä»·å•
func (e *MatchingEngine) matchLimitOrder(order *Order) []*Trade {
    var trades []*Trade
    
    // è·å–å¯¹æ‰‹æ–¹è®¢å•ç°¿
    var oppositeBook *OrderBook
    if order.Side == OrderSideBuy {
        oppositeBook = e.sellBook
    } else {
        oppositeBook = e.buyBook
    }
    
    // æŒç»­æ’®åˆç›´åˆ°è®¢å•å®Œå…¨æˆäº¤æˆ–æ— æ³•æ’®åˆ
    for order.FilledQty.LessThan(order.Quantity) && oppositeBook.Len() > 0 {
        topOrder := oppositeBook.Top()
        
        // ä»·æ ¼ä¸åŒ¹é…ï¼Œåœæ­¢æ’®åˆ
        if order.Side == OrderSideBuy && order.Price.LessThan(topOrder.Price) {
            break
        }
        if order.Side == OrderSideSell && order.Price.GreaterThan(topOrder.Price) {
            break
        }
        
        // è®¡ç®—æˆäº¤æ•°é‡
        remainQty := order.Quantity.Sub(order.FilledQty)
        topRemainQty := topOrder.Quantity.Sub(topOrder.FilledQty)
        tradeQty := remainQty
        if tradeQty.GreaterThan(topRemainQty) {
            tradeQty = topRemainQty
        }
        
        // åˆ›å»ºæˆäº¤è®°å½•
        trade := &Trade{
            Symbol:   order.Symbol,
            Price:    topOrder.Price, // ä½¿ç”¨å…ˆä¸‹å•çš„ä»·æ ¼
            Quantity: tradeQty,
            Amount:   topOrder.Price.Mul(tradeQty),
        }
        
        if order.Side == OrderSideBuy {
            trade.BuyOrderID = order.ID
            trade.SellOrderID = topOrder.ID
        } else {
            trade.BuyOrderID = topOrder.ID
            trade.SellOrderID = order.ID
        }
        
        trades = append(trades, trade)
        
        // æ›´æ–°è®¢å•æˆäº¤æ•°é‡
        order.FilledQty = order.FilledQty.Add(tradeQty)
        topOrder.FilledQty = topOrder.FilledQty.Add(tradeQty)
        
        // å¦‚æœå¯¹æ‰‹å•å®Œå…¨æˆäº¤ï¼Œä»è®¢å•ç°¿ç§»é™¤
        if topOrder.FilledQty.Equal(topOrder.Quantity) {
            oppositeBook.Remove()
        }
    }
    
    return trades
}

// matchMarketOrder æ’®åˆå¸‚ä»·å•
func (e *MatchingEngine) matchMarketOrder(order *Order) []*Trade {
    // å¸‚ä»·å•æ’®åˆé€»è¾‘ç±»ä¼¼é™ä»·å•ï¼Œä½†ä¸æ£€æŸ¥ä»·æ ¼
    // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è€ƒè™‘æ»‘ç‚¹ä¿æŠ¤ç­‰
    return e.matchLimitOrder(order)
}

// OrderBook è®¢å•ç°¿
type OrderBook struct {
    orders    []*Order
    ascending bool // true: ä»·æ ¼ä»ä½åˆ°é«˜, false: ä»·æ ¼ä»é«˜åˆ°ä½
}

// NewOrderBook åˆ›å»ºè®¢å•ç°¿
func NewOrderBook(ascending bool) *OrderBook {
    ob := &OrderBook{
        orders:    make([]*Order, 0),
        ascending: ascending,
    }
    heap.Init(ob)
    return ob
}

// å®ç° heap.Interface
func (ob *OrderBook) Len() int { return len(ob.orders) }

func (ob *OrderBook) Less(i, j int) bool {
    if ob.ascending {
        return ob.orders[i].Price.LessThan(ob.orders[j].Price)
    }
    return ob.orders[i].Price.GreaterThan(ob.orders[j].Price)
}

func (ob *OrderBook) Swap(i, j int) {
    ob.orders[i], ob.orders[j] = ob.orders[j], ob.orders[i]
}

func (ob *OrderBook) Push(x interface{}) {
    ob.orders = append(ob.orders, x.(*Order))
}

func (ob *OrderBook) Pop() interface{} {
    old := ob.orders
    n := len(old)
    item := old[n-1]
    ob.orders = old[0 : n-1]
    return item
}

// Add æ·»åŠ è®¢å•
func (ob *OrderBook) Add(order *Order) {
    heap.Push(ob, order)
}

// Remove ç§»é™¤é¡¶éƒ¨è®¢å•
func (ob *OrderBook) Remove() *Order {
    if ob.Len() == 0 {
        return nil
    }
    return heap.Pop(ob).(*Order)
}

// Top æŸ¥çœ‹é¡¶éƒ¨è®¢å•
func (ob *OrderBook) Top() *Order {
    if ob.Len() == 0 {
        return nil
    }
    return ob.orders[0]
}
```

---

## æ”¯ä»˜æ¸…ç®—ç³»ç»Ÿ

### æ”¯ä»˜æœåŠ¡

```go
package payment

import (
    "context"
    "crypto/md5"
    "database/sql"
    "encoding/hex"
    "errors"
    "fmt"
    "time"
    "github.com/shopspring/decimal"
)

// PaymentOrder æ”¯ä»˜è®¢å•
type PaymentOrder struct {
    ID            int64           `json:"id" db:"id"`
    OrderNo       string          `json:"order_no" db:"order_no"`
    UserID        int64           `json:"user_id" db:"user_id"`
    Amount        decimal.Decimal `json:"amount" db:"amount"`
    Currency      string          `json:"currency" db:"currency"`
    PayMethod     PayMethod       `json:"pay_method" db:"pay_method"`
    Status        PaymentStatus   `json:"status" db:"status"`
    NotifyURL     string          `json:"notify_url" db:"notify_url"`
    CallbackData  string          `json:"callback_data" db:"callback_data"`
    PaidAt        *time.Time      `json:"paid_at" db:"paid_at"`
    CreatedAt     time.Time       `json:"created_at" db:"created_at"`
    ExpireAt      time.Time       `json:"expire_at" db:"expire_at"`
}

// PayMethod æ”¯ä»˜æ–¹å¼
type PayMethod int

const (
    PayMethodBalance PayMethod = 1 // ä½™é¢æ”¯ä»˜
    PayMethodAlipay  PayMethod = 2 // æ”¯ä»˜å®
    PayMethodWechat  PayMethod = 3 // å¾®ä¿¡
    PayMethodBank    PayMethod = 4 // é“¶è¡Œå¡
)

// PaymentStatus æ”¯ä»˜çŠ¶æ€
type PaymentStatus int

const (
    PaymentStatusPending   PaymentStatus = 1 // å¾…æ”¯ä»˜
    PaymentStatusPaid      PaymentStatus = 2 // å·²æ”¯ä»˜
    PaymentStatusFailed    PaymentStatus = 3 // æ”¯ä»˜å¤±è´¥
    PaymentStatusRefunding PaymentStatus = 4 // é€€æ¬¾ä¸­
    PaymentStatusRefunded  PaymentStatus = 5 // å·²é€€æ¬¾
)

// PaymentService æ”¯ä»˜æœåŠ¡
type PaymentService struct {
    db *sql.DB
}

// CreatePaymentOrder åˆ›å»ºæ”¯ä»˜è®¢å•
func (s *PaymentService) CreatePaymentOrder(ctx context.Context, req *CreatePaymentRequest) (*PaymentOrder, error) {
    order := &PaymentOrder{
        OrderNo:   generatePaymentOrderNo(),
        UserID:    req.UserID,
        Amount:    req.Amount,
        Currency:  req.Currency,
        PayMethod: req.PayMethod,
        Status:    PaymentStatusPending,
        NotifyURL: req.NotifyURL,
        ExpireAt:  time.Now().Add(15 * time.Minute), // 15åˆ†é’Ÿè¿‡æœŸ
    }
    
    query := `
        INSERT INTO payment_orders (order_no, user_id, amount, currency, pay_method, status, notify_url, created_at, expire_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), ?)
    `
    
    result, err := s.db.ExecContext(ctx, query,
        order.OrderNo, order.UserID, order.Amount, order.Currency,
        order.PayMethod, order.Status, order.NotifyURL, order.ExpireAt,
    )
    if err != nil {
        return nil, err
    }
    
    id, _ := result.LastInsertId()
    order.ID = id
    
    return order, nil
}

// ProcessPayment å¤„ç†æ”¯ä»˜
func (s *PaymentService) ProcessPayment(ctx context.Context, orderNo string, payMethod PayMethod) error {
    // å¼€å¯äº‹åŠ¡
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    // é”å®šè®¢å•
    var order PaymentOrder
    query := `SELECT id, order_no, user_id, amount, status, expire_at FROM payment_orders WHERE order_no = ? FOR UPDATE`
    err = tx.QueryRowContext(ctx, query, orderNo).Scan(
        &order.ID, &order.OrderNo, &order.UserID, &order.Amount, &order.Status, &order.ExpireAt,
    )
    if err == sql.ErrNoRows {
        return errors.New("è®¢å•ä¸å­˜åœ¨")
    }
    if err != nil {
        return err
    }
    
    // æ£€æŸ¥è®¢å•çŠ¶æ€
    if order.Status != PaymentStatusPending {
        return errors.New("è®¢å•çŠ¶æ€ä¸æ­£ç¡®")
    }
    
    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if time.Now().After(order.ExpireAt) {
        return errors.New("è®¢å•å·²è¿‡æœŸ")
    }
    
    // æ ¹æ®æ”¯ä»˜æ–¹å¼å¤„ç†
    switch payMethod {
    case PayMethodBalance:
        // æ‰£å‡è´¦æˆ·ä½™é¢
        // ... è°ƒç”¨è´¦æˆ·æœåŠ¡æ‰£æ¬¾
    case PayMethodAlipay, PayMethodWechat:
        // è°ƒç”¨ç¬¬ä¸‰æ–¹æ”¯ä»˜æ¥å£
        // ... è¿™é‡Œç®€åŒ–å¤„ç†
    default:
        return errors.New("ä¸æ”¯æŒçš„æ”¯ä»˜æ–¹å¼")
    }
    
    // æ›´æ–°è®¢å•çŠ¶æ€
    now := time.Now()
    updateQuery := `UPDATE payment_orders SET status = ?, paid_at = ?, updated_at = NOW() WHERE id = ?`
    _, err = tx.ExecContext(ctx, updateQuery, PaymentStatusPaid, now, order.ID)
    if err != nil {
        return err
    }
    
    // å‘é€æ”¯ä»˜æˆåŠŸé€šçŸ¥ï¼ˆå¼‚æ­¥ï¼‰
    go s.notifyPaymentSuccess(order.ID)
    
    return tx.Commit()
}

// notifyPaymentSuccess é€šçŸ¥æ”¯ä»˜æˆåŠŸ
func (s *PaymentService) notifyPaymentSuccess(orderID int64) {
    // å¼‚æ­¥é€šçŸ¥ä¸šåŠ¡æ–¹
    // å®ç°å›è°ƒé€šçŸ¥é€»è¾‘
}

// generatePaymentOrderNo ç”Ÿæˆæ”¯ä»˜è®¢å•å·
func generatePaymentOrderNo() string {
    // æ ¼å¼: P + æ—¶é—´æˆ³ + éšæœºæ•°
    return fmt.Sprintf("P%d%04d", time.Now().Unix(), time.Now().Nanosecond()%10000)
}

// CreatePaymentRequest åˆ›å»ºæ”¯ä»˜è¯·æ±‚
type CreatePaymentRequest struct {
    UserID    int64
    Amount    decimal.Decimal
    Currency  string
    PayMethod PayMethod
    NotifyURL string
}
```

---

## é£æ§ç³»ç»Ÿ

### é£æ§è§„åˆ™å¼•æ“

```go
package risk

import (
    "context"
    "sync"
    "time"
    "github.com/shopspring/decimal"
)

// RiskEngine é£æ§å¼•æ“
type RiskEngine struct {
    rules []Rule
    mu    sync.RWMutex
}

// Rule é£æ§è§„åˆ™æ¥å£
type Rule interface {
    Check(ctx context.Context, event *Event) *RiskResult
    Priority() int
}

// Event é£æ§äº‹ä»¶
type Event struct {
    Type      EventType
    UserID    int64
    Amount    decimal.Decimal
    IP        string
    DeviceID  string
    Timestamp time.Time
    Metadata  map[string]interface{}
}

// EventType äº‹ä»¶ç±»å‹
type EventType int

const (
    EventTypeLogin    EventType = 1 // ç™»å½•
    EventTypeTransfer EventType = 2 // è½¬è´¦
    EventTypeTrade    EventType = 3 // äº¤æ˜“
    EventTypeWithdraw EventType = 4 // æç°
)

// RiskResult é£æ§ç»“æœ
type RiskResult struct {
    Passed  bool
    Level   RiskLevel
    Reason  string
    Actions []string
}

// RiskLevel é£é™©ç­‰çº§
type RiskLevel int

const (
    RiskLevelLow    RiskLevel = 1 // ä½é£é™©
    RiskLevelMedium RiskLevel = 2 // ä¸­é£é™©
    RiskLevelHigh   RiskLevel = 3 // é«˜é£é™©
)

// NewRiskEngine åˆ›å»ºé£æ§å¼•æ“
func NewRiskEngine() *RiskEngine {
    engine := &RiskEngine{
        rules: make([]Rule, 0),
    }
    
    // æ³¨å†Œé»˜è®¤è§„åˆ™
    engine.AddRule(&FrequencyLimitRule{})
    engine.AddRule(&AmountLimitRule{})
    engine.AddRule(&BlacklistRule{})
    engine.AddRule(&AnomalyDetectionRule{})
    
    return engine
}

// AddRule æ·»åŠ è§„åˆ™
func (e *RiskEngine) AddRule(rule Rule) {
    e.mu.Lock()
    defer e.mu.Unlock()
    e.rules = append(e.rules, rule)
}

// Check é£æ§æ£€æŸ¥
func (e *RiskEngine) Check(ctx context.Context, event *Event) *RiskResult {
    e.mu.RLock()
    defer e.mu.RUnlock()
    
    // æŒ‰ä¼˜å…ˆçº§æ£€æŸ¥æ‰€æœ‰è§„åˆ™
    for _, rule := range e.rules {
        result := rule.Check(ctx, event)
        if !result.Passed {
            return result
        }
    }
    
    return &RiskResult{
        Passed: true,
        Level:  RiskLevelLow,
    }
}

// FrequencyLimitRule é¢‘ç‡é™åˆ¶è§„åˆ™
type FrequencyLimitRule struct {
    cache sync.Map // userID -> []time.Time
}

func (r *FrequencyLimitRule) Priority() int {
    return 1
}

func (r *FrequencyLimitRule) Check(ctx context.Context, event *Event) *RiskResult {
    key := fmt.Sprintf("%d_%d", event.UserID, event.Type)
    
    // è·å–æœ€è¿‘æ“ä½œè®°å½•
    value, _ := r.cache.LoadOrStore(key, &[]time.Time{})
    timestamps := value.(*[]time.Time)
    
    // ç§»é™¤1åˆ†é’Ÿå‰çš„è®°å½•
    now := time.Now()
    filtered := make([]time.Time, 0)
    for _, ts := range *timestamps {
        if now.Sub(ts) < time.Minute {
            filtered = append(filtered, ts)
        }
    }
    
    // æ£€æŸ¥é¢‘ç‡
    if len(filtered) >= 10 { // 1åˆ†é’Ÿå†…è¶…è¿‡10æ¬¡
        return &RiskResult{
            Passed: false,
            Level:  RiskLevelHigh,
            Reason: "æ“ä½œé¢‘ç‡è¿‡é«˜",
            Actions: []string{"æ‹’ç»æ“ä½œ", "å‘é€å‘Šè­¦"},
        }
    }
    
    // è®°å½•æœ¬æ¬¡æ“ä½œ
    filtered = append(filtered, now)
    r.cache.Store(key, &filtered)
    
    return &RiskResult{Passed: true}
}

// AmountLimitRule é‡‘é¢é™åˆ¶è§„åˆ™
type AmountLimitRule struct{}

func (r *AmountLimitRule) Priority() int {
    return 2
}

func (r *AmountLimitRule) Check(ctx context.Context, event *Event) *RiskResult {
    // å•ç¬”é™é¢
    singleLimit := decimal.NewFromInt(100000) // 10ä¸‡
    if event.Amount.GreaterThan(singleLimit) {
        return &RiskResult{
            Passed: false,
            Level:  RiskLevelHigh,
            Reason: "å•ç¬”é‡‘é¢è¶…é™",
            Actions: []string{"äººå·¥å®¡æ ¸"},
        }
    }
    
    // æ¯æ—¥é™é¢ï¼ˆéœ€è¦æŸ¥è¯¢æ•°æ®åº“ï¼‰
    // ... çœç•¥å®ç°
    
    return &RiskResult{Passed: true}
}

// BlacklistRule é»‘åå•è§„åˆ™
type BlacklistRule struct {
    blacklist sync.Map // userID -> bool
}

func (r *BlacklistRule) Priority() int {
    return 0 // æœ€é«˜ä¼˜å…ˆçº§
}

func (r *BlacklistRule) Check(ctx context.Context, event *Event) *RiskResult {
    if _, exists := r.blacklist.Load(event.UserID); exists {
        return &RiskResult{
            Passed: false,
            Level:  RiskLevelHigh,
            Reason: "ç”¨æˆ·åœ¨é»‘åå•ä¸­",
            Actions: []string{"æ‹’ç»æ“ä½œ", "è®°å½•æ—¥å¿—"},
        }
    }
    
    return &RiskResult{Passed: true}
}

// AnomalyDetectionRule å¼‚å¸¸æ£€æµ‹è§„åˆ™
type AnomalyDetectionRule struct{}

func (r *AnomalyDetectionRule) Priority() int {
    return 3
}

func (r *AnomalyDetectionRule) Check(ctx context.Context, event *Event) *RiskResult {
    // æ£€æµ‹å¼‚å¸¸è¡Œä¸ºæ¨¡å¼
    // 1. å¼‚åœ°ç™»å½•
    // 2. è®¾å¤‡æŒ‡çº¹å˜åŒ–
    // 3. äº¤æ˜“æ—¶é—´å¼‚å¸¸
    // ... è¿™é‡Œç®€åŒ–å®ç°
    
    // ç¤ºä¾‹ï¼šæ·±å¤œå¤§é¢äº¤æ˜“
    hour := event.Timestamp.Hour()
    if (hour >= 0 && hour <= 5) && event.Amount.GreaterThan(decimal.NewFromInt(50000)) {
        return &RiskResult{
            Passed: true,
            Level:  RiskLevelMedium,
            Reason: "æ·±å¤œå¤§é¢äº¤æ˜“",
            Actions: []string{"å¢å¼ºéªŒè¯", "å‘é€é€šçŸ¥"},
        }
    }
    
    return &RiskResult{Passed: true}
}
```

---

## å®æ—¶è¡Œæƒ…ç³»ç»Ÿ

### è¡Œæƒ…æ•°æ®æ¨é€

```go
package market

import (
    "context"
    "encoding/json"
    "sync"
    "time"
    "github.com/gorilla/websocket"
    "github.com/shopspring/decimal"
)

// Ticker è¡Œæƒ…æ•°æ®
type Ticker struct {
    Symbol    string          `json:"symbol"`
    LastPrice decimal.Decimal `json:"last_price"`
    High24h   decimal.Decimal `json:"high_24h"`
    Low24h    decimal.Decimal `json:"low_24h"`
    Volume24h decimal.Decimal `json:"volume_24h"`
    Change24h decimal.Decimal `json:"change_24h"` // æ¶¨è·Œå¹…
    Timestamp time.Time       `json:"timestamp"`
}

// MarketDataHub è¡Œæƒ…æ•°æ®ä¸­å¿ƒ
type MarketDataHub struct {
    clients   map[*Client]bool
    broadcast chan *Ticker
    register  chan *Client
    unregister chan *Client
    mu        sync.RWMutex
}

// Client WebSocket å®¢æˆ·ç«¯
type Client struct {
    hub    *MarketDataHub
    conn   *websocket.Conn
    send   chan []byte
    symbols map[string]bool // è®¢é˜…çš„äº¤æ˜“å¯¹
}

// NewMarketDataHub åˆ›å»ºè¡Œæƒ…æ•°æ®ä¸­å¿ƒ
func NewMarketDataHub() *MarketDataHub {
    return &MarketDataHub{
        broadcast:  make(chan *Ticker, 100),
        register:   make(chan *Client),
        unregister: make(chan *Client),
        clients:    make(map[*Client]bool),
    }
}

// Run è¿è¡Œæ•°æ®ä¸­å¿ƒ
func (h *MarketDataHub) Run() {
    for {
        select {
        case client := <-h.register:
            h.mu.Lock()
            h.clients[client] = true
            h.mu.Unlock()
            
        case client := <-h.unregister:
            h.mu.Lock()
            if _, ok := h.clients[client]; ok {
                delete(h.clients, client)
                close(client.send)
            }
            h.mu.Unlock()
            
        case ticker := <-h.broadcast:
            h.mu.RLock()
            for client := range h.clients {
                // åªæ¨é€è®¢é˜…çš„äº¤æ˜“å¯¹
                if client.symbols[ticker.Symbol] {
                    data, _ := json.Marshal(ticker)
                    select {
                    case client.send <- data:
                    default:
                        close(client.send)
                        delete(h.clients, client)
                    }
                }
            }
            h.mu.RUnlock()
        }
    }
}

// Broadcast å¹¿æ’­è¡Œæƒ…æ•°æ®
func (h *MarketDataHub) Broadcast(ticker *Ticker) {
    h.broadcast <- ticker
}

// readPump è¯»å–å®¢æˆ·ç«¯æ¶ˆæ¯
func (c *Client) readPump() {
    defer func() {
        c.hub.unregister <- c
        c.conn.Close()
    }()
    
    for {
        var msg struct {
            Action string   `json:"action"` // subscribe/unsubscribe
            Symbol string   `json:"symbol"`
        }
        
        err := c.conn.ReadJSON(&msg)
        if err != nil {
            break
        }
        
        // å¤„ç†è®¢é˜…/å–æ¶ˆè®¢é˜…
        switch msg.Action {
        case "subscribe":
            if c.symbols == nil {
                c.symbols = make(map[string]bool)
            }
            c.symbols[msg.Symbol] = true
        case "unsubscribe":
            delete(c.symbols, msg.Symbol)
        }
    }
}

// writePump å‘å®¢æˆ·ç«¯æ¨é€æ¶ˆæ¯
func (c *Client) writePump() {
    ticker := time.NewTicker(54 * time.Second)
    defer func() {
        ticker.Stop()
        c.conn.Close()
    }()
    
    for {
        select {
        case message, ok := <-c.send:
            if !ok {
                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                return
            }
            
            c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
            if err := c.conn.WriteMessage(websocket.TextMessage, message); err != nil {
                return
            }
            
        case <-ticker.C:
            // å‘é€å¿ƒè·³
            c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
            if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {
                return
            }
        }
    }
}
```

---

## æ•°æ®ä¸€è‡´æ€§ä¿è¯

### åˆ†å¸ƒå¼äº‹åŠ¡ - Saga æ¨¡å¼

```go
package saga

import (
    "context"
    "errors"
)

// Saga åˆ†å¸ƒå¼äº‹åŠ¡
type Saga struct {
    steps []Step
}

// Step äº‹åŠ¡æ­¥éª¤
type Step struct {
    Name         string
    Transaction  func(ctx context.Context) error
    Compensation func(ctx context.Context) error
}

// NewSaga åˆ›å»º Saga
func NewSaga() *Saga {
    return &Saga{
        steps: make([]Step, 0),
    }
}

// AddStep æ·»åŠ æ­¥éª¤
func (s *Saga) AddStep(name string, transaction, compensation func(ctx context.Context) error) *Saga {
    s.steps = append(s.steps, Step{
        Name:         name,
        Transaction:  transaction,
        Compensation: compensation,
    })
    return s
}

// Execute æ‰§è¡Œ Saga
func (s *Saga) Execute(ctx context.Context) error {
    executed := make([]int, 0)
    
    // æ­£å‘æ‰§è¡Œæ‰€æœ‰æ­¥éª¤
    for i, step := range s.steps {
        if err := step.Transaction(ctx); err != nil {
            // å‡ºé”™ï¼Œæ‰§è¡Œè¡¥å¿
            s.compensate(ctx, executed)
            return errors.New("saga failed at step: " + step.Name + ", error: " + err.Error())
        }
        executed = append(executed, i)
    }
    
    return nil
}

// compensate æ‰§è¡Œè¡¥å¿
func (s *Saga) compensate(ctx context.Context, executed []int) {
    // é€†åºæ‰§è¡Œè¡¥å¿
    for i := len(executed) - 1; i >= 0; i-- {
        stepIdx := executed[i]
        step := s.steps[stepIdx]
        if step.Compensation != nil {
            _ = step.Compensation(ctx) // å¿½ç•¥è¡¥å¿é”™è¯¯ï¼Œè®°å½•æ—¥å¿—
        }
    }
}

// ç¤ºä¾‹ï¼šè½¬è´¦ Saga
func TransferSaga(fromAccountID, toAccountID int64, amount decimal.Decimal) error {
    saga := NewSaga()
    
    // æ­¥éª¤1ï¼šå†»ç»“ä»˜æ¬¾æ–¹ä½™é¢
    saga.AddStep("freeze_from",
        func(ctx context.Context) error {
            return accountService.Freeze(ctx, fromAccountID, amount)
        },
        func(ctx context.Context) error {
            return accountService.Unfreeze(ctx, fromAccountID, amount)
        },
    )
    
    // æ­¥éª¤2ï¼šæ‰£å‡ä»˜æ¬¾æ–¹ä½™é¢
    saga.AddStep("deduct_from",
        func(ctx context.Context) error {
            return accountService.Deduct(ctx, fromAccountID, amount)
        },
        func(ctx context.Context) error {
            return accountService.Add(ctx, fromAccountID, amount)
        },
    )
    
    // æ­¥éª¤3ï¼šå¢åŠ æ”¶æ¬¾æ–¹ä½™é¢
    saga.AddStep("add_to",
        func(ctx context.Context) error {
            return accountService.Add(ctx, toAccountID, amount)
        },
        func(ctx context.Context) error {
            return accountService.Deduct(ctx, toAccountID, amount)
        },
    )
    
    // æ­¥éª¤4ï¼šè§£å†»ä»˜æ¬¾æ–¹ä½™é¢
    saga.AddStep("unfreeze_from",
        func(ctx context.Context) error {
            return accountService.Unfreeze(ctx, fromAccountID, amount)
        },
        nil, // æœ€åä¸€æ­¥é€šå¸¸ä¸éœ€è¦è¡¥å¿
    )
    
    return saga.Execute(context.Background())
}
```

---

## æ€§èƒ½ä¼˜åŒ–

### æ•°æ®åº“ä¼˜åŒ–

```sql
-- è´¦æˆ·è¡¨ç´¢å¼•
CREATE INDEX idx_accounts_user_id ON accounts(user_id);
CREATE INDEX idx_accounts_account_no ON accounts(account_no);
CREATE INDEX idx_accounts_status ON accounts(status);

-- ä½™é¢å˜åŠ¨è¡¨ç´¢å¼•
CREATE INDEX idx_balance_changes_account_id ON balance_changes(account_id);
CREATE INDEX idx_balance_changes_transaction_id ON balance_changes(transaction_id);
CREATE INDEX idx_balance_changes_created_at ON balance_changes(created_at);

-- è®¢å•è¡¨ç´¢å¼•
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_symbol_status ON orders(symbol, status);
CREATE INDEX idx_orders_created_at ON orders(created_at);

-- åˆ†åŒºè¡¨ï¼ˆæŒ‰æœˆåˆ†åŒºï¼‰
CREATE TABLE balance_changes_202501 PARTITION OF balance_changes
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

CREATE TABLE balance_changes_202502 PARTITION OF balance_changes
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');
```

### Redis ç¼“å­˜ç­–ç•¥

```go
package cache

import (
    "context"
    "encoding/json"
    "fmt"
    "time"
    "github.com/redis/go-redis/v9"
    "github.com/shopspring/decimal"
)

// AccountCache è´¦æˆ·ç¼“å­˜
type AccountCache struct {
    rdb *redis.Client
}

// GetBalance è·å–ä½™é¢ï¼ˆå¸¦ç¼“å­˜ï¼‰
func (c *AccountCache) GetBalance(ctx context.Context, accountID int64) (decimal.Decimal, error) {
    key := fmt.Sprintf("account:balance:%d", accountID)
    
    // 1. å°è¯•ä»ç¼“å­˜è·å–
    val, err := c.rdb.Get(ctx, key).Result()
    if err == nil {
        var balance decimal.Decimal
        balance, _ = decimal.NewFromString(val)
        return balance, nil
    }
    
    // 2. ç¼“å­˜æœªå‘½ä¸­ï¼Œä»æ•°æ®åº“æŸ¥è¯¢
    balance, err := accountService.GetBalance(ctx, accountID)
    if err != nil {
        return decimal.Zero, err
    }
    
    // 3. å†™å…¥ç¼“å­˜
    c.rdb.Set(ctx, key, balance.String(), 5*time.Minute)
    
    return balance, nil
}

// InvalidateBalance å¤±æ•ˆä½™é¢ç¼“å­˜
func (c *AccountCache) InvalidateBalance(ctx context.Context, accountID int64) error {
    key := fmt.Sprintf("account:balance:%d", accountID)
    return c.rdb.Del(ctx, key).Err()
}
```

---

## å®‰å…¨åŠ å›º

### åŠ å¯†å­˜å‚¨

```go
package security

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "encoding/base64"
    "errors"
    "io"
)

// Encrypt AESåŠ å¯†
func Encrypt(plaintext string, key []byte) (string, error) {
    block, err := aes.NewCipher(key)
    if err != nil {
        return "", err
    }
    
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }
    
    nonce := make([]byte, gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return "", err
    }
    
    ciphertext := gcm.Seal(nonce, nonce, []byte(plaintext), nil)
    return base64.StdEncoding.EncodeToString(ciphertext), nil
}

// Decrypt AESè§£å¯†
func Decrypt(ciphertext string, key []byte) (string, error) {
    data, err := base64.StdEncoding.DecodeString(ciphertext)
    if err != nil {
        return "", err
    }
    
    block, err := aes.NewCipher(key)
    if err != nil {
        return "", err
    }
    
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }
    
    nonceSize := gcm.NonceSize()
    if len(data) < nonceSize {
        return "", errors.New("ciphertext too short")
    }
    
    nonce, ciphertext := data[:nonceSize], data[nonceSize:]
    plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return "", err
    }
    
    return string(plaintext), nil
}

// HashPassword å¯†ç å“ˆå¸Œ
func HashPassword(password string) (string, error) {
    // ä½¿ç”¨ bcrypt
    return bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
}
```

---

## ç›‘æ§ä¸è¿ç»´

### Prometheus ç›‘æ§

```go
package metrics

import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    // äº¤æ˜“è®¡æ•°å™¨
    tradeCounter = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "financial_trades_total",
            Help: "Total number of trades",
        },
        []string{"symbol", "side"},
    )
    
    // äº¤æ˜“é‡‘é¢ç»Ÿè®¡
    tradeAmount = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "financial_trade_amount",
            Help:    "Trade amount distribution",
            Buckets: prometheus.ExponentialBuckets(100, 10, 7), // 100, 1000, 10000...
        },
        []string{"symbol"},
    )
    
    // è´¦æˆ·ä½™é¢
    accountBalance = promauto.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "financial_account_balance",
            Help: "Account balance",
        },
        []string{"account_id", "currency"},
    )
    
    // API å»¶è¿Ÿ
    apiLatency = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "financial_api_latency_seconds",
            Help:    "API latency in seconds",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method", "endpoint"},
    )
)

// RecordTrade è®°å½•äº¤æ˜“
func RecordTrade(symbol string, side string, amount decimal.Decimal) {
    tradeCounter.WithLabelValues(symbol, side).Inc()
    amountFloat, _ := amount.Float64()
    tradeAmount.WithLabelValues(symbol).Observe(amountFloat)
}

// UpdateAccountBalance æ›´æ–°è´¦æˆ·ä½™é¢
func UpdateAccountBalance(accountID int64, currency string, balance decimal.Decimal) {
    balanceFloat, _ := balance.Float64()
    accountBalance.WithLabelValues(fmt.Sprintf("%d", accountID), currency).Set(balanceFloat)
}
```

---

## æœ€ä½³å®è·µ

### 1. é‡‘é¢å¤„ç†

```go
// âœ… ä½¿ç”¨ decimal.Decimal å¤„ç†é‡‘é¢
import "github.com/shopspring/decimal"

amount := decimal.NewFromFloat(100.50)
result := amount.Mul(decimal.NewFromFloat(1.05))

// âŒ ä¸è¦ä½¿ç”¨ float64
// price := 100.50 * 1.05 // å¯èƒ½æœ‰ç²¾åº¦é—®é¢˜
```

### 2. å¹‚ç­‰æ€§è®¾è®¡

```go
// ä½¿ç”¨å”¯ä¸€äº¤æ˜“IDä¿è¯å¹‚ç­‰æ€§
func ProcessPayment(ctx context.Context, transactionID string) error {
    // æ£€æŸ¥æ˜¯å¦å·²å¤„ç†
    if isProcessed(transactionID) {
        return nil // å·²å¤„ç†ï¼Œç›´æ¥è¿”å›æˆåŠŸ
    }
    
    // å¤„ç†æ”¯ä»˜
    // ...
    
    // æ ‡è®°ä¸ºå·²å¤„ç†
    markAsProcessed(transactionID)
    
    return nil
}
```

### 3. æ•°æ®åº“äº‹åŠ¡

```go
// ä½¿ç”¨äº‹åŠ¡ä¿è¯åŸå­æ€§
tx, err := db.Begin()
if err != nil {
    return err
}
defer tx.Rollback() // ç¡®ä¿å¼‚å¸¸æ—¶å›æ»š

// æ‰§è¡Œä¸šåŠ¡é€»è¾‘
// ...

return tx.Commit() // æäº¤äº‹åŠ¡
```

---

## æ€»ç»“

é‡‘èç³»ç»Ÿå¼€å‘çš„æ ¸å¿ƒè¦ç‚¹ï¼š

1. **æ•°æ®å‡†ç¡®æ€§**: ä½¿ç”¨ decimal å¤„ç†é‡‘é¢ï¼Œé¿å…æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜
2. **é«˜å¯ç”¨æ€§**: å¤šå‰¯æœ¬éƒ¨ç½²ã€æ•…éšœè‡ªåŠ¨åˆ‡æ¢
3. **é«˜æ€§èƒ½**: ç¼“å­˜ä¼˜åŒ–ã€æ•°æ®åº“åˆ†åº“åˆ†è¡¨ã€è¯»å†™åˆ†ç¦»
4. **å®‰å…¨æ€§**: æ•°æ®åŠ å¯†ã€æƒé™æ§åˆ¶ã€å®¡è®¡æ—¥å¿—
5. **ä¸€è‡´æ€§**: åˆ†å¸ƒå¼äº‹åŠ¡ã€å¹‚ç­‰æ€§è®¾è®¡
6. **å¯è§‚æµ‹æ€§**: å®Œå–„çš„ç›‘æ§ã€æ—¥å¿—ã€å‘Šè­¦ç³»ç»Ÿ

---

**ç»´æŠ¤è€…**: Documentation Team  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22  
**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
