# 2.1 原子操作与并发安全容器

<!-- TOC START -->
- [2.1 原子操作与并发安全容器](#21-原子操作与并发安全容器)
  - [2.1.1 1. 理论基础](#211-1-理论基础)
  - [2.1.2 2. 典型用法](#212-2-典型用法)
    - [2.1.2.1 原子操作](#2121-原子操作)
    - [2.1.2.2 并发安全Map](#2122-并发安全map)
  - [2.1.3 3. 工程分析与最佳实践](#213-3-工程分析与最佳实践)
  - [2.1.4 4. 常见陷阱](#214-4-常见陷阱)
  - [2.1.5 5. 单元测试建议](#215-5-单元测试建议)
  - [2.1.6 6. 参考文献](#216-6-参考文献)
<!-- TOC END -->

## 2.1.1 1. 理论基础

- **原子操作（sync/atomic）**：提供底层无锁原子操作，保障多Goroutine下的数值一致性。
- **并发安全容器（sync.Map）**：内置并发安全的map，适合高并发读写场景。

---

## 2.1.2 2. 典型用法

### 2.1.2.1 原子操作

```go
import "sync/atomic"
var counter int64
atomic.AddInt64(&counter, 1)
val := atomic.LoadInt64(&counter)

```

### 2.1.2.2 并发安全Map

```go
var m sync.Map
m.Store("key", 123)
v, ok := m.Load("key")
m.Delete("key")
m.Range(func(k, v interface{}) bool {
    fmt.Println(k, v)
    return true
})

```

---

## 2.1.3 3. 工程分析与最佳实践

- atomic适合高性能计数器、状态标志等场景。
- sync.Map适合读多写少或热点key场景，替代map+锁。
- sync.Map不支持泛型，需类型断言。
- atomic操作需保证变量64位对齐。
- 对复杂结构体建议用锁保护，避免只用atomic。

---

## 2.1.4 4. 常见陷阱

- atomic操作非万能，复杂逻辑仍需锁。
- sync.Map不适合所有场景，频繁写入性能不佳。
- 忘记类型断言会panic。

---

## 2.1.5 5. 单元测试建议

- 并发场景下测试数据一致性与性能。
- 使用-race检测数据竞争。

---

## 2.1.6 6. 参考文献

- Go官方文档：<https://golang.org/pkg/sync/atomic/>
- Go官方文档：<https://golang.org/pkg/sync/#Map>
- Go Blog: <https://blog.golang.org/go-maps-in-action>
- 《Go语言高级编程》
