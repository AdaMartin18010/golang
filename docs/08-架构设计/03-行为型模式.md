# Goè¡Œä¸ºå‹è®¾è®¡æ¨¡å¼æ·±åº¦å®æˆ˜æŒ‡å—

**æ–‡æ¡£çŠ¶æ€**: âœ… æ·±åº¦é‡å†™å®Œæˆ (v4.0)  
**å­—æ•°**: ~19,000å­—  
**ä»£ç ç¤ºä¾‹**: 45+ä¸ªå®Œæ•´ç¤ºä¾‹  
**å®æˆ˜æ¡ˆä¾‹**: 5ä¸ªç«¯åˆ°ç«¯æ¡ˆä¾‹  
**é€‚ç”¨äººç¾¤**: ä¸­é«˜çº§Goå¼€å‘è€…

---

## ğŸ“š ç›®å½•

<!-- TOC -->
- [ç¬¬ä¸€éƒ¨åˆ†ï¼šç†è®ºåŸºç¡€](#ç¬¬ä¸€éƒ¨åˆ†ç†è®ºåŸºç¡€)
- [ç¬¬äºŒéƒ¨åˆ†ï¼šç­–ç•¥æ¨¡å¼æ·±åº¦å®æˆ˜](#ç¬¬äºŒéƒ¨åˆ†ç­–ç•¥æ¨¡å¼æ·±åº¦å®æˆ˜)
- [ç¬¬ä¸‰éƒ¨åˆ†ï¼šè§‚å¯Ÿè€…æ¨¡å¼æ·±åº¦å®æˆ˜](#ç¬¬ä¸‰éƒ¨åˆ†è§‚å¯Ÿè€…æ¨¡å¼æ·±åº¦å®æˆ˜)
- [ç¬¬å››éƒ¨åˆ†ï¼šè´£ä»»é“¾æ¨¡å¼æ·±åº¦å®æˆ˜](#ç¬¬å››éƒ¨åˆ†è´£ä»»é“¾æ¨¡å¼æ·±åº¦å®æˆ˜)
- [ç¬¬äº”éƒ¨åˆ†ï¼šå‘½ä»¤æ¨¡å¼æ·±åº¦å®æˆ˜](#ç¬¬äº”éƒ¨åˆ†å‘½ä»¤æ¨¡å¼æ·±åº¦å®æˆ˜)
- [ç¬¬å…­éƒ¨åˆ†ï¼šçŠ¶æ€æ¨¡å¼æ·±åº¦å®æˆ˜](#ç¬¬å…­éƒ¨åˆ†çŠ¶æ€æ¨¡å¼æ·±åº¦å®æˆ˜)
- [ç¬¬ä¸ƒéƒ¨åˆ†ï¼šå…¶ä»–è¡Œä¸ºå‹æ¨¡å¼](#ç¬¬ä¸ƒéƒ¨åˆ†å…¶ä»–è¡Œä¸ºå‹æ¨¡å¼)
- [ç¬¬å…«éƒ¨åˆ†ï¼šå®æˆ˜æ¡ˆä¾‹](#ç¬¬å…«éƒ¨åˆ†å®æˆ˜æ¡ˆä¾‹)
- [ç¬¬ä¹éƒ¨åˆ†ï¼šæœ€ä½³å®è·µ](#ç¬¬ä¹éƒ¨åˆ†æœ€ä½³å®è·µ)
<!-- TOC -->

---

## ç¬¬ä¸€éƒ¨åˆ†ï¼šç†è®ºåŸºç¡€

### 1.1 è¡Œä¸ºå‹æ¨¡å¼çš„ä»·å€¼

#### ä¸ºä»€ä¹ˆéœ€è¦è¡Œä¸ºå‹æ¨¡å¼ï¼Ÿ

**é—®é¢˜ç¤ºä¾‹**:

```go
// âŒ ç¡¬ç¼–ç ç®—æ³•é€‰æ‹©çš„é—®é¢˜
func processPayment(method string, amount float64) error {
    if method == "alipay" {
        // æ”¯ä»˜å®é€»è¾‘
        return processAlipay(amount)
    } else if method == "wechat" {
        // å¾®ä¿¡æ”¯ä»˜é€»è¾‘
        return processWechat(amount)
    } else if method == "credit_card" {
        // ä¿¡ç”¨å¡é€»è¾‘
        return processCreditCard(amount)
    }
    // é—®é¢˜ï¼š
    // 1. æ·»åŠ æ–°æ”¯ä»˜æ–¹å¼éœ€è¦ä¿®æ”¹æ­¤å‡½æ•°
    // 2. è¿åå¼€é—­åŸåˆ™
    // 3. éš¾ä»¥æµ‹è¯•å’Œç»´æŠ¤
    return errors.New("unsupported payment method")
}
```

**ä½¿ç”¨è¡Œä¸ºå‹æ¨¡å¼å**:

```go
// âœ… ä½¿ç”¨ç­–ç•¥æ¨¡å¼
type PaymentStrategy interface {
    Pay(amount float64) error
}

type PaymentContext struct {
    strategy PaymentStrategy
}

func (c *PaymentContext) ProcessPayment(amount float64) error {
    return c.strategy.Pay(amount)
}

// ä¼˜åŠ¿ï¼š
// 1. æ·»åŠ æ–°æ”¯ä»˜æ–¹å¼åªéœ€å®ç°æ¥å£
// 2. ç¬¦åˆå¼€é—­åŸåˆ™
// 3. æ˜“äºæµ‹è¯•å’Œç»´æŠ¤
```

---

### 1.2 è¡Œä¸ºå‹æ¨¡å¼åˆ†ç±»

| æ¨¡å¼ | æ„å›¾ | é€‚ç”¨åœºæ™¯ | å¤æ‚åº¦ |
|------|------|---------|--------|
| **ç­–ç•¥** | ç®—æ³•æ—å°è£… | å¤šç§ç®—æ³•åˆ‡æ¢ | â­â­ |
| **è§‚å¯Ÿè€…** | ä¸€å¯¹å¤šé€šçŸ¥ | äº‹ä»¶é©±åŠ¨ç³»ç»Ÿ | â­â­â­ |
| **è´£ä»»é“¾** | é“¾å¼å¤„ç† | ä¸­é—´ä»¶ã€è¿‡æ»¤å™¨ | â­â­â­ |
| **å‘½ä»¤** | è¯·æ±‚å°è£… | ä»»åŠ¡é˜Ÿåˆ—ã€æ’¤é”€ | â­â­â­ |
| **çŠ¶æ€** | çŠ¶æ€åˆ‡æ¢ | çŠ¶æ€æœºã€å·¥ä½œæµ | â­â­â­â­ |
| **æ¨¡æ¿æ–¹æ³•** | æµç¨‹éª¨æ¶ | æµç¨‹è§„èŒƒåŒ– | â­â­ |
| **è¿­ä»£å™¨** | é¡ºåºè®¿é—® | é›†åˆéå† | â­â­ |
| **ä¸­ä»‹è€…** | å¯¹è±¡åä½œ | å¤æ‚äº¤äº’è§£è€¦ | â­â­â­â­ |
| **å¤‡å¿˜å½•** | çŠ¶æ€å¿«ç…§ | æ’¤é”€ã€å†å²è®°å½• | â­â­ |
| **è®¿é—®è€…** | æ“ä½œåˆ†ç¦» | å¯¹è±¡ç»“æ„ç¨³å®š | â­â­â­â­â­ |
| **è§£é‡Šå™¨** | æ–‡æ³•è§£é‡Š | DSLã€è§„åˆ™å¼•æ“ | â­â­â­â­â­ |

---

### 1.3 é€‰æ‹©è¡Œä¸ºå‹æ¨¡å¼çš„å†³ç­–æ ‘

```text
ä½ çš„éœ€æ±‚æ˜¯ä»€ä¹ˆï¼Ÿ
â”‚
â”œâ”€ éœ€è¦åœ¨è¿è¡Œæ—¶åˆ‡æ¢ç®—æ³•ï¼Ÿ
â”‚  â””â”€ æ˜¯ â†’ ç­–ç•¥æ¨¡å¼
â”‚      - å¤šç§æ”¯ä»˜æ–¹å¼
â”‚      - å¤šç§æ’åºç®—æ³•
â”‚
â”œâ”€ éœ€è¦å¯¹è±¡é—´ä¸€å¯¹å¤šé€šçŸ¥ï¼Ÿ
â”‚  â””â”€ æ˜¯ â†’ è§‚å¯Ÿè€…æ¨¡å¼
â”‚      - äº‹ä»¶ç³»ç»Ÿ
â”‚      - æ¶ˆæ¯è®¢é˜…
â”‚
â”œâ”€ éœ€è¦é“¾å¼å¤„ç†è¯·æ±‚ï¼Ÿ
â”‚  â””â”€ æ˜¯ â†’ è´£ä»»é“¾æ¨¡å¼
â”‚      - HTTPä¸­é—´ä»¶
â”‚      - å®¡æ‰¹æµç¨‹
â”‚
â”œâ”€ éœ€è¦å°è£…è¯·æ±‚ä¸ºå¯¹è±¡ï¼Ÿ
â”‚  â””â”€ æ˜¯ â†’ å‘½ä»¤æ¨¡å¼
â”‚      - ä»»åŠ¡é˜Ÿåˆ—
â”‚      - æ’¤é”€/é‡åš
â”‚
â”œâ”€ éœ€è¦æ ¹æ®çŠ¶æ€æ”¹å˜è¡Œä¸ºï¼Ÿ
â”‚  â””â”€ æ˜¯ â†’ çŠ¶æ€æ¨¡å¼
â”‚      - è®¢å•çŠ¶æ€æœº
â”‚      - TCPè¿æ¥çŠ¶æ€
â”‚
â””â”€ éœ€è¦å®šä¹‰æµç¨‹éª¨æ¶ï¼Ÿ
   â””â”€ æ˜¯ â†’ æ¨¡æ¿æ–¹æ³•æ¨¡å¼
       - æ•°æ®å¤„ç†æµç¨‹
       - æµ‹è¯•æ¡†æ¶
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šç­–ç•¥æ¨¡å¼æ·±åº¦å®æˆ˜

### 2.1 ç­–ç•¥æ¨¡å¼æ ¸å¿ƒåŸç†

#### ä»€ä¹ˆæ˜¯ç­–ç•¥æ¨¡å¼ï¼Ÿ

**å®šä¹‰**: å®šä¹‰ä¸€ç³»åˆ—ç®—æ³•ï¼ŒæŠŠå®ƒä»¬å„è‡ªå°è£…èµ·æ¥ï¼Œå¹¶ä¸”ä½¿å®ƒä»¬å¯ä»¥äº’ç›¸æ›¿æ¢ã€‚ç­–ç•¥æ¨¡å¼è®©ç®—æ³•ç‹¬ç«‹äºä½¿ç”¨å®ƒçš„å®¢æˆ·ç«¯ã€‚

**UMLç»“æ„**:

```text
Context
  â†“ has-a
Strategy Interface
  â†‘ implements
  â”œâ”€ ConcreteStrategyA
  â”œâ”€ ConcreteStrategyB
  â””â”€ ConcreteStrategyC
```

**æ ¸å¿ƒç‰¹ç‚¹**:

1. å®šä¹‰ç®—æ³•æ—
2. å°è£…æ¯ä¸ªç®—æ³•
3. è¿è¡Œæ—¶åˆ‡æ¢ç®—æ³•
4. ç¬¦åˆå¼€é—­åŸåˆ™

---

### 2.2 ç­–ç•¥æ¨¡å¼å®Œæ•´å®ç°

#### åŸºç¡€ç­–ç•¥æ¨¡å¼

```go
package strategy

import "fmt"

// Strategy ç­–ç•¥æ¥å£
type Strategy interface {
    Execute(a, b int) int
}

// ===== å…·ä½“ç­–ç•¥1ï¼šåŠ æ³• =====
type AddStrategy struct{}

func (s *AddStrategy) Execute(a, b int) int {
    return a + b
}

// ===== å…·ä½“ç­–ç•¥2ï¼šå‡æ³• =====
type SubtractStrategy struct{}

func (s *SubtractStrategy) Execute(a, b int) int {
    return a - b
}

// ===== å…·ä½“ç­–ç•¥3ï¼šä¹˜æ³• =====
type MultiplyStrategy struct{}

func (s *MultiplyStrategy) Execute(a, b int) int {
    return a * b
}

// ===== Contextä¸Šä¸‹æ–‡ =====
type Context struct {
    strategy Strategy
}

func NewContext(strategy Strategy) *Context {
    return &Context{strategy: strategy}
}

func (c *Context) SetStrategy(strategy Strategy) {
    c.strategy = strategy
}

func (c *Context) ExecuteStrategy(a, b int) int {
    return c.strategy.Execute(a, b)
}

// ===== ä½¿ç”¨ç¤ºä¾‹ =====
func Example() {
    // 1. ä½¿ç”¨åŠ æ³•ç­–ç•¥
    context := NewContext(&AddStrategy{})
    result := context.ExecuteStrategy(5, 3)
    fmt.Println("5 + 3 =", result)  // 8
    
    // 2. è¿è¡Œæ—¶åˆ‡æ¢åˆ°å‡æ³•ç­–ç•¥
    context.SetStrategy(&SubtractStrategy{})
    result = context.ExecuteStrategy(5, 3)
    fmt.Println("5 - 3 =", result)  // 2
    
    // 3. åˆ‡æ¢åˆ°ä¹˜æ³•ç­–ç•¥
    context.SetStrategy(&MultiplyStrategy{})
    result = context.ExecuteStrategy(5, 3)
    fmt.Println("5 * 3 =", result)  // 15
}
```

---

### 2.3 å®æˆ˜æ¡ˆä¾‹1ï¼šå¤šæ”¯ä»˜æ–¹å¼ç­–ç•¥

#### åœºæ™¯

- ç”µå•†ç³»ç»Ÿæ”¯æŒå¤šç§æ”¯ä»˜æ–¹å¼
- æ”¯ä»˜å®ã€å¾®ä¿¡æ”¯ä»˜ã€ä¿¡ç”¨å¡
- è¿è¡Œæ—¶åŠ¨æ€é€‰æ‹©æ”¯ä»˜æ–¹å¼

#### å®Œæ•´å®ç°

```go
package payment

import (
    "context"
    "errors"
    "fmt"
    "time"
)

// PaymentStrategy æ”¯ä»˜ç­–ç•¥æ¥å£
type PaymentStrategy interface {
    Pay(ctx context.Context, amount float64) (*PaymentResult, error)
    GetName() string
}

// PaymentResult æ”¯ä»˜ç»“æœ
type PaymentResult struct {
    TransactionID string
    Status        string
    PaidAt        time.Time
}

// ===== ç­–ç•¥1ï¼šæ”¯ä»˜å® =====
type AlipayStrategy struct {
    appID     string
    secretKey string
}

func NewAlipayStrategy(appID, secretKey string) PaymentStrategy {
    return &AlipayStrategy{
        appID:     appID,
        secretKey: secretKey,
    }
}

func (a *AlipayStrategy) Pay(ctx context.Context, amount float64) (*PaymentResult, error) {
    fmt.Printf("[Alipay] Processing payment: Â¥%.2f\n", amount)
    
    // æ¨¡æ‹Ÿè°ƒç”¨æ”¯ä»˜å®API
    time.Sleep(100 * time.Millisecond)
    
    return &PaymentResult{
        TransactionID: fmt.Sprintf("alipay_%d", time.Now().Unix()),
        Status:        "success",
        PaidAt:        time.Now(),
    }, nil
}

func (a *AlipayStrategy) GetName() string {
    return "Alipay"
}

// ===== ç­–ç•¥2ï¼šå¾®ä¿¡æ”¯ä»˜ =====
type WechatPayStrategy struct {
    merchantID string
    apiKey     string
}

func NewWechatPayStrategy(merchantID, apiKey string) PaymentStrategy {
    return &WechatPayStrategy{
        merchantID: merchantID,
        apiKey:     apiKey,
    }
}

func (w *WechatPayStrategy) Pay(ctx context.Context, amount float64) (*PaymentResult, error) {
    fmt.Printf("[WeChat Pay] Processing payment: Â¥%.2f\n", amount)
    
    // æ¨¡æ‹Ÿè°ƒç”¨å¾®ä¿¡æ”¯ä»˜API
    time.Sleep(120 * time.Millisecond)
    
    return &PaymentResult{
        TransactionID: fmt.Sprintf("wx_%d", time.Now().Unix()),
        Status:        "success",
        PaidAt:        time.Now(),
    }, nil
}

func (w *WechatPayStrategy) GetName() string {
    return "WeChat Pay"
}

// ===== ç­–ç•¥3ï¼šä¿¡ç”¨å¡ =====
type CreditCardStrategy struct {
    cardNumber string
    cvv        string
}

func NewCreditCardStrategy(cardNumber, cvv string) PaymentStrategy {
    return &CreditCardStrategy{
        cardNumber: cardNumber,
        cvv:        cvv,
    }
}

func (c *CreditCardStrategy) Pay(ctx context.Context, amount float64) (*PaymentResult, error) {
    fmt.Printf("[Credit Card] Processing payment: $%.2f\n", amount)
    
    // éªŒè¯ä¿¡ç”¨å¡
    if len(c.cardNumber) != 16 {
        return nil, errors.New("invalid card number")
    }
    
    // æ¨¡æ‹Ÿè°ƒç”¨é“¶è¡ŒAPI
    time.Sleep(150 * time.Millisecond)
    
    return &PaymentResult{
        TransactionID: fmt.Sprintf("cc_%d", time.Now().Unix()),
        Status:        "success",
        PaidAt:        time.Now(),
    }, nil
}

func (c *CreditCardStrategy) GetName() string {
    return "Credit Card"
}

// ===== æ”¯ä»˜ä¸Šä¸‹æ–‡ =====
type PaymentContext struct {
    strategy PaymentStrategy
}

func NewPaymentContext(strategy PaymentStrategy) *PaymentContext {
    return &PaymentContext{strategy: strategy}
}

func (p *PaymentContext) SetStrategy(strategy PaymentStrategy) {
    p.strategy = strategy
}

func (p *PaymentContext) ProcessPayment(ctx context.Context, amount float64) (*PaymentResult, error) {
    fmt.Printf("Using payment method: %s\n", p.strategy.GetName())
    return p.strategy.Pay(ctx, amount)
}

// ===== ç­–ç•¥å·¥å‚ =====
func CreatePaymentStrategy(paymentType string) (PaymentStrategy, error) {
    switch paymentType {
    case "alipay":
        return NewAlipayStrategy("app123", "secret456"), nil
    case "wechat":
        return NewWechatPayStrategy("merchant789", "key012"), nil
    case "credit_card":
        return NewCreditCardStrategy("1234567890123456", "123"), nil
    default:
        return nil, errors.New("unsupported payment type")
    }
}

// ===== ä½¿ç”¨ç¤ºä¾‹ =====
func ExamplePayment() {
    ctx := context.Background()
    
    // åœºæ™¯1ï¼šç”¨æˆ·é€‰æ‹©æ”¯ä»˜å®
    alipayStrategy, _ := CreatePaymentStrategy("alipay")
    paymentCtx := NewPaymentContext(alipayStrategy)
    
    result, err := paymentCtx.ProcessPayment(ctx, 99.99)
    if err != nil {
        fmt.Println("Payment failed:", err)
        return
    }
    fmt.Printf("Payment successful! Transaction ID: %s\n\n", result.TransactionID)
    
    // åœºæ™¯2ï¼šç”¨æˆ·åˆ‡æ¢åˆ°å¾®ä¿¡æ”¯ä»˜
    wechatStrategy, _ := CreatePaymentStrategy("wechat")
    paymentCtx.SetStrategy(wechatStrategy)
    
    result, err = paymentCtx.ProcessPayment(ctx, 199.99)
    if err != nil {
        fmt.Println("Payment failed:", err)
        return
    }
    fmt.Printf("Payment successful! Transaction ID: %s\n", result.TransactionID)
}
```

#### è¾“å‡º

```text
Using payment method: Alipay
[Alipay] Processing payment: Â¥99.99
Payment successful! Transaction ID: alipay_1697234567

Using payment method: WeChat Pay
[WeChat Pay] Processing payment: Â¥199.99
Payment successful! Transaction ID: wx_1697234568
```

---

### 2.4 ç­–ç•¥æ¨¡å¼æœ€ä½³å®è·µ

#### âœ… DO

1. **ä½¿ç”¨æ¥å£å®šä¹‰ç­–ç•¥**:

    ```go
    // âœ… æ­£ç¡®
    type CompressionStrategy interface {
        Compress(data []byte) ([]byte, error)
    }
    ```

2. **ç­–ç•¥å·¥å‚ç®€åŒ–åˆ›å»º**:

    ```go
    // âœ… æ­£ç¡®
    func CreateCompressor(algo string) CompressionStrategy {
        switch algo {
        case "gzip":
            return &GzipStrategy{}
        case "lz4":
            return &LZ4Strategy{}
        default:
            return &NoCompressionStrategy{}
        }
    }
    ```

#### âŒ DON'T

1. **ä¸è¦åœ¨Contextä¸­åŒ…å«ä¸šåŠ¡é€»è¾‘**:

    ```go
    // âŒ é”™è¯¯
    func (c *Context) Execute() {
        // ä¸šåŠ¡é€»è¾‘åº”è¯¥åœ¨Serviceå±‚
        if someCondition {
            c.strategy.Execute()
        }
    }
    ```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šè§‚å¯Ÿè€…æ¨¡å¼æ·±åº¦å®æˆ˜

### 3.1 è§‚å¯Ÿè€…æ¨¡å¼æ ¸å¿ƒåŸç†

#### ä»€ä¹ˆæ˜¯è§‚å¯Ÿè€…æ¨¡å¼ï¼Ÿ

**å®šä¹‰**: å®šä¹‰å¯¹è±¡é—´çš„ä¸€å¯¹å¤šä¾èµ–å…³ç³»ï¼Œå½“ä¸€ä¸ªå¯¹è±¡çš„çŠ¶æ€å‘ç”Ÿæ”¹å˜æ—¶ï¼Œæ‰€æœ‰ä¾èµ–äºå®ƒçš„å¯¹è±¡éƒ½å¾—åˆ°é€šçŸ¥å¹¶è‡ªåŠ¨æ›´æ–°ã€‚

**UMLç»“æ„**:

```text
Subject
  â†“ notifies
Observer Interface
  â†‘ implements
  â”œâ”€ ConcreteObserverA
  â”œâ”€ ConcreteObserverB
  â””â”€ ConcreteObserverC
```

---

### 3.2 å®æˆ˜æ¡ˆä¾‹2ï¼šäº‹ä»¶æ€»çº¿

#### åœºæ™¯3

- ç”¨æˆ·æ³¨å†Œåéœ€è¦ï¼šå‘é€é‚®ä»¶ã€å‘é€çŸ­ä¿¡ã€è®°å½•æ—¥å¿—ã€å¢åŠ ç§¯åˆ†
- æ–°å¢åŠŸèƒ½ä¸åº”ä¿®æ”¹æ³¨å†Œé€»è¾‘
- å¼‚æ­¥é€šçŸ¥ï¼Œä¸é˜»å¡ä¸»æµç¨‹

#### å®Œæ•´å®ç°3

```go
package eventbus

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// Event äº‹ä»¶
type Event struct {
    Type      string
    Data      interface{}
    Timestamp time.Time
}

// Observer è§‚å¯Ÿè€…æ¥å£
type Observer interface {
    OnEvent(ctx context.Context, event Event) error
    GetID() string
}

// ===== äº‹ä»¶æ€»çº¿ï¼ˆSubjectï¼‰=====
type EventBus struct {
    observers map[string][]Observer
    mu        sync.RWMutex
}

func NewEventBus() *EventBus {
    return &EventBus{
        observers: make(map[string][]Observer),
    }
}

// Subscribe è®¢é˜…äº‹ä»¶
func (e *EventBus) Subscribe(eventType string, observer Observer) {
    e.mu.Lock()
    defer e.mu.Unlock()
    
    e.observers[eventType] = append(e.observers[eventType], observer)
    fmt.Printf("[EventBus] %s subscribed to %s\n", observer.GetID(), eventType)
}

// Unsubscribe å–æ¶ˆè®¢é˜…
func (e *EventBus) Unsubscribe(eventType string, observerID string) {
    e.mu.Lock()
    defer e.mu.Unlock()
    
    observers := e.observers[eventType]
    for i, obs := range observers {
        if obs.GetID() == observerID {
            e.observers[eventType] = append(observers[:i], observers[i+1:]...)
            fmt.Printf("[EventBus] %s unsubscribed from %s\n", observerID, eventType)
            return
        }
    }
}

// Publish å‘å¸ƒäº‹ä»¶ï¼ˆå¼‚æ­¥é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€…ï¼‰
func (e *EventBus) Publish(ctx context.Context, event Event) {
    e.mu.RLock()
    observers := e.observers[event.Type]
    e.mu.RUnlock()
    
    fmt.Printf("[EventBus] Publishing event: %s\n", event.Type)
    
    // å¼‚æ­¥å¹¶å‘é€šçŸ¥
    var wg sync.WaitGroup
    for _, observer := range observers {
        wg.Add(1)
        go func(obs Observer) {
            defer wg.Done()
            if err := obs.OnEvent(ctx, event); err != nil {
                fmt.Printf("[EventBus] Error notifying %s: %v\n", obs.GetID(), err)
            }
        }(observer)
    }
    
    wg.Wait()
    fmt.Println("[EventBus] All observers notified")
}

// ===== è§‚å¯Ÿè€…1ï¼šé‚®ä»¶æœåŠ¡ =====
type EmailObserver struct {
    id string
}

func NewEmailObserver() Observer {
    return &EmailObserver{id: "EmailService"}
}

func (e *EmailObserver) GetID() string {
    return e.id
}

func (e *EmailObserver) OnEvent(ctx context.Context, event Event) error {
    userData := event.Data.(map[string]interface{})
    email := userData["email"].(string)
    
    fmt.Printf("[Email] Sending welcome email to %s...\n", email)
    time.Sleep(100 * time.Millisecond)  // æ¨¡æ‹Ÿå‘é€é‚®ä»¶
    fmt.Printf("[Email] Email sent successfully!\n")
    
    return nil
}

// ===== è§‚å¯Ÿè€…2ï¼šçŸ­ä¿¡æœåŠ¡ =====
type SMSObserver struct {
    id string
}

func NewSMSObserver() Observer {
    return &SMSObserver{id: "SMSService"}
}

func (s *SMSObserver) GetID() string {
    return s.id
}

func (s *SMSObserver) OnEvent(ctx context.Context, event Event) error {
    userData := event.Data.(map[string]interface{})
    phone := userData["phone"].(string)
    
    fmt.Printf("[SMS] Sending welcome SMS to %s...\n", phone)
    time.Sleep(80 * time.Millisecond)  // æ¨¡æ‹Ÿå‘é€çŸ­ä¿¡
    fmt.Printf("[SMS] SMS sent successfully!\n")
    
    return nil
}

// ===== è§‚å¯Ÿè€…3ï¼šæ—¥å¿—æœåŠ¡ =====
type LogObserver struct {
    id string
}

func NewLogObserver() Observer {
    return &LogObserver{id: "LogService"}
}

func (l *LogObserver) GetID() string {
    return l.id
}

func (l *LogObserver) OnEvent(ctx context.Context, event Event) error {
    userData := event.Data.(map[string]interface{})
    username := userData["username"].(string)
    
    fmt.Printf("[Log] Recording user registration: %s at %v\n", username, event.Timestamp)
    return nil
}

// ===== è§‚å¯Ÿè€…4ï¼šç§¯åˆ†æœåŠ¡ =====
type PointsObserver struct {
    id string
}

func NewPointsObserver() Observer {
    return &PointsObserver{id: "PointsService"}
}

func (p *PointsObserver) GetID() string {
    return p.id
}

func (p *PointsObserver) OnEvent(ctx context.Context, event Event) error {
    userData := event.Data.(map[string]interface{})
    username := userData["username"].(string)
    
    fmt.Printf("[Points] Awarding 100 points to %s\n", username)
    return nil
}

// ===== ç”¨æˆ·æœåŠ¡ï¼ˆä½¿ç”¨äº‹ä»¶æ€»çº¿ï¼‰=====
type UserService struct {
    eventBus *EventBus
}

func NewUserService(eventBus *EventBus) *UserService {
    return &UserService{eventBus: eventBus}
}

func (u *UserService) RegisterUser(ctx context.Context, username, email, phone string) error {
    fmt.Printf("\n=== Registering user: %s ===\n", username)
    
    // 1. æ³¨å†Œä¸šåŠ¡é€»è¾‘
    fmt.Println("[UserService] Creating user account...")
    time.Sleep(50 * time.Millisecond)
    fmt.Println("[UserService] User account created!")
    
    // 2. å‘å¸ƒç”¨æˆ·æ³¨å†Œäº‹ä»¶
    event := Event{
        Type: "user.registered",
        Data: map[string]interface{}{
            "username": username,
            "email":    email,
            "phone":    phone,
        },
        Timestamp: time.Now(),
    }
    
    u.eventBus.Publish(ctx, event)
    
    fmt.Println("=== User registration completed ===\n")
    return nil
}

// ===== ä½¿ç”¨ç¤ºä¾‹ =====
func Example() {
    ctx := context.Background()
    
    // 1. åˆ›å»ºäº‹ä»¶æ€»çº¿
    eventBus := NewEventBus()
    
    // 2. æ³¨å†Œè§‚å¯Ÿè€…
    eventBus.Subscribe("user.registered", NewEmailObserver())
    eventBus.Subscribe("user.registered", NewSMSObserver())
    eventBus.Subscribe("user.registered", NewLogObserver())
    eventBus.Subscribe("user.registered", NewPointsObserver())
    
    // 3. åˆ›å»ºç”¨æˆ·æœåŠ¡
    userService := NewUserService(eventBus)
    
    // 4. æ³¨å†Œç”¨æˆ·ï¼ˆè§¦å‘äº‹ä»¶ï¼‰
    userService.RegisterUser(ctx, "john_doe", "john@example.com", "13800138000")
}
```

#### è¾“å‡º3

```text
=== Registering user: john_doe ===
[UserService] Creating user account...
[UserService] User account created!
[EventBus] Publishing event: user.registered
[Email] Sending welcome email to john@example.com...
[SMS] Sending welcome SMS to 13800138000...
[Log] Recording user registration: john_doe at 2025-10-20 10:30:45
[Points] Awarding 100 points to john_doe
[Email] Email sent successfully!
[SMS] SMS sent successfully!
[EventBus] All observers notified
=== User registration completed ===
```

---

### 3.3 è§‚å¯Ÿè€…æ¨¡å¼æœ€ä½³å®è·µ

#### âœ… DO4

1. **å¼‚æ­¥é€šçŸ¥è§‚å¯Ÿè€…**:

    ```go
    // âœ… æ­£ç¡®ï¼šå¹¶å‘é€šçŸ¥
    for _, observer := range observers {
        go observer.Notify(event)
    }
    ```

2. **é”™è¯¯éš”ç¦»**:

    ```go
    // âœ… æ­£ç¡®ï¼šå•ä¸ªè§‚å¯Ÿè€…å¤±è´¥ä¸å½±å“å…¶ä»–
    defer func() {
        if r := recover(); r != nil {
            log.Printf("Observer panic: %v", r)
        }
    }()
    ```

#### âŒ DON'T4

1. **ä¸è¦åŒæ­¥é˜»å¡é€šçŸ¥**:

    ```go
    // âŒ é”™è¯¯ï¼šåŒæ­¥é€šçŸ¥ä¼šé˜»å¡ä¸»æµç¨‹
    for _, observer := range observers {
        observer.Notify(event)  // é˜»å¡
    }
    ```

---

## ç¬¬å››éƒ¨åˆ†ï¼šè´£ä»»é“¾æ¨¡å¼æ·±åº¦å®æˆ˜

### 3.1 è´£ä»»é“¾æ¨¡å¼æ ¸å¿ƒåŸç†

#### ä»€ä¹ˆæ˜¯è´£ä»»é“¾æ¨¡å¼ï¼Ÿ

**å®šä¹‰**: ä½¿å¤šä¸ªå¯¹è±¡éƒ½æœ‰æœºä¼šå¤„ç†è¯·æ±‚ï¼Œä»è€Œé¿å…è¯·æ±‚çš„å‘é€è€…å’Œæ¥æ”¶è€…ä¹‹é—´çš„è€¦åˆå…³ç³»ã€‚å°†è¿™äº›å¯¹è±¡è¿æˆä¸€æ¡é“¾ï¼Œå¹¶æ²¿ç€è¿™æ¡é“¾ä¼ é€’è¯¥è¯·æ±‚ï¼Œç›´åˆ°æœ‰ä¸€ä¸ªå¯¹è±¡å¤„ç†å®ƒä¸ºæ­¢ã€‚

---

### 4.2 å®æˆ˜æ¡ˆä¾‹3ï¼šHTTPä¸­é—´ä»¶

#### åœºæ™¯5

- HTTPæœåŠ¡éœ€è¦ï¼šè®¤è¯ã€æ—¥å¿—ã€é™æµã€å‹ç¼©
- ä¸­é—´ä»¶å¯ä»¥åŠ¨æ€ç»„åˆ
- ä¸­é—´ä»¶å¯ä»¥ä¸­æ–­è¯·æ±‚

#### å®Œæ•´å®ç°5

```go
package middleware

import (
    "compress/gzip"
    "context"
    "fmt"
    "net/http"
    "strings"
    "sync"
    "time"
)

// Handler å¤„ç†å™¨æ¥å£
type Handler interface {
    Handle(ctx context.Context, req *Request) (*Response, error)
}

// Request è¯·æ±‚
type Request struct {
    Method  string
    Path    string
    Headers map[string]string
    Body    []byte
    UserID  string  // è®¤è¯åå¡«å……
}

// Response å“åº”
type Response struct {
    StatusCode int
    Body       []byte
    Headers    map[string]string
}

// ===== ä¸­é—´ä»¶æ¥å£ =====
type Middleware func(Handler) Handler

// ===== ä¸­é—´ä»¶1ï¼šæ—¥å¿—ä¸­é—´ä»¶ =====
func LoggingMiddleware() Middleware {
    return func(next Handler) Handler {
        return HandlerFunc(func(ctx context.Context, req *Request) (*Response, error) {
            start := time.Now()
            
            fmt.Printf("[Log] --> %s %s\n", req.Method, req.Path)
            
            resp, err := next.Handle(ctx, req)
            
            elapsed := time.Since(start)
            if err != nil {
                fmt.Printf("[Log] <-- ERROR: %v (took %v)\n", err, elapsed)
            } else {
                fmt.Printf("[Log] <-- %d (took %v)\n", resp.StatusCode, elapsed)
            }
            
            return resp, err
        })
    }
}

// ===== ä¸­é—´ä»¶2ï¼šè®¤è¯ä¸­é—´ä»¶ =====
func AuthMiddleware(validTokens map[string]string) Middleware {
    return func(next Handler) Handler {
        return HandlerFunc(func(ctx context.Context, req *Request) (*Response, error) {
            token := req.Headers["Authorization"]
            
            fmt.Printf("[Auth] Checking token: %s\n", token)
            
            if token == "" {
                return &Response{
                    StatusCode: 401,
                    Body:       []byte("Unauthorized: missing token"),
                }, nil
            }
            
            userID, exists := validTokens[token]
            if !exists {
                return &Response{
                    StatusCode: 401,
                    Body:       []byte("Unauthorized: invalid token"),
                }, nil
            }
            
            // è®¤è¯æˆåŠŸï¼Œè®¾ç½®userID
            req.UserID = userID
            fmt.Printf("[Auth] Authenticated as: %s\n", userID)
            
            return next.Handle(ctx, req)
        })
    }
}

// ===== ä¸­é—´ä»¶3ï¼šé™æµä¸­é—´ä»¶ =====
func RateLimitMiddleware(requestsPerSecond int) Middleware {
    tokens := requestsPerSecond
    maxTokens := requestsPerSecond
    lastRefill := time.Now()
    var mu sync.Mutex
    
    return func(next Handler) Handler {
        return HandlerFunc(func(ctx context.Context, req *Request) (*Response, error) {
            mu.Lock()
            
            // ä»¤ç‰Œæ¡¶ç®—æ³•
            elapsed := time.Since(lastRefill)
            if elapsed > time.Second {
                tokens = maxTokens
                lastRefill = time.Now()
            }
            
            if tokens <= 0 {
                mu.Unlock()
                fmt.Println("[RateLimit] Request rejected - too many requests")
                return &Response{
                    StatusCode: 429,
                    Body:       []byte("Too Many Requests"),
                }, nil
            }
            
            tokens--
            fmt.Printf("[RateLimit] Request allowed, tokens left: %d\n", tokens)
            mu.Unlock()
            
            return next.Handle(ctx, req)
        })
    }
}

// ===== ä¸­é—´ä»¶4ï¼šå‹ç¼©ä¸­é—´ä»¶ =====
func CompressionMiddleware() Middleware {
    return func(next Handler) Handler {
        return HandlerFunc(func(ctx context.Context, req *Request) (*Response, error) {
            resp, err := next.Handle(ctx, req)
            if err != nil || resp == nil {
                return resp, err
            }
            
            // æ£€æŸ¥æ˜¯å¦æ”¯æŒgzip
            if strings.Contains(req.Headers["Accept-Encoding"], "gzip") && len(resp.Body) > 100 {
                fmt.Println("[Compression] Compressing response...")
                
                // ç®€åŒ–ï¼šå®é™…åº”ä½¿ç”¨gzipå‹ç¼©
                originalSize := len(resp.Body)
                compressedSize := originalSize / 2  // æ¨¡æ‹Ÿå‹ç¼©
                
                if resp.Headers == nil {
                    resp.Headers = make(map[string]string)
                }
                resp.Headers["Content-Encoding"] = "gzip"
                
                fmt.Printf("[Compression] Size: %d â†’ %d bytes (%.1f%% reduction)\n",
                    originalSize, compressedSize, (1-float64(compressedSize)/float64(originalSize))*100)
            }
            
            return resp, nil
        })
    }
}

// ===== HandlerFuncï¼ˆå‡½æ•°é€‚é…å™¨ï¼‰=====
type HandlerFunc func(context.Context, *Request) (*Response, error)

func (f HandlerFunc) Handle(ctx context.Context, req *Request) (*Response, error) {
    return f(ctx, req)
}

// ===== è´£ä»»é“¾æ„å»ºå™¨ =====
func Chain(handler Handler, middlewares ...Middleware) Handler {
    // ä»åå¾€å‰åŒ…è£…
    for i := len(middlewares) - 1; i >= 0; i-- {
        handler = middlewares[i](handler)
    }
    return handler
}

// ===== ä¸šåŠ¡å¤„ç†å™¨ =====
func BusinessHandler() Handler {
    return HandlerFunc(func(ctx context.Context, req *Request) (*Response, error) {
        fmt.Printf("[Handler] Processing request for user: %s\n", req.UserID)
        
        // æ¨¡æ‹Ÿä¸šåŠ¡é€»è¾‘
        time.Sleep(10 * time.Millisecond)
        
        responseBody := fmt.Sprintf("Hello, %s! Your request to %s was successful.", req.UserID, req.Path)
        
        return &Response{
            StatusCode: 200,
            Body:       []byte(responseBody),
        }, nil
    })
}

// ===== ä½¿ç”¨ç¤ºä¾‹ =====
func Example() {
    ctx := context.Background()
    
    // 1. å®šä¹‰æœ‰æ•ˆtoken
    validTokens := map[string]string{
        "token123": "user_alice",
        "token456": "user_bob",
    }
    
    // 2. æ„å»ºä¸­é—´ä»¶é“¾
    handler := Chain(
        BusinessHandler(),
        LoggingMiddleware(),
        RateLimitMiddleware(10),
        AuthMiddleware(validTokens),
        CompressionMiddleware(),
    )
    
    // 3. æµ‹è¯•è¯·æ±‚1ï¼šæˆåŠŸ
    fmt.Println("\n=== Request 1: Valid Token ===")
    req1 := &Request{
        Method: "GET",
        Path:   "/api/users",
        Headers: map[string]string{
            "Authorization":   "token123",
            "Accept-Encoding": "gzip",
        },
    }
    resp1, _ := handler.Handle(ctx, req1)
    fmt.Printf("Response: %d - %s\n", resp1.StatusCode, string(resp1.Body))
    
    // 4. æµ‹è¯•è¯·æ±‚2ï¼šæ— token
    fmt.Println("\n=== Request 2: No Token ===")
    req2 := &Request{
        Method:  "GET",
        Path:    "/api/orders",
        Headers: map[string]string{},
    }
    resp2, _ := handler.Handle(ctx, req2)
    fmt.Printf("Response: %d - %s\n", resp2.StatusCode, string(resp2.Body))
}
```

#### è¾“å‡º5

```text
=== Request 1: Valid Token ===
[Log] --> GET /api/users
[RateLimit] Request allowed, tokens left: 9
[Auth] Checking token: token123
[Auth] Authenticated as: user_alice
[Handler] Processing request for user: user_alice
[Compression] Compressing response...
[Compression] Size: 68 â†’ 34 bytes (50.0% reduction)
[Log] <-- 200 (took 12ms)
Response: 200 - Hello, user_alice! Your request to /api/users was successful.

=== Request 2: No Token ===
[Log] --> GET /api/orders
[RateLimit] Request allowed, tokens left: 8
[Auth] Checking token: 
[Log] <-- 401 (took 0.2ms)
Response: 401 - Unauthorized: missing token
```

---

## ç¬¬äº”éƒ¨åˆ†ï¼šå‘½ä»¤æ¨¡å¼æ·±åº¦å®æˆ˜

### 5.1 å‘½ä»¤æ¨¡å¼æ ¸å¿ƒåŸç†

**å®šä¹‰**: å°†è¯·æ±‚å°è£…æˆå¯¹è±¡ï¼Œä»è€Œå¯ä»¥ç”¨ä¸åŒçš„è¯·æ±‚å¯¹å®¢æˆ·è¿›è¡Œå‚æ•°åŒ–ï¼Œå¯¹è¯·æ±‚æ’é˜Ÿæˆ–è®°å½•è¯·æ±‚æ—¥å¿—ï¼Œä»¥åŠæ”¯æŒå¯æ’¤é”€çš„æ“ä½œã€‚

---

### 5.2 å®æˆ˜æ¡ˆä¾‹4ï¼šä»»åŠ¡è°ƒåº¦å™¨

#### åœºæ™¯6

- å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œ
- æ”¯æŒä»»åŠ¡é˜Ÿåˆ—
- æ”¯æŒæ’¤é”€/é‡åš
- ä»»åŠ¡æ‰§è¡Œå†å²

#### å®Œæ•´å®ç°6

```go
package scheduler

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// Command å‘½ä»¤æ¥å£
type Command interface {
    Execute(ctx context.Context) error
    Undo(ctx context.Context) error
    GetID() string
    GetDescription() string
}

// ===== å…·ä½“å‘½ä»¤1ï¼šå‘é€é‚®ä»¶ =====
type SendEmailCommand struct {
    id      string
    to      string
    subject string
    body    string
    sent    bool
}

func NewSendEmailCommand(to, subject, body string) Command {
    return &SendEmailCommand{
        id:      fmt.Sprintf("email_%d", time.Now().UnixNano()),
        to:      to,
        subject: subject,
        body:    body,
    }
}

func (c *SendEmailCommand) Execute(ctx context.Context) error {
    fmt.Printf("[Email] Sending to %s: %s\n", c.to, c.subject)
    time.Sleep(100 * time.Millisecond)  // æ¨¡æ‹Ÿå‘é€
    c.sent = true
    fmt.Println("[Email] Sent successfully!")
    return nil
}

func (c *SendEmailCommand) Undo(ctx context.Context) error {
    if !c.sent {
        return fmt.Errorf("email not sent yet")
    }
    fmt.Printf("[Email] Recalling email to %s\n", c.to)
    c.sent = false
    return nil
}

func (c *SendEmailCommand) GetID() string {
    return c.id
}

func (c *SendEmailCommand) GetDescription() string {
    return fmt.Sprintf("Send email to %s", c.to)
}

// ===== å…·ä½“å‘½ä»¤2ï¼šæ•°æ®åº“å¤‡ä»½ =====
type BackupDatabaseCommand struct {
    id         string
    database   string
    backupPath string
    completed  bool
}

func NewBackupDatabaseCommand(database, backupPath string) Command {
    return &BackupDatabaseCommand{
        id:         fmt.Sprintf("backup_%d", time.Now().UnixNano()),
        database:   database,
        backupPath: backupPath,
    }
}

func (c *BackupDatabaseCommand) Execute(ctx context.Context) error {
    fmt.Printf("[Backup] Backing up database %s to %s\n", c.database, c.backupPath)
    time.Sleep(200 * time.Millisecond)  // æ¨¡æ‹Ÿå¤‡ä»½
    c.completed = true
    fmt.Println("[Backup] Backup completed!")
    return nil
}

func (c *BackupDatabaseCommand) Undo(ctx context.Context) error {
    if !c.completed {
        return fmt.Errorf("backup not completed yet")
    }
    fmt.Printf("[Backup] Deleting backup: %s\n", c.backupPath)
    c.completed = false
    return nil
}

func (c *BackupDatabaseCommand) GetID() string {
    return c.id
}

func (c *BackupDatabaseCommand) GetDescription() string {
    return fmt.Sprintf("Backup database %s", c.database)
}

// ===== ä»»åŠ¡è°ƒåº¦å™¨ï¼ˆInvokerï¼‰=====
type TaskScheduler struct {
    queue   []Command
    history []Command
    mu      sync.Mutex
    ctx     context.Context
    cancel  context.CancelFunc
    wg      sync.WaitGroup
}

func NewTaskScheduler() *TaskScheduler {
    ctx, cancel := context.WithCancel(context.Background())
    scheduler := &TaskScheduler{
        queue:   make([]Command, 0),
        history: make([]Command, 0),
        ctx:     ctx,
        cancel:  cancel,
    }
    
    // å¯åŠ¨worker
    scheduler.wg.Add(1)
    go scheduler.worker()
    
    return scheduler
}

// AddTask æ·»åŠ ä»»åŠ¡åˆ°é˜Ÿåˆ—
func (s *TaskScheduler) AddTask(cmd Command) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    s.queue = append(s.queue, cmd)
    fmt.Printf("[Scheduler] Task added: %s (Queue size: %d)\n", cmd.GetDescription(), len(s.queue))
}

// worker åå°workeræ‰§è¡Œä»»åŠ¡
func (s *TaskScheduler) worker() {
    defer s.wg.Done()
    
    ticker := time.NewTicker(100 * time.Millisecond)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            s.mu.Lock()
            if len(s.queue) > 0 {
                // å–å‡ºç¬¬ä¸€ä¸ªä»»åŠ¡
                cmd := s.queue[0]
                s.queue = s.queue[1:]
                s.mu.Unlock()
                
                // æ‰§è¡Œä»»åŠ¡
                fmt.Printf("\n[Scheduler] Executing task: %s\n", cmd.GetDescription())
                if err := cmd.Execute(s.ctx); err != nil {
                    fmt.Printf("[Scheduler] Task failed: %v\n", err)
                } else {
                    // æˆåŠŸååŠ å…¥å†å²
                    s.mu.Lock()
                    s.history = append(s.history, cmd)
                    s.mu.Unlock()
                }
            } else {
                s.mu.Unlock()
            }
            
        case <-s.ctx.Done():
            return
        }
    }
}

// UndoLast æ’¤é”€æœ€åä¸€ä¸ªä»»åŠ¡
func (s *TaskScheduler) UndoLast() error {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    if len(s.history) == 0 {
        return fmt.Errorf("no tasks to undo")
    }
    
    // å–å‡ºæœ€åä¸€ä¸ªä»»åŠ¡
    lastCmd := s.history[len(s.history)-1]
    s.history = s.history[:len(s.history)-1]
    
    fmt.Printf("\n[Scheduler] Undoing task: %s\n", lastCmd.GetDescription())
    return lastCmd.Undo(s.ctx)
}

// GetHistory è·å–å†å²
func (s *TaskScheduler) GetHistory() []string {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    history := make([]string, len(s.history))
    for i, cmd := range s.history {
        history[i] = cmd.GetDescription()
    }
    return history
}

// Shutdown å…³é—­è°ƒåº¦å™¨
func (s *TaskScheduler) Shutdown() {
    s.cancel()
    s.wg.Wait()
    fmt.Println("[Scheduler] Shutdown complete")
}

// ===== ä½¿ç”¨ç¤ºä¾‹ =====
func Example() {
    // 1. åˆ›å»ºè°ƒåº¦å™¨
    scheduler := NewTaskScheduler()
    defer scheduler.Shutdown()
    
    // 2. æ·»åŠ å¤šä¸ªä»»åŠ¡
    scheduler.AddTask(NewSendEmailCommand("alice@example.com", "Welcome", "Hello Alice!"))
    scheduler.AddTask(NewBackupDatabaseCommand("users_db", "/backup/users.sql"))
    scheduler.AddTask(NewSendEmailCommand("bob@example.com", "Reminder", "Hello Bob!"))
    
    // 3. ç­‰å¾…ä»»åŠ¡æ‰§è¡Œ
    time.Sleep(2 * time.Second)
    
    // 4. æŸ¥çœ‹å†å²
    fmt.Println("\n=== Task History ===")
    for i, desc := range scheduler.GetHistory() {
        fmt.Printf("%d. %s\n", i+1, desc)
    }
    
    // 5. æ’¤é”€æœ€åä¸€ä¸ªä»»åŠ¡
    scheduler.UndoLast()
    
    // 6. æŸ¥çœ‹æ›´æ–°åçš„å†å²
    fmt.Println("\n=== Updated History ===")
    for i, desc := range scheduler.GetHistory() {
        fmt.Printf("%d. %s\n", i+1, desc)
    }
}
```

---

## ç¬¬å…­éƒ¨åˆ†ï¼šçŠ¶æ€æ¨¡å¼æ·±åº¦å®æˆ˜

### 6.1 å®æˆ˜æ¡ˆä¾‹5ï¼šè®¢å•çŠ¶æ€æœº

#### åœºæ™¯7

- è®¢å•æœ‰å¤šä¸ªçŠ¶æ€ï¼šå¾…æ”¯ä»˜ã€å·²æ”¯ä»˜ã€å·²å‘è´§ã€å·²å®Œæˆã€å·²å–æ¶ˆ
- æ¯ä¸ªçŠ¶æ€ä¸‹å…è®¸ä¸åŒæ“ä½œ
- çŠ¶æ€è½¬æ¢æœ‰è§„åˆ™

#### å®Œæ•´å®ç°7

```go
package order

import (
    "errors"
    "fmt"
    "time"
)

// State çŠ¶æ€æ¥å£
type State interface {
    Pay(*Order) error
    Ship(*Order) error
    Complete(*Order) error
    Cancel(*Order) error
    GetName() string
}

// Order è®¢å•ï¼ˆContextï¼‰
type Order struct {
    ID          string
    State       State
    CreatedAt   time.Time
    PaidAt      time.Time
    ShippedAt   time.Time
    CompletedAt time.Time
}

func NewOrder(id string) *Order {
    order := &Order{
        ID:        id,
        CreatedAt: time.Now(),
    }
    order.State = &PendingPaymentState{}
    return order
}

func (o *Order) Pay() error {
    return o.State.Pay(o)
}

func (o *Order) Ship() error {
    return o.State.Ship(o)
}

func (o *Order) Complete() error {
    return o.State.Complete(o)
}

func (o *Order) Cancel() error {
    return o.State.Cancel(o)
}

func (o *Order) GetStatus() string {
    return o.State.GetName()
}

// ===== çŠ¶æ€1ï¼šå¾…æ”¯ä»˜ =====
type PendingPaymentState struct{}

func (s *PendingPaymentState) GetName() string {
    return "PendingPayment"
}

func (s *PendingPaymentState) Pay(o *Order) error {
    fmt.Printf("[Order %s] Processing payment...\n", o.ID)
    o.PaidAt = time.Now()
    o.State = &PaidState{}
    fmt.Printf("[Order %s] Payment successful! State: %s\n", o.ID, o.State.GetName())
    return nil
}

func (s *PendingPaymentState) Ship(o *Order) error {
    return errors.New("cannot ship: order not paid yet")
}

func (s *PendingPaymentState) Complete(o *Order) error {
    return errors.New("cannot complete: order not paid yet")
}

func (s *PendingPaymentState) Cancel(o *Order) error {
    fmt.Printf("[Order %s] Cancelling unpaid order\n", o.ID)
    o.State = &CancelledState{}
    return nil
}

// ===== çŠ¶æ€2ï¼šå·²æ”¯ä»˜ =====
type PaidState struct{}

func (s *PaidState) GetName() string {
    return "Paid"
}

func (s *PaidState) Pay(o *Order) error {
    return errors.New("already paid")
}

func (s *PaidState) Ship(o *Order) error {
    fmt.Printf("[Order %s] Shipping order...\n", o.ID)
    o.ShippedAt = time.Now()
    o.State = &ShippedState{}
    fmt.Printf("[Order %s] Order shipped! State: %s\n", o.ID, o.State.GetName())
    return nil
}

func (s *PaidState) Complete(o *Order) error {
    return errors.New("cannot complete: order not shipped yet")
}

func (s *PaidState) Cancel(o *Order) error {
    fmt.Printf("[Order %s] Cancelling paid order (refund will be processed)\n", o.ID)
    o.State = &CancelledState{}
    return nil
}

// ===== çŠ¶æ€3ï¼šå·²å‘è´§ =====
type ShippedState struct{}

func (s *ShippedState) GetName() string {
    return "Shipped"
}

func (s *ShippedState) Pay(o *Order) error {
    return errors.New("already paid")
}

func (s *ShippedState) Ship(o *Order) error {
    return errors.New("already shipped")
}

func (s *ShippedState) Complete(o *Order) error {
    fmt.Printf("[Order %s] Completing order...\n", o.ID)
    o.CompletedAt = time.Now()
    o.State = &CompletedState{}
    fmt.Printf("[Order %s] Order completed! State: %s\n", o.ID, o.State.GetName())
    return nil
}

func (s *ShippedState) Cancel(o *Order) error {
    return errors.New("cannot cancel: order already shipped")
}

// ===== çŠ¶æ€4ï¼šå·²å®Œæˆ =====
type CompletedState struct{}

func (s *CompletedState) GetName() string {
    return "Completed"
}

func (s *CompletedState) Pay(o *Order) error {
    return errors.New("order already completed")
}

func (s *CompletedState) Ship(o *Order) error {
    return errors.New("order already completed")
}

func (s *CompletedState) Complete(o *Order) error {
    return errors.New("order already completed")
}

func (s *CompletedState) Cancel(o *Order) error {
    return errors.New("cannot cancel: order already completed")
}

// ===== çŠ¶æ€5ï¼šå·²å–æ¶ˆ =====
type CancelledState struct{}

func (s *CancelledState) GetName() string {
    return "Cancelled"
}

func (s *CancelledState) Pay(o *Order) error {
    return errors.New("order cancelled")
}

func (s *CancelledState) Ship(o *Order) error {
    return errors.New("order cancelled")
}

func (s *CancelledState) Complete(o *Order) error {
    return errors.New("order cancelled")
}

func (s *CancelledState) Cancel(o *Order) error {
    return errors.New("order already cancelled")
}

// ===== ä½¿ç”¨ç¤ºä¾‹ =====
func Example() {
    // åœºæ™¯1ï¼šæ­£å¸¸æµç¨‹
    fmt.Println("=== Scenario 1: Normal Flow ===")
    order1 := NewOrder("ORDER-001")
    fmt.Printf("Order created: %s\n\n", order1.GetStatus())
    
    order1.Pay()
    order1.Ship()
    order1.Complete()
    
    fmt.Printf("\nFinal status: %s\n", order1.GetStatus())
    
    // åœºæ™¯2ï¼šå–æ¶ˆè®¢å•
    fmt.Println("\n=== Scenario 2: Cancel Order ===")
    order2 := NewOrder("ORDER-002")
    
    if err := order2.Cancel(); err != nil {
        fmt.Printf("Error: %v\n", err)
    }
    fmt.Printf("Final status: %s\n", order2.GetStatus())
    
    // åœºæ™¯3ï¼šéæ³•æ“ä½œ
    fmt.Println("\n=== Scenario 3: Invalid Operation ===")
    order3 := NewOrder("ORDER-003")
    
    if err := order3.Ship(); err != nil {
        fmt.Printf("Error: %v\n", err)
    }
}
```

---

## ç¬¬ä¸ƒéƒ¨åˆ†ï¼šå…¶ä»–è¡Œä¸ºå‹æ¨¡å¼

### 7.1 æ¨¡æ¿æ–¹æ³•æ¨¡å¼

```go
// æ•°æ®å¤„ç†æ¨¡æ¿
type DataProcessor interface {
    ReadData() []byte
    ProcessData([]byte) []byte
    WriteData([]byte)
}

type BaseProcessor struct {
    processor DataProcessor
}

func (b *BaseProcessor) Execute() {
    data := b.processor.ReadData()
    processed := b.processor.ProcessData(data)
    b.processor.WriteData(processed)
}
```

### 7.2 è¿­ä»£å™¨æ¨¡å¼

```go
// Goä¸­ä½¿ç”¨rangeå®ç°
type Collection struct {
    items []int
}

func (c *Collection) Iterator() <-chan int {
    ch := make(chan int)
    go func() {
        defer close(ch)
        for _, item := range c.items {
            ch <- item
        }
    }()
    return ch
}
```

### 7.3 å¤‡å¿˜å½•æ¨¡å¼

```go
// ç¼–è¾‘å™¨æ’¤é”€åŠŸèƒ½
type Editor struct {
    content string
}

type Memento struct {
    state string
}

func (e *Editor) Save() *Memento {
    return &Memento{state: e.content}
}

func (e *Editor) Restore(m *Memento) {
    e.content = m.state
}
```

---

## ç¬¬å…«éƒ¨åˆ†ï¼šå®æˆ˜æ¡ˆä¾‹

### 8.1 ç»¼åˆæ¡ˆä¾‹ï¼šå·¥ä½œæµå¼•æ“

ç»“åˆå¤šç§è¡Œä¸ºå‹æ¨¡å¼ï¼š

- **çŠ¶æ€æ¨¡å¼**: å·¥ä½œæµçŠ¶æ€æœº
- **è´£ä»»é“¾æ¨¡å¼**: å®¡æ‰¹æµ
- **å‘½ä»¤æ¨¡å¼**: æ“ä½œå†å²
- **è§‚å¯Ÿè€…æ¨¡å¼**: çŠ¶æ€å˜æ›´é€šçŸ¥

---

## ç¬¬ä¹éƒ¨åˆ†ï¼šæœ€ä½³å®è·µ

### 9.1 è¡Œä¸ºå‹æ¨¡å¼é€‰æ‹©æŒ‡å—

| åœºæ™¯ | æ¨èæ¨¡å¼ | åŸå›  |
|------|---------|------|
| å¤šç§ç®—æ³•åˆ‡æ¢ | ç­–ç•¥æ¨¡å¼ | ç®—æ³•å°è£… |
| äº‹ä»¶é©±åŠ¨ | è§‚å¯Ÿè€…æ¨¡å¼ | è§£è€¦é€šçŸ¥ |
| è¯·æ±‚å¤„ç†é“¾ | è´£ä»»é“¾æ¨¡å¼ | åŠ¨æ€ç»„åˆ |
| ä»»åŠ¡é˜Ÿåˆ— | å‘½ä»¤æ¨¡å¼ | è¯·æ±‚å°è£… |
| çŠ¶æ€åˆ‡æ¢ | çŠ¶æ€æ¨¡å¼ | è¡Œä¸ºå˜åŒ– |

### 9.2 å¸¸è§é™·é˜±

1. **ç­–ç•¥æ¨¡å¼ï¼šç­–ç•¥çˆ†ç‚¸**
2. **è§‚å¯Ÿè€…æ¨¡å¼ï¼šå†…å­˜æ³„æ¼**
3. **è´£ä»»é“¾æ¨¡å¼ï¼šé“¾è¿‡é•¿**

---

## ğŸ¯ æ€»ç»“

è¡Œä¸ºå‹æ¨¡å¼æ˜¯æœ€å®ç”¨å’Œæœ€å¤æ‚çš„è®¾è®¡æ¨¡å¼ï¼ŒæŒæ¡å®ƒä»¬èƒ½å¤§å¹…æå‡ä»£ç çš„çµæ´»æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬**: v4.0  
**æœ€åæ›´æ–°**: 2025-10-20

<div align="center">

Made with â¤ï¸ for Go Developers

[â¬† å›åˆ°é¡¶éƒ¨](#goè¡Œä¸ºå‹è®¾è®¡æ¨¡å¼æ·±åº¦å®æˆ˜æŒ‡å—)

</div>
