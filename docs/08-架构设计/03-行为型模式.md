# Go行为型设计模式深度实战指南


**字数**: ~19,000字  
**代码示例**: 45+个完整示例  
**实战案例**: 5个端到端案例  
**适用人群**: 中高级Go开发者

---

## 📚 目录

<!-- TOC -->
- [第一部分：理论基础](#第一部分理论基础)
- [第二部分：策略模式深度实战](#第二部分策略模式深度实战)
- [第三部分：观察者模式深度实战](#第三部分观察者模式深度实战)
- [第四部分：责任链模式深度实战](#第四部分责任链模式深度实战)
- [第五部分：命令模式深度实战](#第五部分命令模式深度实战)
- [第六部分：状态模式深度实战](#第六部分状态模式深度实战)
- [第七部分：其他行为型模式](#第七部分其他行为型模式)
- [第八部分：实战案例](#第八部分实战案例)
- [第九部分：最佳实践](#第九部分最佳实践)
<!-- TOC -->

---

## 第一部分：理论基础

### 行为型模式的价值

#### 为什么需要行为型模式？

**问题示例**:

```go
// ❌ 硬编码算法选择的问题
func processPayment(method string, amount float64) error {
    if method == "alipay" {
        // 支付宝逻辑
        return processAlipay(amount)
    } else if method == "wechat" {
        // 微信支付逻辑
        return processWechat(amount)
    } else if method == "credit_card" {
        // 信用卡逻辑
        return processCreditCard(amount)
    }
    // 问题：
    // 1. 添加新支付方式需要修改此函数
    // 2. 违反开闭原则
    // 3. 难以测试和维护
    return errors.New("unsupported payment method")
}
```

**使用行为型模式后**:

```go
// ✅ 使用策略模式
type PaymentStrategy interface {
    Pay(amount float64) error
}

type PaymentContext struct {
    strategy PaymentStrategy
}

func (c *PaymentContext) ProcessPayment(amount float64) error {
    return c.strategy.Pay(amount)
}

// 优势：
// 1. 添加新支付方式只需实现接口
// 2. 符合开闭原则
// 3. 易于测试和维护
```

---

### 行为型模式分类

| 模式 | 意图 | 适用场景 | 复杂度 |
|------|------|---------|--------|
| **策略** | 算法族封装 | 多种算法切换 | ⭐⭐ |
| **观察者** | 一对多通知 | 事件驱动系统 | ⭐⭐⭐ |
| **责任链** | 链式处理 | 中间件、过滤器 | ⭐⭐⭐ |
| **命令** | 请求封装 | 任务队列、撤销 | ⭐⭐⭐ |
| **状态** | 状态切换 | 状态机、工作流 | ⭐⭐⭐⭐ |
| **模板方法** | 流程骨架 | 流程规范化 | ⭐⭐ |
| **迭代器** | 顺序访问 | 集合遍历 | ⭐⭐ |
| **中介者** | 对象协作 | 复杂交互解耦 | ⭐⭐⭐⭐ |
| **备忘录** | 状态快照 | 撤销、历史记录 | ⭐⭐ |
| **访问者** | 操作分离 | 对象结构稳定 | ⭐⭐⭐⭐⭐ |
| **解释器** | 文法解释 | DSL、规则引擎 | ⭐⭐⭐⭐⭐ |

---

### 选择行为型模式的决策树

```text
你的需求是什么？
│
├─ 需要在运行时切换算法？
│  └─ 是 → 策略模式
│      - 多种支付方式
│      - 多种排序算法
│
├─ 需要对象间一对多通知？
│  └─ 是 → 观察者模式
│      - 事件系统
│      - 消息订阅
│
├─ 需要链式处理请求？
│  └─ 是 → 责任链模式
│      - HTTP中间件
│      - 审批流程
│
├─ 需要封装请求为对象？
│  └─ 是 → 命令模式
│      - 任务队列
│      - 撤销/重做
│
├─ 需要根据状态改变行为？
│  └─ 是 → 状态模式
│      - 订单状态机
│      - TCP连接状态
│
└─ 需要定义流程骨架？
   └─ 是 → 模板方法模式
       - 数据处理流程
       - 测试框架
```

---

## 第二部分：策略模式深度实战

### 策略模式核心原理

#### 什么是策略模式？

**定义**: 定义一系列算法，把它们各自封装起来，并且使它们可以互相替换。策略模式让算法独立于使用它的客户端。

**UML结构**:

```text
Context
  ↓ has-a
Strategy Interface
  ↑ implements
  ├─ ConcreteStrategyA
  ├─ ConcreteStrategyB
  └─ ConcreteStrategyC
```

**核心特点**:

1. 定义算法族
2. 封装每个算法
3. 运行时切换算法
4. 符合开闭原则

---

### 策略模式完整实现

#### 基础策略模式

```go
package strategy

import "fmt"

// Strategy 策略接口
type Strategy interface {
    Execute(a, b int) int
}

// ===== 具体策略1：加法 =====
type AddStrategy struct{}

func (s *AddStrategy) Execute(a, b int) int {
    return a + b
}

// ===== 具体策略2：减法 =====
type SubtractStrategy struct{}

func (s *SubtractStrategy) Execute(a, b int) int {
    return a - b
}

// ===== 具体策略3：乘法 =====
type MultiplyStrategy struct{}

func (s *MultiplyStrategy) Execute(a, b int) int {
    return a * b
}

// ===== Context上下文 =====
type Context struct {
    strategy Strategy
}

func NewContext(strategy Strategy) *Context {
    return &Context{strategy: strategy}
}

func (c *Context) SetStrategy(strategy Strategy) {
    c.strategy = strategy
}

func (c *Context) ExecuteStrategy(a, b int) int {
    return c.strategy.Execute(a, b)
}

// ===== 使用示例 =====
func Example() {
    // 1. 使用加法策略
    context := NewContext(&AddStrategy{})
    result := context.ExecuteStrategy(5, 3)
    fmt.Println("5 + 3 =", result)  // 8
    
    // 2. 运行时切换到减法策略
    context.SetStrategy(&SubtractStrategy{})
    result = context.ExecuteStrategy(5, 3)
    fmt.Println("5 - 3 =", result)  // 2
    
    // 3. 切换到乘法策略
    context.SetStrategy(&MultiplyStrategy{})
    result = context.ExecuteStrategy(5, 3)
    fmt.Println("5 * 3 =", result)  // 15
}
```

---

### 实战案例1：多支付方式策略

#### 场景

- 电商系统支持多种支付方式
- 支付宝、微信支付、信用卡
- 运行时动态选择支付方式

#### 完整实现

```go
package payment

import (
    "context"
    "errors"
    "fmt"
    "time"
)

// PaymentStrategy 支付策略接口
type PaymentStrategy interface {
    Pay(ctx context.Context, amount float64) (*PaymentResult, error)
    GetName() string
}

// PaymentResult 支付结果
type PaymentResult struct {
    TransactionID string
    Status        string
    PaidAt        time.Time
}

// ===== 策略1：支付宝 =====
type AlipayStrategy struct {
    appID     string
    secretKey string
}

func NewAlipayStrategy(appID, secretKey string) PaymentStrategy {
    return &AlipayStrategy{
        appID:     appID,
        secretKey: secretKey,
    }
}

func (a *AlipayStrategy) Pay(ctx context.Context, amount float64) (*PaymentResult, error) {
    fmt.Printf("[Alipay] Processing payment: ¥%.2f\n", amount)
    
    // 模拟调用支付宝API
    time.Sleep(100 * time.Millisecond)
    
    return &PaymentResult{
        TransactionID: fmt.Sprintf("alipay_%d", time.Now().Unix()),
        Status:        "success",
        PaidAt:        time.Now(),
    }, nil
}

func (a *AlipayStrategy) GetName() string {
    return "Alipay"
}

// ===== 策略2：微信支付 =====
type WechatPayStrategy struct {
    merchantID string
    apiKey     string
}

func NewWechatPayStrategy(merchantID, apiKey string) PaymentStrategy {
    return &WechatPayStrategy{
        merchantID: merchantID,
        apiKey:     apiKey,
    }
}

func (w *WechatPayStrategy) Pay(ctx context.Context, amount float64) (*PaymentResult, error) {
    fmt.Printf("[WeChat Pay] Processing payment: ¥%.2f\n", amount)
    
    // 模拟调用微信支付API
    time.Sleep(120 * time.Millisecond)
    
    return &PaymentResult{
        TransactionID: fmt.Sprintf("wx_%d", time.Now().Unix()),
        Status:        "success",
        PaidAt:        time.Now(),
    }, nil
}

func (w *WechatPayStrategy) GetName() string {
    return "WeChat Pay"
}

// ===== 策略3：信用卡 =====
type CreditCardStrategy struct {
    cardNumber string
    cvv        string
}

func NewCreditCardStrategy(cardNumber, cvv string) PaymentStrategy {
    return &CreditCardStrategy{
        cardNumber: cardNumber,
        cvv:        cvv,
    }
}

func (c *CreditCardStrategy) Pay(ctx context.Context, amount float64) (*PaymentResult, error) {
    fmt.Printf("[Credit Card] Processing payment: $%.2f\n", amount)
    
    // 验证信用卡
    if len(c.cardNumber) != 16 {
        return nil, errors.New("invalid card number")
    }
    
    // 模拟调用银行API
    time.Sleep(150 * time.Millisecond)
    
    return &PaymentResult{
        TransactionID: fmt.Sprintf("cc_%d", time.Now().Unix()),
        Status:        "success",
        PaidAt:        time.Now(),
    }, nil
}

func (c *CreditCardStrategy) GetName() string {
    return "Credit Card"
}

// ===== 支付上下文 =====
type PaymentContext struct {
    strategy PaymentStrategy
}

func NewPaymentContext(strategy PaymentStrategy) *PaymentContext {
    return &PaymentContext{strategy: strategy}
}

func (p *PaymentContext) SetStrategy(strategy PaymentStrategy) {
    p.strategy = strategy
}

func (p *PaymentContext) ProcessPayment(ctx context.Context, amount float64) (*PaymentResult, error) {
    fmt.Printf("Using payment method: %s\n", p.strategy.GetName())
    return p.strategy.Pay(ctx, amount)
}

// ===== 策略工厂 =====
func CreatePaymentStrategy(paymentType string) (PaymentStrategy, error) {
    switch paymentType {
    case "alipay":
        return NewAlipayStrategy("app123", "secret456"), nil
    case "wechat":
        return NewWechatPayStrategy("merchant789", "key012"), nil
    case "credit_card":
        return NewCreditCardStrategy("1234567890123456", "123"), nil
    default:
        return nil, errors.New("unsupported payment type")
    }
}

// ===== 使用示例 =====
func ExamplePayment() {
    ctx := context.Background()
    
    // 场景1：用户选择支付宝
    alipayStrategy, _ := CreatePaymentStrategy("alipay")
    paymentCtx := NewPaymentContext(alipayStrategy)
    
    result, err := paymentCtx.ProcessPayment(ctx, 99.99)
    if err != nil {
        fmt.Println("Payment failed:", err)
        return
    }
    fmt.Printf("Payment successful! Transaction ID: %s\n\n", result.TransactionID)
    
    // 场景2：用户切换到微信支付
    wechatStrategy, _ := CreatePaymentStrategy("wechat")
    paymentCtx.SetStrategy(wechatStrategy)
    
    result, err = paymentCtx.ProcessPayment(ctx, 199.99)
    if err != nil {
        fmt.Println("Payment failed:", err)
        return
    }
    fmt.Printf("Payment successful! Transaction ID: %s\n", result.TransactionID)
}
```

#### 输出

```text
Using payment method: Alipay
[Alipay] Processing payment: ¥99.99
Payment successful! Transaction ID: alipay_1697234567

Using payment method: WeChat Pay
[WeChat Pay] Processing payment: ¥199.99
Payment successful! Transaction ID: wx_1697234568
```

---

### 策略模式最佳实践

#### ✅ DO

1. **使用接口定义策略**:

    ```go
    // ✅ 正确
    type CompressionStrategy interface {
        Compress(data []byte) ([]byte, error)
    }
    ```

2. **策略工厂简化创建**:

    ```go
    // ✅ 正确
    func CreateCompressor(algo string) CompressionStrategy {
        switch algo {
        case "gzip":
            return &GzipStrategy{}
        case "lz4":
            return &LZ4Strategy{}
        default:
            return &NoCompressionStrategy{}
        }
    }
    ```

#### ❌ DON'T

1. **不要在Context中包含业务逻辑**:

    ```go
    // ❌ 错误
    func (c *Context) Execute() {
        // 业务逻辑应该在Service层
        if someCondition {
            c.strategy.Execute()
        }
    }
    ```

---

## 第三部分：观察者模式深度实战

### 观察者模式核心原理

#### 什么是观察者模式？

**定义**: 定义对象间的一对多依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。

**UML结构**:

```text
Subject
  ↓ notifies
Observer Interface
  ↑ implements
  ├─ ConcreteObserverA
  ├─ ConcreteObserverB
  └─ ConcreteObserverC
```

---

### 实战案例2：事件总线

#### 场景3

- 用户注册后需要：发送邮件、发送短信、记录日志、增加积分
- 新增功能不应修改注册逻辑
- 异步通知，不阻塞主流程

#### 完整实现3

```go
package eventbus

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// Event 事件
type Event struct {
    Type      string
    Data      interface{}
    Timestamp time.Time
}

// Observer 观察者接口
type Observer interface {
    OnEvent(ctx context.Context, event Event) error
    GetID() string
}

// ===== 事件总线（Subject）=====
type EventBus struct {
    observers map[string][]Observer
    mu        sync.RWMutex
}

func NewEventBus() *EventBus {
    return &EventBus{
        observers: make(map[string][]Observer),
    }
}

// Subscribe 订阅事件
func (e *EventBus) Subscribe(eventType string, observer Observer) {
    e.mu.Lock()
    defer e.mu.Unlock()
    
    e.observers[eventType] = append(e.observers[eventType], observer)
    fmt.Printf("[EventBus] %s subscribed to %s\n", observer.GetID(), eventType)
}

// Unsubscribe 取消订阅
func (e *EventBus) Unsubscribe(eventType string, observerID string) {
    e.mu.Lock()
    defer e.mu.Unlock()
    
    observers := e.observers[eventType]
    for i, obs := range observers {
        if obs.GetID() == observerID {
            e.observers[eventType] = append(observers[:i], observers[i+1:]...)
            fmt.Printf("[EventBus] %s unsubscribed from %s\n", observerID, eventType)
            return
        }
    }
}

// Publish 发布事件（异步通知所有观察者）
func (e *EventBus) Publish(ctx context.Context, event Event) {
    e.mu.RLock()
    observers := e.observers[event.Type]
    e.mu.RUnlock()
    
    fmt.Printf("[EventBus] Publishing event: %s\n", event.Type)
    
    // 异步并发通知
    var wg sync.WaitGroup
    for _, observer := range observers {
        wg.Add(1)
        go func(obs Observer) {
            defer wg.Done()
            if err := obs.OnEvent(ctx, event); err != nil {
                fmt.Printf("[EventBus] Error notifying %s: %v\n", obs.GetID(), err)
            }
        }(observer)
    }
    
    wg.Wait()
    fmt.Println("[EventBus] All observers notified")
}

// ===== 观察者1：邮件服务 =====
type EmailObserver struct {
    id string
}

func NewEmailObserver() Observer {
    return &EmailObserver{id: "EmailService"}
}

func (e *EmailObserver) GetID() string {
    return e.id
}

func (e *EmailObserver) OnEvent(ctx context.Context, event Event) error {
    userData := event.Data.(map[string]interface{})
    email := userData["email"].(string)
    
    fmt.Printf("[Email] Sending welcome email to %s...\n", email)
    time.Sleep(100 * time.Millisecond)  // 模拟发送邮件
    fmt.Printf("[Email] Email sent successfully!\n")
    
    return nil
}

// ===== 观察者2：短信服务 =====
type SMSObserver struct {
    id string
}

func NewSMSObserver() Observer {
    return &SMSObserver{id: "SMSService"}
}

func (s *SMSObserver) GetID() string {
    return s.id
}

func (s *SMSObserver) OnEvent(ctx context.Context, event Event) error {
    userData := event.Data.(map[string]interface{})
    phone := userData["phone"].(string)
    
    fmt.Printf("[SMS] Sending welcome SMS to %s...\n", phone)
    time.Sleep(80 * time.Millisecond)  // 模拟发送短信
    fmt.Printf("[SMS] SMS sent successfully!\n")
    
    return nil
}

// ===== 观察者3：日志服务 =====
type LogObserver struct {
    id string
}

func NewLogObserver() Observer {
    return &LogObserver{id: "LogService"}
}

func (l *LogObserver) GetID() string {
    return l.id
}

func (l *LogObserver) OnEvent(ctx context.Context, event Event) error {
    userData := event.Data.(map[string]interface{})
    username := userData["username"].(string)
    
    fmt.Printf("[Log] Recording user registration: %s at %v\n", username, event.Timestamp)
    return nil
}

// ===== 观察者4：积分服务 =====
type PointsObserver struct {
    id string
}

func NewPointsObserver() Observer {
    return &PointsObserver{id: "PointsService"}
}

func (p *PointsObserver) GetID() string {
    return p.id
}

func (p *PointsObserver) OnEvent(ctx context.Context, event Event) error {
    userData := event.Data.(map[string]interface{})
    username := userData["username"].(string)
    
    fmt.Printf("[Points] Awarding 100 points to %s\n", username)
    return nil
}

// ===== 用户服务（使用事件总线）=====
type UserService struct {
    eventBus *EventBus
}

func NewUserService(eventBus *EventBus) *UserService {
    return &UserService{eventBus: eventBus}
}

func (u *UserService) RegisterUser(ctx context.Context, username, email, phone string) error {
    fmt.Printf("\n=== Registering user: %s ===\n", username)
    
    // 1. 注册业务逻辑
    fmt.Println("[UserService] Creating user account...")
    time.Sleep(50 * time.Millisecond)
    fmt.Println("[UserService] User account created!")
    
    // 2. 发布用户注册事件
    event := Event{
        Type: "user.registered",
        Data: map[string]interface{}{
            "username": username,
            "email":    email,
            "phone":    phone,
        },
        Timestamp: time.Now(),
    }
    
    u.eventBus.Publish(ctx, event)
    
    fmt.Println("=== User registration completed ===\n")
    return nil
}

// ===== 使用示例 =====
func Example() {
    ctx := context.Background()
    
    // 1. 创建事件总线
    eventBus := NewEventBus()
    
    // 2. 注册观察者
    eventBus.Subscribe("user.registered", NewEmailObserver())
    eventBus.Subscribe("user.registered", NewSMSObserver())
    eventBus.Subscribe("user.registered", NewLogObserver())
    eventBus.Subscribe("user.registered", NewPointsObserver())
    
    // 3. 创建用户服务
    userService := NewUserService(eventBus)
    
    // 4. 注册用户（触发事件）
    userService.RegisterUser(ctx, "john_doe", "john@example.com", "13800138000")
}
```

#### 输出3

```text
=== Registering user: john_doe ===
[UserService] Creating user account...
[UserService] User account created!
[EventBus] Publishing event: user.registered
[Email] Sending welcome email to john@example.com...
[SMS] Sending welcome SMS to 13800138000...
[Log] Recording user registration: john_doe at 2025-10-20 10:30:45
[Points] Awarding 100 points to john_doe
[Email] Email sent successfully!
[SMS] SMS sent successfully!
[EventBus] All observers notified
=== User registration completed ===
```

---

### 观察者模式最佳实践

#### ✅ DO4

1. **异步通知观察者**:

    ```go
    // ✅ 正确：并发通知
    for _, observer := range observers {
        go observer.Notify(event)
    }
    ```

2. **错误隔离**:

    ```go
    // ✅ 正确：单个观察者失败不影响其他
    defer func() {
        if r := recover(); r != nil {
            log.Printf("Observer panic: %v", r)
        }
    }()
    ```

#### ❌ DON'T4

1. **不要同步阻塞通知**:

    ```go
    // ❌ 错误：同步通知会阻塞主流程
    for _, observer := range observers {
        observer.Notify(event)  // 阻塞
    }
    ```

---

## 第四部分：责任链模式深度实战

### 责任链模式核心原理

#### 什么是责任链模式？

**定义**: 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

---

### 实战案例3：HTTP中间件

#### 场景5

- HTTP服务需要：认证、日志、限流、压缩
- 中间件可以动态组合
- 中间件可以中断请求

#### 完整实现5

```go
package middleware

import (
    "compress/gzip"
    "context"
    "fmt"
    "net/http"
    "strings"
    "sync"
    "time"
)

// Handler 处理器接口
type Handler interface {
    Handle(ctx context.Context, req *Request) (*Response, error)
}

// Request 请求
type Request struct {
    Method  string
    Path    string
    Headers map[string]string
    Body    []byte
    UserID  string  // 认证后填充
}

// Response 响应
type Response struct {
    StatusCode int
    Body       []byte
    Headers    map[string]string
}

// ===== 中间件接口 =====
type Middleware func(Handler) Handler

// ===== 中间件1：日志中间件 =====
func LoggingMiddleware() Middleware {
    return func(next Handler) Handler {
        return HandlerFunc(func(ctx context.Context, req *Request) (*Response, error) {
            start := time.Now()
            
            fmt.Printf("[Log] --> %s %s\n", req.Method, req.Path)
            
            resp, err := next.Handle(ctx, req)
            
            elapsed := time.Since(start)
            if err != nil {
                fmt.Printf("[Log] <-- ERROR: %v (took %v)\n", err, elapsed)
            } else {
                fmt.Printf("[Log] <-- %d (took %v)\n", resp.StatusCode, elapsed)
            }
            
            return resp, err
        })
    }
}

// ===== 中间件2：认证中间件 =====
func AuthMiddleware(validTokens map[string]string) Middleware {
    return func(next Handler) Handler {
        return HandlerFunc(func(ctx context.Context, req *Request) (*Response, error) {
            token := req.Headers["Authorization"]
            
            fmt.Printf("[Auth] Checking token: %s\n", token)
            
            if token == "" {
                return &Response{
                    StatusCode: 401,
                    Body:       []byte("Unauthorized: missing token"),
                }, nil
            }
            
            userID, exists := validTokens[token]
            if !exists {
                return &Response{
                    StatusCode: 401,
                    Body:       []byte("Unauthorized: invalid token"),
                }, nil
            }
            
            // 认证成功，设置userID
            req.UserID = userID
            fmt.Printf("[Auth] Authenticated as: %s\n", userID)
            
            return next.Handle(ctx, req)
        })
    }
}

// ===== 中间件3：限流中间件 =====
func RateLimitMiddleware(requestsPerSecond int) Middleware {
    tokens := requestsPerSecond
    maxTokens := requestsPerSecond
    lastRefill := time.Now()
    var mu sync.Mutex
    
    return func(next Handler) Handler {
        return HandlerFunc(func(ctx context.Context, req *Request) (*Response, error) {
            mu.Lock()
            
            // 令牌桶算法
            elapsed := time.Since(lastRefill)
            if elapsed > time.Second {
                tokens = maxTokens
                lastRefill = time.Now()
            }
            
            if tokens <= 0 {
                mu.Unlock()
                fmt.Println("[RateLimit] Request rejected - too many requests")
                return &Response{
                    StatusCode: 429,
                    Body:       []byte("Too Many Requests"),
                }, nil
            }
            
            tokens--
            fmt.Printf("[RateLimit] Request allowed, tokens left: %d\n", tokens)
            mu.Unlock()
            
            return next.Handle(ctx, req)
        })
    }
}

// ===== 中间件4：压缩中间件 =====
func CompressionMiddleware() Middleware {
    return func(next Handler) Handler {
        return HandlerFunc(func(ctx context.Context, req *Request) (*Response, error) {
            resp, err := next.Handle(ctx, req)
            if err != nil || resp == nil {
                return resp, err
            }
            
            // 检查是否支持gzip
            if strings.Contains(req.Headers["Accept-Encoding"], "gzip") && len(resp.Body) > 100 {
                fmt.Println("[Compression] Compressing response...")
                
                // 简化：实际应使用gzip压缩
                originalSize := len(resp.Body)
                compressedSize := originalSize / 2  // 模拟压缩
                
                if resp.Headers == nil {
                    resp.Headers = make(map[string]string)
                }
                resp.Headers["Content-Encoding"] = "gzip"
                
                fmt.Printf("[Compression] Size: %d → %d bytes (%.1f%% reduction)\n",
                    originalSize, compressedSize, (1-float64(compressedSize)/float64(originalSize))*100)
            }
            
            return resp, nil
        })
    }
}

// ===== HandlerFunc（函数适配器）=====
type HandlerFunc func(context.Context, *Request) (*Response, error)

func (f HandlerFunc) Handle(ctx context.Context, req *Request) (*Response, error) {
    return f(ctx, req)
}

// ===== 责任链构建器 =====
func Chain(handler Handler, middlewares ...Middleware) Handler {
    // 从后往前包装
    for i := len(middlewares) - 1; i >= 0; i-- {
        handler = middlewares[i](handler)
    }
    return handler
}

// ===== 业务处理器 =====
func BusinessHandler() Handler {
    return HandlerFunc(func(ctx context.Context, req *Request) (*Response, error) {
        fmt.Printf("[Handler] Processing request for user: %s\n", req.UserID)
        
        // 模拟业务逻辑
        time.Sleep(10 * time.Millisecond)
        
        responseBody := fmt.Sprintf("Hello, %s! Your request to %s was successful.", req.UserID, req.Path)
        
        return &Response{
            StatusCode: 200,
            Body:       []byte(responseBody),
        }, nil
    })
}

// ===== 使用示例 =====
func Example() {
    ctx := context.Background()
    
    // 1. 定义有效token
    validTokens := map[string]string{
        "token123": "user_alice",
        "token456": "user_bob",
    }
    
    // 2. 构建中间件链
    handler := Chain(
        BusinessHandler(),
        LoggingMiddleware(),
        RateLimitMiddleware(10),
        AuthMiddleware(validTokens),
        CompressionMiddleware(),
    )
    
    // 3. 测试请求1：成功
    fmt.Println("\n=== Request 1: Valid Token ===")
    req1 := &Request{
        Method: "GET",
        Path:   "/api/users",
        Headers: map[string]string{
            "Authorization":   "token123",
            "Accept-Encoding": "gzip",
        },
    }
    resp1, _ := handler.Handle(ctx, req1)
    fmt.Printf("Response: %d - %s\n", resp1.StatusCode, string(resp1.Body))
    
    // 4. 测试请求2：无token
    fmt.Println("\n=== Request 2: No Token ===")
    req2 := &Request{
        Method:  "GET",
        Path:    "/api/orders",
        Headers: map[string]string{},
    }
    resp2, _ := handler.Handle(ctx, req2)
    fmt.Printf("Response: %d - %s\n", resp2.StatusCode, string(resp2.Body))
}
```

#### 输出5

```text
=== Request 1: Valid Token ===
[Log] --> GET /api/users
[RateLimit] Request allowed, tokens left: 9
[Auth] Checking token: token123
[Auth] Authenticated as: user_alice
[Handler] Processing request for user: user_alice
[Compression] Compressing response...
[Compression] Size: 68 → 34 bytes (50.0% reduction)
[Log] <-- 200 (took 12ms)
Response: 200 - Hello, user_alice! Your request to /api/users was successful.

=== Request 2: No Token ===
[Log] --> GET /api/orders
[RateLimit] Request allowed, tokens left: 8
[Auth] Checking token: 
[Log] <-- 401 (took 0.2ms)
Response: 401 - Unauthorized: missing token
```

---

## 第五部分：命令模式深度实战

### 命令模式核心原理

**定义**: 将请求封装成对象，从而可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

---

### 实战案例4：任务调度器

#### 场景6

- 异步任务执行
- 支持任务队列
- 支持撤销/重做
- 任务执行历史

#### 完整实现6

```go
package scheduler

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// Command 命令接口
type Command interface {
    Execute(ctx context.Context) error
    Undo(ctx context.Context) error
    GetID() string
    GetDescription() string
}

// ===== 具体命令1：发送邮件 =====
type SendEmailCommand struct {
    id      string
    to      string
    subject string
    body    string
    sent    bool
}

func NewSendEmailCommand(to, subject, body string) Command {
    return &SendEmailCommand{
        id:      fmt.Sprintf("email_%d", time.Now().UnixNano()),
        to:      to,
        subject: subject,
        body:    body,
    }
}

func (c *SendEmailCommand) Execute(ctx context.Context) error {
    fmt.Printf("[Email] Sending to %s: %s\n", c.to, c.subject)
    time.Sleep(100 * time.Millisecond)  // 模拟发送
    c.sent = true
    fmt.Println("[Email] Sent successfully!")
    return nil
}

func (c *SendEmailCommand) Undo(ctx context.Context) error {
    if !c.sent {
        return fmt.Errorf("email not sent yet")
    }
    fmt.Printf("[Email] Recalling email to %s\n", c.to)
    c.sent = false
    return nil
}

func (c *SendEmailCommand) GetID() string {
    return c.id
}

func (c *SendEmailCommand) GetDescription() string {
    return fmt.Sprintf("Send email to %s", c.to)
}

// ===== 具体命令2：数据库备份 =====
type BackupDatabaseCommand struct {
    id         string
    database   string
    backupPath string
    completed  bool
}

func NewBackupDatabaseCommand(database, backupPath string) Command {
    return &BackupDatabaseCommand{
        id:         fmt.Sprintf("backup_%d", time.Now().UnixNano()),
        database:   database,
        backupPath: backupPath,
    }
}

func (c *BackupDatabaseCommand) Execute(ctx context.Context) error {
    fmt.Printf("[Backup] Backing up database %s to %s\n", c.database, c.backupPath)
    time.Sleep(200 * time.Millisecond)  // 模拟备份
    c.completed = true
    fmt.Println("[Backup] Backup completed!")
    return nil
}

func (c *BackupDatabaseCommand) Undo(ctx context.Context) error {
    if !c.completed {
        return fmt.Errorf("backup not completed yet")
    }
    fmt.Printf("[Backup] Deleting backup: %s\n", c.backupPath)
    c.completed = false
    return nil
}

func (c *BackupDatabaseCommand) GetID() string {
    return c.id
}

func (c *BackupDatabaseCommand) GetDescription() string {
    return fmt.Sprintf("Backup database %s", c.database)
}

// ===== 任务调度器（Invoker）=====
type TaskScheduler struct {
    queue   []Command
    history []Command
    mu      sync.Mutex
    ctx     context.Context
    cancel  context.CancelFunc
    wg      sync.WaitGroup
}

func NewTaskScheduler() *TaskScheduler {
    ctx, cancel := context.WithCancel(context.Background())
    scheduler := &TaskScheduler{
        queue:   make([]Command, 0),
        history: make([]Command, 0),
        ctx:     ctx,
        cancel:  cancel,
    }
    
    // 启动worker
    scheduler.wg.Add(1)
    go scheduler.worker()
    
    return scheduler
}

// AddTask 添加任务到队列
func (s *TaskScheduler) AddTask(cmd Command) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    s.queue = append(s.queue, cmd)
    fmt.Printf("[Scheduler] Task added: %s (Queue size: %d)\n", cmd.GetDescription(), len(s.queue))
}

// worker 后台worker执行任务
func (s *TaskScheduler) worker() {
    defer s.wg.Done()
    
    ticker := time.NewTicker(100 * time.Millisecond)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            s.mu.Lock()
            if len(s.queue) > 0 {
                // 取出第一个任务
                cmd := s.queue[0]
                s.queue = s.queue[1:]
                s.mu.Unlock()
                
                // 执行任务
                fmt.Printf("\n[Scheduler] Executing task: %s\n", cmd.GetDescription())
                if err := cmd.Execute(s.ctx); err != nil {
                    fmt.Printf("[Scheduler] Task failed: %v\n", err)
                } else {
                    // 成功后加入历史
                    s.mu.Lock()
                    s.history = append(s.history, cmd)
                    s.mu.Unlock()
                }
            } else {
                s.mu.Unlock()
            }
            
        case <-s.ctx.Done():
            return
        }
    }
}

// UndoLast 撤销最后一个任务
func (s *TaskScheduler) UndoLast() error {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    if len(s.history) == 0 {
        return fmt.Errorf("no tasks to undo")
    }
    
    // 取出最后一个任务
    lastCmd := s.history[len(s.history)-1]
    s.history = s.history[:len(s.history)-1]
    
    fmt.Printf("\n[Scheduler] Undoing task: %s\n", lastCmd.GetDescription())
    return lastCmd.Undo(s.ctx)
}

// GetHistory 获取历史
func (s *TaskScheduler) GetHistory() []string {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    history := make([]string, len(s.history))
    for i, cmd := range s.history {
        history[i] = cmd.GetDescription()
    }
    return history
}

// Shutdown 关闭调度器
func (s *TaskScheduler) Shutdown() {
    s.cancel()
    s.wg.Wait()
    fmt.Println("[Scheduler] Shutdown complete")
}

// ===== 使用示例 =====
func Example() {
    // 1. 创建调度器
    scheduler := NewTaskScheduler()
    defer scheduler.Shutdown()
    
    // 2. 添加多个任务
    scheduler.AddTask(NewSendEmailCommand("alice@example.com", "Welcome", "Hello Alice!"))
    scheduler.AddTask(NewBackupDatabaseCommand("users_db", "/backup/users.sql"))
    scheduler.AddTask(NewSendEmailCommand("bob@example.com", "Reminder", "Hello Bob!"))
    
    // 3. 等待任务执行
    time.Sleep(2 * time.Second)
    
    // 4. 查看历史
    fmt.Println("\n=== Task History ===")
    for i, desc := range scheduler.GetHistory() {
        fmt.Printf("%d. %s\n", i+1, desc)
    }
    
    // 5. 撤销最后一个任务
    scheduler.UndoLast()
    
    // 6. 查看更新后的历史
    fmt.Println("\n=== Updated History ===")
    for i, desc := range scheduler.GetHistory() {
        fmt.Printf("%d. %s\n", i+1, desc)
    }
}
```

---

## 第六部分：状态模式深度实战

### 实战案例5：订单状态机

#### 场景7

- 订单有多个状态：待支付、已支付、已发货、已完成、已取消
- 每个状态下允许不同操作
- 状态转换有规则

#### 完整实现7

```go
package order

import (
    "errors"
    "fmt"
    "time"
)

// State 状态接口
type State interface {
    Pay(*Order) error
    Ship(*Order) error
    Complete(*Order) error
    Cancel(*Order) error
    GetName() string
}

// Order 订单（Context）
type Order struct {
    ID          string
    State       State
    CreatedAt   time.Time
    PaidAt      time.Time
    ShippedAt   time.Time
    CompletedAt time.Time
}

func NewOrder(id string) *Order {
    order := &Order{
        ID:        id,
        CreatedAt: time.Now(),
    }
    order.State = &PendingPaymentState{}
    return order
}

func (o *Order) Pay() error {
    return o.State.Pay(o)
}

func (o *Order) Ship() error {
    return o.State.Ship(o)
}

func (o *Order) Complete() error {
    return o.State.Complete(o)
}

func (o *Order) Cancel() error {
    return o.State.Cancel(o)
}

func (o *Order) GetStatus() string {
    return o.State.GetName()
}

// ===== 状态1：待支付 =====
type PendingPaymentState struct{}

func (s *PendingPaymentState) GetName() string {
    return "PendingPayment"
}

func (s *PendingPaymentState) Pay(o *Order) error {
    fmt.Printf("[Order %s] Processing payment...\n", o.ID)
    o.PaidAt = time.Now()
    o.State = &PaidState{}
    fmt.Printf("[Order %s] Payment successful! State: %s\n", o.ID, o.State.GetName())
    return nil
}

func (s *PendingPaymentState) Ship(o *Order) error {
    return errors.New("cannot ship: order not paid yet")
}

func (s *PendingPaymentState) Complete(o *Order) error {
    return errors.New("cannot complete: order not paid yet")
}

func (s *PendingPaymentState) Cancel(o *Order) error {
    fmt.Printf("[Order %s] Cancelling unpaid order\n", o.ID)
    o.State = &CancelledState{}
    return nil
}

// ===== 状态2：已支付 =====
type PaidState struct{}

func (s *PaidState) GetName() string {
    return "Paid"
}

func (s *PaidState) Pay(o *Order) error {
    return errors.New("already paid")
}

func (s *PaidState) Ship(o *Order) error {
    fmt.Printf("[Order %s] Shipping order...\n", o.ID)
    o.ShippedAt = time.Now()
    o.State = &ShippedState{}
    fmt.Printf("[Order %s] Order shipped! State: %s\n", o.ID, o.State.GetName())
    return nil
}

func (s *PaidState) Complete(o *Order) error {
    return errors.New("cannot complete: order not shipped yet")
}

func (s *PaidState) Cancel(o *Order) error {
    fmt.Printf("[Order %s] Cancelling paid order (refund will be processed)\n", o.ID)
    o.State = &CancelledState{}
    return nil
}

// ===== 状态3：已发货 =====
type ShippedState struct{}

func (s *ShippedState) GetName() string {
    return "Shipped"
}

func (s *ShippedState) Pay(o *Order) error {
    return errors.New("already paid")
}

func (s *ShippedState) Ship(o *Order) error {
    return errors.New("already shipped")
}

func (s *ShippedState) Complete(o *Order) error {
    fmt.Printf("[Order %s] Completing order...\n", o.ID)
    o.CompletedAt = time.Now()
    o.State = &CompletedState{}
    fmt.Printf("[Order %s] Order completed! State: %s\n", o.ID, o.State.GetName())
    return nil
}

func (s *ShippedState) Cancel(o *Order) error {
    return errors.New("cannot cancel: order already shipped")
}

// ===== 状态4：已完成 =====
type CompletedState struct{}

func (s *CompletedState) GetName() string {
    return "Completed"
}

func (s *CompletedState) Pay(o *Order) error {
    return errors.New("order already completed")
}

func (s *CompletedState) Ship(o *Order) error {
    return errors.New("order already completed")
}

func (s *CompletedState) Complete(o *Order) error {
    return errors.New("order already completed")
}

func (s *CompletedState) Cancel(o *Order) error {
    return errors.New("cannot cancel: order already completed")
}

// ===== 状态5：已取消 =====
type CancelledState struct{}

func (s *CancelledState) GetName() string {
    return "Cancelled"
}

func (s *CancelledState) Pay(o *Order) error {
    return errors.New("order cancelled")
}

func (s *CancelledState) Ship(o *Order) error {
    return errors.New("order cancelled")
}

func (s *CancelledState) Complete(o *Order) error {
    return errors.New("order cancelled")
}

func (s *CancelledState) Cancel(o *Order) error {
    return errors.New("order already cancelled")
}

// ===== 使用示例 =====
func Example() {
    // 场景1：正常流程
    fmt.Println("=== Scenario 1: Normal Flow ===")
    order1 := NewOrder("ORDER-001")
    fmt.Printf("Order created: %s\n\n", order1.GetStatus())
    
    order1.Pay()
    order1.Ship()
    order1.Complete()
    
    fmt.Printf("\nFinal status: %s\n", order1.GetStatus())
    
    // 场景2：取消订单
    fmt.Println("\n=== Scenario 2: Cancel Order ===")
    order2 := NewOrder("ORDER-002")
    
    if err := order2.Cancel(); err != nil {
        fmt.Printf("Error: %v\n", err)
    }
    fmt.Printf("Final status: %s\n", order2.GetStatus())
    
    // 场景3：非法操作
    fmt.Println("\n=== Scenario 3: Invalid Operation ===")
    order3 := NewOrder("ORDER-003")
    
    if err := order3.Ship(); err != nil {
        fmt.Printf("Error: %v\n", err)
    }
}
```

---

## 第七部分：其他行为型模式

### 模板方法模式

```go
// 数据处理模板
type DataProcessor interface {
    ReadData() []byte
    ProcessData([]byte) []byte
    WriteData([]byte)
}

type BaseProcessor struct {
    processor DataProcessor
}

func (b *BaseProcessor) Execute() {
    data := b.processor.ReadData()
    processed := b.processor.ProcessData(data)
    b.processor.WriteData(processed)
}
```

### 迭代器模式

```go
// Go中使用range实现
type Collection struct {
    items []int
}

func (c *Collection) Iterator() <-chan int {
    ch := make(chan int)
    go func() {
        defer close(ch)
        for _, item := range c.items {
            ch <- item
        }
    }()
    return ch
}
```

### 备忘录模式

```go
// 编辑器撤销功能
type Editor struct {
    content string
}

type Memento struct {
    state string
}

func (e *Editor) Save() *Memento {
    return &Memento{state: e.content}
}

func (e *Editor) Restore(m *Memento) {
    e.content = m.state
}
```

---

## 第八部分：实战案例

### 综合案例：工作流引擎

结合多种行为型模式：

- **状态模式**: 工作流状态机
- **责任链模式**: 审批流
- **命令模式**: 操作历史
- **观察者模式**: 状态变更通知

---

## 第九部分：最佳实践

### 行为型模式选择指南

| 场景 | 推荐模式 | 原因 |
|------|---------|------|
| 多种算法切换 | 策略模式 | 算法封装 |
| 事件驱动 | 观察者模式 | 解耦通知 |
| 请求处理链 | 责任链模式 | 动态组合 |
| 任务队列 | 命令模式 | 请求封装 |
| 状态切换 | 状态模式 | 行为变化 |

### 常见陷阱

1. **策略模式：策略爆炸**
2. **观察者模式：内存泄漏**
3. **责任链模式：链过长**

---

## 🎯 总结

行为型模式是最实用和最复杂的设计模式，掌握它们能大幅提升代码的灵活性和可维护性。

---

**文档版本**: v4.0  


<div align="center">

Made with ❤️ for Go Developers

[⬆ 回到顶部](#go行为型设计模式深度实战指南)

</div>

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025年10月20日  
**文档状态**: 完成  
**适用版本**: Go 1.21+
