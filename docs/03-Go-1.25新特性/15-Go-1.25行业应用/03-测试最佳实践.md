# Go 1.23+ 测试最佳实践

> **版本要求**: Go 1.23++  
> **难度等级**: ⭐⭐⭐ (中级)  
> 

---

## 📋 目录

- [概述](#概述)
- [Go 1.23+ 测试新特性](#go-125-测试新特性)
- [单元测试](#单元测试)
- [并发测试](#并发测试)
- [基准测试](#基准测试)
- [集成测试](#集成测试)
- [最佳实践](#最佳实践)
- [FAQ](#faq)
- [参考资料](#参考资料)

---

## 概述

### 测试的重要性

```text
"测试不能证明程序没有 bug，但可以证明 bug 的存在。"
                                    - Edsger W. Dijkstra
```

Go 语言的测试哲学：

- ✅ **简单**: 内置测试框架，无需第三方库
- ✅ **快速**: 并发测试，快速反馈
- ✅ **可靠**: testing/synctest 确保确定性
- ✅ **集成**: `go test` 命令一站式测试

### Go 1.23+ 测试改进

| 特性 | Go 1.24 | Go 1.23+ | 改进 |
|------|---------|---------|------|
| **并发测试** | 不确定性 | 确定性 | ⭐⭐⭐⭐⭐ |
| **死锁检测** | 手动 | 自动 | ⭐⭐⭐⭐⭐ |
| **时间控制** | 难 | 简单 | ⭐⭐⭐⭐ |
| **WaitGroup** | 3行 | 1行 | ⭐⭐⭐ |

---

## Go 1.23+ 测试新特性

### 🎯 testing/synctest 包

**最重要的新特性！**

#### 问题：并发测试的不确定性

```go
// Go 1.24 - 不可靠的并发测试
func TestConcurrent(t *testing.T) {
    var count int
    var wg sync.WaitGroup
    
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            count++ // 数据竞争！
        }()
    }
    
    wg.Wait()
    
    // 有时通过，有时失败
    if count != 100 {
        t.Errorf("expected 100, got %d", count)
    }
}
```

#### 解决方案：testing/synctest

```go
// Go 1.23+ - 确定性并发测试
import "testing/synctest"

func TestConcurrentDeterministic(t *testing.T) {
    synctest.Run(func() {
        var count int
        var mu sync.Mutex
        var wg sync.WaitGroup
        
        for i := 0; i < 100; i++ {
            wg.Add(1)
            go func() {
                defer wg.Done()
                mu.Lock()
                count++
                mu.Unlock()
            }()
        }
        
        wg.Wait()
        
        // 确定性结果
        if count != 100 {
            t.Errorf("expected 100, got %d", count)
        }
    })
}
```

**优势**:

- ✅ **确定性**: 每次运行结果相同
- ✅ **自动死锁检测**: 自动发现死锁
- ✅ **时间控制**: 模拟时间流逝

---

### 🚀 WaitGroup.Go()

简化并发测试代码：

```go
// Go 1.24 - 容易出错
func TestParallel(t *testing.T) {
    var wg sync.WaitGroup
    
    for i := 0; i < 10; i++ {
        wg.Add(1) // 容易忘记
        go func(n int) {
            defer wg.Done() // 容易忘记
            // 测试逻辑
        }(i)
    }
    
    wg.Wait()
}

// Go 1.23+ - 更简洁
func TestParallelSimple(t *testing.T) {
    var wg sync.WaitGroup
    
    for i := 0; i < 10; i++ {
        wg.Go(func() {
            // 测试逻辑
            // 自动 Add/Done
        })
    }
    
    wg.Wait()
}
```

---

## 单元测试

### 1. 基础测试

```go
// math.go
package math

func Add(a, b int) int {
    return a + b
}

func Divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}
```

```go
// math_test.go
package math

import "testing"

func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"positive", 1, 2, 3},
        {"negative", -1, -2, -3},
        {"zero", 0, 0, 0},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := Add(tt.a, tt.b)
            if got != tt.want {
                t.Errorf("Add(%d, %d) = %d, want %d", 
                    tt.a, tt.b, got, tt.want)
            }
        })
    }
}

func TestDivide(t *testing.T) {
    // 正常情况
    got, err := Divide(10, 2)
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
    if got != 5 {
        t.Errorf("Divide(10, 2) = %d, want 5", got)
    }
    
    // 错误情况
    _, err = Divide(10, 0)
    if err == nil {
        t.Error("expected error for division by zero")
    }
}
```

---

### 2. 表驱动测试

```go
func TestComplexFunction(t *testing.T) {
    tests := []struct {
        name    string
        input   string
        want    string
        wantErr bool
    }{
        {
            name:    "valid input",
            input:   "hello",
            want:    "HELLO",
            wantErr: false,
        },
        {
            name:    "empty input",
            input:   "",
            want:    "",
            wantErr: true,
        },
        {
            name:    "special chars",
            input:   "hello@world",
            want:    "HELLO@WORLD",
            wantErr: false,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := ComplexFunction(tt.input)
            
            if (err != nil) != tt.wantErr {
                t.Errorf("error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            
            if got != tt.want {
                t.Errorf("got %v, want %v", got, tt.want)
            }
        })
    }
}
```

---

## 并发测试

### 1. 使用 testing/synctest (Go 1.23+)

```go
import "testing/synctest"

// 测试并发安全的计数器
func TestCounterConcurrent(t *testing.T) {
    synctest.Run(func() {
        counter := NewCounter()
        var wg sync.WaitGroup
        
        // 100 个并发增加
        for i := 0; i < 100; i++ {
            wg.Go(func() {
                counter.Increment()
            })
        }
        
        wg.Wait()
        
        // 确定性结果
        if counter.Value() != 100 {
            t.Errorf("expected 100, got %d", counter.Value())
        }
    })
}
```

---

### 2. 死锁检测

```go
// synctest 自动检测死锁
func TestDeadlock(t *testing.T) {
    synctest.Run(func() {
        var mu1, mu2 sync.Mutex
        
        // Goroutine 1
        go func() {
            mu1.Lock()
            defer mu1.Unlock()
            time.Sleep(100 * time.Millisecond)
            mu2.Lock() // 死锁！
            mu2.Unlock()
        }()
        
        // Goroutine 2
        go func() {
            mu2.Lock()
            defer mu2.Unlock()
            time.Sleep(100 * time.Millisecond)
            mu1.Lock() // 死锁！
            mu1.Unlock()
        }()
        
        // synctest 会自动检测并报告死锁
    })
}
```

---

### 3. 时间控制测试

```go
// 测试超时逻辑
func TestTimeout(t *testing.T) {
    synctest.Run(func() {
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        
        result := make(chan string, 1)
        
        go func() {
            time.Sleep(10 * time.Second) // 模拟长时间操作
            result <- "done"
        }()
        
        select {
        case <-ctx.Done():
            // 预期超时
            if ctx.Err() != context.DeadlineExceeded {
                t.Errorf("unexpected error: %v", ctx.Err())
            }
        case r := <-result:
            t.Errorf("expected timeout, got result: %s", r)
        }
    })
}
```

---

## 基准测试

### 1. 基础基准测试

```go
// 测试性能
func BenchmarkAdd(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Add(1, 2)
    }
}

// 运行: go test -bench=. -benchmem
// 输出:
// BenchmarkAdd-8    1000000000    0.25 ns/op    0 B/op    0 allocs/op
```

---

### 2. 对比基准测试

```go
// 对比 Go 1.24 vs 1.25
func BenchmarkMapLookup(b *testing.B) {
    m := make(map[string]int, 1000)
    for i := 0; i < 1000; i++ {
        m[fmt.Sprintf("key%d", i)] = i
    }
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = m["key500"]
    }
}

// Go 1.24: 15 ns/op
// Go 1.23+: 10 ns/op (Swiss Tables: +50% faster)
```

---

### 3. 内存分配测试

```go
func BenchmarkAllocations(b *testing.B) {
    b.ReportAllocs()
    
    for i := 0; i < b.N; i++ {
        // 测试代码
        s := make([]int, 1000)
        _ = s
    }
}

// 输出会包含:
// - allocs/op: 每次操作的分配次数
// - B/op: 每次操作分配的字节数
```

---

## 集成测试

### 1. HTTP 服务器测试

```go
import (
    "net/http"
    "net/http/httptest"
    "testing"
)

func TestHTTPHandler(t *testing.T) {
    // 创建测试服务器
    handler := http.HandlerFunc(MyHandler)
    server := httptest.NewServer(handler)
    defer server.Close()
    
    // 发送请求
    resp, err := http.Get(server.URL + "/api/users")
    if err != nil {
        t.Fatalf("request failed: %v", err)
    }
    defer resp.Body.Close()
    
    // 验证响应
    if resp.StatusCode != http.StatusOK {
        t.Errorf("expected 200, got %d", resp.StatusCode)
    }
}
```

---

### 2. 数据库测试

```go
func TestDatabaseOperations(t *testing.T) {
    // 使用测试数据库
    db, err := sql.Open("sqlite3", ":memory:")
    if err != nil {
        t.Fatalf("failed to open db: %v", err)
    }
    defer db.Close()
    
    // 初始化表
    _, err = db.Exec(`CREATE TABLE users (id INTEGER, name TEXT)`)
    if err != nil {
        t.Fatalf("failed to create table: %v", err)
    }
    
    // 测试插入
    _, err = db.Exec(`INSERT INTO users VALUES (1, 'Alice')`)
    if err != nil {
        t.Errorf("failed to insert: %v", err)
    }
    
    // 测试查询
    var name string
    err = db.QueryRow(`SELECT name FROM users WHERE id = 1`).Scan(&name)
    if err != nil {
        t.Errorf("failed to query: %v", err)
    }
    
    if name != "Alice" {
        t.Errorf("expected 'Alice', got '%s'", name)
    }
}
```

---

## 最佳实践

### 1. 测试组织

```text
project/
├── user/
│   ├── user.go
│   ├── user_test.go        # 单元测试
│   └── user_integration_test.go  # 集成测试 (build tag)
├── api/
│   ├── api.go
│   └── api_test.go
└── ...
```

```go
//go:build integration

package user

// 集成测试
// 运行: go test -tags=integration
```

---

### 2. 使用 Testify (可选)

```go
import (
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestWithTestify(t *testing.T) {
    result := Add(1, 2)
    
    // assert: 失败后继续
    assert.Equal(t, 3, result, "1 + 2 should be 3")
    
    // require: 失败后停止
    require.NotNil(t, result, "result should not be nil")
}
```

---

### 3. 测试覆盖率

```bash
# 运行测试并生成覆盖率
go test -cover ./...

# 详细覆盖率报告
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out

# 目标: >80% 覆盖率
```

---

### 4. 并行测试

```go
func TestParallel1(t *testing.T) {
    t.Parallel() // 标记为并行测试
    
    // 测试逻辑
}

func TestParallel2(t *testing.T) {
    t.Parallel() // 并行运行
    
    // 测试逻辑
}

// 运行: go test -parallel 4
```

---

### 5. 测试帮助函数

```go
// 测试帮助函数
func setupTest(t *testing.T) (*Database, func()) {
    t.Helper() // 标记为帮助函数
    
    db := NewDatabase()
    
    // 返回清理函数
    cleanup := func() {
        db.Close()
    }
    
    return db, cleanup
}

func TestWithHelper(t *testing.T) {
    db, cleanup := setupTest(t)
    defer cleanup()
    
    // 使用 db 进行测试
}
```

---

## FAQ

### Q1: Go 1.23+ 的 testing/synctest 是否必须使用？

**A**: 不必须，但**强烈推荐** ✅

对于并发测试:

- ✅ 确定性结果
- ✅ 自动死锁检测
- ✅ 更可靠的测试

---

### Q2: 如何测试并发代码？

**A**: 使用 `testing/synctest.Run()`

```go
synctest.Run(func() {
    // 并发测试代码
})
```

---

### Q3: 测试覆盖率多少合适？

**A**: **80%+** 是好的目标 🎯

```bash
go test -cover ./...
# 目标: >80%
```

但不要盲目追求 100%，重点是测试**关键路径**。

---

### Q4: 如何组织测试代码？

**A**: 按功能组织，使用 build tags

```text
- 单元测试: *_test.go (默认)
- 集成测试: *_integration_test.go (build tag)
- 基准测试: *_bench_test.go (可选)
```

---

### Q5: 测试应该多快？

**A**: **越快越好** ⚡

目标:

- 单元测试: < 100ms
- 集成测试: < 5s
- 完整测试套件: < 5min

---

## 参考资料

### 官方文档

- 📘 [testing 包](https://pkg.go.dev/testing)
- 📘 [testing/synctest 包](https://pkg.go.dev/testing/synctest)
- 📘 [Go 测试最佳实践](https://go.dev/doc/effective_go#testing)

### 本项目文档

- 📚 [testing/synctest 包](../14-Go-1.23并发和网络/02-testing-synctest包.md)
- 📚 [WaitGroup.Go()](../14-Go-1.23并发和网络/01-WaitGroup-Go方法.md)

### 第三方库

- 🔧 [Testify](https://github.com/stretchr/testify)
- 🔧 [GoMock](https://github.com/golang/mock)
- 🔧 [Ginkgo](https://github.com/onsi/ginkgo)

---
<p align="center">
  <b>🧪 Go 1.23+ 让测试更简单、更可靠!</b><br>
  <b>✅ testing/synctest + WaitGroup.Go() = 完美组合!</b>
</p>

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025年10月20日  
**文档状态**: 完成  
**适用版本**: Go 1.21+
