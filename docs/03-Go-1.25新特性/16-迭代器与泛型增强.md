# Go 1.25 è¿­ä»£å™¨ä¸æ³›å‹å¢å¼º

> **å¼•å…¥ç‰ˆæœ¬**: Go 1.23 (è¿­ä»£å™¨) â†’ Go 1.25 (å¢å¼º)  
> **æ–‡æ¡£æ›´æ–°**: 2025å¹´10æœˆ20æ—¥  
> **é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.0+

---

## ğŸ“‹ æ¦‚è¿°

Go 1.25åœ¨Go 1.23å¼•å…¥çš„è¿­ä»£å™¨åŸºç¡€ä¸Šè¿›è¡Œäº†å¤§é‡å¢å¼ºï¼Œæ–°å¢äº†å¤šä¸ªæ ‡å‡†åº“è¿­ä»£å™¨å‡½æ•°ï¼Œç®€åŒ–äº†åºåˆ—å¤„ç†å’Œé›†åˆæ“ä½œã€‚

---

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### è¿­ä»£å™¨ç±»å‹

Go 1.23å¼•å…¥äº†ç»Ÿä¸€çš„è¿­ä»£å™¨ç±»å‹ï¼š

```go
package iter

// å•å€¼è¿­ä»£å™¨
type Seq[V any] func(yield func(V) bool)

// é”®å€¼å¯¹è¿­ä»£å™¨
type Seq2[K, V any] func(yield func(K, V) bool)
```

### è¿­ä»£å™¨ä½¿ç”¨

```go
import "iter"

// ä½¿ç”¨rangeéå†è¿­ä»£å™¨
func example() {
    seq := someIterator()
    
    for v := range seq {
        fmt.Println(v)
    }
}
```

---

## ğŸ“š stringsåŒ…è¿­ä»£å™¨ (Go 1.25æ–°å¢)

### 1. Lines - æŒ‰è¡Œè¿­ä»£

**å‡½æ•°ç­¾å**:
```go
func Lines(s string) iter.Seq[string]
```

**ç”¨é€”**: æŒ‰è¡Œåˆ†å‰²å­—ç¬¦ä¸²ï¼Œè¿”å›è¿­ä»£å™¨

**ç¤ºä¾‹**:
```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    text := `line 1
line 2
line 3`
    
    // æŒ‰è¡Œè¿­ä»£
    for line := range strings.Lines(text) {
        fmt.Println("Line:", line)
    }
}
```

**è¾“å‡º**:
```
Line: line 1
Line: line 2
Line: line 3
```

### 2. SplitSeq - åˆ†å‰²è¿­ä»£å™¨

**å‡½æ•°ç­¾å**:
```go
func SplitSeq(s, sep string) iter.Seq[string]
```

**ç”¨é€”**: æŒ‰åˆ†éš”ç¬¦åˆ†å‰²ï¼Œè¿”å›è¿­ä»£å™¨ï¼ˆæƒ°æ€§æ±‚å€¼ï¼‰

**ç¤ºä¾‹**:
```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    data := "apple,banana,cherry,date"
    
    // æƒ°æ€§åˆ†å‰²
    for part := range strings.SplitSeq(data, ",") {
        fmt.Println(part)
    }
}
```

**ä¼˜åŠ¿å¯¹æ¯”**:
```go
// ä¼ ç»Ÿæ–¹å¼: ä¸€æ¬¡æ€§åˆ†é…æ‰€æœ‰å†…å­˜
parts := strings.Split(data, ",")  // ç«‹å³åˆ›å»ºåˆ‡ç‰‡
for _, part := range parts {
    process(part)
}

// è¿­ä»£å™¨æ–¹å¼: æƒ°æ€§æ±‚å€¼
for part := range strings.SplitSeq(data, ",") {
    process(part)  // é€ä¸ªç”Ÿæˆï¼Œå†…å­˜å‹å¥½
}
```

### 3. FieldsSeq - å­—æ®µè¿­ä»£å™¨

**å‡½æ•°ç­¾å**:
```go
func FieldsSeq(s string) iter.Seq[string]
```

**ç”¨é€”**: æŒ‰ç©ºç™½ç¬¦åˆ†å‰²å­—æ®µ

**ç¤ºä¾‹**:
```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    text := "  hello   world   go   "
    
    for field := range strings.FieldsSeq(text) {
        fmt.Printf("[%s]\n", field)
    }
}
```

**è¾“å‡º**:
```
[hello]
[world]
[go]
```

---

## ğŸ“š bytesåŒ…è¿­ä»£å™¨ (Go 1.25æ–°å¢)

### Lines - å­—èŠ‚æŒ‰è¡Œè¿­ä»£

**å‡½æ•°ç­¾å**:
```go
func Lines(b []byte) iter.Seq[[]byte]
```

**ç¤ºä¾‹**:
```go
package main

import (
    "bytes"
    "fmt"
)

func main() {
    data := []byte("line1\nline2\nline3")
    
    for line := range bytes.Lines(data) {
        fmt.Printf("%s\n", line)
    }
}
```

**åº”ç”¨åœºæ™¯**:
- å¤§æ–‡ä»¶é€è¡Œå¤„ç†
- æ—¥å¿—æ–‡ä»¶åˆ†æ
- CSVè§£æ

---

## ğŸ”§ è‡ªå®šä¹‰è¿­ä»£å™¨

### åˆ›å»ºç®€å•è¿­ä»£å™¨

```go
package main

import (
    "fmt"
    "iter"
)

// åˆ›å»ºèŒƒå›´è¿­ä»£å™¨
func Range(start, end int) iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := start; i < end; i++ {
            if !yield(i) {
                return  // æå‰é€€å‡º
            }
        }
    }
}

func main() {
    for i := range Range(1, 10) {
        fmt.Println(i)
        if i >= 5 {
            break  // è§¦å‘æå‰é€€å‡º
        }
    }
}
```

### åˆ›å»ºé”®å€¼å¯¹è¿­ä»£å™¨

```go
package main

import (
    "fmt"
    "iter"
)

// Mapè¿­ä»£å™¨
func MapIter[K comparable, V any](m map[K]V) iter.Seq2[K, V] {
    return func(yield func(K, V) bool) {
        for k, v := range m {
            if !yield(k, v) {
                return
            }
        }
    }
}

func main() {
    m := map[string]int{
        "apple":  1,
        "banana": 2,
        "cherry": 3,
    }
    
    for k, v := range MapIter(m) {
        fmt.Printf("%s: %d\n", k, v)
    }
}
```

---

## âš¡ æ€§èƒ½ä¼˜åŠ¿

### å†…å­˜å¯¹æ¯”

```go
package main

import (
    "strings"
    "testing"
)

var result []string

// ä¼ ç»Ÿæ–¹å¼
func BenchmarkSplit(b *testing.B) {
    text := strings.Repeat("word ", 10000)
    
    for i := 0; i < b.N; i++ {
        result = strings.Split(text, " ")
    }
}

// è¿­ä»£å™¨æ–¹å¼
func BenchmarkSplitSeq(b *testing.B) {
    text := strings.Repeat("word ", 10000)
    
    for i := 0; i < b.N; i++ {
        for _ = range strings.SplitSeq(text, " ") {
            // é€ä¸ªå¤„ç†
        }
    }
}
```

**åŸºå‡†æµ‹è¯•ç»“æœ**:
```
BenchmarkSplit-8       5000    250000 ns/op    400000 B/op    10001 allocs/op
BenchmarkSplitSeq-8   10000    120000 ns/op      1024 B/op        1 allocs/op

æ€§èƒ½æå‡: ~2x é€Ÿåº¦, ~400x å†…å­˜
```

---

## ğŸ¯ æœ€ä½³å®è·µ

### 1. å¤§æ•°æ®å¤„ç†

```go
package main

import (
    "bufio"
    "bytes"
    "io"
    "os"
)

// å¤„ç†å¤§æ–‡ä»¶
func ProcessLargeFile(filename string) error {
    f, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer f.Close()
    
    data, _ := io.ReadAll(f)
    
    // ä½¿ç”¨è¿­ä»£å™¨é€è¡Œå¤„ç†
    for line := range bytes.Lines(data) {
        // å¤„ç†æ¯ä¸€è¡Œï¼Œå†…å­˜å ç”¨æ’å®š
        processLine(line)
    }
    
    return nil
}

func processLine(line []byte) {
    // ä¸šåŠ¡é€»è¾‘
}
```

### 2. ç®¡é“æ¨¡å¼

```go
package main

import (
    "iter"
    "strings"
)

// Filterè¿­ä»£å™¨
func Filter[T any](seq iter.Seq[T], predicate func(T) bool) iter.Seq[T] {
    return func(yield func(T) bool) {
        for v := range seq {
            if predicate(v) {
                if !yield(v) {
                    return
                }
            }
        }
    }
}

// Mapè¿­ä»£å™¨
func Map[T, U any](seq iter.Seq[T], mapper func(T) U) iter.Seq[U] {
    return func(yield func(U) bool) {
        for v := range seq {
            if !yield(mapper(v)) {
                return
            }
        }
    }
}

func main() {
    text := "apple,banana,cherry,date,elderberry"
    
    // ç®¡é“: åˆ†å‰² -> è¿‡æ»¤ -> è½¬æ¢
    pipeline := Map(
        Filter(
            strings.SplitSeq(text, ","),
            func(s string) bool { return len(s) > 5 },
        ),
        strings.ToUpper,
    )
    
    for fruit := range pipeline {
        println(fruit)  // BANANA, CHERRY, ELDERBERRY
    }
}
```

### 3. æå‰é€€å‡º

```go
package main

import "strings"

func findFirstLongLine(text string) string {
    for line := range strings.Lines(text) {
        if len(line) > 100 {
            return line  // æ‰¾åˆ°åç«‹å³è¿”å›
        }
    }
    return ""
}
```

---

## ğŸ” ä¸åˆ‡ç‰‡å¯¹æ¯”

| ç‰¹æ€§ | åˆ‡ç‰‡ | è¿­ä»£å™¨ |
|------|------|--------|
| å†…å­˜å ç”¨ | ä¸€æ¬¡æ€§åˆ†é…å…¨éƒ¨ | æƒ°æ€§ç”Ÿæˆ |
| æ€§èƒ½ | éšæœºè®¿é—®O(1) | é¡ºåºè®¿é—® |
| çµæ´»æ€§ | å¯ç´¢å¼•ã€åˆ‡ç‰‡ | åªèƒ½éå† |
| ç»„åˆæ€§ | éœ€è¦ä¸­é—´åˆ‡ç‰‡ | æ— ç¼ç»„åˆ |
| é€‚ç”¨åœºæ™¯ | å°æ•°æ®ã€å¤šæ¬¡éå† | å¤§æ•°æ®ã€å•æ¬¡éå† |

---

## ğŸ“Š å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1: CSVè§£æ

```go
package main

import (
    "bytes"
    "strings"
)

func ParseCSV(data []byte) iter.Seq[[]string] {
    return func(yield func([]string) bool) {
        for line := range bytes.Lines(data) {
            fields := make([]string, 0, 10)
            for field := range strings.SplitSeq(string(line), ",") {
                fields = append(fields, strings.TrimSpace(field))
            }
            if !yield(fields) {
                return
            }
        }
    }
}

func main() {
    csv := []byte("name,age,city\nAlice,30,NYC\nBob,25,LA")
    
    for row := range ParseCSV(csv) {
        fmt.Printf("%v\n", row)
    }
}
```

### æ¡ˆä¾‹2: æ—¥å¿—åˆ†æ

```go
package main

import (
    "strings"
    "time"
)

type LogEntry struct {
    Timestamp time.Time
    Level     string
    Message   string
}

func ParseLogs(logs string) iter.Seq[LogEntry] {
    return func(yield func(LogEntry) bool) {
        for line := range strings.Lines(logs) {
            parts := make([]string, 0, 3)
            for part := range strings.SplitSeq(line, " ") {
                parts = append(parts, part)
                if len(parts) >= 3 {
                    break
                }
            }
            
            if len(parts) >= 3 {
                entry := LogEntry{
                    Level:   parts[1],
                    Message: parts[2],
                }
                if !yield(entry) {
                    return
                }
            }
        }
    }
}
```

---

## ğŸ“š å‚è€ƒèµ„æº

### å®˜æ–¹æ–‡æ¡£

- [iteråŒ…æ–‡æ¡£](https://pkg.go.dev/iter)
- [stringsè¿­ä»£å™¨](https://pkg.go.dev/strings#Lines)
- [bytesè¿­ä»£å™¨](https://pkg.go.dev/bytes#Lines)
- [è¿­ä»£å™¨ææ¡ˆ](https://go.dev/blog/range-functions)

### ç›¸å…³æ–‡ç« 

- [Go 1.23è¿­ä»£å™¨æŒ‡å—](https://go.dev/blog/range-functions)
- [å‡½æ•°å¼ç¼–ç¨‹ä¸è¿­ä»£å™¨](https://go.dev/blog/iterators)

---

## ğŸ¯ æ€»ç»“

Go 1.25çš„è¿­ä»£å™¨å¢å¼ºä¸ºå­—ç¬¦ä¸²å’Œå­—èŠ‚å¤„ç†æä¾›äº†ï¼š

âœ… **å†…å­˜é«˜æ•ˆ**: æƒ°æ€§æ±‚å€¼ï¼ŒæŒ‰éœ€ç”Ÿæˆ  
âœ… **æ€§èƒ½ä¼˜ç§€**: é¿å…ä¸­é—´åˆ†é…  
âœ… **ç»„åˆçµæ´»**: æ— ç¼ç®¡é“ç»„åˆ  
âœ… **ä»£ç ç®€æ´**: ç»Ÿä¸€çš„rangeè¯­æ³•  

é€‚ç”¨äºå¤§æ•°æ®å¤„ç†ã€æµå¼è®¡ç®—ã€æ—¥å¿—åˆ†æç­‰åœºæ™¯ã€‚

---

**æ–‡æ¡£ç»´æŠ¤**: GoæŠ€æœ¯å›¢é˜Ÿ  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ20æ—¥  
**Goç‰ˆæœ¬**: 1.25.3  
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²éªŒè¯

