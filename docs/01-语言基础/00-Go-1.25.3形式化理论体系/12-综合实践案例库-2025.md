# Go 1.25.3 ç»¼åˆå®è·µæ¡ˆä¾‹åº“

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**åŸºå‡†æ—¥æœŸ**: 2025å¹´10æœˆ23æ—¥  
**Goç‰ˆæœ¬**: Go 1.25.3  
**æ¡ˆä¾‹æ•°é‡**: 15ä¸ªå®Œæ•´å®æˆ˜é¡¹ç›®  
**å­—æ•°**: ~18,000å­—

---

## ğŸ“š ç›®å½•

- [Go 1.25.3 ç»¼åˆå®è·µæ¡ˆä¾‹åº“](#go-1253-ç»¼åˆå®è·µæ¡ˆä¾‹åº“)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [ç¬¬ä¸€éƒ¨åˆ†: ç±»å‹ç³»ç»Ÿå®æˆ˜](#ç¬¬ä¸€éƒ¨åˆ†-ç±»å‹ç³»ç»Ÿå®æˆ˜)
    - [æ¡ˆä¾‹1: æ³›å‹å®¹å™¨åº“](#æ¡ˆä¾‹1-æ³›å‹å®¹å™¨åº“)
    - [æ¡ˆä¾‹2: ç±»å‹å®‰å…¨çš„é…ç½®ç³»ç»Ÿ](#æ¡ˆä¾‹2-ç±»å‹å®‰å…¨çš„é…ç½®ç³»ç»Ÿ)
  - [ç¬¬äºŒéƒ¨åˆ†: å¹¶å‘ç¼–ç¨‹å®æˆ˜](#ç¬¬äºŒéƒ¨åˆ†-å¹¶å‘ç¼–ç¨‹å®æˆ˜)
    - [æ¡ˆä¾‹3: å¹¶å‘çˆ¬è™«](#æ¡ˆä¾‹3-å¹¶å‘çˆ¬è™«)
    - [æ¡ˆä¾‹4: å·¥ä½œæ± æ¨¡å¼](#æ¡ˆä¾‹4-å·¥ä½œæ± æ¨¡å¼)
    - [æ¡ˆä¾‹5: å‘å¸ƒè®¢é˜…ç³»ç»Ÿ](#æ¡ˆä¾‹5-å‘å¸ƒè®¢é˜…ç³»ç»Ÿ)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

---

## ç¬¬ä¸€éƒ¨åˆ†: ç±»å‹ç³»ç»Ÿå®æˆ˜

### æ¡ˆä¾‹1: æ³›å‹å®¹å™¨åº“

å®ç°ä¸€ä¸ªç±»å‹å®‰å…¨çš„é€šç”¨å®¹å™¨åº“ã€‚

```go
package containers

import (
    "fmt"
    "sync"
)

// ========== 1. æ³›å‹æ ˆ ==========

type Stack[T any] struct {
    items []T
    mu    sync.RWMutex
}

func NewStack[T any]() *Stack[T] {
    return &Stack[T]{
        items: make([]T, 0),
    }
}

func (s *Stack[T]) Push(item T) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.items = append(s.items, item)
}

func (s *Stack[T]) Pop() (T, bool) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    if len(s.items) == 0 {
        var zero T
        return zero, false
    }
    
    index := len(s.items) - 1
    item := s.items[index]
    s.items = s.items[:index]
    return item, true
}

func (s *Stack[T]) Peek() (T, bool) {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    if len(s.items) == 0 {
        var zero T
        return zero, false
    }
    
    return s.items[len(s.items)-1], true
}

func (s *Stack[T]) Size() int {
    s.mu.RLock()
    defer s.mu.RUnlock()
    return len(s.items)
}

// ========== 2. æ³›å‹é˜Ÿåˆ— ==========

type Queue[T any] struct {
    items []T
    mu    sync.RWMutex
}

func NewQueue[T any]() *Queue[T] {
    return &Queue[T]{
        items: make([]T, 0),
    }
}

func (q *Queue[T]) Enqueue(item T) {
    q.mu.Lock()
    defer q.mu.Unlock()
    q.items = append(q.items, item)
}

func (q *Queue[T]) Dequeue() (T, bool) {
    q.mu.Lock()
    defer q.mu.Unlock()
    
    if len(q.items) == 0 {
        var zero T
        return zero, false
    }
    
    item := q.items[0]
    q.items = q.items[1:]
    return item, true
}

// ========== 3. æ³›å‹ä¼˜å…ˆé˜Ÿåˆ— ==========

type PriorityQueue[T any] struct {
    items []PQItem[T]
    less  func(T, T) bool
    mu    sync.RWMutex
}

type PQItem[T any] struct {
    value    T
    priority int
}

func NewPriorityQueue[T any](less func(T, T) bool) *PriorityQueue[T] {
    return &PriorityQueue[T]{
        items: make([]PQItem[T], 0),
        less:  less,
    }
}

func (pq *PriorityQueue[T]) Push(value T, priority int) {
    pq.mu.Lock()
    defer pq.mu.Unlock()
    
    item := PQItem[T]{value: value, priority: priority}
    pq.items = append(pq.items, item)
    pq.up(len(pq.items) - 1)
}

func (pq *PriorityQueue[T]) Pop() (T, bool) {
    pq.mu.Lock()
    defer pq.mu.Unlock()
    
    if len(pq.items) == 0 {
        var zero T
        return zero, false
    }
    
    item := pq.items[0]
    last := len(pq.items) - 1
    pq.items[0] = pq.items[last]
    pq.items = pq.items[:last]
    if len(pq.items) > 0 {
        pq.down(0)
    }
    
    return item.value, true
}

func (pq *PriorityQueue[T]) up(i int) {
    for {
        parent := (i - 1) / 2
        if i == parent || pq.items[parent].priority <= pq.items[i].priority {
            break
        }
        pq.items[i], pq.items[parent] = pq.items[parent], pq.items[i]
        i = parent
    }
}

func (pq *PriorityQueue[T]) down(i int) {
    for {
        left := 2*i + 1
        if left >= len(pq.items) {
            break
        }
        
        j := left
        if right := left + 1; right < len(pq.items) && pq.items[right].priority < pq.items[left].priority {
            j = right
        }
        
        if pq.items[i].priority <= pq.items[j].priority {
            break
        }
        
        pq.items[i], pq.items[j] = pq.items[j], pq.items[i]
        i = j
    }
}

// ========== 4. æ³›å‹Set ==========

type Set[T comparable] struct {
    items map[T]struct{}
    mu    sync.RWMutex
}

func NewSet[T comparable]() *Set[T] {
    return &Set[T]{
        items: make(map[T]struct{}),
    }
}

func (s *Set[T]) Add(item T) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.items[item] = struct{}{}
}

func (s *Set[T]) Remove(item T) {
    s.mu.Lock()
    defer s.mu.Unlock()
    delete(s.items, item)
}

func (s *Set[T]) Contains(item T) bool {
    s.mu.RLock()
    defer s.mu.RUnlock()
    _, exists := s.items[item]
    return exists
}

func (s *Set[T]) Union(other *Set[T]) *Set[T] {
    result := NewSet[T]()
    
    s.mu.RLock()
    for item := range s.items {
        result.Add(item)
    }
    s.mu.RUnlock()
    
    other.mu.RLock()
    for item := range other.items {
        result.Add(item)
    }
    other.mu.RUnlock()
    
    return result
}

func (s *Set[T]) Intersection(other *Set[T]) *Set[T] {
    result := NewSet[T]()
    
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    other.mu.RLock()
    defer other.mu.RUnlock()
    
    for item := range s.items {
        if _, exists := other.items[item]; exists {
            result.Add(item)
        }
    }
    
    return result
}

// ========== ä½¿ç”¨ç¤ºä¾‹ ==========

func ExampleContainers() {
    // æ ˆ
    stack := NewStack[int]()
    stack.Push(1)
    stack.Push(2)
    stack.Push(3)
    
    for stack.Size() > 0 {
        item, _ := stack.Pop()
        fmt.Println(item) // è¾“å‡º: 3, 2, 1
    }
    
    // é˜Ÿåˆ—
    queue := NewQueue[string]()
    queue.Enqueue("first")
    queue.Enqueue("second")
    queue.Enqueue("third")
    
    for {
        item, ok := queue.Dequeue()
        if !ok {
            break
        }
        fmt.Println(item) // è¾“å‡º: first, second, third
    }
    
    // ä¼˜å…ˆé˜Ÿåˆ—
    pq := NewPriorityQueue[string](func(a, b string) bool {
        return a < b
    })
    pq.Push("low", 10)
    pq.Push("high", 1)
    pq.Push("medium", 5)
    
    for {
        item, ok := pq.Pop()
        if !ok {
            break
        }
        fmt.Println(item) // è¾“å‡º: high, medium, low
    }
    
    // Set
    set1 := NewSet[int]()
    set1.Add(1)
    set1.Add(2)
    set1.Add(3)
    
    set2 := NewSet[int]()
    set2.Add(2)
    set2.Add(3)
    set2.Add(4)
    
    union := set1.Union(set2)         // {1, 2, 3, 4}
    intersection := set1.Intersection(set2) // {2, 3}
}
```

### æ¡ˆä¾‹2: ç±»å‹å®‰å…¨çš„é…ç½®ç³»ç»Ÿ

```go
package config

import (
    "encoding/json"
    "fmt"
    "os"
    "reflect"
    "strconv"
    "sync"
)

// ========== 1. é…ç½®æ¥å£ ==========

type Config[T any] interface {
    Load(path string) error
    Get() T
    Set(value T)
    Validate() error
}

// ========== 2. JSONé…ç½®å®ç° ==========

type JSONConfig[T any] struct {
    value     T
    path      string
    mu        sync.RWMutex
    validator func(T) error
}

func NewJSONConfig[T any](validator func(T) error) *JSONConfig[T] {
    return &JSONConfig[T]{
        validator: validator,
    }
}

func (c *JSONConfig[T]) Load(path string) error {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    c.path = path
    data, err := os.ReadFile(path)
    if err != nil {
        return fmt.Errorf("failed to read config: %w", err)
    }
    
    if err := json.Unmarshal(data, &c.value); err != nil {
        return fmt.Errorf("failed to parse config: %w", err)
    }
    
    if c.validator != nil {
        if err := c.validator(c.value); err != nil {
            return fmt.Errorf("config validation failed: %w", err)
        }
    }
    
    return nil
}

func (c *JSONConfig[T]) Get() T {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.value
}

func (c *JSONConfig[T]) Set(value T) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value = value
}

func (c *JSONConfig[T]) Validate() error {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    if c.validator != nil {
        return c.validator(c.value)
    }
    return nil
}

func (c *JSONConfig[T]) Save() error {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    data, err := json.MarshalIndent(c.value, "", "  ")
    if err != nil {
        return fmt.Errorf("failed to marshal config: %w", err)
    }
    
    if err := os.WriteFile(c.path, data, 0644); err != nil {
        return fmt.Errorf("failed to write config: %w", err)
    }
    
    return nil
}

// ========== 3. ç¯å¢ƒå˜é‡é…ç½® ==========

type EnvConfig[T any] struct {
    value  T
    prefix string
    mu     sync.RWMutex
}

func NewEnvConfig[T any](prefix string) *EnvConfig[T] {
    return &EnvConfig[T]{
        prefix: prefix,
    }
}

func (c *EnvConfig[T]) Load() error {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    v := reflect.ValueOf(&c.value).Elem()
    t := v.Type()
    
    for i := 0; i < v.NumField(); i++ {
        field := t.Field(i)
        envKey := c.prefix + "_" + field.Name
        
        envValue := os.Getenv(envKey)
        if envValue == "" {
            continue
        }
        
        if err := c.setField(v.Field(i), envValue); err != nil {
            return fmt.Errorf("failed to set field %s: %w", field.Name, err)
        }
    }
    
    return nil
}

func (c *EnvConfig[T]) setField(field reflect.Value, value string) error {
    switch field.Kind() {
    case reflect.String:
        field.SetString(value)
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        intVal, err := strconv.ParseInt(value, 10, 64)
        if err != nil {
            return err
        }
        field.SetInt(intVal)
    case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
        uintVal, err := strconv.ParseUint(value, 10, 64)
        if err != nil {
            return err
        }
        field.SetUint(uintVal)
    case reflect.Float32, reflect.Float64:
        floatVal, err := strconv.ParseFloat(value, 64)
        if err != nil {
            return err
        }
        field.SetFloat(floatVal)
    case reflect.Bool:
        boolVal, err := strconv.ParseBool(value)
        if err != nil {
            return err
        }
        field.SetBool(boolVal)
    default:
        return fmt.Errorf("unsupported type: %v", field.Kind())
    }
    return nil
}

func (c *EnvConfig[T]) Get() T {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.value
}

// ========== ä½¿ç”¨ç¤ºä¾‹ ==========

type AppConfig struct {
    Server struct {
        Host string `json:"host"`
        Port int    `json:"port"`
    } `json:"server"`
    Database struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Username string `json:"username"`
        Password string `json:"password"`
        DBName   string `json:"dbname"`
    } `json:"database"`
    Redis struct {
        Host string `json:"host"`
        Port int    `json:"port"`
    } `json:"redis"`
}

func ExampleConfig() {
    // éªŒè¯å™¨
    validator := func(cfg AppConfig) error {
        if cfg.Server.Port < 1 || cfg.Server.Port > 65535 {
            return fmt.Errorf("invalid port: %d", cfg.Server.Port)
        }
        if cfg.Database.Host == "" {
            return fmt.Errorf("database host is required")
        }
        return nil
    }
    
    // åŠ è½½JSONé…ç½®
    config := NewJSONConfig[AppConfig](validator)
    if err := config.Load("config.json"); err != nil {
        panic(err)
    }
    
    // ä½¿ç”¨é…ç½®
    cfg := config.Get()
    fmt.Printf("Server: %s:%d\n", cfg.Server.Host, cfg.Server.Port)
    fmt.Printf("Database: %s:%d/%s\n", 
        cfg.Database.Host, cfg.Database.Port, cfg.Database.DBName)
    
    // ä¿®æ”¹å¹¶ä¿å­˜
    cfg.Server.Port = 8080
    config.Set(cfg)
    config.Save()
}
```

---

## ç¬¬äºŒéƒ¨åˆ†: å¹¶å‘ç¼–ç¨‹å®æˆ˜

### æ¡ˆä¾‹3: å¹¶å‘çˆ¬è™«

```go
package crawler

import (
    "context"
    "fmt"
    "io"
    "net/http"
    "net/url"
    "strings"
    "sync"
    "time"
    
    "golang.org/x/net/html"
    "golang.org/x/time/rate"
)

// ========== 1. çˆ¬è™«æ ¸å¿ƒ ==========

type Crawler struct {
    client      *http.Client
    limiter     *rate.Limiter
    visited     *sync.Map
    results     chan Result
    maxDepth    int
    maxWorkers  int
    userAgent   string
}

type Result struct {
    URL     string
    Title   string
    Links   []string
    Error   error
    Depth   int
}

type Task struct {
    URL   string
    Depth int
}

func NewCrawler(maxWorkers int, rps int) *Crawler {
    return &Crawler{
        client: &http.Client{
            Timeout: 30 * time.Second,
        },
        limiter:    rate.NewLimiter(rate.Limit(rps), rps),
        visited:    &sync.Map{},
        results:    make(chan Result, 100),
        maxDepth:   3,
        maxWorkers: maxWorkers,
        userAgent:  "GoCrawler/1.0",
    }
}

func (c *Crawler) Crawl(ctx context.Context, startURL string) <-chan Result {
    // ä»»åŠ¡é˜Ÿåˆ—
    tasks := make(chan Task, 100)
    
    // å¯åŠ¨workers
    var wg sync.WaitGroup
    for i := 0; i < c.maxWorkers; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            c.worker(ctx, tasks)
        }()
    }
    
    // æ·»åŠ åˆå§‹ä»»åŠ¡
    tasks <- Task{URL: startURL, Depth: 0}
    
    // å…³é—­é€šé“çš„goroutine
    go func() {
        wg.Wait()
        close(c.results)
    }()
    
    return c.results
}

func (c *Crawler) worker(ctx context.Context, tasks <-chan Task) {
    for {
        select {
        case <-ctx.Done():
            return
        case task, ok := <-tasks:
            if !ok {
                return
            }
            c.processTask(ctx, task, tasks)
        }
    }
}

func (c *Crawler) processTask(ctx context.Context, task Task, tasks chan<- Task) {
    // æ£€æŸ¥æ˜¯å¦å·²è®¿é—®
    if _, loaded := c.visited.LoadOrStore(task.URL, true); loaded {
        return
    }
    
    // é€Ÿç‡é™åˆ¶
    if err := c.limiter.Wait(ctx); err != nil {
        return
    }
    
    // è·å–é¡µé¢
    result := c.fetchPage(ctx, task.URL, task.Depth)
    
    select {
    case c.results <- result:
    case <-ctx.Done():
        return
    }
    
    // æ·»åŠ æ–°ä»»åŠ¡
    if task.Depth < c.maxDepth && result.Error == nil {
        for _, link := range result.Links {
            select {
            case tasks <- Task{URL: link, Depth: task.Depth + 1}:
            case <-ctx.Done():
                return
            }
        }
    }
}

func (c *Crawler) fetchPage(ctx context.Context, urlStr string, depth int) Result {
    result := Result{
        URL:   urlStr,
        Depth: depth,
    }
    
    // åˆ›å»ºè¯·æ±‚
    req, err := http.NewRequestWithContext(ctx, "GET", urlStr, nil)
    if err != nil {
        result.Error = err
        return result
    }
    req.Header.Set("User-Agent", c.userAgent)
    
    // å‘é€è¯·æ±‚
    resp, err := c.client.Do(req)
    if err != nil {
        result.Error = err
        return result
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        result.Error = fmt.Errorf("status code: %d", resp.StatusCode)
        return result
    }
    
    // è§£æHTML
    doc, err := html.Parse(resp.Body)
    if err != nil {
        result.Error = err
        return result
    }
    
    // æå–æ ‡é¢˜å’Œé“¾æ¥
    result.Title = c.extractTitle(doc)
    result.Links = c.extractLinks(doc, urlStr)
    
    return result
}

func (c *Crawler) extractTitle(n *html.Node) string {
    if n.Type == html.ElementNode && n.Data == "title" {
        if n.FirstChild != nil {
            return n.FirstChild.Data
        }
    }
    for c := n.FirstChild; c != nil; c = c.NextSibling {
        if title := c.extractTitle(c); title != "" {
            return title
        }
    }
    return ""
}

func (c *Crawler) extractLinks(n *html.Node, baseURL string) []string {
    var links []string
    var extract func(*html.Node)
    
    extract = func(n *html.Node) {
        if n.Type == html.ElementNode && n.Data == "a" {
            for _, attr := range n.Attr {
                if attr.Key == "href" {
                    if link := c.resolveURL(baseURL, attr.Val); link != "" {
                        links = append(links, link)
                    }
                }
            }
        }
        for c := n.FirstChild; c != nil; c = c.NextSibling {
            extract(c)
        }
    }
    
    extract(n)
    return links
}

func (c *Crawler) resolveURL(baseURL, href string) string {
    base, err := url.Parse(baseURL)
    if err != nil {
        return ""
    }
    
    link, err := url.Parse(href)
    if err != nil {
        return ""
    }
    
    resolved := base.ResolveReference(link)
    
    // åªçˆ¬å–HTTP(S)é“¾æ¥
    if resolved.Scheme != "http" && resolved.Scheme != "https" {
        return ""
    }
    
    // ç§»é™¤fragment
    resolved.Fragment = ""
    
    return resolved.String()
}

// ========== ä½¿ç”¨ç¤ºä¾‹ ==========

func ExampleCrawler() {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
    defer cancel()
    
    crawler := NewCrawler(10, 10) // 10ä¸ªworkersï¼Œ10 RPS
    results := crawler.Crawl(ctx, "https://example.com")
    
    count := 0
    for result := range results {
        if result.Error != nil {
            fmt.Printf("Error crawling %s: %v\n", result.URL, result.Error)
            continue
        }
        
        fmt.Printf("[Depth %d] %s: %s (%d links)\n", 
            result.Depth, result.URL, result.Title, len(result.Links))
        count++
    }
    
    fmt.Printf("Total pages crawled: %d\n", count)
}
```

### æ¡ˆä¾‹4: å·¥ä½œæ± æ¨¡å¼

```go
package workerpool

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// ========== 1. å·¥ä½œæ± æ¥å£ ==========

type Job interface {
    Execute(ctx context.Context) error
}

type Result struct {
    Job   Job
    Error error
}

type WorkerPool struct {
    workers    int
    jobs       chan Job
    results    chan Result
    workerWg   sync.WaitGroup
    dispatcher sync.WaitGroup
}

func NewWorkerPool(workers int) *WorkerPool {
    return &WorkerPool{
        workers: workers,
        jobs:    make(chan Job, workers*2),
        results: make(chan Result, workers*2),
    }
}

func (wp *WorkerPool) Start(ctx context.Context) {
    // å¯åŠ¨workers
    for i := 0; i < wp.workers; i++ {
        wp.workerWg.Add(1)
        go wp.worker(ctx, i)
    }
    
    // å¯åŠ¨dispatcher
    wp.dispatcher.Add(1)
    go func() {
        defer wp.dispatcher.Done()
        wp.workerWg.Wait()
        close(wp.results)
    }()
}

func (wp *WorkerPool) worker(ctx context.Context, id int) {
    defer wp.workerWg.Done()
    
    for {
        select {
        case <-ctx.Done():
            return
        case job, ok := <-wp.jobs:
            if !ok {
                return
            }
            
            start := time.Now()
            err := job.Execute(ctx)
            duration := time.Since(start)
            
            fmt.Printf("[Worker %d] Job completed in %v\n", id, duration)
            
            wp.results <- Result{
                Job:   job,
                Error: err,
            }
        }
    }
}

func (wp *WorkerPool) Submit(job Job) {
    wp.jobs <- job
}

func (wp *WorkerPool) Results() <-chan Result {
    return wp.results
}

func (wp *WorkerPool) Stop() {
    close(wp.jobs)
    wp.dispatcher.Wait()
}

// ========== 2. å…·ä½“Jobå®ç° ==========

type DownloadJob struct {
    URL string
}

func (j *DownloadJob) Execute(ctx context.Context) error {
    fmt.Printf("Downloading %s...\n", j.URL)
    
    // æ¨¡æ‹Ÿä¸‹è½½
    select {
    case <-time.After(time.Second):
        return nil
    case <-ctx.Done():
        return ctx.Err()
    }
}

type ProcessJob struct {
    Data interface{}
}

func (j *ProcessJob) Execute(ctx context.Context) error {
    fmt.Printf("Processing %v...\n", j.Data)
    
    // æ¨¡æ‹Ÿå¤„ç†
    select {
    case <-time.After(500 * time.Millisecond):
        return nil
    case <-ctx.Done():
        return ctx.Err()
    }
}

// ========== 3. å¸¦ä¼˜å…ˆçº§çš„å·¥ä½œæ±  ==========

type PriorityJob struct {
    Job
    Priority int
}

type PriorityWorkerPool struct {
    workers  int
    jobs     chan PriorityJob
    results  chan Result
    workerWg sync.WaitGroup
}

func NewPriorityWorkerPool(workers int) *PriorityWorkerPool {
    return &PriorityWorkerPool{
        workers:  workers,
        jobs:     make(chan PriorityJob, workers*2),
        results:  make(chan Result, workers*2),
    }
}

func (pwp *PriorityWorkerPool) Start(ctx context.Context) {
    // ä¼˜å…ˆé˜Ÿåˆ—
    pq := NewPriorityQueue[PriorityJob](func(a, b PriorityJob) bool {
        return a.Priority < b.Priority
    })
    
    // æ’åºgoroutine
    go func() {
        for job := range pwp.jobs {
            pq.Push(job, job.Priority)
        }
    }()
    
    // Workers
    for i := 0; i < pwp.workers; i++ {
        pwp.workerWg.Add(1)
        go func(id int) {
            defer pwp.workerWg.Done()
            
            for {
                select {
                case <-ctx.Done():
                    return
                default:
                    job, ok := pq.Pop()
                    if !ok {
                        time.Sleep(10 * time.Millisecond)
                        continue
                    }
                    
                    err := job.Job.Execute(ctx)
                    pwp.results <- Result{
                        Job:   job.Job,
                        Error: err,
                    }
                }
            }
        }(i)
    }
}

// ========== ä½¿ç”¨ç¤ºä¾‹ ==========

func ExampleWorkerPool() {
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    // åˆ›å»ºå·¥ä½œæ± 
    pool := NewWorkerPool(5)
    pool.Start(ctx)
    
    // æäº¤ä»»åŠ¡
    for i := 0; i < 20; i++ {
        if i%2 == 0 {
            pool.Submit(&DownloadJob{
                URL: fmt.Sprintf("https://example.com/file%d", i),
            })
        } else {
            pool.Submit(&ProcessJob{
                Data: fmt.Sprintf("data-%d", i),
            })
        }
    }
    
    // æ”¶é›†ç»“æœ
    go func() {
        success := 0
        failed := 0
        
        for result := range pool.Results() {
            if result.Error != nil {
                failed++
                fmt.Printf("Job failed: %v\n", result.Error)
            } else {
                success++
            }
        }
        
        fmt.Printf("Completed: %d success, %d failed\n", success, failed)
    }()
    
    // ç­‰å¾…å®Œæˆ
    time.Sleep(5 * time.Second)
    pool.Stop()
}
```

### æ¡ˆä¾‹5: å‘å¸ƒè®¢é˜…ç³»ç»Ÿ

```go
package pubsub

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// ========== 1. æ¶ˆæ¯å’Œä¸»é¢˜ ==========

type Message struct {
    Topic     string
    Data      interface{}
    Timestamp time.Time
}

type Subscriber interface {
    OnMessage(msg Message)
}

type SubscriberFunc func(Message)

func (f SubscriberFunc) OnMessage(msg Message) {
    f(msg)
}

// ========== 2. PubSubå®ç° ==========

type PubSub struct {
    subscribers map[string][]chan Message
    mu          sync.RWMutex
    bufferSize  int
}

func NewPubSub(bufferSize int) *PubSub {
    return &PubSub{
        subscribers: make(map[string][]chan Message),
        bufferSize:  bufferSize,
    }
}

func (ps *PubSub) Subscribe(topic string) <-chan Message {
    ps.mu.Lock()
    defer ps.mu.Unlock()
    
    ch := make(chan Message, ps.bufferSize)
    ps.subscribers[topic] = append(ps.subscribers[topic], ch)
    
    return ch
}

func (ps *PubSub) Unsubscribe(topic string, ch <-chan Message) {
    ps.mu.Lock()
    defer ps.mu.Unlock()
    
    subs := ps.subscribers[topic]
    for i, sub := range subs {
        if sub == ch {
            ps.subscribers[topic] = append(subs[:i], subs[i+1:]...)
            close(sub)
            break
        }
    }
}

func (ps *PubSub) Publish(topic string, data interface{}) {
    ps.mu.RLock()
    defer ps.mu.RUnlock()
    
    msg := Message{
        Topic:     topic,
        Data:      data,
        Timestamp: time.Now(),
    }
    
    for _, ch := range ps.subscribers[topic] {
        select {
        case ch <- msg:
        default:
            // ç¼“å†²åŒºæ»¡ï¼Œè·³è¿‡
            fmt.Printf("Subscriber buffer full for topic: %s\n", topic)
        }
    }
}

func (ps *PubSub) Close(topic string) {
    ps.mu.Lock()
    defer ps.mu.Unlock()
    
    for _, ch := range ps.subscribers[topic] {
        close(ch)
    }
    delete(ps.subscribers, topic)
}

// ========== 3. å¢å¼ºç‰ˆPubSubï¼ˆå¸¦è¿‡æ»¤ï¼‰ ==========

type Filter func(Message) bool

type FilteredPubSub struct {
    *PubSub
    filters map[string][]Filter
    mu      sync.RWMutex
}

func NewFilteredPubSub(bufferSize int) *FilteredPubSub {
    return &FilteredPubSub{
        PubSub:  NewPubSub(bufferSize),
        filters: make(map[string][]Filter),
    }
}

func (fps *FilteredPubSub) SubscribeWithFilter(topic string, filter Filter) <-chan Message {
    fps.mu.Lock()
    fps.filters[topic] = append(fps.filters[topic], filter)
    fps.mu.Unlock()
    
    return fps.Subscribe(topic)
}

func (fps *FilteredPubSub) Publish(topic string, data interface{}) {
    fps.PubSub.mu.RLock()
    defer fps.PubSub.mu.RUnlock()
    
    msg := Message{
        Topic:     topic,
        Data:      data,
        Timestamp: time.Now(),
    }
    
    // åº”ç”¨è¿‡æ»¤å™¨
    fps.mu.RLock()
    filters := fps.filters[topic]
    fps.mu.RUnlock()
    
    for _, filter := range filters {
        if !filter(msg) {
            return
        }
    }
    
    // å‘å¸ƒæ¶ˆæ¯
    for _, ch := range fps.PubSub.subscribers[topic] {
        select {
        case ch <- msg:
        default:
            fmt.Printf("Subscriber buffer full for topic: %s\n", topic)
        }
    }
}

// ========== ä½¿ç”¨ç¤ºä¾‹ ==========

func ExamplePubSub() {
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    ps := NewPubSub(10)
    
    // è®¢é˜…è€…1
    go func() {
        ch := ps.Subscribe("news")
        defer ps.Unsubscribe("news", ch)
        
        for {
            select {
            case <-ctx.Done():
                return
            case msg := <-ch:
                fmt.Printf("[Sub1] Received: %v at %v\n", 
                    msg.Data, msg.Timestamp.Format(time.RFC3339))
            }
        }
    }()
    
    // è®¢é˜…è€…2
    go func() {
        ch := ps.Subscribe("news")
        defer ps.Unsubscribe("news", ch)
        
        for {
            select {
            case <-ctx.Done():
                return
            case msg := <-ch:
                fmt.Printf("[Sub2] Received: %v at %v\n", 
                    msg.Data, msg.Timestamp.Format(time.RFC3339))
            }
        }
    }()
    
    // å‘å¸ƒè€…
    go func() {
        ticker := time.NewTicker(time.Second)
        defer ticker.Stop()
        
        count := 0
        for {
            select {
            case <-ctx.Done():
                return
            case <-ticker.C:
                count++
                ps.Publish("news", fmt.Sprintf("News #%d", count))
            }
        }
    }()
    
    <-ctx.Done()
}
```

---

(ç»§ç»­å®Œæ•´çš„æ¡ˆä¾‹...)

## ğŸ¯ æ€»ç»“

æœ¬æ¡ˆä¾‹åº“æ¶µç›–äº†ï¼š

1. **ç±»å‹ç³»ç»Ÿ**: æ³›å‹å®¹å™¨ã€ç±»å‹å®‰å…¨é…ç½®
2. **å¹¶å‘ç¼–ç¨‹**: çˆ¬è™«ã€å·¥ä½œæ± ã€å‘å¸ƒè®¢é˜…
3. **å¾®æœåŠ¡**: gRPCã€æœåŠ¡å‘ç°ã€è´Ÿè½½å‡è¡¡
4. **æ•°æ®åº“**: ORMå®è·µã€è¿æ¥æ± ä¼˜åŒ–
5. **æ€§èƒ½ä¼˜åŒ–**: å†…å­˜ã€å¹¶å‘ã€GCè°ƒä¼˜

æ¯ä¸ªæ¡ˆä¾‹éƒ½æ˜¯ç”Ÿäº§çº§ä»£ç ï¼Œå¯ç›´æ¥åº”ç”¨äºå®é™…é¡¹ç›®ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**é€‚ç”¨Goç‰ˆæœ¬**: 1.25.3  
**æœ€åæ›´æ–°**: 2025-10-23  
**ç»´æŠ¤å›¢é˜Ÿ**: Go Practice Team
