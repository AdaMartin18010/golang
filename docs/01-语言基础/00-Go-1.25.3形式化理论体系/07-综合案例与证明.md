# ç»¼åˆæ¡ˆä¾‹ä¸è¯æ˜

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**åŸºå‡†æ—¥æœŸ**: 2025å¹´10æœˆ22æ—¥  
**Goç‰ˆæœ¬**: Go 1.25.3  
**ç†è®ºåŸºç¡€**: å½¢å¼åŒ–éªŒè¯ + ç¨‹åºè¯æ˜ + Bugåˆ†æ  
**å­—æ•°**: ~14,000å­—

---

## ğŸ“š ç›®å½•

- [ç»¼åˆæ¡ˆä¾‹ä¸è¯æ˜](#ç»¼åˆæ¡ˆä¾‹ä¸è¯æ˜)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [ç¬¬ä¸€éƒ¨åˆ†: å®Œæ•´ç¨‹åºéªŒè¯](#ç¬¬ä¸€éƒ¨åˆ†-å®Œæ•´ç¨‹åºéªŒè¯)
    - [1.1 ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼éªŒè¯](#11-ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼éªŒè¯)
    - [1.2 å¹¶å‘Mapçš„çº¿æ€§åŒ–æ€§è¯æ˜](#12-å¹¶å‘mapçš„çº¿æ€§åŒ–æ€§è¯æ˜)
    - [1.3 å†…å­˜æ± æ­£ç¡®æ€§éªŒè¯](#13-å†…å­˜æ± æ­£ç¡®æ€§éªŒè¯)
  - [ç¬¬äºŒéƒ¨åˆ†: å¹¶å‘ç®—æ³•æ­£ç¡®æ€§è¯æ˜](#ç¬¬äºŒéƒ¨åˆ†-å¹¶å‘ç®—æ³•æ­£ç¡®æ€§è¯æ˜)
    - [2.1 æ— é”æ ˆ (Lock-Free Stack)](#21-æ— é”æ ˆ-lock-free-stack)
    - [2.2 å¹¶å‘é™æµå™¨ (Rate Limiter)](#22-å¹¶å‘é™æµå™¨-rate-limiter)
    - [2.3 Work-Stealingé˜Ÿåˆ—](#23-work-stealingé˜Ÿåˆ—)
  - [ç¬¬ä¸‰éƒ¨åˆ†: å®é™…Bugå½¢å¼åŒ–åˆ†æ](#ç¬¬ä¸‰éƒ¨åˆ†-å®é™…bugå½¢å¼åŒ–åˆ†æ)
    - [3.1 å¾ªç¯å˜é‡æ•è·Bug](#31-å¾ªç¯å˜é‡æ•è·bug)
    - [3.2 Channelæ­»é”Bug](#32-channelæ­»é”bug)
    - [3.3 æ•°æ®ç«äº‰Bug](#33-æ•°æ®ç«äº‰bug)
    - [3.4 å†…å­˜æ³„æ¼Bug](#34-å†…å­˜æ³„æ¼bug)
  - [ç¬¬å››éƒ¨åˆ†: ç¼–è¯‘å™¨ä¼˜åŒ–æ­£ç¡®æ€§](#ç¬¬å››éƒ¨åˆ†-ç¼–è¯‘å™¨ä¼˜åŒ–æ­£ç¡®æ€§)
    - [4.1 å†…è”ä¼˜åŒ–è¯æ˜](#41-å†…è”ä¼˜åŒ–è¯æ˜)
    - [4.2 é€ƒé€¸åˆ†ææ­£ç¡®æ€§](#42-é€ƒé€¸åˆ†ææ­£ç¡®æ€§)
    - [4.3 è¾¹ç•Œæ£€æŸ¥æ¶ˆé™¤éªŒè¯](#43-è¾¹ç•Œæ£€æŸ¥æ¶ˆé™¤éªŒè¯)
  - [ç¬¬äº”éƒ¨åˆ†: å·¥ç¨‹åº”ç”¨æŒ‡å—](#ç¬¬äº”éƒ¨åˆ†-å·¥ç¨‹åº”ç”¨æŒ‡å—)
    - [5.1 å½¢å¼åŒ–æ–¹æ³•åœ¨Goå¼€å‘ä¸­çš„åº”ç”¨](#51-å½¢å¼åŒ–æ–¹æ³•åœ¨goå¼€å‘ä¸­çš„åº”ç”¨)
    - [5.2 é™æ€åˆ†æå·¥å…·](#52-é™æ€åˆ†æå·¥å…·)
    - [5.3 ç¨‹åºéªŒè¯å·¥ä½œæµ](#53-ç¨‹åºéªŒè¯å·¥ä½œæµ)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
    - [æ ¸å¿ƒæˆæœ](#æ ¸å¿ƒæˆæœ)
    - [æ–¹æ³•è®ºä»·å€¼](#æ–¹æ³•è®ºä»·å€¼)
    - [æœªæ¥æ–¹å‘](#æœªæ¥æ–¹å‘)

---

## ç¬¬ä¸€éƒ¨åˆ†: å®Œæ•´ç¨‹åºéªŒè¯

### 1.1 ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼éªŒè¯

```go
/* ç”Ÿäº§è€…-æ¶ˆè´¹è€…å®ç° */

package main

import "sync"

type Buffer struct {
    ch   chan int
    size int
}

func NewBuffer(size int) *Buffer {
    return &Buffer{
        ch:   make(chan int, size),
        size: size,
    }
}

func (b *Buffer) Produce(value int) {
    b.ch <- value
}

func (b *Buffer) Consume() int {
    return <-b.ch
}

func main() {
    buffer := NewBuffer(10)
    var wg sync.WaitGroup
    
    // ç”Ÿäº§è€…
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for j := 0; j < 10; j++ {
                buffer.Produce(id*100 + j)
            }
        }(i)
    }
    
    // æ¶ˆè´¹è€…
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for j := 0; j < 17; j++ {  // 5*10/3 â‰ˆ 17
                v := buffer.Consume()
                process(v)
            }
        }(i)
    }
    
    wg.Wait()
}
```

```mathematical
/* å½¢å¼åŒ–éªŒè¯ */

/* ä¸å˜å¼ */

Invariant(buffer):
    0 â‰¤ len(buffer.ch) â‰¤ buffer.size

/* å®‰å…¨æ€§ */

Safety:
    âˆ€ v âˆˆ consumed_values. v âˆˆ produced_values

è¯æ˜:
ç”±channelçš„FIFOæ€§è´¨ä¿è¯ã€‚
ç”Ÿäº§è€…å†™å…¥çš„æ‰€æœ‰å€¼éƒ½åœ¨channelä¸­,
æ¶ˆè´¹è€…è¯»å–çš„å€¼å¿…ç„¶æ¥è‡ªchannelã€‚ â–¡

/* æ´»æ€§ */

Liveness:
    å¦‚æœç”Ÿäº§è€…å†™å…¥Nä¸ªå€¼,åˆ™æ¶ˆè´¹è€…æœ€ç»ˆè¯»å–Nä¸ªå€¼ã€‚

è¯æ˜:
1. ç”Ÿäº§è€…å†™å…¥Nä¸ªå€¼åˆ°channel
2. channelæ˜¯æœ‰ç•Œçš„,ä¸ä¼šä¸¢å¤±æ•°æ®
3. æ¶ˆè´¹è€…æŒç»­è¯»å–
4. ç”±channelçš„é˜»å¡è¯­ä¹‰,æ‰€æœ‰å€¼æœ€ç»ˆè¢«è¯»å– â–¡

/* æ— æ­»é” */

Deadlock_Freedom:
    ç¨‹åºä¸ä¼šæ­»é”

è¯æ˜:
åè¯æ³•ã€‚å‡è®¾å­˜åœ¨æ­»é”,åˆ™:
- æ‰€æœ‰ç”Ÿäº§è€…åœ¨ ch <- v å¤„é˜»å¡ (channelæ»¡)
- æ‰€æœ‰æ¶ˆè´¹è€…åœ¨ <-ch å¤„é˜»å¡ (channelç©º)
çŸ›ç›¾ (channelä¸èƒ½æ—¢æ»¡åˆç©º)ã€‚
å› æ­¤ä¸å­˜åœ¨æ­»é”ã€‚ â–¡

/* å¹¶å‘æ­£ç¡®æ€§ */

Concurrent_Correctness:
    å¤šä¸ªç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…å¯ä»¥å®‰å…¨å¹¶å‘æ‰§è¡Œ

è¯æ˜:
channelæ“ä½œæ˜¯åŸå­çš„,æä¾›äº†å¿…è¦çš„åŒæ­¥ã€‚
ç”Ÿäº§è€…ä¹‹é—´ä¸å†²çª (channelå†…éƒ¨åŒæ­¥),
æ¶ˆè´¹è€…ä¹‹é—´ä¸å†²çª (channelå†…éƒ¨åŒæ­¥)ã€‚ â–¡
```

### 1.2 å¹¶å‘Mapçš„çº¿æ€§åŒ–æ€§è¯æ˜

```go
/* å¹¶å‘Mapå®ç° */

type ConcurrentMap[K comparable, V any] struct {
    shards []*shard[K, V]
    hash   func(K) uint32
}

type shard[K comparable, V any] struct {
    mu    sync.RWMutex
    items map[K]V
}

func NewConcurrentMap[K comparable, V any](shardCount int) *ConcurrentMap[K, V] {
    cm := &ConcurrentMap[K, V]{
        shards: make([]*shard[K, V], shardCount),
        hash:   defaultHash[K],
    }
    for i := range cm.shards {
        cm.shards[i] = &shard[K, V]{
            items: make(map[K]V),
        }
    }
    return cm
}

func (cm *ConcurrentMap[K, V]) getShard(key K) *shard[K, V] {
    h := cm.hash(key)
    return cm.shards[h%uint32(len(cm.shards))]
}

func (cm *ConcurrentMap[K, V]) Set(key K, value V) {
    shard := cm.getShard(key)
    shard.mu.Lock()
    shard.items[key] = value  // Linearization Point
    shard.mu.Unlock()
}

func (cm *ConcurrentMap[K, V]) Get(key K) (V, bool) {
    shard := cm.getShard(key)
    shard.mu.RLock()
    value, ok := shard.items[key]  // Linearization Point
    shard.mu.RUnlock()
    return value, ok
}

func (cm *ConcurrentMap[K, V]) Delete(key K) {
    shard := cm.getShard(key)
    shard.mu.Lock()
    delete(shard.items, key)  // Linearization Point
    shard.mu.Unlock()
}
```

```mathematical
/* çº¿æ€§åŒ–æ€§è¯æ˜ */

/* çº¿æ€§åŒ–ç‚¹ */

Set(k, v):    å†™å…¥shard.items[k] = v
Get(k):       è¯»å–shard.items[k]
Delete(k):    åˆ é™¤shard.items[k]

/* çº¿æ€§åŒ–æ€§å®šç† */

å®šç† (ConcurrentMap Linearizability):
ConcurrentMapçš„æ‰€æœ‰æ“ä½œéƒ½æ˜¯çº¿æ€§åŒ–çš„ã€‚

è¯æ˜:

1. æ¯ä¸ªæ“ä½œæœ‰å”¯ä¸€çš„çº¿æ€§åŒ–ç‚¹:
   - Set: å†™å…¥mapçš„ç¬é—´
   - Get: è¯»å–mapçš„ç¬é—´
   - Delete: åˆ é™¤çš„ç¬é—´

2. è¿™äº›ç‚¹åœ¨é”ä¿æŠ¤ä¸‹æ‰§è¡Œ:
   - RWMutexä¿è¯è¯»å†™äº’æ–¥
   - å¤šä¸ªè¯»è€…å¯ä»¥å¹¶å‘
   - å†™è€…ç‹¬å 

3. æ„é€ é¡ºåºå†å²:
   æŒ‰çº¿æ€§åŒ–ç‚¹çš„çœŸå®æ—¶é—´é¡ºåºæ’åˆ—æ‰€æœ‰æ“ä½œ,
   è¿™ä¸ªé¡ºåºç­‰ä»·äºä¸€ä¸ªé¡ºåºmapçš„æ‰§è¡Œã€‚

4. ä¿æŒå®æ—¶é¡ºåº:
   å¦‚æœæ“ä½œopâ‚åœ¨çœŸå®æ—¶é—´ä¸Šå®Œæˆäºopâ‚‚å¼€å§‹ä¹‹å‰,
   åˆ™opâ‚çš„çº¿æ€§åŒ–ç‚¹ < opâ‚‚çš„çº¿æ€§åŒ–ç‚¹ã€‚

å› æ­¤ConcurrentMapæ˜¯çº¿æ€§åŒ–çš„ã€‚ â–¡

/* æ­£ç¡®æ€§æ€§è´¨ */

1. åŸå­æ€§:
   æ¯ä¸ªæ“ä½œè¦ä¹ˆå®Œå…¨å®Œæˆ,è¦ä¹ˆå®Œå…¨ä¸æ‰§è¡Œ

2. ä¸€è‡´æ€§:
   è¯»å–æ€»æ˜¯è¿”å›æœ€è¿‘ä¸€æ¬¡å†™å…¥çš„å€¼

3. éš”ç¦»æ€§:
   å¹¶å‘æ“ä½œäº’ä¸å¹²æ‰°

/* æ€§èƒ½åˆ†æ */

è¯»æ€§èƒ½: O(1) æœŸæœ›,å¤šè¯»è€…å¹¶å‘
å†™æ€§èƒ½: O(1) æœŸæœ›,å†™è€…ç‹¬å 
ç©ºé—´: O(n/s) æ¯ä¸ªshard,sä¸ºshardæ•°é‡

åˆ†ç‰‡å‡å°‘é”ç«äº‰:
- å•shard: æ‰€æœ‰æ“ä½œç«äº‰åŒä¸€é”
- å¤šshard: æ“ä½œåˆ†æ•£åˆ°ä¸åŒé”
- ç«äº‰æ¦‚ç‡: 1/s
```

### 1.3 å†…å­˜æ± æ­£ç¡®æ€§éªŒè¯

```go
/* å†…å­˜æ± å®ç° */

type Pool[T any] struct {
    pools []*sync.Pool
}

func NewPool[T any](newFunc func() T) *Pool[T] {
    numCPU := runtime.NumCPU()
    p := &Pool[T]{
        pools: make([]*sync.Pool, numCPU),
    }
    for i := range p.pools {
        p.pools[i] = &sync.Pool{
            New: func() interface{} {
                return newFunc()
            },
        }
    }
    return p
}

func (p *Pool[T]) Get() T {
    pid := runtime_procPin() % len(p.pools)
    obj := p.pools[pid].Get().(T)
    runtime_procUnpin()
    return obj
}

func (p *Pool[T]) Put(obj T) {
    pid := runtime_procPin() % len(p.pools)
    p.pools[pid].Put(obj)
    runtime_procUnpin()
}
```

```mathematical
/* å†…å­˜æ± æ­£ç¡®æ€§ */

/* ä¸å˜å¼ */

Invariant(pool):
    âˆ€ obj âˆˆ pool. initialized(obj)

/* å®‰å…¨æ€§ */

Safety:
    Get()è¿”å›çš„å¯¹è±¡æ€»æ˜¯æœ‰æ•ˆçš„

è¯æ˜:
1. Newå‡½æ•°ä¿è¯åˆ›å»ºæœ‰æ•ˆå¯¹è±¡
2. Putåªæ¥å—ç±»å‹Tçš„å¯¹è±¡
3. sync.Poolå†…éƒ¨ä¿è¯å¯¹è±¡æœ‰æ•ˆæ€§
å› æ­¤Get()æ€»æ˜¯è¿”å›æœ‰æ•ˆå¯¹è±¡ã€‚ â–¡

/* æ— ç«äº‰ */

Race_Freedom:
    åŒä¸€å¯¹è±¡ä¸ä¼šåŒæ—¶è¢«å¤šä¸ªgoroutineä½¿ç”¨

è¯æ˜:
1. Get()ä»æ± ä¸­ç§»é™¤å¯¹è±¡
2. å¯¹è±¡ä½¿ç”¨æœŸé—´ä¸åœ¨æ± ä¸­
3. Put()å½’è¿˜å¯¹è±¡åˆ°æ± 
4. sync.Poolå†…éƒ¨åŒæ­¥ä¿è¯
å› æ­¤ä¸å­˜åœ¨ç«äº‰ã€‚ â–¡

/* GCäº¤äº’ */

GC_Safety:
    GCå¯èƒ½æ¸…ç©ºæ± ,ä½†ä¸å½±å“æ­£ç¡®æ€§

è¯æ˜:
1. sync.Poolå…è®¸GCæ¸…ç©ºæ± 
2. å¦‚æœæ± ä¸ºç©º,Newå‡½æ•°åˆ›å»ºæ–°å¯¹è±¡
3. Newå‡½æ•°è¿”å›æœ‰æ•ˆå¯¹è±¡
å› æ­¤GCä¸å½±å“æ­£ç¡®æ€§ã€‚ â–¡

/* æ€§èƒ½ç‰¹æ€§ */

æ€§èƒ½åˆ†æ:
- Get/Put: O(1) æœŸæœ›
- æ— é”æˆ–ä½ç«äº‰ (per-Pæ± )
- GCå¼€é”€å¯å¿½ç•¥

å†…å­˜æ•ˆç‡:
- å‡å°‘åˆ†é…: é‡ç”¨å¯¹è±¡
- å‡å°‘GCå‹åŠ›: å¯¹è±¡æ± åŒ–
- å±€éƒ¨æ€§: per-På‡å°‘ç¼“å­˜å¤±æ•ˆ
```

---

## ç¬¬äºŒéƒ¨åˆ†: å¹¶å‘ç®—æ³•æ­£ç¡®æ€§è¯æ˜

### 2.1 æ— é”æ ˆ (Lock-Free Stack)

```go
/* æ— é”æ ˆå®ç° */

type Node[T any] struct {
    value T
    next  *Node[T]
}

type LockFreeStack[T any] struct {
    head atomic.Pointer[Node[T]]
}

func (s *LockFreeStack[T]) Push(value T) {
    node := &Node[T]{value: value}
    for {
        old := s.head.Load()
        node.next = old
        if s.head.CompareAndSwap(old, node) {
            return
        }
        // CASå¤±è´¥,é‡è¯•
    }
}

func (s *LockFreeStack[T]) Pop() (T, bool) {
    for {
        old := s.head.Load()
        if old == nil {
            var zero T
            return zero, false
        }
        next := old.next
        if s.head.CompareAndSwap(old, next) {
            return old.value, true
        }
        // CASå¤±è´¥,é‡è¯•
    }
}
```

```mathematical
/* æ— é”æ ˆæ­£ç¡®æ€§ */

/* çº¿æ€§åŒ–ç‚¹ */

Push(v):  æˆåŠŸçš„CAS(old, new)
Pop():    æˆåŠŸçš„CAS(old, next)

/* æ­£ç¡®æ€§å®šç† */

å®šç† (Lock-Free Stack Correctness):
æ— é”æ ˆçš„Pushå’ŒPopæ“ä½œæ˜¯çº¿æ€§åŒ–çš„ã€‚

è¯æ˜:

1. Pushçš„çº¿æ€§åŒ–ç‚¹:
   CASæˆåŠŸæ—¶,nodeè¢«åŸå­åœ°é“¾æ¥åˆ°æ ˆé¡¶ã€‚
   æ­¤æ—¶è¯¥Pushæ“ä½œç”Ÿæ•ˆã€‚

2. Popçš„çº¿æ€§åŒ–ç‚¹:
   CASæˆåŠŸæ—¶,æ—§å¤´èŠ‚ç‚¹è¢«åŸå­åœ°ç§»é™¤ã€‚
   æ­¤æ—¶è¯¥Popæ“ä½œç”Ÿæ•ˆã€‚

3. CASä¿è¯åŸå­æ€§:
   CASæ˜¯åŸå­æ“ä½œ,
   è¦ä¹ˆå®Œå…¨æˆåŠŸ,è¦ä¹ˆå®Œå…¨å¤±è´¥ã€‚

4. é‡è¯•ä¿è¯æ´»æ€§:
   CASå¤±è´¥åé‡è¯•,
   æœ€ç»ˆä¼šæˆåŠŸ(æ— é¥¥é¥¿)ã€‚

æ„é€ çº¿æ€§å†å²:
æŒ‰CASæˆåŠŸçš„é¡ºåºæ’åˆ—æ‰€æœ‰æ“ä½œ,
ç­‰ä»·äºé¡ºåºæ ˆçš„æ‰§è¡Œã€‚ â–¡

/* æ— é”æ€§ (Lock-Freedom) */

å®šç† (Lock-Freedom):
åœ¨ä»»æ„æ—¶åˆ»,è‡³å°‘æœ‰ä¸€ä¸ªæ“ä½œèƒ½å¤Ÿè¿›å±•ã€‚

è¯æ˜:
è®¾æœ‰nä¸ªå¹¶å‘æ“ä½œã€‚
åœ¨æ¯è½®CASä¸­,è‡³å°‘æœ‰ä¸€ä¸ªä¼šæˆåŠŸã€‚
æˆåŠŸçš„æ“ä½œå®Œæˆ,å…¶ä»–æ“ä½œé‡è¯•ã€‚
å› æ­¤ç³»ç»Ÿæ•´ä½“æ€»åœ¨è¿›å±•ã€‚ â–¡

/* ABAé—®é¢˜ */

ABAé—®é¢˜:
  head: A â†’ B â†’ C
  Thread 1: è¯»å–A,å‡†å¤‡CAS(A, B)
  Thread 2: Pop A, Pop B, Push A
  head: A â†’ C
  Thread 1: CAS(A, B) æˆåŠŸ! (ä½†ä¸­é—´çŠ¶æ€æ”¹å˜äº†)

è§£å†³æ–¹æ¡ˆ:
1. ä½¿ç”¨ç‰ˆæœ¬å· (Tagged Pointer)
2. Hazard Pointers
3. Epoch-Based Reclamation

Goçš„GCé¿å…äº†ABA:
- GCä¿è¯è¢«å¼•ç”¨çš„å¯¹è±¡ä¸è¢«å›æ”¶
- å³ä½¿Popäº†A,Aä»ç„¶æœ‰æ•ˆ
- é‡æ–°Pushçš„Aæ˜¯åŒä¸€ä¸ªå¯¹è±¡

/* æ€§èƒ½åˆ†æ */

æ— ç«äº‰æƒ…å†µ: O(1) å•æ¬¡CAS
é«˜ç«äº‰æƒ…å†µ: O(k) kä¸ºç«äº‰goroutineæ•°
å¹³å‡: O(log n) nä¸ºå¹¶å‘åº¦
```

### 2.2 å¹¶å‘é™æµå™¨ (Rate Limiter)

```go
/* Token Bucketé™æµå™¨ */

type RateLimiter struct {
    rate       int64         // tokens per second
    capacity   int64
    tokens     int64
    lastUpdate time.Time
    mu         sync.Mutex
}

func NewRateLimiter(rate, capacity int64) *RateLimiter {
    return &RateLimiter{
        rate:       rate,
        capacity:   capacity,
        tokens:     capacity,
        lastUpdate: time.Now(),
    }
}

func (r *RateLimiter) Allow() bool {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    now := time.Now()
    elapsed := now.Sub(r.lastUpdate).Seconds()
    
    // è¡¥å……tokens
    r.tokens += int64(elapsed * float64(r.rate))
    if r.tokens > r.capacity {
        r.tokens = r.capacity
    }
    r.lastUpdate = now
    
    // å°è¯•æ¶ˆè´¹ä¸€ä¸ªtoken
    if r.tokens > 0 {
        r.tokens--
        return true  // Linearization Point
    }
    return false  // Linearization Point
}
```

```mathematical
/* é™æµå™¨æ­£ç¡®æ€§ */

/* é™æµæ€§è´¨ */

Rate_Limit_Property:
    åœ¨ä»»æ„æ—¶é—´çª—å£[t, t+Î”t]å†…,
    é€šè¿‡çš„è¯·æ±‚æ•° â‰¤ rate Ã— Î”t + capacity

è¯æ˜:

è®¾åœ¨æ—¶é—´tâ‚€å¼€å§‹,tokens = capacityã€‚
åœ¨[tâ‚€, tâ‚€+Î”t]å†…:
- è¡¥å……çš„tokens: rate Ã— Î”t
- åˆå§‹tokens: capacity
- æœ€å¤šé€šè¿‡: capacity + rate Ã— Î”t

å› æ­¤æ»¡è¶³é™æµæ€§è´¨ã€‚ â–¡

/* å…¬å¹³æ€§ */

Fairness:
    å…ˆåˆ°è¾¾çš„è¯·æ±‚ä¼˜å…ˆè·å¾—token

è¯æ˜:
mutexä¿è¯ä¸²è¡ŒåŒ–,
å…ˆlockçš„å…ˆæ‰§è¡Œ,
å› æ­¤å…ˆåˆ°å…ˆæœåŠ¡ã€‚ â–¡

/* çº¿æ€§åŒ–æ€§ */

å®šç† (Rate Limiter Linearizability):
Allow()æ“ä½œæ˜¯çº¿æ€§åŒ–çš„ã€‚

è¯æ˜:
çº¿æ€§åŒ–ç‚¹:
- tokens > 0: tokens--
- tokens == 0: æ£€æŸ¥tokens

mutexä¿è¯è¿™äº›ç‚¹ä¸²è¡Œæ‰§è¡Œ,
æ„æˆçº¿æ€§å†å²ã€‚ â–¡

/* æ€§èƒ½ä¼˜åŒ– */

ä¼˜åŒ–ç‰ˆæœ¬ (æ— é”):

type AtomicRateLimiter struct {
    rate     int64
    capacity int64
    state    atomic.Int64  // packed (tokens, lastUpdate)
}

func (r *AtomicRateLimiter) Allow() bool {
    for {
        oldState := r.state.Load()
        oldTokens, oldTime := unpack(oldState)
        
        now := time.Now().UnixNano()
        elapsed := float64(now - oldTime) / 1e9
        newTokens := min(oldTokens + int64(elapsed*float64(r.rate)), r.capacity)
        
        if newTokens > 0 {
            newState := pack(newTokens-1, now)
            if r.state.CompareAndSwap(oldState, newState) {
                return true
            }
        } else {
            return false
        }
    }
}

æ— é”ç‰ˆæœ¬:
- é«˜åå (æ— é”ç«äº‰)
- CASä¿è¯åŸå­æ€§
- ä»ç„¶çº¿æ€§åŒ–
```

### 2.3 Work-Stealingé˜Ÿåˆ—

```go
/* Work-Stealing Deque */

type WorkStealingDeque[T any] struct {
    buffer []atomic.Pointer[T]
    top    atomic.Int64
    bottom atomic.Int64
    mask   int64
}

func NewWorkStealingDeque[T any](capacity int) *WorkStealingDeque[T] {
    return &WorkStealingDeque[T]{
        buffer: make([]atomic.Pointer[T], capacity),
        mask:   int64(capacity - 1),
    }
}

// Owner: Push to bottom
func (d *WorkStealingDeque[T]) Push(item T) bool {
    b := d.bottom.Load()
    t := d.top.Load()
    
    if b-t >= int64(len(d.buffer)) {
        return false  // Full
    }
    
    d.buffer[b&d.mask].Store(&item)
    d.bottom.Store(b + 1)  // Linearization Point
    return true
}

// Owner: Pop from bottom
func (d *WorkStealingDeque[T]) Pop() (T, bool) {
    b := d.bottom.Load() - 1
    d.bottom.Store(b)
    
    t := d.top.Load()
    
    if t <= b {
        // Non-empty
        item := d.buffer[b&d.mask].Load()
        if t == b {
            // Last item, race with stealers
            if !d.top.CompareAndSwap(t, t+1) {
                // Lost race
                d.bottom.Store(b + 1)
                var zero T
                return zero, false
            }
            d.bottom.Store(b + 1)
        }
        return *item, true
    } else {
        // Empty
        d.bottom.Store(b + 1)
        var zero T
        return zero, false
    }
}

// Stealers: Steal from top
func (d *WorkStealingDeque[T]) Steal() (T, bool) {
    t := d.top.Load()
    b := d.bottom.Load()
    
    if t < b {
        // Non-empty
        item := d.buffer[t&d.mask].Load()
        if !d.top.CompareAndSwap(t, t+1) {
            // Lost race
            var zero T
            return zero, false
        }
        return *item, true  // Linearization Point
    }
    
    var zero T
    return zero, false
}
```

```mathematical
/* Work-Stealingé˜Ÿåˆ—æ­£ç¡®æ€§ */

/* æ­£ç¡®æ€§å®šç† */

å®šç† (Work-Stealing Deque Correctness):
1. Pushå’ŒPop by owneræ˜¯wait-freeçš„
2. Stealæ˜¯lock-freeçš„
3. æ‰€æœ‰æ“ä½œéƒ½æ˜¯çº¿æ€§åŒ–çš„

è¯æ˜:

1. Wait-Freedom (Push/Pop):
   Ownerç‹¬å bottomç«¯,
   æ— ç«äº‰,å›ºå®šæ—¶é—´å®Œæˆã€‚

2. Lock-Freedom (Steal):
   Stealerä¹‹é—´é€šè¿‡CASç«äº‰top,
   è‡³å°‘ä¸€ä¸ªä¼šæˆåŠŸã€‚

3. Linearizability:
   çº¿æ€§åŒ–ç‚¹:
   - Push: Store(b+1)
   - Pop: Load(t) or CAS(t, t+1)
   - Steal: CAS(t, t+1)
   
   è¿™äº›ç‚¹ä¸²è¡ŒåŒ–æ‰€æœ‰æ“ä½œã€‚ â–¡

/* æ— ç«äº‰æ€§è´¨ */

Contention-Free Property:
Ownerçš„Push/Popä¸ä¸Stealå†²çª(å¤§éƒ¨åˆ†æ—¶å€™)ã€‚

è¯æ˜:
- Owneræ“ä½œbottomç«¯
- Stealeræ“ä½œtopç«¯
- åªæœ‰é˜Ÿåˆ—å‰©ä¸€ä¸ªå…ƒç´ æ—¶ç«äº‰
å› æ­¤ç«äº‰å¾ˆå°‘ã€‚ â–¡

/* åº”ç”¨:Goè°ƒåº¦å™¨ */

Goè°ƒåº¦å™¨ä½¿ç”¨Work-Stealing:
- æ¯ä¸ªPæœ‰æœ¬åœ°è¿è¡Œé˜Ÿåˆ—(deque)
- Pä»bottom Push/Popè‡ªå·±çš„G
- å…¶ä»–Pä»top Stealç©ºé—²çš„G

æ€§èƒ½ä¼˜åŠ¿:
- Owneræ— ç«äº‰ (99%æƒ…å†µ)
- Load balancing (Stealing)
- Cache-friendly (Local queue)
```

---

## ç¬¬ä¸‰éƒ¨åˆ†: å®é™…Bugå½¢å¼åŒ–åˆ†æ

### 3.1 å¾ªç¯å˜é‡æ•è·Bug

```go
/* Bugç¤ºä¾‹ */

// é”™è¯¯ä»£ç  (Go 1.21-)
func BuggyCode() {
    var wg sync.WaitGroup
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            fmt.Println(i)  // Bug: å¯èƒ½æ‰“å° 3, 3, 3
        }()
    }
    wg.Wait()
}

// æ­£ç¡®ä»£ç 1 (Go 1.21-): æ‰‹åŠ¨æ‹·è´
func FixedCode1() {
    var wg sync.WaitGroup
    for i := 0; i < 3; i++ {
        i := i  // åˆ›å»ºæ–°å˜é‡
        wg.Add(1)
        go func() {
            defer wg.Done()
            fmt.Println(i)  // æ­£ç¡®: æ‰“å° 0, 1, 2
        }()
    }
    wg.Wait()
}

// æ­£ç¡®ä»£ç 2 (Go 1.22+): è‡ªåŠ¨ä¿®å¤
func FixedCode2() {
    var wg sync.WaitGroup
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            fmt.Println(i)  // æ­£ç¡®: æ‰“å° 0, 1, 2 (æ–°è¯­ä¹‰)
        }()
    }
    wg.Wait()
}
```

```mathematical
/* Bugå½¢å¼åŒ–åˆ†æ */

/* æ—§è¯­ä¹‰ */

[Old-For-Semantics]
âŸ¨for i := 0; i < 3; i++ { body }, Ïƒ, Î¼, ÏâŸ© â†’
  let addr_i = allocate() in
  Ïƒ[i â†¦ addr_i]
  
  iteration 0: Ïƒ[addr_i] = 0; âŸ¨body, Ïƒ, Î¼, ÏâŸ©
  iteration 1: Ïƒ[addr_i] = 1; âŸ¨body, Ïƒ, Î¼, ÏâŸ©
  iteration 2: Ïƒ[addr_i] = 2; âŸ¨body, Ïƒ, Î¼, ÏâŸ©

é—­åŒ…æ•è·: closure captures addr_i

Bugåˆ†æ:
goroutine 1: å»¶è¿Ÿæ‰§è¡Œ, reads Ïƒ[addr_i] â†’ å¯èƒ½è¯»åˆ°2æˆ–3
goroutine 2: å»¶è¿Ÿæ‰§è¡Œ, reads Ïƒ[addr_i] â†’ å¯èƒ½è¯»åˆ°2æˆ–3
goroutine 3: å»¶è¿Ÿæ‰§è¡Œ, reads Ïƒ[addr_i] â†’ å¯èƒ½è¯»åˆ°3

/* æ–°è¯­ä¹‰ */

[New-For-Semantics]
âŸ¨for i := 0; i < 3; i++ { body }, Ïƒ, Î¼, ÏâŸ© â†’
  iteration 0:
    let addr_iâ‚€ = allocate() in
    Ïƒ'â‚€ = Ïƒ[i â†¦ addr_iâ‚€]; Ïƒ'â‚€[addr_iâ‚€] = 0
    âŸ¨body, Ïƒ'â‚€, Î¼, ÏâŸ©
  
  iteration 1:
    let addr_iâ‚ = allocate() in
    Ïƒ'â‚ = Ïƒ[i â†¦ addr_iâ‚]; Ïƒ'â‚[addr_iâ‚] = 1
    âŸ¨body, Ïƒ'â‚, Î¼, ÏâŸ©
  
  iteration 2:
    let addr_iâ‚‚ = allocate() in
    Ïƒ'â‚‚ = Ïƒ[i â†¦ addr_iâ‚‚]; Ïƒ'â‚‚[addr_iâ‚‚] = 2
    âŸ¨body, Ïƒ'â‚‚, Î¼, ÏâŸ©

é—­åŒ…æ•è·: closure captures addr_iâ‚€, addr_iâ‚, addr_iâ‚‚ (ä¸åŒåœ°å€)

ä¿®å¤åˆ†æ:
goroutine 1: reads Ïƒ'â‚€[addr_iâ‚€] â†’ 0
goroutine 2: reads Ïƒ'â‚[addr_iâ‚] â†’ 1
goroutine 3: reads Ïƒ'â‚‚[addr_iâ‚‚] â†’ 2

/* Bugæ£€æµ‹è§„åˆ™ */

å®šç† (Loop Variable Capture Detection):
å¦‚æœå¾ªç¯å˜é‡çš„åœ°å€åœ¨å¾ªç¯ä½“ä¸­é€ƒé€¸,
ä¸”Goç‰ˆæœ¬ < 1.22,
åˆ™å¯èƒ½å­˜åœ¨bugã€‚

æ£€æµ‹ç®—æ³•:
function detect_loop_var_bug(loop):
    for var in loop.variables:
        if escapes(var, loop.body) and go_version < 1.22:
            warn("potential loop variable capture bug")

/* è¿ç§»å®‰å…¨æ€§ */

å®šç† (Migration Safety):
å¦‚æœä»£ç ä¸ä¾èµ–å¾ªç¯å˜é‡çš„åœ°å€åŒä¸€æ€§,
åˆ™ä»æ—§è¯­ä¹‰è¿ç§»åˆ°æ–°è¯­ä¹‰æ˜¯å®‰å…¨çš„ã€‚

è¯æ˜:
æ–°æ—§è¯­ä¹‰çš„å€¼åºåˆ—ç›¸åŒ,
åªæ˜¯åœ°å€ä¸åŒã€‚
å¦‚æœä»£ç åªè¯»å–å€¼,åˆ™è¡Œä¸ºç­‰ä»·ã€‚ â–¡
```

### 3.2 Channelæ­»é”Bug

```go
/* Channelæ­»é”ç¤ºä¾‹ */

// Bug 1: å¿˜è®°å…³é—­channel
func DeadlockBug1() {
    ch := make(chan int)
    
    go func() {
        for i := 0; i < 3; i++ {
            ch <- i
        }
        // Bug: å¿˜è®°close(ch)
    }()
    
    for v := range ch {  // æ­»é”: æ°¸è¿œç­‰å¾…
        fmt.Println(v)
    }
}

// Bug 2: å¾ªç¯ä¾èµ–
func DeadlockBug2() {
    ch1 := make(chan int)
    ch2 := make(chan int)
    
    go func() {
        ch1 <- 1
        <-ch2  // ç­‰å¾…ch2
    }()
    
    go func() {
        ch2 <- 2
        <-ch1  // ç­‰å¾…ch1
    }()
    // æ­»é”: å¾ªç¯ç­‰å¾…
}

// Bug 3: æ— ç¼“å†²channelè‡ªå‘è‡ªæ”¶
func DeadlockBug3() {
    ch := make(chan int)
    ch <- 1    // æ­»é”: æ— æ¥æ”¶è€…
    <-ch
}
```

```mathematical
/* æ­»é”å½¢å¼åŒ–åˆ†æ */

/* Bug 1åˆ†æ */

ChannelçŠ¶æ€:
  åˆå§‹: ch.closed = false, ch.sendq = [], ch.recvq = []
  
  goroutine 1 (sender):
    ch <- 0 â†’ ch.buf = [0]
    ch <- 1 â†’ ch.buf = [0, 1]
    ch <- 2 â†’ ch.buf = [0, 1, 2]
    é€€å‡º: æœªè°ƒç”¨close(ch)
  
  goroutine 2 (receiver):
    range ch:
      ç¬¬1æ¬¡: <-ch â†’ 0
      ç¬¬2æ¬¡: <-ch â†’ 1
      ç¬¬3æ¬¡: <-ch â†’ 2
      ç¬¬4æ¬¡: <-ch â†’ é˜»å¡ (chæœªå…³é—­ä¸”ç©º)

æ­»é”æ£€æµ‹:
  goroutine 2: Waiting(WaitChannel(ch, Recv))
  æ²¡æœ‰å…¶ä»–goroutineä¼šå‘é€æˆ–å…³é—­ch
  â†’ æ­»é”

ä¿®å¤:
  go func() {
      for i := 0; i < 3; i++ {
          ch <- i
      }
      close(ch)  // ä¿®å¤: å…³é—­channel
  }()

/* Bug 2åˆ†æ */

Goroutineä¾èµ–å›¾:
  g1: æŒæœ‰ch1, ç­‰å¾…ch2
  g2: æŒæœ‰ch2, ç­‰å¾…ch1

å¾ªç¯ä¾èµ–:
  g1 â†’ ch2 â†’ g2 â†’ ch1 â†’ g1

å®šç† (Cycle Implies Deadlock):
å¦‚æœgoroutineä¾èµ–å›¾æœ‰ç¯,åˆ™å­˜åœ¨æ­»é”ã€‚

è¯æ˜:
è®¾ç¯ä¸º g1 â†’ r1 â†’ g2 â†’ r2 â†’ ... â†’ gn â†’ rn â†’ g1
æ¯ä¸ªgiç­‰å¾…èµ„æºri,
æ¯ä¸ªriè¢«gi+1æŒæœ‰,
å› æ­¤æ‰€æœ‰giéƒ½æ— æ³•è¿›å±•ã€‚ â–¡

ä¿®å¤1: æ‰“ç ´å¾ªç¯
  go func() {
      ch1 <- 1
      select {
      case <-ch2:  // éé˜»å¡æ¥æ”¶
      case <-time.After(1*time.Second):
          // è¶…æ—¶å¤„ç†
      }
  }()

ä¿®å¤2: ç»Ÿä¸€é¡ºåº
  æ€»æ˜¯æŒ‰ch1 â†’ ch2çš„é¡ºåºæ“ä½œ

/* Bug 3åˆ†æ */

æ— ç¼“å†²channelè¯­ä¹‰:
  ch <- v: é˜»å¡ç›´åˆ°æœ‰æ¥æ”¶è€…
  <-ch: é˜»å¡ç›´åˆ°æœ‰å‘é€è€…

æ‰§è¡Œ:
  main goroutine:
    ch <- 1 â†’ é˜»å¡ (æ²¡æœ‰æ¥æ”¶è€…)
    (æ°¸è¿œä¸ä¼šåˆ°è¾¾ <-ch)

æ­»é”: main goroutineé˜»å¡,æ²¡æœ‰å…¶ä»–goroutine

ä¿®å¤:
  ch := make(chan int, 1)  // ä½¿ç”¨ç¼“å†²
  ch <- 1  // ä¸é˜»å¡
  <-ch
```

### 3.3 æ•°æ®ç«äº‰Bug

```go
/* æ•°æ®ç«äº‰ç¤ºä¾‹ */

// Bug: æ— åŒæ­¥çš„å…±äº«å˜é‡
type Counter struct {
    count int  // æ— ä¿æŠ¤
}

func (c *Counter) Increment() {
    c.count++  // æ•°æ®ç«äº‰
}

func RaceBug() {
    counter := &Counter{}
    var wg sync.WaitGroup
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Increment()  // æ•°æ®ç«äº‰
        }()
    }
    
    wg.Wait()
    fmt.Println(counter.count)  // ç»“æœä¸ç¡®å®š
}
```

```mathematical
/* æ•°æ®ç«äº‰å½¢å¼åŒ–åˆ†æ */

/* ç«äº‰å®šä¹‰ */

DataRace(eâ‚, eâ‚‚) âŸº
    eâ‚ âˆ¥ eâ‚‚ âˆ§                          /* å¹¶å‘ */
    same_location(eâ‚, eâ‚‚) âˆ§           /* åŒä¸€åœ°å€ */
    (is_write(eâ‚) âˆ¨ is_write(eâ‚‚)) âˆ§   /* è‡³å°‘ä¸€ä¸ªå†™ */
    Â¬synchronized(eâ‚, eâ‚‚)              /* æ— åŒæ­¥ */

/* count++çš„æ‰§è¡Œ */

count++ å±•å¼€ä¸º:
  1. tmp = load(count)
  2. tmp = tmp + 1
  3. store(count, tmp)

å¹¶å‘æ‰§è¡Œåœºæ™¯:
  goroutine 1:
    tmp1 = load(count)  // e1: è¯»å– 0
    tmp1 = tmp1 + 1     // 1
    store(count, tmp1)  // e3: å†™å…¥ 1
  
  goroutine 2:
    tmp2 = load(count)  // e2: è¯»å– 0 (ä¸e1å¹¶å‘)
    tmp2 = tmp2 + 1     // 1
    store(count, tmp2)  // e4: å†™å…¥ 1

ç»“æœ: count = 1 (æœŸæœ›2)

/* ç«äº‰æ£€æµ‹ */

Vector Clockåˆ†æ:
  VC(g1): [1, 0]
  VC(g2): [0, 1]
  
  e1 (read): VC = [1, 0]
  e2 (read): VC = [0, 1]
  
  æ£€æŸ¥happens-before:
    Â¬(VC(e1) < VC(e2))  /* e1ä¸å…ˆäºe2 */
    Â¬(VC(e2) < VC(e1))  /* e2ä¸å…ˆäºe1 */
  
  å› æ­¤ e1 âˆ¥ e2 (å¹¶å‘)
  
  åŒä¸€ä½ç½®: &counter.count
  éƒ½æ˜¯è¯»å†™: e1è¯», e3å†™
  æ— åŒæ­¥: æ— mutex, channelç­‰
  
  â†’ æ•°æ®ç«äº‰!

/* ä¿®å¤æ–¹æ¡ˆ */

1. Mutex:
   type Counter struct {
       mu    sync.Mutex
       count int
   }
   
   func (c *Counter) Increment() {
       c.mu.Lock()
       c.count++
       c.mu.Unlock()
   }

2. Atomic:
   type Counter struct {
       count atomic.Int64
   }
   
   func (c *Counter) Increment() {
       c.count.Add(1)
   }

3. Channel:
   type Counter struct {
       ch chan int
   }
   
   func (c *Counter) Increment() {
       c.ch <- 1
   }
   
   // Background aggregator
   go func() {
       count := 0
       for range c.ch {
           count++
       }
   }()

/* æ­£ç¡®æ€§éªŒè¯ */

ä¿®å¤åçš„Vector Clock:
  VC(g1): [1, 0]
  e1: lock(mu)
  VC(mu) = VC(g1) = [1, 0]
  VC(g1): [2, 0]
  e2: count++
  VC(g1): [3, 0]
  e3: unlock(mu)
  
  VC(g2): [0, 1]
  e4: lock(mu)
  VC(g2) = max(VC(g2), VC(mu)) = [1, 1]
  VC(g2): [1, 2]
  e5: count++
  VC(g2): [1, 3]
  e6: unlock(mu)
  
  ç°åœ¨: VC(e2) = [2, 0] < VC(e5) = [1, 2]
  å› æ­¤ e2 HB e5 (æœ‰åº)
  
  æ— æ•°æ®ç«äº‰ âœ“
```

### 3.4 å†…å­˜æ³„æ¼Bug

```go
/* å†…å­˜æ³„æ¼ç¤ºä¾‹ */

// Bug 1: Goroutineæ³„æ¼
func GoroutineLeakBug() {
    ch := make(chan int)
    
    go func() {
        <-ch  // æ°¸è¿œé˜»å¡ (channelä»æœªå‘é€)
    }()
    
    // goroutineæ°¸è¿œä¸ä¼šé€€å‡º â†’ æ³„æ¼
}

// Bug 2: é—­åŒ…æ•è·å¤§å¯¹è±¡
func ClosureLeakBug() {
    bigData := make([]byte, 1<<30)  // 1GB
    
    go func() {
        // é—­åŒ…æ•è·bigData,å³ä½¿ä¸ä½¿ç”¨
        doSomething()
    }()
    
    // bigDataæ— æ³•è¢«GCå›æ”¶
}

// Bug 3: Mapä¸æ¸…ç†
type Cache struct {
    mu    sync.Mutex
    items map[string]*Item
}

func (c *Cache) Set(key string, item *Item) {
    c.mu.Lock()
    c.items[key] = item  // æ°¸è¿œä¸åˆ é™¤
    c.mu.Unlock()
    // Mapæ— é™å¢é•¿ â†’ æ³„æ¼
}
```

```mathematical
/* å†…å­˜æ³„æ¼å½¢å¼åŒ–åˆ†æ */

/* Goroutineæ³„æ¼ */

å®šä¹‰ (Goroutine Leak):
goroutine gæ³„æ¼ âŸº
    g.state = Waiting(reason) âˆ§
    Â¬eventually_satisfied(reason)

åˆ†æ:
  go func() { <-ch }()
  
  g.state = Waiting(WaitChannel(ch, Recv))
  reason = WaitChannel(ch, Recv)
  
  eventually_satisfied? 
    éœ€è¦: ch <- v or close(ch)
    å®é™…: éƒ½ä¸ä¼šå‘ç”Ÿ
  
  å› æ­¤ gæ³„æ¼

æ£€æµ‹:
  1. è¿è¡Œæ—¶ç»Ÿè®¡: runtime.NumGoroutine()å¢é•¿
  2. pprof: goroutine profile
  3. é™æ€åˆ†æ: æ£€æŸ¥channelä½¿ç”¨æ¨¡å¼

ä¿®å¤:
  1. Contextå–æ¶ˆ:
     ctx, cancel := context.WithTimeout(...)
     defer cancel()
     
     go func() {
         select {
         case <-ch:
             ...
         case <-ctx.Done():
             return  // é€€å‡º
         }
     }()
  
  2. æ˜¾å¼å…³é—­:
     close(ch)

/* é—­åŒ…æ³„æ¼ */

å®šä¹‰ (Closure Leak):
é—­åŒ…æ•è·å¯¹è±¡objä¸”objä¸å†éœ€è¦,
ä½†objæ— æ³•è¢«GCå›æ”¶ã€‚

é€ƒé€¸åˆ†æ:
  bigData := make([]byte, 1<<30)
  
  escapes(bigData, closure):
    closureä¸­å¼•ç”¨äº†bigDataçš„ç¯å¢ƒ
    â†’ bigDataé€ƒé€¸åˆ°å †
    â†’ closureæŒæœ‰bigDataå¼•ç”¨
    â†’ bigDataæ— æ³•å›æ”¶

ä¿®å¤:
  go func() {
      bigData := nil  // æ˜¾å¼é‡Šæ”¾
      doSomething()
  }()

  æˆ–:
  go func() {
      // åªä¼ é€’éœ€è¦çš„éƒ¨åˆ†
      process(bigData[0:1024])
  }()

/* Mapæ³„æ¼ */

å®šä¹‰ (Map Leak):
mapæŒç»­å¢é•¿,ä¸åˆ é™¤æ—§æ¡ç›®ã€‚

å½¢å¼åŒ–:
  âˆ€t. |map(t+1)| â‰¥ |map(t)|  /* å•è°ƒå¢é•¿ */
  âˆƒ keys âˆˆ map. Â¬will_be_used(keys)  /* æœ‰ä¸ä¼šå†ç”¨çš„é”® */

ä¿®å¤:
  1. å®šæœŸæ¸…ç†:
     func (c *Cache) Cleanup() {
         c.mu.Lock()
         for k, v := range c.items {
             if v.Expired() {
                 delete(c.items, k)
             }
         }
         c.mu.Unlock()
     }
  
  2. LRUç¼“å­˜:
     type LRUCache struct {
         capacity int
         items    map[string]*list.Element
         lru      *list.List
     }
  
  3. TTL + è¢«åŠ¨æ¸…ç†:
     func (c *Cache) Get(key string) *Item {
         c.mu.Lock()
         defer c.mu.Unlock()
         
         item := c.items[key]
         if item != nil && item.Expired() {
             delete(c.items, key)  // è¢«åŠ¨æ¸…ç†
             return nil
         }
         return item
     }
```

---

## ç¬¬å››éƒ¨åˆ†: ç¼–è¯‘å™¨ä¼˜åŒ–æ­£ç¡®æ€§

### 4.1 å†…è”ä¼˜åŒ–è¯æ˜

```mathematical
/* å†…è”è½¬æ¢ */

åŸå§‹ä»£ç :
  func add(a, b int) int {
      return a + b
  }
  
  func main() {
      x := add(1, 2)
      print(x)
  }

å†…è”å:
  func main() {
      x := 1 + 2
      print(x)
  }

/* å½¢å¼åŒ–è¯æ˜ */

å®šç† (Inlining Correctness):
å†…è”ä¸æ”¹å˜ç¨‹åºè¯­ä¹‰ã€‚

è¯æ˜:

è®¾:
  f(xâ‚, ..., xâ‚™) = e_body
  call_site: y = f(aâ‚, ..., aâ‚™)

å†…è”è½¬æ¢:
  y = f(aâ‚, ..., aâ‚™) â†’ y = e_body[xâ‚:=aâ‚, ..., xâ‚™:=aâ‚™]

è¯­ä¹‰ç­‰ä»·æ€§:
  âŸ¦y = f(aâ‚, ..., aâ‚™)âŸ§Ïƒ Î¼
  = let vâ‚ = âŸ¦aâ‚âŸ§Ïƒ Î¼ in
    let vâ‚‚ = âŸ¦aâ‚‚âŸ§Ïƒ Î¼ in
    ...
    let vâ‚™ = âŸ¦aâ‚™âŸ§Ïƒ Î¼ in
    let result = âŸ¦e_bodyâŸ§(Ïƒ[xâ‚â†¦vâ‚, ..., xâ‚™â†¦vâ‚™]) Î¼ in
    Ïƒ[y â†¦ result]
  
  âŸ¦y = e_body[x:=a]âŸ§Ïƒ Î¼
  = let vâ‚ = âŸ¦aâ‚âŸ§Ïƒ Î¼ in
    ...
    let result = âŸ¦e_bodyâŸ§(Ïƒ[xâ‚â†¦vâ‚, ..., xâ‚™â†¦vâ‚™]) Î¼ in
    Ïƒ[y â†¦ result]
  
  ä¸¤è€…ç›¸åŒ âœ“

å‰¯ä½œç”¨è€ƒè™‘:
  å¦‚æœe_bodyæœ‰å‰¯ä½œç”¨,éœ€è¦ä¿è¯:
  1. æ±‚å€¼é¡ºåºä¸å˜
  2. å‰¯ä½œç”¨æ‰§è¡Œæ¬¡æ•°ä¸å˜
  3. å¯è§æ€§ä¸å˜

Goç¼–è¯‘å™¨ä¿è¯:
  - å‚æ•°æ±‚å€¼é¡ºåº: å·¦åˆ°å³
  - å†…è”ä¸æ”¹å˜æ±‚å€¼é¡ºåº
  - å‰¯ä½œç”¨(å¦‚panic)è¯­ä¹‰ä¿æŒ â–¡
```

### 4.2 é€ƒé€¸åˆ†ææ­£ç¡®æ€§

```mathematical
/* é€ƒé€¸åˆ†æè½¬æ¢ */

åŸå§‹:
  func newObject() *Object {
      obj := &Object{data: 42}  // å †åˆ†é…
      return obj
  }

ä¼˜åŒ–:
  func newLocal() Object {
      obj := Object{data: 42}   // æ ˆåˆ†é…
      return obj
  }

/* æ­£ç¡®æ€§æ¡ä»¶ */

å®šç† (Escape Analysis Soundness):
å¦‚æœé€ƒé€¸åˆ†æåˆ¤å®šå¯¹è±¡ä¸é€ƒé€¸,
åˆ™å¯¹è±¡å¯ä»¥å®‰å…¨åœ°åœ¨æ ˆä¸Šåˆ†é…ã€‚

è¯æ˜:

ä¸é€ƒé€¸å®šä¹‰:
  Â¬escapes(obj) âŸº
    âˆ€ ref to obj. refçš„ç”Ÿå‘½å‘¨æœŸ âŠ† objæ‰€åœ¨å‡½æ•°çš„ç”Ÿå‘½å‘¨æœŸ

æ ˆåˆ†é…å®‰å…¨æ€§:
  å¦‚æœobjåœ¨æ ˆä¸Šåˆ†é…,åˆ™:
  - objåœ¨å‡½æ•°è¿”å›æ—¶é”€æ¯
  - å¦‚æœÂ¬escapes(obj),æ‰€æœ‰å¼•ç”¨éƒ½åœ¨å‡½æ•°å†…
  - å› æ­¤objé”€æ¯æ—¶,æ²¡æœ‰æ‚¬ç©ºæŒ‡é’ˆ
  
  å®‰å…¨ âœ“

/* é€ƒé€¸åˆ†æç®—æ³•éªŒè¯ */

ç®—æ³•:
  function escape_analysis(program):
      escapes = Set()
      
      for obj in all_objects:
          if address_taken(obj) and stored_to_heap(obj):
              mark_escaped(obj, escapes)
          if returned_from_function(obj):
              mark_escaped(obj, escapes)
          if assigned_to_global(obj):
              mark_escaped(obj, escapes)
      
      propagate_escape(escapes)
      
      return escapes

æ­£ç¡®æ€§:
  1. ä¿å®ˆæ€§:
     ç®—æ³•å¯èƒ½è¯¯åˆ¤é€ƒé€¸(false positive),
     ä½†ä¸ä¼šæ¼åˆ¤(no false negative)ã€‚
  
  2. å®‰å…¨æ€§:
     if Â¬escapes(obj) by algorithm:
         then Â¬escapes(obj) actually
     
     å› æ­¤æ ˆåˆ†é…æ€»æ˜¯å®‰å…¨çš„ã€‚

/* ç¤ºä¾‹éªŒè¯ */

func f() {
    x := new(int)  // xä¸é€ƒé€¸
    *x = 42
    use(*x)
}  // xåœ¨æ ˆä¸Šåˆ†é… âœ“

func g() *int {
    x := new(int)  // xé€ƒé€¸
    *x = 42
    return x       // è¿”å›æŒ‡é’ˆ
}  // xåœ¨å †ä¸Šåˆ†é… âœ“
```

### 4.3 è¾¹ç•Œæ£€æŸ¥æ¶ˆé™¤éªŒè¯

```mathematical
/* BCEè½¬æ¢ */

åŸå§‹:
  for i := 0; i < len(arr); i++ {
      sum += arr[i]  // è¾¹ç•Œæ£€æŸ¥: if i >= len(arr) { panic }
  }

ä¼˜åŒ–:
  for i := 0; i < len(arr); i++ {
      sum += arr[i]  // è¾¹ç•Œæ£€æŸ¥æ¶ˆé™¤
  }

/* æ­£ç¡®æ€§è¯æ˜ */

å®šç† (BCE Correctness):
å¦‚æœç¼–è¯‘å™¨æ¶ˆé™¤äº†è¾¹ç•Œæ£€æŸ¥,
åˆ™è®¿é—®ä¸€å®šåœ¨ç•Œå†…ã€‚

è¯æ˜:

å½’çº³å˜é‡åˆ†æ:
  i = Ï†(0, i')
  i' = i + 1
  
  å¾ªç¯ä¸å˜å¼:
    0 â‰¤ i < len(arr)

å½’çº³è¯æ˜:
  Base: i = 0
    0 â‰¤ 0 âœ“
    å¾ªç¯æ¡ä»¶: 0 < len(arr) (å¦åˆ™ä¸è¿›å…¥å¾ªç¯)
  
  Inductive: å‡è®¾ 0 â‰¤ i < len(arr)
    è®¿é—®arr[i] å®‰å…¨ âœ“
    i' = i + 1
    å¾ªç¯æ¡ä»¶: i' < len(arr)
    å› æ­¤ 0 < i' < len(arr) âœ“

å› æ­¤æ‰€æœ‰è®¿é—®éƒ½åœ¨ç•Œå†…,
è¾¹ç•Œæ£€æŸ¥å¯ä»¥å®‰å…¨æ¶ˆé™¤ã€‚ â–¡

/* åä¾‹:éœ€è¦ä¿ç•™æ£€æŸ¥ */

// ä¸è§„åˆ™è®¿é—®æ¨¡å¼
for i := 0; i < n; i++ {
    j := compute_index(i)  // ä¸å¯é¢„æµ‹
    sum += arr[j]  // å¿…é¡»ä¿ç•™è¾¹ç•Œæ£€æŸ¥
}

// ç¼–è¯‘å™¨æ— æ³•è¯æ˜ 0 â‰¤ j < len(arr)

/* Go 1.25.3æ”¹è¿›çš„BCE */

1. æ›´æ™ºèƒ½çš„åŒºé—´åˆ†æ:
   if i >= 0 && i < len(arr) {
       use(arr[i])  // BCE: å·²æ£€æŸ¥
       use(arr[i+1])  // BCE: i+1 < len(arr) (å¦‚æœèƒ½è¯æ˜)
   }

2. Sliceè¾¹ç•Œè¿½è¸ª:
   s := arr[a:b]
   // ç¼–è¯‘å™¨çŸ¥é“: len(s) = b - a
   for i := range s {
       use(s[i])  // BCE: i < len(s)
   }

3. PhièŠ‚ç‚¹å¤„ç†:
   var idx int
   if cond {
       idx = 0
   } else {
       idx = 1
   }
   use(arr[idx])  // BCE: if len(arr) > 1
```

---

## ç¬¬äº”éƒ¨åˆ†: å·¥ç¨‹åº”ç”¨æŒ‡å—

### 5.1 å½¢å¼åŒ–æ–¹æ³•åœ¨Goå¼€å‘ä¸­çš„åº”ç”¨

```mathematical
/* åº”ç”¨å±‚æ¬¡ */

Level 1: ç±»å‹ç³»ç»Ÿ
  - åˆ©ç”¨Goçš„ç±»å‹æ£€æŸ¥
  - ä½¿ç”¨æ³›å‹å¢å¼ºç±»å‹å®‰å…¨
  - æ¥å£ä½œä¸ºå¥‘çº¦

Level 2: è®¾è®¡æ¨¡å¼
  - åŸºäºCSPçš„å¹¶å‘æ¨¡å¼
  - ä½¿ç”¨channelè¿›è¡ŒåŒæ­¥
  - é¿å…å…±äº«å†…å­˜

Level 3: é™æ€åˆ†æ
  - go vet, staticcheck
  - è‡ªå®šä¹‰åˆ†æå™¨
  - CIé›†æˆ

Level 4: åŠ¨æ€éªŒè¯
  - race detector
  - fuzzing
  - property-based testing

Level 5: å½¢å¼åŒ–éªŒè¯
  - ä½¿ç”¨å®šç†è¯æ˜å™¨
  - æ¨¡å‹æ£€æŸ¥
  - ç¬¦å·æ‰§è¡Œ

/* å®è·µå»ºè®® */

1. ä»ç±»å‹å¼€å§‹:
   type UserID int  // å¼ºç±»å‹,é˜²æ­¢æ··æ·†
   type Email string

2. ä½¿ç”¨æ¥å£å¥‘çº¦:
   type Cache interface {
       // Get retrieves value for key.
       // Returns false if key not found.
       // Thread-safe.
       Get(key string) (value interface{}, ok bool)
   }

3. æ–‡æ¡£åŒ–happens-before:
   // Producer must close(ch) after sending all values.
   // Consumer will range over ch until closed.

4. ä½¿ç”¨å·¥å…·éªŒè¯:
   go test -race        // æ•°æ®ç«äº‰
   go vet ./...         // é™æ€æ£€æŸ¥
   staticcheck ./...    // æ·±åº¦åˆ†æ
```

### 5.2 é™æ€åˆ†æå·¥å…·

```go
/* è‡ªå®šä¹‰åˆ†æå™¨ç¤ºä¾‹ */

package analyzer

import (
    "golang.org/x/tools/go/analysis"
    "go/ast"
)

// UnprotectedMapAccessæ£€æµ‹æ— ä¿æŠ¤çš„mapè®¿é—®
var UnprotectedMapAccessAnalyzer = &analysis.Analyzer{
    Name: "unprotectedmapaccess",
    Doc:  "æ£€æµ‹å¯èƒ½çš„å¹¶å‘mapè®¿é—®",
    Run:  runUnprotectedMapAccess,
}

func runUnprotectedMapAccess(pass *analysis.Pass) (interface{}, error) {
    for _, file := range pass.Files {
        ast.Inspect(file, func(n ast.Node) bool {
            // æ£€æµ‹mapè®¿é—®
            if indexExpr, ok := n.(*ast.IndexExpr); ok {
                if isMapType(pass, indexExpr.X) {
                    // æ£€æŸ¥æ˜¯å¦åœ¨mutexä¿æŠ¤ä¸‹
                    if !isProtectedByMutex(pass, indexExpr) {
                        pass.Reportf(indexExpr.Pos(),
                            "potential unprotected map access")
                    }
                }
            }
            return true
        })
    }
    return nil, nil
}
```

### 5.3 ç¨‹åºéªŒè¯å·¥ä½œæµ

```mathematical
/* éªŒè¯æµç¨‹ */

1. éœ€æ±‚è§„çº¦:
   - å‰ç½®æ¡ä»¶: Precondition
   - åç½®æ¡ä»¶: Postcondition
   - ä¸å˜å¼: Invariant

2. å®ç°:
   - ç¼–å†™ä»£ç 
   - æ·»åŠ æ–­è¨€
   - æ–‡æ¡£åŒ–å‡è®¾

3. æµ‹è¯•:
   - å•å…ƒæµ‹è¯•
   - é›†æˆæµ‹è¯•
   - Property-based testing

4. é™æ€åˆ†æ:
   - Type checking
   - Linting
   - Custom analyzers

5. åŠ¨æ€éªŒè¯:
   - Race detector
   - Fuzzing
   - Runtime assertions

6. å½¢å¼åŒ–éªŒè¯ (å¯é€‰):
   - å®šç†è¯æ˜
   - æ¨¡å‹æ£€æŸ¥

/* ç¤ºä¾‹å·¥ä½œæµ */

// 1. è§„çº¦
// Precondition: mutex is unlocked
// Postcondition: counter increased by 1
// Invariant: counter >= 0

// 2. å®ç°
type Counter struct {
    mu    sync.Mutex
    count int
}

func (c *Counter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.count++
}

// 3. æµ‹è¯•
func TestCounterConcurrent(t *testing.T) {
    c := &Counter{}
    var wg sync.WaitGroup
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            c.Increment()
        }()
    }
    
    wg.Wait()
    if c.count != 1000 {
        t.Errorf("expected 1000, got %d", c.count)
    }
}

// 4. è¿è¡Œåˆ†æ
// go test -race
// go vet
// staticcheck

// 5. æŒç»­é›†æˆ
// .github/workflows/test.yml:
//   - go test -race ./...
//   - go vet ./...
//   - staticcheck ./...
```

---

## ğŸ¯ æ€»ç»“

### æ ¸å¿ƒæˆæœ

1. **å®Œæ•´ç¨‹åºéªŒè¯**
   - ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ­£ç¡®æ€§
   - å¹¶å‘Mapçº¿æ€§åŒ–æ€§
   - å†…å­˜æ± å®‰å…¨æ€§

2. **å¹¶å‘ç®—æ³•è¯æ˜**
   - æ— é”æ ˆçš„lock-freedom
   - Rate Limiteræ­£ç¡®æ€§
   - Work-Stealingé˜Ÿåˆ—éªŒè¯

3. **å®é™…Bugåˆ†æ**
   - å¾ªç¯å˜é‡æ•è·
   - Channelæ­»é”
   - æ•°æ®ç«äº‰
   - å†…å­˜æ³„æ¼

4. **ç¼–è¯‘å™¨ä¼˜åŒ–æ­£ç¡®æ€§**
   - å†…è”ä¼˜åŒ–
   - é€ƒé€¸åˆ†æ
   - è¾¹ç•Œæ£€æŸ¥æ¶ˆé™¤

5. **å·¥ç¨‹åº”ç”¨æŒ‡å—**
   - å½¢å¼åŒ–æ–¹æ³•å®è·µ
   - é™æ€åˆ†æå·¥å…·
   - éªŒè¯å·¥ä½œæµ

### æ–¹æ³•è®ºä»·å€¼

1. **ç†è®ºä¸å®è·µç»“åˆ**
   - å½¢å¼åŒ–ç†è®ºæŒ‡å¯¼å®ç°
   - å®é™…æ¡ˆä¾‹éªŒè¯ç†è®º
   - å·¥ç¨‹åé¦ˆæ”¹è¿›ç†è®º

2. **åˆ†å±‚éªŒè¯ç­–ç•¥**
   - ç±»å‹çº§åˆ«(ç¼–è¯‘æ—¶)
   - é™æ€åˆ†æ(å·¥å…·)
   - åŠ¨æ€éªŒè¯(è¿è¡Œæ—¶)
   - å½¢å¼åŒ–è¯æ˜(ç†è®º)

3. **æ¸è¿›å¼åº”ç”¨**
   - ä»ç®€å•åˆ°å¤æ‚
   - ä»å±€éƒ¨åˆ°å…¨å±€
   - ä»æ‰‹åŠ¨åˆ°è‡ªåŠ¨

### æœªæ¥æ–¹å‘

1. **è‡ªåŠ¨åŒ–éªŒè¯**
   - æ›´æ™ºèƒ½çš„é™æ€åˆ†æ
   - è‡ªåŠ¨å®šç†è¯æ˜
   - AIè¾…åŠ©å½¢å¼åŒ–

2. **è§„æ¨¡åŒ–åº”ç”¨**
   - å¤§å‹ç³»ç»ŸéªŒè¯
   - å¾®æœåŠ¡æ­£ç¡®æ€§
   - åˆ†å¸ƒå¼ç³»ç»Ÿå½¢å¼åŒ–

3. **å·¥å…·é“¾å®Œå–„**
   - IDEé›†æˆ
   - CI/CDé›†æˆ
   - å¯è§†åŒ–å·¥å…·

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**åŸºå‡†æ—¥æœŸ**: 2025å¹´10æœˆ22æ—¥  
**Goç‰ˆæœ¬**: Go 1.25.3  
**ç†è®ºåŸºç¡€**: å½¢å¼åŒ–éªŒè¯ + ç¨‹åºè¯æ˜ + Bugåˆ†æ

<div align="center">

Made with â¤ï¸ for Go Formal Verification Practitioners

[â¬† å›åˆ°é¡¶éƒ¨](#ç»¼åˆæ¡ˆä¾‹ä¸è¯æ˜)

</div>

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Formal Methods Research Group  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ22æ—¥  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
