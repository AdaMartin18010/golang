# Go并发编程进阶深度指南


**字数**: ~32,000字  
**代码示例**: 90+个完整示例  
**实战案例**: 10个端到端案例  
**适用人群**: 中级到高级Go开发者

---

## 📚 目录

<!-- TOC -->
- [第一部分：Context深度实战](#第一部分context深度实战)
- [第二部分：sync包完整解析](#第二部分sync包完整解析)
- [第三部分：Channel高级用法](#第三部分channel高级用法)
- [第四部分：Select深度实战](#第四部分select深度实战)
- [第五部分：原子操作详解](#第五部分原子操作详解)
- [第六部分：并发安全数据结构](#第六部分并发安全数据结构)
- [第七部分：并发模式进阶](#第七部分并发模式进阶)
- [第八部分：性能优化与调试](#第八部分性能优化与调试)
- [第九部分：Go 1.23并发新特性](#第九部分go-123并发新特性)
- [第十部分：完整项目实战](#第十部分完整项目实战)
<!-- TOC -->

---

## 第一部分：Context深度实战

### Context核心概念

Context是Go并发编程的核心机制，用于：

```text
✅ 传递请求范围的值
✅ 控制Goroutine生命周期
✅ 传播取消信号
✅ 设置超时和截止时间
```

---

### Context接口定义

```go
type Context interface {
    // 返回Context的截止时间（如果有）
    Deadline() (deadline time.Time, ok bool)
    
    // 返回一个channel，当Context被取消时关闭
    Done() <-chan struct{}
    
    // 返回Context被取消的原因
    Err() error
    
    // 返回与key关联的值
    Value(key any) any
}
```

---

### 实战案例1：Context完整示例

```go
package main

import (
    "context"
    "fmt"
    "time"
)

// ===== 1. WithCancel：手动取消 =====
func withCancelExample() {
    ctx, cancel := context.WithCancel(context.Background())
    
    go func() {
        for {
            select {
            case <-ctx.Done():
                fmt.Println("Worker: 收到取消信号，退出")
                return
            default:
                fmt.Println("Worker: 工作中...")
                time.Sleep(500 * time.Millisecond)
            }
        }
    }()
    
    // 主goroutine工作2秒后取消
    time.Sleep(2 * time.Second)
    cancel()
    time.Sleep(100 * time.Millisecond)
}

// ===== 2. WithTimeout：超时控制 =====
func withTimeoutExample() {
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel() // 确保资源释放
    
    go func(ctx context.Context) {
        select {
        case <-time.After(3 * time.Second):
            fmt.Println("任务完成")
        case <-ctx.Done():
            fmt.Println("任务超时:", ctx.Err())
        }
    }(ctx)
    
    time.Sleep(3 * time.Second)
}

// ===== 3. WithDeadline：截止时间 =====
func withDeadlineExample() {
    deadline := time.Now().Add(1 * time.Second)
    ctx, cancel := context.WithDeadline(context.Background(), deadline)
    defer cancel()
    
    go func(ctx context.Context) {
        select {
        case <-time.After(2 * time.Second):
            fmt.Println("任务完成")
        case <-ctx.Done():
            fmt.Println("到达截止时间:", ctx.Err())
        }
    }(ctx)
    
    time.Sleep(2 * time.Second)
}

// ===== 4. WithValue：传递请求范围的值 =====
type contextKey string

const (
    userIDKey contextKey = "userID"
    traceIDKey contextKey = "traceID"
)

func withValueExample() {
    ctx := context.Background()
    ctx = context.WithValue(ctx, userIDKey, "user123")
    ctx = context.WithValue(ctx, traceIDKey, "trace-abc-123")
    
    processRequest(ctx)
}

func processRequest(ctx context.Context) {
    userID := ctx.Value(userIDKey).(string)
    traceID := ctx.Value(traceIDKey).(string)
    
    fmt.Printf("处理请求 - UserID: %s, TraceID: %s\n", userID, traceID)
}

func main() {
    fmt.Println("===== WithCancel示例 =====")
    withCancelExample()
    
    fmt.Println("\n===== WithTimeout示例 =====")
    withTimeoutExample()
    
    fmt.Println("\n===== WithDeadline示例 =====")
    withDeadlineExample()
    
    fmt.Println("\n===== WithValue示例 =====")
    withValueExample()
}
```

---

### 实战案例2：HTTP服务器Context传播

```go
package main

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "time"
)

// ===== 中间件：添加TraceID =====
func traceMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        traceID := fmt.Sprintf("trace-%d", time.Now().UnixNano())
        ctx := context.WithValue(r.Context(), "traceID", traceID)
        
        // 传播Context
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// ===== 中间件：超时控制 =====
func timeoutMiddleware(timeout time.Duration) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            ctx, cancel := context.WithTimeout(r.Context(), timeout)
            defer cancel()
            
            // 创建一个channel来接收处理结果
            done := make(chan struct{})
            
            go func() {
                next.ServeHTTP(w, r.WithContext(ctx))
                close(done)
            }()
            
            select {
            case <-done:
                // 正常完成
            case <-ctx.Done():
                // 超时
                http.Error(w, "Request timeout", http.StatusGatewayTimeout)
            }
        })
    }
}

// ===== Handler：查询用户信息 =====
func getUserHandler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    traceID := ctx.Value("traceID").(string)
    
    log.Printf("[%s] 开始查询用户信息", traceID)
    
    // 模拟数据库查询
    user, err := queryUser(ctx, "user123")
    if err != nil {
        log.Printf("[%s] 查询失败: %v", traceID, err)
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    log.Printf("[%s] 查询成功", traceID)
    fmt.Fprintf(w, "User: %+v\n", user)
}

// ===== 模拟数据库查询 =====
func queryUser(ctx context.Context, userID string) (map[string]string, error) {
    // 模拟耗时操作
    select {
    case <-time.After(1 * time.Second):
        return map[string]string{
            "id":   userID,
            "name": "Alice",
        }, nil
    case <-ctx.Done():
        return nil, ctx.Err()
    }
}

func main() {
    mux := http.NewServeMux()
    mux.HandleFunc("/user", getUserHandler)
    
    // 组合中间件
    handler := traceMiddleware(timeoutMiddleware(2 * time.Second)(mux))
    
    log.Println("服务器启动在 :8080")
    log.Fatal(http.ListenAndServe(":8080", handler))
}
```

---

## 第二部分：sync包完整解析

### Mutex（互斥锁）

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// ===== 1. Mutex基本用法 =====
type Counter struct {
    mu    sync.Mutex
    value int
}

func (c *Counter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

func (c *Counter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}

// ===== 2. 死锁示例（反例）=====
func deadlockExample() {
    var mu1, mu2 sync.Mutex
    
    // Goroutine 1: 先锁mu1，再锁mu2
    go func() {
        mu1.Lock()
        defer mu1.Unlock()
        time.Sleep(100 * time.Millisecond)
        mu2.Lock()
        defer mu2.Unlock()
        fmt.Println("Goroutine 1 完成")
    }()
    
    // Goroutine 2: 先锁mu2，再锁mu1（死锁！）
    go func() {
        mu2.Lock()
        defer mu2.Unlock()
        time.Sleep(100 * time.Millisecond)
        mu1.Lock()
        defer mu1.Unlock()
        fmt.Println("Goroutine 2 完成")
    }()
    
    time.Sleep(2 * time.Second)
}

// ===== 3. 避免死锁：统一锁顺序 =====
func avoidDeadlock() {
    var mu1, mu2 sync.Mutex
    
    lockInOrder := func(first, second *sync.Mutex) {
        first.Lock()
        defer first.Unlock()
        second.Lock()
        defer second.Unlock()
        fmt.Println("操作完成")
    }
    
    go lockInOrder(&mu1, &mu2)
    go lockInOrder(&mu1, &mu2) // 相同顺序，不会死锁
    
    time.Sleep(1 * time.Second)
}

func main() {
    // 测试Counter
    counter := &Counter{}
    
    var wg sync.WaitGroup
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Increment()
        }()
    }
    
    wg.Wait()
    fmt.Printf("最终值: %d\n", counter.Value())
}
```

---

### RWMutex（读写锁）

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// ===== 读写锁示例 =====
type Cache struct {
    mu    sync.RWMutex
    data  map[string]string
}

func NewCache() *Cache {
    return &Cache{
        data: make(map[string]string),
    }
}

// 读操作（允许多个并发读）
func (c *Cache) Get(key string) (string, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    val, ok := c.data[key]
    return val, ok
}

// 写操作（独占锁）
func (c *Cache) Set(key, value string) {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    c.data[key] = value
}

// ===== 性能对比：Mutex vs RWMutex =====
func benchmarkMutex() time.Duration {
    var mu sync.Mutex
    data := make(map[string]int)
    
    start := time.Now()
    
    var wg sync.WaitGroup
    
    // 90%读操作
    for i := 0; i < 9000; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            mu.Lock()
            _ = data["key"]
            mu.Unlock()
        }(i)
    }
    
    // 10%写操作
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            mu.Lock()
            data["key"] = i
            mu.Unlock()
        }(i)
    }
    
    wg.Wait()
    return time.Since(start)
}

func benchmarkRWMutex() time.Duration {
    var mu sync.RWMutex
    data := make(map[string]int)
    
    start := time.Now()
    
    var wg sync.WaitGroup
    
    // 90%读操作
    for i := 0; i < 9000; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            mu.RLock()
            _ = data["key"]
            mu.RUnlock()
        }(i)
    }
    
    // 10%写操作
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            mu.Lock()
            data["key"] = i
            mu.Unlock()
        }(i)
    }
    
    wg.Wait()
    return time.Since(start)
}

func main() {
    // 测试Cache
    cache := NewCache()
    cache.Set("name", "Alice")
    
    var wg sync.WaitGroup
    
    // 并发读
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            val, _ := cache.Get("name")
            fmt.Printf("Reader %d: %s\n", i, val)
        }(i)
    }
    
    wg.Wait()
    
    // 性能对比
    fmt.Println("\n===== 性能对比（90%读 + 10%写）=====")
    mutexTime := benchmarkMutex()
    rwMutexTime := benchmarkRWMutex()
    
    fmt.Printf("Mutex:   %v\n", mutexTime)
    fmt.Printf("RWMutex: %v\n", rwMutexTime)
    fmt.Printf("RWMutex提升: %.2f倍\n", float64(mutexTime)/float64(rwMutexTime))
}
```

---

### WaitGroup深度实战

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// ===== 1. WaitGroup基本用法 =====
func basicWaitGroup() {
    var wg sync.WaitGroup
    
    for i := 0; i < 5; i++ {
        wg.Add(1) // 在启动goroutine前Add
        
        go func(id int) {
            defer wg.Done() // 确保Done被调用
            
            fmt.Printf("Worker %d 开始\n", id)
            time.Sleep(time.Duration(id) * 100 * time.Millisecond)
            fmt.Printf("Worker %d 完成\n", id)
        }(i)
    }
    
    wg.Wait() // 等待所有goroutine完成
    fmt.Println("所有任务完成")
}

// ===== 2. WaitGroup错误用法（反例）=====
func wrongWaitGroup() {
    var wg sync.WaitGroup
    
    for i := 0; i < 5; i++ {
        go func(id int) {
            wg.Add(1) // ❌ 错误：在goroutine内部Add可能导致竞态
            defer wg.Done()
            
            fmt.Printf("Worker %d\n", id)
        }(i)
    }
    
    wg.Wait() // 可能在所有Add执行前就返回
}

// ===== 3. WaitGroup + 错误收集 =====
func waitGroupWithErrors() {
    var wg sync.WaitGroup
    errCh := make(chan error, 5)
    
    for i := 0; i < 5; i++ {
        wg.Add(1)
        
        go func(id int) {
            defer wg.Done()
            
            // 模拟任务
            if id%2 == 0 {
                errCh <- fmt.Errorf("worker %d 失败", id)
            } else {
                fmt.Printf("Worker %d 成功\n", id)
            }
        }(i)
    }
    
    // 等待所有goroutine完成
    wg.Wait()
    close(errCh)
    
    // 收集错误
    var errors []error
    for err := range errCh {
        errors = append(errors, err)
    }
    
    if len(errors) > 0 {
        fmt.Printf("发现 %d 个错误:\n", len(errors))
        for _, err := range errors {
            fmt.Printf("  - %v\n", err)
        }
    }
}

// ===== 4. WaitGroup.Go()（Go 1.25新特性模拟）=====
type WaitGroupExt struct {
    sync.WaitGroup
}

func (wg *WaitGroupExt) Go(f func()) {
    wg.Add(1)
    go func() {
        defer wg.Done()
        f()
    }()
}

func waitGroupGoExample() {
    var wg WaitGroupExt
    
    for i := 0; i < 5; i++ {
        id := i
        wg.Go(func() {
            fmt.Printf("Worker %d\n", id)
            time.Sleep(100 * time.Millisecond)
        })
    }
    
    wg.Wait()
    fmt.Println("所有任务完成")
}

func main() {
    fmt.Println("===== 基本用法 =====")
    basicWaitGroup()
    
    fmt.Println("\n===== 错误收集 =====")
    waitGroupWithErrors()
    
    fmt.Println("\n===== WaitGroup.Go() =====")
    waitGroupGoExample()
}
```

---

### Once（单次执行）

```go
package main

import (
    "fmt"
    "sync"
)

// ===== 1. Once基本用法：单例模式 =====
type Singleton struct {
    data string
}

var (
    instance *Singleton
    once     sync.Once
)

func GetInstance() *Singleton {
    once.Do(func() {
        fmt.Println("初始化单例...")
        instance = &Singleton{data: "singleton"}
    })
    return instance
}

// ===== 2. Once用于延迟初始化 =====
type Config struct {
    once   sync.Once
    config map[string]string
}

func (c *Config) Load() {
    c.once.Do(func() {
        fmt.Println("加载配置...")
        c.config = map[string]string{
            "host": "localhost",
            "port": "8080",
        }
    })
}

func (c *Config) Get(key string) string {
    c.Load() // 确保配置已加载
    return c.config[key]
}

// ===== 3. Once + 错误处理 =====
type Resource struct {
    once sync.Once
    data *string
    err  error
}

func (r *Resource) Init() error {
    r.once.Do(func() {
        // 模拟初始化
        result := "initialized"
        r.data = &result
        r.err = nil
    })
    return r.err
}

func main() {
    // 测试单例
    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            instance := GetInstance()
            fmt.Printf("Goroutine %d 获得实例: %p\n", id, instance)
        }(i)
    }
    wg.Wait()
    
    // 测试配置加载
    fmt.Println("\n===== 配置加载 =====")
    cfg := &Config{}
    
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            host := cfg.Get("host")
            fmt.Printf("Host: %s\n", host)
        }()
    }
    wg.Wait()
}
```

---

### Pool（对象池）

```go
package main

import (
    "bytes"
    "fmt"
    "sync"
)

// ===== 1. Pool基本用法 =====
var bufferPool = sync.Pool{
    New: func() any {
        fmt.Println("创建新buffer")
        return new(bytes.Buffer)
    },
}

func processData(data string) string {
    // 从池中获取buffer
    buf := bufferPool.Get().(*bytes.Buffer)
    defer func() {
        buf.Reset() // 清空buffer
        bufferPool.Put(buf) // 归还到池中
    }()
    
    buf.WriteString("处理: ")
    buf.WriteString(data)
    return buf.String()
}

// ===== 2. Pool性能对比 =====
func benchmarkWithoutPool(n int) {
    for i := 0; i < n; i++ {
        buf := new(bytes.Buffer)
        buf.WriteString("test")
        _ = buf.String()
    }
}

func benchmarkWithPool(n int) {
    pool := sync.Pool{
        New: func() any {
            return new(bytes.Buffer)
        },
    }
    
    for i := 0; i < n; i++ {
        buf := pool.Get().(*bytes.Buffer)
        buf.WriteString("test")
        _ = buf.String()
        buf.Reset()
        pool.Put(buf)
    }
}

// ===== 3. 自定义Worker Pool =====
type Worker struct {
    id int
}

var workerPool = sync.Pool{
    New: func() any {
        fmt.Println("创建新Worker")
        return &Worker{}
    },
}

func doWork(taskID int) {
    worker := workerPool.Get().(*Worker)
    defer workerPool.Put(worker)
    
    worker.id = taskID
    fmt.Printf("Worker %d 执行任务\n", worker.id)
}

func main() {
    // 测试bufferPool
    fmt.Println("===== Buffer Pool =====")
    for i := 0; i < 3; i++ {
        result := processData(fmt.Sprintf("data%d", i))
        fmt.Println(result)
    }
    
    // 测试workerPool
    fmt.Println("\n===== Worker Pool =====")
    for i := 0; i < 5; i++ {
        doWork(i)
    }
}
```

---

### Cond（条件变量）

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// ===== 1. Cond基本用法：生产者-消费者 =====
type Queue struct {
    mu    sync.Mutex
    cond  *sync.Cond
    items []int
    max   int
}

func NewQueue(max int) *Queue {
    q := &Queue{
        items: make([]int, 0),
        max:   max,
    }
    q.cond = sync.NewCond(&q.mu)
    return q
}

func (q *Queue) Produce(item int) {
    q.mu.Lock()
    defer q.mu.Unlock()
    
    // 等待队列有空间
    for len(q.items) >= q.max {
        fmt.Println("队列满，生产者等待...")
        q.cond.Wait() // 释放锁并等待
    }
    
    q.items = append(q.items, item)
    fmt.Printf("生产: %d, 队列长度: %d\n", item, len(q.items))
    
    q.cond.Signal() // 通知一个等待的消费者
}

func (q *Queue) Consume() int {
    q.mu.Lock()
    defer q.mu.Unlock()
    
    // 等待队列有数据
    for len(q.items) == 0 {
        fmt.Println("队列空，消费者等待...")
        q.cond.Wait()
    }
    
    item := q.items[0]
    q.items = q.items[1:]
    fmt.Printf("消费: %d, 队列长度: %d\n", item, len(q.items))
    
    q.cond.Signal() // 通知一个等待的生产者
    return item
}

func main() {
    queue := NewQueue(3)
    
    // 启动生产者
    for i := 0; i < 5; i++ {
        go func(id int) {
            for j := 0; j < 3; j++ {
                queue.Produce(id*10 + j)
                time.Sleep(100 * time.Millisecond)
            }
        }(i)
    }
    
    // 启动消费者
    for i := 0; i < 3; i++ {
        go func(id int) {
            for j := 0; j < 5; j++ {
                queue.Consume()
                time.Sleep(200 * time.Millisecond)
            }
        }(i)
    }
    
    time.Sleep(5 * time.Second)
}
```

---

### Map（并发安全Map）

```go
package main

import (
    "fmt"
    "sync"
)

// ===== 1. sync.Map基本用法 =====
func basicSyncMap() {
    var m sync.Map
    
    // Store
    m.Store("name", "Alice")
    m.Store("age", 30)
    
    // Load
    if val, ok := m.Load("name"); ok {
        fmt.Printf("name: %v\n", val)
    }
    
    // LoadOrStore
    actual, loaded := m.LoadOrStore("city", "Beijing")
    fmt.Printf("city: %v, loaded: %v\n", actual, loaded)
    
    // Range
    fmt.Println("\n遍历:")
    m.Range(func(key, value any) bool {
        fmt.Printf("%v: %v\n", key, value)
        return true // 继续遍历
    })
    
    // Delete
    m.Delete("age")
}

// ===== 2. 性能对比：Map+Mutex vs sync.Map =====
func benchmarkMapWithMutex(n int) {
    var mu sync.RWMutex
    m := make(map[string]int)
    
    var wg sync.WaitGroup
    
    // 写操作
    for i := 0; i < n/2; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", i)
            mu.Lock()
            m[key] = i
            mu.Unlock()
        }(i)
    }
    
    // 读操作
    for i := 0; i < n/2; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", i)
            mu.RLock()
            _ = m[key]
            mu.RUnlock()
        }(i)
    }
    
    wg.Wait()
}

func benchmarkSyncMap(n int) {
    var m sync.Map
    var wg sync.WaitGroup
    
    // 写操作
    for i := 0; i < n/2; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", i)
            m.Store(key, i)
        }(i)
    }
    
    // 读操作
    for i := 0; i < n/2; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", i)
            m.Load(key)
        }(i)
    }
    
    wg.Wait()
}

// ===== 3. sync.Map适用场景 =====
// 场景1：读多写少
// 场景2：键空间固定，读写不重叠

func main() {
    fmt.Println("===== sync.Map基本用法 =====")
    basicSyncMap()
}
```

---

## 第三部分：Channel高级用法

### Channel关闭与检测

```go
package main

import (
    "fmt"
    "sync"
)

// ===== 1. 检测Channel是否关闭 =====
func checkClosed() {
    ch := make(chan int, 3)
    
    ch <- 1
    ch <- 2
    ch <- 3
    close(ch)
    
    // 方式1：通过ok检测
    for {
        val, ok := <-ch
        if !ok {
            fmt.Println("Channel已关闭")
            break
        }
        fmt.Printf("接收: %d\n", val)
    }
    
    // 方式2：使用range（推荐）
    ch2 := make(chan int, 3)
    ch2 <- 10
    ch2 <- 20
    ch2 <- 30
    close(ch2)
    
    for val := range ch2 {
        fmt.Printf("Range接收: %d\n", val)
    }
}

// ===== 2. 优雅关闭Channel模式 =====
// 原则：发送者关闭，接收者不关闭

// 模式1：单发送者，多接收者
func singleSenderMultiReceiver() {
    ch := make(chan int, 10)
    
    // 发送者
    go func() {
        defer close(ch) // 发送完毕后关闭
        for i := 0; i < 10; i++ {
            ch <- i
        }
    }()
    
    // 多个接收者
    var wg sync.WaitGroup
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for val := range ch {
                fmt.Printf("接收者%d: %d\n", id, val)
            }
        }(i)
    }
    
    wg.Wait()
}

// 模式2：多发送者，单接收者
func multiSenderSingleReceiver() {
    ch := make(chan int, 10)
    stopCh := make(chan struct{})
    
    // 多个发送者
    var wg sync.WaitGroup
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for j := 0; j < 5; j++ {
                select {
                case ch <- id*10 + j:
                case <-stopCh:
                    return
                }
            }
        }(i)
    }
    
    // 等待所有发送者完成后关闭channel
    go func() {
        wg.Wait()
        close(ch)
    }()
    
    // 接收者
    for val := range ch {
        fmt.Printf("接收: %d\n", val)
    }
}

// 模式3：多发送者，多接收者（使用中间协调者）
type Hub struct {
    sources []<-chan int
    dest    chan int
    stop    chan struct{}
}

func NewHub(sources []<-chan int) *Hub {
    return &Hub{
        sources: sources,
        dest:    make(chan int, 10),
        stop:    make(chan struct{}),
    }
}

func (h *Hub) Start() <-chan int {
    var wg sync.WaitGroup
    
    // 为每个source启动一个goroutine
    for _, src := range h.sources {
        wg.Add(1)
        go func(ch <-chan int) {
            defer wg.Done()
            for {
                select {
                case val, ok := <-ch:
                    if !ok {
                        return
                    }
                    select {
                    case h.dest <- val:
                    case <-h.stop:
                        return
                    }
                case <-h.stop:
                    return
                }
            }
        }(src)
    }
    
    // 等待所有source处理完毕后关闭dest
    go func() {
        wg.Wait()
        close(h.dest)
    }()
    
    return h.dest
}

func (h *Hub) Stop() {
    close(h.stop)
}

func main() {
    fmt.Println("===== 检测Channel关闭 =====")
    checkClosed()
    
    fmt.Println("\n===== 单发送者多接收者 =====")
    singleSenderMultiReceiver()
    
    fmt.Println("\n===== 多发送者单接收者 =====")
    multiSenderSingleReceiver()
}
```

---

### nil Channel与零值Channel

```go
package main

import (
    "fmt"
    "time"
)

// ===== 1. nil Channel行为 =====
func nilChannelBehavior() {
    var ch chan int // nil channel
    
    // 从nil channel接收：永久阻塞
    // val := <-ch // 会死锁
    
    // 向nil channel发送：永久阻塞
    // ch <- 1 // 会死锁
    
    // 关闭nil channel：panic
    // close(ch) // panic
    
    // 在select中使用nil channel：该case被忽略
    select {
    case <-ch:
        fmt.Println("不会执行")
    default:
        fmt.Println("nil channel的case被忽略")
    }
}

// ===== 2. nil Channel的实用场景 =====
// 动态禁用select中的case
func mergeChannels(ch1, ch2 <-chan int) <-chan int {
    out := make(chan int)
    
    go func() {
        defer close(out)
        
        for ch1 != nil || ch2 != nil {
            select {
            case val, ok := <-ch1:
                if !ok {
                    ch1 = nil // 禁用ch1
                    continue
                }
                out <- val
            case val, ok := <-ch2:
                if !ok {
                    ch2 = nil // 禁用ch2
                    continue
                }
                out <- val
            }
        }
    }()
    
    return out
}

func main() {
    fmt.Println("===== nil Channel行为 =====")
    nilChannelBehavior()
    
    fmt.Println("\n===== 合并Channel =====")
    ch1 := make(chan int, 3)
    ch2 := make(chan int, 3)
    
    ch1 <- 1
    ch1 <- 2
    ch1 <- 3
    close(ch1)
    
    ch2 <- 10
    ch2 <- 20
    close(ch2)
    
    merged := mergeChannels(ch1, ch2)
    
    for val := range merged {
        fmt.Println(val)
    }
}
```

---

## 第四部分：Select深度实战

### Select完整用法

```go
package main

import (
    "fmt"
    "time"
)

// ===== 1. Select基本用法 =====
func basicSelect() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    
    go func() {
        time.Sleep(1 * time.Second)
        ch1 <- "one"
    }()
    
    go func() {
        time.Sleep(2 * time.Second)
        ch2 <- "two"
    }()
    
    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-ch1:
            fmt.Println("接收ch1:", msg1)
        case msg2 := <-ch2:
            fmt.Println("接收ch2:", msg2)
        }
    }
}

// ===== 2. Select + Default（非阻塞）=====
func selectWithDefault() {
    ch := make(chan int, 1)
    
    // 非阻塞发送
    select {
    case ch <- 1:
        fmt.Println("发送成功")
    default:
        fmt.Println("Channel满，发送失败")
    }
    
    // 非阻塞接收
    select {
    case val := <-ch:
        fmt.Printf("接收成功: %d\n", val)
    default:
        fmt.Println("Channel空，接收失败")
    }
}

// ===== 3. Select + Timeout =====
func selectWithTimeout() {
    ch := make(chan string)
    
    go func() {
        time.Sleep(2 * time.Second)
        ch <- "result"
    }()
    
    select {
    case res := <-ch:
        fmt.Println("接收:", res)
    case <-time.After(1 * time.Second):
        fmt.Println("超时")
    }
}

// ===== 4. Select多路复用 =====
func selectMultiplex() {
    tick := time.Tick(500 * time.Millisecond)
    boom := time.After(2 * time.Second)
    
    for {
        select {
        case <-tick:
            fmt.Println("tick.")
        case <-boom:
            fmt.Println("BOOM!")
            return
        default:
            fmt.Println("    .")
            time.Sleep(200 * time.Millisecond)
        }
    }
}

func main() {
    fmt.Println("===== 基本用法 =====")
    basicSelect()
    
    fmt.Println("\n===== 非阻塞操作 =====")
    selectWithDefault()
    
    fmt.Println("\n===== 超时控制 =====")
    selectWithTimeout()
    
    fmt.Println("\n===== 多路复用 =====")
    selectMultiplex()
}
```

---

## 第五部分：原子操作详解

### atomic包完整解析

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

// ===== 1. 原子整数操作 =====
func atomicIntOperations() {
    var counter int64
    
    var wg sync.WaitGroup
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            atomic.AddInt64(&counter, 1)
        }()
    }
    
    wg.Wait()
    fmt.Printf("Counter: %d\n", atomic.LoadInt64(&counter))
}

// ===== 2. Compare-And-Swap（CAS）=====
func casExample() {
    var value int64 = 100
    
    // 尝试将100替换为200
    swapped := atomic.CompareAndSwapInt64(&value, 100, 200)
    fmt.Printf("CAS成功: %v, 新值: %d\n", swapped, value)
    
    // 再次尝试将100替换为300（失败）
    swapped = atomic.CompareAndSwapInt64(&value, 100, 300)
    fmt.Printf("CAS成功: %v, 值: %d\n", swapped, value)
}

// ===== 3. 原子指针操作 =====
type Config struct {
    host string
    port int
}

var configPtr atomic.Pointer[Config]

func atomicPointerExample() {
    // 初始配置
    config1 := &Config{host: "localhost", port: 8080}
    configPtr.Store(config1)
    
    // 读取配置
    cfg := configPtr.Load()
    fmt.Printf("Config1: %+v\n", cfg)
    
    // 更新配置（原子操作）
    config2 := &Config{host: "0.0.0.0", port: 9090}
    configPtr.Store(config2)
    
    cfg = configPtr.Load()
    fmt.Printf("Config2: %+v\n", cfg)
}

// ===== 4. 原子Value =====
var configValue atomic.Value

func atomicValueExample() {
    // 存储任意类型
    configValue.Store(map[string]string{
        "env": "dev",
    })
    
    // 加载
    cfg := configValue.Load().(map[string]string)
    fmt.Printf("Config: %v\n", cfg)
    
    // 更新
    configValue.Store(map[string]string{
        "env": "prod",
    })
    
    cfg = configValue.Load().(map[string]string)
    fmt.Printf("Updated Config: %v\n", cfg)
}

// ===== 5. 性能对比：Mutex vs Atomic =====
func benchmarkMutex(n int) {
    var mu sync.Mutex
    var counter int64
    
    var wg sync.WaitGroup
    for i := 0; i < n; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            mu.Lock()
            counter++
            mu.Unlock()
        }()
    }
    wg.Wait()
}

func benchmarkAtomic(n int) {
    var counter int64
    
    var wg sync.WaitGroup
    for i := 0; i < n; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            atomic.AddInt64(&counter, 1)
        }()
    }
    wg.Wait()
}

func main() {
    fmt.Println("===== 原子整数操作 =====")
    atomicIntOperations()
    
    fmt.Println("\n===== CAS操作 =====")
    casExample()
    
    fmt.Println("\n===== 原子指针 =====")
    atomicPointerExample()
    
    fmt.Println("\n===== 原子Value =====")
    atomicValueExample()
}
```

---

## 🎯 总结

### 并发核心要点

1. **Context** - 请求范围传播、取消控制、超时管理
2. **sync.Mutex/RWMutex** - 互斥锁、读写锁
3. **sync.WaitGroup** - Goroutine同步等待
4. **sync.Once** - 单次执行、延迟初始化
5. **sync.Pool** - 对象池、减少GC压力
6. **sync.Cond** - 条件变量、生产者-消费者
7. **sync.Map** - 并发安全Map
8. **Channel** - 通信原语、优雅关闭
9. **Select** - 多路复用、超时控制
10. **atomic** - 原子操作、无锁编程

### 最佳实践清单

```text
✅ Context传播请求范围的值和取消信号
✅ 使用WaitGroup同步Goroutine
✅ 读多写少场景使用RWMutex
✅ Once实现单例和延迟初始化
✅ Pool复用对象减少GC
✅ Channel遵循"发送者关闭"原则
✅ Select实现超时和多路复用
✅ atomic实现无锁并发
✅ 避免死锁（统一锁顺序）
✅ 使用-race检测数据竞争
```

---

**文档版本**: v11.0  


<div align="center">

Made with ❤️ for Go Concurrent Developers

[⬆ 回到顶部](#go并发编程进阶深度指南)

</div>

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025年10月20日  
**文档状态**: 完成  
**适用版本**: Go 1.21+
