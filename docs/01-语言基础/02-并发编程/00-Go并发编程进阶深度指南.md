# Goå¹¶å‘ç¼–ç¨‹è¿›é˜¶æ·±åº¦æŒ‡å—

**æ–‡æ¡£çŠ¶æ€**: âœ… æ·±åº¦é‡å†™å®Œæˆ (v11.0)  
**å­—æ•°**: ~32,000å­—  
**ä»£ç ç¤ºä¾‹**: 90+ä¸ªå®Œæ•´ç¤ºä¾‹  
**å®æˆ˜æ¡ˆä¾‹**: 10ä¸ªç«¯åˆ°ç«¯æ¡ˆä¾‹  
**é€‚ç”¨äººç¾¤**: ä¸­çº§åˆ°é«˜çº§Goå¼€å‘è€…

---

## ğŸ“š ç›®å½•

<!-- TOC -->
- [ç¬¬ä¸€éƒ¨åˆ†ï¼šContextæ·±åº¦å®æˆ˜](#ç¬¬ä¸€éƒ¨åˆ†contextæ·±åº¦å®æˆ˜)
- [ç¬¬äºŒéƒ¨åˆ†ï¼šsyncåŒ…å®Œæ•´è§£æ](#ç¬¬äºŒéƒ¨åˆ†syncåŒ…å®Œæ•´è§£æ)
- [ç¬¬ä¸‰éƒ¨åˆ†ï¼šChannelé«˜çº§ç”¨æ³•](#ç¬¬ä¸‰éƒ¨åˆ†channelé«˜çº§ç”¨æ³•)
- [ç¬¬å››éƒ¨åˆ†ï¼šSelectæ·±åº¦å®æˆ˜](#ç¬¬å››éƒ¨åˆ†selectæ·±åº¦å®æˆ˜)
- [ç¬¬äº”éƒ¨åˆ†ï¼šåŸå­æ“ä½œè¯¦è§£](#ç¬¬äº”éƒ¨åˆ†åŸå­æ“ä½œè¯¦è§£)
- [ç¬¬å…­éƒ¨åˆ†ï¼šå¹¶å‘å®‰å…¨æ•°æ®ç»“æ„](#ç¬¬å…­éƒ¨åˆ†å¹¶å‘å®‰å…¨æ•°æ®ç»“æ„)
- [ç¬¬ä¸ƒéƒ¨åˆ†ï¼šå¹¶å‘æ¨¡å¼è¿›é˜¶](#ç¬¬ä¸ƒéƒ¨åˆ†å¹¶å‘æ¨¡å¼è¿›é˜¶)
- [ç¬¬å…«éƒ¨åˆ†ï¼šæ€§èƒ½ä¼˜åŒ–ä¸è°ƒè¯•](#ç¬¬å…«éƒ¨åˆ†æ€§èƒ½ä¼˜åŒ–ä¸è°ƒè¯•)
- [ç¬¬ä¹éƒ¨åˆ†ï¼šGo 1.23å¹¶å‘æ–°ç‰¹æ€§](#ç¬¬ä¹éƒ¨åˆ†go-123å¹¶å‘æ–°ç‰¹æ€§)
- [ç¬¬åéƒ¨åˆ†ï¼šå®Œæ•´é¡¹ç›®å®æˆ˜](#ç¬¬åéƒ¨åˆ†å®Œæ•´é¡¹ç›®å®æˆ˜)
<!-- TOC -->

---

## ç¬¬ä¸€éƒ¨åˆ†ï¼šContextæ·±åº¦å®æˆ˜

### 1.1 Contextæ ¸å¿ƒæ¦‚å¿µ

Contextæ˜¯Goå¹¶å‘ç¼–ç¨‹çš„æ ¸å¿ƒæœºåˆ¶ï¼Œç”¨äºï¼š

```text
âœ… ä¼ é€’è¯·æ±‚èŒƒå›´çš„å€¼
âœ… æ§åˆ¶Goroutineç”Ÿå‘½å‘¨æœŸ
âœ… ä¼ æ’­å–æ¶ˆä¿¡å·
âœ… è®¾ç½®è¶…æ—¶å’Œæˆªæ­¢æ—¶é—´
```

---

### 1.2 Contextæ¥å£å®šä¹‰

```go
type Context interface {
    // è¿”å›Contextçš„æˆªæ­¢æ—¶é—´ï¼ˆå¦‚æœæœ‰ï¼‰
    Deadline() (deadline time.Time, ok bool)
    
    // è¿”å›ä¸€ä¸ªchannelï¼Œå½“Contextè¢«å–æ¶ˆæ—¶å…³é—­
    Done() <-chan struct{}
    
    // è¿”å›Contextè¢«å–æ¶ˆçš„åŸå› 
    Err() error
    
    // è¿”å›ä¸keyå…³è”çš„å€¼
    Value(key any) any
}
```

---

### 1.3 å®æˆ˜æ¡ˆä¾‹1ï¼šContextå®Œæ•´ç¤ºä¾‹

```go
package main

import (
    "context"
    "fmt"
    "time"
)

// ===== 1. WithCancelï¼šæ‰‹åŠ¨å–æ¶ˆ =====
func withCancelExample() {
    ctx, cancel := context.WithCancel(context.Background())
    
    go func() {
        for {
            select {
            case <-ctx.Done():
                fmt.Println("Worker: æ”¶åˆ°å–æ¶ˆä¿¡å·ï¼Œé€€å‡º")
                return
            default:
                fmt.Println("Worker: å·¥ä½œä¸­...")
                time.Sleep(500 * time.Millisecond)
            }
        }
    }()
    
    // ä¸»goroutineå·¥ä½œ2ç§’åå–æ¶ˆ
    time.Sleep(2 * time.Second)
    cancel()
    time.Sleep(100 * time.Millisecond)
}

// ===== 2. WithTimeoutï¼šè¶…æ—¶æ§åˆ¶ =====
func withTimeoutExample() {
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel() // ç¡®ä¿èµ„æºé‡Šæ”¾
    
    go func(ctx context.Context) {
        select {
        case <-time.After(3 * time.Second):
            fmt.Println("ä»»åŠ¡å®Œæˆ")
        case <-ctx.Done():
            fmt.Println("ä»»åŠ¡è¶…æ—¶:", ctx.Err())
        }
    }(ctx)
    
    time.Sleep(3 * time.Second)
}

// ===== 3. WithDeadlineï¼šæˆªæ­¢æ—¶é—´ =====
func withDeadlineExample() {
    deadline := time.Now().Add(1 * time.Second)
    ctx, cancel := context.WithDeadline(context.Background(), deadline)
    defer cancel()
    
    go func(ctx context.Context) {
        select {
        case <-time.After(2 * time.Second):
            fmt.Println("ä»»åŠ¡å®Œæˆ")
        case <-ctx.Done():
            fmt.Println("åˆ°è¾¾æˆªæ­¢æ—¶é—´:", ctx.Err())
        }
    }(ctx)
    
    time.Sleep(2 * time.Second)
}

// ===== 4. WithValueï¼šä¼ é€’è¯·æ±‚èŒƒå›´çš„å€¼ =====
type contextKey string

const (
    userIDKey contextKey = "userID"
    traceIDKey contextKey = "traceID"
)

func withValueExample() {
    ctx := context.Background()
    ctx = context.WithValue(ctx, userIDKey, "user123")
    ctx = context.WithValue(ctx, traceIDKey, "trace-abc-123")
    
    processRequest(ctx)
}

func processRequest(ctx context.Context) {
    userID := ctx.Value(userIDKey).(string)
    traceID := ctx.Value(traceIDKey).(string)
    
    fmt.Printf("å¤„ç†è¯·æ±‚ - UserID: %s, TraceID: %s\n", userID, traceID)
}

func main() {
    fmt.Println("===== WithCancelç¤ºä¾‹ =====")
    withCancelExample()
    
    fmt.Println("\n===== WithTimeoutç¤ºä¾‹ =====")
    withTimeoutExample()
    
    fmt.Println("\n===== WithDeadlineç¤ºä¾‹ =====")
    withDeadlineExample()
    
    fmt.Println("\n===== WithValueç¤ºä¾‹ =====")
    withValueExample()
}
```

---

### 1.4 å®æˆ˜æ¡ˆä¾‹2ï¼šHTTPæœåŠ¡å™¨Contextä¼ æ’­

```go
package main

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "time"
)

// ===== ä¸­é—´ä»¶ï¼šæ·»åŠ TraceID =====
func traceMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        traceID := fmt.Sprintf("trace-%d", time.Now().UnixNano())
        ctx := context.WithValue(r.Context(), "traceID", traceID)
        
        // ä¼ æ’­Context
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// ===== ä¸­é—´ä»¶ï¼šè¶…æ—¶æ§åˆ¶ =====
func timeoutMiddleware(timeout time.Duration) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            ctx, cancel := context.WithTimeout(r.Context(), timeout)
            defer cancel()
            
            // åˆ›å»ºä¸€ä¸ªchannelæ¥æ¥æ”¶å¤„ç†ç»“æœ
            done := make(chan struct{})
            
            go func() {
                next.ServeHTTP(w, r.WithContext(ctx))
                close(done)
            }()
            
            select {
            case <-done:
                // æ­£å¸¸å®Œæˆ
            case <-ctx.Done():
                // è¶…æ—¶
                http.Error(w, "Request timeout", http.StatusGatewayTimeout)
            }
        })
    }
}

// ===== Handlerï¼šæŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯ =====
func getUserHandler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    traceID := ctx.Value("traceID").(string)
    
    log.Printf("[%s] å¼€å§‹æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯", traceID)
    
    // æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
    user, err := queryUser(ctx, "user123")
    if err != nil {
        log.Printf("[%s] æŸ¥è¯¢å¤±è´¥: %v", traceID, err)
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    log.Printf("[%s] æŸ¥è¯¢æˆåŠŸ", traceID)
    fmt.Fprintf(w, "User: %+v\n", user)
}

// ===== æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢ =====
func queryUser(ctx context.Context, userID string) (map[string]string, error) {
    // æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
    select {
    case <-time.After(1 * time.Second):
        return map[string]string{
            "id":   userID,
            "name": "Alice",
        }, nil
    case <-ctx.Done():
        return nil, ctx.Err()
    }
}

func main() {
    mux := http.NewServeMux()
    mux.HandleFunc("/user", getUserHandler)
    
    // ç»„åˆä¸­é—´ä»¶
    handler := traceMiddleware(timeoutMiddleware(2 * time.Second)(mux))
    
    log.Println("æœåŠ¡å™¨å¯åŠ¨åœ¨ :8080")
    log.Fatal(http.ListenAndServe(":8080", handler))
}
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šsyncåŒ…å®Œæ•´è§£æ

### 2.1 Mutexï¼ˆäº’æ–¥é”ï¼‰

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// ===== 1. MutexåŸºæœ¬ç”¨æ³• =====
type Counter struct {
    mu    sync.Mutex
    value int
}

func (c *Counter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

func (c *Counter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}

// ===== 2. æ­»é”ç¤ºä¾‹ï¼ˆåä¾‹ï¼‰=====
func deadlockExample() {
    var mu1, mu2 sync.Mutex
    
    // Goroutine 1: å…ˆé”mu1ï¼Œå†é”mu2
    go func() {
        mu1.Lock()
        defer mu1.Unlock()
        time.Sleep(100 * time.Millisecond)
        mu2.Lock()
        defer mu2.Unlock()
        fmt.Println("Goroutine 1 å®Œæˆ")
    }()
    
    // Goroutine 2: å…ˆé”mu2ï¼Œå†é”mu1ï¼ˆæ­»é”ï¼ï¼‰
    go func() {
        mu2.Lock()
        defer mu2.Unlock()
        time.Sleep(100 * time.Millisecond)
        mu1.Lock()
        defer mu1.Unlock()
        fmt.Println("Goroutine 2 å®Œæˆ")
    }()
    
    time.Sleep(2 * time.Second)
}

// ===== 3. é¿å…æ­»é”ï¼šç»Ÿä¸€é”é¡ºåº =====
func avoidDeadlock() {
    var mu1, mu2 sync.Mutex
    
    lockInOrder := func(first, second *sync.Mutex) {
        first.Lock()
        defer first.Unlock()
        second.Lock()
        defer second.Unlock()
        fmt.Println("æ“ä½œå®Œæˆ")
    }
    
    go lockInOrder(&mu1, &mu2)
    go lockInOrder(&mu1, &mu2) // ç›¸åŒé¡ºåºï¼Œä¸ä¼šæ­»é”
    
    time.Sleep(1 * time.Second)
}

func main() {
    // æµ‹è¯•Counter
    counter := &Counter{}
    
    var wg sync.WaitGroup
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Increment()
        }()
    }
    
    wg.Wait()
    fmt.Printf("æœ€ç»ˆå€¼: %d\n", counter.Value())
}
```

---

### 2.2 RWMutexï¼ˆè¯»å†™é”ï¼‰

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// ===== è¯»å†™é”ç¤ºä¾‹ =====
type Cache struct {
    mu    sync.RWMutex
    data  map[string]string
}

func NewCache() *Cache {
    return &Cache{
        data: make(map[string]string),
    }
}

// è¯»æ“ä½œï¼ˆå…è®¸å¤šä¸ªå¹¶å‘è¯»ï¼‰
func (c *Cache) Get(key string) (string, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    val, ok := c.data[key]
    return val, ok
}

// å†™æ“ä½œï¼ˆç‹¬å é”ï¼‰
func (c *Cache) Set(key, value string) {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    c.data[key] = value
}

// ===== æ€§èƒ½å¯¹æ¯”ï¼šMutex vs RWMutex =====
func benchmarkMutex() time.Duration {
    var mu sync.Mutex
    data := make(map[string]int)
    
    start := time.Now()
    
    var wg sync.WaitGroup
    
    // 90%è¯»æ“ä½œ
    for i := 0; i < 9000; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            mu.Lock()
            _ = data["key"]
            mu.Unlock()
        }(i)
    }
    
    // 10%å†™æ“ä½œ
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            mu.Lock()
            data["key"] = i
            mu.Unlock()
        }(i)
    }
    
    wg.Wait()
    return time.Since(start)
}

func benchmarkRWMutex() time.Duration {
    var mu sync.RWMutex
    data := make(map[string]int)
    
    start := time.Now()
    
    var wg sync.WaitGroup
    
    // 90%è¯»æ“ä½œ
    for i := 0; i < 9000; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            mu.RLock()
            _ = data["key"]
            mu.RUnlock()
        }(i)
    }
    
    // 10%å†™æ“ä½œ
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            mu.Lock()
            data["key"] = i
            mu.Unlock()
        }(i)
    }
    
    wg.Wait()
    return time.Since(start)
}

func main() {
    // æµ‹è¯•Cache
    cache := NewCache()
    cache.Set("name", "Alice")
    
    var wg sync.WaitGroup
    
    // å¹¶å‘è¯»
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            val, _ := cache.Get("name")
            fmt.Printf("Reader %d: %s\n", i, val)
        }(i)
    }
    
    wg.Wait()
    
    // æ€§èƒ½å¯¹æ¯”
    fmt.Println("\n===== æ€§èƒ½å¯¹æ¯”ï¼ˆ90%è¯» + 10%å†™ï¼‰=====")
    mutexTime := benchmarkMutex()
    rwMutexTime := benchmarkRWMutex()
    
    fmt.Printf("Mutex:   %v\n", mutexTime)
    fmt.Printf("RWMutex: %v\n", rwMutexTime)
    fmt.Printf("RWMutexæå‡: %.2få€\n", float64(mutexTime)/float64(rwMutexTime))
}
```

---

### 2.3 WaitGroupæ·±åº¦å®æˆ˜

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// ===== 1. WaitGroupåŸºæœ¬ç”¨æ³• =====
func basicWaitGroup() {
    var wg sync.WaitGroup
    
    for i := 0; i < 5; i++ {
        wg.Add(1) // åœ¨å¯åŠ¨goroutineå‰Add
        
        go func(id int) {
            defer wg.Done() // ç¡®ä¿Doneè¢«è°ƒç”¨
            
            fmt.Printf("Worker %d å¼€å§‹\n", id)
            time.Sleep(time.Duration(id) * 100 * time.Millisecond)
            fmt.Printf("Worker %d å®Œæˆ\n", id)
        }(i)
    }
    
    wg.Wait() // ç­‰å¾…æ‰€æœ‰goroutineå®Œæˆ
    fmt.Println("æ‰€æœ‰ä»»åŠ¡å®Œæˆ")
}

// ===== 2. WaitGroupé”™è¯¯ç”¨æ³•ï¼ˆåä¾‹ï¼‰=====
func wrongWaitGroup() {
    var wg sync.WaitGroup
    
    for i := 0; i < 5; i++ {
        go func(id int) {
            wg.Add(1) // âŒ é”™è¯¯ï¼šåœ¨goroutineå†…éƒ¨Addå¯èƒ½å¯¼è‡´ç«æ€
            defer wg.Done()
            
            fmt.Printf("Worker %d\n", id)
        }(i)
    }
    
    wg.Wait() // å¯èƒ½åœ¨æ‰€æœ‰Addæ‰§è¡Œå‰å°±è¿”å›
}

// ===== 3. WaitGroup + é”™è¯¯æ”¶é›† =====
func waitGroupWithErrors() {
    var wg sync.WaitGroup
    errCh := make(chan error, 5)
    
    for i := 0; i < 5; i++ {
        wg.Add(1)
        
        go func(id int) {
            defer wg.Done()
            
            // æ¨¡æ‹Ÿä»»åŠ¡
            if id%2 == 0 {
                errCh <- fmt.Errorf("worker %d å¤±è´¥", id)
            } else {
                fmt.Printf("Worker %d æˆåŠŸ\n", id)
            }
        }(i)
    }
    
    // ç­‰å¾…æ‰€æœ‰goroutineå®Œæˆ
    wg.Wait()
    close(errCh)
    
    // æ”¶é›†é”™è¯¯
    var errors []error
    for err := range errCh {
        errors = append(errors, err)
    }
    
    if len(errors) > 0 {
        fmt.Printf("å‘ç° %d ä¸ªé”™è¯¯:\n", len(errors))
        for _, err := range errors {
            fmt.Printf("  - %v\n", err)
        }
    }
}

// ===== 4. WaitGroup.Go()ï¼ˆGo 1.25æ–°ç‰¹æ€§æ¨¡æ‹Ÿï¼‰=====
type WaitGroupExt struct {
    sync.WaitGroup
}

func (wg *WaitGroupExt) Go(f func()) {
    wg.Add(1)
    go func() {
        defer wg.Done()
        f()
    }()
}

func waitGroupGoExample() {
    var wg WaitGroupExt
    
    for i := 0; i < 5; i++ {
        id := i
        wg.Go(func() {
            fmt.Printf("Worker %d\n", id)
            time.Sleep(100 * time.Millisecond)
        })
    }
    
    wg.Wait()
    fmt.Println("æ‰€æœ‰ä»»åŠ¡å®Œæˆ")
}

func main() {
    fmt.Println("===== åŸºæœ¬ç”¨æ³• =====")
    basicWaitGroup()
    
    fmt.Println("\n===== é”™è¯¯æ”¶é›† =====")
    waitGroupWithErrors()
    
    fmt.Println("\n===== WaitGroup.Go() =====")
    waitGroupGoExample()
}
```

---

### 2.4 Onceï¼ˆå•æ¬¡æ‰§è¡Œï¼‰

```go
package main

import (
    "fmt"
    "sync"
)

// ===== 1. OnceåŸºæœ¬ç”¨æ³•ï¼šå•ä¾‹æ¨¡å¼ =====
type Singleton struct {
    data string
}

var (
    instance *Singleton
    once     sync.Once
)

func GetInstance() *Singleton {
    once.Do(func() {
        fmt.Println("åˆå§‹åŒ–å•ä¾‹...")
        instance = &Singleton{data: "singleton"}
    })
    return instance
}

// ===== 2. Onceç”¨äºå»¶è¿Ÿåˆå§‹åŒ– =====
type Config struct {
    once   sync.Once
    config map[string]string
}

func (c *Config) Load() {
    c.once.Do(func() {
        fmt.Println("åŠ è½½é…ç½®...")
        c.config = map[string]string{
            "host": "localhost",
            "port": "8080",
        }
    })
}

func (c *Config) Get(key string) string {
    c.Load() // ç¡®ä¿é…ç½®å·²åŠ è½½
    return c.config[key]
}

// ===== 3. Once + é”™è¯¯å¤„ç† =====
type Resource struct {
    once sync.Once
    data *string
    err  error
}

func (r *Resource) Init() error {
    r.once.Do(func() {
        // æ¨¡æ‹Ÿåˆå§‹åŒ–
        result := "initialized"
        r.data = &result
        r.err = nil
    })
    return r.err
}

func main() {
    // æµ‹è¯•å•ä¾‹
    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            instance := GetInstance()
            fmt.Printf("Goroutine %d è·å¾—å®ä¾‹: %p\n", id, instance)
        }(i)
    }
    wg.Wait()
    
    // æµ‹è¯•é…ç½®åŠ è½½
    fmt.Println("\n===== é…ç½®åŠ è½½ =====")
    cfg := &Config{}
    
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            host := cfg.Get("host")
            fmt.Printf("Host: %s\n", host)
        }()
    }
    wg.Wait()
}
```

---

### 2.5 Poolï¼ˆå¯¹è±¡æ± ï¼‰

```go
package main

import (
    "bytes"
    "fmt"
    "sync"
)

// ===== 1. PoolåŸºæœ¬ç”¨æ³• =====
var bufferPool = sync.Pool{
    New: func() any {
        fmt.Println("åˆ›å»ºæ–°buffer")
        return new(bytes.Buffer)
    },
}

func processData(data string) string {
    // ä»æ± ä¸­è·å–buffer
    buf := bufferPool.Get().(*bytes.Buffer)
    defer func() {
        buf.Reset() // æ¸…ç©ºbuffer
        bufferPool.Put(buf) // å½’è¿˜åˆ°æ± ä¸­
    }()
    
    buf.WriteString("å¤„ç†: ")
    buf.WriteString(data)
    return buf.String()
}

// ===== 2. Poolæ€§èƒ½å¯¹æ¯” =====
func benchmarkWithoutPool(n int) {
    for i := 0; i < n; i++ {
        buf := new(bytes.Buffer)
        buf.WriteString("test")
        _ = buf.String()
    }
}

func benchmarkWithPool(n int) {
    pool := sync.Pool{
        New: func() any {
            return new(bytes.Buffer)
        },
    }
    
    for i := 0; i < n; i++ {
        buf := pool.Get().(*bytes.Buffer)
        buf.WriteString("test")
        _ = buf.String()
        buf.Reset()
        pool.Put(buf)
    }
}

// ===== 3. è‡ªå®šä¹‰Worker Pool =====
type Worker struct {
    id int
}

var workerPool = sync.Pool{
    New: func() any {
        fmt.Println("åˆ›å»ºæ–°Worker")
        return &Worker{}
    },
}

func doWork(taskID int) {
    worker := workerPool.Get().(*Worker)
    defer workerPool.Put(worker)
    
    worker.id = taskID
    fmt.Printf("Worker %d æ‰§è¡Œä»»åŠ¡\n", worker.id)
}

func main() {
    // æµ‹è¯•bufferPool
    fmt.Println("===== Buffer Pool =====")
    for i := 0; i < 3; i++ {
        result := processData(fmt.Sprintf("data%d", i))
        fmt.Println(result)
    }
    
    // æµ‹è¯•workerPool
    fmt.Println("\n===== Worker Pool =====")
    for i := 0; i < 5; i++ {
        doWork(i)
    }
}
```

---

### 2.6 Condï¼ˆæ¡ä»¶å˜é‡ï¼‰

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// ===== 1. CondåŸºæœ¬ç”¨æ³•ï¼šç”Ÿäº§è€…-æ¶ˆè´¹è€… =====
type Queue struct {
    mu    sync.Mutex
    cond  *sync.Cond
    items []int
    max   int
}

func NewQueue(max int) *Queue {
    q := &Queue{
        items: make([]int, 0),
        max:   max,
    }
    q.cond = sync.NewCond(&q.mu)
    return q
}

func (q *Queue) Produce(item int) {
    q.mu.Lock()
    defer q.mu.Unlock()
    
    // ç­‰å¾…é˜Ÿåˆ—æœ‰ç©ºé—´
    for len(q.items) >= q.max {
        fmt.Println("é˜Ÿåˆ—æ»¡ï¼Œç”Ÿäº§è€…ç­‰å¾…...")
        q.cond.Wait() // é‡Šæ”¾é”å¹¶ç­‰å¾…
    }
    
    q.items = append(q.items, item)
    fmt.Printf("ç”Ÿäº§: %d, é˜Ÿåˆ—é•¿åº¦: %d\n", item, len(q.items))
    
    q.cond.Signal() // é€šçŸ¥ä¸€ä¸ªç­‰å¾…çš„æ¶ˆè´¹è€…
}

func (q *Queue) Consume() int {
    q.mu.Lock()
    defer q.mu.Unlock()
    
    // ç­‰å¾…é˜Ÿåˆ—æœ‰æ•°æ®
    for len(q.items) == 0 {
        fmt.Println("é˜Ÿåˆ—ç©ºï¼Œæ¶ˆè´¹è€…ç­‰å¾…...")
        q.cond.Wait()
    }
    
    item := q.items[0]
    q.items = q.items[1:]
    fmt.Printf("æ¶ˆè´¹: %d, é˜Ÿåˆ—é•¿åº¦: %d\n", item, len(q.items))
    
    q.cond.Signal() // é€šçŸ¥ä¸€ä¸ªç­‰å¾…çš„ç”Ÿäº§è€…
    return item
}

func main() {
    queue := NewQueue(3)
    
    // å¯åŠ¨ç”Ÿäº§è€…
    for i := 0; i < 5; i++ {
        go func(id int) {
            for j := 0; j < 3; j++ {
                queue.Produce(id*10 + j)
                time.Sleep(100 * time.Millisecond)
            }
        }(i)
    }
    
    // å¯åŠ¨æ¶ˆè´¹è€…
    for i := 0; i < 3; i++ {
        go func(id int) {
            for j := 0; j < 5; j++ {
                queue.Consume()
                time.Sleep(200 * time.Millisecond)
            }
        }(i)
    }
    
    time.Sleep(5 * time.Second)
}
```

---

### 2.7 Mapï¼ˆå¹¶å‘å®‰å…¨Mapï¼‰

```go
package main

import (
    "fmt"
    "sync"
)

// ===== 1. sync.MapåŸºæœ¬ç”¨æ³• =====
func basicSyncMap() {
    var m sync.Map
    
    // Store
    m.Store("name", "Alice")
    m.Store("age", 30)
    
    // Load
    if val, ok := m.Load("name"); ok {
        fmt.Printf("name: %v\n", val)
    }
    
    // LoadOrStore
    actual, loaded := m.LoadOrStore("city", "Beijing")
    fmt.Printf("city: %v, loaded: %v\n", actual, loaded)
    
    // Range
    fmt.Println("\néå†:")
    m.Range(func(key, value any) bool {
        fmt.Printf("%v: %v\n", key, value)
        return true // ç»§ç»­éå†
    })
    
    // Delete
    m.Delete("age")
}

// ===== 2. æ€§èƒ½å¯¹æ¯”ï¼šMap+Mutex vs sync.Map =====
func benchmarkMapWithMutex(n int) {
    var mu sync.RWMutex
    m := make(map[string]int)
    
    var wg sync.WaitGroup
    
    // å†™æ“ä½œ
    for i := 0; i < n/2; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", i)
            mu.Lock()
            m[key] = i
            mu.Unlock()
        }(i)
    }
    
    // è¯»æ“ä½œ
    for i := 0; i < n/2; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", i)
            mu.RLock()
            _ = m[key]
            mu.RUnlock()
        }(i)
    }
    
    wg.Wait()
}

func benchmarkSyncMap(n int) {
    var m sync.Map
    var wg sync.WaitGroup
    
    // å†™æ“ä½œ
    for i := 0; i < n/2; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", i)
            m.Store(key, i)
        }(i)
    }
    
    // è¯»æ“ä½œ
    for i := 0; i < n/2; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", i)
            m.Load(key)
        }(i)
    }
    
    wg.Wait()
}

// ===== 3. sync.Mapé€‚ç”¨åœºæ™¯ =====
// åœºæ™¯1ï¼šè¯»å¤šå†™å°‘
// åœºæ™¯2ï¼šé”®ç©ºé—´å›ºå®šï¼Œè¯»å†™ä¸é‡å 

func main() {
    fmt.Println("===== sync.MapåŸºæœ¬ç”¨æ³• =====")
    basicSyncMap()
}
```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šChannelé«˜çº§ç”¨æ³•

### 3.1 Channelå…³é—­ä¸æ£€æµ‹

```go
package main

import (
    "fmt"
    "sync"
)

// ===== 1. æ£€æµ‹Channelæ˜¯å¦å…³é—­ =====
func checkClosed() {
    ch := make(chan int, 3)
    
    ch <- 1
    ch <- 2
    ch <- 3
    close(ch)
    
    // æ–¹å¼1ï¼šé€šè¿‡okæ£€æµ‹
    for {
        val, ok := <-ch
        if !ok {
            fmt.Println("Channelå·²å…³é—­")
            break
        }
        fmt.Printf("æ¥æ”¶: %d\n", val)
    }
    
    // æ–¹å¼2ï¼šä½¿ç”¨rangeï¼ˆæ¨èï¼‰
    ch2 := make(chan int, 3)
    ch2 <- 10
    ch2 <- 20
    ch2 <- 30
    close(ch2)
    
    for val := range ch2 {
        fmt.Printf("Rangeæ¥æ”¶: %d\n", val)
    }
}

// ===== 2. ä¼˜é›…å…³é—­Channelæ¨¡å¼ =====
// åŸåˆ™ï¼šå‘é€è€…å…³é—­ï¼Œæ¥æ”¶è€…ä¸å…³é—­

// æ¨¡å¼1ï¼šå•å‘é€è€…ï¼Œå¤šæ¥æ”¶è€…
func singleSenderMultiReceiver() {
    ch := make(chan int, 10)
    
    // å‘é€è€…
    go func() {
        defer close(ch) // å‘é€å®Œæ¯•åå…³é—­
        for i := 0; i < 10; i++ {
            ch <- i
        }
    }()
    
    // å¤šä¸ªæ¥æ”¶è€…
    var wg sync.WaitGroup
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for val := range ch {
                fmt.Printf("æ¥æ”¶è€…%d: %d\n", id, val)
            }
        }(i)
    }
    
    wg.Wait()
}

// æ¨¡å¼2ï¼šå¤šå‘é€è€…ï¼Œå•æ¥æ”¶è€…
func multiSenderSingleReceiver() {
    ch := make(chan int, 10)
    stopCh := make(chan struct{})
    
    // å¤šä¸ªå‘é€è€…
    var wg sync.WaitGroup
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for j := 0; j < 5; j++ {
                select {
                case ch <- id*10 + j:
                case <-stopCh:
                    return
                }
            }
        }(i)
    }
    
    // ç­‰å¾…æ‰€æœ‰å‘é€è€…å®Œæˆåå…³é—­channel
    go func() {
        wg.Wait()
        close(ch)
    }()
    
    // æ¥æ”¶è€…
    for val := range ch {
        fmt.Printf("æ¥æ”¶: %d\n", val)
    }
}

// æ¨¡å¼3ï¼šå¤šå‘é€è€…ï¼Œå¤šæ¥æ”¶è€…ï¼ˆä½¿ç”¨ä¸­é—´åè°ƒè€…ï¼‰
type Hub struct {
    sources []<-chan int
    dest    chan int
    stop    chan struct{}
}

func NewHub(sources []<-chan int) *Hub {
    return &Hub{
        sources: sources,
        dest:    make(chan int, 10),
        stop:    make(chan struct{}),
    }
}

func (h *Hub) Start() <-chan int {
    var wg sync.WaitGroup
    
    // ä¸ºæ¯ä¸ªsourceå¯åŠ¨ä¸€ä¸ªgoroutine
    for _, src := range h.sources {
        wg.Add(1)
        go func(ch <-chan int) {
            defer wg.Done()
            for {
                select {
                case val, ok := <-ch:
                    if !ok {
                        return
                    }
                    select {
                    case h.dest <- val:
                    case <-h.stop:
                        return
                    }
                case <-h.stop:
                    return
                }
            }
        }(src)
    }
    
    // ç­‰å¾…æ‰€æœ‰sourceå¤„ç†å®Œæ¯•åå…³é—­dest
    go func() {
        wg.Wait()
        close(h.dest)
    }()
    
    return h.dest
}

func (h *Hub) Stop() {
    close(h.stop)
}

func main() {
    fmt.Println("===== æ£€æµ‹Channelå…³é—­ =====")
    checkClosed()
    
    fmt.Println("\n===== å•å‘é€è€…å¤šæ¥æ”¶è€… =====")
    singleSenderMultiReceiver()
    
    fmt.Println("\n===== å¤šå‘é€è€…å•æ¥æ”¶è€… =====")
    multiSenderSingleReceiver()
}
```

---

### 3.2 nil Channelä¸é›¶å€¼Channel

```go
package main

import (
    "fmt"
    "time"
)

// ===== 1. nil Channelè¡Œä¸º =====
func nilChannelBehavior() {
    var ch chan int // nil channel
    
    // ä»nil channelæ¥æ”¶ï¼šæ°¸ä¹…é˜»å¡
    // val := <-ch // ä¼šæ­»é”
    
    // å‘nil channelå‘é€ï¼šæ°¸ä¹…é˜»å¡
    // ch <- 1 // ä¼šæ­»é”
    
    // å…³é—­nil channelï¼španic
    // close(ch) // panic
    
    // åœ¨selectä¸­ä½¿ç”¨nil channelï¼šè¯¥caseè¢«å¿½ç•¥
    select {
    case <-ch:
        fmt.Println("ä¸ä¼šæ‰§è¡Œ")
    default:
        fmt.Println("nil channelçš„caseè¢«å¿½ç•¥")
    }
}

// ===== 2. nil Channelçš„å®ç”¨åœºæ™¯ =====
// åŠ¨æ€ç¦ç”¨selectä¸­çš„case
func mergeChannels(ch1, ch2 <-chan int) <-chan int {
    out := make(chan int)
    
    go func() {
        defer close(out)
        
        for ch1 != nil || ch2 != nil {
            select {
            case val, ok := <-ch1:
                if !ok {
                    ch1 = nil // ç¦ç”¨ch1
                    continue
                }
                out <- val
            case val, ok := <-ch2:
                if !ok {
                    ch2 = nil // ç¦ç”¨ch2
                    continue
                }
                out <- val
            }
        }
    }()
    
    return out
}

func main() {
    fmt.Println("===== nil Channelè¡Œä¸º =====")
    nilChannelBehavior()
    
    fmt.Println("\n===== åˆå¹¶Channel =====")
    ch1 := make(chan int, 3)
    ch2 := make(chan int, 3)
    
    ch1 <- 1
    ch1 <- 2
    ch1 <- 3
    close(ch1)
    
    ch2 <- 10
    ch2 <- 20
    close(ch2)
    
    merged := mergeChannels(ch1, ch2)
    
    for val := range merged {
        fmt.Println(val)
    }
}
```

---

## ç¬¬å››éƒ¨åˆ†ï¼šSelectæ·±åº¦å®æˆ˜

### 4.1 Selectå®Œæ•´ç”¨æ³•

```go
package main

import (
    "fmt"
    "time"
)

// ===== 1. SelectåŸºæœ¬ç”¨æ³• =====
func basicSelect() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    
    go func() {
        time.Sleep(1 * time.Second)
        ch1 <- "one"
    }()
    
    go func() {
        time.Sleep(2 * time.Second)
        ch2 <- "two"
    }()
    
    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-ch1:
            fmt.Println("æ¥æ”¶ch1:", msg1)
        case msg2 := <-ch2:
            fmt.Println("æ¥æ”¶ch2:", msg2)
        }
    }
}

// ===== 2. Select + Defaultï¼ˆéé˜»å¡ï¼‰=====
func selectWithDefault() {
    ch := make(chan int, 1)
    
    // éé˜»å¡å‘é€
    select {
    case ch <- 1:
        fmt.Println("å‘é€æˆåŠŸ")
    default:
        fmt.Println("Channelæ»¡ï¼Œå‘é€å¤±è´¥")
    }
    
    // éé˜»å¡æ¥æ”¶
    select {
    case val := <-ch:
        fmt.Printf("æ¥æ”¶æˆåŠŸ: %d\n", val)
    default:
        fmt.Println("Channelç©ºï¼Œæ¥æ”¶å¤±è´¥")
    }
}

// ===== 3. Select + Timeout =====
func selectWithTimeout() {
    ch := make(chan string)
    
    go func() {
        time.Sleep(2 * time.Second)
        ch <- "result"
    }()
    
    select {
    case res := <-ch:
        fmt.Println("æ¥æ”¶:", res)
    case <-time.After(1 * time.Second):
        fmt.Println("è¶…æ—¶")
    }
}

// ===== 4. Selectå¤šè·¯å¤ç”¨ =====
func selectMultiplex() {
    tick := time.Tick(500 * time.Millisecond)
    boom := time.After(2 * time.Second)
    
    for {
        select {
        case <-tick:
            fmt.Println("tick.")
        case <-boom:
            fmt.Println("BOOM!")
            return
        default:
            fmt.Println("    .")
            time.Sleep(200 * time.Millisecond)
        }
    }
}

func main() {
    fmt.Println("===== åŸºæœ¬ç”¨æ³• =====")
    basicSelect()
    
    fmt.Println("\n===== éé˜»å¡æ“ä½œ =====")
    selectWithDefault()
    
    fmt.Println("\n===== è¶…æ—¶æ§åˆ¶ =====")
    selectWithTimeout()
    
    fmt.Println("\n===== å¤šè·¯å¤ç”¨ =====")
    selectMultiplex()
}
```

---

## ç¬¬äº”éƒ¨åˆ†ï¼šåŸå­æ“ä½œè¯¦è§£

### 5.1 atomicåŒ…å®Œæ•´è§£æ

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

// ===== 1. åŸå­æ•´æ•°æ“ä½œ =====
func atomicIntOperations() {
    var counter int64
    
    var wg sync.WaitGroup
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            atomic.AddInt64(&counter, 1)
        }()
    }
    
    wg.Wait()
    fmt.Printf("Counter: %d\n", atomic.LoadInt64(&counter))
}

// ===== 2. Compare-And-Swapï¼ˆCASï¼‰=====
func casExample() {
    var value int64 = 100
    
    // å°è¯•å°†100æ›¿æ¢ä¸º200
    swapped := atomic.CompareAndSwapInt64(&value, 100, 200)
    fmt.Printf("CASæˆåŠŸ: %v, æ–°å€¼: %d\n", swapped, value)
    
    // å†æ¬¡å°è¯•å°†100æ›¿æ¢ä¸º300ï¼ˆå¤±è´¥ï¼‰
    swapped = atomic.CompareAndSwapInt64(&value, 100, 300)
    fmt.Printf("CASæˆåŠŸ: %v, å€¼: %d\n", swapped, value)
}

// ===== 3. åŸå­æŒ‡é’ˆæ“ä½œ =====
type Config struct {
    host string
    port int
}

var configPtr atomic.Pointer[Config]

func atomicPointerExample() {
    // åˆå§‹é…ç½®
    config1 := &Config{host: "localhost", port: 8080}
    configPtr.Store(config1)
    
    // è¯»å–é…ç½®
    cfg := configPtr.Load()
    fmt.Printf("Config1: %+v\n", cfg)
    
    // æ›´æ–°é…ç½®ï¼ˆåŸå­æ“ä½œï¼‰
    config2 := &Config{host: "0.0.0.0", port: 9090}
    configPtr.Store(config2)
    
    cfg = configPtr.Load()
    fmt.Printf("Config2: %+v\n", cfg)
}

// ===== 4. åŸå­Value =====
var configValue atomic.Value

func atomicValueExample() {
    // å­˜å‚¨ä»»æ„ç±»å‹
    configValue.Store(map[string]string{
        "env": "dev",
    })
    
    // åŠ è½½
    cfg := configValue.Load().(map[string]string)
    fmt.Printf("Config: %v\n", cfg)
    
    // æ›´æ–°
    configValue.Store(map[string]string{
        "env": "prod",
    })
    
    cfg = configValue.Load().(map[string]string)
    fmt.Printf("Updated Config: %v\n", cfg)
}

// ===== 5. æ€§èƒ½å¯¹æ¯”ï¼šMutex vs Atomic =====
func benchmarkMutex(n int) {
    var mu sync.Mutex
    var counter int64
    
    var wg sync.WaitGroup
    for i := 0; i < n; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            mu.Lock()
            counter++
            mu.Unlock()
        }()
    }
    wg.Wait()
}

func benchmarkAtomic(n int) {
    var counter int64
    
    var wg sync.WaitGroup
    for i := 0; i < n; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            atomic.AddInt64(&counter, 1)
        }()
    }
    wg.Wait()
}

func main() {
    fmt.Println("===== åŸå­æ•´æ•°æ“ä½œ =====")
    atomicIntOperations()
    
    fmt.Println("\n===== CASæ“ä½œ =====")
    casExample()
    
    fmt.Println("\n===== åŸå­æŒ‡é’ˆ =====")
    atomicPointerExample()
    
    fmt.Println("\n===== åŸå­Value =====")
    atomicValueExample()
}
```

---

## ğŸ¯ æ€»ç»“

### å¹¶å‘æ ¸å¿ƒè¦ç‚¹

1. **Context** - è¯·æ±‚èŒƒå›´ä¼ æ’­ã€å–æ¶ˆæ§åˆ¶ã€è¶…æ—¶ç®¡ç†
2. **sync.Mutex/RWMutex** - äº’æ–¥é”ã€è¯»å†™é”
3. **sync.WaitGroup** - GoroutineåŒæ­¥ç­‰å¾…
4. **sync.Once** - å•æ¬¡æ‰§è¡Œã€å»¶è¿Ÿåˆå§‹åŒ–
5. **sync.Pool** - å¯¹è±¡æ± ã€å‡å°‘GCå‹åŠ›
6. **sync.Cond** - æ¡ä»¶å˜é‡ã€ç”Ÿäº§è€…-æ¶ˆè´¹è€…
7. **sync.Map** - å¹¶å‘å®‰å…¨Map
8. **Channel** - é€šä¿¡åŸè¯­ã€ä¼˜é›…å…³é—­
9. **Select** - å¤šè·¯å¤ç”¨ã€è¶…æ—¶æ§åˆ¶
10. **atomic** - åŸå­æ“ä½œã€æ— é”ç¼–ç¨‹

### æœ€ä½³å®è·µæ¸…å•

```text
âœ… Contextä¼ æ’­è¯·æ±‚èŒƒå›´çš„å€¼å’Œå–æ¶ˆä¿¡å·
âœ… ä½¿ç”¨WaitGroupåŒæ­¥Goroutine
âœ… è¯»å¤šå†™å°‘åœºæ™¯ä½¿ç”¨RWMutex
âœ… Onceå®ç°å•ä¾‹å’Œå»¶è¿Ÿåˆå§‹åŒ–
âœ… Poolå¤ç”¨å¯¹è±¡å‡å°‘GC
âœ… Channeléµå¾ª"å‘é€è€…å…³é—­"åŸåˆ™
âœ… Selectå®ç°è¶…æ—¶å’Œå¤šè·¯å¤ç”¨
âœ… atomicå®ç°æ— é”å¹¶å‘
âœ… é¿å…æ­»é”ï¼ˆç»Ÿä¸€é”é¡ºåºï¼‰
âœ… ä½¿ç”¨-raceæ£€æµ‹æ•°æ®ç«äº‰
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v11.0  
**æœ€åæ›´æ–°**: 2025-10-20

<div align="center">

Made with â¤ï¸ for Go Concurrent Developers

[â¬† å›åˆ°é¡¶éƒ¨](#goå¹¶å‘ç¼–ç¨‹è¿›é˜¶æ·±åº¦æŒ‡å—)

</div>
