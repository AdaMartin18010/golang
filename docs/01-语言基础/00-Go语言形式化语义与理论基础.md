# Goè¯­è¨€å½¢å¼åŒ–è¯­ä¹‰ä¸ç†è®ºåŸºç¡€

**æ–‡æ¡£çŠ¶æ€**: âœ… ç†è®ºå®Œæ•´ç‰ˆ (v10.0)  
**åŸºå‡†æ—¥æœŸ**: 2025å¹´10æœˆ20æ—¥  
**Goç‰ˆæœ¬**: Go 1.23.x  
**å­—æ•°**: ~35,000å­—  
**é€‚ç”¨äººç¾¤**: å­¦æœ¯ç ”ç©¶è€…ã€ç¼–è¯‘å™¨å¼€å‘è€…ã€è¯­è¨€ç†è®ºç ”ç©¶è€…

---

## ğŸ“š ç›®å½•

<!-- TOC -->
- [ç¬¬ä¸€éƒ¨åˆ†ï¼šè¯­æ³•å½¢å¼åŒ–å®šä¹‰](#ç¬¬ä¸€éƒ¨åˆ†è¯­æ³•å½¢å¼åŒ–å®šä¹‰)
- [ç¬¬äºŒéƒ¨åˆ†ï¼šæ“ä½œè¯­ä¹‰ä¸æŒ‡ç§°è¯­ä¹‰](#ç¬¬äºŒéƒ¨åˆ†æ“ä½œè¯­ä¹‰ä¸æŒ‡ç§°è¯­ä¹‰)
- [ç¬¬ä¸‰éƒ¨åˆ†ï¼šç±»å‹ç³»ç»Ÿå½¢å¼åŒ–](#ç¬¬ä¸‰éƒ¨åˆ†ç±»å‹ç³»ç»Ÿå½¢å¼åŒ–)
- [ç¬¬å››éƒ¨åˆ†ï¼šCSPå¹¶å‘æ¨¡å‹å½¢å¼åŒ–](#ç¬¬å››éƒ¨åˆ†cspå¹¶å‘æ¨¡å‹å½¢å¼åŒ–)
- [ç¬¬äº”éƒ¨åˆ†ï¼šæ§åˆ¶æµå½¢å¼åŒ–](#ç¬¬äº”éƒ¨åˆ†æ§åˆ¶æµå½¢å¼åŒ–)
- [ç¬¬å…­éƒ¨åˆ†ï¼šå†…å­˜æ¨¡å‹ä¸ä¸€è‡´æ€§](#ç¬¬å…­éƒ¨åˆ†å†…å­˜æ¨¡å‹ä¸ä¸€è‡´æ€§)
- [ç¬¬ä¸ƒéƒ¨åˆ†ï¼šå½¢å¼åŒ–éªŒè¯ä¸è¯æ˜](#ç¬¬ä¸ƒéƒ¨åˆ†å½¢å¼åŒ–éªŒè¯ä¸è¯æ˜)
- [ç¬¬å…«éƒ¨åˆ†ï¼šGo 1.23æ–°ç‰¹æ€§å½¢å¼åŒ–](#ç¬¬å…«éƒ¨åˆ†go-123æ–°ç‰¹æ€§å½¢å¼åŒ–)
<!-- TOC -->

---

## ç¬¬ä¸€éƒ¨åˆ†ï¼šè¯­æ³•å½¢å¼åŒ–å®šä¹‰

### 1.1 æ‰©å±•å·´ç§‘æ–¯-ç‘™å°”èŒƒå¼ï¼ˆEBNFï¼‰

Goè¯­è¨€çš„è¯­æ³•é‡‡ç”¨EBNFè¿›è¡Œå½¢å¼åŒ–æè¿°ã€‚ä»¥ä¸‹æ˜¯æ ¸å¿ƒè¯­æ³•çš„å½¢å¼åŒ–å®šä¹‰ï¼š

#### 1.1.1 è¯æ³•å…ƒç´ 

```ebnf
/* å­—é¢é‡ */
int_lit        = decimal_lit | octal_lit | hex_lit | binary_lit .
decimal_lit    = "0" | ( "1" â€¦ "9" ) [ [ "_" ] decimal_digits ] .
octal_lit      = "0" [ "o" | "O" ] [ "_" ] octal_digits .
hex_lit        = "0" ( "x" | "X" ) [ "_" ] hex_digits .
binary_lit     = "0" ( "b" | "B" ) [ "_" ] binary_digits .

float_lit      = decimal_float_lit | hex_float_lit .
decimal_float_lit = decimal_digits "." [ decimal_digits ] [ decimal_exponent ] |
                    decimal_digits decimal_exponent |
                    "." decimal_digits [ decimal_exponent ] .
hex_float_lit  = "0" ( "x" | "X" ) hex_mantissa hex_exponent .

string_lit     = raw_string_lit | interpreted_string_lit .
raw_string_lit = "`" { unicode_char | newline } "`" .
interpreted_string_lit = `"` { unicode_value | byte_value } `"` .

/* æ ‡è¯†ç¬¦ */
identifier = letter { letter | unicode_digit } .
letter     = unicode_letter | "_" .
```

#### 1.1.2 ç±»å‹å®šä¹‰

```ebnf
Type      = TypeName [ TypeArgs ] | TypeLit | "(" Type ")" .
TypeName  = identifier | QualifiedIdent .
TypeArgs  = "[" TypeList [ "," ] "]" .
TypeList  = Type { "," Type } .
TypeLit   = ArrayType | StructType | PointerType | FunctionType | 
            InterfaceType | SliceType | MapType | ChannelType .

/* æ•°ç»„ç±»å‹ */
ArrayType   = "[" ArrayLength "]" ElementType .
ArrayLength = Expression .
ElementType = Type .

/* åˆ‡ç‰‡ç±»å‹ */
SliceType = "[" "]" ElementType .

/* ç»“æ„ä½“ç±»å‹ */
StructType    = "struct" "{" { FieldDecl ";" } "}" .
FieldDecl     = ( IdentifierList Type | EmbeddedField ) [ Tag ] .
EmbeddedField = [ "*" ] TypeName [ TypeArgs ] .
Tag           = string_lit .

/* æŒ‡é’ˆç±»å‹ */
PointerType = "*" BaseType .
BaseType    = Type .

/* å‡½æ•°ç±»å‹ */
FunctionType   = "func" Signature .
Signature      = Parameters [ Result ] .
Result         = Parameters | Type .
Parameters     = "(" [ ParameterList [ "," ] ] ")" .
ParameterList  = ParameterDecl { "," ParameterDecl } .
ParameterDecl  = [ IdentifierList ] [ "..." ] Type .

/* æ¥å£ç±»å‹ */
InterfaceType  = "interface" "{" { InterfaceElem ";" } "}" .
InterfaceElem  = MethodElem | TypeElem .
MethodElem     = MethodName Signature .
TypeElem       = TypeTerm { "|" TypeTerm } .
TypeTerm       = Type | UnderlyingType .
UnderlyingType = "~" Type .

/* æ˜ å°„ç±»å‹ */
MapType     = "map" "[" KeyType "]" ElementType .
KeyType     = Type .

/* é€šé“ç±»å‹ */
ChannelType = ( "chan" | "chan" "<-" | "<-" "chan" ) ElementType .
```

#### 1.1.3 è¡¨è¾¾å¼å®šä¹‰

```ebnf
Expression    = UnaryExpr | Expression binary_op Expression .
UnaryExpr     = PrimaryExpr | unary_op UnaryExpr .
PrimaryExpr   = Operand | Conversion | MethodExpr | 
                PrimaryExpr Selector | PrimaryExpr Index |
                PrimaryExpr Slice | PrimaryExpr TypeAssertion |
                PrimaryExpr Arguments .

Operand       = Literal | OperandName [ TypeArgs ] | "(" Expression ")" .
Literal       = BasicLit | CompositeLit | FunctionLit .
BasicLit      = int_lit | float_lit | imaginary_lit | rune_lit | string_lit .
OperandName   = identifier | QualifiedIdent .

/* äºŒå…ƒæ“ä½œç¬¦ä¼˜å…ˆçº§ */
binary_op  = "||" |                             /* ä¼˜å…ˆçº§1 */
             "&&" |                             /* ä¼˜å…ˆçº§2 */
             rel_op |                           /* ä¼˜å…ˆçº§3 */
             add_op |                           /* ä¼˜å…ˆçº§4 */
             mul_op .                           /* ä¼˜å…ˆçº§5 */
rel_op     = "==" | "!=" | "<" | "<=" | ">" | ">=" .
add_op     = "+" | "-" | "|" | "^" .
mul_op     = "*" | "/" | "%" | "<<" | ">>" | "&" | "&^" .
unary_op   = "+" | "-" | "!" | "^" | "*" | "&" | "<-" .
```

#### 1.1.4 è¯­å¥å®šä¹‰

```ebnf
Statement =
    Declaration | LabeledStmt | SimpleStmt |
    GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
    FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
    DeferStmt .

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .

/* æ§åˆ¶æµè¯­å¥ */
IfStmt = "if" [ SimpleStmt ";" ] Expression Block [ "else" ( IfStmt | Block ) ] .

SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .
ExprSwitchStmt = "switch" [ SimpleStmt ";" ] [ Expression ] "{" { ExprCaseClause } "}" .
ExprCaseClause = ExprSwitchCase ":" StatementList .
ExprSwitchCase = "case" ExpressionList | "default" .

ForStmt = "for" [ Condition | ForClause | RangeClause ] Block .
ForClause = [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ] .
RangeClause = [ ExpressionList "=" | IdentifierList ":=" ] "range" Expression .

/* å¹¶å‘è¯­å¥ */
GoStmt = "go" Expression .
SelectStmt = "select" "{" { CommClause } "}" .
CommClause = CommCase ":" StatementList .
CommCase   = "case" ( SendStmt | RecvStmt ) | "default" .
SendStmt   = Channel "<-" Expression .
RecvStmt   = [ ExpressionList "=" | IdentifierList ":=" ] RecvExpr .
RecvExpr   = Expression .
```

---

### 1.2 æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰

Goè¯­è¨€çš„æŠ½è±¡è¯­æ³•æ ‘é‡‡ç”¨ä»£æ•°æ•°æ®ç±»å‹ï¼ˆADTï¼‰è¡¨ç¤ºï¼š

```mathematical
/* è¡¨è¾¾å¼AST */
Expr ::= Const(value: Value)
       | Var(name: Identifier)
       | BinOp(op: BinaryOp, left: Expr, right: Expr)
       | UnOp(op: UnaryOp, expr: Expr)
       | Call(func: Expr, args: List[Expr])
       | Index(array: Expr, index: Expr)
       | Selector(expr: Expr, field: Identifier)
       | TypeAssert(expr: Expr, type: Type)
       | Channel(op: ChanOp, expr: Expr)
       | Lambda(params: List[Param], body: Stmt)

/* è¯­å¥AST */
Stmt ::= Assign(lhs: List[Expr], rhs: List[Expr])
       | VarDecl(vars: List[Var], init: List[Expr])
       | If(cond: Expr, then: Stmt, else: Stmt)
       | For(init: Stmt, cond: Expr, post: Stmt, body: Stmt)
       | Range(vars: List[Var], expr: Expr, body: Stmt)
       | Return(exprs: List[Expr])
       | Go(expr: Expr)
       | Defer(expr: Expr)
       | Select(cases: List[CommCase])
       | Block(stmts: List[Stmt])

/* ç±»å‹AST */
Type ::= Basic(kind: BasicKind)
       | Array(length: Int, elem: Type)
       | Slice(elem: Type)
       | Struct(fields: List[Field])
       | Pointer(base: Type)
       | Function(params: List[Type], results: List[Type])
       | Interface(methods: List[Method])
       | Map(key: Type, value: Type)
       | Channel(dir: Direction, elem: Type)
       | TypeParam(name: Identifier, constraint: Type)
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šæ“ä½œè¯­ä¹‰ä¸æŒ‡ç§°è¯­ä¹‰

### 2.1 å°æ­¥æ“ä½œè¯­ä¹‰ï¼ˆSmall-Step Operational Semanticsï¼‰

Goè¯­è¨€çš„æ‰§è¡Œå¯ä»¥é€šè¿‡å°æ­¥è¯­ä¹‰è¿›è¡Œå½¢å¼åŒ–ï¼š

#### 2.1.1 è¯­ä¹‰é…ç½®

```mathematical
âŸ¨Stmt, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨Stmt', Ïƒ', Î¼', Ï'âŸ©

å…¶ä¸­ï¼š
- Stmt: å½“å‰è¯­å¥
- Ïƒ: å˜é‡ç¯å¢ƒ (Var â†’ Value)
- Î¼: å †å†…å­˜ (Address â†’ Value)
- Ï: Goroutineä¸Šä¸‹æ–‡ (GoroutineID â†’ State)
```

#### 2.1.2 è¡¨è¾¾å¼æ±‚å€¼è§„åˆ™

```mathematical
/* å˜é‡æŸ¥æ‰¾ */
[E-Var]
Ïƒ(x) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨x, Ïƒ, Î¼âŸ© â†’ âŸ¨v, Ïƒ, Î¼âŸ©

/* äºŒå…ƒæ“ä½œ */
[E-BinOp]
âŸ¨eâ‚, Ïƒ, Î¼âŸ© â†’ âŸ¨vâ‚, Ïƒ', Î¼'âŸ©    âŸ¨eâ‚‚, Ïƒ', Î¼'âŸ© â†’ âŸ¨vâ‚‚, Ïƒ'', Î¼''âŸ©    v = eval(op, vâ‚, vâ‚‚)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨eâ‚ op eâ‚‚, Ïƒ, Î¼âŸ© â†’ âŸ¨v, Ïƒ'', Î¼''âŸ©

/* å‡½æ•°è°ƒç”¨ */
[E-Call]
âŸ¨f, Ïƒ, Î¼âŸ© â†’ âŸ¨func(params){body}, Ïƒ', Î¼'âŸ©
âŸ¨args, Ïƒ', Î¼'âŸ© â†’ âŸ¨vals, Ïƒ'', Î¼''âŸ©
Ïƒ''' = Ïƒ'' âŠ• {params â†¦ vals}
âŸ¨body, Ïƒ''', Î¼''âŸ© â†’ âŸ¨v, Ïƒâ½â´â¾, Î¼â½â´â¾âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨f(args), Ïƒ, Î¼âŸ© â†’ âŸ¨v, Ïƒâ½â´â¾, Î¼â½â´â¾âŸ©

/* Channelæ“ä½œ */
[E-Send]
âŸ¨ch, Ïƒ, Î¼âŸ© â†’ âŸ¨c, Ïƒ', Î¼'âŸ©
âŸ¨v, Ïƒ', Î¼'âŸ© â†’ âŸ¨val, Ïƒ'', Î¼''âŸ©
Î¼''' = Î¼''[c.buffer â† Î¼''(c.buffer) âŠ• val]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ch <- v, Ïƒ, Î¼âŸ© â†’ âŸ¨(), Ïƒ'', Î¼'''âŸ©

[E-Recv]
âŸ¨ch, Ïƒ, Î¼âŸ© â†’ âŸ¨c, Ïƒ', Î¼'âŸ©
Î¼'(c.buffer) = val :: rest
Î¼'' = Î¼'[c.buffer â† rest]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨<-ch, Ïƒ, Î¼âŸ© â†’ âŸ¨val, Ïƒ', Î¼''âŸ©
```

#### 2.1.3 è¯­å¥æ‰§è¡Œè§„åˆ™

```mathematical
/* èµ‹å€¼è¯­å¥ */
[S-Assign]
âŸ¨e, Ïƒ, Î¼âŸ© â†’ âŸ¨v, Ïƒ', Î¼'âŸ©
Ïƒ'' = Ïƒ'[x â†¦ v]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨x = e, Ïƒ, Î¼âŸ© â†’ âŸ¨(), Ïƒ'', Î¼'âŸ©

/* Ifè¯­å¥ */
[S-If-True]
âŸ¨cond, Ïƒ, Î¼âŸ© â†’ âŸ¨true, Ïƒ', Î¼'âŸ©
âŸ¨then, Ïƒ', Î¼'âŸ© â†’ âŸ¨(), Ïƒ'', Î¼''âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨if cond {then} else {els}, Ïƒ, Î¼âŸ© â†’ âŸ¨(), Ïƒ'', Î¼''âŸ©

[S-If-False]
âŸ¨cond, Ïƒ, Î¼âŸ© â†’ âŸ¨false, Ïƒ', Î¼'âŸ©
âŸ¨els, Ïƒ', Î¼'âŸ© â†’ âŸ¨(), Ïƒ'', Î¼''âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨if cond {then} else {els}, Ïƒ, Î¼âŸ© â†’ âŸ¨(), Ïƒ'', Î¼''âŸ©

/* Forå¾ªç¯ */
[S-For]
âŸ¨cond, Ïƒ, Î¼âŸ© â†’ âŸ¨true, Ïƒ', Î¼'âŸ©
âŸ¨body, Ïƒ', Î¼'âŸ© â†’ âŸ¨(), Ïƒ'', Î¼''âŸ©
âŸ¨for cond {body}, Ïƒ'', Î¼''âŸ© â†’ âŸ¨(), Ïƒ''', Î¼'''âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨for cond {body}, Ïƒ, Î¼âŸ© â†’ âŸ¨(), Ïƒ''', Î¼'''âŸ©

/* Goroutineå¯åŠ¨ */
[S-Go]
Ï' = Ï âŠ• {fresh_gid â†¦ (expr, Ïƒ, Î¼)}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨go expr, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨(), Ïƒ, Î¼, Ï'âŸ©
```

---

### 2.2 æŒ‡ç§°è¯­ä¹‰ï¼ˆDenotational Semanticsï¼‰

Goè¯­è¨€çš„æŒ‡ç§°è¯­ä¹‰å°†ç¨‹åºæ˜ å°„åˆ°æ•°å­¦å¯¹è±¡ï¼š

#### 2.2.1 è¯­ä¹‰åŸŸï¼ˆSemantic Domainsï¼‰

```mathematical
/* åŸºæœ¬åŸŸ */
Value  = Int âˆª Float âˆª String âˆª Bool âˆª Pointer âˆª Channel âˆª Interface
Env    = Var â†’ Value
Store  = Address â†’ Value
Cont   = Value â†’ Answer
Answer = Value âˆª Error

/* ç±»å‹åŸŸ */
TypeEnv = Var â†’ Type
TypeValue = Type â†’ Set[Value]

/* å‡½æ•°åŸŸ */
FuncValue = (List[Value] Ã— Env Ã— Store Ã— Cont) â†’ Answer
```

#### 2.2.2 è¡¨è¾¾å¼æŒ‡ç§°

```mathematical
EâŸ¦_âŸ§ : Expr â†’ (Env Ã— Store Ã— Cont) â†’ Answer

EâŸ¦nâŸ§Ï store Îº = Îº(n)
EâŸ¦xâŸ§Ï store Îº = Îº(Ï(x))
EâŸ¦eâ‚ op eâ‚‚âŸ§Ï store Îº = 
    EâŸ¦eâ‚âŸ§Ï store (Î»vâ‚. 
        EâŸ¦eâ‚‚âŸ§Ï store (Î»vâ‚‚. 
            Îº(eval_op(op, vâ‚, vâ‚‚))))

EâŸ¦f(args)âŸ§Ï store Îº = 
    EâŸ¦fâŸ§Ï store (Î»func.
        eval_argsâŸ¦argsâŸ§Ï store (Î»vals.
            func(vals, Ï, store, Îº)))

EâŸ¦&xâŸ§Ï store Îº = Îº(addr_of(Ï, x))
EâŸ¦*pâŸ§Ï store Îº = 
    EâŸ¦pâŸ§Ï store (Î»ptr.
        Îº(store(ptr)))
```

#### 2.2.3 è¯­å¥æŒ‡ç§°

```mathematical
SâŸ¦_âŸ§ : Stmt â†’ (Env Ã— Store Ã— Cont) â†’ Answer

SâŸ¦x = eâŸ§Ï store Îº = 
    EâŸ¦eâŸ§Ï store (Î»v.
        Îº((), Ï[x â†¦ v], store))

SâŸ¦if cond {then} else {els}âŸ§Ï store Îº = 
    EâŸ¦condâŸ§Ï store (Î»v.
        if v then 
            SâŸ¦thenâŸ§Ï store Îº
        else 
            SâŸ¦elsâŸ§Ï store Îº)

SâŸ¦for cond {body}âŸ§Ï store Îº = 
    fix (Î»loop.
        EâŸ¦condâŸ§Ï store (Î»v.
            if v then
                SâŸ¦bodyâŸ§Ï store (Î»_.
                    loop Ï store Îº)
            else
                Îº((), Ï, store)))

SâŸ¦return eâŸ§Ï store Îº = 
    EâŸ¦eâŸ§Ï store (Î»v.
        throw_return(v))
```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šç±»å‹ç³»ç»Ÿå½¢å¼åŒ–

### 3.1 ç±»å‹åˆ¤æ–­è§„åˆ™

Goè¯­è¨€çš„ç±»å‹ç³»ç»Ÿé‡‡ç”¨Hindley-Milneré£æ ¼çš„ç±»å‹æ¨å¯¼ï¼š

#### 3.1.1 ç±»å‹ç¯å¢ƒ

```mathematical
Î“ ::= âˆ…                    /* ç©ºç¯å¢ƒ */
    | Î“, x : T             /* å˜é‡ç»‘å®š */
    | Î“, Î±                 /* ç±»å‹å˜é‡ */
    | Î“, Tâ‚ <: Tâ‚‚          /* å­ç±»å‹å…³ç³» */
```

#### 3.1.2 ç±»å‹åˆ¤æ–­

```mathematical
/* åŸºæœ¬ç±»å‹ */
[T-Const]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ n : int

[T-Var]
(x : T) âˆˆ Î“
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ x : T

/* å‡½æ•°ç±»å‹ */
[T-Func]
Î“, xâ‚:Tâ‚, ..., xâ‚™:Tâ‚™ âŠ¢ body : Táµ£
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ func(xâ‚ Tâ‚, ..., xâ‚™ Tâ‚™) Táµ£ {body} : Tâ‚ Ã— ... Ã— Tâ‚™ â†’ Táµ£

[T-App]
Î“ âŠ¢ f : Tâ‚ Ã— ... Ã— Tâ‚™ â†’ Táµ£
Î“ âŠ¢ eâ‚ : Tâ‚  ...  Î“ âŠ¢ eâ‚™ : Tâ‚™
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ f(eâ‚, ..., eâ‚™) : Táµ£

/* æŒ‡é’ˆç±»å‹ */
[T-Ref]
Î“ âŠ¢ x : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ &x : *T

[T-Deref]
Î“ âŠ¢ p : *T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ *p : T

/* æ¥å£ç±»å‹ */
[T-Interface]
Î“ âŠ¢ v : T
T implements Interface I
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ v : I

/* Channelç±»å‹ */
[T-MakeChan]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ make(chan T) : chan T

[T-Send]
Î“ âŠ¢ ch : chan T
Î“ âŠ¢ v : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ch <- v : ()

[T-Recv]
Î“ âŠ¢ ch : chan T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ <-ch : T
```

#### 3.1.3 æ³›å‹ç±»å‹çº¦æŸ

```mathematical
/* ç±»å‹å‚æ•° */
[T-TypeParam]
Î± âˆˆ Î“
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Î± : Type

/* æ³›å‹å‡½æ•° */
[T-Generic]
Î“, [Tâ‚, ..., Tâ‚™ constraints C] âŠ¢ body : Táµ£
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ func[Tâ‚, ..., Tâ‚™ C](params) Táµ£ {body} : âˆ€Tâ‚...Tâ‚™.C â‡’ Params â†’ Táµ£

/* ç±»å‹å®ä¾‹åŒ– */
[T-Instantiate]
Î“ âŠ¢ f : âˆ€T.C â‡’ T â†’ Táµ£
Î“ âŠ¢ S : Type
S satisfies C
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ f[S] : S â†’ Táµ£[T := S]

/* Go 1.18+ ç±»å‹çº¦æŸ */
[T-Constraint]
Î“ âŠ¢ T : Type
T satisfies interface{ ~underlying | type_union }
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : Constraint
```

---

### 3.2 ç±»å‹å®‰å…¨æ€§è¯æ˜

#### 3.2.1 è¿›å±•å®šç†ï¼ˆProgressï¼‰

```mathematical
å®šç†ï¼ˆProgressï¼‰:
å¦‚æœ âŠ¢ e : T ä¸” e ä¸æ˜¯å€¼ï¼Œåˆ™å­˜åœ¨ e' ä½¿å¾— e â†’ e'ã€‚

è¯æ˜ï¼š
å¯¹ e çš„ç»“æ„è¿›è¡Œå½’çº³ï¼š
1. e = nï¼ˆå¸¸é‡ï¼‰ï¼še æ˜¯å€¼ï¼Œä¸é€‚ç”¨
2. e = xï¼ˆå˜é‡ï¼‰ï¼šç”±ç±»å‹ç¯å¢ƒä¿è¯ï¼Œä¸ä¼šå‡ºç°æœªç»‘å®šå˜é‡
3. e = eâ‚ op eâ‚‚ï¼š
   - å½’çº³å‡è®¾ï¼šeâ‚ â†’ eâ‚' æˆ– eâ‚ æ˜¯å€¼
   - å½’çº³å‡è®¾ï¼šeâ‚‚ â†’ eâ‚‚' æˆ– eâ‚‚ æ˜¯å€¼
   - å¦‚æœ eâ‚ ä¸æ˜¯å€¼ï¼Œåˆ™ e â†’ eâ‚' op eâ‚‚
   - å¦‚æœ eâ‚ æ˜¯å€¼ä½† eâ‚‚ ä¸æ˜¯ï¼Œåˆ™ e â†’ eâ‚ op eâ‚‚'
   - å¦‚æœ eâ‚ å’Œ eâ‚‚ éƒ½æ˜¯å€¼ï¼Œåˆ™ e â†’ eval(op, eâ‚, eâ‚‚)
4. e = f(args)ï¼šç±»ä¼¼è¯æ˜
```

#### 3.2.2 ä¿æŒå®šç†ï¼ˆPreservationï¼‰

```mathematical
å®šç†ï¼ˆPreservationï¼‰:
å¦‚æœ Î“ âŠ¢ e : T ä¸” e â†’ e'ï¼Œåˆ™ Î“ âŠ¢ e' : Tã€‚

è¯æ˜ï¼š
å¯¹ e â†’ e' çš„æ¨å¯¼è§„åˆ™è¿›è¡Œå½’çº³ï¼š
1. [E-BinOp]: 
   - å‰æï¼šÎ“ âŠ¢ eâ‚ : Tâ‚, Î“ âŠ¢ eâ‚‚ : Tâ‚‚, op : Tâ‚ Ã— Tâ‚‚ â†’ T
   - å½’çº³å‡è®¾ï¼šå¦‚æœ eâ‚ â†’ eâ‚'ï¼Œåˆ™ Î“ âŠ¢ eâ‚' : Tâ‚
   - å½’çº³å‡è®¾ï¼šå¦‚æœ eâ‚‚ â†’ eâ‚‚'ï¼Œåˆ™ Î“ âŠ¢ eâ‚‚' : Tâ‚‚
   - ç»“è®ºï¼šÎ“ âŠ¢ eâ‚' op eâ‚‚ : T
2. [E-Call]:
   - å‰æï¼šÎ“ âŠ¢ f : Tâ‚ Ã— ... Ã— Tâ‚™ â†’ Táµ£
   - å‰æï¼šÎ“ âŠ¢ args : Tâ‚ Ã— ... Ã— Tâ‚™
   - ç»“è®ºï¼šÎ“ âŠ¢ f(args) : Táµ£
```

---

## ç¬¬å››éƒ¨åˆ†ï¼šCSPå¹¶å‘æ¨¡å‹å½¢å¼åŒ–

### 4.1 è¿›ç¨‹ä»£æ•°è¡¨ç¤º

Goçš„å¹¶å‘æ¨¡å‹åŸºäºCSPï¼ˆCommunicating Sequential Processesï¼‰ï¼Œå¯ä»¥ç”¨è¿›ç¨‹ä»£æ•°å½¢å¼åŒ–ï¼š

#### 4.1.1 CSPè¿›ç¨‹å®šä¹‰

```mathematical
/* è¿›ç¨‹è¯­æ³• */
P ::= STOP                 /* ç»ˆæ­¢è¿›ç¨‹ */
    | SKIP                 /* ç©ºæ“ä½œ */
    | a â†’ P                /* å‰ç¼€æ“ä½œ */
    | P â–¡ Q                /* å¤–éƒ¨é€‰æ‹© */
    | P âŠ“ Q                /* å†…éƒ¨é€‰æ‹© */
    | P ||| Q              /* äº¤é”™å¹¶è¡Œ */
    | P || Q               /* åŒæ­¥å¹¶è¡Œ */
    | P \ A                /* éšè— */
    | P [a/b]              /* é‡å‘½å */
    | Î¼X. P                /* é€’å½’ */

/* Goå¹¶å‘åŸè¯­æ˜ å°„ */
go f()      â‰¡ f() ||| P
ch <- v     â‰¡ send(ch, v) â†’ P
v := <-ch   â‰¡ recv(ch, v) â†’ P
select {..} â‰¡ (câ‚ â†’ Pâ‚) â–¡ (câ‚‚ â†’ Pâ‚‚) â–¡ ...
```

#### 4.1.2 Goroutineè¯­ä¹‰

```mathematical
/* GoroutineçŠ¶æ€æœº */
State_G ::= Running(Ïƒ, pc)      /* è¿è¡Œä¸­ */
          | Blocked(ch, op)     /* é˜»å¡åœ¨channelæ“ä½œ */
          | Ready               /* å°±ç»ª */
          | Terminated          /* ç»ˆæ­¢ */

/* Goroutineè½¬æ¢è§„åˆ™ */
[G-Spawn]
âŸ¨go f(), Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨(), Ïƒ, Î¼, Ï âŠ• {g_new â†¦ Ready}âŸ©

[G-Send]
âŸ¨ch <- v, Ïƒ, Î¼, ÏâŸ© â†’ 
    if channel_has_space(Î¼(ch)) then
        âŸ¨(), Ïƒ, Î¼[ch.buffer â† Î¼(ch.buffer) âŠ• v], ÏâŸ©
    else
        âŸ¨(), Ïƒ, Î¼, Ï[g_current â†¦ Blocked(ch, Send(v))]âŸ©

[G-Recv]
âŸ¨v := <-ch, Ïƒ, Î¼, ÏâŸ© â†’ 
    if channel_has_data(Î¼(ch)) then
        let val = head(Î¼(ch.buffer)) in
        âŸ¨(), Ïƒ[v â†¦ val], Î¼[ch.buffer â† tail(Î¼(ch.buffer))], ÏâŸ©
    else
        âŸ¨(), Ïƒ, Î¼, Ï[g_current â†¦ Blocked(ch, Recv)]âŸ©
```

#### 4.1.3 ChannelåŒæ­¥è¯­ä¹‰

```mathematical
/* Channelæ“ä½œçš„åŒæ­¥è¯­ä¹‰ */
SyncOp ::= Send(ch: Channel, val: Value)
         | Recv(ch: Channel)

/* åŒ¹é…è§„åˆ™ */
[Sync-Match]
Gâ‚ = Blocked(ch, Send(v))
Gâ‚‚ = Blocked(ch, Recv)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Ï[Gâ‚ â†¦ Ready, Gâ‚‚ â†¦ Ready], Î¼âŸ© â†’ 
âŸ¨Ï, Î¼[ch â†¦ transfer(v, Gâ‚, Gâ‚‚)]âŸ©

/* Buffered Channel */
[Buf-Send]
|Î¼(ch.buffer)| < ch.capacity
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨G: ch <- v, Î¼âŸ© â†’ âŸ¨G: Ready, Î¼[ch.buffer â† Î¼(ch.buffer) âŠ• v]âŸ©

[Buf-Recv]
|Î¼(ch.buffer)| > 0
val = head(Î¼(ch.buffer))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨G: <-ch, Î¼âŸ© â†’ âŸ¨G: Ready(val), Î¼[ch.buffer â† tail(Î¼(ch.buffer))]âŸ©
```

#### 4.1.4 Selectè¯­å¥å½¢å¼åŒ–

```mathematical
/* Selectè¯­ä¹‰ */
SelectCase ::= Send(ch, val, cont)
             | Recv(ch, var, cont)
             | Default(cont)

[Select-Ready]
âˆƒ case âˆˆ cases. is_ready(case, Î¼)
case' = select_ready_case(cases, Î¼)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨select{cases}, Ïƒ, Î¼, ÏâŸ© â†’ execute_case(case', Ïƒ, Î¼, Ï)

[Select-Block]
âˆ€ case âˆˆ cases. Â¬is_ready(case, Î¼) âˆ§ Â¬has_default(cases)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨select{cases}, Ïƒ, Î¼, ÏâŸ© â†’ 
âŸ¨(), Ïƒ, Î¼, Ï[g_current â†¦ Blocked(cases)]âŸ©

[Select-Default]
âˆ€ case âˆˆ send_recv_cases. Â¬is_ready(case, Î¼) âˆ§ has_default(cases)
default_case = get_default(cases)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨select{cases}, Ïƒ, Î¼, ÏâŸ© â†’ execute_case(default_case, Ïƒ, Î¼, Ï)
```

---

### 4.2 Happens-Beforeå…³ç³»

```mathematical
/* Happens-Beforeå®šä¹‰ */
HB âŠ† Event Ã— Event

/* è§„åˆ™ */
[HB-PO]  /* Program Order */
eâ‚ < eâ‚‚ in same goroutine
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ HB eâ‚‚

[HB-Sync]  /* Synchronization */
eâ‚ = send(ch, v) âˆ§ eâ‚‚ = recv(ch, v)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ HB eâ‚‚

[HB-Trans]  /* Transitivity */
eâ‚ HB eâ‚‚ âˆ§ eâ‚‚ HB eâ‚ƒ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ HB eâ‚ƒ

[HB-Go]  /* Goroutine Creation */
eâ‚ = go f() âˆ§ eâ‚‚ = first_event(f)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ HB eâ‚‚

[HB-Close]  /* Channel Close */
eâ‚ = close(ch) âˆ§ eâ‚‚ = recv_from_closed(ch)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ HB eâ‚‚
```

---

## ç¬¬äº”éƒ¨åˆ†ï¼šæ§åˆ¶æµå½¢å¼åŒ–

### 5.1 æ§åˆ¶æµå›¾ï¼ˆCFGï¼‰

```mathematical
CFG = (N, E, n_entry, n_exit)

å…¶ä¸­ï¼š
- N: èŠ‚ç‚¹é›†åˆï¼ˆåŸºæœ¬å—ï¼‰
- E âŠ† N Ã— N: è¾¹é›†åˆï¼ˆæ§åˆ¶æµï¼‰
- n_entry: å…¥å£èŠ‚ç‚¹
- n_exit: å‡ºå£èŠ‚ç‚¹

/* åŸºæœ¬å—å®šä¹‰ */
BasicBlock ::= seq(stmts: List[Stmt])
             | branch(cond: Expr, true_bb: BB, false_bb: BB)
             | loop(cond: Expr, body: BB, exit: BB)
             | call(func: Expr, args: List[Expr])
             | return(vals: List[Expr])
```

### 5.2 æ”¯é…æ ‘ï¼ˆDominator Treeï¼‰

```mathematical
/* æ”¯é…å…³ç³» */
nâ‚ dom nâ‚‚ âŸº æ‰€æœ‰ä» n_entry åˆ° nâ‚‚ çš„è·¯å¾„éƒ½ç»è¿‡ nâ‚

/* ç›´æ¥æ”¯é… */
nâ‚ idom nâ‚‚ âŸº nâ‚ dom nâ‚‚ âˆ§ Â¬âˆƒnâ‚ƒ. nâ‚ dom nâ‚ƒ âˆ§ nâ‚ƒ dom nâ‚‚

/* æ”¯é…æ ‘æ„é€ ï¼ˆLengauer-Tarjanç®—æ³•ï¼‰*/
function build_dominator_tree(CFG):
    DFS(CFG) // è®¡ç®—DFSåº
    for each v in reverse_postorder:
        compute_immediate_dominator(v)
    return DomTree
```

### 5.3 æ•°æ®æµåˆ†æ

```mathematical
/* åˆ°è¾¾å®šä¹‰åˆ†æ */
ReachingDef = (KILL, GEN)

KILL[B] = {d | d åœ¨ B ä¸­è¢«é‡æ–°å®šä¹‰}
GEN[B]  = {d | d åœ¨ B ä¸­å®šä¹‰ä¸”ä¸è¢«åç»­æ€æ­»}

IN[B]  = â‹ƒ_{P âˆˆ pred(B)} OUT[P]
OUT[B] = GEN[B] âˆª (IN[B] - KILL[B])

/* æ´»è·ƒå˜é‡åˆ†æ */
LiveVar = (USE, DEF)

USE[B] = {v | v åœ¨ B ä¸­è¢«ä½¿ç”¨ä¸”æœªè¢«å®šä¹‰}
DEF[B] = {v | v åœ¨ B ä¸­è¢«å®šä¹‰}

IN[B]  = USE[B] âˆª (OUT[B] - DEF[B])
OUT[B] = â‹ƒ_{S âˆˆ succ(B)} IN[S]
```

---

## ç¬¬å…­éƒ¨åˆ†ï¼šå†…å­˜æ¨¡å‹ä¸ä¸€è‡´æ€§

### 6.1 Goå†…å­˜æ¨¡å‹å½¢å¼åŒ–

```mathematical
/* å†…å­˜æ“ä½œ */
MemOp ::= Read(addr: Address, value: Value)
        | Write(addr: Address, value: Value)
        | Lock(mutex: Mutex)
        | Unlock(mutex: Mutex)

/* å†…å­˜ä¸€è‡´æ€§å…¬ç† */
[MM-SC]  /* Sequential Consistency */
âˆ€ read r, write w. 
    r reads value from w âŸº 
    w HB r âˆ§ Â¬âˆƒw'. w HB w' âˆ§ w' HB r âˆ§ same_address(w, w', r)

[MM-Acquire]  /* Acquire Semantics */
eâ‚ = Lock(Î¼) âˆ§ eâ‚‚ occurs after eâ‚ in same goroutine
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ HB eâ‚‚

[MM-Release]  /* Release Semantics */
eâ‚ occurs before eâ‚‚ in same goroutine âˆ§ eâ‚‚ = Unlock(Î¼)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ HB eâ‚‚

[MM-Sync]  /* Mutex Synchronization */
eâ‚ = Unlock(Î¼) âˆ§ eâ‚‚ = Lock(Î¼) âˆ§ eâ‚‚ succeeds eâ‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ HB eâ‚‚
```

### 6.2 æ•°æ®ç«äº‰æ£€æµ‹

```mathematical
/* æ•°æ®ç«äº‰å®šä¹‰ */
DataRace(eâ‚, eâ‚‚) âŸº 
    same_address(eâ‚, eâ‚‚) âˆ§
    (is_write(eâ‚) âˆ¨ is_write(eâ‚‚)) âˆ§
    Â¬(eâ‚ HB eâ‚‚) âˆ§
    Â¬(eâ‚‚ HB eâ‚) âˆ§
    Â¬protected_by_same_lock(eâ‚, eâ‚‚)

/* æ•°æ®ç«äº‰è‡ªç”± */
RaceFree(P) âŸº âˆ€eâ‚, eâ‚‚ âˆˆ Execution(P). Â¬DataRace(eâ‚, eâ‚‚)
```

---

## ç¬¬ä¸ƒéƒ¨åˆ†ï¼šå½¢å¼åŒ–éªŒè¯ä¸è¯æ˜

### 7.1 éœå°”é€»è¾‘ï¼ˆHoare Logicï¼‰

```mathematical
/* éœå°”ä¸‰å…ƒç»„ */
{P} S {Q}

è¡¨ç¤ºï¼šå¦‚æœå‰ç½®æ¡ä»¶Pæˆç«‹ï¼Œæ‰§è¡Œè¯­å¥Såï¼Œåç½®æ¡ä»¶Qæˆç«‹

/* æ¨å¯¼è§„åˆ™ */
[H-Skip]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{P} skip {P}

[H-Assign]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{P[e/x]} x = e {P}

[H-Seq]
{P} Sâ‚ {Q}    {Q} Sâ‚‚ {R}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{P} Sâ‚; Sâ‚‚ {R}

[H-If]
{P âˆ§ b} Sâ‚ {Q}    {P âˆ§ Â¬b} Sâ‚‚ {Q}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{P} if b {Sâ‚} else {Sâ‚‚} {Q}

[H-While]
{I âˆ§ b} S {I}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{I} for b {S} {I âˆ§ Â¬b}

[H-Conseq]
P' â‡’ P    {P} S {Q}    Q â‡’ Q'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{P'} S {Q'}
```

### 7.2 å¹¶å‘ç¨‹åºéªŒè¯

```mathematical
/* å¹¶å‘éœå°”é€»è¾‘ï¼ˆConcurrent Separation Logicï¼‰*/
[CSL-Par]
{Pâ‚} Sâ‚ {Qâ‚}    {Pâ‚‚} Sâ‚‚ {Qâ‚‚}    Pâ‚ * Pâ‚‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{Pâ‚ * Pâ‚‚} Sâ‚ || Sâ‚‚ {Qâ‚ * Qâ‚‚}

/* èµ„æºä¸å˜å¼ */
[CSL-Resource]
{P * R} S {Q * R}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{P} with_lock(Î¼) {S} {Q}

å…¶ä¸­ R æ˜¯å— Î¼ ä¿æŠ¤çš„èµ„æºä¸å˜å¼

/* ChanneléªŒè¯ */
[CSL-Send]
{P * ch_inv(ch, v)} ch <- v {Q}

[CSL-Recv]
{P} v := <-ch {Q * ch_inv(ch, v)}
```

### 7.3 Goç¨‹åºéªŒè¯ç¤ºä¾‹

```mathematical
/* ç¤ºä¾‹ï¼šCounteréªŒè¯ */
type Counter struct {
    mu    sync.Mutex
    value int
}

/* ä¸å˜å¼ */
Inv(c) = âˆƒv. c.value = v âˆ§ v â‰¥ 0

/* Incrementæ–¹æ³•éªŒè¯ */
{Inv(c) * âŸ¨this = câŸ©}
func (c *Counter) Increment() {
    {Inv(c) * âŸ¨this = câŸ©}
    c.mu.Lock()
    {Inv(c) * âŸ¨this = câŸ© * Locked(c.mu)}
    c.value++
    {Inv(c') * âŸ¨this = c'âŸ© * Locked(c'.mu) where c'.value = c.value + 1}
    c.mu.Unlock()
    {Inv(c') * âŸ¨this = c'âŸ©}
}
{Inv(c') * âŸ¨this = c'âŸ©}

/* è¯æ˜ï¼š
1. Lockåè·å¾—èµ„æºä¸å˜å¼
2. value++ä¿æŒä¸å˜å¼ï¼ˆv+1 â‰¥ 0å½“v â‰¥ 0ï¼‰
3. Unlockåé‡Šæ”¾èµ„æº
*/
```

---

## ç¬¬å…«éƒ¨åˆ†ï¼šGo 1.23æ–°ç‰¹æ€§å½¢å¼åŒ–

### 8.1 æ³›å‹è¿­ä»£å™¨ï¼ˆiter.Seqï¼‰

```mathematical
/* è¿­ä»£å™¨ç±»å‹ */
type Seq[T] = func(yield func(T) bool)
type Seq2[K, V] = func(yield func(K, V) bool)

/* è¿­ä»£å™¨è¯­ä¹‰ */
[Iter-Empty]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨iter(), yieldâŸ© â†’ âŸ¨()âŸ©

[Iter-Yield]
âŸ¨yield(v), ÎºâŸ© â†’ âŸ¨b, Îº'âŸ©
b = true â‡’ âŸ¨iter_rest(), yield, Îº'âŸ© â†’ âŸ¨(), Îº''âŸ©
b = false â‡’ âŸ¨(), Îº'âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨iter(v :: rest), yield, ÎºâŸ© â†’ âŸ¨(), Îº''âŸ©

/* Range overè¿­ä»£å™¨ */
[Range-Iter]
Î“ âŠ¢ seq : iter.Seq[T]
Î“, v:T âŠ¢ body : ()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ for v := range seq { body } : ()
```

### 8.2 Uniqueç±»å‹ï¼ˆunique.Handle[T]ï¼‰

```mathematical
/* Uniqueç±»å‹å®šä¹‰ */
unique.Handle[T] = {
    value: T,
    intern_id: InternID
}

/* äº’é”æ€§è´¨ */
[Unique-Identity]
hâ‚ = unique.Make(vâ‚)
hâ‚‚ = unique.Make(vâ‚‚)
vâ‚ = vâ‚‚ â‡’ hâ‚.intern_id = hâ‚‚.intern_id
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
unique_eq(hâ‚, hâ‚‚) âŸº vâ‚ = vâ‚‚

/* ç±»å‹å®‰å…¨æ€§ */
[Unique-Type-Safety]
Î“ âŠ¢ v : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ unique.Make(v) : unique.Handle[T]
```

### 8.3 Testing.B.Loop()å¢å¼º

```mathematical
/* Loopæ–¹æ³•è¯­ä¹‰ */
[Benchmark-Loop]
âŸ¨b.Loop(), bodyâŸ© â†’ 
    âŸ¨for i := 0; i < b.N; i++ { body }, measure_timeâŸ©

/* æ—¶é—´æµ‹é‡ */
T(n) = measure(Î»_. loop n times body)
b.N = find_optimal_n such that T(n) âˆˆ [target_time, 2*target_time]
```

---

## ğŸ¯ æ€»ç»“

### ç†è®ºæ ¸å¿ƒè¦ç‚¹

1. **è¯­æ³•å½¢å¼åŒ–** - EBNFè§„èŒƒã€ASTä»£æ•°æ•°æ®ç±»å‹
2. **æ“ä½œè¯­ä¹‰** - å°æ­¥è¯­ä¹‰ã€å¤§æ­¥è¯­ä¹‰
3. **æŒ‡ç§°è¯­ä¹‰** - è¯­ä¹‰åŸŸã€è¿ç»­å‡½æ•°
4. **ç±»å‹ç³»ç»Ÿ** - Hindley-Milnerã€æ³›å‹çº¦æŸ
5. **CSPæ¨¡å‹** - è¿›ç¨‹ä»£æ•°ã€é€šé“åŒæ­¥
6. **å†…å­˜æ¨¡å‹** - Happens-Beforeã€æ•°æ®ç«äº‰
7. **å½¢å¼åŒ–éªŒè¯** - éœå°”é€»è¾‘ã€å¹¶å‘éªŒè¯

### å½¢å¼åŒ–æ–¹æ³•ä½“ç³»

```text
è¯­æ³•å±‚æ¬¡ï¼š
  EBNF â†’ AST â†’ è¯­æ³•æ ‘

è¯­ä¹‰å±‚æ¬¡ï¼š
  æ“ä½œè¯­ä¹‰ï¼ˆæ‰§è¡Œè§„åˆ™ï¼‰
  æŒ‡ç§°è¯­ä¹‰ï¼ˆæ•°å­¦å¯¹è±¡ï¼‰
  å…¬ç†è¯­ä¹‰ï¼ˆéœå°”é€»è¾‘ï¼‰

ç±»å‹å±‚æ¬¡ï¼š
  ç±»å‹åˆ¤æ–­ â†’ ç±»å‹æ¨å¯¼ â†’ ç±»å‹æ£€æŸ¥

å¹¶å‘å±‚æ¬¡ï¼š
  CSPè¿›ç¨‹ä»£æ•° â†’ Goroutineè¯­ä¹‰ â†’ åŒæ­¥åŸè¯­

éªŒè¯å±‚æ¬¡ï¼š
  è¿›å±•å®šç† â†’ ä¿æŒå®šç† â†’ ç±»å‹å®‰å…¨æ€§
```

### ç ”ç©¶æ–¹å‘

```text
âœ… Goè¯­è¨€çš„å®Œæ•´å½¢å¼åŒ–è¯­ä¹‰
âœ… å¹¶å‘ç¨‹åºçš„è‡ªåŠ¨åŒ–éªŒè¯
âœ… ç±»å‹ç³»ç»Ÿçš„å¯é æ€§è¯æ˜
âœ… ç¼–è¯‘å™¨æ­£ç¡®æ€§éªŒè¯
âœ… è¿è¡Œæ—¶ç³»ç»Ÿçš„å½¢å¼åŒ–æ¨¡å‹
âœ… å†…å­˜å®‰å…¨æ€§çš„æœºå™¨æ£€æŸ¥è¯æ˜
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v10.0  
**åŸºå‡†æ—¥æœŸ**: 2025å¹´10æœˆ20æ—¥  
**Goç‰ˆæœ¬**: Go 1.23.x  
**ç†è®ºåŸºç¡€**: CSP + Î»-calculus + Type Theory

<div align="center">

Made with â¤ï¸ for Go Theory Researchers

[â¬† å›åˆ°é¡¶éƒ¨](#goè¯­è¨€å½¢å¼åŒ–è¯­ä¹‰ä¸ç†è®ºåŸºç¡€)

</div>
