# Go语言错误处理

> **简介**: 深入讲解Go语言的错误处理机制，包括error接口、错误创建、错误包装和panic/recover
> **版本**: Go 1.25.3+  
> **难度**: ⭐⭐⭐  
> **标签**: #基础 #错误处理 #panic #recover

<!-- TOC START -->
- [Go语言错误处理](#go语言错误处理)
  - [📚 理论分析](#-理论分析)
    - [error接口](#error接口)
    - [错误处理哲学](#错误处理哲学)
  - [💻 代码实现](#-代码实现)
    - [基本错误处理](#基本错误处理)
    - [自定义错误类型](#自定义错误类型)
    - [错误包装与解包](#错误包装与解包)
    - [多错误处理](#多错误处理)
    - [panic和recover](#panic和recover)
  - [📊 性能分析](#-性能分析)
  - [🧪 测试代码](#-测试代码)
  - [🎯 最佳实践](#-最佳实践)
    - [1. 错误命名规范](#1-错误命名规范)
    - [2. 错误处理模式](#2-错误处理模式)
    - [3. 添加错误上下文](#3-添加错误上下文)
    - [4. panic使用场景](#4-panic使用场景)
  - [🔍 常见问题](#-常见问题)
    - [Q1: 什么时候使用panic？](#q1-什么时候使用panic)
    - [Q2: error是nil时能调用Error()方法吗？](#q2-error是nil时能调用error方法吗)
    - [Q3: errors.Is和==有什么区别？](#q3-errorsis和有什么区别)
    - [Q4: 何时使用自定义错误类型？](#q4-何时使用自定义错误类型)
  - [📚 扩展阅读](#-扩展阅读)
    - [相关概念](#相关概念)
    - [进阶主题](#进阶主题)
<!-- TOC END -->

## 📚 理论分析

### error接口

Go语言中的错误是通过内置的`error`接口表示的：

```go
type error interface {
    Error() string
}
```

特点：

- 错误是值，可以像其他值一样传递和处理
- 函数通常返回error作为最后一个返回值
- nil error表示没有错误
- 显式的错误处理（不是异常机制）

### 错误处理哲学

Go的错误处理遵循以下原则：

1. **显式优于隐式**：错误必须显式检查和处理
2. **错误是值**：可以像其他值一样操作
3. **早返回**：遇到错误立即返回
4. **错误上下文**：添加上下文信息帮助调试

## 💻 代码实现

### 基本错误处理

```go
package main

import (
    "errors"
    "fmt"
    "os"
    "strconv"
)

// 1. 使用errors.New创建错误
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

// 2. 使用fmt.Errorf格式化错误
func readFile(filename string) ([]byte, error) {
    if filename == "" {
        return nil, fmt.Errorf("filename cannot be empty")
    }
    
    data, err := os.ReadFile(filename)
    if err != nil {
        return nil, fmt.Errorf("failed to read file %s: %w", filename, err)
    }
    
    return data, nil
}

// 3. 预定义错误
var (
    ErrNotFound     = errors.New("not found")
    ErrUnauthorized = errors.New("unauthorized")
    ErrInvalidInput = errors.New("invalid input")
)

func findUser(id int) (string, error) {
    if id <= 0 {
        return "", ErrInvalidInput
    }
    
    // 模拟查找用户
    if id > 1000 {
        return "", ErrNotFound
    }
    
    return fmt.Sprintf("User%d", id), nil
}

// 4. 错误处理模式
func processData(data string) error {
    // 转换数据
    num, err := strconv.Atoi(data)
    if err != nil {
        return fmt.Errorf("invalid number format: %w", err)
    }
    
    // 验证数据
    if num < 0 {
        return errors.New("number must be positive")
    }
    
    // 处理数据
    fmt.Printf("Processed number: %d\n", num)
    return nil
}

func main() {
    // 基本错误处理
    result, err := divide(10, 2)
    if err != nil {
        fmt.Printf("Error: %v\n", err)
        return
    }
    fmt.Printf("Result: %.2f\n", result)
    
    // 错误处理
    _, err = divide(10, 0)
    if err != nil {
        fmt.Printf("Expected error: %v\n", err)
    }
    
    // 预定义错误检查
    _, err = findUser(-1)
    if err == ErrInvalidInput {
        fmt.Println("Invalid input provided")
    }
    
    // 错误处理链
    if err := processData("abc"); err != nil {
        fmt.Printf("Process error: %v\n", err)
    }
}
```

### 自定义错误类型

```go
package main

import (
    "fmt"
)

// 1. 简单自定义错误
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error on field '%s': %s", e.Field, e.Message)
}

// 2. 带状态码的错误
type HTTPError struct {
    Code    int
    Message string
}

func (e *HTTPError) Error() string {
    return fmt.Sprintf("HTTP %d: %s", e.Code, e.Message)
}

// 3. 包含原因的错误
type DatabaseError struct {
    Operation string
    Err       error
}

func (e *DatabaseError) Error() string {
    return fmt.Sprintf("database %s failed: %v", e.Operation, e.Err)
}

func (e *DatabaseError) Unwrap() error {
    return e.Err
}

// 4. 多字段错误
type UserError struct {
    Username string
    Email    string
    Reason   string
}

func (e *UserError) Error() string {
    return fmt.Sprintf("user error for %s (%s): %s", e.Username, e.Email, e.Reason)
}

// 使用自定义错误
func validateUser(username, email string) error {
    if username == "" {
        return &ValidationError{
            Field:   "username",
            Message: "cannot be empty",
        }
    }
    
    if email == "" {
        return &ValidationError{
            Field:   "email",
            Message: "cannot be empty",
        }
    }
    
    return nil
}

func fetchData(id int) error {
    if id <= 0 {
        return &HTTPError{
            Code:    400,
            Message: "Invalid ID",
        }
    }
    
    if id > 1000 {
        return &HTTPError{
            Code:    404,
            Message: "Not Found",
        }
    }
    
    return nil
}

func main() {
    // 处理自定义错误
    err := validateUser("", "user@example.com")
    if err != nil {
        if ve, ok := err.(*ValidationError); ok {
            fmt.Printf("Validation failed: field=%s, message=%s\n", ve.Field, ve.Message)
        } else {
            fmt.Printf("Error: %v\n", err)
        }
    }
    
    // 处理HTTP错误
    err = fetchData(2000)
    if err != nil {
        if he, ok := err.(*HTTPError); ok {
            fmt.Printf("HTTP Error: code=%d, message=%s\n", he.Code, he.Message)
        }
    }
}
```

### 错误包装与解包

```go
package main

import (
    "errors"
    "fmt"
)

// 模拟底层错误
var ErrDatabase = errors.New("database connection failed")

// 包装错误
func queryUser(id int) error {
    // 模拟数据库操作失败
    if id < 0 {
        return fmt.Errorf("query user failed: %w", ErrDatabase)
    }
    return nil
}

func getUser(id int) error {
    err := queryUser(id)
    if err != nil {
        return fmt.Errorf("get user %d: %w", id, err)
    }
    return nil
}

func handleRequest(id int) error {
    err := getUser(id)
    if err != nil {
        return fmt.Errorf("handle request: %w", err)
    }
    return nil
}

func main() {
    err := handleRequest(-1)
    if err != nil {
        fmt.Printf("Error occurred: %v\n", err)
        
        // 使用errors.Is检查错误链中是否包含特定错误
        if errors.Is(err, ErrDatabase) {
            fmt.Println("Root cause: database connection failed")
        }
        
        // 使用errors.As提取特定类型的错误
        var dbErr *DatabaseError
        if errors.As(err, &dbErr) {
            fmt.Printf("Database error: %s\n", dbErr.Operation)
        }
    }
    
    // 错误链示例
    baseErr := errors.New("base error")
    wrapped1 := fmt.Errorf("wrapped 1: %w", baseErr)
    wrapped2 := fmt.Errorf("wrapped 2: %w", wrapped1)
    
    fmt.Printf("\nError chain:\n")
    fmt.Printf("Top: %v\n", wrapped2)
    fmt.Printf("Is base error: %t\n", errors.Is(wrapped2, baseErr))
    
    // 解包错误
    fmt.Printf("\nUnwrapping:\n")
    current := wrapped2
    for current != nil {
        fmt.Printf("  - %v\n", current)
        current = errors.Unwrap(current)
    }
}
```

### 多错误处理

```go
package main

import (
    "errors"
    "fmt"
)

// MultiError 多错误类型
type MultiError struct {
    Errors []error
}

func (me *MultiError) Error() string {
    if len(me.Errors) == 0 {
        return "no errors"
    }
    if len(me.Errors) == 1 {
        return me.Errors[0].Error()
    }
    return fmt.Sprintf("%d errors occurred: %v", len(me.Errors), me.Errors[0])
}

func (me *MultiError) Add(err error) {
    if err != nil {
        me.Errors = append(me.Errors, err)
    }
}

func (me *MultiError) HasErrors() bool {
    return len(me.Errors) > 0
}

// 批量处理示例
func processItems(items []string) error {
    var multiErr MultiError
    
    for i, item := range items {
        if err := processItem(item); err != nil {
            multiErr.Add(fmt.Errorf("item %d (%s): %w", i, item, err))
        }
    }
    
    if multiErr.HasErrors() {
        return &multiErr
    }
    
    return nil
}

func processItem(item string) error {
    if item == "" {
        return errors.New("item is empty")
    }
    if item == "invalid" {
        return errors.New("item is invalid")
    }
    return nil
}

func main() {
    items := []string{"valid", "", "invalid", "another"}
    
    if err := processItems(items); err != nil {
        if me, ok := err.(*MultiError); ok {
            fmt.Printf("Multiple errors occurred (%d):\n", len(me.Errors))
            for i, e := range me.Errors {
                fmt.Printf("  %d. %v\n", i+1, e)
            }
        } else {
            fmt.Printf("Error: %v\n", err)
        }
    }
}
```

### panic和recover

```go
package main

import (
    "fmt"
    "log"
)

// 1. 基本panic
func causePanic() {
    panic("something went wrong")
}

// 2. recover捕获panic
func safeFunction() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf("Recovered from panic: %v\n", r)
        }
    }()
    
    causePanic()
    fmt.Println("This will not be printed")
}

// 3. 在defer中recover
func riskyOperation(value int) (result int, err error) {
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("panic occurred: %v", r)
        }
    }()
    
    if value < 0 {
        panic("negative value not allowed")
    }
    
    result = 100 / value // 可能除零
    return result, nil
}

// 4. Web服务器中的panic恢复
func handleRequest(handler func()) {
    defer func() {
        if r := recover(); r != nil {
            log.Printf("Panic recovered: %v", r)
            // 记录堆栈信息
            // debug.PrintStack()
        }
    }()
    
    handler()
}

// 5. 有选择地重新panic
func processWithRecover() {
    defer func() {
        if r := recover(); r != nil {
            // 只恢复特定类型的panic
            if err, ok := r.(error); ok {
                fmt.Printf("Recovered error: %v\n", err)
            } else {
                // 重新panic其他类型
                panic(r)
            }
        }
    }()
    
    panic(fmt.Errorf("recoverable error"))
}

func main() {
    // 1. 基本recover
    fmt.Println("Testing safe function:")
    safeFunction()
    fmt.Println("Program continues after recovery")
    
    // 2. recover返回错误
    fmt.Println("\nTesting risky operation:")
    result, err := riskyOperation(-1)
    if err != nil {
        fmt.Printf("Operation failed: %v\n", err)
    } else {
        fmt.Printf("Result: %d\n", result)
    }
    
    // 3. Web服务器模拟
    fmt.Println("\nTesting request handler:")
    handleRequest(func() {
        panic("request processing failed")
    })
    fmt.Println("Server continues running")
    
    // 4. 有选择地recover
    fmt.Println("\nTesting selective recover:")
    processWithRecover()
    fmt.Println("Done")
}
```

## 📊 性能分析

```go
package main

import (
    "errors"
    "fmt"
    "testing"
)

var ErrTest = errors.New("test error")

// 基准测试：创建错误
func BenchmarkErrorsNew(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = errors.New("test error")
    }
}

func BenchmarkFmtErrorf(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = fmt.Errorf("test error: %d", i)
    }
}

// 基准测试：错误检查
func BenchmarkErrorCheck(b *testing.B) {
    err := ErrTest
    for i := 0; i < b.N; i++ {
        if err != nil {
            _ = err
        }
    }
}

// 基准测试：panic/recover
func BenchmarkPanicRecover(b *testing.B) {
    for i := 0; i < b.N; i++ {
        func() {
            defer func() {
                _ = recover()
            }()
            panic("test")
        }()
    }
}
```

## 🧪 测试代码

```go
package main

import (
    "errors"
    "testing"
)

func TestDivide(t *testing.T) {
    tests := []struct {
        name    string
        a, b    float64
        want    float64
        wantErr bool
    }{
        {"normal", 10, 2, 5, false},
        {"divide by zero", 10, 0, 0, true},
        {"negative", -10, 2, -5, false},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := divide(tt.a, tt.b)
            if (err != nil) != tt.wantErr {
                t.Errorf("divide() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if !tt.wantErr && got != tt.want {
                t.Errorf("divide() = %v, want %v", got, tt.want)
            }
        })
    }
}

func TestErrorWrapping(t *testing.T) {
    baseErr := errors.New("base error")
    wrappedErr := fmt.Errorf("wrapped: %w", baseErr)
    
    if !errors.Is(wrappedErr, baseErr) {
        t.Error("errors.Is should find base error in wrapped error")
    }
}
```

## 🎯 最佳实践

### 1. 错误命名规范

```go
// ✅ 错误变量以Err开头
var (
    ErrNotFound = errors.New("not found")
    ErrTimeout  = errors.New("timeout")
)

// ✅ 错误类型以Error结尾
type ValidationError struct {
    Field string
}
```

### 2. 错误处理模式

```go
// ✅ 早返回模式
func process() error {
    if err := step1(); err != nil {
        return fmt.Errorf("step1 failed: %w", err)
    }
    
    if err := step2(); err != nil {
        return fmt.Errorf("step2 failed: %w", err)
    }
    
    return nil
}

// ❌ 避免深层嵌套
func processBad() error {
    if err := step1(); err == nil {
        if err := step2(); err == nil {
            return nil
        } else {
            return err
        }
    } else {
        return err
    }
}
```

### 3. 添加错误上下文

```go
// ✅ 使用%w包装错误
func readConfig(filename string) error {
    data, err := os.ReadFile(filename)
    if err != nil {
        return fmt.Errorf("read config %s: %w", filename, err)
    }
    // ...
}

// ❌ 丢失错误信息
func readConfigBad(filename string) error {
    data, err := os.ReadFile(filename)
    if err != nil {
        return errors.New("failed to read config")
    }
    // ...
}
```

### 4. panic使用场景

```go
// ✅ 适合使用panic的场景:
// 1. 不可恢复的初始化错误
func init() {
    if err := loadConfig(); err != nil {
        panic(fmt.Sprintf("failed to load config: %v", err))
    }
}

// 2. 程序员错误（bug）
func process(data []int) {
    if len(data) == 0 {
        panic("data cannot be empty") // 调用者的bug
    }
}

// ❌ 不应使用panic的场景:
// 业务逻辑错误应返回error
func login(username, password string) error {
    if username == "" {
        // panic("username is empty") // 不要这样做
        return errors.New("username is empty") // 应该返回error
    }
    // ...
}
```

## 🔍 常见问题

### Q1: 什么时候使用panic？

A:

- 程序无法继续运行时（如配置文件缺失）
- 程序员错误（如违反API约定）
- 不应使用panic处理业务逻辑错误

### Q2: error是nil时能调用Error()方法吗？

A: 不能。会panic。应先检查error是否为nil。

### Q3: errors.Is和==有什么区别？

A:

- `==`：直接比较错误
- `errors.Is`：检查错误链，可以找到被包装的错误

### Q4: 何时使用自定义错误类型？

A:

- 需要携带额外信息时
- 调用者需要根据错误类型采取不同行动时
- 需要实现特殊的Error()格式时

## 📚 扩展阅读

### 相关概念

- [函数](./05-函数.md)
- [接口](./07-接口.md)
- [defer](./05-函数.md#延迟执行-defer)

### 进阶主题

- 错误处理最佳实践
- 错误设计模式
- Go 2错误处理提案
- 第三方错误处理库

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025年10月24日  
**文档状态**: ✅ 已完成  
**适用版本**: Go 1.25.3+
