# Goè¯­è¨€é”™è¯¯å¤„ç†

> **ç®€ä»‹**: æ·±å…¥è®²è§£Goè¯­è¨€çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼ŒåŒ…æ‹¬erroræ¥å£ã€é”™è¯¯åˆ›å»ºã€é”™è¯¯åŒ…è£…å’Œpanic/recover
> **ç‰ˆæœ¬**: Go 1.25.3+  
> **éš¾åº¦**: â­â­â­  
> **æ ‡ç­¾**: #åŸºç¡€ #é”™è¯¯å¤„ç† #panic #recover

<!-- TOC START -->
- [Goè¯­è¨€é”™è¯¯å¤„ç†](#goè¯­è¨€é”™è¯¯å¤„ç†)
  - [ğŸ“š ç†è®ºåˆ†æ](#-ç†è®ºåˆ†æ)
    - [erroræ¥å£](#erroræ¥å£)
    - [é”™è¯¯å¤„ç†å“²å­¦](#é”™è¯¯å¤„ç†å“²å­¦)
  - [ğŸ’» ä»£ç å®ç°](#-ä»£ç å®ç°)
    - [åŸºæœ¬é”™è¯¯å¤„ç†](#åŸºæœ¬é”™è¯¯å¤„ç†)
    - [è‡ªå®šä¹‰é”™è¯¯ç±»å‹](#è‡ªå®šä¹‰é”™è¯¯ç±»å‹)
    - [é”™è¯¯åŒ…è£…ä¸è§£åŒ…](#é”™è¯¯åŒ…è£…ä¸è§£åŒ…)
    - [å¤šé”™è¯¯å¤„ç†](#å¤šé”™è¯¯å¤„ç†)
    - [panicå’Œrecover](#panicå’Œrecover)
  - [ğŸ“Š æ€§èƒ½åˆ†æ](#-æ€§èƒ½åˆ†æ)
  - [ğŸ§ª æµ‹è¯•ä»£ç ](#-æµ‹è¯•ä»£ç )
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [1. é”™è¯¯å‘½åè§„èŒƒ](#1-é”™è¯¯å‘½åè§„èŒƒ)
    - [2. é”™è¯¯å¤„ç†æ¨¡å¼](#2-é”™è¯¯å¤„ç†æ¨¡å¼)
    - [3. æ·»åŠ é”™è¯¯ä¸Šä¸‹æ–‡](#3-æ·»åŠ é”™è¯¯ä¸Šä¸‹æ–‡)
    - [4. panicä½¿ç”¨åœºæ™¯](#4-panicä½¿ç”¨åœºæ™¯)
  - [ğŸ” å¸¸è§é—®é¢˜](#-å¸¸è§é—®é¢˜)
    - [Q1: ä»€ä¹ˆæ—¶å€™ä½¿ç”¨panicï¼Ÿ](#q1-ä»€ä¹ˆæ—¶å€™ä½¿ç”¨panic)
    - [Q2: erroræ˜¯nilæ—¶èƒ½è°ƒç”¨Error()æ–¹æ³•å—ï¼Ÿ](#q2-erroræ˜¯nilæ—¶èƒ½è°ƒç”¨erroræ–¹æ³•å—)
    - [Q3: errors.Iså’Œ==æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ](#q3-errorsiså’Œæœ‰ä»€ä¹ˆåŒºåˆ«)
    - [Q4: ä½•æ—¶ä½¿ç”¨è‡ªå®šä¹‰é”™è¯¯ç±»å‹ï¼Ÿ](#q4-ä½•æ—¶ä½¿ç”¨è‡ªå®šä¹‰é”™è¯¯ç±»å‹)
  - [ğŸ“š æ‰©å±•é˜…è¯»](#-æ‰©å±•é˜…è¯»)
    - [ç›¸å…³æ¦‚å¿µ](#ç›¸å…³æ¦‚å¿µ)
    - [è¿›é˜¶ä¸»é¢˜](#è¿›é˜¶ä¸»é¢˜)
<!-- TOC END -->

## ğŸ“š ç†è®ºåˆ†æ

### erroræ¥å£

Goè¯­è¨€ä¸­çš„é”™è¯¯æ˜¯é€šè¿‡å†…ç½®çš„`error`æ¥å£è¡¨ç¤ºçš„ï¼š

```go
type error interface {
    Error() string
}
```

ç‰¹ç‚¹ï¼š

- é”™è¯¯æ˜¯å€¼ï¼Œå¯ä»¥åƒå…¶ä»–å€¼ä¸€æ ·ä¼ é€’å’Œå¤„ç†
- å‡½æ•°é€šå¸¸è¿”å›errorä½œä¸ºæœ€åä¸€ä¸ªè¿”å›å€¼
- nil errorè¡¨ç¤ºæ²¡æœ‰é”™è¯¯
- æ˜¾å¼çš„é”™è¯¯å¤„ç†ï¼ˆä¸æ˜¯å¼‚å¸¸æœºåˆ¶ï¼‰

### é”™è¯¯å¤„ç†å“²å­¦

Goçš„é”™è¯¯å¤„ç†éµå¾ªä»¥ä¸‹åŸåˆ™ï¼š

1. **æ˜¾å¼ä¼˜äºéšå¼**ï¼šé”™è¯¯å¿…é¡»æ˜¾å¼æ£€æŸ¥å’Œå¤„ç†
2. **é”™è¯¯æ˜¯å€¼**ï¼šå¯ä»¥åƒå…¶ä»–å€¼ä¸€æ ·æ“ä½œ
3. **æ—©è¿”å›**ï¼šé‡åˆ°é”™è¯¯ç«‹å³è¿”å›
4. **é”™è¯¯ä¸Šä¸‹æ–‡**ï¼šæ·»åŠ ä¸Šä¸‹æ–‡ä¿¡æ¯å¸®åŠ©è°ƒè¯•

## ğŸ’» ä»£ç å®ç°

### åŸºæœ¬é”™è¯¯å¤„ç†

```go
package main

import (
    "errors"
    "fmt"
    "os"
    "strconv"
)

// 1. ä½¿ç”¨errors.Newåˆ›å»ºé”™è¯¯
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

// 2. ä½¿ç”¨fmt.Errorfæ ¼å¼åŒ–é”™è¯¯
func readFile(filename string) ([]byte, error) {
    if filename == "" {
        return nil, fmt.Errorf("filename cannot be empty")
    }
    
    data, err := os.ReadFile(filename)
    if err != nil {
        return nil, fmt.Errorf("failed to read file %s: %w", filename, err)
    }
    
    return data, nil
}

// 3. é¢„å®šä¹‰é”™è¯¯
var (
    ErrNotFound     = errors.New("not found")
    ErrUnauthorized = errors.New("unauthorized")
    ErrInvalidInput = errors.New("invalid input")
)

func findUser(id int) (string, error) {
    if id <= 0 {
        return "", ErrInvalidInput
    }
    
    // æ¨¡æ‹ŸæŸ¥æ‰¾ç”¨æˆ·
    if id > 1000 {
        return "", ErrNotFound
    }
    
    return fmt.Sprintf("User%d", id), nil
}

// 4. é”™è¯¯å¤„ç†æ¨¡å¼
func processData(data string) error {
    // è½¬æ¢æ•°æ®
    num, err := strconv.Atoi(data)
    if err != nil {
        return fmt.Errorf("invalid number format: %w", err)
    }
    
    // éªŒè¯æ•°æ®
    if num < 0 {
        return errors.New("number must be positive")
    }
    
    // å¤„ç†æ•°æ®
    fmt.Printf("Processed number: %d\n", num)
    return nil
}

func main() {
    // åŸºæœ¬é”™è¯¯å¤„ç†
    result, err := divide(10, 2)
    if err != nil {
        fmt.Printf("Error: %v\n", err)
        return
    }
    fmt.Printf("Result: %.2f\n", result)
    
    // é”™è¯¯å¤„ç†
    _, err = divide(10, 0)
    if err != nil {
        fmt.Printf("Expected error: %v\n", err)
    }
    
    // é¢„å®šä¹‰é”™è¯¯æ£€æŸ¥
    _, err = findUser(-1)
    if err == ErrInvalidInput {
        fmt.Println("Invalid input provided")
    }
    
    // é”™è¯¯å¤„ç†é“¾
    if err := processData("abc"); err != nil {
        fmt.Printf("Process error: %v\n", err)
    }
}
```

### è‡ªå®šä¹‰é”™è¯¯ç±»å‹

```go
package main

import (
    "fmt"
)

// 1. ç®€å•è‡ªå®šä¹‰é”™è¯¯
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error on field '%s': %s", e.Field, e.Message)
}

// 2. å¸¦çŠ¶æ€ç çš„é”™è¯¯
type HTTPError struct {
    Code    int
    Message string
}

func (e *HTTPError) Error() string {
    return fmt.Sprintf("HTTP %d: %s", e.Code, e.Message)
}

// 3. åŒ…å«åŸå› çš„é”™è¯¯
type DatabaseError struct {
    Operation string
    Err       error
}

func (e *DatabaseError) Error() string {
    return fmt.Sprintf("database %s failed: %v", e.Operation, e.Err)
}

func (e *DatabaseError) Unwrap() error {
    return e.Err
}

// 4. å¤šå­—æ®µé”™è¯¯
type UserError struct {
    Username string
    Email    string
    Reason   string
}

func (e *UserError) Error() string {
    return fmt.Sprintf("user error for %s (%s): %s", e.Username, e.Email, e.Reason)
}

// ä½¿ç”¨è‡ªå®šä¹‰é”™è¯¯
func validateUser(username, email string) error {
    if username == "" {
        return &ValidationError{
            Field:   "username",
            Message: "cannot be empty",
        }
    }
    
    if email == "" {
        return &ValidationError{
            Field:   "email",
            Message: "cannot be empty",
        }
    }
    
    return nil
}

func fetchData(id int) error {
    if id <= 0 {
        return &HTTPError{
            Code:    400,
            Message: "Invalid ID",
        }
    }
    
    if id > 1000 {
        return &HTTPError{
            Code:    404,
            Message: "Not Found",
        }
    }
    
    return nil
}

func main() {
    // å¤„ç†è‡ªå®šä¹‰é”™è¯¯
    err := validateUser("", "user@example.com")
    if err != nil {
        if ve, ok := err.(*ValidationError); ok {
            fmt.Printf("Validation failed: field=%s, message=%s\n", ve.Field, ve.Message)
        } else {
            fmt.Printf("Error: %v\n", err)
        }
    }
    
    // å¤„ç†HTTPé”™è¯¯
    err = fetchData(2000)
    if err != nil {
        if he, ok := err.(*HTTPError); ok {
            fmt.Printf("HTTP Error: code=%d, message=%s\n", he.Code, he.Message)
        }
    }
}
```

### é”™è¯¯åŒ…è£…ä¸è§£åŒ…

```go
package main

import (
    "errors"
    "fmt"
)

// æ¨¡æ‹Ÿåº•å±‚é”™è¯¯
var ErrDatabase = errors.New("database connection failed")

// åŒ…è£…é”™è¯¯
func queryUser(id int) error {
    // æ¨¡æ‹Ÿæ•°æ®åº“æ“ä½œå¤±è´¥
    if id < 0 {
        return fmt.Errorf("query user failed: %w", ErrDatabase)
    }
    return nil
}

func getUser(id int) error {
    err := queryUser(id)
    if err != nil {
        return fmt.Errorf("get user %d: %w", id, err)
    }
    return nil
}

func handleRequest(id int) error {
    err := getUser(id)
    if err != nil {
        return fmt.Errorf("handle request: %w", err)
    }
    return nil
}

func main() {
    err := handleRequest(-1)
    if err != nil {
        fmt.Printf("Error occurred: %v\n", err)
        
        // ä½¿ç”¨errors.Isæ£€æŸ¥é”™è¯¯é“¾ä¸­æ˜¯å¦åŒ…å«ç‰¹å®šé”™è¯¯
        if errors.Is(err, ErrDatabase) {
            fmt.Println("Root cause: database connection failed")
        }
        
        // ä½¿ç”¨errors.Asæå–ç‰¹å®šç±»å‹çš„é”™è¯¯
        var dbErr *DatabaseError
        if errors.As(err, &dbErr) {
            fmt.Printf("Database error: %s\n", dbErr.Operation)
        }
    }
    
    // é”™è¯¯é“¾ç¤ºä¾‹
    baseErr := errors.New("base error")
    wrapped1 := fmt.Errorf("wrapped 1: %w", baseErr)
    wrapped2 := fmt.Errorf("wrapped 2: %w", wrapped1)
    
    fmt.Printf("\nError chain:\n")
    fmt.Printf("Top: %v\n", wrapped2)
    fmt.Printf("Is base error: %t\n", errors.Is(wrapped2, baseErr))
    
    // è§£åŒ…é”™è¯¯
    fmt.Printf("\nUnwrapping:\n")
    current := wrapped2
    for current != nil {
        fmt.Printf("  - %v\n", current)
        current = errors.Unwrap(current)
    }
}
```

### å¤šé”™è¯¯å¤„ç†

```go
package main

import (
    "errors"
    "fmt"
)

// MultiError å¤šé”™è¯¯ç±»å‹
type MultiError struct {
    Errors []error
}

func (me *MultiError) Error() string {
    if len(me.Errors) == 0 {
        return "no errors"
    }
    if len(me.Errors) == 1 {
        return me.Errors[0].Error()
    }
    return fmt.Sprintf("%d errors occurred: %v", len(me.Errors), me.Errors[0])
}

func (me *MultiError) Add(err error) {
    if err != nil {
        me.Errors = append(me.Errors, err)
    }
}

func (me *MultiError) HasErrors() bool {
    return len(me.Errors) > 0
}

// æ‰¹é‡å¤„ç†ç¤ºä¾‹
func processItems(items []string) error {
    var multiErr MultiError
    
    for i, item := range items {
        if err := processItem(item); err != nil {
            multiErr.Add(fmt.Errorf("item %d (%s): %w", i, item, err))
        }
    }
    
    if multiErr.HasErrors() {
        return &multiErr
    }
    
    return nil
}

func processItem(item string) error {
    if item == "" {
        return errors.New("item is empty")
    }
    if item == "invalid" {
        return errors.New("item is invalid")
    }
    return nil
}

func main() {
    items := []string{"valid", "", "invalid", "another"}
    
    if err := processItems(items); err != nil {
        if me, ok := err.(*MultiError); ok {
            fmt.Printf("Multiple errors occurred (%d):\n", len(me.Errors))
            for i, e := range me.Errors {
                fmt.Printf("  %d. %v\n", i+1, e)
            }
        } else {
            fmt.Printf("Error: %v\n", err)
        }
    }
}
```

### panicå’Œrecover

```go
package main

import (
    "fmt"
    "log"
)

// 1. åŸºæœ¬panic
func causePanic() {
    panic("something went wrong")
}

// 2. recoveræ•è·panic
func safeFunction() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf("Recovered from panic: %v\n", r)
        }
    }()
    
    causePanic()
    fmt.Println("This will not be printed")
}

// 3. åœ¨deferä¸­recover
func riskyOperation(value int) (result int, err error) {
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("panic occurred: %v", r)
        }
    }()
    
    if value < 0 {
        panic("negative value not allowed")
    }
    
    result = 100 / value // å¯èƒ½é™¤é›¶
    return result, nil
}

// 4. WebæœåŠ¡å™¨ä¸­çš„panicæ¢å¤
func handleRequest(handler func()) {
    defer func() {
        if r := recover(); r != nil {
            log.Printf("Panic recovered: %v", r)
            // è®°å½•å †æ ˆä¿¡æ¯
            // debug.PrintStack()
        }
    }()
    
    handler()
}

// 5. æœ‰é€‰æ‹©åœ°é‡æ–°panic
func processWithRecover() {
    defer func() {
        if r := recover(); r != nil {
            // åªæ¢å¤ç‰¹å®šç±»å‹çš„panic
            if err, ok := r.(error); ok {
                fmt.Printf("Recovered error: %v\n", err)
            } else {
                // é‡æ–°panicå…¶ä»–ç±»å‹
                panic(r)
            }
        }
    }()
    
    panic(fmt.Errorf("recoverable error"))
}

func main() {
    // 1. åŸºæœ¬recover
    fmt.Println("Testing safe function:")
    safeFunction()
    fmt.Println("Program continues after recovery")
    
    // 2. recoverè¿”å›é”™è¯¯
    fmt.Println("\nTesting risky operation:")
    result, err := riskyOperation(-1)
    if err != nil {
        fmt.Printf("Operation failed: %v\n", err)
    } else {
        fmt.Printf("Result: %d\n", result)
    }
    
    // 3. WebæœåŠ¡å™¨æ¨¡æ‹Ÿ
    fmt.Println("\nTesting request handler:")
    handleRequest(func() {
        panic("request processing failed")
    })
    fmt.Println("Server continues running")
    
    // 4. æœ‰é€‰æ‹©åœ°recover
    fmt.Println("\nTesting selective recover:")
    processWithRecover()
    fmt.Println("Done")
}
```

## ğŸ“Š æ€§èƒ½åˆ†æ

```go
package main

import (
    "errors"
    "fmt"
    "testing"
)

var ErrTest = errors.New("test error")

// åŸºå‡†æµ‹è¯•ï¼šåˆ›å»ºé”™è¯¯
func BenchmarkErrorsNew(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = errors.New("test error")
    }
}

func BenchmarkFmtErrorf(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = fmt.Errorf("test error: %d", i)
    }
}

// åŸºå‡†æµ‹è¯•ï¼šé”™è¯¯æ£€æŸ¥
func BenchmarkErrorCheck(b *testing.B) {
    err := ErrTest
    for i := 0; i < b.N; i++ {
        if err != nil {
            _ = err
        }
    }
}

// åŸºå‡†æµ‹è¯•ï¼španic/recover
func BenchmarkPanicRecover(b *testing.B) {
    for i := 0; i < b.N; i++ {
        func() {
            defer func() {
                _ = recover()
            }()
            panic("test")
        }()
    }
}
```

## ğŸ§ª æµ‹è¯•ä»£ç 

```go
package main

import (
    "errors"
    "testing"
)

func TestDivide(t *testing.T) {
    tests := []struct {
        name    string
        a, b    float64
        want    float64
        wantErr bool
    }{
        {"normal", 10, 2, 5, false},
        {"divide by zero", 10, 0, 0, true},
        {"negative", -10, 2, -5, false},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := divide(tt.a, tt.b)
            if (err != nil) != tt.wantErr {
                t.Errorf("divide() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if !tt.wantErr && got != tt.want {
                t.Errorf("divide() = %v, want %v", got, tt.want)
            }
        })
    }
}

func TestErrorWrapping(t *testing.T) {
    baseErr := errors.New("base error")
    wrappedErr := fmt.Errorf("wrapped: %w", baseErr)
    
    if !errors.Is(wrappedErr, baseErr) {
        t.Error("errors.Is should find base error in wrapped error")
    }
}
```

## ğŸ¯ æœ€ä½³å®è·µ

### 1. é”™è¯¯å‘½åè§„èŒƒ

```go
// âœ… é”™è¯¯å˜é‡ä»¥Errå¼€å¤´
var (
    ErrNotFound = errors.New("not found")
    ErrTimeout  = errors.New("timeout")
)

// âœ… é”™è¯¯ç±»å‹ä»¥Errorç»“å°¾
type ValidationError struct {
    Field string
}
```

### 2. é”™è¯¯å¤„ç†æ¨¡å¼

```go
// âœ… æ—©è¿”å›æ¨¡å¼
func process() error {
    if err := step1(); err != nil {
        return fmt.Errorf("step1 failed: %w", err)
    }
    
    if err := step2(); err != nil {
        return fmt.Errorf("step2 failed: %w", err)
    }
    
    return nil
}

// âŒ é¿å…æ·±å±‚åµŒå¥—
func processBad() error {
    if err := step1(); err == nil {
        if err := step2(); err == nil {
            return nil
        } else {
            return err
        }
    } else {
        return err
    }
}
```

### 3. æ·»åŠ é”™è¯¯ä¸Šä¸‹æ–‡

```go
// âœ… ä½¿ç”¨%wåŒ…è£…é”™è¯¯
func readConfig(filename string) error {
    data, err := os.ReadFile(filename)
    if err != nil {
        return fmt.Errorf("read config %s: %w", filename, err)
    }
    // ...
}

// âŒ ä¸¢å¤±é”™è¯¯ä¿¡æ¯
func readConfigBad(filename string) error {
    data, err := os.ReadFile(filename)
    if err != nil {
        return errors.New("failed to read config")
    }
    // ...
}
```

### 4. panicä½¿ç”¨åœºæ™¯

```go
// âœ… é€‚åˆä½¿ç”¨panicçš„åœºæ™¯:
// 1. ä¸å¯æ¢å¤çš„åˆå§‹åŒ–é”™è¯¯
func init() {
    if err := loadConfig(); err != nil {
        panic(fmt.Sprintf("failed to load config: %v", err))
    }
}

// 2. ç¨‹åºå‘˜é”™è¯¯ï¼ˆbugï¼‰
func process(data []int) {
    if len(data) == 0 {
        panic("data cannot be empty") // è°ƒç”¨è€…çš„bug
    }
}

// âŒ ä¸åº”ä½¿ç”¨panicçš„åœºæ™¯:
// ä¸šåŠ¡é€»è¾‘é”™è¯¯åº”è¿”å›error
func login(username, password string) error {
    if username == "" {
        // panic("username is empty") // ä¸è¦è¿™æ ·åš
        return errors.New("username is empty") // åº”è¯¥è¿”å›error
    }
    // ...
}
```

## ğŸ” å¸¸è§é—®é¢˜

### Q1: ä»€ä¹ˆæ—¶å€™ä½¿ç”¨panicï¼Ÿ

A:

- ç¨‹åºæ— æ³•ç»§ç»­è¿è¡Œæ—¶ï¼ˆå¦‚é…ç½®æ–‡ä»¶ç¼ºå¤±ï¼‰
- ç¨‹åºå‘˜é”™è¯¯ï¼ˆå¦‚è¿åAPIçº¦å®šï¼‰
- ä¸åº”ä½¿ç”¨panicå¤„ç†ä¸šåŠ¡é€»è¾‘é”™è¯¯

### Q2: erroræ˜¯nilæ—¶èƒ½è°ƒç”¨Error()æ–¹æ³•å—ï¼Ÿ

A: ä¸èƒ½ã€‚ä¼španicã€‚åº”å…ˆæ£€æŸ¥erroræ˜¯å¦ä¸ºnilã€‚

### Q3: errors.Iså’Œ==æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

A:

- `==`ï¼šç›´æ¥æ¯”è¾ƒé”™è¯¯
- `errors.Is`ï¼šæ£€æŸ¥é”™è¯¯é“¾ï¼Œå¯ä»¥æ‰¾åˆ°è¢«åŒ…è£…çš„é”™è¯¯

### Q4: ä½•æ—¶ä½¿ç”¨è‡ªå®šä¹‰é”™è¯¯ç±»å‹ï¼Ÿ

A:

- éœ€è¦æºå¸¦é¢å¤–ä¿¡æ¯æ—¶
- è°ƒç”¨è€…éœ€è¦æ ¹æ®é”™è¯¯ç±»å‹é‡‡å–ä¸åŒè¡ŒåŠ¨æ—¶
- éœ€è¦å®ç°ç‰¹æ®Šçš„Error()æ ¼å¼æ—¶

## ğŸ“š æ‰©å±•é˜…è¯»

### ç›¸å…³æ¦‚å¿µ

- [å‡½æ•°](./05-å‡½æ•°.md)
- [æ¥å£](./07-æ¥å£.md)
- [defer](./05-å‡½æ•°.md#å»¶è¿Ÿæ‰§è¡Œ-defer)

### è¿›é˜¶ä¸»é¢˜

- é”™è¯¯å¤„ç†æœ€ä½³å®è·µ
- é”™è¯¯è®¾è®¡æ¨¡å¼
- Go 2é”™è¯¯å¤„ç†ææ¡ˆ
- ç¬¬ä¸‰æ–¹é”™è¯¯å¤„ç†åº“

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ24æ—¥  
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
