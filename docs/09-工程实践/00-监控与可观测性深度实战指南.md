# ç›‘æ§ä¸å¯è§‚æµ‹æ€§æ·±åº¦å®æˆ˜æŒ‡å—

**æ–‡æ¡£çŠ¶æ€**: âœ… æ·±åº¦é‡å†™å®Œæˆ (v18.0)  
**å­—æ•°**: ~46,000å­—  
**ä»£ç ç¤ºä¾‹**: 160+ä¸ªå®Œæ•´ç¤ºä¾‹  
**å®æˆ˜æ¡ˆä¾‹**: 17ä¸ªç«¯åˆ°ç«¯æ¡ˆä¾‹  
**é€‚ç”¨äººç¾¤**: ä¸­çº§åˆ°é«˜çº§Goå¼€å‘è€…

---

## ğŸ“š ç›®å½•

<!-- TOC -->
- [ç¬¬ä¸€éƒ¨åˆ†ï¼šå¯è§‚æµ‹æ€§æ ¸å¿ƒç†è®º](#ç¬¬ä¸€éƒ¨åˆ†å¯è§‚æµ‹æ€§æ ¸å¿ƒç†è®º)
- [ç¬¬äºŒéƒ¨åˆ†ï¼šPrometheusç›‘æ§](#ç¬¬äºŒéƒ¨åˆ†prometheusç›‘æ§)
- [ç¬¬ä¸‰éƒ¨åˆ†ï¼šGrafanaå¯è§†åŒ–](#ç¬¬ä¸‰éƒ¨åˆ†grafanaå¯è§†åŒ–)
- [ç¬¬å››éƒ¨åˆ†ï¼šOpenTelemetryè¿½è¸ª](#ç¬¬å››éƒ¨åˆ†opentelemetryè¿½è¸ª)
- [ç¬¬äº”éƒ¨åˆ†ï¼šç»“æ„åŒ–æ—¥å¿—](#ç¬¬äº”éƒ¨åˆ†ç»“æ„åŒ–æ—¥å¿—)
- [ç¬¬å…­éƒ¨åˆ†ï¼šæŒ‡æ ‡æ”¶é›†](#ç¬¬å…­éƒ¨åˆ†æŒ‡æ ‡æ”¶é›†)
- [ç¬¬ä¸ƒéƒ¨åˆ†ï¼šåˆ†å¸ƒå¼è¿½è¸ª](#ç¬¬ä¸ƒéƒ¨åˆ†åˆ†å¸ƒå¼è¿½è¸ª)
- [ç¬¬å…«éƒ¨åˆ†ï¼šæ—¥å¿—èšåˆ](#ç¬¬å…«éƒ¨åˆ†æ—¥å¿—èšåˆ)
- [ç¬¬ä¹éƒ¨åˆ†ï¼šå‘Šè­¦ç³»ç»Ÿ](#ç¬¬ä¹éƒ¨åˆ†å‘Šè­¦ç³»ç»Ÿ)
- [ç¬¬åéƒ¨åˆ†ï¼šæ€§èƒ½åˆ†æ](#ç¬¬åéƒ¨åˆ†æ€§èƒ½åˆ†æ)
- [ç¬¬åä¸€éƒ¨åˆ†ï¼šSLI/SLO/SLA](#ç¬¬åä¸€éƒ¨åˆ†slislosla)
- [ç¬¬åäºŒéƒ¨åˆ†ï¼šæ•…éšœæ’æŸ¥](#ç¬¬åäºŒéƒ¨åˆ†æ•…éšœæ’æŸ¥)
- [ç¬¬åä¸‰éƒ¨åˆ†ï¼šç›‘æ§æœ€ä½³å®è·µ](#ç¬¬åä¸‰éƒ¨åˆ†ç›‘æ§æœ€ä½³å®è·µ)
- [ç¬¬åå››éƒ¨åˆ†ï¼šå¯è§‚æµ‹æ€§å¹³å°](#ç¬¬åå››éƒ¨åˆ†å¯è§‚æµ‹æ€§å¹³å°)
- [ç¬¬åäº”éƒ¨åˆ†ï¼šå®¹å™¨ç›‘æ§](#ç¬¬åäº”éƒ¨åˆ†å®¹å™¨ç›‘æ§)
- [ç¬¬åå…­éƒ¨åˆ†ï¼šå¾®æœåŠ¡ç›‘æ§](#ç¬¬åå…­éƒ¨åˆ†å¾®æœåŠ¡ç›‘æ§)
- [ç¬¬åä¸ƒéƒ¨åˆ†ï¼šå®Œæ•´ç›‘æ§ç³»ç»Ÿ](#ç¬¬åä¸ƒéƒ¨åˆ†å®Œæ•´ç›‘æ§ç³»ç»Ÿ)
<!-- TOC -->

---

## ç¬¬ä¸€éƒ¨åˆ†ï¼šå¯è§‚æµ‹æ€§æ ¸å¿ƒç†è®º

### 1.1 å¯è§‚æµ‹æ€§ä¸‰å¤§æ”¯æŸ±

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              å¯è§‚æµ‹æ€§ä¸‰å¤§æ”¯æŸ±                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                Application
                     â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚            â”‚            â”‚
        â–¼            â–¼            â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”
    â”‚Metricsâ”‚   â”‚ Tracesâ”‚   â”‚  Logs â”‚
    â”‚ æŒ‡æ ‡  â”‚   â”‚ è¿½è¸ª  â”‚   â”‚ æ—¥å¿—  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚            â”‚            â”‚
        â–¼            â–¼            â–¼

1ï¸âƒ£ Metricsï¼ˆæŒ‡æ ‡ï¼‰
   - æ•°å€¼å‹æ•°æ®ï¼ˆCPUã€å†…å­˜ã€QPSï¼‰
   - æ—¶é—´åºåˆ—
   - èšåˆç»Ÿè®¡
   å·¥å…·ï¼šPrometheusã€InfluxDB

2ï¸âƒ£ Tracesï¼ˆè¿½è¸ªï¼‰
   - è¯·æ±‚é“¾è·¯
   - è·¨æœåŠ¡è°ƒç”¨
   - æ€§èƒ½åˆ†æ
   å·¥å…·ï¼šJaegerã€Zipkinã€OpenTelemetry

3ï¸âƒ£ Logsï¼ˆæ—¥å¿—ï¼‰
   - äº‹ä»¶è®°å½•
   - é”™è¯¯ä¿¡æ¯
   - ä¸šåŠ¡æ—¥å¿—
   å·¥å…·ï¼šELKã€Lokiã€Fluentd

                â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Observability Platform  â”‚
    â”‚  (å¯è§‚æµ‹æ€§å¹³å°)           â”‚
    â”‚  - Grafana               â”‚
    â”‚  - Kibana                â”‚
    â”‚  - Datadog               â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 1.2 ç›‘æ§ vs å¯è§‚æµ‹æ€§

```text
ç›‘æ§ï¼ˆMonitoringï¼‰:
- å·²çŸ¥é—®é¢˜çš„æ£€æµ‹
- é¢„å®šä¹‰çš„æŒ‡æ ‡
- é˜ˆå€¼å‘Šè­¦
ä¾‹å¦‚ï¼šCPU > 80% â†’ å‘Šè­¦

å¯è§‚æµ‹æ€§ï¼ˆObservabilityï¼‰:
- æœªçŸ¥é—®é¢˜çš„æ¢ç´¢
- ä»»æ„ç»´åº¦æŸ¥è¯¢
- æ ¹å› åˆ†æ
ä¾‹å¦‚ï¼šä¸ºä»€ä¹ˆç¬¬95ç™¾åˆ†ä½å»¶è¿Ÿçªç„¶ä¸Šå‡ï¼Ÿ

                ç›‘æ§
                 â†“
    æˆ‘çŸ¥é“ä¼šå‡ºç°ä»€ä¹ˆé—®é¢˜
    ï¼ˆå·²çŸ¥çš„å·²çŸ¥ï¼‰
                 
            å¯è§‚æµ‹æ€§
                 â†“
    æˆ‘ä¸çŸ¥é“ä¼šå‡ºç°ä»€ä¹ˆé—®é¢˜
    ï¼ˆå·²çŸ¥çš„æœªçŸ¥ + æœªçŸ¥çš„æœªçŸ¥ï¼‰
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šPrometheusç›‘æ§

### 2.1 å®æˆ˜æ¡ˆä¾‹1ï¼šPrometheusåŸºç¡€ä½¿ç”¨

```go
package main

import (
 "net/http"
 "time"

 "github.com/prometheus/client_golang/prometheus"
 "github.com/prometheus/client_golang/prometheus/promauto"
 "github.com/prometheus/client_golang/prometheus/promhttp"
)

// ===== å››ç§æŒ‡æ ‡ç±»å‹ =====

// 1. Counterï¼ˆè®¡æ•°å™¨ï¼‰- åªå¢ä¸å‡
var (
 httpRequestsTotal = promauto.NewCounterVec(
  prometheus.CounterOpts{
   Name: "http_requests_total",
   Help: "Total number of HTTP requests",
  },
  []string{"method", "endpoint", "status"},
 )

 httpRequestErrors = promauto.NewCounter(
  prometheus.CounterOpts{
   Name: "http_request_errors_total",
   Help: "Total number of HTTP request errors",
  },
 )
)

// 2. Gaugeï¼ˆä»ªè¡¨ç›˜ï¼‰- å¯å¢å¯å‡
var (
 activeConnections = promauto.NewGauge(
  prometheus.GaugeOpts{
   Name: "active_connections",
   Help: "Number of active connections",
  },
 )

 cpuUsage = promauto.NewGauge(
  prometheus.GaugeOpts{
   Name: "cpu_usage_percent",
   Help: "Current CPU usage in percent",
  },
 )

 memoryUsage = promauto.NewGaugeVec(
  prometheus.GaugeOpts{
   Name: "memory_usage_bytes",
   Help: "Memory usage in bytes",
  },
  []string{"type"}, // heap, stack, etc.
 )
)

// 3. Histogramï¼ˆç›´æ–¹å›¾ï¼‰- åˆ†å¸ƒç»Ÿè®¡
var (
 httpRequestDuration = promauto.NewHistogramVec(
  prometheus.HistogramOpts{
   Name:    "http_request_duration_seconds",
   Help:    "HTTP request latency in seconds",
   Buckets: prometheus.DefBuckets, // [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]
  },
  []string{"method", "endpoint"},
 )

 // è‡ªå®šä¹‰buckets
 dbQueryDuration = promauto.NewHistogram(
  prometheus.HistogramOpts{
   Name:    "db_query_duration_seconds",
   Help:    "Database query latency",
   Buckets: []float64{0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 2},
  },
 )
)

// 4. Summaryï¼ˆæ‘˜è¦ï¼‰- ç™¾åˆ†ä½ç»Ÿè®¡
var (
 requestSize = promauto.NewSummaryVec(
  prometheus.SummaryOpts{
   Name:       "http_request_size_bytes",
   Help:       "HTTP request size in bytes",
   Objectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001}, // åˆ†ä½æ•°
  },
  []string{"method"},
 )
)

// ===== ä½¿ç”¨ç¤ºä¾‹ =====

// MetricsMiddleware HTTPä¸­é—´ä»¶
func MetricsMiddleware(next http.Handler) http.Handler {
 return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  start := time.Now()

  // å¢åŠ æ´»è·ƒè¿æ¥æ•°
  activeConnections.Inc()
  defer activeConnections.Dec()

  // è®°å½•è¯·æ±‚å¤§å°
  requestSize.WithLabelValues(r.Method).Observe(float64(r.ContentLength))

  // åŒ…è£…ResponseWriterä»¥æ•è·çŠ¶æ€ç 
  rw := &responseWriter{ResponseWriter: w, statusCode: 200}

  // è°ƒç”¨ä¸‹ä¸€ä¸ªå¤„ç†å™¨
  next.ServeHTTP(rw, r)

  // è®°å½•è¯·æ±‚æŒ‡æ ‡
  duration := time.Since(start).Seconds()
  httpRequestDuration.WithLabelValues(r.Method, r.URL.Path).Observe(duration)
  httpRequestsTotal.WithLabelValues(r.Method, r.URL.Path, http.StatusText(rw.statusCode)).Inc()

  // è®°å½•é”™è¯¯
  if rw.statusCode >= 400 {
   httpRequestErrors.Inc()
  }
 })
}

type responseWriter struct {
 http.ResponseWriter
 statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
 rw.statusCode = code
 rw.ResponseWriter.WriteHeader(code)
}

// ===== ä¸šåŠ¡æŒ‡æ ‡ç¤ºä¾‹ =====

var (
 // è®¢å•æŒ‡æ ‡
 ordersTotal = promauto.NewCounterVec(
  prometheus.CounterOpts{
   Name: "orders_total",
   Help: "Total number of orders",
  },
  []string{"status"}, // pending, completed, failed
 )

 orderAmount = promauto.NewHistogramVec(
  prometheus.HistogramOpts{
   Name:    "order_amount_dollars",
   Help:    "Order amount in dollars",
   Buckets: []float64{10, 50, 100, 200, 500, 1000, 5000},
  },
  []string{"product_category"},
 )

 // ç”¨æˆ·æŒ‡æ ‡
 activeUsers = promauto.NewGauge(
  prometheus.GaugeOpts{
   Name: "active_users",
   Help: "Number of currently active users",
  },
 )

 userRegistrations = promauto.NewCounter(
  prometheus.CounterOpts{
   Name: "user_registrations_total",
   Help: "Total number of user registrations",
  },
 )
)

// RecordOrder è®°å½•è®¢å•
func RecordOrder(status string, amount float64, category string) {
 ordersTotal.WithLabelValues(status).Inc()
 orderAmount.WithLabelValues(category).Observe(amount)
}

// UpdateActiveUsers æ›´æ–°æ´»è·ƒç”¨æˆ·æ•°
func UpdateActiveUsers(count int) {
 activeUsers.Set(float64(count))
}

// ===== ä¸»ç¨‹åº =====

func main() {
 // æ³¨å†Œ/metricsç«¯ç‚¹
 http.Handle("/metrics", promhttp.Handler())

 // ä¸šåŠ¡è·¯ç”±ï¼ˆå¸¦ç›‘æ§ä¸­é—´ä»¶ï¼‰
 mux := http.NewServeMux()
 mux.HandleFunc("/api/users", func(w http.ResponseWriter, r *http.Request) {
  w.Write([]byte("Users API"))
 })
 mux.HandleFunc("/api/orders", func(w http.ResponseWriter, r *http.Request) {
  // æ¨¡æ‹Ÿä¸šåŠ¡é€»è¾‘
  RecordOrder("completed", 99.99, "electronics")
  w.Write([]byte("Orders API"))
 })

 // åº”ç”¨ä¸­é—´ä»¶
 handler := MetricsMiddleware(mux)
 http.Handle("/", handler)

 // å¯åŠ¨æœåŠ¡å™¨
 http.ListenAndServe(":8080", nil)
}
```

---

### 2.2 å®æˆ˜æ¡ˆä¾‹2ï¼šè‡ªå®šä¹‰Collector

```go
package main

import (
 "log"
 "runtime"
 "time"

 "github.com/prometheus/client_golang/prometheus"
)

// ===== è‡ªå®šä¹‰Collectorï¼ˆé«˜çº§ç”¨æ³•ï¼‰=====

// SystemStatsCollector ç³»ç»Ÿç»Ÿè®¡æ”¶é›†å™¨
type SystemStatsCollector struct {
 goroutines *prometheus.Desc
 threads    *prometheus.Desc
 gcPauses   *prometheus.Desc
 heapAlloc  *prometheus.Desc
 heapSys    *prometheus.Desc
}

// NewSystemStatsCollector åˆ›å»ºæ”¶é›†å™¨
func NewSystemStatsCollector() *SystemStatsCollector {
 return &SystemStatsCollector{
  goroutines: prometheus.NewDesc(
   "go_goroutines_count",
   "Number of goroutines",
   nil, nil,
  ),
  threads: prometheus.NewDesc(
   "go_threads_count",
   "Number of OS threads",
   nil, nil,
  ),
  gcPauses: prometheus.NewDesc(
   "go_gc_pause_seconds",
   "GC pause duration in seconds",
   nil, nil,
  ),
  heapAlloc: prometheus.NewDesc(
   "go_heap_alloc_bytes",
   "Heap allocated bytes",
   nil, nil,
  ),
  heapSys: prometheus.NewDesc(
   "go_heap_sys_bytes",
   "Heap system bytes",
   nil, nil,
  ),
 }
}

// Describe å®ç°Collectoræ¥å£
func (c *SystemStatsCollector) Describe(ch chan<- *prometheus.Desc) {
 ch <- c.goroutines
 ch <- c.threads
 ch <- c.gcPauses
 ch <- c.heapAlloc
 ch <- c.heapSys
}

// Collect å®ç°Collectoræ¥å£
func (c *SystemStatsCollector) Collect(ch chan<- prometheus.Metric) {
 var m runtime.MemStats
 runtime.ReadMemStats(&m)

 ch <- prometheus.MustNewConstMetric(
  c.goroutines,
  prometheus.GaugeValue,
  float64(runtime.NumGoroutine()),
 )

 ch <- prometheus.MustNewConstMetric(
  c.threads,
  prometheus.GaugeValue,
  float64(runtime.GOMAXPROCS(0)),
 )

 ch <- prometheus.MustNewConstMetric(
  c.gcPauses,
  prometheus.GaugeValue,
  float64(m.PauseNs[(m.NumGC+255)%256])/1e9,
 )

 ch <- prometheus.MustNewConstMetric(
  c.heapAlloc,
  prometheus.GaugeValue,
  float64(m.HeapAlloc),
 )

 ch <- prometheus.MustNewConstMetric(
  c.heapSys,
  prometheus.GaugeValue,
  float64(m.HeapSys),
 )
}

// ===== ä½¿ç”¨ç¤ºä¾‹ =====

func main() {
 // æ³¨å†Œè‡ªå®šä¹‰æ”¶é›†å™¨
 collector := NewSystemStatsCollector()
 prometheus.MustRegister(collector)

 log.Println("Custom collector registered")
}
```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šGrafanaå¯è§†åŒ–

### 3.1 å®æˆ˜æ¡ˆä¾‹3ï¼šGrafana Dashboardé…ç½®

```json
{
  "dashboard": {
    "title": "Go Application Monitoring",
    "panels": [
      {
        "title": "HTTP Request Rate",
        "targets": [
          {
            "expr": "rate(http_requests_total[5m])",
            "legendFormat": "{{method}} {{endpoint}}"
          }
        ],
        "type": "graph"
      },
      {
        "title": "HTTP Request Duration P95",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "p95"
          }
        ],
        "type": "graph"
      },
      {
        "title": "Error Rate",
        "targets": [
          {
            "expr": "rate(http_request_errors_total[5m])",
            "legendFormat": "errors/s"
          }
        ],
        "type": "graph"
      },
      {
        "title": "Active Connections",
        "targets": [
          {
            "expr": "active_connections"
          }
        ],
        "type": "stat"
      }
    ]
  }
}
```

---

## ç¬¬å››éƒ¨åˆ†ï¼šOpenTelemetryè¿½è¸ª

### 4.1 å®æˆ˜æ¡ˆä¾‹4ï¼šåˆ†å¸ƒå¼è¿½è¸ª

```go
package main

import (
 "context"
 "log"
 "time"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/exporters/jaeger"
 "go.opentelemetry.io/otel/sdk/resource"
 tracesdk "go.opentelemetry.io/otel/sdk/trace"
 semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
 "go.opentelemetry.io/otel/trace"
)

// ===== OpenTelemetryåˆå§‹åŒ– =====

func InitTracer(serviceName string) (*tracesdk.TracerProvider, error) {
 // åˆ›å»ºJaegerå¯¼å‡ºå™¨
 exporter, err := jaeger.New(jaeger.WithCollectorEndpoint(
  jaeger.WithEndpoint("http://localhost:14268/api/traces"),
 ))
 if err != nil {
  return nil, err
 }

 // åˆ›å»ºTracerProvider
 tp := tracesdk.NewTracerProvider(
  tracesdk.WithBatcher(exporter),
  tracesdk.WithResource(resource.NewWithAttributes(
   semconv.SchemaURL,
   semconv.ServiceNameKey.String(serviceName),
  )),
  tracesdk.WithSampler(tracesdk.AlwaysSample()),
 )

 // è®¾ç½®å…¨å±€TracerProvider
 otel.SetTracerProvider(tp)

 return tp, nil
}

// ===== ä¸šåŠ¡ä»£ç ç¤ºä¾‹ =====

type OrderService struct {
 tracer trace.Tracer
}

func NewOrderService() *OrderService {
 return &OrderService{
  tracer: otel.Tracer("order-service"),
 }
}

// CreateOrder åˆ›å»ºè®¢å•ï¼ˆå¸¦è¿½è¸ªï¼‰
func (s *OrderService) CreateOrder(ctx context.Context, userID, productID string, amount float64) (string, error) {
 // åˆ›å»ºSpan
 ctx, span := s.tracer.Start(ctx, "CreateOrder",
  trace.WithAttributes(
   attribute.String("user.id", userID),
   attribute.String("product.id", productID),
   attribute.Float64("order.amount", amount),
  ),
 )
 defer span.End()

 // 1. éªŒè¯ç”¨æˆ·
 if err := s.validateUser(ctx, userID); err != nil {
  span.RecordError(err)
  return "", err
 }

 // 2. æ£€æŸ¥åº“å­˜
 if err := s.checkInventory(ctx, productID); err != nil {
  span.RecordError(err)
  return "", err
 }

 // 3. åˆ›å»ºè®¢å•
 orderID := s.createOrderInDB(ctx, userID, productID, amount)
 span.SetAttributes(attribute.String("order.id", orderID))

 // 4. å‘é€é€šçŸ¥
 s.sendNotification(ctx, userID, orderID)

 return orderID, nil
}

func (s *OrderService) validateUser(ctx context.Context, userID string) error {
 ctx, span := s.tracer.Start(ctx, "ValidateUser")
 defer span.End()

 // æ¨¡æ‹ŸéªŒè¯é€»è¾‘
 time.Sleep(50 * time.Millisecond)
 span.SetAttributes(attribute.Bool("user.valid", true))

 return nil
}

func (s *OrderService) checkInventory(ctx context.Context, productID string) error {
 ctx, span := s.tracer.Start(ctx, "CheckInventory")
 defer span.End()

 // æ¨¡æ‹Ÿåº“å­˜æ£€æŸ¥
 time.Sleep(100 * time.Millisecond)
 span.SetAttributes(attribute.Int("inventory.count", 10))

 return nil
}

func (s *OrderService) createOrderInDB(ctx context.Context, userID, productID string, amount float64) string {
 ctx, span := s.tracer.Start(ctx, "CreateOrderInDB")
 defer span.End()

 // æ¨¡æ‹Ÿæ•°æ®åº“æ“ä½œ
 time.Sleep(200 * time.Millisecond)
 orderID := "order-123"
 span.SetAttributes(attribute.String("db.operation", "INSERT"))

 return orderID
}

func (s *OrderService) sendNotification(ctx context.Context, userID, orderID string) {
 ctx, span := s.tracer.Start(ctx, "SendNotification")
 defer span.End()

 // æ¨¡æ‹Ÿå‘é€é€šçŸ¥
 time.Sleep(50 * time.Millisecond)
 span.SetAttributes(attribute.String("notification.type", "email"))
}

// ===== ä¸»ç¨‹åº =====

func main() {
 // åˆå§‹åŒ–è¿½è¸ª
 tp, err := InitTracer("order-service")
 if err != nil {
  log.Fatal(err)
 }
 defer func() {
  if err := tp.Shutdown(context.Background()); err != nil {
   log.Printf("Error shutting down tracer provider: %v", err)
  }
 }()

 // åˆ›å»ºæœåŠ¡
 orderService := NewOrderService()

 // æ¨¡æ‹Ÿè¯·æ±‚
 ctx := context.Background()
 orderID, err := orderService.CreateOrder(ctx, "user-001", "product-123", 99.99)
 if err != nil {
  log.Printf("Create order failed: %v", err)
 } else {
  log.Printf("Order created: %s", orderID)
 }
}
```

---

## ç¬¬äº”éƒ¨åˆ†ï¼šç»“æ„åŒ–æ—¥å¿—

### 5.1 å®æˆ˜æ¡ˆä¾‹5ï¼šZapç»“æ„åŒ–æ—¥å¿—

```go
package main

import (
 "context"
 "fmt"
 "time"

 "go.uber.org/zap"
 "go.uber.org/zap/zapcore"
)

// ===== Zapæ—¥å¿—åˆå§‹åŒ– =====

func InitLogger(env string) (*zap.Logger, error) {
 var config zap.Config

 if env == "production" {
  config = zap.NewProductionConfig()
  config.EncoderConfig.TimeKey = "timestamp"
  config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
 } else {
  config = zap.NewDevelopmentConfig()
  config.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
 }

 // è®¾ç½®æ—¥å¿—çº§åˆ«
 config.Level = zap.NewAtomicLevelAt(zap.InfoLevel)

 // è¾“å‡ºåˆ°æ–‡ä»¶å’Œæ§åˆ¶å°
 config.OutputPaths = []string{"stdout", "app.log"}
 config.ErrorOutputPaths = []string{"stderr", "error.log"}

 logger, err := config.Build(
  zap.AddCaller(),      // æ·»åŠ è°ƒç”¨è€…ä¿¡æ¯
  zap.AddStacktrace(zapcore.ErrorLevel), // é”™è¯¯çº§åˆ«æ·»åŠ å †æ ˆ
 )
 if err != nil {
  return nil, err
 }

 return logger, nil
}

// ===== æ—¥å¿—å°è£… =====

type Logger struct {
 logger *zap.Logger
}

func NewLogger(logger *zap.Logger) *Logger {
 return &Logger{logger: logger}
}

// WithContext ä»contextæå–traceä¿¡æ¯
func (l *Logger) WithContext(ctx context.Context) *zap.Logger {
 // ä»contextæå–trace_idã€span_idç­‰
 // è¿™é‡Œç®€åŒ–å¤„ç†
 return l.logger.With(
  zap.String("request_id", getRequestID(ctx)),
  zap.String("user_id", getUserID(ctx)),
 )
}

func getRequestID(ctx context.Context) string {
 if id, ok := ctx.Value("request_id").(string); ok {
  return id
 }
 return "unknown"
}

func getUserID(ctx context.Context) string {
 if id, ok := ctx.Value("user_id").(string); ok {
  return id
 }
 return "anonymous"
}

// ===== ä¸šåŠ¡æ—¥å¿—ç¤ºä¾‹ =====

type UserService struct {
 logger *Logger
}

func NewUserService(logger *Logger) *UserService {
 return &UserService{logger: logger}
}

// Login ç”¨æˆ·ç™»å½•ï¼ˆå¸¦ç»“æ„åŒ–æ—¥å¿—ï¼‰
func (s *UserService) Login(ctx context.Context, username, password string) error {
 logger := s.logger.WithContext(ctx)

 logger.Info("User login attempt",
  zap.String("username", username),
  zap.Time("timestamp", time.Now()),
 )

 // æ¨¡æ‹Ÿç™»å½•é€»è¾‘
 if username == "" {
  logger.Warn("Login failed: empty username",
   zap.String("username", username),
  )
  return fmt.Errorf("empty username")
 }

 // æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
 time.Sleep(50 * time.Millisecond)

 logger.Info("User login successful",
  zap.String("username", username),
  zap.Duration("duration", 50*time.Millisecond),
 )

 return nil
}

// ProcessOrder å¤„ç†è®¢å•ï¼ˆå¸¦è¯¦ç»†æ—¥å¿—ï¼‰
func (s *UserService) ProcessOrder(ctx context.Context, orderID string, amount float64) error {
 logger := s.logger.WithContext(ctx)

 logger.Info("Processing order",
  zap.String("order_id", orderID),
  zap.Float64("amount", amount),
 )

 // æ¨¡æ‹Ÿä¸šåŠ¡é€»è¾‘
 if amount <= 0 {
  logger.Error("Invalid order amount",
   zap.String("order_id", orderID),
   zap.Float64("amount", amount),
   zap.String("error", "amount must be positive"),
  )
  return fmt.Errorf("invalid amount")
 }

 // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
 start := time.Now()
 time.Sleep(200 * time.Millisecond)
 duration := time.Since(start)

 logger.Info("Order processed successfully",
  zap.String("order_id", orderID),
  zap.Duration("duration", duration),
  zap.String("status", "completed"),
 )

 return nil
}

// ===== ä¸»ç¨‹åº =====

func main() {
 // åˆå§‹åŒ–æ—¥å¿—
 zapLogger, err := InitLogger("development")
 if err != nil {
  panic(err)
 }
 defer zapLogger.Sync()

 logger := NewLogger(zapLogger)

 // åˆ›å»ºæœåŠ¡
 userService := NewUserService(logger)

 // æ¨¡æ‹Ÿè¯·æ±‚
 ctx := context.WithValue(context.Background(), "request_id", "req-001")
 ctx = context.WithValue(ctx, "user_id", "user-123")

 // ç”¨æˆ·ç™»å½•
 userService.Login(ctx, "alice", "password123")

 // å¤„ç†è®¢å•
 userService.ProcessOrder(ctx, "order-001", 99.99)
}
```

---

## ğŸ¯ æ€»ç»“

### å¯è§‚æµ‹æ€§æ ¸å¿ƒè¦ç‚¹

1. **ä¸‰å¤§æ”¯æŸ±** - Metrics/Traces/Logs
2. **Prometheus** - æŒ‡æ ‡æ”¶é›†ã€PromQLæŸ¥è¯¢ã€å‘Šè­¦è§„åˆ™
3. **Grafana** - å¯è§†åŒ–Dashboardã€å‘Šè­¦é€šçŸ¥
4. **OpenTelemetry** - åˆ†å¸ƒå¼è¿½è¸ªã€ä¸Šä¸‹æ–‡ä¼ æ’­
5. **ç»“æ„åŒ–æ—¥å¿—** - Zap/Logrusã€æ—¥å¿—èšåˆ
6. **æŒ‡æ ‡ç±»å‹** - Counter/Gauge/Histogram/Summary
7. **SLI/SLO/SLA** - æœåŠ¡è´¨é‡æŒ‡æ ‡
8. **å‘Šè­¦ç³»ç»Ÿ** - AlertManagerã€å‘Šè­¦è·¯ç”±
9. **æ€§èƒ½åˆ†æ** - pprofé›†æˆã€ç«ç„°å›¾
10. **æ•…éšœæ’æŸ¥** - æ—¥å¿—å…³è”ã€è¿½è¸ªåˆ†æ

### æœ€ä½³å®è·µæ¸…å•

```text
âœ… å®æ–½ä¸‰å¤§æ”¯æŸ±ï¼ˆæŒ‡æ ‡+è¿½è¸ª+æ—¥å¿—ï¼‰
âœ… å®šä¹‰å…³é”®SLI/SLO
âœ… ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—
âœ… å®æ–½åˆ†å¸ƒå¼è¿½è¸ª
âœ… é…ç½®åˆç†çš„å‘Šè­¦è§„åˆ™
âœ… åˆ›å»ºå¯è§†åŒ–Dashboard
âœ… è®°å½•ä¸šåŠ¡æŒ‡æ ‡
âœ… å®æ–½æ—¥å¿—é‡‡æ ·
âœ… ä½¿ç”¨å”¯ä¸€è¯·æ±‚ID
âœ… å®šæœŸæ•…éšœæ¼”ç»ƒ
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v18.0  
**æœ€åæ›´æ–°**: 2025-10-20

<div align="center">

Made with â¤ï¸ for Production-Ready Developers

[â¬† å›åˆ°é¡¶éƒ¨](#ç›‘æ§ä¸å¯è§‚æµ‹æ€§æ·±åº¦å®æˆ˜æŒ‡å—)

</div>
