# 02-å¸¸ç”¨ç®—æ³•

> Goè¯­è¨€ä¸­å¸¸ç”¨ç®—æ³•çš„å®ç°ä¸åº”ç”¨

---

## ğŸ“š ç›®å½•

- [02-å¸¸ç”¨ç®—æ³•](#02-å¸¸ç”¨ç®—æ³•)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [ğŸ“š ç« èŠ‚æ¦‚è§ˆ](#-ç« èŠ‚æ¦‚è§ˆ)
  - [1. æ’åºç®—æ³•](#1-æ’åºç®—æ³•)
    - [1.1 å†’æ³¡æ’åº (Bubble Sort)](#11-å†’æ³¡æ’åº-bubble-sort)
    - [1.2 å¿«é€Ÿæ’åº (Quick Sort)](#12-å¿«é€Ÿæ’åº-quick-sort)
    - [1.3 å½’å¹¶æ’åº (Merge Sort)](#13-å½’å¹¶æ’åº-merge-sort)
  - [2. æŸ¥æ‰¾ç®—æ³•](#2-æŸ¥æ‰¾ç®—æ³•)
    - [2.1 äºŒåˆ†æŸ¥æ‰¾ (Binary Search)](#21-äºŒåˆ†æŸ¥æ‰¾-binary-search)
  - [3. å­—ç¬¦ä¸²ç®—æ³•](#3-å­—ç¬¦ä¸²ç®—æ³•)
    - [3.1 KMPç®—æ³•ï¼ˆå­—ç¬¦ä¸²åŒ¹é…ï¼‰](#31-kmpç®—æ³•å­—ç¬¦ä¸²åŒ¹é…)
  - [4. åŠ¨æ€è§„åˆ’](#4-åŠ¨æ€è§„åˆ’)
    - [4.1 æ–æ³¢é‚£å¥‘æ•°åˆ—](#41-æ–æ³¢é‚£å¥‘æ•°åˆ—)
    - [4.2 æœ€é•¿å…¬å…±å­åºåˆ— (LCS)](#42-æœ€é•¿å…¬å…±å­åºåˆ—-lcs)
    - [4.3 èƒŒåŒ…é—®é¢˜](#43-èƒŒåŒ…é—®é¢˜)
  - [5. è´ªå¿ƒç®—æ³•](#5-è´ªå¿ƒç®—æ³•)
    - [5.1 æ´»åŠ¨é€‰æ‹©é—®é¢˜](#51-æ´»åŠ¨é€‰æ‹©é—®é¢˜)
  - [6. å›æº¯ç®—æ³•](#6-å›æº¯ç®—æ³•)
    - [6.1 å…¨æ’åˆ—](#61-å…¨æ’åˆ—)
  - [ğŸ’¡ ç®—æ³•æ€»ç»“](#-ç®—æ³•æ€»ç»“)
    - [æ—¶é—´å¤æ‚åº¦å¯¹æ¯”](#æ—¶é—´å¤æ‚åº¦å¯¹æ¯”)
    - [åº”ç”¨åœºæ™¯](#åº”ç”¨åœºæ™¯)
  - [ğŸ”— ç›¸å…³ç« èŠ‚](#-ç›¸å…³ç« èŠ‚)

## ğŸ“š ç« èŠ‚æ¦‚è§ˆ

æœ¬ç« ä»‹ç»Goè¯­è¨€ä¸­çš„å¸¸ç”¨ç®—æ³•ï¼ŒåŒ…æ‹¬æ’åºç®—æ³•ã€æŸ¥æ‰¾ç®—æ³•ã€å­—ç¬¦ä¸²ç®—æ³•ã€åŠ¨æ€è§„åˆ’å’Œè´ªå¿ƒç®—æ³•ç­‰ã€‚

---

## 1. æ’åºç®—æ³•

### 1.1 å†’æ³¡æ’åº (Bubble Sort)

**æ—¶é—´å¤æ‚åº¦**: O(nÂ²)  
**ç©ºé—´å¤æ‚åº¦**: O(1)  
**ç¨³å®šæ€§**: ç¨³å®š

```go
package main

import "fmt"

// å†’æ³¡æ’åº
func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        swapped := false
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = true
            }
        }
        // å¦‚æœæ²¡æœ‰äº¤æ¢ï¼Œè¯´æ˜å·²ç»æœ‰åº
        if !swapped {
            break
        }
    }
}

func main() {
    arr := []int{64, 34, 25, 12, 22, 11, 90}
    bubbleSort(arr)
    fmt.Println("æ’åºå:", arr)
}
```

### 1.2 å¿«é€Ÿæ’åº (Quick Sort)

**æ—¶é—´å¤æ‚åº¦**: O(n log n) å¹³å‡ï¼ŒO(nÂ²) æœ€å  
**ç©ºé—´å¤æ‚åº¦**: O(log n)  
**ç¨³å®šæ€§**: ä¸ç¨³å®š

```go
package main

import "fmt"

// å¿«é€Ÿæ’åº
func quickSort(arr []int, low, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    }
}

// åˆ†åŒºå‡½æ•°
func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low - 1
    
    for j := low; j < high; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

func main() {
    arr := []int{10, 7, 8, 9, 1, 5}
    quickSort(arr, 0, len(arr)-1)
    fmt.Println("æ’åºå:", arr)
}
```

### 1.3 å½’å¹¶æ’åº (Merge Sort)

**æ—¶é—´å¤æ‚åº¦**: O(n log n)  
**ç©ºé—´å¤æ‚åº¦**: O(n)  
**ç¨³å®šæ€§**: ç¨³å®š

```go
package main

import "fmt"

// å½’å¹¶æ’åº
func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])
    
    return merge(left, right)
}

// åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„
func merge(left, right []int) []int {
    result := make([]int, 0, len(left)+len(right))
    i, j := 0, 0
    
    for i < len(left) && j < len(right) {
        if left[i] <= right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }
    
    result = append(result, left[i:]...)
    result = append(result, right[j:]...)
    
    return result
}

func main() {
    arr := []int{38, 27, 43, 3, 9, 82, 10}
    sorted := mergeSort(arr)
    fmt.Println("æ’åºå:", sorted)
}
```

---

## 2. æŸ¥æ‰¾ç®—æ³•

### 2.1 äºŒåˆ†æŸ¥æ‰¾ (Binary Search)

**æ—¶é—´å¤æ‚åº¦**: O(log n)  
**ç©ºé—´å¤æ‚åº¦**: O(1)  
**å‰æ**: æ•°ç»„å¿…é¡»æœ‰åº

```go
package main

import "fmt"

// äºŒåˆ†æŸ¥æ‰¾ï¼ˆè¿­ä»£ï¼‰
func binarySearch(arr []int, target int) int {
    left, right := 0, len(arr)-1
    
    for left <= right {
        mid := left + (right-left)/2
        
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return -1 // æœªæ‰¾åˆ°
}

// äºŒåˆ†æŸ¥æ‰¾ï¼ˆé€’å½’ï¼‰
func binarySearchRecursive(arr []int, target, left, right int) int {
    if left > right {
        return -1
    }
    
    mid := left + (right-left)/2
    
    if arr[mid] == target {
        return mid
    } else if arr[mid] < target {
        return binarySearchRecursive(arr, target, mid+1, right)
    } else {
        return binarySearchRecursive(arr, target, left, mid-1)
    }
}

func main() {
    arr := []int{2, 3, 4, 10, 40}
    target := 10
    
    result := binarySearch(arr, target)
    if result != -1 {
        fmt.Printf("å…ƒç´  %d åœ¨ç´¢å¼• %d\n", target, result)
    } else {
        fmt.Println("å…ƒç´ æœªæ‰¾åˆ°")
    }
}
```

---

## 3. å­—ç¬¦ä¸²ç®—æ³•

### 3.1 KMPç®—æ³•ï¼ˆå­—ç¬¦ä¸²åŒ¹é…ï¼‰

**æ—¶é—´å¤æ‚åº¦**: O(n + m)  
**ç©ºé—´å¤æ‚åº¦**: O(m)

```go
package main

import "fmt"

// æ„å»ºéƒ¨åˆ†åŒ¹é…è¡¨
func buildNext(pattern string) []int {
    m := len(pattern)
    next := make([]int, m)
    next[0] = -1
    
    i, j := 0, -1
    for i < m-1 {
        if j == -1 || pattern[i] == pattern[j] {
            i++
            j++
            next[i] = j
        } else {
            j = next[j]
        }
    }
    
    return next
}

// KMPå­—ç¬¦ä¸²åŒ¹é…
func kmpSearch(text, pattern string) int {
    if len(pattern) == 0 {
        return 0
    }
    
    next := buildNext(pattern)
    i, j := 0, 0
    
    for i < len(text) && j < len(pattern) {
        if j == -1 || text[i] == pattern[j] {
            i++
            j++
        } else {
            j = next[j]
        }
        
        if j == len(pattern) {
            return i - j
        }
    }
    
    return -1
}

func main() {
    text := "ABABDABACDABABCABAB"
    pattern := "ABABCABAB"
    
    pos := kmpSearch(text, pattern)
    if pos != -1 {
        fmt.Printf("æ¨¡å¼ä¸²åœ¨ä½ç½® %d æ‰¾åˆ°\n", pos)
    } else {
        fmt.Println("æ¨¡å¼ä¸²æœªæ‰¾åˆ°")
    }
}
```

---

## 4. åŠ¨æ€è§„åˆ’

### 4.1 æ–æ³¢é‚£å¥‘æ•°åˆ—

```go
package main

import "fmt"

// é€’å½’æ–¹æ³•ï¼ˆæ•ˆç‡ä½ï¼‰
func fibRecursive(n int) int {
    if n <= 1 {
        return n
    }
    return fibRecursive(n-1) + fibRecursive(n-2)
}

// åŠ¨æ€è§„åˆ’ï¼ˆè‡ªåº•å‘ä¸Šï¼‰
func fibDP(n int) int {
    if n <= 1 {
        return n
    }
    
    dp := make([]int, n+1)
    dp[0], dp[1] = 0, 1
    
    for i := 2; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    
    return dp[n]
}

// ç©ºé—´ä¼˜åŒ–ç‰ˆæœ¬
func fibOptimized(n int) int {
    if n <= 1 {
        return n
    }
    
    prev, curr := 0, 1
    for i := 2; i <= n; i++ {
        prev, curr = curr, prev+curr
    }
    
    return curr
}

func main() {
    n := 10
    fmt.Printf("Fibonacci(%d) = %d\n", n, fibDP(n))
}
```

### 4.2 æœ€é•¿å…¬å…±å­åºåˆ— (LCS)

```go
package main

import "fmt"

// æœ€é•¿å…¬å…±å­åºåˆ—
func longestCommonSubsequence(text1, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    text1 := "abcde"
    text2 := "ace"
    
    result := longestCommonSubsequence(text1, text2)
    fmt.Printf("æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦: %d\n", result)
}
```

### 4.3 èƒŒåŒ…é—®é¢˜

```go
package main

import "fmt"

// 0-1èƒŒåŒ…é—®é¢˜
func knapsack(weights, values []int, capacity int) int {
    n := len(weights)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, capacity+1)
    }
    
    for i := 1; i <= n; i++ {
        for w := 1; w <= capacity; w++ {
            if weights[i-1] <= w {
                // å–max(ä¸æ”¾å…¥, æ”¾å…¥)
                dp[i][w] = max(
                    dp[i-1][w],
                    dp[i-1][w-weights[i-1]]+values[i-1],
                )
            } else {
                dp[i][w] = dp[i-1][w]
            }
        }
    }
    
    return dp[n][capacity]
}

func main() {
    weights := []int{1, 3, 4, 5}
    values := []int{1, 4, 5, 7}
    capacity := 7
    
    maxValue := knapsack(weights, values, capacity)
    fmt.Printf("æœ€å¤§ä»·å€¼: %d\n", maxValue)
}
```

---

## 5. è´ªå¿ƒç®—æ³•

### 5.1 æ´»åŠ¨é€‰æ‹©é—®é¢˜

```go
package main

import (
    "fmt"
    "sort"
)

type Activity struct {
    start int
    end   int
}

// æŒ‰ç»“æŸæ—¶é—´æ’åº
func activitySelection(activities []Activity) []Activity {
    // æŒ‰ç»“æŸæ—¶é—´æ’åº
    sort.Slice(activities, func(i, j int) bool {
        return activities[i].end < activities[j].end
    })
    
    result := []Activity{activities[0]}
    lastEnd := activities[0].end
    
    for i := 1; i < len(activities); i++ {
        if activities[i].start >= lastEnd {
            result = append(result, activities[i])
            lastEnd = activities[i].end
        }
    }
    
    return result
}

func main() {
    activities := []Activity{
        {1, 4}, {3, 5}, {0, 6},
        {5, 7}, {3, 9}, {5, 9},
        {6, 10}, {8, 11}, {8, 12},
        {2, 14}, {12, 16},
    }
    
    selected := activitySelection(activities)
    fmt.Printf("é€‰æ‹©çš„æ´»åŠ¨æ•°: %d\n", len(selected))
    for _, act := range selected {
        fmt.Printf("[%d, %d] ", act.start, act.end)
    }
}
```

---

## 6. å›æº¯ç®—æ³•

### 6.1 å…¨æ’åˆ—

```go
package main

import "fmt"

// å…¨æ’åˆ—
func permute(nums []int) [][]int {
    result := [][]int{}
    backtrack(nums, []int{}, &result)
    return result
}

func backtrack(nums []int, path []int, result *[][]int) {
    if len(path) == len(nums) {
        temp := make([]int, len(path))
        copy(temp, path)
        *result = append(*result, temp)
        return
    }
    
    for i := 0; i < len(nums); i++ {
        if contains(path, nums[i]) {
            continue
        }
        path = append(path, nums[i])
        backtrack(nums, path, result)
        path = path[:len(path)-1]
    }
}

func contains(slice []int, val int) bool {
    for _, v := range slice {
        if v == val {
            return true
        }
    }
    return false
}

func main() {
    nums := []int{1, 2, 3}
    result := permute(nums)
    fmt.Println("å…¨æ’åˆ—:", result)
}
```

---

## ğŸ’¡ ç®—æ³•æ€»ç»“

### æ—¶é—´å¤æ‚åº¦å¯¹æ¯”

| ç®—æ³• | æœ€å¥½ | å¹³å‡ | æœ€å | ç©ºé—´ |
|------|------|------|------|------|
| å†’æ³¡æ’åº | O(n) | O(nÂ²) | O(nÂ²) | O(1) |
| å¿«é€Ÿæ’åº | O(n log n) | O(n log n) | O(nÂ²) | O(log n) |
| å½’å¹¶æ’åº | O(n log n) | O(n log n) | O(n log n) | O(n) |
| äºŒåˆ†æŸ¥æ‰¾ | O(1) | O(log n) | O(log n) | O(1) |

### åº”ç”¨åœºæ™¯

| ç®—æ³•ç±»å‹ | é€‚ç”¨åœºæ™¯ |
|---------|---------|
| **æ’åº** | æ•°æ®æ•´ç†ã€ä¼˜å…ˆçº§é˜Ÿåˆ— |
| **æŸ¥æ‰¾** | å¿«é€Ÿå®šä½ã€å»é‡ |
| **å­—ç¬¦ä¸²** | æ–‡æœ¬å¤„ç†ã€æ¨¡å¼åŒ¹é… |
| **åŠ¨æ€è§„åˆ’** | æœ€ä¼˜åŒ–é—®é¢˜ã€è·¯å¾„é—®é¢˜ |
| **è´ªå¿ƒ** | å±€éƒ¨æœ€ä¼˜è§£ã€è°ƒåº¦é—®é¢˜ |
| **å›æº¯** | ç»„åˆé—®é¢˜ã€çº¦æŸæ»¡è¶³ |

---

## ğŸ”— ç›¸å…³ç« èŠ‚

- [01-åŸºç¡€æ•°æ®ç»“æ„](01-åŸºç¡€æ•°æ®ç»“æ„.md) - æ•°æ®ç»“æ„åŸºç¡€
- [03-ç®—æ³•æ¨¡å¼](03-ç®—æ³•æ¨¡å¼.md) - å¸¸è§è§£é¢˜æ¨¡å¼
- [04-å®æˆ˜æ¡ˆä¾‹](04-å®æˆ˜æ¡ˆä¾‹.md) - LeetCodeé¢˜ç›®

---

**ç»´æŠ¤è€…**: Documentation Team  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22  
**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
