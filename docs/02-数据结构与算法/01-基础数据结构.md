# 01-åŸºç¡€æ•°æ®ç»“æ„

> Goè¯­è¨€ä¸­çš„åŸºç¡€æ•°æ®ç»“æ„å®ç°ä¸åº”ç”¨

---

## ğŸ“š ç« èŠ‚æ¦‚è§ˆ

æœ¬ç« ä»‹ç»Goè¯­è¨€ä¸­å¸¸ç”¨çš„åŸºç¡€æ•°æ®ç»“æ„,åŒ…æ‹¬æ•°ç»„ã€åˆ‡ç‰‡ã€é“¾è¡¨ã€æ ˆã€é˜Ÿåˆ—ã€å“ˆå¸Œè¡¨ã€æ ‘å’Œå›¾ç­‰ã€‚

---

## 1. æ•°ç»„ (Array)

### 1.1 æ•°ç»„åŸºç¡€

```go
package main

import "fmt"

func main() {
    // å£°æ˜å’Œåˆå§‹åŒ–
    var arr1 [5]int
    arr2 := [5]int{1, 2, 3, 4, 5}
    arr3 := [...]int{1, 2, 3} // è‡ªåŠ¨æ¨å¯¼é•¿åº¦
    
    fmt.Println(arr1) // [0 0 0 0 0]
    fmt.Println(arr2) // [1 2 3 4 5]
    fmt.Println(arr3) // [1 2 3]
}
```

### 1.2 æ•°ç»„æ“ä½œ

```go
// éå†æ•°ç»„
arr := [5]int{1, 2, 3, 4, 5}

// æ–¹å¼1: forå¾ªç¯
for i := 0; i < len(arr); i++ {
    fmt.Printf("arr[%d] = %d\n", i, arr[i])
}

// æ–¹å¼2: range
for index, value := range arr {
    fmt.Printf("arr[%d] = %d\n", index, value)
}
```

---

## 2. åˆ‡ç‰‡ (Slice)

### 2.1 åˆ‡ç‰‡åŸºç¡€

```go
package main

import "fmt"

func main() {
    // åˆ›å»ºåˆ‡ç‰‡
    slice1 := []int{1, 2, 3}
    slice2 := make([]int, 5)      // é•¿åº¦5
    slice3 := make([]int, 5, 10)  // é•¿åº¦5,å®¹é‡10
    
    fmt.Printf("slice1: %v, len: %d, cap: %d\n", 
               slice1, len(slice1), cap(slice1))
}
```

### 2.2 åˆ‡ç‰‡æ“ä½œ

```go
// è¿½åŠ å…ƒç´ 
slice := []int{1, 2, 3}
slice = append(slice, 4, 5)

// åˆ‡ç‰‡æˆªå–
subSlice := slice[1:4]  // [2 3 4]

// å¤åˆ¶åˆ‡ç‰‡
dst := make([]int, len(slice))
copy(dst, slice)
```

---

## 3. é“¾è¡¨ (Linked List)

### 3.1 å•é“¾è¡¨å®ç°

```go
package main

import "fmt"

// å®šä¹‰èŠ‚ç‚¹
type Node struct {
    Data int
    Next *Node
}

// å®šä¹‰é“¾è¡¨
type LinkedList struct {
    Head *Node
    Size int
}

// åœ¨å¤´éƒ¨æ’å…¥
func (list *LinkedList) InsertAtHead(data int) {
    newNode := &Node{Data: data}
    newNode.Next = list.Head
    list.Head = newNode
    list.Size++
}

// åœ¨å°¾éƒ¨æ’å…¥
func (list *LinkedList) InsertAtTail(data int) {
    newNode := &Node{Data: data}
    
    if list.Head == nil {
        list.Head = newNode
        list.Size++
        return
    }
    
    current := list.Head
    for current.Next != nil {
        current = current.Next
    }
    current.Next = newNode
    list.Size++
}

// æ‰“å°é“¾è¡¨
func (list *LinkedList) Print() {
    current := list.Head
    for current != nil {
        fmt.Printf("%d -> ", current.Data)
        current = current.Next
    }
    fmt.Println("nil")
}

func main() {
    list := &LinkedList{}
    list.InsertAtHead(3)
    list.InsertAtHead(2)
    list.InsertAtHead(1)
    list.InsertAtTail(4)
    
    list.Print() // 1 -> 2 -> 3 -> 4 -> nil
}
```

---

## 4. æ ˆ (Stack)

### 4.1 æ ˆå®ç°

```go
package main

import (
    "errors"
    "fmt"
)

// ä½¿ç”¨åˆ‡ç‰‡å®ç°æ ˆ
type Stack struct {
    items []interface{}
}

// å…¥æ ˆ
func (s *Stack) Push(item interface{}) {
    s.items = append(s.items, item)
}

// å‡ºæ ˆ
func (s *Stack) Pop() (interface{}, error) {
    if len(s.items) == 0 {
        return nil, errors.New("stack is empty")
    }
    
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item, nil
}

// æŸ¥çœ‹æ ˆé¡¶
func (s *Stack) Peek() (interface{}, error) {
    if len(s.items) == 0 {
        return nil, errors.New("stack is empty")
    }
    return s.items[len(s.items)-1], nil
}

// åˆ¤æ–­æ˜¯å¦ä¸ºç©º
func (s *Stack) IsEmpty() bool {
    return len(s.items) == 0
}

func main() {
    stack := &Stack{}
    stack.Push(1)
    stack.Push(2)
    stack.Push(3)
    
    fmt.Println(stack.Pop())  // 3
    fmt.Println(stack.Peek()) // 2
}
```

---

## 5. é˜Ÿåˆ— (Queue)

### 5.1 é˜Ÿåˆ—å®ç°

```go
package main

import (
    "errors"
    "fmt"
)

// ä½¿ç”¨åˆ‡ç‰‡å®ç°é˜Ÿåˆ—
type Queue struct {
    items []interface{}
}

// å…¥é˜Ÿ
func (q *Queue) Enqueue(item interface{}) {
    q.items = append(q.items, item)
}

// å‡ºé˜Ÿ
func (q *Queue) Dequeue() (interface{}, error) {
    if len(q.items) == 0 {
        return nil, errors.New("queue is empty")
    }
    
    item := q.items[0]
    q.items = q.items[1:]
    return item, nil
}

// æŸ¥çœ‹é˜Ÿé¦–
func (q *Queue) Peek() (interface{}, error) {
    if len(q.items) == 0 {
        return nil, errors.New("queue is empty")
    }
    return q.items[0], nil
}

func main() {
    queue := &Queue{}
    queue.Enqueue(1)
    queue.Enqueue(2)
    queue.Enqueue(3)
    
    fmt.Println(queue.Dequeue()) // 1
    fmt.Println(queue.Peek())    // 2
}
```

---

## 6. å“ˆå¸Œè¡¨ (Hash Map)

### 6.1 å“ˆå¸Œè¡¨å†…éƒ¨ç»“æ„å¯è§†åŒ–

```mermaid
graph TB
    subgraph "å“ˆå¸Œè¡¨ç»“æ„"
        Hash[Hash Function<br/>hash=key%buckets]
    end
    
    subgraph "Buckets æ¡¶æ•°ç»„"
        B0[Bucket 0]
        B1[Bucket 1]
        B2[Bucket 2]
        B3[Bucket 3]
        B4[Bucket 4]
    end
    
    Key1["Key: 'apple'"] --> Hash
    Key2["Key: 'banana'"] --> Hash
    Key3["Key: 'orange'"] --> Hash
    
    Hash -->|hash=0| B0
    Hash -->|hash=1| B1
    Hash -->|hash=2| B2
    Hash -->|hash=3| B3
    Hash -->|hash=4| B4
    
    B1 --> KV1[["Key: 'apple'<br/>Val: 1"]]
    B2 --> KV2[["Key: 'banana'<br/>Val: 2"]]
    B2 --> KV3[["Key: 'orange'<br/>Val: 3"]]
    
    KV2 -.å†²çªé“¾.-> KV3
    
    style Hash fill:#e1f5ff
    style B0 fill:#f0f0f0
    style B1 fill:#e1ffe1
    style B2 fill:#ffe1e1
    style B3 fill:#f0f0f0
    style B4 fill:#f0f0f0
    style KV1 fill:#fff4e1
    style KV2 fill:#fff4e1
    style KV3 fill:#fff4e1
```

### 6.2 MapåŸºç¡€

```go
package main

import "fmt"

func main() {
    // åˆ›å»ºmap
    m1 := make(map[string]int)
    m2 := map[string]int{
        "apple":  1,
        "banana": 2,
    }
    
    // æ·»åŠ /ä¿®æ”¹
    m1["orange"] = 3
    
    // æŸ¥è¯¢
    value, exists := m1["orange"]
    if exists {
        fmt.Println(value)
    }
    
    // åˆ é™¤
    delete(m1, "orange")
    
    // éå†
    for key, value := range m2 {
        fmt.Printf("%s: %d\n", key, value)
    }
}
```

---

## 7. æ ‘ (Tree)

### 7.1 äºŒå‰æ ‘ç»“æ„å¯è§†åŒ–

```mermaid
graph TD
    subgraph "äºŒå‰æ ‘ç»“æ„"
        Root[æ ¹èŠ‚ç‚¹ Root<br/>Val: 1]
        Left[å·¦å­æ ‘ Left<br/>Val: 2]
        Right[å³å­æ ‘ Right<br/>Val: 3]
        LL[Left-Left<br/>Val: 4]
        LR[Left-Right<br/>Val: 5]
        RL[Right-Left<br/>Val: 6]
        RR[Right-Right<br/>Val: 7]
    end
    
    Root --> Left
    Root --> Right
    Left --> LL
    Left --> LR
    Right --> RL
    Right --> RR
    
    style Root fill:#e1f5ff
    style Left fill:#e1ffe1
    style Right fill:#e1ffe1
    style LL fill:#fff4e1
    style LR fill:#fff4e1
    style RL fill:#fff4e1
    style RR fill:#fff4e1
    
    classDef nodeClass stroke:#333,stroke-width:2px;
    class Root,Left,Right,LL,LR,RL,RR nodeClass;
```

#### äºŒå‰æ ‘éå†é¡ºåºå¯è§†åŒ–

```mermaid
graph TB
    subgraph "å‰åºéå† Pre-order"
        P1[1 æ ¹]
        P2[2 å·¦]
        P3[3 å³]
        P1 --> P2 --> P3
    end
    
    subgraph "ä¸­åºéå† In-order"
        I1[1 å·¦]
        I2[2 æ ¹]
        I3[3 å³]
        I1 --> I2 --> I3
    end
    
    subgraph "ååºéå† Post-order"
        PO1[1 å·¦]
        PO2[2 å³]
        PO3[3 æ ¹]
        PO1 --> PO2 --> PO3
    end
    
    style P1 fill:#ffe1e1
    style I2 fill:#ffe1e1
    style PO3 fill:#ffe1e1
```

### 7.2 äºŒå‰æ ‘å®ç°

```go
package main

import "fmt"

// æ ‘èŠ‚ç‚¹
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

// å‰åºéå†
func preorderTraversal(root *TreeNode) []int {
    if root == nil {
        return []int{}
    }
    
    result := []int{root.Val}
    result = append(result, preorderTraversal(root.Left)...)
    result = append(result, preorderTraversal(root.Right)...)
    return result
}

// ä¸­åºéå†
func inorderTraversal(root *TreeNode) []int {
    if root == nil {
        return []int{}
    }
    
    result := inorderTraversal(root.Left)
    result = append(result, root.Val)
    result = append(result, inorderTraversal(root.Right)...)
    return result
}

// ååºéå†
func postorderTraversal(root *TreeNode) []int {
    if root == nil {
        return []int{}
    }
    
    result := postorderTraversal(root.Left)
    result = append(result, postorderTraversal(root.Right)...)
    result = append(result, root.Val)
    return result
}

func main() {
    root := &TreeNode{Val: 1}
    root.Left = &TreeNode{Val: 2}
    root.Right = &TreeNode{Val: 3}
    
    fmt.Println("å‰åº:", preorderTraversal(root))
    fmt.Println("ä¸­åº:", inorderTraversal(root))
    fmt.Println("ååº:", postorderTraversal(root))
}
```

---

## 8. å›¾ (Graph)

### 8.1 å›¾çš„é‚»æ¥è¡¨å¯è§†åŒ–

```mermaid
graph LR
    subgraph "é¡¶ç‚¹ 0"
        V0[é¡¶ç‚¹ 0]
    end
    
    subgraph "é¡¶ç‚¹ 1"
        V1[é¡¶ç‚¹ 1]
    end
    
    subgraph "é¡¶ç‚¹ 2"
        V2[é¡¶ç‚¹ 2]
    end
    
    subgraph "é¡¶ç‚¹ 3"
        V3[é¡¶ç‚¹ 3]
    end
    
    V0 -->|è¾¹| V1
    V0 -->|è¾¹| V2
    V1 -->|è¾¹| V2
    V2 -->|è¾¹| V3
    
    style V0 fill:#e1f5ff
    style V1 fill:#e1ffe1
    style V2 fill:#fff4e1
    style V3 fill:#ffe1f5
```

#### é‚»æ¥è¡¨å­˜å‚¨ç»“æ„

```mermaid
graph TB
    subgraph "å›¾çš„é‚»æ¥è¡¨è¡¨ç¤º"
        Header[é¡¶ç‚¹æ•°ç»„<br/>vertices]
    end
    
    Header --> V0[é¡¶ç‚¹ 0]
    Header --> V1[é¡¶ç‚¹ 1]
    Header --> V2[é¡¶ç‚¹ 2]
    Header --> V3[é¡¶ç‚¹ 3]
    
    V0 --> E01[â†’ 1] --> E02[â†’ 2] --> Null1[null]
    V1 --> E12[â†’ 2] --> Null2[null]
    V2 --> E23[â†’ 3] --> Null3[null]
    V3 --> Null4[null]
    
    style Header fill:#e1f5ff
    style V0 fill:#e1ffe1
    style V1 fill:#e1ffe1
    style V2 fill:#e1ffe1
    style V3 fill:#e1ffe1
    style E01 fill:#fff4e1
    style E02 fill:#fff4e1
    style E12 fill:#fff4e1
    style E23 fill:#fff4e1
```

### 8.2 é‚»æ¥è¡¨å®ç°

```go
package main

import "fmt"

// å›¾ç»“æ„
type Graph struct {
    vertices map[int][]int
}

// åˆ›å»ºå›¾
func NewGraph() *Graph {
    return &Graph{
        vertices: make(map[int][]int),
    }
}

// æ·»åŠ è¾¹
func (g *Graph) AddEdge(v1, v2 int) {
    g.vertices[v1] = append(g.vertices[v1], v2)
    // å¦‚æœæ˜¯æ— å‘å›¾,æ·»åŠ åå‘è¾¹
    // g.vertices[v2] = append(g.vertices[v2], v1)
}

// æ‰“å°å›¾
func (g *Graph) Print() {
    for vertex, edges := range g.vertices {
        fmt.Printf("%d -> %v\n", vertex, edges)
    }
}

func main() {
    graph := NewGraph()
    graph.AddEdge(0, 1)
    graph.AddEdge(0, 2)
    graph.AddEdge(1, 2)
    graph.AddEdge(2, 3)
    
    graph.Print()
}
```

---

## ğŸ’¡ æ€»ç»“

æœ¬ç« ä»‹ç»äº†Goè¯­è¨€ä¸­çš„åŸºç¡€æ•°æ®ç»“æ„:

| æ•°æ®ç»“æ„ | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ |
|---------|------|---------|
| æ•°ç»„ | å›ºå®šå¤§å°,è¿ç»­å†…å­˜ | å›ºå®šé•¿åº¦æ•°æ® |
| åˆ‡ç‰‡ | åŠ¨æ€å¤§å°,å¼•ç”¨ç±»å‹ | åŠ¨æ€æ•°æ®é›†åˆ |
| é“¾è¡¨ | åŠ¨æ€æ’å…¥åˆ é™¤ | é¢‘ç¹æ’å…¥åˆ é™¤ |
| æ ˆ | åè¿›å…ˆå‡º (LIFO) | å‡½æ•°è°ƒç”¨,è¡¨è¾¾å¼æ±‚å€¼ |
| é˜Ÿåˆ— | å…ˆè¿›å…ˆå‡º (FIFO) | ä»»åŠ¡è°ƒåº¦,BFS |
| å“ˆå¸Œè¡¨ | O(1)æŸ¥æ‰¾ | å¿«é€ŸæŸ¥æ‰¾,å»é‡ |
| æ ‘ | å±‚æ¬¡ç»“æ„ | æ–‡ä»¶ç³»ç»Ÿ,æœç´¢ |
| å›¾ | èŠ‚ç‚¹å…³ç³» | ç¤¾äº¤ç½‘ç»œ,è·¯å¾„æŸ¥æ‰¾ |

---

## ğŸ”— ç›¸å…³ç« èŠ‚

- [02-å¸¸ç”¨ç®—æ³•](02-å¸¸ç”¨ç®—æ³•.md) - æ•°æ®ç»“æ„åº”ç”¨
- [03-ç®—æ³•æ¨¡å¼](03-ç®—æ³•æ¨¡å¼.md) - è§£é¢˜æŠ€å·§
- [04-å®æˆ˜æ¡ˆä¾‹](04-å®æˆ˜æ¡ˆä¾‹.md) - LeetCodeé¢˜ç›®

---

**ç»´æŠ¤è€…**: Documentation Team  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22  
**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£çŠ¶æ€**: âœ… åˆç¨¿å®Œæˆ
