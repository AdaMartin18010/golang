# Go 1.25.3 åˆ†å¸ƒå¼ç¼“å­˜æ¶æ„å®Œæ•´å®æˆ˜

**æ–‡æ¡£ç±»å‹**: åˆ†å¸ƒå¼ç¼“å­˜æ¶æ„æŒ‡å—  
**Goç‰ˆæœ¬**: Go 1.25.3  
**éš¾åº¦ç­‰çº§**: â­â­â­â­â­ (ä¸“å®¶çº§)  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ22æ—¥

---


## ğŸ“‹ ç›®å½•


- [ğŸ“– æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
- [ç›®å½•](#ç›®å½•)
- [1. Redisæ·±åº¦å®æˆ˜](#1-redisæ·±åº¦å®æˆ˜)
  - [1.1 Rediså®¢æˆ·ç«¯å°è£…](#11-rediså®¢æˆ·ç«¯å°è£…)
  - [1.2 Pipelineæ‰¹é‡æ“ä½œ](#12-pipelineæ‰¹é‡æ“ä½œ)
- [2. æœ¬åœ°ç¼“å­˜](#2-æœ¬åœ°ç¼“å­˜)
  - [2.1 LRUæœ¬åœ°ç¼“å­˜](#21-lruæœ¬åœ°ç¼“å­˜)
  - [2.2 å®šæ—¶æ¸…ç†è¿‡æœŸç¼“å­˜](#22-å®šæ—¶æ¸…ç†è¿‡æœŸç¼“å­˜)
- [3. å¤šçº§ç¼“å­˜](#3-å¤šçº§ç¼“å­˜)
  - [3.1 å¤šçº§ç¼“å­˜æ¶æ„](#31-å¤šçº§ç¼“å­˜æ¶æ„)
- [4. ç¼“å­˜æ¨¡å¼](#4-ç¼“å­˜æ¨¡å¼)
  - [4.1 Cache-Asideæ¨¡å¼](#41-cache-asideæ¨¡å¼)
  - [4.2 Read-Throughæ¨¡å¼](#42-read-throughæ¨¡å¼)
  - [4.3 Write-Throughæ¨¡å¼](#43-write-throughæ¨¡å¼)
- [5. ç¼“å­˜é—®é¢˜è§£å†³](#5-ç¼“å­˜é—®é¢˜è§£å†³)
  - [5.1 ç¼“å­˜ç©¿é€è§£å†³](#51-ç¼“å­˜ç©¿é€è§£å†³)
  - [5.2 ç¼“å­˜å‡»ç©¿è§£å†³ï¼ˆå•é£ï¼‰](#52-ç¼“å­˜å‡»ç©¿è§£å†³å•é£)
  - [5.3 ç¼“å­˜é›ªå´©è§£å†³](#53-ç¼“å­˜é›ªå´©è§£å†³)
- [6. åˆ†å¸ƒå¼é”](#6-åˆ†å¸ƒå¼é”)
  - [6.1 Redisåˆ†å¸ƒå¼é”](#61-redisåˆ†å¸ƒå¼é”)
  - [6.2 è‡ªåŠ¨ç»­æœŸé”](#62-è‡ªåŠ¨ç»­æœŸé”)
- [7. ç¼“å­˜ç­–ç•¥](#7-ç¼“å­˜ç­–ç•¥)
  - [7.1 ç¼“å­˜æ›´æ–°ç­–ç•¥](#71-ç¼“å­˜æ›´æ–°ç­–ç•¥)
  - [7.2 ç¼“å­˜é¢„çƒ­](#72-ç¼“å­˜é¢„çƒ­)
- [8. å®Œæ•´æ¡ˆä¾‹](#8-å®Œæ•´æ¡ˆä¾‹)
  - [8.1 ç”µå•†å•†å“ç¼“å­˜ç³»ç»Ÿ](#81-ç”µå•†å•†å“ç¼“å­˜ç³»ç»Ÿ)
- [ğŸ“š ç¼“å­˜æ¶æ„æœ€ä½³å®è·µ](#-ç¼“å­˜æ¶æ„æœ€ä½³å®è·µ)
  - [ç¼“å­˜é€‰å‹](#ç¼“å­˜é€‰å‹)
  - [ç¼“å­˜ç­–ç•¥](#ç¼“å­˜ç­–ç•¥)
  - [é—®é¢˜é˜²æŠ¤](#é—®é¢˜é˜²æŠ¤)
- [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

## ğŸ“– æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£å±•ç¤ºGo 1.25.3çš„**åˆ†å¸ƒå¼ç¼“å­˜æ¶æ„å®Œæ•´æ–¹æ¡ˆ**ï¼Œæ„å»ºé«˜æ€§èƒ½ç¼“å­˜ç³»ç»Ÿï¼š

- âœ… Redisæ·±åº¦å®æˆ˜
- âœ… æœ¬åœ°ç¼“å­˜ä¼˜åŒ–
- âœ… å¤šçº§ç¼“å­˜æ¶æ„
- âœ… ç¼“å­˜ä¸€è‡´æ€§
- âœ… ç¼“å­˜ç©¿é€/å‡»ç©¿/é›ªå´©
- âœ… åˆ†å¸ƒå¼é”
- âœ… ç¼“å­˜é¢„çƒ­ä¸æ›´æ–°

---

## ç›®å½•

- [Go 1.25.3 åˆ†å¸ƒå¼ç¼“å­˜æ¶æ„å®Œæ•´å®æˆ˜](#go-1253-åˆ†å¸ƒå¼ç¼“å­˜æ¶æ„å®Œæ•´å®æˆ˜)
  - [ğŸ“– æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. Redisæ·±åº¦å®æˆ˜](#1-redisæ·±åº¦å®æˆ˜)
    - [1.1 Rediså®¢æˆ·ç«¯å°è£…](#11-rediså®¢æˆ·ç«¯å°è£…)
    - [1.2 Pipelineæ‰¹é‡æ“ä½œ](#12-pipelineæ‰¹é‡æ“ä½œ)
  - [2. æœ¬åœ°ç¼“å­˜](#2-æœ¬åœ°ç¼“å­˜)
    - [2.1 LRUæœ¬åœ°ç¼“å­˜](#21-lruæœ¬åœ°ç¼“å­˜)
    - [2.2 å®šæ—¶æ¸…ç†è¿‡æœŸç¼“å­˜](#22-å®šæ—¶æ¸…ç†è¿‡æœŸç¼“å­˜)
  - [3. å¤šçº§ç¼“å­˜](#3-å¤šçº§ç¼“å­˜)
    - [3.1 å¤šçº§ç¼“å­˜æ¶æ„](#31-å¤šçº§ç¼“å­˜æ¶æ„)
  - [4. ç¼“å­˜æ¨¡å¼](#4-ç¼“å­˜æ¨¡å¼)
    - [4.1 Cache-Asideæ¨¡å¼](#41-cache-asideæ¨¡å¼)
    - [4.2 Read-Throughæ¨¡å¼](#42-read-throughæ¨¡å¼)
    - [4.3 Write-Throughæ¨¡å¼](#43-write-throughæ¨¡å¼)
  - [5. ç¼“å­˜é—®é¢˜è§£å†³](#5-ç¼“å­˜é—®é¢˜è§£å†³)
    - [5.1 ç¼“å­˜ç©¿é€è§£å†³](#51-ç¼“å­˜ç©¿é€è§£å†³)
    - [5.2 ç¼“å­˜å‡»ç©¿è§£å†³ï¼ˆå•é£ï¼‰](#52-ç¼“å­˜å‡»ç©¿è§£å†³å•é£)
    - [5.3 ç¼“å­˜é›ªå´©è§£å†³](#53-ç¼“å­˜é›ªå´©è§£å†³)
  - [6. åˆ†å¸ƒå¼é”](#6-åˆ†å¸ƒå¼é”)
    - [6.1 Redisåˆ†å¸ƒå¼é”](#61-redisåˆ†å¸ƒå¼é”)
    - [6.2 è‡ªåŠ¨ç»­æœŸé”](#62-è‡ªåŠ¨ç»­æœŸé”)
  - [7. ç¼“å­˜ç­–ç•¥](#7-ç¼“å­˜ç­–ç•¥)
    - [7.1 ç¼“å­˜æ›´æ–°ç­–ç•¥](#71-ç¼“å­˜æ›´æ–°ç­–ç•¥)
    - [7.2 ç¼“å­˜é¢„çƒ­](#72-ç¼“å­˜é¢„çƒ­)
  - [8. å®Œæ•´æ¡ˆä¾‹](#8-å®Œæ•´æ¡ˆä¾‹)
    - [8.1 ç”µå•†å•†å“ç¼“å­˜ç³»ç»Ÿ](#81-ç”µå•†å•†å“ç¼“å­˜ç³»ç»Ÿ)
  - [ğŸ“š ç¼“å­˜æ¶æ„æœ€ä½³å®è·µ](#-ç¼“å­˜æ¶æ„æœ€ä½³å®è·µ)
    - [ç¼“å­˜é€‰å‹](#ç¼“å­˜é€‰å‹)
    - [ç¼“å­˜ç­–ç•¥](#ç¼“å­˜ç­–ç•¥)
    - [é—®é¢˜é˜²æŠ¤](#é—®é¢˜é˜²æŠ¤)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

---

## 1. Redisæ·±åº¦å®æˆ˜

### 1.1 Rediså®¢æˆ·ç«¯å°è£…

```go
package cache

import (
 "context"
 "encoding/json"
 "fmt"
 "time"
 
 "github.com/redis/go-redis/v9"
)

// RedisCache Redisç¼“å­˜
type RedisCache struct {
 client *redis.Client
 prefix string
}

// NewRedisCache åˆ›å»ºRedisç¼“å­˜
func NewRedisCache(addr, password string, db int, prefix string) (*RedisCache, error) {
 client := redis.NewClient(&redis.Options{
  Addr:         addr,
  Password:     password,
  DB:           db,
  PoolSize:     100,
  MinIdleConns: 10,
 })
 
 // æµ‹è¯•è¿æ¥
 ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
 defer cancel()
 
 if err := client.Ping(ctx).Err(); err != nil {
  return nil, fmt.Errorf("failed to connect to redis: %w", err)
 }
 
 return &RedisCache{
  client: client,
  prefix: prefix,
 }, nil
}

// buildKey æ„å»ºé”®
func (rc *RedisCache) buildKey(key string) string {
 if rc.prefix == "" {
  return key
 }
 return fmt.Sprintf("%s:%s", rc.prefix, key)
}

// Get è·å–ç¼“å­˜
func (rc *RedisCache) Get(ctx context.Context, key string, dest interface{}) error {
 fullKey := rc.buildKey(key)
 
 data, err := rc.client.Get(ctx, fullKey).Bytes()
 if err == redis.Nil {
  return ErrCacheMiss
 }
 if err != nil {
  return err
 }
 
 return json.Unmarshal(data, dest)
}

// Set è®¾ç½®ç¼“å­˜
func (rc *RedisCache) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error {
 fullKey := rc.buildKey(key)
 
 data, err := json.Marshal(value)
 if err != nil {
  return err
 }
 
 return rc.client.Set(ctx, fullKey, data, ttl).Err()
}

// Delete åˆ é™¤ç¼“å­˜
func (rc *RedisCache) Delete(ctx context.Context, keys ...string) error {
 fullKeys := make([]string, len(keys))
 for i, key := range keys {
  fullKeys[i] = rc.buildKey(key)
 }
 
 return rc.client.Del(ctx, fullKeys...).Err()
}

// Exists æ£€æŸ¥å­˜åœ¨
func (rc *RedisCache) Exists(ctx context.Context, key string) (bool, error) {
 fullKey := rc.buildKey(key)
 
 count, err := rc.client.Exists(ctx, fullKey).Result()
 if err != nil {
  return false, err
 }
 
 return count > 0, nil
}

// TTL è·å–è¿‡æœŸæ—¶é—´
func (rc *RedisCache) TTL(ctx context.Context, key string) (time.Duration, error) {
 fullKey := rc.buildKey(key)
 return rc.client.TTL(ctx, fullKey).Result()
}

// Expire è®¾ç½®è¿‡æœŸæ—¶é—´
func (rc *RedisCache) Expire(ctx context.Context, key string, ttl time.Duration) error {
 fullKey := rc.buildKey(key)
 return rc.client.Expire(ctx, fullKey, ttl).Err()
}
```

---

### 1.2 Pipelineæ‰¹é‡æ“ä½œ

```go
// MGet æ‰¹é‡è·å–
func (rc *RedisCache) MGet(ctx context.Context, keys []string) (map[string]interface{}, error) {
 if len(keys) == 0 {
  return make(map[string]interface{}), nil
 }
 
 // æ„å»ºå®Œæ•´é”®
 fullKeys := make([]string, len(keys))
 for i, key := range keys {
  fullKeys[i] = rc.buildKey(key)
 }
 
 // æ‰§è¡ŒMGet
 values, err := rc.client.MGet(ctx, fullKeys...).Result()
 if err != nil {
  return nil, err
 }
 
 // è§£æç»“æœ
 result := make(map[string]interface{})
 for i, val := range values {
  if val != nil {
   result[keys[i]] = val
  }
 }
 
 return result, nil
}

// MSet æ‰¹é‡è®¾ç½®
func (rc *RedisCache) MSet(ctx context.Context, items map[string]interface{}, ttl time.Duration) error {
 if len(items) == 0 {
  return nil
 }
 
 pipe := rc.client.Pipeline()
 
 for key, value := range items {
  fullKey := rc.buildKey(key)
  
  data, err := json.Marshal(value)
  if err != nil {
   return err
  }
  
  pipe.Set(ctx, fullKey, data, ttl)
 }
 
 _, err := pipe.Exec(ctx)
 return err
}

// DeletePattern åˆ é™¤åŒ¹é…çš„é”®
func (rc *RedisCache) DeletePattern(ctx context.Context, pattern string) error {
 fullPattern := rc.buildKey(pattern)
 
 iter := rc.client.Scan(ctx, 0, fullPattern, 0).Iterator()
 
 pipe := rc.client.Pipeline()
 count := 0
 
 for iter.Next(ctx) {
  pipe.Del(ctx, iter.Val())
  count++
  
  // æ¯100ä¸ªé”®æ‰§è¡Œä¸€æ¬¡
  if count%100 == 0 {
   if _, err := pipe.Exec(ctx); err != nil {
    return err
   }
  }
 }
 
 if err := iter.Err(); err != nil {
  return err
 }
 
 if count%100 != 0 {
  _, err := pipe.Exec(ctx)
  return err
 }
 
 return nil
}
```

---

## 2. æœ¬åœ°ç¼“å­˜

### 2.1 LRUæœ¬åœ°ç¼“å­˜

```go
package localcache

import (
 "container/list"
 "sync"
 "time"
)

// LRUCache LRUç¼“å­˜
type LRUCache struct {
 capacity int
 items    map[string]*list.Element
 lru      *list.List
 mu       sync.RWMutex
}

// entry ç¼“å­˜æ¡ç›®
type entry struct {
 key       string
 value     interface{}
 expireAt  time.Time
}

// NewLRUCache åˆ›å»ºLRUç¼“å­˜
func NewLRUCache(capacity int) *LRUCache {
 return &LRUCache{
  capacity: capacity,
  items:    make(map[string]*list.Element),
  lru:      list.New(),
 }
}

// Get è·å–
func (lc *LRUCache) Get(key string) (interface{}, bool) {
 lc.mu.Lock()
 defer lc.mu.Unlock()
 
 elem, ok := lc.items[key]
 if !ok {
  return nil, false
 }
 
 // æ£€æŸ¥è¿‡æœŸ
 entry := elem.Value.(*entry)
 if !entry.expireAt.IsZero() && time.Now().After(entry.expireAt) {
  lc.removeElement(elem)
  return nil, false
 }
 
 // ç§»åˆ°æœ€å‰é¢
 lc.lru.MoveToFront(elem)
 
 return entry.value, true
}

// Set è®¾ç½®
func (lc *LRUCache) Set(key string, value interface{}, ttl time.Duration) {
 lc.mu.Lock()
 defer lc.mu.Unlock()
 
 // è®¡ç®—è¿‡æœŸæ—¶é—´
 var expireAt time.Time
 if ttl > 0 {
  expireAt = time.Now().Add(ttl)
 }
 
 // å¦‚æœå·²å­˜åœ¨ï¼Œæ›´æ–°
 if elem, ok := lc.items[key]; ok {
  entry := elem.Value.(*entry)
  entry.value = value
  entry.expireAt = expireAt
  lc.lru.MoveToFront(elem)
  return
 }
 
 // æ£€æŸ¥å®¹é‡
 if lc.lru.Len() >= lc.capacity {
  // åˆ é™¤æœ€å°‘ä½¿ç”¨çš„
  lc.removeElement(lc.lru.Back())
 }
 
 // æ·»åŠ æ–°æ¡ç›®
 entry := &entry{
  key:      key,
  value:    value,
  expireAt: expireAt,
 }
 elem := lc.lru.PushFront(entry)
 lc.items[key] = elem
}

// Delete åˆ é™¤
func (lc *LRUCache) Delete(key string) {
 lc.mu.Lock()
 defer lc.mu.Unlock()
 
 if elem, ok := lc.items[key]; ok {
  lc.removeElement(elem)
 }
}

// removeElement åˆ é™¤å…ƒç´ 
func (lc *LRUCache) removeElement(elem *list.Element) {
 entry := elem.Value.(*entry)
 delete(lc.items, entry.key)
 lc.lru.Remove(elem)
}

// Clear æ¸…ç©º
func (lc *LRUCache) Clear() {
 lc.mu.Lock()
 defer lc.mu.Unlock()
 
 lc.items = make(map[string]*list.Element)
 lc.lru.Init()
}

// Len é•¿åº¦
func (lc *LRUCache) Len() int {
 lc.mu.RLock()
 defer lc.mu.RUnlock()
 
 return lc.lru.Len()
}
```

---

### 2.2 å®šæ—¶æ¸…ç†è¿‡æœŸç¼“å­˜

```go
// StartCleanup å¯åŠ¨å®šæ—¶æ¸…ç†
func (lc *LRUCache) StartCleanup(interval time.Duration, done <-chan struct{}) {
 ticker := time.NewTicker(interval)
 defer ticker.Stop()
 
 for {
  select {
  case <-ticker.C:
   lc.cleanup()
  case <-done:
   return
  }
 }
}

// cleanup æ¸…ç†è¿‡æœŸç¼“å­˜
func (lc *LRUCache) cleanup() {
 lc.mu.Lock()
 defer lc.mu.Unlock()
 
 now := time.Now()
 
 // ä»åå¾€å‰éå†ï¼ˆåé¢æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„ï¼‰
 for elem := lc.lru.Back(); elem != nil; {
  entry := elem.Value.(*entry)
  
  // å¦‚æœæœªè¿‡æœŸä¸”åé¢çš„æ›´ä¸å¯èƒ½è¿‡æœŸï¼Œåœæ­¢
  if entry.expireAt.IsZero() || now.Before(entry.expireAt) {
   break
  }
  
  // åˆ é™¤è¿‡æœŸæ¡ç›®
  prev := elem.Prev()
  lc.removeElement(elem)
  elem = prev
 }
}
```

---

## 3. å¤šçº§ç¼“å­˜

### 3.1 å¤šçº§ç¼“å­˜æ¶æ„

```go
package multilevelcache

import (
 "context"
 "time"
)

// MultiLevelCache å¤šçº§ç¼“å­˜
type MultiLevelCache struct {
 l1       *localcache.LRUCache
 l2       *cache.RedisCache
 l1TTL    time.Duration
 l2TTL    time.Duration
 loader   DataLoader
}

// DataLoader æ•°æ®åŠ è½½å™¨
type DataLoader func(ctx context.Context, key string) (interface{}, error)

// NewMultiLevelCache åˆ›å»ºå¤šçº§ç¼“å­˜
func NewMultiLevelCache(
 l1Capacity int,
 l1TTL time.Duration,
 redis *cache.RedisCache,
 l2TTL time.Duration,
 loader DataLoader,
) *MultiLevelCache {
 return &MultiLevelCache{
  l1:     localcache.NewLRUCache(l1Capacity),
  l2:     redis,
  l1TTL:  l1TTL,
  l2TTL:  l2TTL,
  loader: loader,
 }
}

// Get è·å–ç¼“å­˜
func (mlc *MultiLevelCache) Get(ctx context.Context, key string) (interface{}, error) {
 // 1. æŸ¥è¯¢L1ç¼“å­˜
 if value, ok := mlc.l1.Get(key); ok {
  return value, nil
 }
 
 // 2. æŸ¥è¯¢L2ç¼“å­˜
 var value interface{}
 err := mlc.l2.Get(ctx, key, &value)
 if err == nil {
  // å›å¡«L1ç¼“å­˜
  mlc.l1.Set(key, value, mlc.l1TTL)
  return value, nil
 }
 
 if err != cache.ErrCacheMiss {
  return nil, err
 }
 
 // 3. ä»æ•°æ®æºåŠ è½½
 value, err = mlc.loader(ctx, key)
 if err != nil {
  return nil, err
 }
 
 // 4. å†™å…¥å¤šçº§ç¼“å­˜
 go func() {
  // å¼‚æ­¥å†™å…¥ï¼Œä¸å½±å“ä¸»æµç¨‹
  mlc.Set(context.Background(), key, value)
 }()
 
 return value, nil
}

// Set è®¾ç½®ç¼“å­˜
func (mlc *MultiLevelCache) Set(ctx context.Context, key string, value interface{}) error {
 // å†™å…¥L1
 mlc.l1.Set(key, value, mlc.l1TTL)
 
 // å†™å…¥L2
 return mlc.l2.Set(ctx, key, value, mlc.l2TTL)
}

// Delete åˆ é™¤ç¼“å­˜
func (mlc *MultiLevelCache) Delete(ctx context.Context, key string) error {
 // åˆ é™¤L1
 mlc.l1.Delete(key)
 
 // åˆ é™¤L2
 return mlc.l2.Delete(ctx, key)
}
```

---

## 4. ç¼“å­˜æ¨¡å¼

### 4.1 Cache-Asideæ¨¡å¼

```go
// CacheAsidePattern Cache-Asideæ¨¡å¼
type CacheAsidePattern struct {
 cache  *cache.RedisCache
 db     *sql.DB
}

// GetUser è·å–ç”¨æˆ·ï¼ˆCache-Asideï¼‰
func (cap *CacheAsidePattern) GetUser(ctx context.Context, userID string) (*User, error) {
 key := fmt.Sprintf("user:%s", userID)
 
 // 1. æŸ¥è¯¢ç¼“å­˜
 var user User
 err := cap.cache.Get(ctx, key, &user)
 if err == nil {
  return &user, nil
 }
 
 if err != cache.ErrCacheMiss {
  return nil, err
 }
 
 // 2. æŸ¥è¯¢æ•°æ®åº“
 err = cap.db.QueryRowContext(ctx, "SELECT id, name, email FROM users WHERE id = ?", userID).
  Scan(&user.ID, &user.Name, &user.Email)
 if err != nil {
  return nil, err
 }
 
 // 3. å†™å…¥ç¼“å­˜
 cap.cache.Set(ctx, key, &user, 1*time.Hour)
 
 return &user, nil
}

// UpdateUser æ›´æ–°ç”¨æˆ·
func (cap *CacheAsidePattern) UpdateUser(ctx context.Context, user *User) error {
 // 1. æ›´æ–°æ•°æ®åº“
 _, err := cap.db.ExecContext(ctx,
  "UPDATE users SET name = ?, email = ? WHERE id = ?",
  user.Name, user.Email, user.ID)
 if err != nil {
  return err
 }
 
 // 2. åˆ é™¤ç¼“å­˜
 key := fmt.Sprintf("user:%s", user.ID)
 return cap.cache.Delete(ctx, key)
}
```

---

### 4.2 Read-Throughæ¨¡å¼

```go
// ReadThroughCache Read-Throughç¼“å­˜
type ReadThroughCache struct {
 cache  *cache.RedisCache
 loader DataLoader
 ttl    time.Duration
}

// Get è·å–æ•°æ®
func (rtc *ReadThroughCache) Get(ctx context.Context, key string) (interface{}, error) {
 // æŸ¥è¯¢ç¼“å­˜
 var value interface{}
 err := rtc.cache.Get(ctx, key, &value)
 if err == nil {
  return value, nil
 }
 
 if err != cache.ErrCacheMiss {
  return nil, err
 }
 
 // åŠ è½½æ•°æ®
 value, err = rtc.loader(ctx, key)
 if err != nil {
  return nil, err
 }
 
 // å†™å…¥ç¼“å­˜
 rtc.cache.Set(ctx, key, value, rtc.ttl)
 
 return value, nil
}
```

---

### 4.3 Write-Throughæ¨¡å¼

```go
// WriteThroughCache Write-Throughç¼“å­˜
type WriteThroughCache struct {
 cache  *cache.RedisCache
 writer DataWriter
 ttl    time.Duration
}

// DataWriter æ•°æ®å†™å…¥å™¨
type DataWriter func(ctx context.Context, key string, value interface{}) error

// Set è®¾ç½®æ•°æ®
func (wtc *WriteThroughCache) Set(ctx context.Context, key string, value interface{}) error {
 // 1. å†™å…¥æ•°æ®åº“
 if err := wtc.writer(ctx, key, value); err != nil {
  return err
 }
 
 // 2. å†™å…¥ç¼“å­˜
 return wtc.cache.Set(ctx, key, value, wtc.ttl)
}
```

---

## 5. ç¼“å­˜é—®é¢˜è§£å†³

### 5.1 ç¼“å­˜ç©¿é€è§£å†³

```go
// BloomFilter å¸ƒéš†è¿‡æ»¤å™¨
type BloomFilter struct {
 client *redis.Client
 key    string
}

// Add æ·»åŠ å…ƒç´ 
func (bf *BloomFilter) Add(ctx context.Context, item string) error {
 return bf.client.BFAdd(ctx, bf.key, item).Err()
}

// Exists æ£€æŸ¥å­˜åœ¨
func (bf *BloomFilter) Exists(ctx context.Context, item string) (bool, error) {
 return bf.client.BFExists(ctx, bf.key, item).Result()
}

// ç¼“å­˜ç©¿é€é˜²æŠ¤
func (cap *CacheAsidePattern) GetUserWithBloomFilter(ctx context.Context, userID string) (*User, error) {
 // 1. å¸ƒéš†è¿‡æ»¤å™¨æ£€æŸ¥
 exists, err := bloomFilter.Exists(ctx, userID)
 if err != nil {
  return nil, err
 }
 
 if !exists {
  return nil, ErrUserNotFound
 }
 
 // 2. æ­£å¸¸çš„ç¼“å­˜æŸ¥è¯¢æµç¨‹
 return cap.GetUser(ctx, userID)
}
```

---

### 5.2 ç¼“å­˜å‡»ç©¿è§£å†³ï¼ˆå•é£ï¼‰

```go
package singleflight

import (
 "context"
 "sync"
)

// Group å•é£ç»„
type Group struct {
 mu sync.Mutex
 m  map[string]*call
}

// call è°ƒç”¨
type call struct {
 wg  sync.WaitGroup
 val interface{}
 err error
}

// NewGroup åˆ›å»ºå•é£ç»„
func NewGroup() *Group {
 return &Group{
  m: make(map[string]*call),
 }
}

// Do æ‰§è¡Œ
func (g *Group) Do(key string, fn func() (interface{}, error)) (interface{}, error) {
 g.mu.Lock()
 
 if c, ok := g.m[key]; ok {
  g.mu.Unlock()
  c.wg.Wait()
  return c.val, c.err
 }
 
 c := &call{}
 c.wg.Add(1)
 g.m[key] = c
 g.mu.Unlock()
 
 c.val, c.err = fn()
 c.wg.Done()
 
 g.mu.Lock()
 delete(g.m, key)
 g.mu.Unlock()
 
 return c.val, c.err
}

// ä½¿ç”¨å•é£é˜²æ­¢ç¼“å­˜å‡»ç©¿
type CacheWithSingleFlight struct {
 cache *cache.RedisCache
 sf    *Group
 loader DataLoader
}

func (csf *CacheWithSingleFlight) Get(ctx context.Context, key string) (interface{}, error) {
 // æŸ¥è¯¢ç¼“å­˜
 var value interface{}
 err := csf.cache.Get(ctx, key, &value)
 if err == nil {
  return value, nil
 }
 
 // ä½¿ç”¨å•é£åŠ è½½
 return csf.sf.Do(key, func() (interface{}, error) {
  // å†æ¬¡æ£€æŸ¥ç¼“å­˜ï¼ˆå¯èƒ½å·²è¢«å…¶ä»–goroutineåŠ è½½ï¼‰
  var value interface{}
  err := csf.cache.Get(ctx, key, &value)
  if err == nil {
   return value, nil
  }
  
  // åŠ è½½æ•°æ®
  value, err = csf.loader(ctx, key)
  if err != nil {
   return nil, err
  }
  
  // å†™å…¥ç¼“å­˜
  csf.cache.Set(ctx, key, value, 1*time.Hour)
  
  return value, nil
 })
}
```

---

### 5.3 ç¼“å­˜é›ªå´©è§£å†³

```go
// éšæœºTTLé˜²æ­¢é›ªå´©
func (rc *RedisCache) SetWithRandomTTL(ctx context.Context, key string, value interface{}, baseTTL time.Duration) error {
 // æ·»åŠ éšæœºåç§»ï¼ˆÂ±10%ï¼‰
 offset := time.Duration(float64(baseTTL) * (rand.Float64()*0.2 - 0.1))
 ttl := baseTTL + offset
 
 return rc.Set(ctx, key, value, ttl)
}

// ç¼“å­˜é¢„çƒ­
func (rc *RedisCache) Warmup(ctx context.Context, keys []string, loader DataLoader) error {
 for _, key := range keys {
  value, err := loader(ctx, key)
  if err != nil {
   log.Printf("Failed to load key %s: %v", key, err)
   continue
  }
  
  if err := rc.Set(ctx, key, value, 1*time.Hour); err != nil {
   log.Printf("Failed to set key %s: %v", key, err)
  }
 }
 
 return nil
}
```

---

## 6. åˆ†å¸ƒå¼é”

### 6.1 Redisåˆ†å¸ƒå¼é”

```go
package distributedlock

import (
 "context"
 "errors"
 "time"
 
 "github.com/redis/go-redis/v9"
)

// RedisLock Redisåˆ†å¸ƒå¼é”
type RedisLock struct {
 client *redis.Client
 key    string
 value  string
 ttl    time.Duration
}

// NewRedisLock åˆ›å»ºRedisé”
func NewRedisLock(client *redis.Client, key, value string, ttl time.Duration) *RedisLock {
 return &RedisLock{
  client: client,
  key:    key,
  value:  value,
  ttl:    ttl,
 }
}

// Lock åŠ é”
func (rl *RedisLock) Lock(ctx context.Context) error {
 // ä½¿ç”¨SET NX EXå®ç°
 ok, err := rl.client.SetNX(ctx, rl.key, rl.value, rl.ttl).Result()
 if err != nil {
  return err
 }
 
 if !ok {
  return errors.New("failed to acquire lock")
 }
 
 return nil
}

// Unlock è§£é”
func (rl *RedisLock) Unlock(ctx context.Context) error {
 // Luaè„šæœ¬ç¡®ä¿åªåˆ é™¤è‡ªå·±çš„é”
 script := `
  if redis.call("get", KEYS[1]) == ARGV[1] then
   return redis.call("del", KEYS[1])
  else
   return 0
  end
 `
 
 result, err := rl.client.Eval(ctx, script, []string{rl.key}, rl.value).Int()
 if err != nil {
  return err
 }
 
 if result == 0 {
  return errors.New("lock not held")
 }
 
 return nil
}

// TryLock å°è¯•åŠ é”
func (rl *RedisLock) TryLock(ctx context.Context, maxRetries int, retryDelay time.Duration) error {
 for i := 0; i < maxRetries; i++ {
  err := rl.Lock(ctx)
  if err == nil {
   return nil
  }
  
  if i < maxRetries-1 {
   time.Sleep(retryDelay)
  }
 }
 
 return errors.New("failed to acquire lock after retries")
}

// Renew ç»­æœŸ
func (rl *RedisLock) Renew(ctx context.Context) error {
 // Luaè„šæœ¬ç¡®ä¿åªç»­æœŸè‡ªå·±çš„é”
 script := `
  if redis.call("get", KEYS[1]) == ARGV[1] then
   return redis.call("expire", KEYS[1], ARGV[2])
  else
   return 0
  end
 `
 
 result, err := rl.client.Eval(ctx, script, []string{rl.key}, rl.value, int(rl.ttl.Seconds())).Int()
 if err != nil {
  return err
 }
 
 if result == 0 {
  return errors.New("lock not held")
 }
 
 return nil
}
```

---

### 6.2 è‡ªåŠ¨ç»­æœŸé”

```go
// AutoRenewLock è‡ªåŠ¨ç»­æœŸé”
type AutoRenewLock struct {
 lock       *RedisLock
 renewInterval time.Duration
 stopRenew  chan struct{}
}

// NewAutoRenewLock åˆ›å»ºè‡ªåŠ¨ç»­æœŸé”
func NewAutoRenewLock(lock *RedisLock) *AutoRenewLock {
 return &AutoRenewLock{
  lock:          lock,
  renewInterval: lock.ttl / 3, // æ¯1/3 TTLç»­æœŸä¸€æ¬¡
  stopRenew:     make(chan struct{}),
 }
}

// Lock åŠ é”å¹¶å¼€å§‹è‡ªåŠ¨ç»­æœŸ
func (arl *AutoRenewLock) Lock(ctx context.Context) error {
 if err := arl.lock.Lock(ctx); err != nil {
  return err
 }
 
 // å¯åŠ¨è‡ªåŠ¨ç»­æœŸ
 go arl.autoRenew(ctx)
 
 return nil
}

// Unlock è§£é”å¹¶åœæ­¢ç»­æœŸ
func (arl *AutoRenewLock) Unlock(ctx context.Context) error {
 // åœæ­¢ç»­æœŸ
 close(arl.stopRenew)
 
 // è§£é”
 return arl.lock.Unlock(ctx)
}

// autoRenew è‡ªåŠ¨ç»­æœŸ
func (arl *AutoRenewLock) autoRenew(ctx context.Context) {
 ticker := time.NewTicker(arl.renewInterval)
 defer ticker.Stop()
 
 for {
  select {
  case <-ticker.C:
   if err := arl.lock.Renew(ctx); err != nil {
    log.Printf("Failed to renew lock: %v", err)
    return
   }
  case <-arl.stopRenew:
   return
  case <-ctx.Done():
   return
  }
 }
}
```

---

## 7. ç¼“å­˜ç­–ç•¥

### 7.1 ç¼“å­˜æ›´æ–°ç­–ç•¥

```go
// UpdateStrategy æ›´æ–°ç­–ç•¥
type UpdateStrategy int

const (
 DeleteCache     UpdateStrategy = iota // åˆ é™¤ç¼“å­˜
 UpdateCache                           // æ›´æ–°ç¼“å­˜
 ExpireCache                           // è¿‡æœŸç¼“å­˜
)

// CacheManager ç¼“å­˜ç®¡ç†å™¨
type CacheManager struct {
 cache    *cache.RedisCache
 db       *sql.DB
 strategy UpdateStrategy
}

// UpdateData æ›´æ–°æ•°æ®
func (cm *CacheManager) UpdateData(ctx context.Context, key string, data interface{}) error {
 // 1. æ›´æ–°æ•°æ®åº“
 if err := cm.writeToDatabase(ctx, key, data); err != nil {
  return err
 }
 
 // 2. æ ¹æ®ç­–ç•¥å¤„ç†ç¼“å­˜
 switch cm.strategy {
 case DeleteCache:
  return cm.cache.Delete(ctx, key)
  
 case UpdateCache:
  return cm.cache.Set(ctx, key, data, 1*time.Hour)
  
 case ExpireCache:
  return cm.cache.Expire(ctx, key, 1*time.Minute)
  
 default:
  return nil
 }
}
```

---

### 7.2 ç¼“å­˜é¢„çƒ­

```go
// Warmer ç¼“å­˜é¢„çƒ­å™¨
type Warmer struct {
 cache   *cache.RedisCache
 loader  DataLoader
 keys    []string
}

// Warmup é¢„çƒ­
func (w *Warmer) Warmup(ctx context.Context) error {
 log.Println("Starting cache warmup...")
 
 errChan := make(chan error, len(w.keys))
 sem := make(chan struct{}, 10) // å¹¶å‘æ§åˆ¶
 
 var wg sync.WaitGroup
 
 for _, key := range w.keys {
  wg.Add(1)
  
  go func(k string) {
   defer wg.Done()
   
   sem <- struct{}{}
   defer func() { <-sem }()
   
   // åŠ è½½æ•°æ®
   value, err := w.loader(ctx, k)
   if err != nil {
    errChan <- fmt.Errorf("failed to load %s: %w", k, err)
    return
   }
   
   // å†™å…¥ç¼“å­˜
   if err := w.cache.Set(ctx, k, value, 24*time.Hour); err != nil {
    errChan <- fmt.Errorf("failed to cache %s: %w", k, err)
   }
  }(key)
 }
 
 wg.Wait()
 close(errChan)
 
 // æ”¶é›†é”™è¯¯
 var errors []error
 for err := range errChan {
  errors = append(errors, err)
  log.Println(err)
 }
 
 log.Printf("Cache warmup completed. Success: %d, Failed: %d", 
  len(w.keys)-len(errors), len(errors))
 
 return nil
}
```

---

## 8. å®Œæ•´æ¡ˆä¾‹

### 8.1 ç”µå•†å•†å“ç¼“å­˜ç³»ç»Ÿ

```go
package productcache

import (
 "context"
 "fmt"
 "time"
)

// ProductCacheService å•†å“ç¼“å­˜æœåŠ¡
type ProductCacheService struct {
 l1Cache    *localcache.LRUCache
 l2Cache    *cache.RedisCache
 db         *sql.DB
 sf         *singleflight.Group
 bloomFilter *BloomFilter
 lock       *distributedlock.RedisLock
}

// GetProduct è·å–å•†å“
func (pcs *ProductCacheService) GetProduct(ctx context.Context, productID string) (*Product, error) {
 key := fmt.Sprintf("product:%s", productID)
 
 // 1. å¸ƒéš†è¿‡æ»¤å™¨æ£€æŸ¥
 exists, err := pcs.bloomFilter.Exists(ctx, productID)
 if err != nil {
  return nil, err
 }
 
 if !exists {
  return nil, ErrProductNotFound
 }
 
 // 2. L1ç¼“å­˜
 if value, ok := pcs.l1Cache.Get(key); ok {
  return value.(*Product), nil
 }
 
 // 3. L2ç¼“å­˜ + å•é£
 value, err := pcs.sf.Do(key, func() (interface{}, error) {
  var product Product
  err := pcs.l2Cache.Get(ctx, key, &product)
  if err == nil {
   return &product, nil
  }
  
  // 4. æ•°æ®åº“
  product, err = pcs.loadFromDatabase(ctx, productID)
  if err != nil {
   return nil, err
  }
  
  // 5. å†™å…¥ç¼“å­˜
  go func() {
   pcs.l1Cache.Set(key, &product, 5*time.Minute)
   pcs.l2Cache.SetWithRandomTTL(context.Background(), key, &product, 1*time.Hour)
  }()
  
  return &product, nil
 })
 
 if err != nil {
  return nil, err
 }
 
 return value.(*Product), nil
}

// UpdateProduct æ›´æ–°å•†å“
func (pcs *ProductCacheService) UpdateProduct(ctx context.Context, product *Product) error {
 key := fmt.Sprintf("product:%s", product.ID)
 
 // 1. è·å–åˆ†å¸ƒå¼é”
 lock := distributedlock.NewRedisLock(pcs.l2Cache.client, key+":lock", "update", 5*time.Second)
 if err := lock.TryLock(ctx, 3, 100*time.Millisecond); err != nil {
  return err
 }
 defer lock.Unlock(ctx)
 
 // 2. æ›´æ–°æ•°æ®åº“
 if err := pcs.updateDatabase(ctx, product); err != nil {
  return err
 }
 
 // 3. åˆ é™¤ç¼“å­˜ï¼ˆæ¨èï¼‰æˆ–æ›´æ–°ç¼“å­˜
 pcs.l1Cache.Delete(key)
 pcs.l2Cache.Delete(ctx, key)
 
 return nil
}

// BatchGetProducts æ‰¹é‡è·å–å•†å“
func (pcs *ProductCacheService) BatchGetProducts(ctx context.Context, productIDs []string) (map[string]*Product, error) {
 result := make(map[string]*Product)
 missedKeys := make([]string, 0)
 
 // 1. æ‰¹é‡ä»L2ç¼“å­˜è·å–
 keys := make([]string, len(productIDs))
 for i, id := range productIDs {
  keys[i] = fmt.Sprintf("product:%s", id)
 }
 
 cached, err := pcs.l2Cache.MGet(ctx, keys)
 if err != nil {
  return nil, err
 }
 
 // 2. æ”¶é›†æœªå‘½ä¸­çš„é”®
 for i, key := range keys {
  if value, ok := cached[key]; ok {
   var product Product
   if err := json.Unmarshal([]byte(value.(string)), &product); err == nil {
    result[productIDs[i]] = &product
   }
  } else {
   missedKeys = append(missedKeys, productIDs[i])
  }
 }
 
 // 3. æ‰¹é‡ä»æ•°æ®åº“åŠ è½½æœªå‘½ä¸­çš„
 if len(missedKeys) > 0 {
  products, err := pcs.batchLoadFromDatabase(ctx, missedKeys)
  if err != nil {
   return nil, err
  }
  
  // 4. å†™å…¥ç¼“å­˜
  cacheItems := make(map[string]interface{})
  for id, product := range products {
   result[id] = product
   cacheItems[fmt.Sprintf("product:%s", id)] = product
  }
  
  go pcs.l2Cache.MSet(context.Background(), cacheItems, 1*time.Hour)
 }
 
 return result, nil
}
```

---

## ğŸ“š ç¼“å­˜æ¶æ„æœ€ä½³å®è·µ

### ç¼“å­˜é€‰å‹

- **æœ¬åœ°ç¼“å­˜**: çƒ­ç‚¹æ•°æ®ã€ä½å»¶è¿Ÿè¦æ±‚
- **Redis**: åˆ†å¸ƒå¼ç¼“å­˜ã€æŒä¹…åŒ–éœ€æ±‚
- **å¤šçº§ç¼“å­˜**: é«˜å¹¶å‘ã€å¤§æµé‡åœºæ™¯

### ç¼“å­˜ç­–ç•¥

- âœ… Cache-Asideï¼ˆæ—è·¯ç¼“å­˜ï¼‰- æœ€å¸¸ç”¨
- âœ… Read-Throughï¼ˆè¯»ç©¿é€ï¼‰- å°è£…æ•°æ®æº
- âœ… Write-Throughï¼ˆå†™ç©¿é€ï¼‰- å¼ºä¸€è‡´æ€§
- âœ… Write-Behindï¼ˆå†™å›ï¼‰- é«˜æ€§èƒ½å†™å…¥

### é—®é¢˜é˜²æŠ¤

- âœ… ç¼“å­˜ç©¿é€ï¼šå¸ƒéš†è¿‡æ»¤å™¨ã€ç©ºå€¼ç¼“å­˜
- âœ… ç¼“å­˜å‡»ç©¿ï¼šå•é£ã€åˆ†å¸ƒå¼é”
- âœ… ç¼“å­˜é›ªå´©ï¼šéšæœºTTLã€ç¼“å­˜é¢„çƒ­

---

## ğŸ¯ æ€»ç»“

Go 1.25.3åˆ†å¸ƒå¼ç¼“å­˜å…³é”®ç‚¹ï¼š

1. **Redisæ·±åº¦**: Pipelineã€Luaè„šæœ¬ã€é›†ç¾¤
2. **æœ¬åœ°ç¼“å­˜**: LRUã€TTLã€å®šæ—¶æ¸…ç†
3. **å¤šçº§ç¼“å­˜**: L1+L2ã€å¼‚æ­¥å†™å…¥ã€å›å¡«
4. **ç¼“å­˜æ¨¡å¼**: Cache-Asideã€Read/Write-Through
5. **é—®é¢˜è§£å†³**: ç©¿é€ã€å‡»ç©¿ã€é›ªå´©
6. **åˆ†å¸ƒå¼é”**: SET NXã€Luaè„šæœ¬ã€è‡ªåŠ¨ç»­æœŸ
7. **ç¼“å­˜ç­–ç•¥**: æ›´æ–°ã€é¢„çƒ­ã€æ·˜æ±°

**ç¼“å­˜æ˜¯æ€§èƒ½ä¼˜åŒ–çš„ç¬¬ä¸€åˆ©å™¨ï¼**

---

<div align="center">

**æŒæ¡åˆ†å¸ƒå¼ç¼“å­˜ï¼Œæ„å»ºé«˜æ€§èƒ½ç³»ç»Ÿ**ï¼š

[ğŸ“š è¿”å›ç›®å½•](../README.md) | [ğŸ“– ä¸‹ä¸€ç« ](22-å¾®æœåŠ¡æ²»ç†å®æˆ˜.md)

Made with â¤ï¸ for Go Developers

</div>

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-10-22  
**Goç‰ˆæœ¬**: Go 1.25.3  
**ç”Ÿäº§å°±ç»ª**: âœ…
