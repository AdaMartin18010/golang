# Go 1.25.3 分布式缓存架构完整实战

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---


## 📋 目录


- [📖 文档说明](#文档说明)
- [目录](#目录)
- [1. Redis深度实战](#1.-redis深度实战)
  - [1.1 Redis客户端封装](#11-redis客户端封装)
  - [1.2 Pipeline批量操作](#12-pipeline批量操作)
- [2. 本地缓存](#2.-本地缓存)
  - [2.1 LRU本地缓存](#21-lru本地缓存)
  - [2.2 定时清理过期缓存](#22-定时清理过期缓存)
- [3. 多级缓存](#3.-多级缓存)
  - [3.1 多级缓存架构](#31-多级缓存架构)
- [4. 缓存模式](#4.-缓存模式)
  - [4.1 Cache-Aside模式](#41-cache-aside模式)
  - [4.2 Read-Through模式](#42-read-through模式)
  - [4.3 Write-Through模式](#43-write-through模式)
- [5. 缓存问题解决](#5.-缓存问题解决)
  - [5.1 缓存穿透解决](#51-缓存穿透解决)
  - [5.2 缓存击穿解决（单飞）](#52-缓存击穿解决单飞)
  - [5.3 缓存雪崩解决](#53-缓存雪崩解决)
- [6. 分布式锁](#6.-分布式锁)
  - [6.1 Redis分布式锁](#61-redis分布式锁)
  - [6.2 自动续期锁](#62-自动续期锁)
- [7. 缓存策略](#7.-缓存策略)
  - [7.1 缓存更新策略](#71-缓存更新策略)
  - [7.2 缓存预热](#72-缓存预热)
- [8. 完整案例](#8.-完整案例)
  - [8.1 电商商品缓存系统](#81-电商商品缓存系统)
- [📚 缓存架构最佳实践](#缓存架构最佳实践)
  - [缓存选型](#缓存选型)
  - [缓存策略](#缓存策略)
  - [问题防护](#问题防护)
- [🎯 总结](#总结)

## 📖 文档说明

本文档展示Go 1.25.3的**分布式缓存架构完整方案**，构建高性能缓存系统：

- ✅ Redis深度实战
- ✅ 本地缓存优化
- ✅ 多级缓存架构
- ✅ 缓存一致性
- ✅ 缓存穿透/击穿/雪崩
- ✅ 分布式锁
- ✅ 缓存预热与更新

---

## 目录

- [Go 1.25.3 分布式缓存架构完整实战](#go-1.25.3-分布式缓存架构完整实战)
  - [📖 文档说明](#文档说明)
  - [目录](#目录)
  - [1. Redis深度实战](#1.-redis深度实战)
    - [1.1 Redis客户端封装](#11-redis客户端封装)
    - [1.2 Pipeline批量操作](#12-pipeline批量操作)
  - [2. 本地缓存](#2.-本地缓存)
    - [2.1 LRU本地缓存](#21-lru本地缓存)
    - [2.2 定时清理过期缓存](#22-定时清理过期缓存)
  - [3. 多级缓存](#3.-多级缓存)
    - [3.1 多级缓存架构](#31-多级缓存架构)
  - [4. 缓存模式](#4.-缓存模式)
    - [4.1 Cache-Aside模式](#41-cache-aside模式)
    - [4.2 Read-Through模式](#42-read-through模式)
    - [4.3 Write-Through模式](#43-write-through模式)
  - [5. 缓存问题解决](#5.-缓存问题解决)
    - [5.1 缓存穿透解决](#51-缓存穿透解决)
    - [5.2 缓存击穿解决（单飞）](#52-缓存击穿解决单飞)
    - [5.3 缓存雪崩解决](#53-缓存雪崩解决)
  - [6. 分布式锁](#6.-分布式锁)
    - [6.1 Redis分布式锁](#61-redis分布式锁)
    - [6.2 自动续期锁](#62-自动续期锁)
  - [7. 缓存策略](#7.-缓存策略)
    - [7.1 缓存更新策略](#71-缓存更新策略)
    - [7.2 缓存预热](#72-缓存预热)
  - [8. 完整案例](#8.-完整案例)
    - [8.1 电商商品缓存系统](#81-电商商品缓存系统)
  - [📚 缓存架构最佳实践](#缓存架构最佳实践)
    - [缓存选型](#缓存选型)
    - [缓存策略](#缓存策略)
    - [问题防护](#问题防护)
  - [🎯 总结](#总结)

---

## 1. Redis深度实战

### 1.1 Redis客户端封装

```go
package cache

import (
 "context"
 "encoding/json"
 "fmt"
 "time"
 
 "github.com/redis/go-redis/v9"
)

// RedisCache Redis缓存
type RedisCache struct {
 client *redis.Client
 prefix string
}

// NewRedisCache 创建Redis缓存
func NewRedisCache(addr, password string, db int, prefix string) (*RedisCache, error) {
 client := redis.NewClient(&redis.Options{
  Addr:         addr,
  Password:     password,
  DB:           db,
  PoolSize:     100,
  MinIdleConns: 10,
 })
 
 // 测试连接
 ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
 defer cancel()
 
 if err := client.Ping(ctx).Err(); err != nil {
  return nil, fmt.Errorf("failed to connect to redis: %w", err)
 }
 
 return &RedisCache{
  client: client,
  prefix: prefix,
 }, nil
}

// buildKey 构建键
func (rc *RedisCache) buildKey(key string) string {
 if rc.prefix == "" {
  return key
 }
 return fmt.Sprintf("%s:%s", rc.prefix, key)
}

// Get 获取缓存
func (rc *RedisCache) Get(ctx context.Context, key string, dest interface{}) error {
 fullKey := rc.buildKey(key)
 
 data, err := rc.client.Get(ctx, fullKey).Bytes()
 if err == redis.Nil {
  return ErrCacheMiss
 }
 if err != nil {
  return err
 }
 
 return json.Unmarshal(data, dest)
}

// Set 设置缓存
func (rc *RedisCache) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error {
 fullKey := rc.buildKey(key)
 
 data, err := json.Marshal(value)
 if err != nil {
  return err
 }
 
 return rc.client.Set(ctx, fullKey, data, ttl).Err()
}

// Delete 删除缓存
func (rc *RedisCache) Delete(ctx context.Context, keys ...string) error {
 fullKeys := make([]string, len(keys))
 for i, key := range keys {
  fullKeys[i] = rc.buildKey(key)
 }
 
 return rc.client.Del(ctx, fullKeys...).Err()
}

// Exists 检查存在
func (rc *RedisCache) Exists(ctx context.Context, key string) (bool, error) {
 fullKey := rc.buildKey(key)
 
 count, err := rc.client.Exists(ctx, fullKey).Result()
 if err != nil {
  return false, err
 }
 
 return count > 0, nil
}

// TTL 获取过期时间
func (rc *RedisCache) TTL(ctx context.Context, key string) (time.Duration, error) {
 fullKey := rc.buildKey(key)
 return rc.client.TTL(ctx, fullKey).Result()
}

// Expire 设置过期时间
func (rc *RedisCache) Expire(ctx context.Context, key string, ttl time.Duration) error {
 fullKey := rc.buildKey(key)
 return rc.client.Expire(ctx, fullKey, ttl).Err()
}
```

---

### 1.2 Pipeline批量操作

```go
// MGet 批量获取
func (rc *RedisCache) MGet(ctx context.Context, keys []string) (map[string]interface{}, error) {
 if len(keys) == 0 {
  return make(map[string]interface{}), nil
 }
 
 // 构建完整键
 fullKeys := make([]string, len(keys))
 for i, key := range keys {
  fullKeys[i] = rc.buildKey(key)
 }
 
 // 执行MGet
 values, err := rc.client.MGet(ctx, fullKeys...).Result()
 if err != nil {
  return nil, err
 }
 
 // 解析结果
 result := make(map[string]interface{})
 for i, val := range values {
  if val != nil {
   result[keys[i]] = val
  }
 }
 
 return result, nil
}

// MSet 批量设置
func (rc *RedisCache) MSet(ctx context.Context, items map[string]interface{}, ttl time.Duration) error {
 if len(items) == 0 {
  return nil
 }
 
 pipe := rc.client.Pipeline()
 
 for key, value := range items {
  fullKey := rc.buildKey(key)
  
  data, err := json.Marshal(value)
  if err != nil {
   return err
  }
  
  pipe.Set(ctx, fullKey, data, ttl)
 }
 
 _, err := pipe.Exec(ctx)
 return err
}

// DeletePattern 删除匹配的键
func (rc *RedisCache) DeletePattern(ctx context.Context, pattern string) error {
 fullPattern := rc.buildKey(pattern)
 
 iter := rc.client.Scan(ctx, 0, fullPattern, 0).Iterator()
 
 pipe := rc.client.Pipeline()
 count := 0
 
 for iter.Next(ctx) {
  pipe.Del(ctx, iter.Val())
  count++
  
  // 每100个键执行一次
  if count%100 == 0 {
   if _, err := pipe.Exec(ctx); err != nil {
    return err
   }
  }
 }
 
 if err := iter.Err(); err != nil {
  return err
 }
 
 if count%100 != 0 {
  _, err := pipe.Exec(ctx)
  return err
 }
 
 return nil
}
```

---

## 2. 本地缓存

### 2.1 LRU本地缓存

```go
package localcache

import (
 "container/list"
 "sync"
 "time"
)

// LRUCache LRU缓存
type LRUCache struct {
 capacity int
 items    map[string]*list.Element
 lru      *list.List
 mu       sync.RWMutex
}

// entry 缓存条目
type entry struct {
 key       string
 value     interface{}
 expireAt  time.Time
}

// NewLRUCache 创建LRU缓存
func NewLRUCache(capacity int) *LRUCache {
 return &LRUCache{
  capacity: capacity,
  items:    make(map[string]*list.Element),
  lru:      list.New(),
 }
}

// Get 获取
func (lc *LRUCache) Get(key string) (interface{}, bool) {
 lc.mu.Lock()
 defer lc.mu.Unlock()
 
 elem, ok := lc.items[key]
 if !ok {
  return nil, false
 }
 
 // 检查过期
 entry := elem.Value.(*entry)
 if !entry.expireAt.IsZero() && time.Now().After(entry.expireAt) {
  lc.removeElement(elem)
  return nil, false
 }
 
 // 移到最前面
 lc.lru.MoveToFront(elem)
 
 return entry.value, true
}

// Set 设置
func (lc *LRUCache) Set(key string, value interface{}, ttl time.Duration) {
 lc.mu.Lock()
 defer lc.mu.Unlock()
 
 // 计算过期时间
 var expireAt time.Time
 if ttl > 0 {
  expireAt = time.Now().Add(ttl)
 }
 
 // 如果已存在，更新
 if elem, ok := lc.items[key]; ok {
  entry := elem.Value.(*entry)
  entry.value = value
  entry.expireAt = expireAt
  lc.lru.MoveToFront(elem)
  return
 }
 
 // 检查容量
 if lc.lru.Len() >= lc.capacity {
  // 删除最少使用的
  lc.removeElement(lc.lru.Back())
 }
 
 // 添加新条目
 entry := &entry{
  key:      key,
  value:    value,
  expireAt: expireAt,
 }
 elem := lc.lru.PushFront(entry)
 lc.items[key] = elem
}

// Delete 删除
func (lc *LRUCache) Delete(key string) {
 lc.mu.Lock()
 defer lc.mu.Unlock()
 
 if elem, ok := lc.items[key]; ok {
  lc.removeElement(elem)
 }
}

// removeElement 删除元素
func (lc *LRUCache) removeElement(elem *list.Element) {
 entry := elem.Value.(*entry)
 delete(lc.items, entry.key)
 lc.lru.Remove(elem)
}

// Clear 清空
func (lc *LRUCache) Clear() {
 lc.mu.Lock()
 defer lc.mu.Unlock()
 
 lc.items = make(map[string]*list.Element)
 lc.lru.Init()
}

// Len 长度
func (lc *LRUCache) Len() int {
 lc.mu.RLock()
 defer lc.mu.RUnlock()
 
 return lc.lru.Len()
}
```

---

### 2.2 定时清理过期缓存

```go
// StartCleanup 启动定时清理
func (lc *LRUCache) StartCleanup(interval time.Duration, done <-chan struct{}) {
 ticker := time.NewTicker(interval)
 defer ticker.Stop()
 
 for {
  select {
  case <-ticker.C:
   lc.cleanup()
  case <-done:
   return
  }
 }
}

// cleanup 清理过期缓存
func (lc *LRUCache) cleanup() {
 lc.mu.Lock()
 defer lc.mu.Unlock()
 
 now := time.Now()
 
 // 从后往前遍历（后面是最久未使用的）
 for elem := lc.lru.Back(); elem != nil; {
  entry := elem.Value.(*entry)
  
  // 如果未过期且后面的更不可能过期，停止
  if entry.expireAt.IsZero() || now.Before(entry.expireAt) {
   break
  }
  
  // 删除过期条目
  prev := elem.Prev()
  lc.removeElement(elem)
  elem = prev
 }
}
```

---

## 3. 多级缓存

### 3.1 多级缓存架构

```go
package multilevelcache

import (
 "context"
 "time"
)

// MultiLevelCache 多级缓存
type MultiLevelCache struct {
 l1       *localcache.LRUCache
 l2       *cache.RedisCache
 l1TTL    time.Duration
 l2TTL    time.Duration
 loader   DataLoader
}

// DataLoader 数据加载器
type DataLoader func(ctx context.Context, key string) (interface{}, error)

// NewMultiLevelCache 创建多级缓存
func NewMultiLevelCache(
 l1Capacity int,
 l1TTL time.Duration,
 redis *cache.RedisCache,
 l2TTL time.Duration,
 loader DataLoader,
) *MultiLevelCache {
 return &MultiLevelCache{
  l1:     localcache.NewLRUCache(l1Capacity),
  l2:     redis,
  l1TTL:  l1TTL,
  l2TTL:  l2TTL,
  loader: loader,
 }
}

// Get 获取缓存
func (mlc *MultiLevelCache) Get(ctx context.Context, key string) (interface{}, error) {
 // 1. 查询L1缓存
 if value, ok := mlc.l1.Get(key); ok {
  return value, nil
 }
 
 // 2. 查询L2缓存
 var value interface{}
 err := mlc.l2.Get(ctx, key, &value)
 if err == nil {
  // 回填L1缓存
  mlc.l1.Set(key, value, mlc.l1TTL)
  return value, nil
 }
 
 if err != cache.ErrCacheMiss {
  return nil, err
 }
 
 // 3. 从数据源加载
 value, err = mlc.loader(ctx, key)
 if err != nil {
  return nil, err
 }
 
 // 4. 写入多级缓存
 go func() {
  // 异步写入，不影响主流程
  mlc.Set(context.Background(), key, value)
 }()
 
 return value, nil
}

// Set 设置缓存
func (mlc *MultiLevelCache) Set(ctx context.Context, key string, value interface{}) error {
 // 写入L1
 mlc.l1.Set(key, value, mlc.l1TTL)
 
 // 写入L2
 return mlc.l2.Set(ctx, key, value, mlc.l2TTL)
}

// Delete 删除缓存
func (mlc *MultiLevelCache) Delete(ctx context.Context, key string) error {
 // 删除L1
 mlc.l1.Delete(key)
 
 // 删除L2
 return mlc.l2.Delete(ctx, key)
}
```

---

## 4. 缓存模式

### 4.1 Cache-Aside模式

```go
// CacheAsidePattern Cache-Aside模式
type CacheAsidePattern struct {
 cache  *cache.RedisCache
 db     *sql.DB
}

// GetUser 获取用户（Cache-Aside）
func (cap *CacheAsidePattern) GetUser(ctx context.Context, userID string) (*User, error) {
 key := fmt.Sprintf("user:%s", userID)
 
 // 1. 查询缓存
 var user User
 err := cap.cache.Get(ctx, key, &user)
 if err == nil {
  return &user, nil
 }
 
 if err != cache.ErrCacheMiss {
  return nil, err
 }
 
 // 2. 查询数据库
 err = cap.db.QueryRowContext(ctx, "SELECT id, name, email FROM users WHERE id = ?", userID).
  Scan(&user.ID, &user.Name, &user.Email)
 if err != nil {
  return nil, err
 }
 
 // 3. 写入缓存
 cap.cache.Set(ctx, key, &user, 1*time.Hour)
 
 return &user, nil
}

// UpdateUser 更新用户
func (cap *CacheAsidePattern) UpdateUser(ctx context.Context, user *User) error {
 // 1. 更新数据库
 _, err := cap.db.ExecContext(ctx,
  "UPDATE users SET name = ?, email = ? WHERE id = ?",
  user.Name, user.Email, user.ID)
 if err != nil {
  return err
 }
 
 // 2. 删除缓存
 key := fmt.Sprintf("user:%s", user.ID)
 return cap.cache.Delete(ctx, key)
}
```

---

### 4.2 Read-Through模式

```go
// ReadThroughCache Read-Through缓存
type ReadThroughCache struct {
 cache  *cache.RedisCache
 loader DataLoader
 ttl    time.Duration
}

// Get 获取数据
func (rtc *ReadThroughCache) Get(ctx context.Context, key string) (interface{}, error) {
 // 查询缓存
 var value interface{}
 err := rtc.cache.Get(ctx, key, &value)
 if err == nil {
  return value, nil
 }
 
 if err != cache.ErrCacheMiss {
  return nil, err
 }
 
 // 加载数据
 value, err = rtc.loader(ctx, key)
 if err != nil {
  return nil, err
 }
 
 // 写入缓存
 rtc.cache.Set(ctx, key, value, rtc.ttl)
 
 return value, nil
}
```

---

### 4.3 Write-Through模式

```go
// WriteThroughCache Write-Through缓存
type WriteThroughCache struct {
 cache  *cache.RedisCache
 writer DataWriter
 ttl    time.Duration
}

// DataWriter 数据写入器
type DataWriter func(ctx context.Context, key string, value interface{}) error

// Set 设置数据
func (wtc *WriteThroughCache) Set(ctx context.Context, key string, value interface{}) error {
 // 1. 写入数据库
 if err := wtc.writer(ctx, key, value); err != nil {
  return err
 }
 
 // 2. 写入缓存
 return wtc.cache.Set(ctx, key, value, wtc.ttl)
}
```

---

## 5. 缓存问题解决

### 5.1 缓存穿透解决

```go
// BloomFilter 布隆过滤器
type BloomFilter struct {
 client *redis.Client
 key    string
}

// Add 添加元素
func (bf *BloomFilter) Add(ctx context.Context, item string) error {
 return bf.client.BFAdd(ctx, bf.key, item).Err()
}

// Exists 检查存在
func (bf *BloomFilter) Exists(ctx context.Context, item string) (bool, error) {
 return bf.client.BFExists(ctx, bf.key, item).Result()
}

// 缓存穿透防护
func (cap *CacheAsidePattern) GetUserWithBloomFilter(ctx context.Context, userID string) (*User, error) {
 // 1. 布隆过滤器检查
 exists, err := bloomFilter.Exists(ctx, userID)
 if err != nil {
  return nil, err
 }
 
 if !exists {
  return nil, ErrUserNotFound
 }
 
 // 2. 正常的缓存查询流程
 return cap.GetUser(ctx, userID)
}
```

---

### 5.2 缓存击穿解决（单飞）

```go
package singleflight

import (
 "context"
 "sync"
)

// Group 单飞组
type Group struct {
 mu sync.Mutex
 m  map[string]*call
}

// call 调用
type call struct {
 wg  sync.WaitGroup
 val interface{}
 err error
}

// NewGroup 创建单飞组
func NewGroup() *Group {
 return &Group{
  m: make(map[string]*call),
 }
}

// Do 执行
func (g *Group) Do(key string, fn func() (interface{}, error)) (interface{}, error) {
 g.mu.Lock()
 
 if c, ok := g.m[key]; ok {
  g.mu.Unlock()
  c.wg.Wait()
  return c.val, c.err
 }
 
 c := &call{}
 c.wg.Add(1)
 g.m[key] = c
 g.mu.Unlock()
 
 c.val, c.err = fn()
 c.wg.Done()
 
 g.mu.Lock()
 delete(g.m, key)
 g.mu.Unlock()
 
 return c.val, c.err
}

// 使用单飞防止缓存击穿
type CacheWithSingleFlight struct {
 cache *cache.RedisCache
 sf    *Group
 loader DataLoader
}

func (csf *CacheWithSingleFlight) Get(ctx context.Context, key string) (interface{}, error) {
 // 查询缓存
 var value interface{}
 err := csf.cache.Get(ctx, key, &value)
 if err == nil {
  return value, nil
 }
 
 // 使用单飞加载
 return csf.sf.Do(key, func() (interface{}, error) {
  // 再次检查缓存（可能已被其他goroutine加载）
  var value interface{}
  err := csf.cache.Get(ctx, key, &value)
  if err == nil {
   return value, nil
  }
  
  // 加载数据
  value, err = csf.loader(ctx, key)
  if err != nil {
   return nil, err
  }
  
  // 写入缓存
  csf.cache.Set(ctx, key, value, 1*time.Hour)
  
  return value, nil
 })
}
```

---

### 5.3 缓存雪崩解决

```go
// 随机TTL防止雪崩
func (rc *RedisCache) SetWithRandomTTL(ctx context.Context, key string, value interface{}, baseTTL time.Duration) error {
 // 添加随机偏移（±10%）
 offset := time.Duration(float64(baseTTL) * (rand.Float64()*0.2 - 0.1))
 ttl := baseTTL + offset
 
 return rc.Set(ctx, key, value, ttl)
}

// 缓存预热
func (rc *RedisCache) Warmup(ctx context.Context, keys []string, loader DataLoader) error {
 for _, key := range keys {
  value, err := loader(ctx, key)
  if err != nil {
   log.Printf("Failed to load key %s: %v", key, err)
   continue
  }
  
  if err := rc.Set(ctx, key, value, 1*time.Hour); err != nil {
   log.Printf("Failed to set key %s: %v", key, err)
  }
 }
 
 return nil
}
```

---

## 6. 分布式锁

### 6.1 Redis分布式锁

```go
package distributedlock

import (
 "context"
 "errors"
 "time"
 
 "github.com/redis/go-redis/v9"
)

// RedisLock Redis分布式锁
type RedisLock struct {
 client *redis.Client
 key    string
 value  string
 ttl    time.Duration
}

// NewRedisLock 创建Redis锁
func NewRedisLock(client *redis.Client, key, value string, ttl time.Duration) *RedisLock {
 return &RedisLock{
  client: client,
  key:    key,
  value:  value,
  ttl:    ttl,
 }
}

// Lock 加锁
func (rl *RedisLock) Lock(ctx context.Context) error {
 // 使用SET NX EX实现
 ok, err := rl.client.SetNX(ctx, rl.key, rl.value, rl.ttl).Result()
 if err != nil {
  return err
 }
 
 if !ok {
  return errors.New("failed to acquire lock")
 }
 
 return nil
}

// Unlock 解锁
func (rl *RedisLock) Unlock(ctx context.Context) error {
 // Lua脚本确保只删除自己的锁
 script := `
  if redis.call("get", KEYS[1]) == ARGV[1] then
   return redis.call("del", KEYS[1])
  else
   return 0
  end
 `
 
 result, err := rl.client.Eval(ctx, script, []string{rl.key}, rl.value).Int()
 if err != nil {
  return err
 }
 
 if result == 0 {
  return errors.New("lock not held")
 }
 
 return nil
}

// TryLock 尝试加锁
func (rl *RedisLock) TryLock(ctx context.Context, maxRetries int, retryDelay time.Duration) error {
 for i := 0; i < maxRetries; i++ {
  err := rl.Lock(ctx)
  if err == nil {
   return nil
  }
  
  if i < maxRetries-1 {
   time.Sleep(retryDelay)
  }
 }
 
 return errors.New("failed to acquire lock after retries")
}

// Renew 续期
func (rl *RedisLock) Renew(ctx context.Context) error {
 // Lua脚本确保只续期自己的锁
 script := `
  if redis.call("get", KEYS[1]) == ARGV[1] then
   return redis.call("expire", KEYS[1], ARGV[2])
  else
   return 0
  end
 `
 
 result, err := rl.client.Eval(ctx, script, []string{rl.key}, rl.value, int(rl.ttl.Seconds())).Int()
 if err != nil {
  return err
 }
 
 if result == 0 {
  return errors.New("lock not held")
 }
 
 return nil
}
```

---

### 6.2 自动续期锁

```go
// AutoRenewLock 自动续期锁
type AutoRenewLock struct {
 lock       *RedisLock
 renewInterval time.Duration
 stopRenew  chan struct{}
}

// NewAutoRenewLock 创建自动续期锁
func NewAutoRenewLock(lock *RedisLock) *AutoRenewLock {
 return &AutoRenewLock{
  lock:          lock,
  renewInterval: lock.ttl / 3, // 每1/3 TTL续期一次
  stopRenew:     make(chan struct{}),
 }
}

// Lock 加锁并开始自动续期
func (arl *AutoRenewLock) Lock(ctx context.Context) error {
 if err := arl.lock.Lock(ctx); err != nil {
  return err
 }
 
 // 启动自动续期
 go arl.autoRenew(ctx)
 
 return nil
}

// Unlock 解锁并停止续期
func (arl *AutoRenewLock) Unlock(ctx context.Context) error {
 // 停止续期
 close(arl.stopRenew)
 
 // 解锁
 return arl.lock.Unlock(ctx)
}

// autoRenew 自动续期
func (arl *AutoRenewLock) autoRenew(ctx context.Context) {
 ticker := time.NewTicker(arl.renewInterval)
 defer ticker.Stop()
 
 for {
  select {
  case <-ticker.C:
   if err := arl.lock.Renew(ctx); err != nil {
    log.Printf("Failed to renew lock: %v", err)
    return
   }
  case <-arl.stopRenew:
   return
  case <-ctx.Done():
   return
  }
 }
}
```

---

## 7. 缓存策略

### 7.1 缓存更新策略

```go
// UpdateStrategy 更新策略
type UpdateStrategy int

const (
 DeleteCache     UpdateStrategy = iota // 删除缓存
 UpdateCache                           // 更新缓存
 ExpireCache                           // 过期缓存
)

// CacheManager 缓存管理器
type CacheManager struct {
 cache    *cache.RedisCache
 db       *sql.DB
 strategy UpdateStrategy
}

// UpdateData 更新数据
func (cm *CacheManager) UpdateData(ctx context.Context, key string, data interface{}) error {
 // 1. 更新数据库
 if err := cm.writeToDatabase(ctx, key, data); err != nil {
  return err
 }
 
 // 2. 根据策略处理缓存
 switch cm.strategy {
 case DeleteCache:
  return cm.cache.Delete(ctx, key)
  
 case UpdateCache:
  return cm.cache.Set(ctx, key, data, 1*time.Hour)
  
 case ExpireCache:
  return cm.cache.Expire(ctx, key, 1*time.Minute)
  
 default:
  return nil
 }
}
```

---

### 7.2 缓存预热

```go
// Warmer 缓存预热器
type Warmer struct {
 cache   *cache.RedisCache
 loader  DataLoader
 keys    []string
}

// Warmup 预热
func (w *Warmer) Warmup(ctx context.Context) error {
 log.Println("Starting cache warmup...")
 
 errChan := make(chan error, len(w.keys))
 sem := make(chan struct{}, 10) // 并发控制
 
 var wg sync.WaitGroup
 
 for _, key := range w.keys {
  wg.Add(1)
  
  go func(k string) {
   defer wg.Done()
   
   sem <- struct{}{}
   defer func() { <-sem }()
   
   // 加载数据
   value, err := w.loader(ctx, k)
   if err != nil {
    errChan <- fmt.Errorf("failed to load %s: %w", k, err)
    return
   }
   
   // 写入缓存
   if err := w.cache.Set(ctx, k, value, 24*time.Hour); err != nil {
    errChan <- fmt.Errorf("failed to cache %s: %w", k, err)
   }
  }(key)
 }
 
 wg.Wait()
 close(errChan)
 
 // 收集错误
 var errors []error
 for err := range errChan {
  errors = append(errors, err)
  log.Println(err)
 }
 
 log.Printf("Cache warmup completed. Success: %d, Failed: %d", 
  len(w.keys)-len(errors), len(errors))
 
 return nil
}
```

---

## 8. 完整案例

### 8.1 电商商品缓存系统

```go
package productcache

import (
 "context"
 "fmt"
 "time"
)

// ProductCacheService 商品缓存服务
type ProductCacheService struct {
 l1Cache    *localcache.LRUCache
 l2Cache    *cache.RedisCache
 db         *sql.DB
 sf         *singleflight.Group
 bloomFilter *BloomFilter
 lock       *distributedlock.RedisLock
}

// GetProduct 获取商品
func (pcs *ProductCacheService) GetProduct(ctx context.Context, productID string) (*Product, error) {
 key := fmt.Sprintf("product:%s", productID)
 
 // 1. 布隆过滤器检查
 exists, err := pcs.bloomFilter.Exists(ctx, productID)
 if err != nil {
  return nil, err
 }
 
 if !exists {
  return nil, ErrProductNotFound
 }
 
 // 2. L1缓存
 if value, ok := pcs.l1Cache.Get(key); ok {
  return value.(*Product), nil
 }
 
 // 3. L2缓存 + 单飞
 value, err := pcs.sf.Do(key, func() (interface{}, error) {
  var product Product
  err := pcs.l2Cache.Get(ctx, key, &product)
  if err == nil {
   return &product, nil
  }
  
  // 4. 数据库
  product, err = pcs.loadFromDatabase(ctx, productID)
  if err != nil {
   return nil, err
  }
  
  // 5. 写入缓存
  go func() {
   pcs.l1Cache.Set(key, &product, 5*time.Minute)
   pcs.l2Cache.SetWithRandomTTL(context.Background(), key, &product, 1*time.Hour)
  }()
  
  return &product, nil
 })
 
 if err != nil {
  return nil, err
 }
 
 return value.(*Product), nil
}

// UpdateProduct 更新商品
func (pcs *ProductCacheService) UpdateProduct(ctx context.Context, product *Product) error {
 key := fmt.Sprintf("product:%s", product.ID)
 
 // 1. 获取分布式锁
 lock := distributedlock.NewRedisLock(pcs.l2Cache.client, key+":lock", "update", 5*time.Second)
 if err := lock.TryLock(ctx, 3, 100*time.Millisecond); err != nil {
  return err
 }
 defer lock.Unlock(ctx)
 
 // 2. 更新数据库
 if err := pcs.updateDatabase(ctx, product); err != nil {
  return err
 }
 
 // 3. 删除缓存（推荐）或更新缓存
 pcs.l1Cache.Delete(key)
 pcs.l2Cache.Delete(ctx, key)
 
 return nil
}

// BatchGetProducts 批量获取商品
func (pcs *ProductCacheService) BatchGetProducts(ctx context.Context, productIDs []string) (map[string]*Product, error) {
 result := make(map[string]*Product)
 missedKeys := make([]string, 0)
 
 // 1. 批量从L2缓存获取
 keys := make([]string, len(productIDs))
 for i, id := range productIDs {
  keys[i] = fmt.Sprintf("product:%s", id)
 }
 
 cached, err := pcs.l2Cache.MGet(ctx, keys)
 if err != nil {
  return nil, err
 }
 
 // 2. 收集未命中的键
 for i, key := range keys {
  if value, ok := cached[key]; ok {
   var product Product
   if err := json.Unmarshal([]byte(value.(string)), &product); err == nil {
    result[productIDs[i]] = &product
   }
  } else {
   missedKeys = append(missedKeys, productIDs[i])
  }
 }
 
 // 3. 批量从数据库加载未命中的
 if len(missedKeys) > 0 {
  products, err := pcs.batchLoadFromDatabase(ctx, missedKeys)
  if err != nil {
   return nil, err
  }
  
  // 4. 写入缓存
  cacheItems := make(map[string]interface{})
  for id, product := range products {
   result[id] = product
   cacheItems[fmt.Sprintf("product:%s", id)] = product
  }
  
  go pcs.l2Cache.MSet(context.Background(), cacheItems, 1*time.Hour)
 }
 
 return result, nil
}
```

---

## 📚 缓存架构最佳实践

### 缓存选型

- **本地缓存**: 热点数据、低延迟要求
- **Redis**: 分布式缓存、持久化需求
- **多级缓存**: 高并发、大流量场景

### 缓存策略

- ✅ Cache-Aside（旁路缓存）- 最常用
- ✅ Read-Through（读穿透）- 封装数据源
- ✅ Write-Through（写穿透）- 强一致性
- ✅ Write-Behind（写回）- 高性能写入

### 问题防护

- ✅ 缓存穿透：布隆过滤器、空值缓存
- ✅ 缓存击穿：单飞、分布式锁
- ✅ 缓存雪崩：随机TTL、缓存预热

---

## 🎯 总结

Go 1.25.3分布式缓存关键点：

1. **Redis深度**: Pipeline、Lua脚本、集群
2. **本地缓存**: LRU、TTL、定时清理
3. **多级缓存**: L1+L2、异步写入、回填
4. **缓存模式**: Cache-Aside、Read/Write-Through
5. **问题解决**: 穿透、击穿、雪崩
6. **分布式锁**: SET NX、Lua脚本、自动续期
7. **缓存策略**: 更新、预热、淘汰

**缓存是性能优化的第一利器！**

---

<div align="center">

**掌握分布式缓存，构建高性能系统**：

[📚 返回目录](../README.md) | [📖 下一章](22-微服务治理实战.md)

Made with ❤️ for Go Developers

</div>

---

**文档版本**: v1.0  
**最后更新**: 2025-10-29  
**Go版本**: Go 1.25.3  
**生产就绪**: ✅
