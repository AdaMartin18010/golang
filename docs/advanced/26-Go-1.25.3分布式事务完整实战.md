# Go 1.25.3 åˆ†å¸ƒå¼äº‹åŠ¡å®Œæ•´å®æˆ˜

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.25.3

---

## ğŸ“‹ ç›®å½•

- [Go 1.25.3 åˆ†å¸ƒå¼äº‹åŠ¡å®Œæ•´å®æˆ˜](#go-1253-åˆ†å¸ƒå¼äº‹åŠ¡å®Œæ•´å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“– æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. Sagaæ¨¡å¼](#1-sagaæ¨¡å¼)
    - [1.1 Sagaç¼–æ’å™¨](#11-sagaç¼–æ’å™¨)
    - [1.2 è®¢å•Sagaç¤ºä¾‹](#12-è®¢å•sagaç¤ºä¾‹)
  - [2. TCCæ¨¡å¼](#2-tccæ¨¡å¼)
    - [2.1 TCCåè°ƒå™¨](#21-tccåè°ƒå™¨)
    - [2.2 TCCå®ç°ç¤ºä¾‹](#22-tccå®ç°ç¤ºä¾‹)
  - [3. ä¸¤é˜¶æ®µæäº¤](#3-ä¸¤é˜¶æ®µæäº¤)
    - [3.1 2PCåè°ƒå™¨](#31-2pcåè°ƒå™¨)
    - [3.2 å‚ä¸è€…å®ç°](#32-å‚ä¸è€…å®ç°)
  - [4. æœ¬åœ°æ¶ˆæ¯è¡¨](#4-æœ¬åœ°æ¶ˆæ¯è¡¨)
    - [4.1 æ¶ˆæ¯è¡¨è®¾è®¡](#41-æ¶ˆæ¯è¡¨è®¾è®¡)
    - [4.2 æ¶ˆæ¯å‘é€ä¸ç¡®è®¤](#42-æ¶ˆæ¯å‘é€ä¸ç¡®è®¤)
  - [5. äº‹åŠ¡æ¶ˆæ¯](#5-äº‹åŠ¡æ¶ˆæ¯)
    - [5.1 RocketMQäº‹åŠ¡æ¶ˆæ¯](#51-rocketmqäº‹åŠ¡æ¶ˆæ¯)
    - [5.2 Kafkaäº‹åŠ¡æ¶ˆæ¯](#52-kafkaäº‹åŠ¡æ¶ˆæ¯)
  - [6. æœ€å¤§åŠªåŠ›é€šçŸ¥](#6-æœ€å¤§åŠªåŠ›é€šçŸ¥)
    - [6.1 é€šçŸ¥æœåŠ¡](#61-é€šçŸ¥æœåŠ¡)
    - [6.2 é‡è¯•ç­–ç•¥](#62-é‡è¯•ç­–ç•¥)
  - [7. æœ€ç»ˆä¸€è‡´æ€§](#7-æœ€ç»ˆä¸€è‡´æ€§)
    - [7.1 çŠ¶æ€æœº](#71-çŠ¶æ€æœº)
    - [7.2 å¹‚ç­‰æ€§](#72-å¹‚ç­‰æ€§)
  - [8. å®Œæ•´æ¡ˆä¾‹](#8-å®Œæ•´æ¡ˆä¾‹)
    - [8.1 ç”µå•†è®¢å•ç³»ç»Ÿ](#81-ç”µå•†è®¢å•ç³»ç»Ÿ)
  - [ğŸ“š åˆ†å¸ƒå¼äº‹åŠ¡æœ€ä½³å®è·µ](#-åˆ†å¸ƒå¼äº‹åŠ¡æœ€ä½³å®è·µ)
    - [æ¨¡å¼é€‰æ‹©](#æ¨¡å¼é€‰æ‹©)
    - [è®¾è®¡åŸåˆ™](#è®¾è®¡åŸåˆ™)
    - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
    - [ç›‘æ§å‘Šè­¦](#ç›‘æ§å‘Šè­¦)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

## ğŸ“– æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£å±•ç¤ºGo 1.25.3çš„**åˆ†å¸ƒå¼äº‹åŠ¡å®Œæ•´æ–¹æ¡ˆ**ï¼Œç¡®ä¿æ•°æ®ä¸€è‡´æ€§ï¼š

- âœ… Sagaæ¨¡å¼
- âœ… TCCæ¨¡å¼
- âœ… ä¸¤é˜¶æ®µæäº¤(2PC)
- âœ… æœ¬åœ°æ¶ˆæ¯è¡¨
- âœ… äº‹åŠ¡æ¶ˆæ¯
- âœ… æœ€å¤§åŠªåŠ›é€šçŸ¥
- âœ… æœ€ç»ˆä¸€è‡´æ€§
- âœ… è¡¥å¿æœºåˆ¶

---

## ç›®å½•

- [Go 1.25.3 åˆ†å¸ƒå¼äº‹åŠ¡å®Œæ•´å®æˆ˜](#go-1253-åˆ†å¸ƒå¼äº‹åŠ¡å®Œæ•´å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“– æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. Sagaæ¨¡å¼](#1-sagaæ¨¡å¼)
    - [1.1 Sagaç¼–æ’å™¨](#11-sagaç¼–æ’å™¨)
    - [1.2 è®¢å•Sagaç¤ºä¾‹](#12-è®¢å•sagaç¤ºä¾‹)
  - [2. TCCæ¨¡å¼](#2-tccæ¨¡å¼)
    - [2.1 TCCåè°ƒå™¨](#21-tccåè°ƒå™¨)
    - [2.2 TCCå®ç°ç¤ºä¾‹](#22-tccå®ç°ç¤ºä¾‹)
  - [3. ä¸¤é˜¶æ®µæäº¤](#3-ä¸¤é˜¶æ®µæäº¤)
    - [3.1 2PCåè°ƒå™¨](#31-2pcåè°ƒå™¨)
    - [3.2 å‚ä¸è€…å®ç°](#32-å‚ä¸è€…å®ç°)
  - [4. æœ¬åœ°æ¶ˆæ¯è¡¨](#4-æœ¬åœ°æ¶ˆæ¯è¡¨)
    - [4.1 æ¶ˆæ¯è¡¨è®¾è®¡](#41-æ¶ˆæ¯è¡¨è®¾è®¡)
    - [4.2 æ¶ˆæ¯å‘é€ä¸ç¡®è®¤](#42-æ¶ˆæ¯å‘é€ä¸ç¡®è®¤)
  - [5. äº‹åŠ¡æ¶ˆæ¯](#5-äº‹åŠ¡æ¶ˆæ¯)
    - [5.1 RocketMQäº‹åŠ¡æ¶ˆæ¯](#51-rocketmqäº‹åŠ¡æ¶ˆæ¯)
    - [5.2 Kafkaäº‹åŠ¡æ¶ˆæ¯](#52-kafkaäº‹åŠ¡æ¶ˆæ¯)
  - [6. æœ€å¤§åŠªåŠ›é€šçŸ¥](#6-æœ€å¤§åŠªåŠ›é€šçŸ¥)
    - [6.1 é€šçŸ¥æœåŠ¡](#61-é€šçŸ¥æœåŠ¡)
    - [6.2 é‡è¯•ç­–ç•¥](#62-é‡è¯•ç­–ç•¥)
  - [7. æœ€ç»ˆä¸€è‡´æ€§](#7-æœ€ç»ˆä¸€è‡´æ€§)
    - [7.1 çŠ¶æ€æœº](#71-çŠ¶æ€æœº)
    - [7.2 å¹‚ç­‰æ€§](#72-å¹‚ç­‰æ€§)
  - [8. å®Œæ•´æ¡ˆä¾‹](#8-å®Œæ•´æ¡ˆä¾‹)
    - [8.1 ç”µå•†è®¢å•ç³»ç»Ÿ](#81-ç”µå•†è®¢å•ç³»ç»Ÿ)
  - [ğŸ“š åˆ†å¸ƒå¼äº‹åŠ¡æœ€ä½³å®è·µ](#-åˆ†å¸ƒå¼äº‹åŠ¡æœ€ä½³å®è·µ)
    - [æ¨¡å¼é€‰æ‹©](#æ¨¡å¼é€‰æ‹©)
    - [è®¾è®¡åŸåˆ™](#è®¾è®¡åŸåˆ™)
    - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
    - [ç›‘æ§å‘Šè­¦](#ç›‘æ§å‘Šè­¦)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

---

## 1. Sagaæ¨¡å¼

### 1.1 Sagaç¼–æ’å™¨

```go
package saga

import (
 "context"
 "errors"
 "fmt"
 "sync"
)

// Step Sagaæ­¥éª¤
type Step struct {
 Name        string
 Action      func(ctx context.Context, data interface{}) (interface{}, error)
 Compensate  func(ctx context.Context, data interface{}) error
}

// Saga Sagaç¼–æ’å™¨
type Saga struct {
 steps       []Step
 executedSteps []int
 mu          sync.Mutex
}

// NewSaga åˆ›å»ºSaga
func NewSaga() *Saga {
 return &Saga{
  steps:         make([]Step, 0),
  executedSteps: make([]int, 0),
 }
}

// AddStep æ·»åŠ æ­¥éª¤
func (s *Saga) AddStep(step Step) *Saga {
 s.steps = append(s.steps, step)
 return s
}

// Execute æ‰§è¡ŒSaga
func (s *Saga) Execute(ctx context.Context, initialData interface{}) error {
 s.mu.Lock()
 defer s.mu.Unlock()

 data := initialData

 // æ‰§è¡Œæ‰€æœ‰æ­¥éª¤
 for i, step := range s.steps {
  result, err := step.Action(ctx, data)
  if err != nil {
   // å‘ç”Ÿé”™è¯¯ï¼Œæ‰§è¡Œè¡¥å¿
   s.compensate(ctx, initialData)
   return fmt.Errorf("step %s failed: %w", step.Name, err)
  }

  // è®°å½•å·²æ‰§è¡Œçš„æ­¥éª¤
  s.executedSteps = append(s.executedSteps, i)
  data = result
 }

 return nil
}

// compensate æ‰§è¡Œè¡¥å¿
func (s *Saga) compensate(ctx context.Context, data interface{}) {
 // é€†åºæ‰§è¡Œè¡¥å¿
 for i := len(s.executedSteps) - 1; i >= 0; i-- {
  stepIndex := s.executedSteps[i]
  step := s.steps[stepIndex]

  if step.Compensate != nil {
   if err := step.Compensate(ctx, data); err != nil {
    // è®°å½•è¡¥å¿å¤±è´¥ï¼ˆéœ€è¦äººå·¥ä»‹å…¥ï¼‰
    fmt.Printf("Compensation failed for step %s: %v\n", step.Name, err)
   }
  }
 }

 // æ¸…ç©ºå·²æ‰§è¡Œæ­¥éª¤
 s.executedSteps = s.executedSteps[:0]
}
```

---

### 1.2 è®¢å•Sagaç¤ºä¾‹

```go
// OrderSaga è®¢å•Saga
type OrderSaga struct {
 orderService    *OrderService
 inventoryService *InventoryService
 paymentService  *PaymentService
 deliveryService *DeliveryService
}

// CreateOrderSaga åˆ›å»ºè®¢å•Saga
func (os *OrderSaga) CreateOrderSaga(order *Order) *saga.Saga {
 return saga.NewSaga().
  AddStep(saga.Step{
   Name: "create_order",
   Action: func(ctx context.Context, data interface{}) (interface{}, error) {
    order := data.(*Order)
    return os.orderService.CreateOrder(ctx, order)
   },
   Compensate: func(ctx context.Context, data interface{}) error {
    order := data.(*Order)
    return os.orderService.CancelOrder(ctx, order.ID)
   },
  }).
  AddStep(saga.Step{
   Name: "reserve_inventory",
   Action: func(ctx context.Context, data interface{}) (interface{}, error) {
    order := data.(*Order)
    return order, os.inventoryService.ReserveItems(ctx, order.Items)
   },
   Compensate: func(ctx context.Context, data interface{}) error {
    order := data.(*Order)
    return os.inventoryService.ReleaseItems(ctx, order.Items)
   },
  }).
  AddStep(saga.Step{
   Name: "process_payment",
   Action: func(ctx context.Context, data interface{}) (interface{}, error) {
    order := data.(*Order)
    paymentID, err := os.paymentService.ProcessPayment(ctx, order.Payment)
    if err != nil {
     return nil, err
    }
    order.PaymentID = paymentID
    return order, nil
   },
   Compensate: func(ctx context.Context, data interface{}) error {
    order := data.(*Order)
    return os.paymentService.RefundPayment(ctx, order.PaymentID)
   },
  }).
  AddStep(saga.Step{
   Name: "create_delivery",
   Action: func(ctx context.Context, data interface{}) (interface{}, error) {
    order := data.(*Order)
    deliveryID, err := os.deliveryService.CreateDelivery(ctx, order)
    if err != nil {
     return nil, err
    }
    order.DeliveryID = deliveryID
    return order, nil
   },
   Compensate: func(ctx context.Context, data interface{}) error {
    order := data.(*Order)
    return os.deliveryService.CancelDelivery(ctx, order.DeliveryID)
   },
  })
}

// ExecuteOrderCreation æ‰§è¡Œè®¢å•åˆ›å»º
func (os *OrderSaga) ExecuteOrderCreation(ctx context.Context, order *Order) error {
 saga := os.CreateOrderSaga(order)
 return saga.Execute(ctx, order)
}
```

---

## 2. TCCæ¨¡å¼

### 2.1 TCCåè°ƒå™¨

```go
package tcc

import (
 "context"
 "errors"
 "fmt"
 "sync"
 "time"
)

// Participant TCCå‚ä¸è€…æ¥å£
type Participant interface {
 Try(ctx context.Context, data interface{}) error
 Confirm(ctx context.Context, data interface{}) error
 Cancel(ctx context.Context, data interface{}) error
}

// Transaction TCCäº‹åŠ¡
type Transaction struct {
 ID           string
 Status       TransactionStatus
 Participants []Participant
 Data         interface{}
 CreatedAt    time.Time
 UpdatedAt    time.Time
}

// TransactionStatus äº‹åŠ¡çŠ¶æ€
type TransactionStatus int

const (
 StatusTrying TransactionStatus = iota
 StatusConfirmed
 StatusCancelled
 StatusFailed
)

// Coordinator TCCåè°ƒå™¨
type Coordinator struct {
 transactions map[string]*Transaction
 mu           sync.RWMutex
}

// NewCoordinator åˆ›å»ºTCCåè°ƒå™¨
func NewCoordinator() *Coordinator {
 return &Coordinator{
  transactions: make(map[string]*Transaction),
 }
}

// Begin å¼€å§‹äº‹åŠ¡
func (c *Coordinator) Begin(ctx context.Context, id string, participants []Participant, data interface{}) (*Transaction, error) {
 c.mu.Lock()
 defer c.mu.Unlock()

 tx := &Transaction{
  ID:           id,
  Status:       StatusTrying,
  Participants: participants,
  Data:         data,
  CreatedAt:    time.Now(),
  UpdatedAt:    time.Now(),
 }

 c.transactions[id] = tx

 // Tryé˜¶æ®µ
 for _, p := range participants {
  if err := p.Try(ctx, data); err != nil {
   // Tryå¤±è´¥ï¼Œæ‰§è¡ŒCancel
   c.cancel(ctx, tx)
   return nil, fmt.Errorf("try phase failed: %w", err)
  }
 }

 return tx, nil
}

// Commit æäº¤äº‹åŠ¡
func (c *Coordinator) Commit(ctx context.Context, txID string) error {
 c.mu.Lock()
 defer c.mu.Unlock()

 tx, ok := c.transactions[txID]
 if !ok {
  return errors.New("transaction not found")
 }

 if tx.Status != StatusTrying {
  return errors.New("transaction not in trying status")
 }

 // Confirmé˜¶æ®µ
 for _, p := range tx.Participants {
  if err := p.Confirm(ctx, tx.Data); err != nil {
   tx.Status = StatusFailed
   tx.UpdatedAt = time.Now()
   return fmt.Errorf("confirm phase failed: %w", err)
  }
 }

 tx.Status = StatusConfirmed
 tx.UpdatedAt = time.Now()

 return nil
}

// Rollback å›æ»šäº‹åŠ¡
func (c *Coordinator) Rollback(ctx context.Context, txID string) error {
 c.mu.Lock()
 defer c.mu.Unlock()

 tx, ok := c.transactions[txID]
 if !ok {
  return errors.New("transaction not found")
 }

 return c.cancel(ctx, tx)
}

// cancel å–æ¶ˆäº‹åŠ¡
func (c *Coordinator) cancel(ctx context.Context, tx *Transaction) error {
 // Cancelé˜¶æ®µ
 for _, p := range tx.Participants {
  if err := p.Cancel(ctx, tx.Data); err != nil {
   // è®°å½•Cancelå¤±è´¥ï¼ˆéœ€è¦è¡¥å¿ï¼‰
   fmt.Printf("Cancel failed for transaction %s: %v\n", tx.ID, err)
  }
 }

 tx.Status = StatusCancelled
 tx.UpdatedAt = time.Now()

 return nil
}
```

---

### 2.2 TCCå®ç°ç¤ºä¾‹

```go
// AccountParticipant è´¦æˆ·TCCå‚ä¸è€…
type AccountParticipant struct {
 db *sql.DB
}

// Try å°è¯•é˜¶æ®µï¼šå†»ç»“èµ„é‡‘
func (ap *AccountParticipant) Try(ctx context.Context, data interface{}) error {
 transfer := data.(*Transfer)

 tx, err := ap.db.BeginTx(ctx, nil)
 if err != nil {
  return err
 }
 defer tx.Rollback()

 // æ£€æŸ¥ä½™é¢
 var balance float64
 err = tx.QueryRowContext(ctx,
  "SELECT balance FROM accounts WHERE id = ? FOR UPDATE",
  transfer.FromAccount).Scan(&balance)
 if err != nil {
  return err
 }

 if balance < transfer.Amount {
  return errors.New("insufficient balance")
 }

 // å†»ç»“é‡‘é¢
 _, err = tx.ExecContext(ctx,
  "UPDATE accounts SET frozen = frozen + ? WHERE id = ?",
  transfer.Amount, transfer.FromAccount)
 if err != nil {
  return err
 }

 // è®°å½•å†»ç»“
 _, err = tx.ExecContext(ctx,
  "INSERT INTO frozen_records (tx_id, account_id, amount, created_at) VALUES (?, ?, ?, ?)",
  transfer.TxID, transfer.FromAccount, transfer.Amount, time.Now())
 if err != nil {
  return err
 }

 return tx.Commit()
}

// Confirm ç¡®è®¤é˜¶æ®µï¼šæ‰£é™¤ä½™é¢ï¼Œè§£å†»
func (ap *AccountParticipant) Confirm(ctx context.Context, data interface{}) error {
 transfer := data.(*Transfer)

 tx, err := ap.db.BeginTx(ctx, nil)
 if err != nil {
  return err
 }
 defer tx.Rollback()

 // æ‰£é™¤ä½™é¢
 _, err = tx.ExecContext(ctx,
  "UPDATE accounts SET balance = balance - ?, frozen = frozen - ? WHERE id = ?",
  transfer.Amount, transfer.Amount, transfer.FromAccount)
 if err != nil {
  return err
 }

 // å¢åŠ ç›®æ ‡è´¦æˆ·ä½™é¢
 _, err = tx.ExecContext(ctx,
  "UPDATE accounts SET balance = balance + ? WHERE id = ?",
  transfer.Amount, transfer.ToAccount)
 if err != nil {
  return err
 }

 // åˆ é™¤å†»ç»“è®°å½•
 _, err = tx.ExecContext(ctx,
  "DELETE FROM frozen_records WHERE tx_id = ?",
  transfer.TxID)
 if err != nil {
  return err
 }

 return tx.Commit()
}

// Cancel å–æ¶ˆé˜¶æ®µï¼šè§£å†»èµ„é‡‘
func (ap *AccountParticipant) Cancel(ctx context.Context, data interface{}) error {
 transfer := data.(*Transfer)

 tx, err := ap.db.BeginTx(ctx, nil)
 if err != nil {
  return err
 }
 defer tx.Rollback()

 // è§£å†»é‡‘é¢
 _, err = tx.ExecContext(ctx,
  "UPDATE accounts SET frozen = frozen - ? WHERE id = ?",
  transfer.Amount, transfer.FromAccount)
 if err != nil {
  return err
 }

 // åˆ é™¤å†»ç»“è®°å½•
 _, err = tx.ExecContext(ctx,
  "DELETE FROM frozen_records WHERE tx_id = ?",
  transfer.TxID)
 if err != nil {
  return err
 }

 return tx.Commit()
}
```

---

## 3. ä¸¤é˜¶æ®µæäº¤

### 3.1 2PCåè°ƒå™¨

```go
package twopc

import (
 "context"
 "errors"
 "fmt"
 "sync"
 "time"
)

// Participant 2PCå‚ä¸è€…æ¥å£
type Participant interface {
 Prepare(ctx context.Context, txID string) (bool, error)
 Commit(ctx context.Context, txID string) error
 Abort(ctx context.Context, txID string) error
}

// Coordinator 2PCåè°ƒå™¨
type Coordinator struct {
 participants []Participant
 mu           sync.Mutex
}

// NewCoordinator åˆ›å»º2PCåè°ƒå™¨
func NewCoordinator(participants []Participant) *Coordinator {
 return &Coordinator{
  participants: participants,
 }
}

// Execute æ‰§è¡Œä¸¤é˜¶æ®µæäº¤
func (c *Coordinator) Execute(ctx context.Context, txID string) error {
 c.mu.Lock()
 defer c.mu.Unlock()

 // ç¬¬ä¸€é˜¶æ®µï¼šPrepare
 prepareResults := make([]bool, len(c.participants))
 prepareErrors := make([]error, len(c.participants))

 var wg sync.WaitGroup
 for i, p := range c.participants {
  wg.Add(1)
  go func(index int, participant Participant) {
   defer wg.Done()

   prepared, err := participant.Prepare(ctx, txID)
   prepareResults[index] = prepared
   prepareErrors[index] = err
  }(i, p)
 }

 wg.Wait()

 // æ£€æŸ¥Prepareç»“æœ
 allPrepared := true
 for i, err := range prepareErrors {
  if err != nil || !prepareResults[i] {
   allPrepared = false
   break
  }
 }

 // ç¬¬äºŒé˜¶æ®µï¼šCommitæˆ–Abort
 if allPrepared {
  // æ‰€æœ‰å‚ä¸è€…éƒ½å‡†å¤‡å¥½ï¼Œæ‰§è¡ŒCommit
  return c.commitAll(ctx, txID)
 } else {
  // æœ‰å‚ä¸è€…æœªå‡†å¤‡å¥½ï¼Œæ‰§è¡ŒAbort
  return c.abortAll(ctx, txID)
 }
}

// commitAll æäº¤æ‰€æœ‰å‚ä¸è€…
func (c *Coordinator) commitAll(ctx context.Context, txID string) error {
 var wg sync.WaitGroup
 errors := make([]error, len(c.participants))

 for i, p := range c.participants {
  wg.Add(1)
  go func(index int, participant Participant) {
   defer wg.Done()
   errors[index] = participant.Commit(ctx, txID)
  }(i, p)
 }

 wg.Wait()

 // æ£€æŸ¥æäº¤ç»“æœ
 for _, err := range errors {
  if err != nil {
   return fmt.Errorf("commit failed: %w", err)
  }
 }

 return nil
}

// abortAll ä¸­æ­¢æ‰€æœ‰å‚ä¸è€…
func (c *Coordinator) abortAll(ctx context.Context, txID string) error {
 var wg sync.WaitGroup

 for _, p := range c.participants {
  wg.Add(1)
  go func(participant Participant) {
   defer wg.Done()
   participant.Abort(ctx, txID)
  }(p)
 }

 wg.Wait()

 return errors.New("transaction aborted")
}
```

---

### 3.2 å‚ä¸è€…å®ç°

```go
// DatabaseParticipant æ•°æ®åº“2PCå‚ä¸è€…
type DatabaseParticipant struct {
 db         *sql.DB
 preparedTx map[string]*sql.Tx
 mu         sync.RWMutex
}

// NewDatabaseParticipant åˆ›å»ºæ•°æ®åº“å‚ä¸è€…
func NewDatabaseParticipant(db *sql.DB) *DatabaseParticipant {
 return &DatabaseParticipant{
  db:         db,
  preparedTx: make(map[string]*sql.Tx),
 }
}

// Prepare å‡†å¤‡é˜¶æ®µ
func (dp *DatabaseParticipant) Prepare(ctx context.Context, txID string) (bool, error) {
 dp.mu.Lock()
 defer dp.mu.Unlock()

 // å¼€å§‹äº‹åŠ¡
 tx, err := dp.db.BeginTx(ctx, nil)
 if err != nil {
  return false, err
 }

 // æ‰§è¡Œä¸šåŠ¡é€»è¾‘ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼‰
 // ...

 // ä¿å­˜å‡†å¤‡å¥½çš„äº‹åŠ¡
 dp.preparedTx[txID] = tx

 return true, nil
}

// Commit æäº¤é˜¶æ®µ
func (dp *DatabaseParticipant) Commit(ctx context.Context, txID string) error {
 dp.mu.Lock()
 defer dp.mu.Unlock()

 tx, ok := dp.preparedTx[txID]
 if !ok {
  return errors.New("transaction not prepared")
 }

 err := tx.Commit()
 if err != nil {
  return err
 }

 delete(dp.preparedTx, txID)
 return nil
}

// Abort ä¸­æ­¢é˜¶æ®µ
func (dp *DatabaseParticipant) Abort(ctx context.Context, txID string) error {
 dp.mu.Lock()
 defer dp.mu.Unlock()

 tx, ok := dp.preparedTx[txID]
 if !ok {
  return nil // å·²ç»ä¸­æ­¢æˆ–æœªå‡†å¤‡
 }

 err := tx.Rollback()
 delete(dp.preparedTx, txID)

 return err
}
```

---

## 4. æœ¬åœ°æ¶ˆæ¯è¡¨

### 4.1 æ¶ˆæ¯è¡¨è®¾è®¡

```go
package localmsg

import (
 "context"
 "database/sql"
 "encoding/json"
 "time"
)

// Message æœ¬åœ°æ¶ˆæ¯
type Message struct {
 ID         int64
 Topic      string
 Key        string
 Payload    json.RawMessage
 Status     MessageStatus
 RetryCount int
 MaxRetry   int
 NextRetry  time.Time
 CreatedAt  time.Time
 UpdatedAt  time.Time
}

// MessageStatus æ¶ˆæ¯çŠ¶æ€
type MessageStatus string

const (
 StatusPending   MessageStatus = "pending"
 StatusSent      MessageStatus = "sent"
 StatusFailed    MessageStatus = "failed"
)

// LocalMessageTable æœ¬åœ°æ¶ˆæ¯è¡¨
type LocalMessageTable struct {
 db *sql.DB
}

// NewLocalMessageTable åˆ›å»ºæœ¬åœ°æ¶ˆæ¯è¡¨
func NewLocalMessageTable(db *sql.DB) *LocalMessageTable {
 return &LocalMessageTable{db: db}
}

// SaveWithTransaction åœ¨äº‹åŠ¡ä¸­ä¿å­˜æ¶ˆæ¯
func (lmt *LocalMessageTable) SaveWithTransaction(ctx context.Context, tx *sql.Tx, msg *Message) error {
 payload, err := json.Marshal(msg.Payload)
 if err != nil {
  return err
 }

 result, err := tx.ExecContext(ctx, `
  INSERT INTO local_messages
  (topic, message_key, payload, status, retry_count, max_retry, next_retry, created_at, updated_at)
  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
 `, msg.Topic, msg.Key, payload, StatusPending, 0, msg.MaxRetry, time.Now(), time.Now(), time.Now())

 if err != nil {
  return err
 }

 id, err := result.LastInsertId()
 if err != nil {
  return err
 }

 msg.ID = id
 return nil
}

// GetPendingMessages è·å–å¾…å‘é€æ¶ˆæ¯
func (lmt *LocalMessageTable) GetPendingMessages(ctx context.Context, limit int) ([]*Message, error) {
 rows, err := lmt.db.QueryContext(ctx, `
  SELECT id, topic, message_key, payload, status, retry_count, max_retry, next_retry, created_at, updated_at
  FROM local_messages
  WHERE status = ? AND next_retry <= ?
  ORDER BY created_at
  LIMIT ?
 `, StatusPending, time.Now(), limit)

 if err != nil {
  return nil, err
 }
 defer rows.Close()

 messages := make([]*Message, 0)
 for rows.Next() {
  msg := &Message{}
  err := rows.Scan(
   &msg.ID, &msg.Topic, &msg.Key, &msg.Payload, &msg.Status,
   &msg.RetryCount, &msg.MaxRetry, &msg.NextRetry, &msg.CreatedAt, &msg.UpdatedAt,
  )
  if err != nil {
   return nil, err
  }
  messages = append(messages, msg)
 }

 return messages, rows.Err()
}

// MarkAsSent æ ‡è®°ä¸ºå·²å‘é€
func (lmt *LocalMessageTable) MarkAsSent(ctx context.Context, id int64) error {
 _, err := lmt.db.ExecContext(ctx, `
  UPDATE local_messages
  SET status = ?, updated_at = ?
  WHERE id = ?
 `, StatusSent, time.Now(), id)

 return err
}

// MarkAsFailed æ ‡è®°ä¸ºå¤±è´¥å¹¶æ›´æ–°é‡è¯•ä¿¡æ¯
func (lmt *LocalMessageTable) MarkAsFailed(ctx context.Context, id int64) error {
 _, err := lmt.db.ExecContext(ctx, `
  UPDATE local_messages
  SET retry_count = retry_count + 1,
      next_retry = ?,
      status = CASE
          WHEN retry_count + 1 >= max_retry THEN ?
          ELSE status
      END,
      updated_at = ?
  WHERE id = ?
 `, time.Now().Add(time.Minute*5), StatusFailed, time.Now(), id)

 return err
}
```

---

### 4.2 æ¶ˆæ¯å‘é€ä¸ç¡®è®¤

```go
// MessageProducer æ¶ˆæ¯ç”Ÿäº§è€…
type MessageProducer struct {
 lmt    *LocalMessageTable
 broker MessageBroker
}

// MessageBroker æ¶ˆæ¯ä»£ç†æ¥å£
type MessageBroker interface {
 Send(ctx context.Context, topic, key string, payload []byte) error
}

// NewMessageProducer åˆ›å»ºæ¶ˆæ¯ç”Ÿäº§è€…
func NewMessageProducer(lmt *LocalMessageTable, broker MessageBroker) *MessageProducer {
 return &MessageProducer{
  lmt:    lmt,
  broker: broker,
 }
}

// PublishWithTransaction åœ¨äº‹åŠ¡ä¸­å‘å¸ƒæ¶ˆæ¯
func (mp *MessageProducer) PublishWithTransaction(ctx context.Context, tx *sql.Tx, topic, key string, payload interface{}) error {
 payloadBytes, err := json.Marshal(payload)
 if err != nil {
  return err
 }

 msg := &Message{
  Topic:    topic,
  Key:      key,
  Payload:  payloadBytes,
  MaxRetry: 5,
 }

 return mp.lmt.SaveWithTransaction(ctx, tx, msg)
}

// SendPendingMessages å‘é€å¾…å‘é€æ¶ˆæ¯
func (mp *MessageProducer) SendPendingMessages(ctx context.Context) error {
 messages, err := mp.lmt.GetPendingMessages(ctx, 100)
 if err != nil {
  return err
 }

 for _, msg := range messages {
  err := mp.broker.Send(ctx, msg.Topic, msg.Key, msg.Payload)
  if err != nil {
   mp.lmt.MarkAsFailed(ctx, msg.ID)
   continue
  }

  mp.lmt.MarkAsSent(ctx, msg.ID)
 }

 return nil
}

// StartScheduler å¯åŠ¨å®šæ—¶å‘é€
func (mp *MessageProducer) StartScheduler(ctx context.Context) {
 ticker := time.NewTicker(time.Second * 5)
 defer ticker.Stop()

 for {
  select {
  case <-ctx.Done():
   return
  case <-ticker.C:
   mp.SendPendingMessages(ctx)
  }
 }
}
```

---

## 5. äº‹åŠ¡æ¶ˆæ¯

### 5.1 RocketMQäº‹åŠ¡æ¶ˆæ¯

```go
package transactionmsg

import (
 "context"
 "fmt"

 "github.com/apache/rocketmq-client-go/v2"
 "github.com/apache/rocketmq-client-go/v2/primitive"
 "github.com/apache/rocketmq-client-go/v2/producer"
)

// TransactionalProducer äº‹åŠ¡æ¶ˆæ¯ç”Ÿäº§è€…
type TransactionalProducer struct {
 producer rocketmq.TransactionProducer
}

// NewTransactionalProducer åˆ›å»ºäº‹åŠ¡æ¶ˆæ¯ç”Ÿäº§è€…
func NewTransactionalProducer(nameservers []string, listener primitive.TransactionListener) (*TransactionalProducer, error) {
 p, err := rocketmq.NewTransactionProducer(
  listener,
  producer.WithNsResolver(primitive.NewPassthroughResolver(nameservers)),
  producer.WithRetry(2),
 )

 if err != nil {
  return nil, err
 }

 err = p.Start()
 if err != nil {
  return nil, err
 }

 return &TransactionalProducer{producer: p}, nil
}

// SendMessageInTransaction å‘é€äº‹åŠ¡æ¶ˆæ¯
func (tp *TransactionalProducer) SendMessageInTransaction(ctx context.Context, msg *primitive.Message) (*primitive.TransactionSendResult, error) {
 return tp.producer.SendMessageInTransaction(ctx, msg)
}

// OrderTransactionListener è®¢å•äº‹åŠ¡ç›‘å¬å™¨
type OrderTransactionListener struct {
 orderService *OrderService
}

// ExecuteLocalTransaction æ‰§è¡Œæœ¬åœ°äº‹åŠ¡
func (otl *OrderTransactionListener) ExecuteLocalTransaction(msg *primitive.Message) primitive.LocalTransactionState {
 // è§£ææ¶ˆæ¯
 order := &Order{}
 if err := json.Unmarshal(msg.Body, order); err != nil {
  return primitive.RollbackMessageState
 }

 // æ‰§è¡Œæœ¬åœ°äº‹åŠ¡
 if err := otl.orderService.CreateOrder(context.Background(), order); err != nil {
  return primitive.RollbackMessageState
 }

 return primitive.CommitMessageState
}

// CheckLocalTransaction æ£€æŸ¥æœ¬åœ°äº‹åŠ¡çŠ¶æ€
func (otl *OrderTransactionListener) CheckLocalTransaction(msg *primitive.MessageExt) primitive.LocalTransactionState {
 // è§£ææ¶ˆæ¯ID
 orderID := string(msg.Body)

 // æŸ¥è¯¢è®¢å•çŠ¶æ€
 order, err := otl.orderService.GetOrder(context.Background(), orderID)
 if err != nil {
  return primitive.UnknowState
 }

 if order.Status == OrderStatusCreated {
  return primitive.CommitMessageState
 }

 return primitive.RollbackMessageState
}
```

---

### 5.2 Kafkaäº‹åŠ¡æ¶ˆæ¯

```go
// KafkaTransactionalProducer Kafkaäº‹åŠ¡ç”Ÿäº§è€…
type KafkaTransactionalProducer struct {
 producer *kafka.Producer
}

// NewKafkaTransactionalProducer åˆ›å»ºKafkaäº‹åŠ¡ç”Ÿäº§è€…
func NewKafkaTransactionalProducer(brokers []string, transactionalID string) (*KafkaTransactionalProducer, error) {
 config := &kafka.ConfigMap{
  "bootstrap.servers":       strings.Join(brokers, ","),
  "transactional.id":        transactionalID,
  "enable.idempotence":      true,
  "max.in.flight.requests.per.connection": 5,
 }

 producer, err := kafka.NewProducer(config)
 if err != nil {
  return nil, err
 }

 // åˆå§‹åŒ–äº‹åŠ¡
 if err := producer.InitTransactions(nil); err != nil {
  return nil, err
 }

 return &KafkaTransactionalProducer{producer: producer}, nil
}

// SendMessageInTransaction åœ¨äº‹åŠ¡ä¸­å‘é€æ¶ˆæ¯
func (ktp *KafkaTransactionalProducer) SendMessageInTransaction(
 ctx context.Context,
 topic string,
 key, value []byte,
 localTxFunc func() error,
) error {
 // å¼€å§‹äº‹åŠ¡
 if err := ktp.producer.BeginTransaction(); err != nil {
  return err
 }

 // æ‰§è¡Œæœ¬åœ°äº‹åŠ¡
 if err := localTxFunc(); err != nil {
  ktp.producer.AbortTransaction(nil)
  return err
 }

 // å‘é€æ¶ˆæ¯
 msg := &kafka.Message{
  TopicPartition: kafka.TopicPartition{
   Topic:     &topic,
   Partition: kafka.PartitionAny,
  },
  Key:   key,
  Value: value,
 }

 deliveryChan := make(chan kafka.Event)
 if err := ktp.producer.Produce(msg, deliveryChan); err != nil {
  ktp.producer.AbortTransaction(nil)
  return err
 }

 // ç­‰å¾…å‘é€ç»“æœ
 e := <-deliveryChan
 m := e.(*kafka.Message)

 if m.TopicPartition.Error != nil {
  ktp.producer.AbortTransaction(nil)
  return m.TopicPartition.Error
 }

 // æäº¤äº‹åŠ¡
 if err := ktp.producer.CommitTransaction(nil); err != nil {
  return err
 }

 return nil
}
```

---

## 6. æœ€å¤§åŠªåŠ›é€šçŸ¥

### 6.1 é€šçŸ¥æœåŠ¡

```go
package besteffort

import (
 "context"
 "database/sql"
 "encoding/json"
 "net/http"
 "time"
)

// Notification é€šçŸ¥
type Notification struct {
 ID          int64
 URL         string
 Method      string
 Headers     map[string]string
 Body        json.RawMessage
 Status      NotificationStatus
 RetryCount  int
 MaxRetry    int
 NextRetry   time.Time
 LastError   string
 CreatedAt   time.Time
 UpdatedAt   time.Time
}

// NotificationStatus é€šçŸ¥çŠ¶æ€
type NotificationStatus string

const (
 NotifStatusPending   NotificationStatus = "pending"
 NotifStatusSucceeded NotificationStatus = "succeeded"
 NotifStatusFailed    NotificationStatus = "failed"
)

// NotificationService é€šçŸ¥æœåŠ¡
type NotificationService struct {
 db     *sql.DB
 client *http.Client
}

// NewNotificationService åˆ›å»ºé€šçŸ¥æœåŠ¡
func NewNotificationService(db *sql.DB) *NotificationService {
 return &NotificationService{
  db: db,
  client: &http.Client{
   Timeout: time.Second * 30,
  },
 }
}

// CreateNotification åˆ›å»ºé€šçŸ¥
func (ns *NotificationService) CreateNotification(ctx context.Context, notif *Notification) error {
 headers, _ := json.Marshal(notif.Headers)

 result, err := ns.db.ExecContext(ctx, `
  INSERT INTO notifications
  (url, method, headers, body, status, retry_count, max_retry, next_retry, created_at, updated_at)
  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
 `, notif.URL, notif.Method, headers, notif.Body, NotifStatusPending, 0, notif.MaxRetry, time.Now(), time.Now(), time.Now())

 if err != nil {
  return err
 }

 id, _ := result.LastInsertId()
 notif.ID = id

 return nil
}

// SendNotification å‘é€é€šçŸ¥
func (ns *NotificationService) SendNotification(ctx context.Context, notif *Notification) error {
 // åˆ›å»ºHTTPè¯·æ±‚
 req, err := http.NewRequestWithContext(ctx, notif.Method, notif.URL, bytes.NewReader(notif.Body))
 if err != nil {
  return err
 }

 // è®¾ç½®è¯·æ±‚å¤´
 for key, value := range notif.Headers {
  req.Header.Set(key, value)
 }

 // å‘é€è¯·æ±‚
 resp, err := ns.client.Do(req)
 if err != nil {
  return err
 }
 defer resp.Body.Close()

 if resp.StatusCode < 200 || resp.StatusCode >= 300 {
  return fmt.Errorf("notification failed with status: %d", resp.StatusCode)
 }

 return nil
}

// ProcessPendingNotifications å¤„ç†å¾…å‘é€é€šçŸ¥
func (ns *NotificationService) ProcessPendingNotifications(ctx context.Context) error {
 // è·å–å¾…å‘é€é€šçŸ¥
 rows, err := ns.db.QueryContext(ctx, `
  SELECT id, url, method, headers, body, status, retry_count, max_retry
  FROM notifications
  WHERE status = ? AND next_retry <= ?
  LIMIT 100
 `, NotifStatusPending, time.Now())

 if err != nil {
  return err
 }
 defer rows.Close()

 for rows.Next() {
  notif := &Notification{}
  var headers string

  err := rows.Scan(
   &notif.ID, &notif.URL, &notif.Method, &headers, &notif.Body,
   &notif.Status, &notif.RetryCount, &notif.MaxRetry,
  )
  if err != nil {
   continue
  }

  json.Unmarshal([]byte(headers), &notif.Headers)

  // å‘é€é€šçŸ¥
  err = ns.SendNotification(ctx, notif)
  if err != nil {
   ns.updateNotificationFailed(ctx, notif.ID, err.Error())
  } else {
   ns.updateNotificationSucceeded(ctx, notif.ID)
  }
 }

 return rows.Err()
}

// updateNotificationSucceeded æ›´æ–°é€šçŸ¥ä¸ºæˆåŠŸ
func (ns *NotificationService) updateNotificationSucceeded(ctx context.Context, id int64) error {
 _, err := ns.db.ExecContext(ctx, `
  UPDATE notifications
  SET status = ?, updated_at = ?
  WHERE id = ?
 `, NotifStatusSucceeded, time.Now(), id)

 return err
}

// updateNotificationFailed æ›´æ–°é€šçŸ¥ä¸ºå¤±è´¥
func (ns *NotificationService) updateNotificationFailed(ctx context.Context, id int64, errMsg string) error {
 _, err := ns.db.ExecContext(ctx, `
  UPDATE notifications
  SET retry_count = retry_count + 1,
      last_error = ?,
      next_retry = ?,
      status = CASE
          WHEN retry_count + 1 >= max_retry THEN ?
          ELSE status
      END,
      updated_at = ?
  WHERE id = ?
 `, errMsg, time.Now().Add(time.Minute*5), NotifStatusFailed, time.Now(), id)

 return err
}
```

---

### 6.2 é‡è¯•ç­–ç•¥

```go
// RetryStrategy é‡è¯•ç­–ç•¥
type RetryStrategy interface {
 NextRetryTime(retryCount int) time.Time
}

// ExponentialBackoff æŒ‡æ•°é€€é¿
type ExponentialBackoff struct {
 InitialInterval time.Duration
 MaxInterval     time.Duration
 Multiplier      float64
}

// NextRetryTime è®¡ç®—ä¸‹æ¬¡é‡è¯•æ—¶é—´
func (eb *ExponentialBackoff) NextRetryTime(retryCount int) time.Time {
 interval := float64(eb.InitialInterval)

 for i := 0; i < retryCount; i++ {
  interval *= eb.Multiplier
  if time.Duration(interval) > eb.MaxInterval {
   interval = float64(eb.MaxInterval)
   break
  }
 }

 return time.Now().Add(time.Duration(interval))
}

// FixedInterval å›ºå®šé—´éš”
type FixedInterval struct {
 Interval time.Duration
}

// NextRetryTime è®¡ç®—ä¸‹æ¬¡é‡è¯•æ—¶é—´
func (fi *FixedInterval) NextRetryTime(retryCount int) time.Time {
 return time.Now().Add(fi.Interval)
}
```

---

## 7. æœ€ç»ˆä¸€è‡´æ€§

### 7.1 çŠ¶æ€æœº

```go
package consistency

import (
 "errors"
 "sync"
)

// State çŠ¶æ€
type State string

// Event äº‹ä»¶
type Event string

// StateMachine çŠ¶æ€æœº
type StateMachine struct {
 currentState  State
 transitions   map[State]map[Event]State
 handlers      map[State]map[Event]func() error
 mu            sync.RWMutex
}

// NewStateMachine åˆ›å»ºçŠ¶æ€æœº
func NewStateMachine(initialState State) *StateMachine {
 return &StateMachine{
  currentState: initialState,
  transitions:  make(map[State]map[Event]State),
  handlers:     make(map[State]map[Event]func() error),
 }
}

// AddTransition æ·»åŠ çŠ¶æ€è½¬æ¢
func (sm *StateMachine) AddTransition(from State, event Event, to State, handler func() error) {
 sm.mu.Lock()
 defer sm.mu.Unlock()

 if sm.transitions[from] == nil {
  sm.transitions[from] = make(map[Event]State)
 }
 sm.transitions[from][event] = to

 if sm.handlers[from] == nil {
  sm.handlers[from] = make(map[Event]func() error)
 }
 sm.handlers[from][event] = handler
}

// Trigger è§¦å‘äº‹ä»¶
func (sm *StateMachine) Trigger(event Event) error {
 sm.mu.Lock()
 defer sm.mu.Unlock()

 // æ£€æŸ¥è½¬æ¢æ˜¯å¦å­˜åœ¨
 transitions, ok := sm.transitions[sm.currentState]
 if !ok {
  return errors.New("no transitions from current state")
 }

 nextState, ok := transitions[event]
 if !ok {
  return errors.New("invalid event for current state")
 }

 // æ‰§è¡Œå¤„ç†å™¨
 if handler := sm.handlers[sm.currentState][event]; handler != nil {
  if err := handler(); err != nil {
   return err
  }
 }

 // æ›´æ–°çŠ¶æ€
 sm.currentState = nextState

 return nil
}

// CurrentState è·å–å½“å‰çŠ¶æ€
func (sm *StateMachine) CurrentState() State {
 sm.mu.RLock()
 defer sm.mu.RUnlock()

 return sm.currentState
}

// OrderStateMachine è®¢å•çŠ¶æ€æœºç¤ºä¾‹
func NewOrderStateMachine(order *Order) *StateMachine {
 sm := NewStateMachine(State("created"))

 // å®šä¹‰çŠ¶æ€è½¬æ¢
 sm.AddTransition(
  State("created"),
  Event("pay"),
  State("paid"),
  func() error {
   // æ”¯ä»˜å¤„ç†
   return nil
  },
 )

 sm.AddTransition(
  State("paid"),
  Event("ship"),
  State("shipped"),
  func() error {
   // å‘è´§å¤„ç†
   return nil
  },
 )

 sm.AddTransition(
  State("shipped"),
  Event("deliver"),
  State("delivered"),
  func() error {
   // é…é€å®Œæˆå¤„ç†
   return nil
  },
 )

 sm.AddTransition(
  State("created"),
  Event("cancel"),
  State("cancelled"),
  func() error {
   // å–æ¶ˆå¤„ç†
   return nil
  },
 )

 return sm
}
```

---

### 7.2 å¹‚ç­‰æ€§

```go
// IdempotentService å¹‚ç­‰æœåŠ¡
type IdempotentService struct {
 cache *redis.Client
 ttl   time.Duration
}

// NewIdempotentService åˆ›å»ºå¹‚ç­‰æœåŠ¡
func NewIdempotentService(cache *redis.Client, ttl time.Duration) *IdempotentService {
 return &IdempotentService{
  cache: cache,
  ttl:   ttl,
 }
}

// CheckAndSet æ£€æŸ¥å¹¶è®¾ç½®å¹‚ç­‰é”®
func (is *IdempotentService) CheckAndSet(ctx context.Context, key string) (bool, error) {
 // ä½¿ç”¨SetNXç¡®ä¿åŸå­æ€§
 success, err := is.cache.SetNX(ctx, key, "1", is.ttl).Result()
 if err != nil {
  return false, err
 }

 return success, nil
}

// Remove ç§»é™¤å¹‚ç­‰é”®
func (is *IdempotentService) Remove(ctx context.Context, key string) error {
 return is.cache.Del(ctx, key).Err()
}

// IdempotentMiddleware å¹‚ç­‰ä¸­é—´ä»¶
func IdempotentMiddleware(service *IdempotentService) func(http.Handler) http.Handler {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   // ä»è¯·æ±‚å¤´è·å–å¹‚ç­‰é”®
   idempotentKey := r.Header.Get("X-Idempotent-Key")
   if idempotentKey == "" {
    http.Error(w, "Missing idempotent key", http.StatusBadRequest)
    return
   }

   // æ£€æŸ¥å¹‚ç­‰æ€§
   success, err := service.CheckAndSet(r.Context(), idempotentKey)
   if err != nil {
    http.Error(w, "Internal server error", http.StatusInternalServerError)
    return
   }

   if !success {
    http.Error(w, "Duplicate request", http.StatusConflict)
    return
   }

   next.ServeHTTP(w, r)
  })
 }
}
```

---

## 8. å®Œæ•´æ¡ˆä¾‹

### 8.1 ç”µå•†è®¢å•ç³»ç»Ÿ

```go
package main

import (
 "context"
 "database/sql"
 "log"
)

// OrderService è®¢å•æœåŠ¡
type OrderService struct {
 db              *sql.DB
 saga            *saga.Saga
 lmt             *localmsg.LocalMessageTable
 producer        *localmsg.MessageProducer
 notificationSvc *besteffort.NotificationService
 idempotentSvc   *IdempotentService
}

// CreateOrder åˆ›å»ºè®¢å•ï¼ˆä½¿ç”¨Sagaæ¨¡å¼ï¼‰
func (os *OrderService) CreateOrder(ctx context.Context, order *Order) error {
 // åˆ›å»ºè®¢å•Saga
 orderSaga := os.createOrderSaga(order)

 // æ‰§è¡ŒSaga
 return orderSaga.Execute(ctx, order)
}

// createOrderSaga åˆ›å»ºè®¢å•Saga
func (os *OrderService) createOrderSaga(order *Order) *saga.Saga {
 return saga.NewSaga().
  AddStep(saga.Step{
   Name: "validate_order",
   Action: func(ctx context.Context, data interface{}) (interface{}, error) {
    return data, os.validateOrder(ctx, data.(*Order))
   },
   Compensate: nil,
  }).
  AddStep(saga.Step{
   Name: "create_order_record",
   Action: func(ctx context.Context, data interface{}) (interface{}, error) {
    order := data.(*Order)

    // å¼€å§‹æ•°æ®åº“äº‹åŠ¡
    tx, err := os.db.BeginTx(ctx, nil)
    if err != nil {
     return nil, err
    }
    defer tx.Rollback()

    // æ’å…¥è®¢å•
    result, err := tx.ExecContext(ctx, `
     INSERT INTO orders (user_id, total_amount, status, created_at)
     VALUES (?, ?, ?, ?)
    `, order.UserID, order.TotalAmount, "created", time.Now())

    if err != nil {
     return nil, err
    }

    orderID, _ := result.LastInsertId()
    order.ID = orderID

    // ä¿å­˜æœ¬åœ°æ¶ˆæ¯ï¼ˆè®¢å•åˆ›å»ºäº‹ä»¶ï¼‰
    msg := &localmsg.Message{
     Topic:    "order-events",
     Key:      fmt.Sprintf("%d", orderID),
     Payload:  mustMarshal(order),
     MaxRetry: 5,
    }

    if err := os.lmt.SaveWithTransaction(ctx, tx, msg); err != nil {
     return nil, err
    }

    // æäº¤äº‹åŠ¡
    if err := tx.Commit(); err != nil {
     return nil, err
    }

    return order, nil
   },
   Compensate: func(ctx context.Context, data interface{}) error {
    order := data.(*Order)
    _, err := os.db.ExecContext(ctx, `
     UPDATE orders SET status = 'cancelled' WHERE id = ?
    `, order.ID)
    return err
   },
  }).
  AddStep(saga.Step{
   Name: "reserve_inventory",
   Action: func(ctx context.Context, data interface{}) (interface{}, error) {
    order := data.(*Order)
    // è°ƒç”¨åº“å­˜æœåŠ¡
    return order, os.callInventoryService(ctx, "reserve", order)
   },
   Compensate: func(ctx context.Context, data interface{}) error {
    order := data.(*Order)
    return os.callInventoryService(ctx, "release", order)
   },
  }).
  AddStep(saga.Step{
   Name: "process_payment",
   Action: func(ctx context.Context, data interface{}) (interface{}, error) {
    order := data.(*Order)
    // è°ƒç”¨æ”¯ä»˜æœåŠ¡
    return order, os.callPaymentService(ctx, "charge", order)
   },
   Compensate: func(ctx context.Context, data interface{}) error {
    order := data.(*Order)
    return os.callPaymentService(ctx, "refund", order)
   },
  }).
  AddStep(saga.Step{
   Name: "notify_user",
   Action: func(ctx context.Context, data interface{}) (interface{}, error) {
    order := data.(*Order)

    // åˆ›å»ºæœ€å¤§åŠªåŠ›é€šçŸ¥
    notif := &besteffort.Notification{
     URL:      "https://api.example.com/webhooks/order-created",
     Method:   "POST",
     Headers:  map[string]string{"Content-Type": "application/json"},
     Body:     mustMarshal(order),
     MaxRetry: 10,
    }

    return order, os.notificationSvc.CreateNotification(ctx, notif)
   },
   Compensate: nil,
  })
}

func main() {
 // åˆå§‹åŒ–æ•°æ®åº“
 db, err := sql.Open("mysql", "user:password@tcp(localhost:3306)/orders")
 if err != nil {
  log.Fatal(err)
 }
 defer db.Close()

 // åˆå§‹åŒ–Redis
 redisClient := redis.NewClient(&redis.Options{
  Addr: "localhost:6379",
 })

 // åˆ›å»ºæœåŠ¡
 lmt := localmsg.NewLocalMessageTable(db)
 broker := &KafkaBroker{} // å®ç°MessageBrokeræ¥å£
 producer := localmsg.NewMessageProducer(lmt, broker)
 notificationSvc := besteffort.NewNotificationService(db)
 idempotentSvc := NewIdempotentService(redisClient, time.Minute*10)

 orderService := &OrderService{
  db:              db,
  lmt:             lmt,
  producer:        producer,
  notificationSvc: notificationSvc,
  idempotentSvc:   idempotentSvc,
 }

 // å¯åŠ¨æ¶ˆæ¯å‘é€å®šæ—¶ä»»åŠ¡
 go producer.StartScheduler(context.Background())

 // å¯åŠ¨é€šçŸ¥å‘é€å®šæ—¶ä»»åŠ¡
 go func() {
  ticker := time.NewTicker(time.Second * 10)
  defer ticker.Stop()

  for range ticker.C {
   notificationSvc.ProcessPendingNotifications(context.Background())
  }
 }()

 // åˆ›å»ºè®¢å•ç¤ºä¾‹
 order := &Order{
  UserID:      1001,
  TotalAmount: 299.99,
  Items: []OrderItem{
   {ProductID: 2001, Quantity: 2, Price: 149.99},
  },
 }

 if err := orderService.CreateOrder(context.Background(), order); err != nil {
  log.Printf("Failed to create order: %v", err)
 } else {
  log.Printf("Order created successfully: %d", order.ID)
 }
}
```

---

## ğŸ“š åˆ†å¸ƒå¼äº‹åŠ¡æœ€ä½³å®è·µ

### æ¨¡å¼é€‰æ‹©

- âœ… **Saga**: é€‚åˆé•¿æµç¨‹ã€ä¸šåŠ¡è¡¥å¿æ˜ç¡®
- âœ… **TCC**: é€‚åˆçŸ­æµç¨‹ã€ä¸€è‡´æ€§è¦æ±‚é«˜
- âœ… **2PC**: é€‚åˆå¼ºä¸€è‡´æ€§åœºæ™¯ï¼ˆæ€§èƒ½è¾ƒä½ï¼‰
- âœ… **æœ¬åœ°æ¶ˆæ¯è¡¨**: é€‚åˆå¼‚æ­¥å¤„ç†ã€æœ€ç»ˆä¸€è‡´æ€§
- âœ… **äº‹åŠ¡æ¶ˆæ¯**: é€‚åˆæ¶ˆæ¯é˜Ÿåˆ—åœºæ™¯
- âœ… **æœ€å¤§åŠªåŠ›é€šçŸ¥**: é€‚åˆå¯¹æ–¹ç³»ç»Ÿå®¹å¿å»¶è¿Ÿ

### è®¾è®¡åŸåˆ™

- âœ… ä¼˜å…ˆè€ƒè™‘æœ€ç»ˆä¸€è‡´æ€§
- âœ… è®¾è®¡æ˜ç¡®çš„è¡¥å¿æœºåˆ¶
- âœ… ç¡®ä¿å¹‚ç­‰æ€§
- âœ… é¿å…é•¿äº‹åŠ¡
- âœ… çŠ¶æ€å¯è¿½è¸ª

### æ€§èƒ½ä¼˜åŒ–

- âœ… å¼‚æ­¥åŒ–å¤„ç†
- âœ… æ‰¹é‡æ“ä½œ
- âœ… ç¼“å­˜çŠ¶æ€
- âœ… å‡å°‘ç½‘ç»œè°ƒç”¨
- âœ… è¶…æ—¶æ§åˆ¶

### ç›‘æ§å‘Šè­¦

- âœ… äº‹åŠ¡æˆåŠŸç‡
- âœ… è¡¥å¿æ‰§è¡Œç‡
- âœ… æ¶ˆæ¯å‘é€å»¶è¿Ÿ
- âœ… é‡è¯•æ¬¡æ•°
- âœ… å¤±è´¥å‘Šè­¦

---

## ğŸ¯ æ€»ç»“

Go 1.25.3åˆ†å¸ƒå¼äº‹åŠ¡å…³é”®ç‚¹ï¼š

1. **Sagaæ¨¡å¼**: ç¼–æ’å™¨ã€è¡¥å¿æœºåˆ¶ã€é•¿æµç¨‹
2. **TCCæ¨¡å¼**: Try-Confirm-Cancelã€ä¸‰é˜¶æ®µã€å¼ºä¸€è‡´
3. **2PC**: åè°ƒå™¨ã€å‡†å¤‡-æäº¤ã€é˜»å¡é—®é¢˜
4. **æœ¬åœ°æ¶ˆæ¯è¡¨**: äº‹åŠ¡æ€§å‘é€ã€å¼‚æ­¥å¤„ç†ã€æœ€ç»ˆä¸€è‡´
5. **äº‹åŠ¡æ¶ˆæ¯**: RocketMQ/Kafkaã€äº‹åŠ¡ä¿è¯ã€å›æŸ¥æœºåˆ¶
6. **æœ€å¤§åŠªåŠ›é€šçŸ¥**: é‡è¯•ç­–ç•¥ã€æŒ‡æ•°é€€é¿ã€é€šçŸ¥ç¡®è®¤
7. **æœ€ç»ˆä¸€è‡´æ€§**: çŠ¶æ€æœºã€å¹‚ç­‰æ€§ã€è¡¥å¿é‡è¯•

**åˆ†å¸ƒå¼äº‹åŠ¡æ˜¯å¾®æœåŠ¡æ•°æ®ä¸€è‡´æ€§çš„æ ¸å¿ƒä¿éšœï¼**

---

<div align="center">

**æ„å»ºå¯é çš„åˆ†å¸ƒå¼ç³»ç»Ÿ**:

[ğŸ“š è¿”å›ç›®å½•](../README.md) | [ğŸ“– ä¸‹ä¸€ç« ](27-é…ç½®ä¸­å¿ƒä¸æœåŠ¡æ²»ç†å®Œæ•´å®æˆ˜.md)

Made with â¤ï¸ for Go Developers

</div>

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2025-10-29
**Goç‰ˆæœ¬**: Go 1.25.3
**ç”Ÿäº§å°±ç»ª**: âœ…
