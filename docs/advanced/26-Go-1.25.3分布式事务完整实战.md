# Go 1.25.3 分布式事务完整实战

**版本**: v1.0
**更新日期**: 2025-10-29
**适用于**: Go 1.25.3

---
## 📋 目录

- [Go 1.25.3 分布式事务完整实战](#go-1253-分布式事务完整实战)
  - [📖 文档说明](#文档说明)
  - [1. Saga模式](#1-saga模式)
  - [2. TCC模式](#2-tcc模式)
  - [3. 两阶段提交](#3-两阶段提交)
  - [4. 本地消息表](#4-本地消息表)
  - [5. 事务消息](#5-事务消息)
  - [6. 最大努力通知](#6-最大努力通知)
  - [7. 最终一致性](#7-最终一致性)
  - [8. 完整案例](#8-完整案例)
  - [📚 分布式事务最佳实践](#分布式事务最佳实践)
  - [🎯 总结](#总结)

---

## 📖 文档说明

本文档展示Go 1.25.3的**分布式事务完整方案**，确保数据一致性：

- ✅ Saga模式
- ✅ TCC模式
- ✅ 两阶段提交(2PC)
- ✅ 本地消息表
- ✅ 事务消息
- ✅ 最大努力通知
- ✅ 最终一致性
- ✅ 补偿机制

---

## 1. Saga模式

### 1.1 Saga编排器

```go
package saga

import (
 "Context"
 "errors"
 "fmt"
 "sync"
)

// Step Saga步骤
type Step struct {
 Name        string
 Action      func(ctx Context.Context, data interface{}) (interface{}, error)
 Compensate  func(ctx Context.Context, data interface{}) error
}

// Saga Saga编排器
type Saga struct {
 steps       []Step
 executedSteps []int
 mu          sync.Mutex
}

// NewSaga 创建Saga
func NewSaga() *Saga {
 return &Saga{
  steps:         make([]Step, 0),
  executedSteps: make([]int, 0),
 }
}

// AddStep 添加步骤
func (s *Saga) AddStep(step Step) *Saga {
 s.steps = append(s.steps, step)
 return s
}

// Execute 执行Saga
func (s *Saga) Execute(ctx Context.Context, initialData interface{}) error {
 s.mu.Lock()
 defer s.mu.Unlock()

 data := initialData

 // 执行所有步骤
 for i, step := range s.steps {
  result, err := step.Action(ctx, data)
  if err != nil {
   // 发生错误，执行补偿
   s.compensate(ctx, initialData)
   return fmt.Errorf("step %s failed: %w", step.Name, err)
  }

  // 记录已执行的步骤
  s.executedSteps = append(s.executedSteps, i)
  data = result
 }

 return nil
}

// compensate 执行补偿
func (s *Saga) compensate(ctx Context.Context, data interface{}) {
 // 逆序执行补偿
 for i := len(s.executedSteps) - 1; i >= 0; i-- {
  stepIndex := s.executedSteps[i]
  step := s.steps[stepIndex]

  if step.Compensate != nil {
   if err := step.Compensate(ctx, data); err != nil {
    // 记录补偿失败（需要人工介入）
    fmt.Printf("Compensation failed for step %s: %v\n", step.Name, err)
   }
  }
 }

 // 清空已执行步骤
 s.executedSteps = s.executedSteps[:0]
}
```

---

### 1.2 订单Saga示例

```go
// OrderSaga 订单Saga
type OrderSaga struct {
 orderService    *OrderService
 inventoryService *InventoryService
 paymentService  *PaymentService
 deliveryService *DeliveryService
}

// CreateOrderSaga 创建订单Saga
func (os *OrderSaga) CreateOrderSaga(order *Order) *saga.Saga {
 return saga.NewSaga().
  AddStep(saga.Step{
   Name: "create_order",
   Action: func(ctx Context.Context, data interface{}) (interface{}, error) {
    order := data.(*Order)
    return os.orderService.CreateOrder(ctx, order)
   },
   Compensate: func(ctx Context.Context, data interface{}) error {
    order := data.(*Order)
    return os.orderService.CancelOrder(ctx, order.ID)
   },
  }).
  AddStep(saga.Step{
   Name: "reserve_inventory",
   Action: func(ctx Context.Context, data interface{}) (interface{}, error) {
    order := data.(*Order)
    return order, os.inventoryService.ReserveItems(ctx, order.Items)
   },
   Compensate: func(ctx Context.Context, data interface{}) error {
    order := data.(*Order)
    return os.inventoryService.ReleaseItems(ctx, order.Items)
   },
  }).
  AddStep(saga.Step{
   Name: "process_payment",
   Action: func(ctx Context.Context, data interface{}) (interface{}, error) {
    order := data.(*Order)
    paymentID, err := os.paymentService.ProcessPayment(ctx, order.Payment)
    if err != nil {
     return nil, err
    }
    order.PaymentID = paymentID
    return order, nil
   },
   Compensate: func(ctx Context.Context, data interface{}) error {
    order := data.(*Order)
    return os.paymentService.RefundPayment(ctx, order.PaymentID)
   },
  }).
  AddStep(saga.Step{
   Name: "create_delivery",
   Action: func(ctx Context.Context, data interface{}) (interface{}, error) {
    order := data.(*Order)
    deliveryID, err := os.deliveryService.CreateDelivery(ctx, order)
    if err != nil {
     return nil, err
    }
    order.DeliveryID = deliveryID
    return order, nil
   },
   Compensate: func(ctx Context.Context, data interface{}) error {
    order := data.(*Order)
    return os.deliveryService.CancelDelivery(ctx, order.DeliveryID)
   },
  })
}

// ExecuteOrderCreation 执行订单创建
func (os *OrderSaga) ExecuteOrderCreation(ctx Context.Context, order *Order) error {
 saga := os.CreateOrderSaga(order)
 return saga.Execute(ctx, order)
}
```

---

## 2. TCC模式

### 2.1 TCC协调器

```go
package tcc

import (
 "Context"
 "errors"
 "fmt"
 "sync"
 "time"
)

// Participant TCC参与者接口
type Participant interface {
 Try(ctx Context.Context, data interface{}) error
 Confirm(ctx Context.Context, data interface{}) error
 Cancel(ctx Context.Context, data interface{}) error
}

// Transaction TCC事务
type Transaction struct {
 ID           string
 Status       TransactionStatus
 Participants []Participant
 Data         interface{}
 CreatedAt    time.Time
 UpdatedAt    time.Time
}

// TransactionStatus 事务状态
type TransactionStatus int

const (
 StatusTrying TransactionStatus = iota
 StatusConfirmed
 StatusCancelled
 StatusFailed
)

// Coordinator TCC协调器
type Coordinator struct {
 transactions map[string]*Transaction
 mu           sync.RWMutex
}

// NewCoordinator 创建TCC协调器
func NewCoordinator() *Coordinator {
 return &Coordinator{
  transactions: make(map[string]*Transaction),
 }
}

// Begin 开始事务
func (c *Coordinator) Begin(ctx Context.Context, id string, participants []Participant, data interface{}) (*Transaction, error) {
 c.mu.Lock()
 defer c.mu.Unlock()

 tx := &Transaction{
  ID:           id,
  Status:       StatusTrying,
  Participants: participants,
  Data:         data,
  CreatedAt:    time.Now(),
  UpdatedAt:    time.Now(),
 }

 c.transactions[id] = tx

 // Try阶段
 for _, p := range participants {
  if err := p.Try(ctx, data); err != nil {
   // Try失败，执行Cancel
   c.cancel(ctx, tx)
   return nil, fmt.Errorf("try phase failed: %w", err)
  }
 }

 return tx, nil
}

// Commit 提交事务
func (c *Coordinator) Commit(ctx Context.Context, txID string) error {
 c.mu.Lock()
 defer c.mu.Unlock()

 tx, ok := c.transactions[txID]
 if !ok {
  return errors.New("transaction not found")
 }

 if tx.Status != StatusTrying {
  return errors.New("transaction not in trying status")
 }

 // Confirm阶段
 for _, p := range tx.Participants {
  if err := p.Confirm(ctx, tx.Data); err != nil {
   tx.Status = StatusFailed
   tx.UpdatedAt = time.Now()
   return fmt.Errorf("confirm phase failed: %w", err)
  }
 }

 tx.Status = StatusConfirmed
 tx.UpdatedAt = time.Now()

 return nil
}

// Rollback 回滚事务
func (c *Coordinator) Rollback(ctx Context.Context, txID string) error {
 c.mu.Lock()
 defer c.mu.Unlock()

 tx, ok := c.transactions[txID]
 if !ok {
  return errors.New("transaction not found")
 }

 return c.cancel(ctx, tx)
}

// cancel 取消事务
func (c *Coordinator) cancel(ctx Context.Context, tx *Transaction) error {
 // Cancel阶段
 for _, p := range tx.Participants {
  if err := p.Cancel(ctx, tx.Data); err != nil {
   // 记录Cancel失败（需要补偿）
   fmt.Printf("Cancel failed for transaction %s: %v\n", tx.ID, err)
  }
 }

 tx.Status = StatusCancelled
 tx.UpdatedAt = time.Now()

 return nil
}
```

---

### 2.2 TCC实现示例

```go
// AccountParticipant 账户TCC参与者
type AccountParticipant struct {
 db *sql.DB
}

// Try 尝试阶段：冻结资金
func (ap *AccountParticipant) Try(ctx Context.Context, data interface{}) error {
 transfer := data.(*Transfer)

 tx, err := ap.db.BeginTx(ctx, nil)
 if err != nil {
  return err
 }
 defer tx.Rollback()

 // 检查余额
 var balance float64
 err = tx.QueryRowContext(ctx,
  "SELECT balance FROM accounts WHERE id = ? FOR UPDATE",
  transfer.FromAccount).Scan(&balance)
 if err != nil {
  return err
 }

 if balance < transfer.Amount {
  return errors.New("insufficient balance")
 }

 // 冻结金额
 _, err = tx.ExecContext(ctx,
  "UPDATE accounts SET frozen = frozen + ? WHERE id = ?",
  transfer.Amount, transfer.FromAccount)
 if err != nil {
  return err
 }

 // 记录冻结
 _, err = tx.ExecContext(ctx,
  "INSERT INTO frozen_records (tx_id, account_id, amount, created_at) VALUES (?, ?, ?, ?)",
  transfer.TxID, transfer.FromAccount, transfer.Amount, time.Now())
 if err != nil {
  return err
 }

 return tx.Commit()
}

// Confirm 确认阶段：扣除余额，解冻
func (ap *AccountParticipant) Confirm(ctx Context.Context, data interface{}) error {
 transfer := data.(*Transfer)

 tx, err := ap.db.BeginTx(ctx, nil)
 if err != nil {
  return err
 }
 defer tx.Rollback()

 // 扣除余额
 _, err = tx.ExecContext(ctx,
  "UPDATE accounts SET balance = balance - ?, frozen = frozen - ? WHERE id = ?",
  transfer.Amount, transfer.Amount, transfer.FromAccount)
 if err != nil {
  return err
 }

 // 增加目标账户余额
 _, err = tx.ExecContext(ctx,
  "UPDATE accounts SET balance = balance + ? WHERE id = ?",
  transfer.Amount, transfer.ToAccount)
 if err != nil {
  return err
 }

 // 删除冻结记录
 _, err = tx.ExecContext(ctx,
  "DELETE FROM frozen_records WHERE tx_id = ?",
  transfer.TxID)
 if err != nil {
  return err
 }

 return tx.Commit()
}

// Cancel 取消阶段：解冻资金
func (ap *AccountParticipant) Cancel(ctx Context.Context, data interface{}) error {
 transfer := data.(*Transfer)

 tx, err := ap.db.BeginTx(ctx, nil)
 if err != nil {
  return err
 }
 defer tx.Rollback()

 // 解冻金额
 _, err = tx.ExecContext(ctx,
  "UPDATE accounts SET frozen = frozen - ? WHERE id = ?",
  transfer.Amount, transfer.FromAccount)
 if err != nil {
  return err
 }

 // 删除冻结记录
 _, err = tx.ExecContext(ctx,
  "DELETE FROM frozen_records WHERE tx_id = ?",
  transfer.TxID)
 if err != nil {
  return err
 }

 return tx.Commit()
}
```

---

## 3. 两阶段提交

### 3.1 2PC协调器

```go
package twopc

import (
 "Context"
 "errors"
 "fmt"
 "sync"
 "time"
)

// Participant 2PC参与者接口
type Participant interface {
 Prepare(ctx Context.Context, txID string) (bool, error)
 Commit(ctx Context.Context, txID string) error
 Abort(ctx Context.Context, txID string) error
}

// Coordinator 2PC协调器
type Coordinator struct {
 participants []Participant
 mu           sync.Mutex
}

// NewCoordinator 创建2PC协调器
func NewCoordinator(participants []Participant) *Coordinator {
 return &Coordinator{
  participants: participants,
 }
}

// Execute 执行两阶段提交
func (c *Coordinator) Execute(ctx Context.Context, txID string) error {
 c.mu.Lock()
 defer c.mu.Unlock()

 // 第一阶段：Prepare
 prepareResults := make([]bool, len(c.participants))
 prepareErrors := make([]error, len(c.participants))

 var wg sync.WaitGroup
 for i, p := range c.participants {
  wg.Add(1)
  go func(index int, participant Participant) {
   defer wg.Done()

   prepared, err := participant.Prepare(ctx, txID)
   prepareResults[index] = prepared
   prepareErrors[index] = err
  }(i, p)
 }

 wg.Wait()

 // 检查Prepare结果
 allPrepared := true
 for i, err := range prepareErrors {
  if err != nil || !prepareResults[i] {
   allPrepared = false
   break
  }
 }

 // 第二阶段：Commit或Abort
 if allPrepared {
  // 所有参与者都准备好，执行Commit
  return c.commitAll(ctx, txID)
 } else {
  // 有参与者未准备好，执行Abort
  return c.abortAll(ctx, txID)
 }
}

// commitAll 提交所有参与者
func (c *Coordinator) commitAll(ctx Context.Context, txID string) error {
 var wg sync.WaitGroup
 errors := make([]error, len(c.participants))

 for i, p := range c.participants {
  wg.Add(1)
  go func(index int, participant Participant) {
   defer wg.Done()
   errors[index] = participant.Commit(ctx, txID)
  }(i, p)
 }

 wg.Wait()

 // 检查提交结果
 for _, err := range errors {
  if err != nil {
   return fmt.Errorf("commit failed: %w", err)
  }
 }

 return nil
}

// abortAll 中止所有参与者
func (c *Coordinator) abortAll(ctx Context.Context, txID string) error {
 var wg sync.WaitGroup

 for _, p := range c.participants {
  wg.Add(1)
  go func(participant Participant) {
   defer wg.Done()
   participant.Abort(ctx, txID)
  }(p)
 }

 wg.Wait()

 return errors.New("transaction aborted")
}
```

---

### 3.2 参与者实现

```go
// DatabaseParticipant 数据库2PC参与者
type DatabaseParticipant struct {
 db         *sql.DB
 preparedTx map[string]*sql.Tx
 mu         sync.RWMutex
}

// NewDatabaseParticipant 创建数据库参与者
func NewDatabaseParticipant(db *sql.DB) *DatabaseParticipant {
 return &DatabaseParticipant{
  db:         db,
  preparedTx: make(map[string]*sql.Tx),
 }
}

// Prepare 准备阶段
func (dp *DatabaseParticipant) Prepare(ctx Context.Context, txID string) (bool, error) {
 dp.mu.Lock()
 defer dp.mu.Unlock()

 // 开始事务
 tx, err := dp.db.BeginTx(ctx, nil)
 if err != nil {
  return false, err
 }

 // 执行业务逻辑（这里简化处理）
 // ...

 // 保存准备好的事务
 dp.preparedTx[txID] = tx

 return true, nil
}

// Commit 提交阶段
func (dp *DatabaseParticipant) Commit(ctx Context.Context, txID string) error {
 dp.mu.Lock()
 defer dp.mu.Unlock()

 tx, ok := dp.preparedTx[txID]
 if !ok {
  return errors.New("transaction not prepared")
 }

 err := tx.Commit()
 if err != nil {
  return err
 }

 delete(dp.preparedTx, txID)
 return nil
}

// Abort 中止阶段
func (dp *DatabaseParticipant) Abort(ctx Context.Context, txID string) error {
 dp.mu.Lock()
 defer dp.mu.Unlock()

 tx, ok := dp.preparedTx[txID]
 if !ok {
  return nil // 已经中止或未准备
 }

 err := tx.Rollback()
 delete(dp.preparedTx, txID)

 return err
}
```

---

## 4. 本地消息表

### 4.1 消息表设计

```go
package localmsg

import (
 "Context"
 "database/sql"
 "encoding/json"
 "time"
)

// Message 本地消息
type Message struct {
 ID         int64
 Topic      string
 Key        string
 Payload    json.RawMessage
 Status     MessageStatus
 RetryCount int
 MaxRetry   int
 NextRetry  time.Time
 CreatedAt  time.Time
 UpdatedAt  time.Time
}

// MessageStatus 消息状态
type MessageStatus string

const (
 StatusPending   MessageStatus = "pending"
 StatusSent      MessageStatus = "sent"
 StatusFailed    MessageStatus = "failed"
)

// LocalMessageTable 本地消息表
type LocalMessageTable struct {
 db *sql.DB
}

// NewLocalMessageTable 创建本地消息表
func NewLocalMessageTable(db *sql.DB) *LocalMessageTable {
 return &LocalMessageTable{db: db}
}

// SaveWithTransaction 在事务中保存消息
func (lmt *LocalMessageTable) SaveWithTransaction(ctx Context.Context, tx *sql.Tx, msg *Message) error {
 payload, err := json.Marshal(msg.Payload)
 if err != nil {
  return err
 }

 result, err := tx.ExecContext(ctx, `
  INSERT INTO local_messages
  (topic, message_key, payload, status, retry_count, max_retry, next_retry, created_at, updated_at)
  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
 `, msg.Topic, msg.Key, payload, StatusPending, 0, msg.MaxRetry, time.Now(), time.Now(), time.Now())

 if err != nil {
  return err
 }

 id, err := result.LastInsertId()
 if err != nil {
  return err
 }

 msg.ID = id
 return nil
}

// GetPendingMessages 获取待发送消息
func (lmt *LocalMessageTable) GetPendingMessages(ctx Context.Context, limit int) ([]*Message, error) {
 rows, err := lmt.db.QueryContext(ctx, `
  SELECT id, topic, message_key, payload, status, retry_count, max_retry, next_retry, created_at, updated_at
  FROM local_messages
  WHERE status = ? AND next_retry <= ?
  ORDER BY created_at
  LIMIT ?
 `, StatusPending, time.Now(), limit)

 if err != nil {
  return nil, err
 }
 defer rows.Close()

 messages := make([]*Message, 0)
 for rows.Next() {
  msg := &Message{}
  err := rows.Scan(
   &msg.ID, &msg.Topic, &msg.Key, &msg.Payload, &msg.Status,
   &msg.RetryCount, &msg.MaxRetry, &msg.NextRetry, &msg.CreatedAt, &msg.UpdatedAt,
  )
  if err != nil {
   return nil, err
  }
  messages = append(messages, msg)
 }

 return messages, rows.Err()
}

// MarkAsSent 标记为已发送
func (lmt *LocalMessageTable) MarkAsSent(ctx Context.Context, id int64) error {
 _, err := lmt.db.ExecContext(ctx, `
  UPDATE local_messages
  SET status = ?, updated_at = ?
  WHERE id = ?
 `, StatusSent, time.Now(), id)

 return err
}

// MarkAsFailed 标记为失败并更新重试信息
func (lmt *LocalMessageTable) MarkAsFailed(ctx Context.Context, id int64) error {
 _, err := lmt.db.ExecContext(ctx, `
  UPDATE local_messages
  SET retry_count = retry_count + 1,
      next_retry = ?,
      status = CASE
          WHEN retry_count + 1 >= max_retry THEN ?
          ELSE status
      END,
      updated_at = ?
  WHERE id = ?
 `, time.Now().Add(time.Minute*5), StatusFailed, time.Now(), id)

 return err
}
```

---

### 4.2 消息发送与确认

```go
// MessageProducer 消息生产者
type MessageProducer struct {
 lmt    *LocalMessageTable
 broker MessageBroker
}

// MessageBroker 消息代理接口
type MessageBroker interface {
 Send(ctx Context.Context, topic, key string, payload []byte) error
}

// NewMessageProducer 创建消息生产者
func NewMessageProducer(lmt *LocalMessageTable, broker MessageBroker) *MessageProducer {
 return &MessageProducer{
  lmt:    lmt,
  broker: broker,
 }
}

// PublishWithTransaction 在事务中发布消息
func (mp *MessageProducer) PublishWithTransaction(ctx Context.Context, tx *sql.Tx, topic, key string, payload interface{}) error {
 payloadBytes, err := json.Marshal(payload)
 if err != nil {
  return err
 }

 msg := &Message{
  Topic:    topic,
  Key:      key,
  Payload:  payloadBytes,
  MaxRetry: 5,
 }

 return mp.lmt.SaveWithTransaction(ctx, tx, msg)
}

// SendPendingMessages 发送待发送消息
func (mp *MessageProducer) SendPendingMessages(ctx Context.Context) error {
 messages, err := mp.lmt.GetPendingMessages(ctx, 100)
 if err != nil {
  return err
 }

 for _, msg := range messages {
  err := mp.broker.Send(ctx, msg.Topic, msg.Key, msg.Payload)
  if err != nil {
   mp.lmt.MarkAsFailed(ctx, msg.ID)
   continue
  }

  mp.lmt.MarkAsSent(ctx, msg.ID)
 }

 return nil
}

// StartScheduler 启动定时发送
func (mp *MessageProducer) StartScheduler(ctx Context.Context) {
 ticker := time.NewTicker(time.Second * 5)
 defer ticker.Stop()

 for {
  select {
  case <-ctx.Done():
   return
  case <-ticker.C:
   mp.SendPendingMessages(ctx)
  }
 }
}
```

---

## 5. 事务消息

### 5.1 RocketMQ事务消息

```go
package transactionmsg

import (
 "Context"
 "fmt"

 "github.com/apache/rocketmq-client-go/v2"
 "github.com/apache/rocketmq-client-go/v2/primitive"
 "github.com/apache/rocketmq-client-go/v2/producer"
)

// TransactionalProducer 事务消息生产者
type TransactionalProducer struct {
 producer rocketmq.TransactionProducer
}

// NewTransactionalProducer 创建事务消息生产者
func NewTransactionalProducer(nameservers []string, listener primitive.TransactionListener) (*TransactionalProducer, error) {
 p, err := rocketmq.NewTransactionProducer(
  listener,
  producer.WithNsResolver(primitive.NewPassthroughResolver(nameservers)),
  producer.WithRetry(2),
 )

 if err != nil {
  return nil, err
 }

 err = p.Start()
 if err != nil {
  return nil, err
 }

 return &TransactionalProducer{producer: p}, nil
}

// SendMessageInTransaction 发送事务消息
func (tp *TransactionalProducer) SendMessageInTransaction(ctx Context.Context, msg *primitive.Message) (*primitive.TransactionSendResult, error) {
 return tp.producer.SendMessageInTransaction(ctx, msg)
}

// OrderTransactionListener 订单事务监听器
type OrderTransactionListener struct {
 orderService *OrderService
}

// ExecuteLocalTransaction 执行本地事务
func (otl *OrderTransactionListener) ExecuteLocalTransaction(msg *primitive.Message) primitive.LocalTransactionState {
 // 解析消息
 order := &Order{}
 if err := json.Unmarshal(msg.Body, order); err != nil {
  return primitive.RollbackMessageState
 }

 // 执行本地事务
 if err := otl.orderService.CreateOrder(Context.Background(), order); err != nil {
  return primitive.RollbackMessageState
 }

 return primitive.CommitMessageState
}

// CheckLocalTransaction 检查本地事务状态
func (otl *OrderTransactionListener) CheckLocalTransaction(msg *primitive.MessageExt) primitive.LocalTransactionState {
 // 解析消息ID
 orderID := string(msg.Body)

 // 查询订单状态
 order, err := otl.orderService.GetOrder(Context.Background(), orderID)
 if err != nil {
  return primitive.UnknowState
 }

 if order.Status == OrderStatusCreated {
  return primitive.CommitMessageState
 }

 return primitive.RollbackMessageState
}
```

---

### 5.2 Kafka事务消息

```go
// KafkaTransactionalProducer Kafka事务生产者
type KafkaTransactionalProducer struct {
 producer *kafka.Producer
}

// NewKafkaTransactionalProducer 创建Kafka事务生产者
func NewKafkaTransactionalProducer(brokers []string, transactionalID string) (*KafkaTransactionalProducer, error) {
 config := &kafka.ConfigMap{
  "bootstrap.servers":       strings.Join(brokers, ","),
  "transactional.id":        transactionalID,
  "enable.idempotence":      true,
  "max.in.flight.requests.per.connection": 5,
 }

 producer, err := kafka.NewProducer(config)
 if err != nil {
  return nil, err
 }

 // 初始化事务
 if err := producer.InitTransactions(nil); err != nil {
  return nil, err
 }

 return &KafkaTransactionalProducer{producer: producer}, nil
}

// SendMessageInTransaction 在事务中发送消息
func (ktp *KafkaTransactionalProducer) SendMessageInTransaction(
 ctx Context.Context,
 topic string,
 key, value []byte,
 localTxFunc func() error,
) error {
 // 开始事务
 if err := ktp.producer.BeginTransaction(); err != nil {
  return err
 }

 // 执行本地事务
 if err := localTxFunc(); err != nil {
  ktp.producer.AbortTransaction(nil)
  return err
 }

 // 发送消息
 msg := &kafka.Message{
  TopicPartition: kafka.TopicPartition{
   Topic:     &topic,
   Partition: kafka.PartitionAny,
  },
  Key:   key,
  Value: value,
 }

 deliveryChan := make(Channel kafka.Event)
 if err := ktp.producer.Produce(msg, deliveryChan); err != nil {
  ktp.producer.AbortTransaction(nil)
  return err
 }

 // 等待发送结果
 e := <-deliveryChan
 m := e.(*kafka.Message)

 if m.TopicPartition.Error != nil {
  ktp.producer.AbortTransaction(nil)
  return m.TopicPartition.Error
 }

 // 提交事务
 if err := ktp.producer.CommitTransaction(nil); err != nil {
  return err
 }

 return nil
}
```

---

## 6. 最大努力通知

### 6.1 通知服务

```go
package besteffort

import (
 "Context"
 "database/sql"
 "encoding/json"
 "net/http"
 "time"
)

// Notification 通知
type Notification struct {
 ID          int64
 URL         string
 Method      string
 Headers     map[string]string
 Body        json.RawMessage
 Status      NotificationStatus
 RetryCount  int
 MaxRetry    int
 NextRetry   time.Time
 LastError   string
 CreatedAt   time.Time
 UpdatedAt   time.Time
}

// NotificationStatus 通知状态
type NotificationStatus string

const (
 NotifStatusPending   NotificationStatus = "pending"
 NotifStatusSucceeded NotificationStatus = "succeeded"
 NotifStatusFailed    NotificationStatus = "failed"
)

// NotificationService 通知服务
type NotificationService struct {
 db     *sql.DB
 client *http.Client
}

// NewNotificationService 创建通知服务
func NewNotificationService(db *sql.DB) *NotificationService {
 return &NotificationService{
  db: db,
  client: &http.Client{
   Timeout: time.Second * 30,
  },
 }
}

// CreateNotification 创建通知
func (ns *NotificationService) CreateNotification(ctx Context.Context, notif *Notification) error {
 headers, _ := json.Marshal(notif.Headers)

 result, err := ns.db.ExecContext(ctx, `
  INSERT INTO notifications
  (url, method, headers, body, status, retry_count, max_retry, next_retry, created_at, updated_at)
  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
 `, notif.URL, notif.Method, headers, notif.Body, NotifStatusPending, 0, notif.MaxRetry, time.Now(), time.Now(), time.Now())

 if err != nil {
  return err
 }

 id, _ := result.LastInsertId()
 notif.ID = id

 return nil
}

// SendNotification 发送通知
func (ns *NotificationService) SendNotification(ctx Context.Context, notif *Notification) error {
 // 创建HTTP请求
 req, err := http.NewRequestWithContext(ctx, notif.Method, notif.URL, bytes.NewReader(notif.Body))
 if err != nil {
  return err
 }

 // 设置请求头
 for key, value := range notif.Headers {
  req.Header.Set(key, value)
 }

 // 发送请求
 resp, err := ns.client.Do(req)
 if err != nil {
  return err
 }
 defer resp.Body.Close()

 if resp.StatusCode < 200 || resp.StatusCode >= 300 {
  return fmt.Errorf("notification failed with status: %d", resp.StatusCode)
 }

 return nil
}

// ProcessPendingNotifications 处理待发送通知
func (ns *NotificationService) ProcessPendingNotifications(ctx Context.Context) error {
 // 获取待发送通知
 rows, err := ns.db.QueryContext(ctx, `
  SELECT id, url, method, headers, body, status, retry_count, max_retry
  FROM notifications
  WHERE status = ? AND next_retry <= ?
  LIMIT 100
 `, NotifStatusPending, time.Now())

 if err != nil {
  return err
 }
 defer rows.Close()

 for rows.Next() {
  notif := &Notification{}
  var headers string

  err := rows.Scan(
   &notif.ID, &notif.URL, &notif.Method, &headers, &notif.Body,
   &notif.Status, &notif.RetryCount, &notif.MaxRetry,
  )
  if err != nil {
   continue
  }

  json.Unmarshal([]byte(headers), &notif.Headers)

  // 发送通知
  err = ns.SendNotification(ctx, notif)
  if err != nil {
   ns.updateNotificationFailed(ctx, notif.ID, err.Error())
  } else {
   ns.updateNotificationSucceeded(ctx, notif.ID)
  }
 }

 return rows.Err()
}

// updateNotificationSucceeded 更新通知为成功
func (ns *NotificationService) updateNotificationSucceeded(ctx Context.Context, id int64) error {
 _, err := ns.db.ExecContext(ctx, `
  UPDATE notifications
  SET status = ?, updated_at = ?
  WHERE id = ?
 `, NotifStatusSucceeded, time.Now(), id)

 return err
}

// updateNotificationFailed 更新通知为失败
func (ns *NotificationService) updateNotificationFailed(ctx Context.Context, id int64, errMsg string) error {
 _, err := ns.db.ExecContext(ctx, `
  UPDATE notifications
  SET retry_count = retry_count + 1,
      last_error = ?,
      next_retry = ?,
      status = CASE
          WHEN retry_count + 1 >= max_retry THEN ?
          ELSE status
      END,
      updated_at = ?
  WHERE id = ?
 `, errMsg, time.Now().Add(time.Minute*5), NotifStatusFailed, time.Now(), id)

 return err
}
```

---

### 6.2 重试策略

```go
// RetryStrategy 重试策略
type RetryStrategy interface {
 NextRetryTime(retryCount int) time.Time
}

// ExponentialBackoff 指数退避
type ExponentialBackoff struct {
 InitialInterval time.Duration
 MaxInterval     time.Duration
 Multiplier      float64
}

// NextRetryTime 计算下次重试时间
func (eb *ExponentialBackoff) NextRetryTime(retryCount int) time.Time {
 interval := float64(eb.InitialInterval)

 for i := 0; i < retryCount; i++ {
  interval *= eb.Multiplier
  if time.Duration(interval) > eb.MaxInterval {
   interval = float64(eb.MaxInterval)
   break
  }
 }

 return time.Now().Add(time.Duration(interval))
}

// FixedInterval 固定间隔
type FixedInterval struct {
 Interval time.Duration
}

// NextRetryTime 计算下次重试时间
func (fi *FixedInterval) NextRetryTime(retryCount int) time.Time {
 return time.Now().Add(fi.Interval)
}
```

---

## 7. 最终一致性

### 7.1 状态机

```go
package consistency

import (
 "errors"
 "sync"
)

// State 状态
type State string

// Event 事件
type Event string

// StateMachine 状态机
type StateMachine struct {
 currentState  State
 transitions   map[State]map[Event]State
 handlers      map[State]map[Event]func() error
 mu            sync.RWMutex
}

// NewStateMachine 创建状态机
func NewStateMachine(initialState State) *StateMachine {
 return &StateMachine{
  currentState: initialState,
  transitions:  make(map[State]map[Event]State),
  handlers:     make(map[State]map[Event]func() error),
 }
}

// AddTransition 添加状态转换
func (sm *StateMachine) AddTransition(from State, event Event, to State, handler func() error) {
 sm.mu.Lock()
 defer sm.mu.Unlock()

 if sm.transitions[from] == nil {
  sm.transitions[from] = make(map[Event]State)
 }
 sm.transitions[from][event] = to

 if sm.handlers[from] == nil {
  sm.handlers[from] = make(map[Event]func() error)
 }
 sm.handlers[from][event] = handler
}

// Trigger 触发事件
func (sm *StateMachine) Trigger(event Event) error {
 sm.mu.Lock()
 defer sm.mu.Unlock()

 // 检查转换是否存在
 transitions, ok := sm.transitions[sm.currentState]
 if !ok {
  return errors.New("no transitions from current state")
 }

 nextState, ok := transitions[event]
 if !ok {
  return errors.New("invalid event for current state")
 }

 // 执行处理器
 if handler := sm.handlers[sm.currentState][event]; handler != nil {
  if err := handler(); err != nil {
   return err
  }
 }

 // 更新状态
 sm.currentState = nextState

 return nil
}

// CurrentState 获取当前状态
func (sm *StateMachine) CurrentState() State {
 sm.mu.RLock()
 defer sm.mu.RUnlock()

 return sm.currentState
}

// OrderStateMachine 订单状态机示例
func NewOrderStateMachine(order *Order) *StateMachine {
 sm := NewStateMachine(State("created"))

 // 定义状态转换
 sm.AddTransition(
  State("created"),
  Event("pay"),
  State("paid"),
  func() error {
   // 支付处理
   return nil
  },
 )

 sm.AddTransition(
  State("paid"),
  Event("ship"),
  State("shipped"),
  func() error {
   // 发货处理
   return nil
  },
 )

 sm.AddTransition(
  State("shipped"),
  Event("deliver"),
  State("delivered"),
  func() error {
   // 配送完成处理
   return nil
  },
 )

 sm.AddTransition(
  State("created"),
  Event("cancel"),
  State("cancelled"),
  func() error {
   // 取消处理
   return nil
  },
 )

 return sm
}
```

---

### 7.2 幂等性

```go
// IdempotentService 幂等服务
type IdempotentService struct {
 cache *redis.Client
 ttl   time.Duration
}

// NewIdempotentService 创建幂等服务
func NewIdempotentService(cache *redis.Client, ttl time.Duration) *IdempotentService {
 return &IdempotentService{
  cache: cache,
  ttl:   ttl,
 }
}

// CheckAndSet 检查并设置幂等键
func (is *IdempotentService) CheckAndSet(ctx Context.Context, key string) (bool, error) {
 // 使用SetNX确保原子性
 success, err := is.cache.SetNX(ctx, key, "1", is.ttl).Result()
 if err != nil {
  return false, err
 }

 return success, nil
}

// Remove 移除幂等键
func (is *IdempotentService) Remove(ctx Context.Context, key string) error {
 return is.cache.Del(ctx, key).Err()
}

// IdempotentMiddleware 幂等中间件
func IdempotentMiddleware(service *IdempotentService) func(http.Handler) http.Handler {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   // 从请求头获取幂等键
   idempotentKey := r.Header.Get("X-Idempotent-Key")
   if idempotentKey == "" {
    http.Error(w, "Missing idempotent key", http.StatusBadRequest)
    return
   }

   // 检查幂等性
   success, err := service.CheckAndSet(r.Context(), idempotentKey)
   if err != nil {
    http.Error(w, "Internal server error", http.StatusInternalServerError)
    return
   }

   if !success {
    http.Error(w, "Duplicate request", http.StatusConflict)
    return
   }

   next.ServeHTTP(w, r)
  })
 }
}
```

---

## 8. 完整案例

### 8.1 电商订单系统

```go
package main

import (
 "Context"
 "database/sql"
 "log"
)

// OrderService 订单服务
type OrderService struct {
 db              *sql.DB
 saga            *saga.Saga
 lmt             *localmsg.LocalMessageTable
 producer        *localmsg.MessageProducer
 notificationSvc *besteffort.NotificationService
 idempotentSvc   *IdempotentService
}

// CreateOrder 创建订单（使用Saga模式）
func (os *OrderService) CreateOrder(ctx Context.Context, order *Order) error {
 // 创建订单Saga
 orderSaga := os.createOrderSaga(order)

 // 执行Saga
 return orderSaga.Execute(ctx, order)
}

// createOrderSaga 创建订单Saga
func (os *OrderService) createOrderSaga(order *Order) *saga.Saga {
 return saga.NewSaga().
  AddStep(saga.Step{
   Name: "validate_order",
   Action: func(ctx Context.Context, data interface{}) (interface{}, error) {
    return data, os.validateOrder(ctx, data.(*Order))
   },
   Compensate: nil,
  }).
  AddStep(saga.Step{
   Name: "create_order_record",
   Action: func(ctx Context.Context, data interface{}) (interface{}, error) {
    order := data.(*Order)

    // 开始数据库事务
    tx, err := os.db.BeginTx(ctx, nil)
    if err != nil {
     return nil, err
    }
    defer tx.Rollback()

    // 插入订单
    result, err := tx.ExecContext(ctx, `
     INSERT INTO orders (user_id, total_amount, status, created_at)
     VALUES (?, ?, ?, ?)
    `, order.UserID, order.TotalAmount, "created", time.Now())

    if err != nil {
     return nil, err
    }

    orderID, _ := result.LastInsertId()
    order.ID = orderID

    // 保存本地消息（订单创建事件）
    msg := &localmsg.Message{
     Topic:    "order-events",
     Key:      fmt.Sprintf("%d", orderID),
     Payload:  mustMarshal(order),
     MaxRetry: 5,
    }

    if err := os.lmt.SaveWithTransaction(ctx, tx, msg); err != nil {
     return nil, err
    }

    // 提交事务
    if err := tx.Commit(); err != nil {
     return nil, err
    }

    return order, nil
   },
   Compensate: func(ctx Context.Context, data interface{}) error {
    order := data.(*Order)
    _, err := os.db.ExecContext(ctx, `
     UPDATE orders SET status = 'cancelled' WHERE id = ?
    `, order.ID)
    return err
   },
  }).
  AddStep(saga.Step{
   Name: "reserve_inventory",
   Action: func(ctx Context.Context, data interface{}) (interface{}, error) {
    order := data.(*Order)
    // 调用库存服务
    return order, os.callInventoryService(ctx, "reserve", order)
   },
   Compensate: func(ctx Context.Context, data interface{}) error {
    order := data.(*Order)
    return os.callInventoryService(ctx, "release", order)
   },
  }).
  AddStep(saga.Step{
   Name: "process_payment",
   Action: func(ctx Context.Context, data interface{}) (interface{}, error) {
    order := data.(*Order)
    // 调用支付服务
    return order, os.callPaymentService(ctx, "charge", order)
   },
   Compensate: func(ctx Context.Context, data interface{}) error {
    order := data.(*Order)
    return os.callPaymentService(ctx, "refund", order)
   },
  }).
  AddStep(saga.Step{
   Name: "notify_user",
   Action: func(ctx Context.Context, data interface{}) (interface{}, error) {
    order := data.(*Order)

    // 创建最大努力通知
    notif := &besteffort.Notification{
     URL:      "https://api.example.com/webhooks/order-created",
     Method:   "POST",
     Headers:  map[string]string{"Content-Type": "application/json"},
     Body:     mustMarshal(order),
     MaxRetry: 10,
    }

    return order, os.notificationSvc.CreateNotification(ctx, notif)
   },
   Compensate: nil,
  })
}

func main() {
 // 初始化数据库
 db, err := sql.Open("mysql", "user:password@tcp(localhost:3306)/orders")
 if err != nil {
  log.Fatal(err)
 }
 defer db.Close()

 // 初始化Redis
 redisClient := redis.NewClient(&redis.Options{
  Addr: "localhost:6379",
 })

 // 创建服务
 lmt := localmsg.NewLocalMessageTable(db)
 broker := &KafkaBroker{} // 实现MessageBroker接口
 producer := localmsg.NewMessageProducer(lmt, broker)
 notificationSvc := besteffort.NewNotificationService(db)
 idempotentSvc := NewIdempotentService(redisClient, time.Minute*10)

 orderService := &OrderService{
  db:              db,
  lmt:             lmt,
  producer:        producer,
  notificationSvc: notificationSvc,
  idempotentSvc:   idempotentSvc,
 }

 // 启动消息发送定时任务
 go producer.StartScheduler(Context.Background())

 // 启动通知发送定时任务
 go func() {
  ticker := time.NewTicker(time.Second * 10)
  defer ticker.Stop()

  for range ticker.C {
   notificationSvc.ProcessPendingNotifications(Context.Background())
  }
 }()

 // 创建订单示例
 order := &Order{
  UserID:      1001,
  TotalAmount: 299.99,
  Items: []OrderItem{
   {ProductID: 2001, Quantity: 2, Price: 149.99},
  },
 }

 if err := orderService.CreateOrder(Context.Background(), order); err != nil {
  log.Printf("Failed to create order: %v", err)
 } else {
  log.Printf("Order created successfully: %d", order.ID)
 }
}
```

---

## 📚 分布式事务最佳实践

### 模式选择

- ✅ **Saga**: 适合长流程、业务补偿明确
- ✅ **TCC**: 适合短流程、一致性要求高
- ✅ **2PC**: 适合强一致性场景（性能较低）
- ✅ **本地消息表**: 适合异步处理、最终一致性
- ✅ **事务消息**: 适合消息队列场景
- ✅ **最大努力通知**: 适合对方系统容忍延迟

### 设计原则

- ✅ 优先考虑最终一致性
- ✅ 设计明确的补偿机制
- ✅ 确保幂等性
- ✅ 避免长事务
- ✅ 状态可追踪

### 性能优化

- ✅ 异步化处理
- ✅ 批量操作
- ✅ 缓存状态
- ✅ 减少网络调用
- ✅ 超时控制

### 监控告警

- ✅ 事务成功率
- ✅ 补偿执行率
- ✅ 消息发送延迟
- ✅ 重试次数
- ✅ 失败告警

---

## 🎯 总结
