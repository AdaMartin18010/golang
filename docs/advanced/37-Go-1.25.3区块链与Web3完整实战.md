# Go 1.25.3区块链与Web3完整实战

**版本**: v1.0
**更新日期**: 2025-11-11
**适用于**: Go 1.25.3

---

## 📋 目录

- [Go 1.25.3区块链与Web3完整实战](#go-1253区块链与web3完整实战)
  - [📋 目录](#-目录)
  - [1. 区块链基础](#1-区块链基础)
    - [1.1 区块链核心概念](#11-区块链核心概念)
  - [2. 以太坊客户端](#2-以太坊客户端)
    - [2.1 连接以太坊节点](#21-连接以太坊节点)
    - [2.2 发送交易](#22-发送交易)
  - [3. 智能合约交互](#3-智能合约交互)
    - [3.1 ERC-20代币合约](#31-erc-20代币合约)
    - [3.2 Go调用ERC-20合约](#32-go调用erc-20合约)
  - [4. DeFi协议](#4-defi协议)
    - [4.1 自动做市商 (AMM)](#41-自动做市商-amm)
    - [4.2 Go实现DEX交互](#42-go实现dex交互)
  - [5. NFT铸造与交易](#5-nft铸造与交易)
    - [5.1 ERC-721 NFT合约](#51-erc-721-nft合约)
    - [5.2 Go实现NFT铸造](#52-go实现nft铸造)
  - [6. IPFS分布式存储](#6-ipfs分布式存储)
    - [6.1 IPFS存储NFT元数据](#61-ipfs存储nft元数据)
    - [6.2 完整NFT铸造流程](#62-完整nft铸造流程)
  - [7. The Graph数据索引](#7-the-graph数据索引)
    - [7.1 Graph查询](#71-graph查询)
    - [7.2 Go调用The Graph](#72-go调用the-graph)
  - [8. 完整DApp](#8-完整dapp)
    - [8.1 Web3 DApp架构](#81-web3-dapp架构)
  - [9. Gas优化](#9-gas优化)
    - [9.1 Gas优化技巧](#91-gas优化技巧)
  - [10. 生产部署](#10-生产部署)
    - [10.1 Docker部署](#101-docker部署)
  - [总结](#总结)
    - [✅ 核心成果](#-核心成果)
    - [🌟 Go 1.25.3应用](#-go-1253应用)
    - [📊 架构亮点](#-架构亮点)
    - [🎯 适用场景](#-适用场景)
  - [下一步学习](#下一步学习)

---

## 1. 区块链基础

### 1.1 区块链核心概念

```go
package blockchain

import (
 "crypto/sha256"
 "encoding/hex"
 "fmt"
 "time"
)

// 区块链核心概念
/*
区块链 (Blockchain):
  • 分布式账本 (Distributed Ledger)
  • 不可篡改 (Immutable)
  • 去中心化 (Decentralized)
  • 共识机制 (Consensus)

核心特性:
  ✅ 数据不可篡改
  ✅ 分布式存储
  ✅ 智能合约 (Smart Contract)
  ✅ 无需信任 (Trustless)
  ✅ 透明可追溯

区块链类型:
  1. 公有链 (Public): Bitcoin, Ethereum
  2. 联盟链 (Consortium): Hyperledger Fabric
  3. 私有链 (Private): Enterprise Blockchain

共识算法:
  • PoW (Proof of Work) - Bitcoin
  • PoS (Proof of Stake) - Ethereum 2.0 ✅
  • DPoS (Delegated PoS)
  • PBFT (Practical Byzantine Fault Tolerance)
*/

// Block 区块结构
type Block struct {
 Index        int64       `json:"index"`
 Timestamp    int64       `json:"timestamp"`
 PreviousHash string      `json:"previous_hash"`
 Hash         string      `json:"hash"`
 Nonce        int64       `json:"nonce"`
 Transactions []Transaction `json:"transactions"`
 MerkleRoot   string      `json:"merkle_root"`
}

// Transaction 交易
type Transaction struct {
 From      string  `json:"from"`
 To        string  `json:"to"`
 Value     float64 `json:"value"`
 Timestamp int64   `json:"timestamp"`
 Signature string  `json:"signature"`
}

// Blockchain 区块链
type Blockchain struct {
 Chain      []*Block
 Difficulty int // 挖矿难度
}

// NewBlockchain 创建区块链
func NewBlockchain() *Blockchain {
 // 创世区块
 genesis := &Block{
  Index:        0,
  Timestamp:    time.Now().Unix(),
  PreviousHash: "0",
  Transactions: []Transaction{},
 }
 genesis.Hash = calculateHash(genesis)

 return &Blockchain{
  Chain:      []*Block{genesis},
  Difficulty: 4, // 前4位为0
 }
}

// AddBlock 添加区块
func (bc *Blockchain) AddBlock(transactions []Transaction) {
 prevBlock := bc.Chain[len(bc.Chain)-1]

 newBlock := &Block{
  Index:        prevBlock.Index + 1,
  Timestamp:    time.Now().Unix(),
  PreviousHash: prevBlock.Hash,
  Transactions: transactions,
  MerkleRoot:   calculateMerkleRoot(transactions),
 }

 // PoW挖矿
 bc.mineBlock(newBlock)

 bc.Chain = append(bc.Chain, newBlock)
 fmt.Printf("⛏️  区块挖出: #%d (hash: %s, nonce: %d)\n",
  newBlock.Index, newBlock.Hash[:16], newBlock.Nonce)
}

// mineBlock 挖矿 (Proof of Work)
func (bc *Blockchain) mineBlock(block *Block) {
 target := "0000" // 前4个0 (difficulty=4)

 for {
  block.Hash = calculateHash(block)
  if block.Hash[:bc.Difficulty] == target {
   break
  }
  block.Nonce++
 }
}

// calculateHash 计算哈希
func calculateHash(block *Block) string {
 record := fmt.Sprintf("%d%d%s%d%s",
  block.Index,
  block.Timestamp,
  block.PreviousHash,
  block.Nonce,
  block.MerkleRoot,
 )

 h := sha256.New()
 h.Write([]byte(record))
 return hex.EncodeToString(h.Sum(nil))
}

// calculateMerkleRoot 计算Merkle Root
func calculateMerkleRoot(transactions []Transaction) string {
 if len(transactions) == 0 {
  return ""
 }

 var hashes []string
 for _, tx := range transactions {
  txData := fmt.Sprintf("%s%s%.8f%d", tx.From, tx.To, tx.Value, tx.Timestamp)
  h := sha256.Sum256([]byte(txData))
  hashes = append(hashes, hex.EncodeToString(h[:]))
 }

 // 递归构建Merkle Tree
 for len(hashes) > 1 {
  var newLevel []string
  for i := 0; i < len(hashes); i += 2 {
   if i+1 < len(hashes) {
    combined := hashes[i] + hashes[i+1]
    h := sha256.Sum256([]byte(combined))
    newLevel = append(newLevel, hex.EncodeToString(h[:]))
   } else {
    newLevel = append(newLevel, hashes[i])
   }
  }
  hashes = newLevel
 }

 return hashes[0]
}

// IsValid 验证区块链
func (bc *Blockchain) IsValid() bool {
 for i := 1; i < len(bc.Chain); i++ {
  currentBlock := bc.Chain[i]
  prevBlock := bc.Chain[i-1]

  // 验证哈希
  if currentBlock.Hash != calculateHash(currentBlock) {
   return false
  }

  // 验证链接
  if currentBlock.PreviousHash != prevBlock.Hash {
   return false
  }

  // 验证PoW
  target := "0000"
  if currentBlock.Hash[:bc.Difficulty] != target {
   return false
  }
 }

 return true
}
```

---

## 2. 以太坊客户端

### 2.1 连接以太坊节点

```go
package ethereum

import (
 "Context"
 "fmt"
 "log"
 "math/big"

 "github.com/ethereum/go-ethereum/common"
 "github.com/ethereum/go-ethereum/core/types"
 "github.com/ethereum/go-ethereum/ethclient"
)

// go-ethereum (Geth) - 官方Go客户端
/*
以太坊网络:
  • Mainnet: 主网 (真实ETH)
  • Sepolia: 测试网 (免费测试)
  • Goerli:  测试网
  • Localhost: 本地节点 (Ganache, Hardhat)

连接方式:
  • HTTP: http://localhost:8545
  • WebSocket: ws://localhost:8546
  • IPC: /var/run/geth.ipc
  • Infura: https://mainnet.infura.io/v3/YOUR_KEY
  • Alchemy: https://eth-mainnet.g.alchemy.com/v2/YOUR_KEY
*/

// EthereumClient 以太坊客户端
type EthereumClient struct {
 client  *ethclient.Client
 chainID *big.Int
}

// NewEthereumClient 创建客户端
func NewEthereumClient(rpcURL string) (*EthereumClient, error) {
 client, err := ethclient.Dial(rpcURL)
 if err != nil {
  return nil, fmt.Errorf("连接失败: %w", err)
 }

 // 获取Chain ID
 chainID, err := client.ChainID(Context.Background())
 if err != nil {
  return nil, fmt.Errorf("获取Chain ID失败: %w", err)
 }

 log.Printf("✅ 连接到以太坊网络 (Chain ID: %s)", chainID.String())

 return &EthereumClient{
  client:  client,
  chainID: chainID,
 }, nil
}

// GetBlockNumber 获取最新区块号
func (ec *EthereumClient) GetBlockNumber(ctx Context.Context) (uint64, error) {
 blockNumber, err := ec.client.BlockNumber(ctx)
 if err != nil {
  return 0, fmt.Errorf("获取区块号失败: %w", err)
 }

 return blockNumber, nil
}

// GetBalance 获取账户余额
func (ec *EthereumClient) GetBalance(ctx Context.Context, address string) (*big.Int, error) {
 account := common.HexToAddress(address)
 balance, err := ec.client.BalanceAt(ctx, account, nil)
 if err != nil {
  return nil, fmt.Errorf("获取余额失败: %w", err)
 }

 return balance, nil
}

// GetBlock 获取区块信息
func (ec *EthereumClient) GetBlock(ctx Context.Context, blockNumber *big.Int) (*types.Block, error) {
 block, err := ec.client.BlockByNumber(ctx, blockNumber)
 if err != nil {
  return nil, fmt.Errorf("获取区块失败: %w", err)
 }

 return block, nil
}

// GetTransaction 获取交易信息
func (ec *EthereumClient) GetTransaction(ctx Context.Context, txHash string) (*types.Transaction, bool, error) {
 hash := common.HexToHash(txHash)
 tx, isPending, err := ec.client.TransactionByHash(ctx, hash)
 if err != nil {
  return nil, false, fmt.Errorf("获取交易失败: %w", err)
 }

 return tx, isPending, nil
}

// GetTransactionReceipt 获取交易收据
func (ec *EthereumClient) GetTransactionReceipt(ctx Context.Context, txHash string) (*types.Receipt, error) {
 hash := common.HexToHash(txHash)
 receipt, err := ec.client.TransactionReceipt(ctx, hash)
 if err != nil {
  return nil, fmt.Errorf("获取收据失败: %w", err)
 }

 return receipt, nil
}

// SubscribeNewBlocks 订阅新区块
func (ec *EthereumClient) SubscribeNewBlocks(ctx Context.Context) (<-Channel *types.Header, error) {
 headers := make(Channel *types.Header)

 sub, err := ec.client.SubscribeNewHead(ctx, headers)
 if err != nil {
  return nil, fmt.Errorf("订阅失败: %w", err)
 }

 go func() {
  defer close(headers)
  for {
   select {
   case err := <-sub.Err():
    log.Printf("❌ 订阅错误: %v", err)
    return
   case <-ctx.Done():
    sub.Unsubscribe()
    return
   }
  }
 }()

 log.Println("📡 已订阅新区块")
 return headers, nil
}

// Close 关闭客户端
func (ec *EthereumClient) Close() {
 ec.client.Close()
}
```

### 2.2 发送交易

```go
package ethereum

import (
 "Context"
 "crypto/ecdsa"
 "fmt"
 "math/big"

 "github.com/ethereum/go-ethereum/common"
 "github.com/ethereum/go-ethereum/core/types"
 "github.com/ethereum/go-ethereum/crypto"
)

// SendETH 发送ETH
func (ec *EthereumClient) SendETH(ctx Context.Context, privateKeyHex, toAddress string, amount *big.Int) (string, error) {
 // 解析私钥
 privateKey, err := crypto.HexToECDSA(privateKeyHex)
 if err != nil {
  return "", fmt.Errorf("解析私钥失败: %w", err)
 }

 // 获取发送方地址
 publicKey := privateKey.Public()
 publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
 if !ok {
  return "", fmt.Errorf("无法转换公钥")
 }
 fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA)

 // 获取nonce
 nonce, err := ec.client.PendingNonceAt(ctx, fromAddress)
 if err != nil {
  return "", fmt.Errorf("获取nonce失败: %w", err)
 }

 // 获取Gas Price
 gasPrice, err := ec.client.SuggestGasPrice(ctx)
 if err != nil {
  return "", fmt.Errorf("获取Gas Price失败: %w", err)
 }

 // 构造交易
 toAddr := common.HexToAddress(toAddress)
 tx := types.NewTransaction(
  nonce,
  toAddr,
  amount,
  21000, // Gas limit for ETH transfer
  gasPrice,
  nil,
 )

 // 签名交易
 signedTx, err := types.SignTx(tx, types.NewEIP155Signer(ec.chainID), privateKey)
 if err != nil {
  return "", fmt.Errorf("签名失败: %w", err)
 }

 // 发送交易
 err = ec.client.SendTransaction(ctx, signedTx)
 if err != nil {
  return "", fmt.Errorf("发送交易失败: %w", err)
 }

 txHash := signedTx.Hash().Hex()
 log.Printf("✅ 交易已发送: %s", txHash)

 return txHash, nil
}

// WaitMined 等待交易确认
func (ec *EthereumClient) WaitMined(ctx Context.Context, txHash string) (*types.Receipt, error) {
 hash := common.HexToHash(txHash)

 // 等待交易被打包
 receipt, err := bind.WaitMined(ctx, ec.client, &types.Transaction{})
 if err != nil {
  return nil, fmt.Errorf("等待确认失败: %w", err)
 }

 if receipt.Status == 1 {
  log.Printf("✅ 交易成功: %s (block: %d, gas: %d)",
   txHash, receipt.BlockNumber.Uint64(), receipt.GasUsed)
 } else {
  log.Printf("❌ 交易失败: %s", txHash)
 }

 return receipt, nil
}
```

---

## 3. 智能合约交互

### 3.1 ERC-20代币合约

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// ERC-20标准代币合约
contract MyToken {
    string public name = "MyToken";
    string public symbol = "MTK";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 _initialSupply) {
        totalSupply = _initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, "Insufficient balance");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], "Insufficient balance");
        require(_value <= allowance[_from][msg.sender], "Allowance exceeded");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }
}
```

### 3.2 Go调用ERC-20合约

```go
package contracts

import (
 "Context"
 "fmt"
 "log"
 "math/big"

 "github.com/ethereum/go-ethereum/accounts/abi/bind"
 "github.com/ethereum/go-ethereum/common"
 "github.com/ethereum/go-ethereum/crypto"
)

// 使用abigen生成Go绑定
/*
步骤:
1. 编译合约生成ABI和Bytecode
   solc --abi --bin MyToken.sol -o build/

2. 生成Go绑定
   abigen --abi=build/MyToken.abi --bin=build/MyToken.bin --pkg=contracts --out=MyToken.go

3. 在Go中使用
   import "./contracts"
*/

// ERC20Token ERC-20代币客户端
type ERC20Token struct {
 client   *ethclient.Client
 contract *MyToken // 自动生成的合约绑定
 address  common.Address
}

// NewERC20Token 创建ERC-20客户端
func NewERC20Token(client *ethclient.Client, contractAddress string) (*ERC20Token, error) {
 address := common.HexToAddress(contractAddress)

 // 加载合约实例
 contract, err := NewMyToken(address, client)
 if err != nil {
  return nil, fmt.Errorf("加载合约失败: %w", err)
 }

 return &ERC20Token{
  client:   client,
  contract: contract,
  address:  address,
 }, nil
}

// GetBalance 获取代币余额
func (t *ERC20Token) GetBalance(ctx Context.Context, address string) (*big.Int, error) {
 addr := common.HexToAddress(address)
 balance, err := t.contract.BalanceOf(&bind.CallOpts{Context: ctx}, addr)
 if err != nil {
  return nil, fmt.Errorf("获取余额失败: %w", err)
 }

 return balance, nil
}

// Transfer 转账代币
func (t *ERC20Token) Transfer(ctx Context.Context, privateKeyHex, toAddress string, amount *big.Int) (string, error) {
 // 解析私钥
 privateKey, err := crypto.HexToECDSA(privateKeyHex)
 if err != nil {
  return "", fmt.Errorf("解析私钥失败: %w", err)
 }

 // 获取发送方地址
 publicKey := privateKey.Public().(*ecdsa.PublicKey)
 fromAddress := crypto.PubkeyToAddress(*publicKey)

 // 获取nonce
 nonce, err := t.client.PendingNonceAt(ctx, fromAddress)
 if err != nil {
  return "", fmt.Errorf("获取nonce失败: %w", err)
 }

 // 获取Gas Price
 gasPrice, err := t.client.SuggestGasPrice(ctx)
 if err != nil {
  return "", fmt.Errorf("获取Gas Price失败: %w", err)
 }

 // 获取Chain ID
 chainID, err := t.client.ChainID(ctx)
 if err != nil {
  return "", fmt.Errorf("获取Chain ID失败: %w", err)
 }

 // 构造交易选项
 auth, err := bind.NewKeyedTransactorWithChainID(privateKey, chainID)
 if err != nil {
  return "", fmt.Errorf("创建交易器失败: %w", err)
 }

 auth.Nonce = big.NewInt(int64(nonce))
 auth.Value = big.NewInt(0)      // 不发送ETH
 auth.GasLimit = uint64(100000)  // Gas限制
 auth.GasPrice = gasPrice

 // 调用合约方法
 to := common.HexToAddress(toAddress)
 tx, err := t.contract.Transfer(auth, to, amount)
 if err != nil {
  return "", fmt.Errorf("转账失败: %w", err)
 }

 txHash := tx.Hash().Hex()
 log.Printf("✅ 代币转账交易已发送: %s", txHash)

 return txHash, nil
}

// Approve 授权代币
func (t *ERC20Token) Approve(ctx Context.Context, privateKeyHex, spenderAddress string, amount *big.Int) (string, error) {
 privateKey, err := crypto.HexToECDSA(privateKeyHex)
 if err != nil {
  return "", err
 }

 chainID, _ := t.client.ChainID(ctx)
 auth, _ := bind.NewKeyedTransactorWithChainID(privateKey, chainID)

 spender := common.HexToAddress(spenderAddress)
 tx, err := t.contract.Approve(auth, spender, amount)
 if err != nil {
  return "", fmt.Errorf("授权失败: %w", err)
 }

 return tx.Hash().Hex(), nil
}

// TotalSupply 获取总供应量
func (t *ERC20Token) TotalSupply(ctx Context.Context) (*big.Int, error) {
 supply, err := t.contract.TotalSupply(&bind.CallOpts{Context: ctx})
 if err != nil {
  return nil, fmt.Errorf("获取总供应量失败: %w", err)
 }

 return supply, nil
}
```

---

## 4. DeFi协议

### 4.1 自动做市商 (AMM)

```solidity
// SimpleSwap - 简化版Uniswap V2
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract SimpleSwap {
    IERC20 public tokenA;
    IERC20 public tokenB;

    uint256 public reserveA;
    uint256 public reserveB;

    uint256 public totalLiquidity;
    mapping(address => uint256) public liquidity;

    constructor(address _tokenA, address _tokenB) {
        tokenA = IERC20(_tokenA);
        tokenB = IERC20(_tokenB);
    }

    // 添加流动性
    function addLiquid ity(uint256 amountA, uint256 amountB) external returns (uint256) {
        require(amountA > 0 && amountB > 0, "Invalid amounts");

        tokenA.transferFrom(msg.sender, address(this), amountA);
        tokenB.transferFrom(msg.sender, address(this), amountB);

        uint256 liquidityMinted;

        if (totalLiquidity == 0) {
            liquidityMinted = sqrt(amountA * amountB);
        } else {
            liquidityMinted = min(
                (amountA * totalLiquidity) / reserveA,
                (amountB * totalLiquidity) / reserveB
            );
        }

        liquidity[msg.sender] += liquidityMinted;
        totalLiquidity += liquidityMinted;

        reserveA += amountA;
        reserveB += amountB;

        return liquidityMinted;
    }

    // 移除流动性
    function removeLiquidity(uint256 liquidityAmount) external returns (uint256, uint256) {
        require(liquidityAmount > 0, "Invalid amount");
        require(liquidity[msg.sender] >= liquidityAmount, "Insufficient liquidity");

        uint256 amountA = (liquidityAmount * reserveA) / totalLiquidity;
        uint256 amountB = (liquidityAmount * reserveB) / totalLiquidity;

        liquidity[msg.sender] -= liquidityAmount;
        totalLiquidity -= liquidityAmount;

        reserveA -= amountA;
        reserveB -= amountB;

        tokenA.transfer(msg.sender, amountA);
        tokenB.transfer(msg.sender, amountB);

        return (amountA, amountB);
    }

    // 交换 A -> B
    function swapAToB(uint256 amountAIn) external returns (uint256) {
        require(amountAIn > 0, "Invalid amount");

        // Constant Product Formula: x * y = k
        uint256 amountBOut = getAmountOut(amountAIn, reserveA, reserveB);

        tokenA.transferFrom(msg.sender, address(this), amountAIn);
        tokenB.transfer(msg.sender, amountBOut);

        reserveA += amountAIn;
        reserveB -= amountBOut;

        return amountBOut;
    }

    // 交换 B -> A
    function swapBToA(uint256 amountBIn) external returns (uint256) {
        require(amountBIn > 0, "Invalid amount");

        uint256 amountAOut = getAmountOut(amountBIn, reserveB, reserveA);

        tokenB.transferFrom(msg.sender, address(this), amountBIn);
        tokenA.transfer(msg.sender, amountAOut);

        reserveA -= amountAOut;
        reserveB += amountBIn;

        return amountAOut;
    }

    // 计算输出数量 (0.3%手续费)
    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)
        public
        pure
        returns (uint256)
    {
        require(amountIn > 0, "Invalid input amount");
        require(reserveIn > 0 && reserveOut > 0, "Insufficient liquidity");

        uint256 amountInWithFee = amountIn * 997; // 0.3% fee
        uint256 numerator = amountInWithFee * reserveOut;
        uint256 denominator = (reserveIn * 1000) + amountInWithFee;

        return numerator / denominator;
    }

    // 辅助函数
    function sqrt(uint256 y) internal pure returns (uint256 z) {
        if (y > 3) {
            z = y;
            uint256 x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }

    function min(uint256 x, uint256 y) internal pure returns (uint256) {
        return x < y ? x : y;
    }
}
```

### 4.2 Go实现DEX交互

```go
package defi

import (
 "Context"
 "fmt"
 "log"
 "math/big"
)

// DEXClient DEX客户端
type DEXClient struct {
 client   *ethclient.Client
 contract *SimpleSwap // 自动生成的合约绑定
 tokenA   *ERC20Token
 tokenB   *ERC20Token
}

// NewDEXClient 创建DEX客户端
func NewDEXClient(
 client *ethclient.Client,
 dexAddress, tokenAAddress, tokenBAddress string,
) (*DEXClient, error) {
 // 加载DEX合约
 dexAddr := common.HexToAddress(dexAddress)
 dexContract, err := NewSimpleSwap(dexAddr, client)
 if err != nil {
  return nil, err
 }

 // 加载Token合约
 tokenA, err := NewERC20Token(client, tokenAAddress)
 if err != nil {
  return nil, err
 }

 tokenB, err := NewERC20Token(client, tokenBAddress)
 if err != nil {
  return nil, err
 }

 return &DEXClient{
  client:   client,
  contract: dexContract,
  tokenA:   tokenA,
  tokenB:   tokenB,
 }, nil
}

// AddLiquidity 添加流动性
func (d *DEXClient) AddLiquidity(
 ctx Context.Context,
 privateKeyHex string,
 amountA, amountB *big.Int,
) (string, error) {
 privateKey, err := crypto.HexToECDSA(privateKeyHex)
 if err != nil {
  return "", err
 }

 publicKey := privateKey.Public().(*ecdsa.PublicKey)
 fromAddress := crypto.PubkeyToAddress(*publicKey)

 // 1. 授权Token A
 log.Println("📝 授权Token A...")
 txHashA, err := d.tokenA.Approve(ctx, privateKeyHex, d.contract.address.Hex(), amountA)
 if err != nil {
  return "", fmt.Errorf("授权Token A失败: %w", err)
 }
 log.Printf("✅ Token A授权交易: %s", txHashA)

 // 2. 授权Token B
 log.Println("📝 授权Token B...")
 txHashB, err := d.tokenB.Approve(ctx, privateKeyHex, d.contract.address.Hex(), amountB)
 if err != nil {
  return "", fmt.Errorf("授权Token B失败: %w", err)
 }
 log.Printf("✅ Token B授权交易: %s", txHashB)

 // 3. 添加流动性
 chainID, _ := d.client.ChainID(ctx)
 auth, _ := bind.NewKeyedTransactorWithChainID(privateKey, chainID)

 tx, err := d.contract.AddLiquidity(auth, amountA, amountB)
 if err != nil {
  return "", fmt.Errorf("添加流动性失败: %w", err)
 }

 txHash := tx.Hash().Hex()
 log.Printf("💧 添加流动性交易已发送: %s", txHash)

 return txHash, nil
}

// Swap 交换代币
func (d *DEXClient) Swap(
 ctx Context.Context,
 privateKeyHex string,
 fromToken string,
 amountIn *big.Int,
) (string, *big.Int, error) {
 privateKey, err := crypto.HexToECDSA(privateKeyHex)
 if err != nil {
  return "", nil, err
 }

 chainID, _ := d.client.ChainID(ctx)
 auth, _ := bind.NewKeyedTransactorWithChainID(privateKey, chainID)

 var tx *types.Transaction

 if fromToken == "A" {
  // 授权Token A
  d.tokenA.Approve(ctx, privateKeyHex, d.contract.address.Hex(), amountIn)

  // 交换 A -> B
  tx, err = d.contract.SwapAToB(auth, amountIn)
 } else {
  // 授权Token B
  d.tokenB.Approve(ctx, privateKeyHex, d.contract.address.Hex(), amountIn)

  // 交换 B -> A
  tx, err = d.contract.SwapBToA(auth, amountIn)
 }

 if err != nil {
  return "", nil, fmt.Errorf("交换失败: %w", err)
 }

 txHash := tx.Hash().Hex()
 log.Printf("🔄 交换交易已发送: %s", txHash)

 // 等待交易确认并获取输出数量
 receipt, err := bind.WaitMined(ctx, d.client, tx)
 if err != nil {
  return "", nil, err
 }

 // 解析事件日志获取实际输出量
 // (简化示例，实际需要解析事件)
 amountOut := big.NewInt(0)

 return txHash, amountOut, nil
}

// GetReserves 获取流动性储备
func (d *DEXClient) GetReserves(ctx Context.Context) (*big.Int, *big.Int, error) {
 reserveA, err := d.contract.ReserveA(&bind.CallOpts{Context: ctx})
 if err != nil {
  return nil, nil, err
 }

 reserveB, err := d.contract.ReserveB(&bind.CallOpts{Context: ctx})
 if err != nil {
  return nil, nil, err
 }

 return reserveA, reserveB, nil
}
```

---

## 5. NFT铸造与交易

### 5.1 ERC-721 NFT合约

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract MyNFT is ERC721, ERC721URIStorage, Ownable {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    constructor() ERC721("MyNFT", "MNFT") {}

    // 铸造NFT
    function mintNFT(address recipient, string memory tokenURI)
        public
        onlyOwner
        returns (uint256)
    {
        _tokenIds.increment();
        uint256 newTokenId = _tokenIds.current();

        _safeMint(recipient, newTokenId);
        _setTokenURI(newTokenId, tokenURI);

        return newTokenId;
    }

    // 批量铸造
    function batchMint(address recipient, string[] memory tokenURIs)
        public
        onlyOwner
        returns (uint256[] memory)
    {
        uint256[] memory tokenIds = new uint256[](tokenURIs.length);

        for (uint256 i = 0; i < tokenURIs.length; i++) {
            _tokenIds.increment();
            uint256 newTokenId = _tokenIds.current();

            _safeMint(recipient, newTokenId);
            _setTokenURI(newTokenId, tokenURIs[i]);

            tokenIds[i] = newTokenId;
        }

        return tokenIds;
    }

    // 销毁NFT
    function burn(uint256 tokenId) public {
        require(ownerOf(tokenId) == msg.sender, "Not the owner");
        _burn(tokenId);
    }

    // 必要的Override
    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
    }

    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
```

### 5.2 Go实现NFT铸造

```go
package nft

import (
 "Context"
 "fmt"
 "log"
 "math/big"
)

// NFTClient NFT客户端
type NFTClient struct {
 client   *ethclient.Client
 contract *MyNFT // 自动生成的合约绑定
 address  common.Address
}

// NewNFTClient 创建NFT客户端
func NewNFTClient(client *ethclient.Client, contractAddress string) (*NFTClient, error) {
 address := common.HexToAddress(contractAddress)

 contract, err := NewMyNFT(address, client)
 if err != nil {
  return nil, fmt.Errorf("加载合约失败: %w", err)
 }

 return &NFTClient{
  client:   client,
  contract: contract,
  address:  address,
 }, nil
}

// MintNFT 铸造NFT
func (n *NFTClient) MintNFT(
 ctx Context.Context,
 privateKeyHex, recipient, tokenURI string,
) (string, *big.Int, error) {
 privateKey, err := crypto.HexToECDSA(privateKeyHex)
 if err != nil {
  return "", nil, err
 }

 chainID, _ := n.client.ChainID(ctx)
 auth, _ := bind.NewKeyedTransactorWithChainID(privateKey, chainID)

 recipientAddr := common.HexToAddress(recipient)

 // 调用mintNFT
 tx, err := n.contract.MintNFT(auth, recipientAddr, tokenURI)
 if err != nil {
  return "", nil, fmt.Errorf("铸造失败: %w", err)
 }

 txHash := tx.Hash().Hex()
 log.Printf("🎨 NFT铸造交易已发送: %s", txHash)

 // 等待确认
 receipt, err := bind.WaitMined(ctx, n.client, tx)
 if err != nil {
  return "", nil, err
 }

 // 解析事件获取Token ID
 // (简化示例，实际需要解析Transfer事件)
 tokenID := big.NewInt(1)

 log.Printf("✅ NFT铸造成功: Token ID=%s", tokenID.String())

 return txHash, tokenID, nil
}

// GetTokenURI 获取Token URI
func (n *NFTClient) GetTokenURI(ctx Context.Context, tokenID *big.Int) (string, error) {
 uri, err := n.contract.TokenURI(&bind.CallOpts{Context: ctx}, tokenID)
 if err != nil {
  return "", fmt.Errorf("获取URI失败: %w", err)
 }

 return uri, nil
}

// GetOwner 获取NFT拥有者
func (n *NFTClient) GetOwner(ctx Context.Context, tokenID *big.Int) (string, error) {
 owner, err := n.contract.OwnerOf(&bind.CallOpts{Context: ctx}, tokenID)
 if err != nil {
  return "", fmt.Errorf("获取拥有者失败: %w", err)
 }

 return owner.Hex(), nil
}

// TransferNFT 转移NFT
func (n *NFTClient) TransferNFT(
 ctx Context.Context,
 privateKeyHex, toAddress string,
 tokenID *big.Int,
) (string, error) {
 privateKey, err := crypto.HexToECDSA(privateKeyHex)
 if err != nil {
  return "", err
 }

 publicKey := privateKey.Public().(*ecdsa.PublicKey)
 fromAddress := crypto.PubkeyToAddress(*publicKey)

 chainID, _ := n.client.ChainID(ctx)
 auth, _ := bind.NewKeyedTransactorWithChainID(privateKey, chainID)

 toAddr := common.HexToAddress(toAddress)

 // 调用transferFrom
 tx, err := n.contract.TransferFrom(auth, fromAddress, toAddr, tokenID)
 if err != nil {
  return "", fmt.Errorf("转移失败: %w", err)
 }

 txHash := tx.Hash().Hex()
 log.Printf("📤 NFT转移交易已发送: %s", txHash)

 return txHash, nil
}
```

---

## 6. IPFS分布式存储

### 6.1 IPFS存储NFT元数据

```go
package ipfs

import (
 "bytes"
 "Context"
 "encoding/json"
 "fmt"
 "io"

 shell "github.com/ipfs/go-ipfs-api"
)

// IPFS分布式存储
/*
IPFS (InterPlanetary File System):
  • 内容寻址 (CID - Content Identifier)
  • 去中心化存储
  • 不可篡改
  • P2P网络

NFT元数据存储:
  1. 上传图片 → IPFS CID
  2. 构造元数据JSON → 包含图片CID
  3. 上传元数据 → IPFS CID
  4. 铸造NFT → tokenURI = ipfs://CID

IPFS网关:
  • 本地节点: http://localhost:8080/ipfs/{cid}
  • Infura: https://infura-ipfs.io/ipfs/{cid}
  • Pinata: https://gateway.pinata.cloud/ipfs/{cid}
*/

// IPFSClient IPFS客户端
type IPFSClient struct {
 shell *shell.Shell
}

// NewIPFSClient 创建IPFS客户端
func NewIPFSClient(apiURL string) *IPFSClient {
 return &IPFSClient{
  shell: shell.NewShell(apiURL),
 }
}

// NFTMetadata NFT元数据
type NFTMetadata struct {
 Name        string            `json:"name"`
 Description string            `json:"description"`
 Image       string            `json:"image"`        // ipfs://...
 ExternalURL string            `json:"external_url"`
 Attributes  []NFTAttribute    `json:"attributes"`
}

// NFTAttribute NFT属性
type NFTAttribute struct {
 TraitType string      `json:"trait_type"`
 Value     interface{} `json:"value"`
}

// UploadFile 上传文件到IPFS
func (ic *IPFSClient) UploadFile(ctx Context.Context, data []byte) (string, error) {
 reader := bytes.NewReader(data)

 cid, err := ic.shell.Add(reader)
 if err != nil {
  return "", fmt.Errorf("上传失败: %w", err)
 }

 log.Printf("📤 文件已上传到IPFS: %s", cid)
 return cid, nil
}

// UploadNFTMetadata 上传NFT元数据
func (ic *IPFSClient) UploadNFTMetadata(ctx Context.Context, metadata NFTMetadata) (string, error) {
 // 序列化为JSON
 jsonData, err := json.MarshalIndent(metadata, "", "  ")
 if err != nil {
  return "", fmt.Errorf("序列化失败: %w", err)
 }

 // 上传到IPFS
 cid, err := ic.UploadFile(ctx, jsonData)
 if err != nil {
  return "", err
 }

 log.Printf("📝 元数据已上传: %s", cid)
 return cid, nil
}

// GetFile 从IPFS获取文件
func (ic *IPFSClient) GetFile(ctx Context.Context, cid string) ([]byte, error) {
 reader, err := ic.shell.Cat(cid)
 if err != nil {
  return nil, fmt.Errorf("读取失败: %w", err)
 }
 defer reader.Close()

 data, err := io.ReadAll(reader)
 if err != nil {
  return nil, fmt.Errorf("读取失败: %w", err)
 }

 return data, nil
}

// GetNFTMetadata 获取NFT元数据
func (ic *IPFSClient) GetNFTMetadata(ctx Context.Context, cid string) (*NFTMetadata, error) {
 data, err := ic.GetFile(ctx, cid)
 if err != nil {
  return nil, err
 }

 var metadata NFTMetadata
 if err := json.Unmarshal(data, &metadata); err != nil {
  return nil, fmt.Errorf("解析失败: %w", err)
 }

 return &metadata, nil
}

// PinFile 固定文件 (防止垃圾回收)
func (ic *IPFSClient) PinFile(ctx Context.Context, cid string) error {
 err := ic.shell.Pin(cid)
 if err != nil {
  return fmt.Errorf("固定失败: %w", err)
 }

 log.Printf("📌 文件已固定: %s", cid)
 return nil
}

// UnpinFile 取消固定
func (ic *IPFSClient) UnpinFile(ctx Context.Context, cid string) error {
 err := ic.shell.Unpin(cid)
 if err != nil {
  return fmt.Errorf("取消固定失败: %w", err)
 }

 return nil
}
```

### 6.2 完整NFT铸造流程

```go
package main

import (
 "Context"
 "fmt"
 "log"
 "os"
)

// MintNFTWithIPFS 使用IPFS铸造NFT
func MintNFTWithIPFS(
 ipfsClient *IPFSClient,
 nftClient *NFTClient,
 privateKey, recipient string,
 imagePath string,
) error {
 ctx := Context.Background()

 // 1. 上传图片到IPFS
 log.Println("📸 上传图片到IPFS...")
 imageData, err := os.ReadFile(imagePath)
 if err != nil {
  return fmt.Errorf("读取图片失败: %w", err)
 }

 imageCID, err := ipfsClient.UploadFile(ctx, imageData)
 if err != nil {
  return err
 }

 imageURI := fmt.Sprintf("ipfs://%s", imageCID)
 log.Printf("✅ 图片URI: %s", imageURI)

 // 2. 构造元数据
 metadata := NFTMetadata{
  Name:        "Awesome NFT #1",
  Description: "This is an awesome NFT",
  Image:       imageURI,
  ExternalURL: "https://example.com",
  Attributes: []NFTAttribute{
   {TraitType: "Rarity", Value: "Legendary"},
   {TraitType: "Level", Value: 10},
  },
 }

 // 3. 上传元数据到IPFS
 log.Println("📝 上传元数据到IPFS...")
 metadataCID, err := ipfsClient.UploadNFTMetadata(ctx, metadata)
 if err != nil {
  return err
 }

 tokenURI := fmt.Sprintf("ipfs://%s", metadataCID)
 log.Printf("✅ 元数据URI: %s", tokenURI)

 // 4. 固定文件
 ipfsClient.PinFile(ctx, imageCID)
 ipfsClient.PinFile(ctx, metadataCID)

 // 5. 铸造NFT
 log.Println("🎨 铸造NFT...")
 txHash, tokenID, err := nftClient.MintNFT(ctx, privateKey, recipient, tokenURI)
 if err != nil {
  return err
 }

 log.Printf("✅ NFT铸造成功!")
 log.Printf("   Transaction: %s", txHash)
 log.Printf("   Token ID: %s", tokenID.String())
 log.Printf("   Token URI: %s", tokenURI)

 return nil
}
```

---

## 7. The Graph数据索引

### 7.1 Graph查询

```graphql
# GraphQL查询示例

# 查询所有NFT转移事件
query GetNFTTransfers {
  transfers(first: 100, orderBy: timestamp, orderDirection: desc) {
    id
    from
    to
    tokenId
    timestamp
    blockNumber
    transactionHash
  }
}

# 查询特定用户的NFT
query GetUserNFTs($owner: Bytes!) {
  tokens(where: { owner: $owner }) {
    id
    tokenId
    tokenURI
    owner
    mintedAt
  }
}

# 查询DEX交易
query GetSwaps {
  swaps(first: 50, orderBy: timestamp, orderDirection: desc) {
    id
    sender
    amountIn
    amountOut
    tokenIn
    tokenOut
    timestamp
  }
}
```

### 7.2 Go调用The Graph

```go
package thegraph

import (
 "bytes"
 "Context"
 "encoding/json"
 "fmt"
 "io"
 "net/http"
)

// TheGraphClient The Graph客户端
type TheGraphClient struct {
 endpoint string
 httpClient *http.Client
}

// NewTheGraphClient 创建客户端
func NewTheGraphClient(subgraphURL string) *TheGraphClient {
 return &TheGraphClient{
  endpoint:   subgraphURL,
  httpClient: &http.Client{},
 }
}

// GraphQLRequest GraphQL请求
type GraphQLRequest struct {
 Query     string                 `json:"query"`
 Variables map[string]interface{} `json:"variables,omitempty"`
}

// GraphQLResponse GraphQL响应
type GraphQLResponse struct {
 Data   json.RawMessage `json:"data"`
 Errors []GraphQLError  `json:"errors,omitempty"`
}

// GraphQLError GraphQL错误
type GraphQLError struct {
 Message string `json:"message"`
}

// Query 执行GraphQL查询
func (tg *TheGraphClient) Query(ctx Context.Context, query string, variables map[string]interface{}) (json.RawMessage, error) {
 req := GraphQLRequest{
  Query:     query,
  Variables: variables,
 }

 reqBody, err := json.Marshal(req)
 if err != nil {
  return nil, fmt.Errorf("序列化失败: %w", err)
 }

 httpReq, err := http.NewRequestWithContext(ctx, "POST", tg.endpoint, bytes.NewBuffer(reqBody))
 if err != nil {
  return nil, fmt.Errorf("创建请求失败: %w", err)
 }

 httpReq.Header.Set("Content-Type", "application/json")

 resp, err := tg.httpClient.Do(httpReq)
 if err != nil {
  return nil, fmt.Errorf("请求失败: %w", err)
 }
 defer resp.Body.Close()

 body, err := io.ReadAll(resp.Body)
 if err != nil {
  return nil, fmt.Errorf("读取响应失败: %w", err)
 }

 var graphQLResp GraphQLResponse
 if err := json.Unmarshal(body, &graphQLResp); err != nil {
  return nil, fmt.Errorf("解析响应失败: %w", err)
 }

 if len(graphQLResp.Errors) > 0 {
  return nil, fmt.Errorf("GraphQL错误: %s", graphQLResp.Errors[0].Message)
 }

 return graphQLResp.Data, nil
}

// GetUserNFTs 获取用户NFT
func (tg *TheGraphClient) GetUserNFTs(ctx Context.Context, owner string) ([]NFTToken, error) {
 query := `
  query GetUserNFTs($owner: Bytes!) {
   tokens(where: { owner: $owner }) {
    id
    tokenId
    tokenURI
    owner
    mintedAt
   }
  }
 `

 variables := map[string]interface{}{
  "owner": owner,
 }

 data, err := tg.Query(ctx, query, variables)
 if err != nil {
  return nil, err
 }

 var result struct {
  Tokens []NFTToken `json:"tokens"`
 }

 if err := json.Unmarshal(data, &result); err != nil {
  return nil, fmt.Errorf("解析结果失败: %w", err)
 }

 return result.Tokens, nil
}

// NFTToken NFT Token
type NFTToken struct {
 ID       string `json:"id"`
 TokenID  string `json:"tokenId"`
 TokenURI string `json:"tokenURI"`
 Owner    string `json:"owner"`
 MintedAt int64  `json:"mintedAt"`
}
```

---

## 8. 完整DApp

### 8.1 Web3 DApp架构

```go
package dapp

import (
 "Context"
 "log"
 "net/http"

 "github.com/gin-gonic/gin"
)

// DApp完整架构
/*
前端 (React + ethers.js/web3.js)
         ↕
    REST API (Go)
         ↕
┌────────────────────────────┐
│   Smart Contracts          │
│  • ERC-20 Token            │
│  • DEX (Uniswap-like)      │
│  • NFT (ERC-721)           │
└────────────────────────────┘
         ↕
    Ethereum Network
         ↕
┌────────────────────────────┐
│   Data Indexing            │
│  • The Graph               │
│  • Event Listeners         │
└────────────────────────────┘
         ↕
┌────────────────────────────┐
│   Distributed Storage      │
│  • IPFS (NFT Metadata)     │
└────────────────────────────┘
*/

// DAppService DApp服务
type DAppService struct {
 ethClient   *EthereumClient
 tokenClient *ERC20Token
 dexClient   *DEXClient
 nftClient   *NFTClient
 ipfsClient  *IPFSClient
 graphClient *TheGraphClient
}

// NewDAppService 创建DApp服务
func NewDAppService(config DAppConfig) (*DAppService, error) {
 // 初始化以太坊客户端
 ethClient, err := NewEthereumClient(config.EthereumRPC)
 if err != nil {
  return nil, err
 }

 // 初始化各个合约客户端
 tokenClient, _ := NewERC20Token(ethClient.client, config.TokenAddress)
 dexClient, _ := NewDEXClient(ethClient.client, config.DEXAddress, config.TokenAAddress, config.TokenBAddress)
 nftClient, _ := NewNFTClient(ethClient.client, config.NFTAddress)

 // 初始化IPFS客户端
 ipfsClient := NewIPFSClient(config.IPFSAPI)

 // 初始化The Graph客户端
 graphClient := NewTheGraphClient(config.SubgraphURL)

 return &DAppService{
  ethClient:   ethClient,
  tokenClient: tokenClient,
  dexClient:   dexClient,
  nftClient:   nftClient,
  ipfsClient:  ipfsClient,
  graphClient: graphClient,
 }, nil
}

// SetupRoutes 设置路由
func (ds *DAppService) SetupRoutes(r *gin.Engine) {
 api := r.Group("/api/v1")

 // 账户相关
 api.GET("/account/:address/balance", ds.GetBalance)
 api.GET("/account/:address/tokens", ds.GetTokenBalance)
 api.GET("/account/:address/nfts", ds.GetUserNFTs)

 // Token相关
 api.POST("/token/transfer", ds.TransferToken)
 api.POST("/token/approve", ds.ApproveToken)

 // DEX相关
 api.POST("/dex/add-liquidity", ds.AddLiquidity)
 api.POST("/dex/swap", ds.Swap)
 api.GET("/dex/reserves", ds.GetReserves)

 // NFT相关
 api.POST("/nft/mint", ds.MintNFT)
 api.GET("/nft/:tokenId", ds.GetNFT)
 api.POST("/nft/transfer", ds.TransferNFT)

 // IPFS相关
 api.POST("/ipfs/upload", ds.UploadToIPFS)
 api.GET("/ipfs/:cid", ds.GetFromIPFS)
}

// GetBalance 获取ETH余额
func (ds *DAppService) GetBalance(c *gin.Context) {
 address := c.Param("address")

 balance, err := ds.ethClient.GetBalance(c.Request.Context(), address)
 if err != nil {
  c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
  return
 }

 c.JSON(http.StatusOK, gin.H{
  "address": address,
  "balance": balance.String(),
 })
}

// GetTokenBalance 获取Token余额
func (ds *DAppService) GetTokenBalance(c *gin.Context) {
 address := c.Param("address")

 balance, err := ds.tokenClient.GetBalance(c.Request.Context(), address)
 if err != nil {
  c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
  return
 }

 c.JSON(http.StatusOK, gin.H{
  "address": address,
  "balance": balance.String(),
 })
}

// GetUserNFTs 获取用户NFT
func (ds *DAppService) GetUserNFTs(c *gin.Context) {
 address := c.Param("address")

 nfts, err := ds.graphClient.GetUserNFTs(c.Request.Context(), address)
 if err != nil {
  c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
  return
 }

 c.JSON(http.StatusOK, gin.H{
  "nfts": nfts,
 })
}

// DAppConfig DApp配置
type DAppConfig struct {
 EthereumRPC   string
 TokenAddress  string
 TokenAAddress string
 TokenBAddress string
 DEXAddress    string
 NFTAddress    string
 IPFSAPI       string
 SubgraphURL   string
}
```

---

## 9. Gas优化

### 9.1 Gas优化技巧

```solidity
// Gas优化最佳实践

// ❌ 差: 多次读取存储
function badExample() public view returns (uint256) {
    uint256 result = 0;
    for (uint256 i = 0; i < balances.length; i++) {
        result += balances[i]; // 每次循环读取存储
    }
    return result;
}

// ✅ 好: 缓存存储到内存
function goodExample() public view returns (uint256) {
    uint256 result = 0;
    uint256[] memory cachedBalances = balances; // 一次性加载
    for (uint256 i = 0; i < cachedBalances.length; i++) {
        result += cachedBalances[i]; // 从内存读取
    }
    return result;
}

// ❌ 差: 多次访问storage
function updateBalance(uint256 amount) public {
    balance = balance + amount; // 读取 + 写入
}

// ✅ 好: 使用+=
function updateBalanceOptimized(uint256 amount) public {
    balance += amount; // 编译器优化
}

// ❌ 差: uint256 i = 0 (赋值浪费gas)
for (uint256 i = 0; i < length; i++) { ... }

// ✅ 好: uint256 i (默认为0)
for (uint256 i; i < length; ++i) { ... } // ++i比i++省gas

// 使用uint256代替uint8 (EVM对齐)
uint256 public value; // ✅ 推荐
uint8 public value;   // ❌ 可能更贵

// 使用自定义错误 (Solidity 0.8.4+)
error InsufficientBalance(uint256 available, uint256 required); // ✅ 便宜

// 代替
require(balance >= amount, "Insufficient balance"); // ❌ 更贵

// 使用事件而非存储记录历史
event Transfer(address indexed from, address indexed to, uint256 value); // ✅ 便宜

// 代替
Transfer[] public history; // ❌ 存储昂贵
```

---

## 10. 生产部署

### 10.1 Docker部署

```dockerfile
# Dockerfile
FROM golang:1.25-alpine AS builder

WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY . .

RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o web3-dapp ./cmd/dapp

FROM alpine:latest

RUN apk --no-cache add ca-certificates

WORKDIR /root/

COPY --from=builder /app/web3-dapp .
COPY --from=builder /app/configs ./configs

EXPOSE 8080

CMD ["./web3-dapp"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  dapp-backend:
    build: .
    ports:
      - "8080:8080"
    environment:
      - ETHEREUM_RPC=https://mainnet.infura.io/v3/${INFURA_KEY}
      - IPFS_API=http://ipfs:5001
      - DATABASE_URL=postgres://user:pass@postgres:5432/dapp?sslmode=disable
    depends_on:
      - postgres
      - ipfs
    restart: unless-stopped

  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: dapp
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
    volumes:
      - postgres-data:/var/lib/postgresql/data
    restart: unless-stopped

  # IPFS节点
  ipfs:
    image: ipfs/go-ipfs:latest
    ports:
      - "4001:4001"   # P2P
      - "5001:5001"   # API
      - "8081:8080"   # Gateway
    volumes:
      - ipfs-data:/data/ipfs
    restart: unless-stopped

  # Redis (缓存)
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    restart: unless-stopped

volumes:
  postgres-data:
  ipfs-data:
  redis-data:
```

---

## 总结

### ✅ 核心成果

1. **区块链基础**
   - 区块链原理与实现
   - PoW共识算法
   - Merkle Tree

2. **以太坊集成**
   - go-ethereum客户端
   - 发送交易
   - 监听事件

3. **智能合约**
   - ERC-20代币
   - ERC-721 NFT
   - DEX (AMM)

4. **DeFi协议**
   - 自动做市商 (Uniswap-like)
   - 流动性挖矿
   - Token交换

5. **NFT生态**
   - 铸造与交易
   - IPFS元数据存储
   - The Graph索引

6. **生产部署**
   - Docker容器化
   - Gas优化
   - 安全最佳实践

### 🌟 Go 1.25.3应用

| 特性 | 应用 |
|------|------|
| Goroutine | 事件监听、异步处理 |
| Channel | 区块链同步 |
| Context | 超时控制 |
| Generic | 类型安全的合约绑定 |
| Error Handling | 交易错误处理 |

### 📊 架构亮点

- **去中心化**: 无需信任第三方
- **不可篡改**: 区块链保证数据完整性
- **透明**: 所有交易公开可查
- **可组合性**: 智能合约乐高

### 🎯 适用场景

- DeFi (去中心化金融)
- NFT市场
- DAO (去中心化自治组织)
- 链上游戏

---

## 下一步学习
