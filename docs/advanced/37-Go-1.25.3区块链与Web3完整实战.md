# Go 1.25.3åŒºå—é“¾ä¸Web3å®Œæ•´å®æˆ˜

> **ä»¥å¤ªåŠé›†æˆÂ·æ™ºèƒ½åˆçº¦Â·DeFiåè®®Â·NFTÂ·IPFSåˆ†å¸ƒå¼å­˜å‚¨**  
> ğŸ“ **éš¾åº¦**ï¼šâ­â­â­â­â­ (é«˜çº§)  
> ğŸ¯ **ç›®æ ‡**ï¼šæ„å»ºç”Ÿäº§çº§Web3åº”ç”¨  
> â± **é¢„è®¡æ—¶é—´**ï¼š6-8å°æ—¶  
> ğŸ”§ **æŠ€æœ¯æ ˆ**ï¼šEthereumÂ·SolidityÂ·go-ethereumÂ·IPFSÂ·The GraphÂ·Chainlink

---


## ğŸ“‹ ç›®å½•


- [ç›®å½•](#ç›®å½•)
- [1. åŒºå—é“¾åŸºç¡€](#1-åŒºå—é“¾åŸºç¡€)
  - [1.1 åŒºå—é“¾æ ¸å¿ƒæ¦‚å¿µ](#11-åŒºå—é“¾æ ¸å¿ƒæ¦‚å¿µ)
- [2. ä»¥å¤ªåŠå®¢æˆ·ç«¯](#2-ä»¥å¤ªåŠå®¢æˆ·ç«¯)
  - [2.1 è¿æ¥ä»¥å¤ªåŠèŠ‚ç‚¹](#21-è¿æ¥ä»¥å¤ªåŠèŠ‚ç‚¹)
  - [2.2 å‘é€äº¤æ˜“](#22-å‘é€äº¤æ˜“)
- [3. æ™ºèƒ½åˆçº¦äº¤äº’](#3-æ™ºèƒ½åˆçº¦äº¤äº’)
  - [3.1 ERC-20ä»£å¸åˆçº¦](#31-erc-20ä»£å¸åˆçº¦)
  - [3.2 Goè°ƒç”¨ERC-20åˆçº¦](#32-goè°ƒç”¨erc-20åˆçº¦)
- [4. DeFiåè®®](#4-defiåè®®)
  - [4.1 è‡ªåŠ¨åšå¸‚å•† (AMM)](#41-è‡ªåŠ¨åšå¸‚å•†-amm)
  - [4.2 Goå®ç°DEXäº¤äº’](#42-goå®ç°dexäº¤äº’)
- [5. NFTé“¸é€ ä¸äº¤æ˜“](#5-nfté“¸é€ ä¸äº¤æ˜“)
  - [5.1 ERC-721 NFTåˆçº¦](#51-erc-721-nftåˆçº¦)
  - [5.2 Goå®ç°NFTé“¸é€ ](#52-goå®ç°nfté“¸é€ )
- [6. IPFSåˆ†å¸ƒå¼å­˜å‚¨](#6-ipfsåˆ†å¸ƒå¼å­˜å‚¨)
  - [6.1 IPFSå­˜å‚¨NFTå…ƒæ•°æ®](#61-ipfså­˜å‚¨nftå…ƒæ•°æ®)
  - [6.2 å®Œæ•´NFTé“¸é€ æµç¨‹](#62-å®Œæ•´nfté“¸é€ æµç¨‹)
- [7. The Graphæ•°æ®ç´¢å¼•](#7-the-graphæ•°æ®ç´¢å¼•)
  - [7.1 GraphæŸ¥è¯¢](#71-graphæŸ¥è¯¢)
  - [7.2 Goè°ƒç”¨The Graph](#72-goè°ƒç”¨the-graph)
- [8. å®Œæ•´DApp](#8-å®Œæ•´dapp)
  - [8.1 Web3 DAppæ¶æ„](#81-web3-dappæ¶æ„)
- [9. Gasä¼˜åŒ–](#9-gasä¼˜åŒ–)
  - [9.1 Gasä¼˜åŒ–æŠ€å·§](#91-gasä¼˜åŒ–æŠ€å·§)
- [10. ç”Ÿäº§éƒ¨ç½²](#10-ç”Ÿäº§éƒ¨ç½²)
  - [10.1 Dockeréƒ¨ç½²](#101-dockeréƒ¨ç½²)
- [æ€»ç»“](#æ€»ç»“)
  - [âœ… æ ¸å¿ƒæˆæœ](#-æ ¸å¿ƒæˆæœ)
  - [ğŸŒŸ Go 1.25.3åº”ç”¨](#-go-1253åº”ç”¨)
  - [ğŸ“Š æ¶æ„äº®ç‚¹](#-æ¶æ„äº®ç‚¹)
  - [ğŸ¯ é€‚ç”¨åœºæ™¯](#-é€‚ç”¨åœºæ™¯)
- [ä¸‹ä¸€æ­¥å­¦ä¹ ](#ä¸‹ä¸€æ­¥å­¦ä¹ )

## ç›®å½•

- [Go 1.25.3åŒºå—é“¾ä¸Web3å®Œæ•´å®æˆ˜](#go-1253åŒºå—é“¾ä¸web3å®Œæ•´å®æˆ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. åŒºå—é“¾åŸºç¡€](#1-åŒºå—é“¾åŸºç¡€)
    - [1.1 åŒºå—é“¾æ ¸å¿ƒæ¦‚å¿µ](#11-åŒºå—é“¾æ ¸å¿ƒæ¦‚å¿µ)
  - [2. ä»¥å¤ªåŠå®¢æˆ·ç«¯](#2-ä»¥å¤ªåŠå®¢æˆ·ç«¯)
    - [2.1 è¿æ¥ä»¥å¤ªåŠèŠ‚ç‚¹](#21-è¿æ¥ä»¥å¤ªåŠèŠ‚ç‚¹)
    - [2.2 å‘é€äº¤æ˜“](#22-å‘é€äº¤æ˜“)
  - [3. æ™ºèƒ½åˆçº¦äº¤äº’](#3-æ™ºèƒ½åˆçº¦äº¤äº’)
    - [3.1 ERC-20ä»£å¸åˆçº¦](#31-erc-20ä»£å¸åˆçº¦)
    - [3.2 Goè°ƒç”¨ERC-20åˆçº¦](#32-goè°ƒç”¨erc-20åˆçº¦)
  - [4. DeFiåè®®](#4-defiåè®®)
    - [4.1 è‡ªåŠ¨åšå¸‚å•† (AMM)](#41-è‡ªåŠ¨åšå¸‚å•†-amm)
    - [4.2 Goå®ç°DEXäº¤äº’](#42-goå®ç°dexäº¤äº’)
  - [5. NFTé“¸é€ ä¸äº¤æ˜“](#5-nfté“¸é€ ä¸äº¤æ˜“)
    - [5.1 ERC-721 NFTåˆçº¦](#51-erc-721-nftåˆçº¦)
    - [5.2 Goå®ç°NFTé“¸é€ ](#52-goå®ç°nfté“¸é€ )
  - [6. IPFSåˆ†å¸ƒå¼å­˜å‚¨](#6-ipfsåˆ†å¸ƒå¼å­˜å‚¨)
    - [6.1 IPFSå­˜å‚¨NFTå…ƒæ•°æ®](#61-ipfså­˜å‚¨nftå…ƒæ•°æ®)
    - [6.2 å®Œæ•´NFTé“¸é€ æµç¨‹](#62-å®Œæ•´nfté“¸é€ æµç¨‹)
  - [7. The Graphæ•°æ®ç´¢å¼•](#7-the-graphæ•°æ®ç´¢å¼•)
    - [7.1 GraphæŸ¥è¯¢](#71-graphæŸ¥è¯¢)
    - [7.2 Goè°ƒç”¨The Graph](#72-goè°ƒç”¨the-graph)
  - [8. å®Œæ•´DApp](#8-å®Œæ•´dapp)
    - [8.1 Web3 DAppæ¶æ„](#81-web3-dappæ¶æ„)
  - [9. Gasä¼˜åŒ–](#9-gasä¼˜åŒ–)
    - [9.1 Gasä¼˜åŒ–æŠ€å·§](#91-gasä¼˜åŒ–æŠ€å·§)
  - [10. ç”Ÿäº§éƒ¨ç½²](#10-ç”Ÿäº§éƒ¨ç½²)
    - [10.1 Dockeréƒ¨ç½²](#101-dockeréƒ¨ç½²)
  - [æ€»ç»“](#æ€»ç»“)
    - [âœ… æ ¸å¿ƒæˆæœ](#-æ ¸å¿ƒæˆæœ)
    - [ğŸŒŸ Go 1.25.3åº”ç”¨](#-go-1253åº”ç”¨)
    - [ğŸ“Š æ¶æ„äº®ç‚¹](#-æ¶æ„äº®ç‚¹)
    - [ğŸ¯ é€‚ç”¨åœºæ™¯](#-é€‚ç”¨åœºæ™¯)
  - [ä¸‹ä¸€æ­¥å­¦ä¹ ](#ä¸‹ä¸€æ­¥å­¦ä¹ )

---

## 1. åŒºå—é“¾åŸºç¡€

### 1.1 åŒºå—é“¾æ ¸å¿ƒæ¦‚å¿µ

```go
package blockchain

import (
 "crypto/sha256"
 "encoding/hex"
 "fmt"
 "time"
)

// åŒºå—é“¾æ ¸å¿ƒæ¦‚å¿µ
/*
åŒºå—é“¾ (Blockchain):
  â€¢ åˆ†å¸ƒå¼è´¦æœ¬ (Distributed Ledger)
  â€¢ ä¸å¯ç¯¡æ”¹ (Immutable)
  â€¢ å»ä¸­å¿ƒåŒ– (Decentralized)
  â€¢ å…±è¯†æœºåˆ¶ (Consensus)

æ ¸å¿ƒç‰¹æ€§:
  âœ… æ•°æ®ä¸å¯ç¯¡æ”¹
  âœ… åˆ†å¸ƒå¼å­˜å‚¨
  âœ… æ™ºèƒ½åˆçº¦ (Smart Contract)
  âœ… æ— éœ€ä¿¡ä»» (Trustless)
  âœ… é€æ˜å¯è¿½æº¯

åŒºå—é“¾ç±»å‹:
  1. å…¬æœ‰é“¾ (Public): Bitcoin, Ethereum
  2. è”ç›Ÿé“¾ (Consortium): Hyperledger Fabric
  3. ç§æœ‰é“¾ (Private): Enterprise Blockchain

å…±è¯†ç®—æ³•:
  â€¢ PoW (Proof of Work) - Bitcoin
  â€¢ PoS (Proof of Stake) - Ethereum 2.0 âœ…
  â€¢ DPoS (Delegated PoS)
  â€¢ PBFT (Practical Byzantine Fault Tolerance)
*/

// Block åŒºå—ç»“æ„
type Block struct {
 Index        int64       `json:"index"`
 Timestamp    int64       `json:"timestamp"`
 PreviousHash string      `json:"previous_hash"`
 Hash         string      `json:"hash"`
 Nonce        int64       `json:"nonce"`
 Transactions []Transaction `json:"transactions"`
 MerkleRoot   string      `json:"merkle_root"`
}

// Transaction äº¤æ˜“
type Transaction struct {
 From      string  `json:"from"`
 To        string  `json:"to"`
 Value     float64 `json:"value"`
 Timestamp int64   `json:"timestamp"`
 Signature string  `json:"signature"`
}

// Blockchain åŒºå—é“¾
type Blockchain struct {
 Chain      []*Block
 Difficulty int // æŒ–çŸ¿éš¾åº¦
}

// NewBlockchain åˆ›å»ºåŒºå—é“¾
func NewBlockchain() *Blockchain {
 // åˆ›ä¸–åŒºå—
 genesis := &Block{
  Index:        0,
  Timestamp:    time.Now().Unix(),
  PreviousHash: "0",
  Transactions: []Transaction{},
 }
 genesis.Hash = calculateHash(genesis)

 return &Blockchain{
  Chain:      []*Block{genesis},
  Difficulty: 4, // å‰4ä½ä¸º0
 }
}

// AddBlock æ·»åŠ åŒºå—
func (bc *Blockchain) AddBlock(transactions []Transaction) {
 prevBlock := bc.Chain[len(bc.Chain)-1]

 newBlock := &Block{
  Index:        prevBlock.Index + 1,
  Timestamp:    time.Now().Unix(),
  PreviousHash: prevBlock.Hash,
  Transactions: transactions,
  MerkleRoot:   calculateMerkleRoot(transactions),
 }

 // PoWæŒ–çŸ¿
 bc.mineBlock(newBlock)

 bc.Chain = append(bc.Chain, newBlock)
 fmt.Printf("â›ï¸  åŒºå—æŒ–å‡º: #%d (hash: %s, nonce: %d)\n", 
  newBlock.Index, newBlock.Hash[:16], newBlock.Nonce)
}

// mineBlock æŒ–çŸ¿ (Proof of Work)
func (bc *Blockchain) mineBlock(block *Block) {
 target := "0000" // å‰4ä¸ª0 (difficulty=4)

 for {
  block.Hash = calculateHash(block)
  if block.Hash[:bc.Difficulty] == target {
   break
  }
  block.Nonce++
 }
}

// calculateHash è®¡ç®—å“ˆå¸Œ
func calculateHash(block *Block) string {
 record := fmt.Sprintf("%d%d%s%d%s",
  block.Index,
  block.Timestamp,
  block.PreviousHash,
  block.Nonce,
  block.MerkleRoot,
 )

 h := sha256.New()
 h.Write([]byte(record))
 return hex.EncodeToString(h.Sum(nil))
}

// calculateMerkleRoot è®¡ç®—Merkle Root
func calculateMerkleRoot(transactions []Transaction) string {
 if len(transactions) == 0 {
  return ""
 }

 var hashes []string
 for _, tx := range transactions {
  txData := fmt.Sprintf("%s%s%.8f%d", tx.From, tx.To, tx.Value, tx.Timestamp)
  h := sha256.Sum256([]byte(txData))
  hashes = append(hashes, hex.EncodeToString(h[:]))
 }

 // é€’å½’æ„å»ºMerkle Tree
 for len(hashes) > 1 {
  var newLevel []string
  for i := 0; i < len(hashes); i += 2 {
   if i+1 < len(hashes) {
    combined := hashes[i] + hashes[i+1]
    h := sha256.Sum256([]byte(combined))
    newLevel = append(newLevel, hex.EncodeToString(h[:]))
   } else {
    newLevel = append(newLevel, hashes[i])
   }
  }
  hashes = newLevel
 }

 return hashes[0]
}

// IsValid éªŒè¯åŒºå—é“¾
func (bc *Blockchain) IsValid() bool {
 for i := 1; i < len(bc.Chain); i++ {
  currentBlock := bc.Chain[i]
  prevBlock := bc.Chain[i-1]

  // éªŒè¯å“ˆå¸Œ
  if currentBlock.Hash != calculateHash(currentBlock) {
   return false
  }

  // éªŒè¯é“¾æ¥
  if currentBlock.PreviousHash != prevBlock.Hash {
   return false
  }

  // éªŒè¯PoW
  target := "0000"
  if currentBlock.Hash[:bc.Difficulty] != target {
   return false
  }
 }

 return true
}
```

---

## 2. ä»¥å¤ªåŠå®¢æˆ·ç«¯

### 2.1 è¿æ¥ä»¥å¤ªåŠèŠ‚ç‚¹

```go
package ethereum

import (
 "context"
 "fmt"
 "log"
 "math/big"

 "github.com/ethereum/go-ethereum/common"
 "github.com/ethereum/go-ethereum/core/types"
 "github.com/ethereum/go-ethereum/ethclient"
)

// go-ethereum (Geth) - å®˜æ–¹Goå®¢æˆ·ç«¯
/*
ä»¥å¤ªåŠç½‘ç»œ:
  â€¢ Mainnet: ä¸»ç½‘ (çœŸå®ETH)
  â€¢ Sepolia: æµ‹è¯•ç½‘ (å…è´¹æµ‹è¯•)
  â€¢ Goerli:  æµ‹è¯•ç½‘
  â€¢ Localhost: æœ¬åœ°èŠ‚ç‚¹ (Ganache, Hardhat)

è¿æ¥æ–¹å¼:
  â€¢ HTTP: http://localhost:8545
  â€¢ WebSocket: ws://localhost:8546
  â€¢ IPC: /var/run/geth.ipc
  â€¢ Infura: https://mainnet.infura.io/v3/YOUR_KEY
  â€¢ Alchemy: https://eth-mainnet.g.alchemy.com/v2/YOUR_KEY
*/

// EthereumClient ä»¥å¤ªåŠå®¢æˆ·ç«¯
type EthereumClient struct {
 client  *ethclient.Client
 chainID *big.Int
}

// NewEthereumClient åˆ›å»ºå®¢æˆ·ç«¯
func NewEthereumClient(rpcURL string) (*EthereumClient, error) {
 client, err := ethclient.Dial(rpcURL)
 if err != nil {
  return nil, fmt.Errorf("è¿æ¥å¤±è´¥: %w", err)
 }

 // è·å–Chain ID
 chainID, err := client.ChainID(context.Background())
 if err != nil {
  return nil, fmt.Errorf("è·å–Chain IDå¤±è´¥: %w", err)
 }

 log.Printf("âœ… è¿æ¥åˆ°ä»¥å¤ªåŠç½‘ç»œ (Chain ID: %s)", chainID.String())

 return &EthereumClient{
  client:  client,
  chainID: chainID,
 }, nil
}

// GetBlockNumber è·å–æœ€æ–°åŒºå—å·
func (ec *EthereumClient) GetBlockNumber(ctx context.Context) (uint64, error) {
 blockNumber, err := ec.client.BlockNumber(ctx)
 if err != nil {
  return 0, fmt.Errorf("è·å–åŒºå—å·å¤±è´¥: %w", err)
 }

 return blockNumber, nil
}

// GetBalance è·å–è´¦æˆ·ä½™é¢
func (ec *EthereumClient) GetBalance(ctx context.Context, address string) (*big.Int, error) {
 account := common.HexToAddress(address)
 balance, err := ec.client.BalanceAt(ctx, account, nil)
 if err != nil {
  return nil, fmt.Errorf("è·å–ä½™é¢å¤±è´¥: %w", err)
 }

 return balance, nil
}

// GetBlock è·å–åŒºå—ä¿¡æ¯
func (ec *EthereumClient) GetBlock(ctx context.Context, blockNumber *big.Int) (*types.Block, error) {
 block, err := ec.client.BlockByNumber(ctx, blockNumber)
 if err != nil {
  return nil, fmt.Errorf("è·å–åŒºå—å¤±è´¥: %w", err)
 }

 return block, nil
}

// GetTransaction è·å–äº¤æ˜“ä¿¡æ¯
func (ec *EthereumClient) GetTransaction(ctx context.Context, txHash string) (*types.Transaction, bool, error) {
 hash := common.HexToHash(txHash)
 tx, isPending, err := ec.client.TransactionByHash(ctx, hash)
 if err != nil {
  return nil, false, fmt.Errorf("è·å–äº¤æ˜“å¤±è´¥: %w", err)
 }

 return tx, isPending, nil
}

// GetTransactionReceipt è·å–äº¤æ˜“æ”¶æ®
func (ec *EthereumClient) GetTransactionReceipt(ctx context.Context, txHash string) (*types.Receipt, error) {
 hash := common.HexToHash(txHash)
 receipt, err := ec.client.TransactionReceipt(ctx, hash)
 if err != nil {
  return nil, fmt.Errorf("è·å–æ”¶æ®å¤±è´¥: %w", err)
 }

 return receipt, nil
}

// SubscribeNewBlocks è®¢é˜…æ–°åŒºå—
func (ec *EthereumClient) SubscribeNewBlocks(ctx context.Context) (<-chan *types.Header, error) {
 headers := make(chan *types.Header)

 sub, err := ec.client.SubscribeNewHead(ctx, headers)
 if err != nil {
  return nil, fmt.Errorf("è®¢é˜…å¤±è´¥: %w", err)
 }

 go func() {
  defer close(headers)
  for {
   select {
   case err := <-sub.Err():
    log.Printf("âŒ è®¢é˜…é”™è¯¯: %v", err)
    return
   case <-ctx.Done():
    sub.Unsubscribe()
    return
   }
  }
 }()

 log.Println("ğŸ“¡ å·²è®¢é˜…æ–°åŒºå—")
 return headers, nil
}

// Close å…³é—­å®¢æˆ·ç«¯
func (ec *EthereumClient) Close() {
 ec.client.Close()
}
```

### 2.2 å‘é€äº¤æ˜“

```go
package ethereum

import (
 "context"
 "crypto/ecdsa"
 "fmt"
 "math/big"

 "github.com/ethereum/go-ethereum/common"
 "github.com/ethereum/go-ethereum/core/types"
 "github.com/ethereum/go-ethereum/crypto"
)

// SendETH å‘é€ETH
func (ec *EthereumClient) SendETH(ctx context.Context, privateKeyHex, toAddress string, amount *big.Int) (string, error) {
 // è§£æç§é’¥
 privateKey, err := crypto.HexToECDSA(privateKeyHex)
 if err != nil {
  return "", fmt.Errorf("è§£æç§é’¥å¤±è´¥: %w", err)
 }

 // è·å–å‘é€æ–¹åœ°å€
 publicKey := privateKey.Public()
 publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
 if !ok {
  return "", fmt.Errorf("æ— æ³•è½¬æ¢å…¬é’¥")
 }
 fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA)

 // è·å–nonce
 nonce, err := ec.client.PendingNonceAt(ctx, fromAddress)
 if err != nil {
  return "", fmt.Errorf("è·å–nonceå¤±è´¥: %w", err)
 }

 // è·å–Gas Price
 gasPrice, err := ec.client.SuggestGasPrice(ctx)
 if err != nil {
  return "", fmt.Errorf("è·å–Gas Priceå¤±è´¥: %w", err)
 }

 // æ„é€ äº¤æ˜“
 toAddr := common.HexToAddress(toAddress)
 tx := types.NewTransaction(
  nonce,
  toAddr,
  amount,
  21000, // Gas limit for ETH transfer
  gasPrice,
  nil,
 )

 // ç­¾åäº¤æ˜“
 signedTx, err := types.SignTx(tx, types.NewEIP155Signer(ec.chainID), privateKey)
 if err != nil {
  return "", fmt.Errorf("ç­¾åå¤±è´¥: %w", err)
 }

 // å‘é€äº¤æ˜“
 err = ec.client.SendTransaction(ctx, signedTx)
 if err != nil {
  return "", fmt.Errorf("å‘é€äº¤æ˜“å¤±è´¥: %w", err)
 }

 txHash := signedTx.Hash().Hex()
 log.Printf("âœ… äº¤æ˜“å·²å‘é€: %s", txHash)

 return txHash, nil
}

// WaitMined ç­‰å¾…äº¤æ˜“ç¡®è®¤
func (ec *EthereumClient) WaitMined(ctx context.Context, txHash string) (*types.Receipt, error) {
 hash := common.HexToHash(txHash)

 // ç­‰å¾…äº¤æ˜“è¢«æ‰“åŒ…
 receipt, err := bind.WaitMined(ctx, ec.client, &types.Transaction{})
 if err != nil {
  return nil, fmt.Errorf("ç­‰å¾…ç¡®è®¤å¤±è´¥: %w", err)
 }

 if receipt.Status == 1 {
  log.Printf("âœ… äº¤æ˜“æˆåŠŸ: %s (block: %d, gas: %d)", 
   txHash, receipt.BlockNumber.Uint64(), receipt.GasUsed)
 } else {
  log.Printf("âŒ äº¤æ˜“å¤±è´¥: %s", txHash)
 }

 return receipt, nil
}
```

---

## 3. æ™ºèƒ½åˆçº¦äº¤äº’

### 3.1 ERC-20ä»£å¸åˆçº¦

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// ERC-20æ ‡å‡†ä»£å¸åˆçº¦
contract MyToken {
    string public name = "MyToken";
    string public symbol = "MTK";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 _initialSupply) {
        totalSupply = _initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, "Insufficient balance");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], "Insufficient balance");
        require(_value <= allowance[_from][msg.sender], "Allowance exceeded");
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }
}
```

### 3.2 Goè°ƒç”¨ERC-20åˆçº¦

```go
package contracts

import (
 "context"
 "fmt"
 "log"
 "math/big"

 "github.com/ethereum/go-ethereum/accounts/abi/bind"
 "github.com/ethereum/go-ethereum/common"
 "github.com/ethereum/go-ethereum/crypto"
)

// ä½¿ç”¨abigenç”ŸæˆGoç»‘å®š
/*
æ­¥éª¤:
1. ç¼–è¯‘åˆçº¦ç”ŸæˆABIå’ŒBytecode
   solc --abi --bin MyToken.sol -o build/

2. ç”ŸæˆGoç»‘å®š
   abigen --abi=build/MyToken.abi --bin=build/MyToken.bin --pkg=contracts --out=MyToken.go

3. åœ¨Goä¸­ä½¿ç”¨
   import "./contracts"
*/

// ERC20Token ERC-20ä»£å¸å®¢æˆ·ç«¯
type ERC20Token struct {
 client   *ethclient.Client
 contract *MyToken // è‡ªåŠ¨ç”Ÿæˆçš„åˆçº¦ç»‘å®š
 address  common.Address
}

// NewERC20Token åˆ›å»ºERC-20å®¢æˆ·ç«¯
func NewERC20Token(client *ethclient.Client, contractAddress string) (*ERC20Token, error) {
 address := common.HexToAddress(contractAddress)

 // åŠ è½½åˆçº¦å®ä¾‹
 contract, err := NewMyToken(address, client)
 if err != nil {
  return nil, fmt.Errorf("åŠ è½½åˆçº¦å¤±è´¥: %w", err)
 }

 return &ERC20Token{
  client:   client,
  contract: contract,
  address:  address,
 }, nil
}

// GetBalance è·å–ä»£å¸ä½™é¢
func (t *ERC20Token) GetBalance(ctx context.Context, address string) (*big.Int, error) {
 addr := common.HexToAddress(address)
 balance, err := t.contract.BalanceOf(&bind.CallOpts{Context: ctx}, addr)
 if err != nil {
  return nil, fmt.Errorf("è·å–ä½™é¢å¤±è´¥: %w", err)
 }

 return balance, nil
}

// Transfer è½¬è´¦ä»£å¸
func (t *ERC20Token) Transfer(ctx context.Context, privateKeyHex, toAddress string, amount *big.Int) (string, error) {
 // è§£æç§é’¥
 privateKey, err := crypto.HexToECDSA(privateKeyHex)
 if err != nil {
  return "", fmt.Errorf("è§£æç§é’¥å¤±è´¥: %w", err)
 }

 // è·å–å‘é€æ–¹åœ°å€
 publicKey := privateKey.Public().(*ecdsa.PublicKey)
 fromAddress := crypto.PubkeyToAddress(*publicKey)

 // è·å–nonce
 nonce, err := t.client.PendingNonceAt(ctx, fromAddress)
 if err != nil {
  return "", fmt.Errorf("è·å–nonceå¤±è´¥: %w", err)
 }

 // è·å–Gas Price
 gasPrice, err := t.client.SuggestGasPrice(ctx)
 if err != nil {
  return "", fmt.Errorf("è·å–Gas Priceå¤±è´¥: %w", err)
 }

 // è·å–Chain ID
 chainID, err := t.client.ChainID(ctx)
 if err != nil {
  return "", fmt.Errorf("è·å–Chain IDå¤±è´¥: %w", err)
 }

 // æ„é€ äº¤æ˜“é€‰é¡¹
 auth, err := bind.NewKeyedTransactorWithChainID(privateKey, chainID)
 if err != nil {
  return "", fmt.Errorf("åˆ›å»ºäº¤æ˜“å™¨å¤±è´¥: %w", err)
 }

 auth.Nonce = big.NewInt(int64(nonce))
 auth.Value = big.NewInt(0)      // ä¸å‘é€ETH
 auth.GasLimit = uint64(100000)  // Gasé™åˆ¶
 auth.GasPrice = gasPrice

 // è°ƒç”¨åˆçº¦æ–¹æ³•
 to := common.HexToAddress(toAddress)
 tx, err := t.contract.Transfer(auth, to, amount)
 if err != nil {
  return "", fmt.Errorf("è½¬è´¦å¤±è´¥: %w", err)
 }

 txHash := tx.Hash().Hex()
 log.Printf("âœ… ä»£å¸è½¬è´¦äº¤æ˜“å·²å‘é€: %s", txHash)

 return txHash, nil
}

// Approve æˆæƒä»£å¸
func (t *ERC20Token) Approve(ctx context.Context, privateKeyHex, spenderAddress string, amount *big.Int) (string, error) {
 privateKey, err := crypto.HexToECDSA(privateKeyHex)
 if err != nil {
  return "", err
 }

 chainID, _ := t.client.ChainID(ctx)
 auth, _ := bind.NewKeyedTransactorWithChainID(privateKey, chainID)

 spender := common.HexToAddress(spenderAddress)
 tx, err := t.contract.Approve(auth, spender, amount)
 if err != nil {
  return "", fmt.Errorf("æˆæƒå¤±è´¥: %w", err)
 }

 return tx.Hash().Hex(), nil
}

// TotalSupply è·å–æ€»ä¾›åº”é‡
func (t *ERC20Token) TotalSupply(ctx context.Context) (*big.Int, error) {
 supply, err := t.contract.TotalSupply(&bind.CallOpts{Context: ctx})
 if err != nil {
  return nil, fmt.Errorf("è·å–æ€»ä¾›åº”é‡å¤±è´¥: %w", err)
 }

 return supply, nil
}
```

---

## 4. DeFiåè®®

### 4.1 è‡ªåŠ¨åšå¸‚å•† (AMM)

```solidity
// SimpleSwap - ç®€åŒ–ç‰ˆUniswap V2
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract SimpleSwap {
    IERC20 public tokenA;
    IERC20 public tokenB;

    uint256 public reserveA;
    uint256 public reserveB;

    uint256 public totalLiquidity;
    mapping(address => uint256) public liquidity;

    constructor(address _tokenA, address _tokenB) {
        tokenA = IERC20(_tokenA);
        tokenB = IERC20(_tokenB);
    }

    // æ·»åŠ æµåŠ¨æ€§
    function addLiquid ity(uint256 amountA, uint256 amountB) external returns (uint256) {
        require(amountA > 0 && amountB > 0, "Invalid amounts");

        tokenA.transferFrom(msg.sender, address(this), amountA);
        tokenB.transferFrom(msg.sender, address(this), amountB);

        uint256 liquidityMinted;

        if (totalLiquidity == 0) {
            liquidityMinted = sqrt(amountA * amountB);
        } else {
            liquidityMinted = min(
                (amountA * totalLiquidity) / reserveA,
                (amountB * totalLiquidity) / reserveB
            );
        }

        liquidity[msg.sender] += liquidityMinted;
        totalLiquidity += liquidityMinted;

        reserveA += amountA;
        reserveB += amountB;

        return liquidityMinted;
    }

    // ç§»é™¤æµåŠ¨æ€§
    function removeLiquidity(uint256 liquidityAmount) external returns (uint256, uint256) {
        require(liquidityAmount > 0, "Invalid amount");
        require(liquidity[msg.sender] >= liquidityAmount, "Insufficient liquidity");

        uint256 amountA = (liquidityAmount * reserveA) / totalLiquidity;
        uint256 amountB = (liquidityAmount * reserveB) / totalLiquidity;

        liquidity[msg.sender] -= liquidityAmount;
        totalLiquidity -= liquidityAmount;

        reserveA -= amountA;
        reserveB -= amountB;

        tokenA.transfer(msg.sender, amountA);
        tokenB.transfer(msg.sender, amountB);

        return (amountA, amountB);
    }

    // äº¤æ¢ A -> B
    function swapAToB(uint256 amountAIn) external returns (uint256) {
        require(amountAIn > 0, "Invalid amount");

        // Constant Product Formula: x * y = k
        uint256 amountBOut = getAmountOut(amountAIn, reserveA, reserveB);

        tokenA.transferFrom(msg.sender, address(this), amountAIn);
        tokenB.transfer(msg.sender, amountBOut);

        reserveA += amountAIn;
        reserveB -= amountBOut;

        return amountBOut;
    }

    // äº¤æ¢ B -> A
    function swapBToA(uint256 amountBIn) external returns (uint256) {
        require(amountBIn > 0, "Invalid amount");

        uint256 amountAOut = getAmountOut(amountBIn, reserveB, reserveA);

        tokenB.transferFrom(msg.sender, address(this), amountBIn);
        tokenA.transfer(msg.sender, amountAOut);

        reserveA -= amountAOut;
        reserveB += amountBIn;

        return amountAOut;
    }

    // è®¡ç®—è¾“å‡ºæ•°é‡ (0.3%æ‰‹ç»­è´¹)
    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) 
        public 
        pure 
        returns (uint256) 
    {
        require(amountIn > 0, "Invalid input amount");
        require(reserveIn > 0 && reserveOut > 0, "Insufficient liquidity");

        uint256 amountInWithFee = amountIn * 997; // 0.3% fee
        uint256 numerator = amountInWithFee * reserveOut;
        uint256 denominator = (reserveIn * 1000) + amountInWithFee;

        return numerator / denominator;
    }

    // è¾…åŠ©å‡½æ•°
    function sqrt(uint256 y) internal pure returns (uint256 z) {
        if (y > 3) {
            z = y;
            uint256 x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }

    function min(uint256 x, uint256 y) internal pure returns (uint256) {
        return x < y ? x : y;
    }
}
```

### 4.2 Goå®ç°DEXäº¤äº’

```go
package defi

import (
 "context"
 "fmt"
 "log"
 "math/big"
)

// DEXClient DEXå®¢æˆ·ç«¯
type DEXClient struct {
 client   *ethclient.Client
 contract *SimpleSwap // è‡ªåŠ¨ç”Ÿæˆçš„åˆçº¦ç»‘å®š
 tokenA   *ERC20Token
 tokenB   *ERC20Token
}

// NewDEXClient åˆ›å»ºDEXå®¢æˆ·ç«¯
func NewDEXClient(
 client *ethclient.Client,
 dexAddress, tokenAAddress, tokenBAddress string,
) (*DEXClient, error) {
 // åŠ è½½DEXåˆçº¦
 dexAddr := common.HexToAddress(dexAddress)
 dexContract, err := NewSimpleSwap(dexAddr, client)
 if err != nil {
  return nil, err
 }

 // åŠ è½½Tokenåˆçº¦
 tokenA, err := NewERC20Token(client, tokenAAddress)
 if err != nil {
  return nil, err
 }

 tokenB, err := NewERC20Token(client, tokenBAddress)
 if err != nil {
  return nil, err
 }

 return &DEXClient{
  client:   client,
  contract: dexContract,
  tokenA:   tokenA,
  tokenB:   tokenB,
 }, nil
}

// AddLiquidity æ·»åŠ æµåŠ¨æ€§
func (d *DEXClient) AddLiquidity(
 ctx context.Context,
 privateKeyHex string,
 amountA, amountB *big.Int,
) (string, error) {
 privateKey, err := crypto.HexToECDSA(privateKeyHex)
 if err != nil {
  return "", err
 }

 publicKey := privateKey.Public().(*ecdsa.PublicKey)
 fromAddress := crypto.PubkeyToAddress(*publicKey)

 // 1. æˆæƒToken A
 log.Println("ğŸ“ æˆæƒToken A...")
 txHashA, err := d.tokenA.Approve(ctx, privateKeyHex, d.contract.address.Hex(), amountA)
 if err != nil {
  return "", fmt.Errorf("æˆæƒToken Aå¤±è´¥: %w", err)
 }
 log.Printf("âœ… Token Aæˆæƒäº¤æ˜“: %s", txHashA)

 // 2. æˆæƒToken B
 log.Println("ğŸ“ æˆæƒToken B...")
 txHashB, err := d.tokenB.Approve(ctx, privateKeyHex, d.contract.address.Hex(), amountB)
 if err != nil {
  return "", fmt.Errorf("æˆæƒToken Bå¤±è´¥: %w", err)
 }
 log.Printf("âœ… Token Bæˆæƒäº¤æ˜“: %s", txHashB)

 // 3. æ·»åŠ æµåŠ¨æ€§
 chainID, _ := d.client.ChainID(ctx)
 auth, _ := bind.NewKeyedTransactorWithChainID(privateKey, chainID)

 tx, err := d.contract.AddLiquidity(auth, amountA, amountB)
 if err != nil {
  return "", fmt.Errorf("æ·»åŠ æµåŠ¨æ€§å¤±è´¥: %w", err)
 }

 txHash := tx.Hash().Hex()
 log.Printf("ğŸ’§ æ·»åŠ æµåŠ¨æ€§äº¤æ˜“å·²å‘é€: %s", txHash)

 return txHash, nil
}

// Swap äº¤æ¢ä»£å¸
func (d *DEXClient) Swap(
 ctx context.Context,
 privateKeyHex string,
 fromToken string,
 amountIn *big.Int,
) (string, *big.Int, error) {
 privateKey, err := crypto.HexToECDSA(privateKeyHex)
 if err != nil {
  return "", nil, err
 }

 chainID, _ := d.client.ChainID(ctx)
 auth, _ := bind.NewKeyedTransactorWithChainID(privateKey, chainID)

 var tx *types.Transaction

 if fromToken == "A" {
  // æˆæƒToken A
  d.tokenA.Approve(ctx, privateKeyHex, d.contract.address.Hex(), amountIn)

  // äº¤æ¢ A -> B
  tx, err = d.contract.SwapAToB(auth, amountIn)
 } else {
  // æˆæƒToken B
  d.tokenB.Approve(ctx, privateKeyHex, d.contract.address.Hex(), amountIn)

  // äº¤æ¢ B -> A
  tx, err = d.contract.SwapBToA(auth, amountIn)
 }

 if err != nil {
  return "", nil, fmt.Errorf("äº¤æ¢å¤±è´¥: %w", err)
 }

 txHash := tx.Hash().Hex()
 log.Printf("ğŸ”„ äº¤æ¢äº¤æ˜“å·²å‘é€: %s", txHash)

 // ç­‰å¾…äº¤æ˜“ç¡®è®¤å¹¶è·å–è¾“å‡ºæ•°é‡
 receipt, err := bind.WaitMined(ctx, d.client, tx)
 if err != nil {
  return "", nil, err
 }

 // è§£æäº‹ä»¶æ—¥å¿—è·å–å®é™…è¾“å‡ºé‡
 // (ç®€åŒ–ç¤ºä¾‹ï¼Œå®é™…éœ€è¦è§£æäº‹ä»¶)
 amountOut := big.NewInt(0)

 return txHash, amountOut, nil
}

// GetReserves è·å–æµåŠ¨æ€§å‚¨å¤‡
func (d *DEXClient) GetReserves(ctx context.Context) (*big.Int, *big.Int, error) {
 reserveA, err := d.contract.ReserveA(&bind.CallOpts{Context: ctx})
 if err != nil {
  return nil, nil, err
 }

 reserveB, err := d.contract.ReserveB(&bind.CallOpts{Context: ctx})
 if err != nil {
  return nil, nil, err
 }

 return reserveA, reserveB, nil
}
```

---

## 5. NFTé“¸é€ ä¸äº¤æ˜“

### 5.1 ERC-721 NFTåˆçº¦

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract MyNFT is ERC721, ERC721URIStorage, Ownable {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    constructor() ERC721("MyNFT", "MNFT") {}

    // é“¸é€ NFT
    function mintNFT(address recipient, string memory tokenURI) 
        public 
        onlyOwner 
        returns (uint256) 
    {
        _tokenIds.increment();
        uint256 newTokenId = _tokenIds.current();

        _safeMint(recipient, newTokenId);
        _setTokenURI(newTokenId, tokenURI);

        return newTokenId;
    }

    // æ‰¹é‡é“¸é€ 
    function batchMint(address recipient, string[] memory tokenURIs) 
        public 
        onlyOwner 
        returns (uint256[] memory) 
    {
        uint256[] memory tokenIds = new uint256[](tokenURIs.length);

        for (uint256 i = 0; i < tokenURIs.length; i++) {
            _tokenIds.increment();
            uint256 newTokenId = _tokenIds.current();

            _safeMint(recipient, newTokenId);
            _setTokenURI(newTokenId, tokenURIs[i]);

            tokenIds[i] = newTokenId;
        }

        return tokenIds;
    }

    // é”€æ¯NFT
    function burn(uint256 tokenId) public {
        require(ownerOf(tokenId) == msg.sender, "Not the owner");
        _burn(tokenId);
    }

    // å¿…è¦çš„Override
    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
    }

    function tokenURI(uint256 tokenId) 
        public 
        view 
        override(ERC721, ERC721URIStorage) 
        returns (string memory) 
    {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(bytes4 interfaceId) 
        public 
        view 
        override(ERC721, ERC721URIStorage) 
        returns (bool) 
    {
        return super.supportsInterface(interfaceId);
    }
}
```

### 5.2 Goå®ç°NFTé“¸é€ 

```go
package nft

import (
 "context"
 "fmt"
 "log"
 "math/big"
)

// NFTClient NFTå®¢æˆ·ç«¯
type NFTClient struct {
 client   *ethclient.Client
 contract *MyNFT // è‡ªåŠ¨ç”Ÿæˆçš„åˆçº¦ç»‘å®š
 address  common.Address
}

// NewNFTClient åˆ›å»ºNFTå®¢æˆ·ç«¯
func NewNFTClient(client *ethclient.Client, contractAddress string) (*NFTClient, error) {
 address := common.HexToAddress(contractAddress)

 contract, err := NewMyNFT(address, client)
 if err != nil {
  return nil, fmt.Errorf("åŠ è½½åˆçº¦å¤±è´¥: %w", err)
 }

 return &NFTClient{
  client:   client,
  contract: contract,
  address:  address,
 }, nil
}

// MintNFT é“¸é€ NFT
func (n *NFTClient) MintNFT(
 ctx context.Context,
 privateKeyHex, recipient, tokenURI string,
) (string, *big.Int, error) {
 privateKey, err := crypto.HexToECDSA(privateKeyHex)
 if err != nil {
  return "", nil, err
 }

 chainID, _ := n.client.ChainID(ctx)
 auth, _ := bind.NewKeyedTransactorWithChainID(privateKey, chainID)

 recipientAddr := common.HexToAddress(recipient)

 // è°ƒç”¨mintNFT
 tx, err := n.contract.MintNFT(auth, recipientAddr, tokenURI)
 if err != nil {
  return "", nil, fmt.Errorf("é“¸é€ å¤±è´¥: %w", err)
 }

 txHash := tx.Hash().Hex()
 log.Printf("ğŸ¨ NFTé“¸é€ äº¤æ˜“å·²å‘é€: %s", txHash)

 // ç­‰å¾…ç¡®è®¤
 receipt, err := bind.WaitMined(ctx, n.client, tx)
 if err != nil {
  return "", nil, err
 }

 // è§£æäº‹ä»¶è·å–Token ID
 // (ç®€åŒ–ç¤ºä¾‹ï¼Œå®é™…éœ€è¦è§£æTransferäº‹ä»¶)
 tokenID := big.NewInt(1)

 log.Printf("âœ… NFTé“¸é€ æˆåŠŸ: Token ID=%s", tokenID.String())

 return txHash, tokenID, nil
}

// GetTokenURI è·å–Token URI
func (n *NFTClient) GetTokenURI(ctx context.Context, tokenID *big.Int) (string, error) {
 uri, err := n.contract.TokenURI(&bind.CallOpts{Context: ctx}, tokenID)
 if err != nil {
  return "", fmt.Errorf("è·å–URIå¤±è´¥: %w", err)
 }

 return uri, nil
}

// GetOwner è·å–NFTæ‹¥æœ‰è€…
func (n *NFTClient) GetOwner(ctx context.Context, tokenID *big.Int) (string, error) {
 owner, err := n.contract.OwnerOf(&bind.CallOpts{Context: ctx}, tokenID)
 if err != nil {
  return "", fmt.Errorf("è·å–æ‹¥æœ‰è€…å¤±è´¥: %w", err)
 }

 return owner.Hex(), nil
}

// TransferNFT è½¬ç§»NFT
func (n *NFTClient) TransferNFT(
 ctx context.Context,
 privateKeyHex, toAddress string,
 tokenID *big.Int,
) (string, error) {
 privateKey, err := crypto.HexToECDSA(privateKeyHex)
 if err != nil {
  return "", err
 }

 publicKey := privateKey.Public().(*ecdsa.PublicKey)
 fromAddress := crypto.PubkeyToAddress(*publicKey)

 chainID, _ := n.client.ChainID(ctx)
 auth, _ := bind.NewKeyedTransactorWithChainID(privateKey, chainID)

 toAddr := common.HexToAddress(toAddress)

 // è°ƒç”¨transferFrom
 tx, err := n.contract.TransferFrom(auth, fromAddress, toAddr, tokenID)
 if err != nil {
  return "", fmt.Errorf("è½¬ç§»å¤±è´¥: %w", err)
 }

 txHash := tx.Hash().Hex()
 log.Printf("ğŸ“¤ NFTè½¬ç§»äº¤æ˜“å·²å‘é€: %s", txHash)

 return txHash, nil
}
```

---

## 6. IPFSåˆ†å¸ƒå¼å­˜å‚¨

### 6.1 IPFSå­˜å‚¨NFTå…ƒæ•°æ®

```go
package ipfs

import (
 "bytes"
 "context"
 "encoding/json"
 "fmt"
 "io"

 shell "github.com/ipfs/go-ipfs-api"
)

// IPFSåˆ†å¸ƒå¼å­˜å‚¨
/*
IPFS (InterPlanetary File System):
  â€¢ å†…å®¹å¯»å€ (CID - Content Identifier)
  â€¢ å»ä¸­å¿ƒåŒ–å­˜å‚¨
  â€¢ ä¸å¯ç¯¡æ”¹
  â€¢ P2Pç½‘ç»œ

NFTå…ƒæ•°æ®å­˜å‚¨:
  1. ä¸Šä¼ å›¾ç‰‡ â†’ IPFS CID
  2. æ„é€ å…ƒæ•°æ®JSON â†’ åŒ…å«å›¾ç‰‡CID
  3. ä¸Šä¼ å…ƒæ•°æ® â†’ IPFS CID
  4. é“¸é€ NFT â†’ tokenURI = ipfs://CID

IPFSç½‘å…³:
  â€¢ æœ¬åœ°èŠ‚ç‚¹: http://localhost:8080/ipfs/{cid}
  â€¢ Infura: https://infura-ipfs.io/ipfs/{cid}
  â€¢ Pinata: https://gateway.pinata.cloud/ipfs/{cid}
*/

// IPFSClient IPFSå®¢æˆ·ç«¯
type IPFSClient struct {
 shell *shell.Shell
}

// NewIPFSClient åˆ›å»ºIPFSå®¢æˆ·ç«¯
func NewIPFSClient(apiURL string) *IPFSClient {
 return &IPFSClient{
  shell: shell.NewShell(apiURL),
 }
}

// NFTMetadata NFTå…ƒæ•°æ®
type NFTMetadata struct {
 Name        string            `json:"name"`
 Description string            `json:"description"`
 Image       string            `json:"image"`        // ipfs://...
 ExternalURL string            `json:"external_url"` 
 Attributes  []NFTAttribute    `json:"attributes"`
}

// NFTAttribute NFTå±æ€§
type NFTAttribute struct {
 TraitType string      `json:"trait_type"`
 Value     interface{} `json:"value"`
}

// UploadFile ä¸Šä¼ æ–‡ä»¶åˆ°IPFS
func (ic *IPFSClient) UploadFile(ctx context.Context, data []byte) (string, error) {
 reader := bytes.NewReader(data)

 cid, err := ic.shell.Add(reader)
 if err != nil {
  return "", fmt.Errorf("ä¸Šä¼ å¤±è´¥: %w", err)
 }

 log.Printf("ğŸ“¤ æ–‡ä»¶å·²ä¸Šä¼ åˆ°IPFS: %s", cid)
 return cid, nil
}

// UploadNFTMetadata ä¸Šä¼ NFTå…ƒæ•°æ®
func (ic *IPFSClient) UploadNFTMetadata(ctx context.Context, metadata NFTMetadata) (string, error) {
 // åºåˆ—åŒ–ä¸ºJSON
 jsonData, err := json.MarshalIndent(metadata, "", "  ")
 if err != nil {
  return "", fmt.Errorf("åºåˆ—åŒ–å¤±è´¥: %w", err)
 }

 // ä¸Šä¼ åˆ°IPFS
 cid, err := ic.UploadFile(ctx, jsonData)
 if err != nil {
  return "", err
 }

 log.Printf("ğŸ“ å…ƒæ•°æ®å·²ä¸Šä¼ : %s", cid)
 return cid, nil
}

// GetFile ä»IPFSè·å–æ–‡ä»¶
func (ic *IPFSClient) GetFile(ctx context.Context, cid string) ([]byte, error) {
 reader, err := ic.shell.Cat(cid)
 if err != nil {
  return nil, fmt.Errorf("è¯»å–å¤±è´¥: %w", err)
 }
 defer reader.Close()

 data, err := io.ReadAll(reader)
 if err != nil {
  return nil, fmt.Errorf("è¯»å–å¤±è´¥: %w", err)
 }

 return data, nil
}

// GetNFTMetadata è·å–NFTå…ƒæ•°æ®
func (ic *IPFSClient) GetNFTMetadata(ctx context.Context, cid string) (*NFTMetadata, error) {
 data, err := ic.GetFile(ctx, cid)
 if err != nil {
  return nil, err
 }

 var metadata NFTMetadata
 if err := json.Unmarshal(data, &metadata); err != nil {
  return nil, fmt.Errorf("è§£æå¤±è´¥: %w", err)
 }

 return &metadata, nil
}

// PinFile å›ºå®šæ–‡ä»¶ (é˜²æ­¢åƒåœ¾å›æ”¶)
func (ic *IPFSClient) PinFile(ctx context.Context, cid string) error {
 err := ic.shell.Pin(cid)
 if err != nil {
  return fmt.Errorf("å›ºå®šå¤±è´¥: %w", err)
 }

 log.Printf("ğŸ“Œ æ–‡ä»¶å·²å›ºå®š: %s", cid)
 return nil
}

// UnpinFile å–æ¶ˆå›ºå®š
func (ic *IPFSClient) UnpinFile(ctx context.Context, cid string) error {
 err := ic.shell.Unpin(cid)
 if err != nil {
  return fmt.Errorf("å–æ¶ˆå›ºå®šå¤±è´¥: %w", err)
 }

 return nil
}
```

### 6.2 å®Œæ•´NFTé“¸é€ æµç¨‹

```go
package main

import (
 "context"
 "fmt"
 "log"
 "os"
)

// MintNFTWithIPFS ä½¿ç”¨IPFSé“¸é€ NFT
func MintNFTWithIPFS(
 ipfsClient *IPFSClient,
 nftClient *NFTClient,
 privateKey, recipient string,
 imagePath string,
) error {
 ctx := context.Background()

 // 1. ä¸Šä¼ å›¾ç‰‡åˆ°IPFS
 log.Println("ğŸ“¸ ä¸Šä¼ å›¾ç‰‡åˆ°IPFS...")
 imageData, err := os.ReadFile(imagePath)
 if err != nil {
  return fmt.Errorf("è¯»å–å›¾ç‰‡å¤±è´¥: %w", err)
 }

 imageCID, err := ipfsClient.UploadFile(ctx, imageData)
 if err != nil {
  return err
 }

 imageURI := fmt.Sprintf("ipfs://%s", imageCID)
 log.Printf("âœ… å›¾ç‰‡URI: %s", imageURI)

 // 2. æ„é€ å…ƒæ•°æ®
 metadata := NFTMetadata{
  Name:        "Awesome NFT #1",
  Description: "This is an awesome NFT",
  Image:       imageURI,
  ExternalURL: "https://example.com",
  Attributes: []NFTAttribute{
   {TraitType: "Rarity", Value: "Legendary"},
   {TraitType: "Level", Value: 10},
  },
 }

 // 3. ä¸Šä¼ å…ƒæ•°æ®åˆ°IPFS
 log.Println("ğŸ“ ä¸Šä¼ å…ƒæ•°æ®åˆ°IPFS...")
 metadataCID, err := ipfsClient.UploadNFTMetadata(ctx, metadata)
 if err != nil {
  return err
 }

 tokenURI := fmt.Sprintf("ipfs://%s", metadataCID)
 log.Printf("âœ… å…ƒæ•°æ®URI: %s", tokenURI)

 // 4. å›ºå®šæ–‡ä»¶
 ipfsClient.PinFile(ctx, imageCID)
 ipfsClient.PinFile(ctx, metadataCID)

 // 5. é“¸é€ NFT
 log.Println("ğŸ¨ é“¸é€ NFT...")
 txHash, tokenID, err := nftClient.MintNFT(ctx, privateKey, recipient, tokenURI)
 if err != nil {
  return err
 }

 log.Printf("âœ… NFTé“¸é€ æˆåŠŸ!")
 log.Printf("   Transaction: %s", txHash)
 log.Printf("   Token ID: %s", tokenID.String())
 log.Printf("   Token URI: %s", tokenURI)

 return nil
}
```

---

## 7. The Graphæ•°æ®ç´¢å¼•

### 7.1 GraphæŸ¥è¯¢

```graphql
# GraphQLæŸ¥è¯¢ç¤ºä¾‹

# æŸ¥è¯¢æ‰€æœ‰NFTè½¬ç§»äº‹ä»¶
query GetNFTTransfers {
  transfers(first: 100, orderBy: timestamp, orderDirection: desc) {
    id
    from
    to
    tokenId
    timestamp
    blockNumber
    transactionHash
  }
}

# æŸ¥è¯¢ç‰¹å®šç”¨æˆ·çš„NFT
query GetUserNFTs($owner: Bytes!) {
  tokens(where: { owner: $owner }) {
    id
    tokenId
    tokenURI
    owner
    mintedAt
  }
}

# æŸ¥è¯¢DEXäº¤æ˜“
query GetSwaps {
  swaps(first: 50, orderBy: timestamp, orderDirection: desc) {
    id
    sender
    amountIn
    amountOut
    tokenIn
    tokenOut
    timestamp
  }
}
```

### 7.2 Goè°ƒç”¨The Graph

```go
package thegraph

import (
 "bytes"
 "context"
 "encoding/json"
 "fmt"
 "io"
 "net/http"
)

// TheGraphClient The Graphå®¢æˆ·ç«¯
type TheGraphClient struct {
 endpoint string
 httpClient *http.Client
}

// NewTheGraphClient åˆ›å»ºå®¢æˆ·ç«¯
func NewTheGraphClient(subgraphURL string) *TheGraphClient {
 return &TheGraphClient{
  endpoint:   subgraphURL,
  httpClient: &http.Client{},
 }
}

// GraphQLRequest GraphQLè¯·æ±‚
type GraphQLRequest struct {
 Query     string                 `json:"query"`
 Variables map[string]interface{} `json:"variables,omitempty"`
}

// GraphQLResponse GraphQLå“åº”
type GraphQLResponse struct {
 Data   json.RawMessage `json:"data"`
 Errors []GraphQLError  `json:"errors,omitempty"`
}

// GraphQLError GraphQLé”™è¯¯
type GraphQLError struct {
 Message string `json:"message"`
}

// Query æ‰§è¡ŒGraphQLæŸ¥è¯¢
func (tg *TheGraphClient) Query(ctx context.Context, query string, variables map[string]interface{}) (json.RawMessage, error) {
 req := GraphQLRequest{
  Query:     query,
  Variables: variables,
 }

 reqBody, err := json.Marshal(req)
 if err != nil {
  return nil, fmt.Errorf("åºåˆ—åŒ–å¤±è´¥: %w", err)
 }

 httpReq, err := http.NewRequestWithContext(ctx, "POST", tg.endpoint, bytes.NewBuffer(reqBody))
 if err != nil {
  return nil, fmt.Errorf("åˆ›å»ºè¯·æ±‚å¤±è´¥: %w", err)
 }

 httpReq.Header.Set("Content-Type", "application/json")

 resp, err := tg.httpClient.Do(httpReq)
 if err != nil {
  return nil, fmt.Errorf("è¯·æ±‚å¤±è´¥: %w", err)
 }
 defer resp.Body.Close()

 body, err := io.ReadAll(resp.Body)
 if err != nil {
  return nil, fmt.Errorf("è¯»å–å“åº”å¤±è´¥: %w", err)
 }

 var graphQLResp GraphQLResponse
 if err := json.Unmarshal(body, &graphQLResp); err != nil {
  return nil, fmt.Errorf("è§£æå“åº”å¤±è´¥: %w", err)
 }

 if len(graphQLResp.Errors) > 0 {
  return nil, fmt.Errorf("GraphQLé”™è¯¯: %s", graphQLResp.Errors[0].Message)
 }

 return graphQLResp.Data, nil
}

// GetUserNFTs è·å–ç”¨æˆ·NFT
func (tg *TheGraphClient) GetUserNFTs(ctx context.Context, owner string) ([]NFTToken, error) {
 query := `
  query GetUserNFTs($owner: Bytes!) {
   tokens(where: { owner: $owner }) {
    id
    tokenId
    tokenURI
    owner
    mintedAt
   }
  }
 `

 variables := map[string]interface{}{
  "owner": owner,
 }

 data, err := tg.Query(ctx, query, variables)
 if err != nil {
  return nil, err
 }

 var result struct {
  Tokens []NFTToken `json:"tokens"`
 }

 if err := json.Unmarshal(data, &result); err != nil {
  return nil, fmt.Errorf("è§£æç»“æœå¤±è´¥: %w", err)
 }

 return result.Tokens, nil
}

// NFTToken NFT Token
type NFTToken struct {
 ID       string `json:"id"`
 TokenID  string `json:"tokenId"`
 TokenURI string `json:"tokenURI"`
 Owner    string `json:"owner"`
 MintedAt int64  `json:"mintedAt"`
}
```

---

## 8. å®Œæ•´DApp

### 8.1 Web3 DAppæ¶æ„

```go
package dapp

import (
 "context"
 "log"
 "net/http"

 "github.com/gin-gonic/gin"
)

// DAppå®Œæ•´æ¶æ„
/*
å‰ç«¯ (React + ethers.js/web3.js)
         â†•
    REST API (Go)
         â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Smart Contracts          â”‚
â”‚  â€¢ ERC-20 Token            â”‚
â”‚  â€¢ DEX (Uniswap-like)      â”‚
â”‚  â€¢ NFT (ERC-721)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†•
    Ethereum Network
         â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Data Indexing            â”‚
â”‚  â€¢ The Graph               â”‚
â”‚  â€¢ Event Listeners         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Distributed Storage      â”‚
â”‚  â€¢ IPFS (NFT Metadata)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
*/

// DAppService DAppæœåŠ¡
type DAppService struct {
 ethClient   *EthereumClient
 tokenClient *ERC20Token
 dexClient   *DEXClient
 nftClient   *NFTClient
 ipfsClient  *IPFSClient
 graphClient *TheGraphClient
}

// NewDAppService åˆ›å»ºDAppæœåŠ¡
func NewDAppService(config DAppConfig) (*DAppService, error) {
 // åˆå§‹åŒ–ä»¥å¤ªåŠå®¢æˆ·ç«¯
 ethClient, err := NewEthereumClient(config.EthereumRPC)
 if err != nil {
  return nil, err
 }

 // åˆå§‹åŒ–å„ä¸ªåˆçº¦å®¢æˆ·ç«¯
 tokenClient, _ := NewERC20Token(ethClient.client, config.TokenAddress)
 dexClient, _ := NewDEXClient(ethClient.client, config.DEXAddress, config.TokenAAddress, config.TokenBAddress)
 nftClient, _ := NewNFTClient(ethClient.client, config.NFTAddress)

 // åˆå§‹åŒ–IPFSå®¢æˆ·ç«¯
 ipfsClient := NewIPFSClient(config.IPFSAPI)

 // åˆå§‹åŒ–The Graphå®¢æˆ·ç«¯
 graphClient := NewTheGraphClient(config.SubgraphURL)

 return &DAppService{
  ethClient:   ethClient,
  tokenClient: tokenClient,
  dexClient:   dexClient,
  nftClient:   nftClient,
  ipfsClient:  ipfsClient,
  graphClient: graphClient,
 }, nil
}

// SetupRoutes è®¾ç½®è·¯ç”±
func (ds *DAppService) SetupRoutes(r *gin.Engine) {
 api := r.Group("/api/v1")

 // è´¦æˆ·ç›¸å…³
 api.GET("/account/:address/balance", ds.GetBalance)
 api.GET("/account/:address/tokens", ds.GetTokenBalance)
 api.GET("/account/:address/nfts", ds.GetUserNFTs)

 // Tokenç›¸å…³
 api.POST("/token/transfer", ds.TransferToken)
 api.POST("/token/approve", ds.ApproveToken)

 // DEXç›¸å…³
 api.POST("/dex/add-liquidity", ds.AddLiquidity)
 api.POST("/dex/swap", ds.Swap)
 api.GET("/dex/reserves", ds.GetReserves)

 // NFTç›¸å…³
 api.POST("/nft/mint", ds.MintNFT)
 api.GET("/nft/:tokenId", ds.GetNFT)
 api.POST("/nft/transfer", ds.TransferNFT)

 // IPFSç›¸å…³
 api.POST("/ipfs/upload", ds.UploadToIPFS)
 api.GET("/ipfs/:cid", ds.GetFromIPFS)
}

// GetBalance è·å–ETHä½™é¢
func (ds *DAppService) GetBalance(c *gin.Context) {
 address := c.Param("address")

 balance, err := ds.ethClient.GetBalance(c.Request.Context(), address)
 if err != nil {
  c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
  return
 }

 c.JSON(http.StatusOK, gin.H{
  "address": address,
  "balance": balance.String(),
 })
}

// GetTokenBalance è·å–Tokenä½™é¢
func (ds *DAppService) GetTokenBalance(c *gin.Context) {
 address := c.Param("address")

 balance, err := ds.tokenClient.GetBalance(c.Request.Context(), address)
 if err != nil {
  c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
  return
 }

 c.JSON(http.StatusOK, gin.H{
  "address": address,
  "balance": balance.String(),
 })
}

// GetUserNFTs è·å–ç”¨æˆ·NFT
func (ds *DAppService) GetUserNFTs(c *gin.Context) {
 address := c.Param("address")

 nfts, err := ds.graphClient.GetUserNFTs(c.Request.Context(), address)
 if err != nil {
  c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
  return
 }

 c.JSON(http.StatusOK, gin.H{
  "nfts": nfts,
 })
}

// DAppConfig DAppé…ç½®
type DAppConfig struct {
 EthereumRPC   string
 TokenAddress  string
 TokenAAddress string
 TokenBAddress string
 DEXAddress    string
 NFTAddress    string
 IPFSAPI       string
 SubgraphURL   string
}
```

---

## 9. Gasä¼˜åŒ–

### 9.1 Gasä¼˜åŒ–æŠ€å·§

```solidity
// Gasä¼˜åŒ–æœ€ä½³å®è·µ

// âŒ å·®: å¤šæ¬¡è¯»å–å­˜å‚¨
function badExample() public view returns (uint256) {
    uint256 result = 0;
    for (uint256 i = 0; i < balances.length; i++) {
        result += balances[i]; // æ¯æ¬¡å¾ªç¯è¯»å–å­˜å‚¨
    }
    return result;
}

// âœ… å¥½: ç¼“å­˜å­˜å‚¨åˆ°å†…å­˜
function goodExample() public view returns (uint256) {
    uint256 result = 0;
    uint256[] memory cachedBalances = balances; // ä¸€æ¬¡æ€§åŠ è½½
    for (uint256 i = 0; i < cachedBalances.length; i++) {
        result += cachedBalances[i]; // ä»å†…å­˜è¯»å–
    }
    return result;
}

// âŒ å·®: å¤šæ¬¡è®¿é—®storage
function updateBalance(uint256 amount) public {
    balance = balance + amount; // è¯»å– + å†™å…¥
}

// âœ… å¥½: ä½¿ç”¨+=
function updateBalanceOptimized(uint256 amount) public {
    balance += amount; // ç¼–è¯‘å™¨ä¼˜åŒ–
}

// âŒ å·®: uint256 i = 0 (èµ‹å€¼æµªè´¹gas)
for (uint256 i = 0; i < length; i++) { ... }

// âœ… å¥½: uint256 i (é»˜è®¤ä¸º0)
for (uint256 i; i < length; ++i) { ... } // ++iæ¯”i++çœgas

// ä½¿ç”¨uint256ä»£æ›¿uint8 (EVMå¯¹é½)
uint256 public value; // âœ… æ¨è
uint8 public value;   // âŒ å¯èƒ½æ›´è´µ

// ä½¿ç”¨è‡ªå®šä¹‰é”™è¯¯ (Solidity 0.8.4+)
error InsufficientBalance(uint256 available, uint256 required); // âœ… ä¾¿å®œ

// ä»£æ›¿
require(balance >= amount, "Insufficient balance"); // âŒ æ›´è´µ

// ä½¿ç”¨äº‹ä»¶è€Œéå­˜å‚¨è®°å½•å†å²
event Transfer(address indexed from, address indexed to, uint256 value); // âœ… ä¾¿å®œ

// ä»£æ›¿
Transfer[] public history; // âŒ å­˜å‚¨æ˜‚è´µ
```

---

## 10. ç”Ÿäº§éƒ¨ç½²

### 10.1 Dockeréƒ¨ç½²

```dockerfile
# Dockerfile
FROM golang:1.25-alpine AS builder

WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY . .

RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o web3-dapp ./cmd/dapp

FROM alpine:latest

RUN apk --no-cache add ca-certificates

WORKDIR /root/

COPY --from=builder /app/web3-dapp .
COPY --from=builder /app/configs ./configs

EXPOSE 8080

CMD ["./web3-dapp"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  dapp-backend:
    build: .
    ports:
      - "8080:8080"
    environment:
      - ETHEREUM_RPC=https://mainnet.infura.io/v3/${INFURA_KEY}
      - IPFS_API=http://ipfs:5001
      - DATABASE_URL=postgres://user:pass@postgres:5432/dapp?sslmode=disable
    depends_on:
      - postgres
      - ipfs
    restart: unless-stopped

  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: dapp
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
    volumes:
      - postgres-data:/var/lib/postgresql/data
    restart: unless-stopped

  # IPFSèŠ‚ç‚¹
  ipfs:
    image: ipfs/go-ipfs:latest
    ports:
      - "4001:4001"   # P2P
      - "5001:5001"   # API
      - "8081:8080"   # Gateway
    volumes:
      - ipfs-data:/data/ipfs
    restart: unless-stopped

  # Redis (ç¼“å­˜)
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    restart: unless-stopped

volumes:
  postgres-data:
  ipfs-data:
  redis-data:
```

---

## æ€»ç»“

### âœ… æ ¸å¿ƒæˆæœ

1. **åŒºå—é“¾åŸºç¡€**
   - åŒºå—é“¾åŸç†ä¸å®ç°
   - PoWå…±è¯†ç®—æ³•
   - Merkle Tree

2. **ä»¥å¤ªåŠé›†æˆ**
   - go-ethereumå®¢æˆ·ç«¯
   - å‘é€äº¤æ˜“
   - ç›‘å¬äº‹ä»¶

3. **æ™ºèƒ½åˆçº¦**
   - ERC-20ä»£å¸
   - ERC-721 NFT
   - DEX (AMM)

4. **DeFiåè®®**
   - è‡ªåŠ¨åšå¸‚å•† (Uniswap-like)
   - æµåŠ¨æ€§æŒ–çŸ¿
   - Tokenäº¤æ¢

5. **NFTç”Ÿæ€**
   - é“¸é€ ä¸äº¤æ˜“
   - IPFSå…ƒæ•°æ®å­˜å‚¨
   - The Graphç´¢å¼•

6. **ç”Ÿäº§éƒ¨ç½²**
   - Dockerå®¹å™¨åŒ–
   - Gasä¼˜åŒ–
   - å®‰å…¨æœ€ä½³å®è·µ

### ğŸŒŸ Go 1.25.3åº”ç”¨

| ç‰¹æ€§ | åº”ç”¨ |
|------|------|
| Goroutine | äº‹ä»¶ç›‘å¬ã€å¼‚æ­¥å¤„ç† |
| Channel | åŒºå—é“¾åŒæ­¥ |
| Context | è¶…æ—¶æ§åˆ¶ |
| Generic | ç±»å‹å®‰å…¨çš„åˆçº¦ç»‘å®š |
| Error Handling | äº¤æ˜“é”™è¯¯å¤„ç† |

### ğŸ“Š æ¶æ„äº®ç‚¹

- **å»ä¸­å¿ƒåŒ–**: æ— éœ€ä¿¡ä»»ç¬¬ä¸‰æ–¹
- **ä¸å¯ç¯¡æ”¹**: åŒºå—é“¾ä¿è¯æ•°æ®å®Œæ•´æ€§
- **é€æ˜**: æ‰€æœ‰äº¤æ˜“å…¬å¼€å¯æŸ¥
- **å¯ç»„åˆæ€§**: æ™ºèƒ½åˆçº¦ä¹é«˜

### ğŸ¯ é€‚ç”¨åœºæ™¯

- DeFi (å»ä¸­å¿ƒåŒ–é‡‘è)
- NFTå¸‚åœº
- DAO (å»ä¸­å¿ƒåŒ–è‡ªæ²»ç»„ç»‡)
- é“¾ä¸Šæ¸¸æˆ

---

## ä¸‹ä¸€æ­¥å­¦ä¹ 

- [ ] Layer 2æ‰©å®¹æ–¹æ¡ˆ (Polygon, Arbitrum)
- [ ] è·¨é“¾æ¡¥ (Cross-Chain Bridge)
- [ ] MEV (Maximal Extractable Value)
- [ ] DAOæ²»ç†åˆçº¦

---

> **å»¶ä¼¸é˜…è¯»**:  
> â€¢ [ä»¥å¤ªåŠå®˜æ–¹æ–‡æ¡£](https://ethereum.org)  
> â€¢ [Solidityæ–‡æ¡£](https://docs.soliditylang.org)  
> â€¢ [OpenZeppelinåˆçº¦åº“](https://docs.openzeppelin.com/contracts)  
> â€¢ [Uniswap V2ç™½çš®ä¹¦](https://uniswap.org/whitepaper.pdf)
