# Goå¹¶å‘å‹è®¾è®¡æ¨¡å¼

> **ç®€ä»‹**: æ·±å…¥æŒæ¡Goå¹¶å‘å‹è®¾è®¡æ¨¡å¼ï¼ŒåŒ…æ‹¬Future/Promiseã€Worker Poolã€Pipelineã€Fan-Out/Fan-Inç­‰æ¨¡å¼
> **ç‰ˆæœ¬**: Go 1.23+  
> **éš¾åº¦**: â­â­â­â­â­  
> **æ ‡ç­¾**: #è®¾è®¡æ¨¡å¼ #å¹¶å‘æ¨¡å¼ #å¹¶å‘ç¼–ç¨‹ #æ¶æ„è®¾è®¡

<!-- TOC START -->
- [Goå¹¶å‘å‹è®¾è®¡æ¨¡å¼](#goå¹¶å‘å‹è®¾è®¡æ¨¡å¼)
  - [ç†è®ºåŸºç¡€ä¸åˆ†ç±»](#ç†è®ºåŸºç¡€ä¸åˆ†ç±»)
  - [Future/Promiseæ¨¡å¼](#futurepromiseæ¨¡å¼)
  - [Worker Poolæ¨¡å¼](#worker-poolæ¨¡å¼)
  - [Pipelineæ¨¡å¼](#pipelineæ¨¡å¼)
  - [Fan-Out/Fan-Inæ¨¡å¼](#fan-outfan-inæ¨¡å¼)
  - [ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼](#ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼)
  - [Semaphoreæ¨¡å¼](#semaphoreæ¨¡å¼)
  - [Contextä¼ æ’­æ¨¡å¼](#contextä¼ æ’­æ¨¡å¼)
  - [æœ€ä½³å®è·µä¸å¸¸è§é™·é˜±](#æœ€ä½³å®è·µä¸å¸¸è§é™·é˜±)
<!-- TOC END -->


## ğŸ“‹ ç›®å½•


- [ç†è®ºåŸºç¡€ä¸åˆ†ç±»](#ç†è®ºåŸºç¡€ä¸åˆ†ç±»)
  - [å¹¶å‘æ¨¡å¼çš„é‡è¦æ€§](#å¹¶å‘æ¨¡å¼çš„é‡è¦æ€§)
  - [æ¨¡å¼åˆ†ç±»](#æ¨¡å¼åˆ†ç±»)
- [Future/Promiseæ¨¡å¼](#futurepromiseæ¨¡å¼)
  - [å®šä¹‰](#å®šä¹‰)
  - [å®ç°](#å®ç°)
  - [æ‰¹é‡Future](#æ‰¹é‡future)
- [Worker Poolæ¨¡å¼](#worker-poolæ¨¡å¼)
  - [å®šä¹‰](#å®šä¹‰)
  - [åŸºç¡€å®ç°](#åŸºç¡€å®ç°)
  - [å¸¦Contextçš„Worker Pool](#å¸¦contextçš„worker-pool)
- [Pipelineæ¨¡å¼](#pipelineæ¨¡å¼)
  - [å®šä¹‰](#å®šä¹‰)
  - [å®ç°](#å®ç°)
  - [å¯å–æ¶ˆçš„Pipeline](#å¯å–æ¶ˆçš„pipeline)
- [Fan-Out/Fan-Inæ¨¡å¼](#fan-outfan-inæ¨¡å¼)
  - [å®šä¹‰](#å®šä¹‰)
  - [å®ç°](#å®ç°)
- [ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼](#ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼)
  - [å®šä¹‰](#å®šä¹‰)
  - [å®ç°](#å®ç°)
- [Semaphoreæ¨¡å¼](#semaphoreæ¨¡å¼)
  - [å®šä¹‰](#å®šä¹‰)
  - [å®ç°](#å®ç°)
- [Contextä¼ æ’­æ¨¡å¼](#contextä¼ æ’­æ¨¡å¼)
  - [å®šä¹‰](#å®šä¹‰)
  - [å®ç°](#å®ç°)
- [æœ€ä½³å®è·µä¸å¸¸è§é™·é˜±](#æœ€ä½³å®è·µä¸å¸¸è§é™·é˜±)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [å¸¸è§é™·é˜±](#å¸¸è§é™·é˜±)
  - [æ€§èƒ½è€ƒé‡](#æ€§èƒ½è€ƒé‡)

## ç†è®ºåŸºç¡€ä¸åˆ†ç±»

### å¹¶å‘æ¨¡å¼çš„é‡è¦æ€§

åœ¨ç°ä»£è½¯ä»¶ç³»ç»Ÿä¸­ï¼Œå¹¶å‘æ˜¯æå‡æ€§èƒ½çš„å…³é”®æ‰‹æ®µã€‚Goè¯­è¨€ä»¥å…¶è½»é‡çº§goroutineå’Œchannelä¸ºæ ¸å¿ƒï¼Œæä¾›äº†å¼ºå¤§çš„å¹¶å‘æ”¯æŒã€‚

### æ¨¡å¼åˆ†ç±»

| æ¨¡å¼ | æ ¸å¿ƒæ€æƒ³ | é€‚ç”¨åœºæ™¯ |
|------|---------|----------|
| **Future/Promise** | å¼‚æ­¥è®¡ç®—ç»“æœ | å¼‚æ­¥ä»»åŠ¡ã€ç»“æœæ”¶é›† |
| **Worker Pool** | å›ºå®šæ•°é‡worker | é™æµã€èµ„æºå¤ç”¨ |
| **Pipeline** | æ•°æ®æµæ°´çº¿ | æ•°æ®è½¬æ¢ã€æµå¼å¤„ç† |
| **Fan-Out/Fan-In** | å¹¶å‘åˆ†å‘/æ±‡æ€» | å¹¶è¡Œè®¡ç®—ã€ç»“æœèšåˆ |
| **Producer-Consumer** | ç”Ÿäº§æ¶ˆè´¹è§£è€¦ | é€Ÿç‡ä¸åŒ¹é… |
| **Semaphore** | èµ„æºé™åˆ¶ | å¹¶å‘æ§åˆ¶ |
| **Context** | ä¸Šä¸‹æ–‡ä¼ æ’­ | å–æ¶ˆã€è¶…æ—¶ã€å…ƒæ•°æ® |

---

## Future/Promiseæ¨¡å¼

### å®šä¹‰

**Future/Promise** è¡¨ç¤ºä¸€ä¸ªå°šæœªå®Œæˆä½†å°†æ¥å¯ç”¨çš„ç»“æœï¼Œå…è®¸å¼‚æ­¥æ‰§è¡Œä»»åŠ¡ã€‚

### å®ç°

```go
package main

import (
    "errors"
    "time"
)

// Future ä»£è¡¨æœªæ¥çš„è®¡ç®—ç»“æœ
type Future struct {
    result chan interface{}
    err    chan error
}

// NewFuture åˆ›å»ºå¹¶å¼‚æ­¥æ‰§è¡Œä»»åŠ¡
func NewFuture(task func() (interface{}, error)) *Future {
    f := &Future{
        result: make(chan interface{}, 1),
        err:    make(chan error, 1),
    }
    
    go func() {
        result, err := task()
        if err != nil {
            f.err <- err
        } else {
            f.result <- result
        }
    }()
    
    return f
}

// Get é˜»å¡è·å–ç»“æœ
func (f *Future) Get() (interface{}, error) {
    select {
    case result := <-f.result:
        return result, nil
    case err := <-f.err:
        return nil, err
    }
}

// GetWithTimeout å¸¦è¶…æ—¶è·å–ç»“æœ
func (f *Future) GetWithTimeout(timeout time.Duration) (interface{}, error) {
    select {
    case result := <-f.result:
        return result, nil
    case err := <-f.err:
        return nil, err
    case <-time.After(timeout):
        return nil, errors.New("timeout")
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    future := NewFuture(func() (interface{}, error) {
        time.Sleep(2 * time.Second)
        return "result", nil
    })
    
    result, err := future.Get()
    if err != nil {
        panic(err)
    }
    println(result.(string))
}
```

### æ‰¹é‡Future

```go
// FutureAll ç­‰å¾…æ‰€æœ‰futureå®Œæˆ
func FutureAll(futures ...*Future) ([]interface{}, error) {
    results := make([]interface{}, len(futures))
    
    for i, f := range futures {
        result, err := f.Get()
        if err != nil {
            return nil, err
        }
        results[i] = result
    }
    
    return results, nil
}

// ä½¿ç”¨
func main() {
    f1 := NewFuture(func() (interface{}, error) { return 1, nil })
    f2 := NewFuture(func() (interface{}, error) { return 2, nil })
    f3 := NewFuture(func() (interface{}, error) { return 3, nil })
    
    results, _ := FutureAll(f1, f2, f3)
    println(results)  // [1, 2, 3]
}
```

---

## Worker Poolæ¨¡å¼

### å®šä¹‰

é€šè¿‡å›ºå®šæ•°é‡çš„workerå¹¶å‘å¤„ç†ä»»åŠ¡ï¼Œæ§åˆ¶èµ„æºæ¶ˆè€—ï¼Œæå‡ååé‡ã€‚

### åŸºç¡€å®ç°

```go
package main

import (
    "fmt"
    "sync"
)

type Job struct {
    ID   int
    Data string
}

type Result struct {
    Job    Job
    Output string
}

// WorkerPool å·¥ä½œæ± 
type WorkerPool struct {
    jobs    chan Job
    results chan Result
    workers int
    wg      sync.WaitGroup
}

// NewWorkerPool åˆ›å»ºå·¥ä½œæ± 
func NewWorkerPool(workers, jobBuffer int) *WorkerPool {
    return &WorkerPool{
        jobs:    make(chan Job, jobBuffer),
        results: make(chan Result, jobBuffer),
        workers: workers,
    }
}

// Start å¯åŠ¨worker
func (wp *WorkerPool) Start() {
    for i := 0; i < wp.workers; i++ {
        wp.wg.Add(1)
        go wp.worker(i)
    }
}

// worker æ‰§è¡Œä»»åŠ¡
func (wp *WorkerPool) worker(id int) {
    defer wp.wg.Done()
    
    for job := range wp.jobs {
        // å¤„ç†ä»»åŠ¡
        output := fmt.Sprintf("Worker %d processed job %d: %s", 
            id, job.ID, job.Data)
        
        wp.results <- Result{
            Job:    job,
            Output: output,
        }
    }
}

// Submit æäº¤ä»»åŠ¡
func (wp *WorkerPool) Submit(job Job) {
    wp.jobs <- job
}

// Wait ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
func (wp *WorkerPool) Wait() {
    close(wp.jobs)
    wp.wg.Wait()
    close(wp.results)
}

// Results è·å–ç»“æœchannel
func (wp *WorkerPool) Results() <-chan Result {
    return wp.results
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    pool := NewWorkerPool(5, 100)
    pool.Start()
    
    // æäº¤ä»»åŠ¡
    go func() {
        for i := 0; i < 10; i++ {
            pool.Submit(Job{ID: i, Data: fmt.Sprintf("data-%d", i)})
        }
        pool.Wait()
    }()
    
    // æ”¶é›†ç»“æœ
    for result := range pool.Results() {
        fmt.Println(result.Output)
    }
}
```

### å¸¦Contextçš„Worker Pool

```go
type WorkerPoolWithContext struct {
    jobs    chan Job
    results chan Result
    workers int
    ctx     context.Context
    cancel  context.CancelFunc
}

func (wp *WorkerPoolWithContext) worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for {
        select {
        case <-wp.ctx.Done():
            return  // å–æ¶ˆä¿¡å·
        case job, ok := <-wp.jobs:
            if !ok {
                return
            }
            // å¤„ç†job
            wp.results <- process(job)
        }
    }
}
```

---

## Pipelineæ¨¡å¼

### å®šä¹‰

å°†æ•°æ®å¤„ç†åˆ†è§£ä¸ºå¤šä¸ªé˜¶æ®µï¼Œæ¯ä¸ªé˜¶æ®µå¹¶å‘æ‰§è¡Œï¼Œå½¢æˆæ•°æ®æµæ°´çº¿ã€‚

### å®ç°

```go
// é˜¶æ®µ1ï¼šç”Ÿæˆæ•°æ®
func generate(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for _, n := range nums {
            out <- n
        }
    }()
    return out
}

// é˜¶æ®µ2ï¼šå¹³æ–¹
func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            out <- n * n
        }
    }()
    return out
}

// é˜¶æ®µ3ï¼šè¿‡æ»¤
func filter(in <-chan int, predicate func(int) bool) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            if predicate(n) {
                out <- n
            }
        }
    }()
    return out
}

// é˜¶æ®µ4ï¼šæ±‚å’Œ
func sum(in <-chan int) int {
    total := 0
    for n := range in {
        total += n
    }
    return total
}

// ç»„è£…Pipeline
func main() {
    // ç”Ÿæˆ -> å¹³æ–¹ -> è¿‡æ»¤(>10) -> æ±‚å’Œ
    c := generate(1, 2, 3, 4, 5)
    c = square(c)
    c = filter(c, func(n int) bool { return n > 10 })
    
    result := sum(c)
    fmt.Println(result)  // 25 + 16 = 41
}
```

### å¯å–æ¶ˆçš„Pipeline

```go
func squareWithContext(ctx context.Context, in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for {
            select {
            case <-ctx.Done():
                return
            case n, ok := <-in:
                if !ok {
                    return
                }
                select {
                case out <- n * n:
                case <-ctx.Done():
                    return
                }
            }
        }
    }()
    return out
}
```

---

## Fan-Out/Fan-Inæ¨¡å¼

### å®šä¹‰

**Fan-Out**: å°†ä»»åŠ¡åˆ†å‘åˆ°å¤šä¸ªworkerå¹¶å‘å¤„ç†  
**Fan-In**: å°†å¤šä¸ªworkerçš„ç»“æœæ±‡æ€»åˆ°ä¸€ä¸ªchannel

### å®ç°

```go
// Fan-Out: å¯åŠ¨å¤šä¸ªworker
func fanOut(in <-chan int, workers int) []<-chan int {
    channels := make([]<-chan int, workers)
    for i := 0; i < workers; i++ {
        channels[i] = worker(in)
    }
    return channels
}

func worker(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            // æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
            time.Sleep(time.Millisecond)
            out <- n * n
        }
    }()
    return out
}

// Fan-In: åˆå¹¶å¤šä¸ªchannel
func fanIn(channels ...<-chan int) <-chan int {
    out := make(chan int)
    var wg sync.WaitGroup
    
    for _, ch := range channels {
        wg.Add(1)
        go func(c <-chan int) {
            defer wg.Done()
            for n := range c {
                out <- n
            }
        }(ch)
    }
    
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}

// ä½¿ç”¨
func main() {
    in := generate(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    
    // Fan-Out: 3ä¸ªworkerå¹¶å‘å¤„ç†
    workers := fanOut(in, 3)
    
    // Fan-In: åˆå¹¶ç»“æœ
    results := fanIn(workers...)
    
    for result := range results {
        fmt.Println(result)
    }
}
```

---

## ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼

### å®šä¹‰

ç”Ÿäº§è€…ç”Ÿæˆæ•°æ®ï¼Œæ¶ˆè´¹è€…å¤„ç†æ•°æ®ï¼Œé€šè¿‡ç¼“å†²channelè§£è€¦ï¼Œé€‚åº”ä¸åŒé€Ÿç‡ã€‚

### å®ç°

```go
type Queue struct {
    items chan interface{}
}

// ç”Ÿäº§è€…
func producer(q *Queue, count int) {
    for i := 0; i < count; i++ {
        q.items <- i
        fmt.Printf("Produced: %d\n", i)
        time.Sleep(time.Millisecond * 100)
    }
    close(q.items)
}

// æ¶ˆè´¹è€…
func consumer(id int, q *Queue, wg *sync.WaitGroup) {
    defer wg.Done()
    for item := range q.items {
        fmt.Printf("Consumer %d consumed: %v\n", id, item)
        time.Sleep(time.Millisecond * 200)  // æ¶ˆè´¹æ›´æ…¢
    }
}

func main() {
    q := &Queue{items: make(chan interface{}, 10)}
    
    go producer(q, 20)
    
    var wg sync.WaitGroup
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go consumer(i, q, &wg)
    }
    
    wg.Wait()
}
```

---

## Semaphoreæ¨¡å¼

### å®šä¹‰

ä½¿ç”¨channelå®ç°ä¿¡å·é‡ï¼Œé™åˆ¶å¹¶å‘è®¿é—®æ•°é‡ã€‚

### å®ç°

```go
type Semaphore chan struct{}

// NewSemaphore åˆ›å»ºä¿¡å·é‡
func NewSemaphore(n int) Semaphore {
    return make(Semaphore, n)
}

// Acquire è·å–èµ„æº
func (s Semaphore) Acquire() {
    s <- struct{}{}
}

// Release é‡Šæ”¾èµ„æº
func (s Semaphore) Release() {
    <-s
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    sem := NewSemaphore(3)  // æœ€å¤š3ä¸ªå¹¶å‘
    
    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            sem.Acquire()
            defer sem.Release()
            
            fmt.Printf("Task %d running\n", id)
            time.Sleep(time.Second)
        }(i)
    }
    
    wg.Wait()
}
```

---

## Contextä¼ æ’­æ¨¡å¼

### å®šä¹‰

ä½¿ç”¨contextä¼ é€’å–æ¶ˆä¿¡å·ã€è¶…æ—¶ã€æˆªæ­¢æ—¶é—´å’Œè¯·æ±‚èŒƒå›´çš„å€¼ã€‚

### å®ç°

```go
func worker(ctx context.Context, id int) {
    for {
        select {
        case <-ctx.Done():
            fmt.Printf("Worker %d stopped: %v\n", id, ctx.Err())
            return
        default:
            fmt.Printf("Worker %d working...\n", id)
            time.Sleep(time.Millisecond * 500)
        }
    }
}

func main() {
    // å¸¦è¶…æ—¶çš„context
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()
    
    // å¯åŠ¨å¤šä¸ªworker
    var wg sync.WaitGroup
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            worker(ctx, id)
        }(i)
    }
    
    wg.Wait()
    fmt.Println("All workers stopped")
}
```

---

## æœ€ä½³å®è·µä¸å¸¸è§é™·é˜±

### æœ€ä½³å®è·µ

1. **åˆç†è®¾ç½®ç¼“å†²åŒº**
   - ç¼“å†²è¿‡å°ï¼šé¢‘ç¹é˜»å¡
   - ç¼“å†²è¿‡å¤§ï¼šæµªè´¹å†…å­˜
   - å»ºè®®ï¼šæ ¹æ®ç”Ÿäº§/æ¶ˆè´¹é€Ÿç‡ä¼°ç®—

2. **ä½¿ç”¨Contextæ§åˆ¶ç”Ÿå‘½å‘¨æœŸ**
   ```go
   ctx, cancel := context.WithCancel(context.Background())
   defer cancel()  // ç¡®ä¿å–æ¶ˆ
   ```

3. **é¿å…Goroutineæ³„æ¼**
   - ç¡®ä¿æ¯ä¸ªgoroutineéƒ½æœ‰é€€å‡ºè·¯å¾„
   - ä½¿ç”¨contextæˆ–done channel

4. **Workeræ•°é‡è°ƒä¼˜**
   - CPUå¯†é›†å‹ï¼šworkers = CPUæ ¸æ•°
   - I/Oå¯†é›†å‹ï¼šworkers > CPUæ ¸æ•°
   - é€šè¿‡benchmarkç¡®å®šæœ€ä½³å€¼

5. **Channelå…³é—­åŸåˆ™**
   - åªç”±ç”Ÿäº§è€…å…³é—­channel
   - æ¶ˆè´¹è€…æ£€æµ‹å…³é—­ï¼š`val, ok := <-ch`

### å¸¸è§é™·é˜±

**1. Goroutineæ³„æ¼**

```go
// âŒ æ³„æ¼ï¼šchannelæ°¸è¿œé˜»å¡
func leak() {
    ch := make(chan int)
    go func() {
        ch <- 42  // æ°¸è¿œé˜»å¡
    }()
}

// âœ… æ­£ç¡®ï¼šä½¿ç”¨ç¼“å†²æˆ–ç¡®ä¿æ¥æ”¶
func noLeak() {
    ch := make(chan int, 1)
    go func() {
        ch <- 42
    }()
}
```

**2. æ­»é”**

```go
// âŒ æ­»é”ï¼šå¾ªç¯ä¾èµ–
ch1 := make(chan int)
ch2 := make(chan int)

go func() {
    ch1 <- <-ch2
}()

go func() {
    ch2 <- <-ch1
}()
```

**3. ç«æ€æ¡ä»¶**

```go
// âŒ ç«æ€
count := 0
for i := 0; i < 10; i++ {
    go func() {
        count++  // ç«æ€ï¼
    }()
}

// âœ… ä½¿ç”¨atomicæˆ–channel
var count int64
for i := 0; i < 10; i++ {
    go func() {
        atomic.AddInt64(&count, 1)
    }()
}
```

### æ€§èƒ½è€ƒé‡

| æ¨¡å¼ | å¼€é”€ | ååé‡ | é€‚ç”¨åœºæ™¯ |
|------|------|--------|----------|
| Worker Pool | ä½ | é«˜ | æ‰¹é‡ä»»åŠ¡ |
| Pipeline | ä¸­ | ä¸­ | æµå¼å¤„ç† |
| Fan-Out/Fan-In | ä¸­ | é«˜ | å¹¶è¡Œè®¡ç®— |
| Future/Promise | ä½ | ä¸­ | å¼‚æ­¥ä»»åŠ¡ |

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ27æ—¥  
**æ–‡æ¡£çŠ¶æ€**: å·²ä¼˜åŒ–  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
