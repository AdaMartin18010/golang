# Go设计模式

**版本**: v1.0
**更新日期**: 2025-10-29
**适用于**: Go 1.25.3

---

> **难度**: ⭐⭐⭐⭐
> **标签**: #设计模式 #架构 #最佳实践

## 📋 目录

- [Go设计模式](#go设计模式)
  - [📋 目录](#-目录)
  - [1. 创建型模式](#1-创建型模式)
    - [单例模式（Singleton）](#单例模式singleton)
    - [工厂模式（Factory）](#工厂模式factory)
    - [建造者模式（Builder）](#建造者模式builder)
    - [原型模式（Prototype）](#原型模式prototype)
  - [2. 结构型模式](#2-结构型模式)
    - [适配器模式（Adapter）](#适配器模式adapter)
    - [装饰器模式（Decorator）](#装饰器模式decorator)
    - [代理模式（Proxy）](#代理模式proxy)
    - [外观模式（Facade）](#外观模式facade)
  - [3. 行为型模式](#3-行为型模式)
    - [策略模式（Strategy）](#策略模式strategy)
    - [观察者模式（Observer）](#观察者模式observer)
    - [模板方法模式（Template Method）](#模板方法模式template-method)
  - [4. Go特有模式](#4-go特有模式)
    - [选项模式（Options Pattern）](#选项模式options-pattern)
    - [管道模式（Pipeline Pattern）](#管道模式pipeline-pattern)
    - [上下文模式（Context Pattern）](#上下文模式context-pattern)
  - [🔗 相关资源](#-相关资源)

## 1. 创建型模式

### 单例模式（Singleton）

```go
package singleton

import "sync"

type singleton struct {
    value string
}

var (
    instance *singleton
    once     sync.Once
)

// GetInstance 线程安全的单例获取
func GetInstance() *singleton {
    once.Do(func() {
        instance = &singleton{
            value: "singleton instance",
        }
    })
    return instance
}

// 使用
func main() {
    s1 := singleton.GetInstance()
    s2 := singleton.GetInstance()
    // s1 和 s2 是同一个实例
}
```

---

### 工厂模式（Factory）

```go
// 简单工厂
type Animal interface {
    Speak() string
}

type Dog struct{}

func (d *Dog) Speak() string {
    return "Woof!"
}

type Cat struct{}

func (c *Cat) Speak() string {
    return "Meow!"
}

func NewAnimal(animalType string) Animal {
    switch animalType {
    case "dog":
        return &Dog{}
    case "cat":
        return &Cat{}
    default:
        return nil
    }
}

// 使用
func main() {
    dog := NewAnimal("dog")
    fmt.Println(dog.Speak())  // Woof!

    cat := NewAnimal("cat")
    fmt.Println(cat.Speak())  // Meow!
}
```

---

### 建造者模式（Builder）

```go
type User struct {
    Name     string
    Email    string
    Age      int
    Address  string
    Phone    string
}

type UserBuilder struct {
    user *User
}

func NewUserBuilder() *UserBuilder {
    return &UserBuilder{
        user: &User{},
    }
}

func (b *UserBuilder) Name(name string) *UserBuilder {
    b.user.Name = name
    return b
}

func (b *UserBuilder) Email(email string) *UserBuilder {
    b.user.Email = email
    return b
}

func (b *UserBuilder) Age(age int) *UserBuilder {
    b.user.Age = age
    return b
}

func (b *UserBuilder) Address(address string) *UserBuilder {
    b.user.Address = address
    return b
}

func (b *UserBuilder) Phone(phone string) *UserBuilder {
    b.user.Phone = phone
    return b
}

func (b *UserBuilder) Build() *User {
    return b.user
}

// 使用
func main() {
    user := NewUserBuilder().
        Name("Alice").
        Email("alice@example.com").
        Age(25).
        Address("123 Main St").
        Build()

    fmt.Printf("%+v\n", user)
}
```

---

### 原型模式（Prototype）

```go
type Cloneable interface {
    Clone() Cloneable
}

type User struct {
    Name  string
    Email string
    Tags  []string
}

func (u *User) Clone() *User {
    // 深拷贝
    tags := make([]string, len(u.Tags))
    copy(tags, u.Tags)

    return &User{
        Name:  u.Name,
        Email: u.Email,
        Tags:  tags,
    }
}

// 使用
func main() {
    original := &User{
        Name:  "Alice",
        Email: "alice@example.com",
        Tags:  []string{"admin", "user"},
    }

    cloned := original.Clone()
    cloned.Name = "Bob"
    cloned.Tags[0] = "editor"

    fmt.Println(original.Name, original.Tags[0])  // Alice admin
    fmt.Println(cloned.Name, cloned.Tags[0])      // Bob editor
}
```

---

## 2. 结构型模式

### 适配器模式（Adapter）

```go
// 目标接口
type MediaPlayer interface {
    Play(audioType, fileName string)
}

// 被适配接口
type AdvancedMediaPlayer interface {
    PlayVLC(fileName string)
    PlayMP4(fileName string)
}

// VLC播放器
type VLCPlayer struct{}

func (v *VLCPlayer) PlayVLC(fileName string) {
    fmt.Printf("Playing VLC file: %s\n", fileName)
}

func (v *VLCPlayer) PlayMP4(fileName string) {}

// 适配器
type MediaAdapter struct {
    advancedPlayer AdvancedMediaPlayer
}

func NewMediaAdapter(audioType string) *MediaAdapter {
    if audioType == "vlc" {
        return &MediaAdapter{
            advancedPlayer: &VLCPlayer{},
        }
    }
    return nil
}

func (m *MediaAdapter) Play(audioType, fileName string) {
    if audioType == "vlc" {
        m.advancedPlayer.PlayVLC(fileName)
    }
}
```

---

### 装饰器模式（Decorator）

```go
type Coffee interface {
    Cost() float64
    Description() string
}

type SimpleCoffee struct{}

func (s *SimpleCoffee) Cost() float64 {
    return 2.0
}

func (s *SimpleCoffee) Description() string {
    return "Simple coffee"
}

// 牛奶装饰器
type MilkDecorator struct {
    coffee Coffee
}

func (m *MilkDecorator) Cost() float64 {
    return m.coffee.Cost() + 0.5
}

func (m *MilkDecorator) Description() string {
    return m.coffee.Description() + ", milk"
}

// 糖装饰器
type SugarDecorator struct {
    coffee Coffee
}

func (s *SugarDecorator) Cost() float64 {
    return s.coffee.Cost() + 0.3
}

func (s *SugarDecorator) Description() string {
    return s.coffee.Description() + ", sugar"
}

// 使用
func main() {
    coffee := &SimpleCoffee{}
    coffee = &MilkDecorator{coffee: coffee}
    coffee = &SugarDecorator{coffee: coffee}

    fmt.Println(coffee.Description())  // Simple coffee, milk, sugar
    fmt.Println(coffee.Cost())         // 2.8
}
```

---

### 代理模式（Proxy）

```go
type Subject interface {
    Request() string
}

type RealSubject struct{}

func (r *RealSubject) Request() string {
    return "Real subject"
}

type Proxy struct {
    realSubject *RealSubject
    cache       string
}

func (p *Proxy) Request() string {
    if p.cache == "" {
        if p.realSubject == nil {
            p.realSubject = &RealSubject{}
        }
        p.cache = p.realSubject.Request()
    }
    return p.cache
}

// 使用
func main() {
    proxy := &Proxy{}
    fmt.Println(proxy.Request())  // 第一次调用，创建RealSubject
    fmt.Println(proxy.Request())  // 第二次调用，使用缓存
}
```

---

### 外观模式（Facade）

```go
// 复杂子系统
type CPU struct{}

func (c *CPU) Freeze() {
    fmt.Println("CPU: Freeze")
}

func (c *CPU) Execute() {
    fmt.Println("CPU: Execute")
}

type Memory struct{}

func (m *Memory) Load() {
    fmt.Println("Memory: Load")
}

type HardDrive struct{}

func (h *HardDrive) Read() {
    fmt.Println("HardDrive: Read")
}

// 外观
type Computer struct {
    cpu       *CPU
    memory    *Memory
    hardDrive *HardDrive
}

func NewComputer() *Computer {
    return &Computer{
        cpu:       &CPU{},
        memory:    &Memory{},
        hardDrive: &HardDrive{},
    }
}

func (c *Computer) Start() {
    fmt.Println("Computer starting...")
    c.cpu.Freeze()
    c.memory.Load()
    c.hardDrive.Read()
    c.cpu.Execute()
    fmt.Println("Computer started!")
}

// 使用
func main() {
    computer := NewComputer()
    computer.Start()  // 简化的接口
}
```

---

## 3. 行为型模式

### 策略模式（Strategy）

```go
type PaymentStrategy interface {
    Pay(amount float64) string
}

type CreditCard struct {
    number string
}

func (c *CreditCard) Pay(amount float64) string {
    return fmt.Sprintf("Paid %.2f using Credit Card %s", amount, c.number)
}

type PayPal struct {
    email string
}

func (p *PayPal) Pay(amount float64) string {
    return fmt.Sprintf("Paid %.2f using PayPal %s", amount, p.email)
}

type ShoppingCart struct {
    strategy PaymentStrategy
}

func (s *ShoppingCart) SetStrategy(strategy PaymentStrategy) {
    s.strategy = strategy
}

func (s *ShoppingCart) Checkout(amount float64) string {
    return s.strategy.Pay(amount)
}

// 使用
func main() {
    cart := &ShoppingCart{}

    cart.SetStrategy(&CreditCard{number: "1234-5678"})
    fmt.Println(cart.Checkout(100.0))

    cart.SetStrategy(&PayPal{email: "user@example.com"})
    fmt.Println(cart.Checkout(50.0))
}
```

---

### 观察者模式（Observer）

```go
type Observer interface {
    Update(message string)
}

type Subject struct {
    observers []Observer
}

func (s *Subject) Attach(observer Observer) {
    s.observers = append(s.observers, observer)
}

func (s *Subject) Notify(message string) {
    for _, observer := range s.observers {
        observer.Update(message)
    }
}

type EmailObserver struct {
    email string
}

func (e *EmailObserver) Update(message string) {
    fmt.Printf("Email to %s: %s\n", e.email, message)
}

type SMSObserver struct {
    phone string
}

func (s *SMSObserver) Update(message string) {
    fmt.Printf("SMS to %s: %s\n", s.phone, message)
}

// 使用
func main() {
    subject := &Subject{}

    subject.Attach(&EmailObserver{email: "user@example.com"})
    subject.Attach(&SMSObserver{phone: "123-456-7890"})

    subject.Notify("New message!")
}
```

---

### 模板方法模式（Template Method）

```go
type DataProcessor interface {
    LoadData()
    ProcessData()
    SaveData()
}

type BaseProcessor struct {
    processor DataProcessor
}

func (b *BaseProcessor) Execute() {
    b.processor.LoadData()
    b.processor.ProcessData()
    b.processor.SaveData()
}

type CSVProcessor struct{}

func (c *CSVProcessor) LoadData() {
    fmt.Println("Loading CSV data")
}

func (c *CSVProcessor) ProcessData() {
    fmt.Println("Processing CSV data")
}

func (c *CSVProcessor) SaveData() {
    fmt.Println("Saving CSV data")
}

// 使用
func main() {
    processor := &CSVProcessor{}
    base := &BaseProcessor{processor: processor}
    base.Execute()
}
```

---

## 4. Go特有模式

### 选项模式（Options Pattern）

```go
type Server struct {
    host    string
    port    int
    timeout time.Duration
    maxConn int
}

type Option func(*Server)

func WithHost(host string) Option {
    return func(s *Server) {
        s.host = host
    }
}

func WithPort(port int) Option {
    return func(s *Server) {
        s.port = port
    }
}

func WithTimeout(timeout time.Duration) Option {
    return func(s *Server) {
        s.timeout = timeout
    }
}

func NewServer(opts ...Option) *Server {
    server := &Server{
        host:    "localhost",
        port:    8080,
        timeout: 30 * time.Second,
        maxConn: 100,
    }

    for _, opt := range opts {
        opt(server)
    }

    return server
}

// 使用
func main() {
    server := NewServer(
        WithHost("0.0.0.0"),
        WithPort(9000),
        WithTimeout(60*time.Second),
    )
}
```

---

### 管道模式（Pipeline Pattern）

```go
func generator(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for _, n := range nums {
            out <- n
        }
    }()
    return out
}

func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            out <- n * n
        }
    }()
    return out
}

func filter(in <-chan int, predicate func(int) bool) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            if predicate(n) {
                out <- n
            }
        }
    }()
    return out
}

// 使用
func main() {
    nums := generator(1, 2, 3, 4, 5)
    squared := square(nums)
    even := filter(squared, func(n int) bool {
        return n%2 == 0
    })

    for n := range even {
        fmt.Println(n)  // 4, 16
    }
}
```

---

### 上下文模式（Context Pattern）

```go
type key string

const userIDKey key = "userID"

func WithUserID(ctx context.Context, userID int) context.Context {
    return context.WithValue(ctx, userIDKey, userID)
}

func GetUserID(ctx context.Context) (int, bool) {
    userID, ok := ctx.Value(userIDKey).(int)
    return userID, ok
}

func processRequest(ctx context.Context) {
    userID, ok := GetUserID(ctx)
    if !ok {
        fmt.Println("No user ID in context")
        return
    }

    fmt.Printf("Processing request for user %d\n", userID)
}

// 使用
func main() {
    ctx := context.Background()
    ctx = WithUserID(ctx, 123)
    processRequest(ctx)
}
```

---

## 🔗 相关资源

- [架构模式](./02-架构模式.md)
- [最佳实践](../../practices/engineering/README.md)
- [并发模式](../../fundamentals/language/02-并发编程/05-并发模式.md)

---

**最后更新**: 2025-10-29
**Go版本**: 1.25.3
