# Goè®¾è®¡æ¨¡å¼

> **ç®€ä»‹**: Goè®¾è®¡æ¨¡å¼å®Œæ•´æŒ‡å—ï¼ŒåŒ…æ‹¬åˆ›å»ºå‹ã€ç»“æ„å‹ã€è¡Œä¸ºå‹æ¨¡å¼å’ŒGoç‰¹æœ‰æ¨¡å¼

> **ç‰ˆæœ¬**: Go 1.25.3  
> **éš¾åº¦**: â­â­â­â­  
> **æ ‡ç­¾**: #è®¾è®¡æ¨¡å¼ #æ¶æ„ #æœ€ä½³å®è·µ

---

## ğŸ“š ç›®å½•

1. [åˆ›å»ºå‹æ¨¡å¼](#åˆ›å»ºå‹æ¨¡å¼)
2. [ç»“æ„å‹æ¨¡å¼](#ç»“æ„å‹æ¨¡å¼)
3. [è¡Œä¸ºå‹æ¨¡å¼](#è¡Œä¸ºå‹æ¨¡å¼)
4. [Goç‰¹æœ‰æ¨¡å¼](#goç‰¹æœ‰æ¨¡å¼)

---

## 1. åˆ›å»ºå‹æ¨¡å¼

### å•ä¾‹æ¨¡å¼ï¼ˆSingletonï¼‰

```go
package singleton

import "sync"

type singleton struct {
    value string
}

var (
    instance *singleton
    once     sync.Once
)

// GetInstance çº¿ç¨‹å®‰å…¨çš„å•ä¾‹è·å–
func GetInstance() *singleton {
    once.Do(func() {
        instance = &singleton{
            value: "singleton instance",
        }
    })
    return instance
}

// ä½¿ç”¨
func main() {
    s1 := singleton.GetInstance()
    s2 := singleton.GetInstance()
    // s1 å’Œ s2 æ˜¯åŒä¸€ä¸ªå®ä¾‹
}
```

---

### å·¥å‚æ¨¡å¼ï¼ˆFactoryï¼‰

```go
// ç®€å•å·¥å‚
type Animal interface {
    Speak() string
}

type Dog struct{}

func (d *Dog) Speak() string {
    return "Woof!"
}

type Cat struct{}

func (c *Cat) Speak() string {
    return "Meow!"
}

func NewAnimal(animalType string) Animal {
    switch animalType {
    case "dog":
        return &Dog{}
    case "cat":
        return &Cat{}
    default:
        return nil
    }
}

// ä½¿ç”¨
func main() {
    dog := NewAnimal("dog")
    fmt.Println(dog.Speak())  // Woof!
    
    cat := NewAnimal("cat")
    fmt.Println(cat.Speak())  // Meow!
}
```

---

### å»ºé€ è€…æ¨¡å¼ï¼ˆBuilderï¼‰

```go
type User struct {
    Name     string
    Email    string
    Age      int
    Address  string
    Phone    string
}

type UserBuilder struct {
    user *User
}

func NewUserBuilder() *UserBuilder {
    return &UserBuilder{
        user: &User{},
    }
}

func (b *UserBuilder) Name(name string) *UserBuilder {
    b.user.Name = name
    return b
}

func (b *UserBuilder) Email(email string) *UserBuilder {
    b.user.Email = email
    return b
}

func (b *UserBuilder) Age(age int) *UserBuilder {
    b.user.Age = age
    return b
}

func (b *UserBuilder) Address(address string) *UserBuilder {
    b.user.Address = address
    return b
}

func (b *UserBuilder) Phone(phone string) *UserBuilder {
    b.user.Phone = phone
    return b
}

func (b *UserBuilder) Build() *User {
    return b.user
}

// ä½¿ç”¨
func main() {
    user := NewUserBuilder().
        Name("Alice").
        Email("alice@example.com").
        Age(25).
        Address("123 Main St").
        Build()
    
    fmt.Printf("%+v\n", user)
}
```

---

### åŸå‹æ¨¡å¼ï¼ˆPrototypeï¼‰

```go
type Cloneable interface {
    Clone() Cloneable
}

type User struct {
    Name  string
    Email string
    Tags  []string
}

func (u *User) Clone() *User {
    // æ·±æ‹·è´
    tags := make([]string, len(u.Tags))
    copy(tags, u.Tags)
    
    return &User{
        Name:  u.Name,
        Email: u.Email,
        Tags:  tags,
    }
}

// ä½¿ç”¨
func main() {
    original := &User{
        Name:  "Alice",
        Email: "alice@example.com",
        Tags:  []string{"admin", "user"},
    }
    
    cloned := original.Clone()
    cloned.Name = "Bob"
    cloned.Tags[0] = "editor"
    
    fmt.Println(original.Name, original.Tags[0])  // Alice admin
    fmt.Println(cloned.Name, cloned.Tags[0])      // Bob editor
}
```

---

## 2. ç»“æ„å‹æ¨¡å¼

### é€‚é…å™¨æ¨¡å¼ï¼ˆAdapterï¼‰

```go
// ç›®æ ‡æ¥å£
type MediaPlayer interface {
    Play(audioType, fileName string)
}

// è¢«é€‚é…æ¥å£
type AdvancedMediaPlayer interface {
    PlayVLC(fileName string)
    PlayMP4(fileName string)
}

// VLCæ’­æ”¾å™¨
type VLCPlayer struct{}

func (v *VLCPlayer) PlayVLC(fileName string) {
    fmt.Printf("Playing VLC file: %s\n", fileName)
}

func (v *VLCPlayer) PlayMP4(fileName string) {}

// é€‚é…å™¨
type MediaAdapter struct {
    advancedPlayer AdvancedMediaPlayer
}

func NewMediaAdapter(audioType string) *MediaAdapter {
    if audioType == "vlc" {
        return &MediaAdapter{
            advancedPlayer: &VLCPlayer{},
        }
    }
    return nil
}

func (m *MediaAdapter) Play(audioType, fileName string) {
    if audioType == "vlc" {
        m.advancedPlayer.PlayVLC(fileName)
    }
}
```

---

### è£…é¥°å™¨æ¨¡å¼ï¼ˆDecoratorï¼‰

```go
type Coffee interface {
    Cost() float64
    Description() string
}

type SimpleCoffee struct{}

func (s *SimpleCoffee) Cost() float64 {
    return 2.0
}

func (s *SimpleCoffee) Description() string {
    return "Simple coffee"
}

// ç‰›å¥¶è£…é¥°å™¨
type MilkDecorator struct {
    coffee Coffee
}

func (m *MilkDecorator) Cost() float64 {
    return m.coffee.Cost() + 0.5
}

func (m *MilkDecorator) Description() string {
    return m.coffee.Description() + ", milk"
}

// ç³–è£…é¥°å™¨
type SugarDecorator struct {
    coffee Coffee
}

func (s *SugarDecorator) Cost() float64 {
    return s.coffee.Cost() + 0.3
}

func (s *SugarDecorator) Description() string {
    return s.coffee.Description() + ", sugar"
}

// ä½¿ç”¨
func main() {
    coffee := &SimpleCoffee{}
    coffee = &MilkDecorator{coffee: coffee}
    coffee = &SugarDecorator{coffee: coffee}
    
    fmt.Println(coffee.Description())  // Simple coffee, milk, sugar
    fmt.Println(coffee.Cost())         // 2.8
}
```

---

### ä»£ç†æ¨¡å¼ï¼ˆProxyï¼‰

```go
type Subject interface {
    Request() string
}

type RealSubject struct{}

func (r *RealSubject) Request() string {
    return "Real subject"
}

type Proxy struct {
    realSubject *RealSubject
    cache       string
}

func (p *Proxy) Request() string {
    if p.cache == "" {
        if p.realSubject == nil {
            p.realSubject = &RealSubject{}
        }
        p.cache = p.realSubject.Request()
    }
    return p.cache
}

// ä½¿ç”¨
func main() {
    proxy := &Proxy{}
    fmt.Println(proxy.Request())  // ç¬¬ä¸€æ¬¡è°ƒç”¨ï¼Œåˆ›å»ºRealSubject
    fmt.Println(proxy.Request())  // ç¬¬äºŒæ¬¡è°ƒç”¨ï¼Œä½¿ç”¨ç¼“å­˜
}
```

---

### å¤–è§‚æ¨¡å¼ï¼ˆFacadeï¼‰

```go
// å¤æ‚å­ç³»ç»Ÿ
type CPU struct{}

func (c *CPU) Freeze() {
    fmt.Println("CPU: Freeze")
}

func (c *CPU) Execute() {
    fmt.Println("CPU: Execute")
}

type Memory struct{}

func (m *Memory) Load() {
    fmt.Println("Memory: Load")
}

type HardDrive struct{}

func (h *HardDrive) Read() {
    fmt.Println("HardDrive: Read")
}

// å¤–è§‚
type Computer struct {
    cpu       *CPU
    memory    *Memory
    hardDrive *HardDrive
}

func NewComputer() *Computer {
    return &Computer{
        cpu:       &CPU{},
        memory:    &Memory{},
        hardDrive: &HardDrive{},
    }
}

func (c *Computer) Start() {
    fmt.Println("Computer starting...")
    c.cpu.Freeze()
    c.memory.Load()
    c.hardDrive.Read()
    c.cpu.Execute()
    fmt.Println("Computer started!")
}

// ä½¿ç”¨
func main() {
    computer := NewComputer()
    computer.Start()  // ç®€åŒ–çš„æ¥å£
}
```

---

## 3. è¡Œä¸ºå‹æ¨¡å¼

### ç­–ç•¥æ¨¡å¼ï¼ˆStrategyï¼‰

```go
type PaymentStrategy interface {
    Pay(amount float64) string
}

type CreditCard struct {
    number string
}

func (c *CreditCard) Pay(amount float64) string {
    return fmt.Sprintf("Paid %.2f using Credit Card %s", amount, c.number)
}

type PayPal struct {
    email string
}

func (p *PayPal) Pay(amount float64) string {
    return fmt.Sprintf("Paid %.2f using PayPal %s", amount, p.email)
}

type ShoppingCart struct {
    strategy PaymentStrategy
}

func (s *ShoppingCart) SetStrategy(strategy PaymentStrategy) {
    s.strategy = strategy
}

func (s *ShoppingCart) Checkout(amount float64) string {
    return s.strategy.Pay(amount)
}

// ä½¿ç”¨
func main() {
    cart := &ShoppingCart{}
    
    cart.SetStrategy(&CreditCard{number: "1234-5678"})
    fmt.Println(cart.Checkout(100.0))
    
    cart.SetStrategy(&PayPal{email: "user@example.com"})
    fmt.Println(cart.Checkout(50.0))
}
```

---

### è§‚å¯Ÿè€…æ¨¡å¼ï¼ˆObserverï¼‰

```go
type Observer interface {
    Update(message string)
}

type Subject struct {
    observers []Observer
}

func (s *Subject) Attach(observer Observer) {
    s.observers = append(s.observers, observer)
}

func (s *Subject) Notify(message string) {
    for _, observer := range s.observers {
        observer.Update(message)
    }
}

type EmailObserver struct {
    email string
}

func (e *EmailObserver) Update(message string) {
    fmt.Printf("Email to %s: %s\n", e.email, message)
}

type SMSObserver struct {
    phone string
}

func (s *SMSObserver) Update(message string) {
    fmt.Printf("SMS to %s: %s\n", s.phone, message)
}

// ä½¿ç”¨
func main() {
    subject := &Subject{}
    
    subject.Attach(&EmailObserver{email: "user@example.com"})
    subject.Attach(&SMSObserver{phone: "123-456-7890"})
    
    subject.Notify("New message!")
}
```

---

### æ¨¡æ¿æ–¹æ³•æ¨¡å¼ï¼ˆTemplate Methodï¼‰

```go
type DataProcessor interface {
    LoadData()
    ProcessData()
    SaveData()
}

type BaseProcessor struct {
    processor DataProcessor
}

func (b *BaseProcessor) Execute() {
    b.processor.LoadData()
    b.processor.ProcessData()
    b.processor.SaveData()
}

type CSVProcessor struct{}

func (c *CSVProcessor) LoadData() {
    fmt.Println("Loading CSV data")
}

func (c *CSVProcessor) ProcessData() {
    fmt.Println("Processing CSV data")
}

func (c *CSVProcessor) SaveData() {
    fmt.Println("Saving CSV data")
}

// ä½¿ç”¨
func main() {
    processor := &CSVProcessor{}
    base := &BaseProcessor{processor: processor}
    base.Execute()
}
```

---

## 4. Goç‰¹æœ‰æ¨¡å¼

### é€‰é¡¹æ¨¡å¼ï¼ˆOptions Patternï¼‰

```go
type Server struct {
    host    string
    port    int
    timeout time.Duration
    maxConn int
}

type Option func(*Server)

func WithHost(host string) Option {
    return func(s *Server) {
        s.host = host
    }
}

func WithPort(port int) Option {
    return func(s *Server) {
        s.port = port
    }
}

func WithTimeout(timeout time.Duration) Option {
    return func(s *Server) {
        s.timeout = timeout
    }
}

func NewServer(opts ...Option) *Server {
    server := &Server{
        host:    "localhost",
        port:    8080,
        timeout: 30 * time.Second,
        maxConn: 100,
    }
    
    for _, opt := range opts {
        opt(server)
    }
    
    return server
}

// ä½¿ç”¨
func main() {
    server := NewServer(
        WithHost("0.0.0.0"),
        WithPort(9000),
        WithTimeout(60*time.Second),
    )
}
```

---

### ç®¡é“æ¨¡å¼ï¼ˆPipeline Patternï¼‰

```go
func generator(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for _, n := range nums {
            out <- n
        }
    }()
    return out
}

func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            out <- n * n
        }
    }()
    return out
}

func filter(in <-chan int, predicate func(int) bool) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            if predicate(n) {
                out <- n
            }
        }
    }()
    return out
}

// ä½¿ç”¨
func main() {
    nums := generator(1, 2, 3, 4, 5)
    squared := square(nums)
    even := filter(squared, func(n int) bool {
        return n%2 == 0
    })
    
    for n := range even {
        fmt.Println(n)  // 4, 16
    }
}
```

---

### ä¸Šä¸‹æ–‡æ¨¡å¼ï¼ˆContext Patternï¼‰

```go
type key string

const userIDKey key = "userID"

func WithUserID(ctx context.Context, userID int) context.Context {
    return context.WithValue(ctx, userIDKey, userID)
}

func GetUserID(ctx context.Context) (int, bool) {
    userID, ok := ctx.Value(userIDKey).(int)
    return userID, ok
}

func processRequest(ctx context.Context) {
    userID, ok := GetUserID(ctx)
    if !ok {
        fmt.Println("No user ID in context")
        return
    }
    
    fmt.Printf("Processing request for user %d\n", userID)
}

// ä½¿ç”¨
func main() {
    ctx := context.Background()
    ctx = WithUserID(ctx, 123)
    processRequest(ctx)
}
```

---

## ğŸ”— ç›¸å…³èµ„æº

- [æ¶æ„æ¨¡å¼](./02-æ¶æ„æ¨¡å¼.md)
- [æœ€ä½³å®è·µ](../../practices/engineering/README.md)
- [å¹¶å‘æ¨¡å¼](../../fundamentals/language/02-å¹¶å‘ç¼–ç¨‹/05-å¹¶å‘æ¨¡å¼.md)

---

**æœ€åæ›´æ–°**: 2025-10-28  
**Goç‰ˆæœ¬**: 1.25.3

