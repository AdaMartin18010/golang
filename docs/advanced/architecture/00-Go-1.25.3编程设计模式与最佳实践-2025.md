# Go 1.25.3 ç¼–ç¨‹è®¾è®¡æ¨¡å¼ä¸æœ€ä½³å®è·µ (2025)

> **ç®€ä»‹**: ç³»ç»Ÿæ¢³ç†Goè¯­è¨€çš„æ¶æ„æ¨¡å¼ã€è®¾è®¡æ¨¡å¼å’Œå·¥ç¨‹å®è·µï¼Œå¯¹æ ‡2025å¹´10æœˆæœ€æ–°å®è·µ  
> **ç‰ˆæœ¬**: Go 1.25.3  
> **æ›´æ–°æ—¥æœŸ**: 2025-10-23  
> **æ ‡ç­¾**: #è®¾è®¡æ¨¡å¼ #æ¶æ„æ¨¡å¼ #æœ€ä½³å®è·µ #Goæƒ¯ä¾‹

---

## ğŸ“‹ ç›®å½•


- [1. æ¶æ„æ¨¡å¼](#1-æ¶æ„æ¨¡å¼)
  - [1.1 åˆ†å±‚æ¶æ„ (Layered Architecture)](#11-åˆ†å±‚æ¶æ„-layered-architecture)
  - [1.2 å…­è¾¹å½¢æ¶æ„ (Hexagonal Architecture / Ports & Adapters)](#12-å…­è¾¹å½¢æ¶æ„-hexagonal-architecture--ports--adapters)
  - [1.3 Clean Architecture](#13-clean-architecture)
  - [1.4 DDD (Domain-Driven Design) æ¨¡å¼](#14-ddd-domain-driven-design-æ¨¡å¼)
- [2. åˆ›å»ºå‹æ¨¡å¼](#2-åˆ›å»ºå‹æ¨¡å¼)
  - [2.1 å•ä¾‹æ¨¡å¼ (Singleton)](#21-å•ä¾‹æ¨¡å¼-singleton)
  - [2.2 å·¥å‚æ¨¡å¼ (Factory)](#22-å·¥å‚æ¨¡å¼-factory)
  - [2.3 å»ºé€ è€…æ¨¡å¼ (Builder)](#23-å»ºé€ è€…æ¨¡å¼-builder)
  - [2.4 åŸå‹æ¨¡å¼ (Prototype)](#24-åŸå‹æ¨¡å¼-prototype)
- [3. ç»“æ„å‹æ¨¡å¼](#3-ç»“æ„å‹æ¨¡å¼)
  - [3.1 é€‚é…å™¨æ¨¡å¼ (Adapter)](#31-é€‚é…å™¨æ¨¡å¼-adapter)
  - [3.2 è£…é¥°å™¨æ¨¡å¼ (Decorator)](#32-è£…é¥°å™¨æ¨¡å¼-decorator)
  - [3.3 ä»£ç†æ¨¡å¼ (Proxy)](#33-ä»£ç†æ¨¡å¼-proxy)
  - [3.4 å¤–è§‚æ¨¡å¼ (Facade)](#34-å¤–è§‚æ¨¡å¼-facade)
  - [3.5 ç»„åˆæ¨¡å¼ (Composite)](#35-ç»„åˆæ¨¡å¼-composite)
- [4. è¡Œä¸ºå‹æ¨¡å¼](#4-è¡Œä¸ºå‹æ¨¡å¼)
  - [4.1 ç­–ç•¥æ¨¡å¼ (Strategy)](#41-ç­–ç•¥æ¨¡å¼-strategy)
  - [4.2 è§‚å¯Ÿè€…æ¨¡å¼ (Observer)](#42-è§‚å¯Ÿè€…æ¨¡å¼-observer)
  - [4.3 è´£ä»»é“¾æ¨¡å¼ (Chain of Responsibility)](#43-è´£ä»»é“¾æ¨¡å¼-chain-of-responsibility)
  - [4.4 æ¨¡æ¿æ–¹æ³•æ¨¡å¼ (Template Method)](#44-æ¨¡æ¿æ–¹æ³•æ¨¡å¼-template-method)
- [5. Goç‰¹æœ‰æ¨¡å¼](#5-goç‰¹æœ‰æ¨¡å¼)
  - [5.1 æ¥å£ç»„åˆ](#51-æ¥å£ç»„åˆ)
  - [5.2 å‡½æ•°å¼é€‰é¡¹æ¨¡å¼ (è§2.3)](#52-å‡½æ•°å¼é€‰é¡¹æ¨¡å¼-è§23)
  - [5.3 é”™è¯¯åŒ…è£…æ¨¡å¼](#53-é”™è¯¯åŒ…è£…æ¨¡å¼)
  - [5.4 ä¸Šä¸‹æ–‡ä¼ é€’æ¨¡å¼](#54-ä¸Šä¸‹æ–‡ä¼ é€’æ¨¡å¼)
- [6. å¹¶å‘æ¨¡å¼](#6-å¹¶å‘æ¨¡å¼)
  - [6.1 Worker Pool](#61-worker-pool)
  - [6.2 Pipeline æ¨¡å¼](#62-pipeline-æ¨¡å¼)
  - [6.3 Fan-Out, Fan-In æ¨¡å¼](#63-fan-out-fan-in-æ¨¡å¼)
  - [6.4 è¶…æ—¶å’Œå–æ¶ˆæ¨¡å¼](#64-è¶…æ—¶å’Œå–æ¶ˆæ¨¡å¼)
- [7. å·¥ç¨‹æœ€ä½³å®è·µ](#7-å·¥ç¨‹æœ€ä½³å®è·µ)
  - [7.1 é¡¹ç›®ç»“æ„](#71-é¡¹ç›®ç»“æ„)
  - [7.2 ä¾èµ–æ³¨å…¥](#72-ä¾èµ–æ³¨å…¥)
  - [7.3 é…ç½®ç®¡ç†](#73-é…ç½®ç®¡ç†)
  - [7.4 æ—¥å¿—è§„èŒƒ](#74-æ—¥å¿—è§„èŒƒ)
  - [7.5 ä¼˜é›…å…³é—­](#75-ä¼˜é›…å…³é—­)
- [8. æ€§èƒ½ä¼˜åŒ–æ¨¡å¼](#8-æ€§èƒ½ä¼˜åŒ–æ¨¡å¼)
  - [8.1 å¯¹è±¡æ± ](#81-å¯¹è±¡æ± )
  - [8.2 æ‡’åŠ è½½](#82-æ‡’åŠ è½½)
  - [8.3 æ‰¹é‡å¤„ç†](#83-æ‰¹é‡å¤„ç†)
- [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

## 1. æ¶æ„æ¨¡å¼

### 1.1 åˆ†å±‚æ¶æ„ (Layered Architecture)

**ç»“æ„**:

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Presentation Layer (API/UI)    â”‚  â† HTTP Handlers, Controllers
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Application Layer (Use Cases)  â”‚  â† Business Logic
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Domain Layer (Entities)        â”‚  â† Core Business Models
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Infrastructure Layer           â”‚  â† Database, External Services
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ç¤ºä¾‹**:

```go
// Domain Layer - é¢†åŸŸå®ä½“
package domain

type User struct {
    ID       string
    Email    string
    Name     string
    Password string
}

type UserRepository interface {
    Create(user *User) error
    FindByID(id string) (*User, error)
    FindByEmail(email string) (*User, error)
}

// Application Layer - ç”¨ä¾‹/æœåŠ¡
package service

type UserService struct {
    repo domain.UserRepository
}

func NewUserService(repo domain.UserRepository) *UserService {
    return &UserService{repo: repo}
}

func (s *UserService) RegisterUser(email, name, password string) (*domain.User, error) {
    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
    existing, _ := s.repo.FindByEmail(email)
    if existing != nil {
        return nil, errors.New("user already exists")
    }
    
    // åˆ›å»ºç”¨æˆ·
    user := &domain.User{
        ID:       generateID(),
        Email:    email,
        Name:     name,
        Password: hashPassword(password),
    }
    
    if err := s.repo.Create(user); err != nil {
        return nil, err
    }
    
    return user, nil
}

// Infrastructure Layer - ä»“å‚¨å®ç°
package postgres

type PostgresUserRepository struct {
    db *sql.DB
}

func (r *PostgresUserRepository) Create(user *domain.User) error {
    query := `INSERT INTO users (id, email, name, password) VALUES ($1, $2, $3, $4)`
    _, err := r.db.Exec(query, user.ID, user.Email, user.Name, user.Password)
    return err
}

// Presentation Layer - HTTPå¤„ç†å™¨
package handler

type UserHandler struct {
    service *service.UserService
}

func (h *UserHandler) Register(w http.ResponseWriter, r *http.Request) {
    var req RegisterRequest
    json.NewDecoder(r.Body).Decode(&req)
    
    user, err := h.service.RegisterUser(req.Email, req.Name, req.Password)
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    json.NewEncoder(w).Encode(user)
}
```

### 1.2 å…­è¾¹å½¢æ¶æ„ (Hexagonal Architecture / Ports & Adapters)

**æ ¸å¿ƒæ€æƒ³**: ä¸šåŠ¡é€»è¾‘ä¸å¤–éƒ¨ä¾èµ–è§£è€¦

```go
// æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼ˆå…­è¾¹å½¢çš„ä¸­å¿ƒï¼‰
package core

type OrderService struct {
    orderRepo   OrderRepository   // Port (æ¥å£)
    paymentGate PaymentGateway    // Port (æ¥å£)
    notifier    Notifier          // Port (æ¥å£)
}

// Port - å®šä¹‰æŠ½è±¡æ¥å£
type OrderRepository interface {
    Save(order *Order) error
    FindByID(id string) (*Order, error)
}

type PaymentGateway interface {
    ProcessPayment(order *Order) error
}

type Notifier interface {
    SendOrderConfirmation(order *Order) error
}

// ä¸šåŠ¡é€»è¾‘
func (s *OrderService) PlaceOrder(order *Order) error {
    // 1. éªŒè¯è®¢å•
    if err := order.Validate(); err != nil {
        return err
    }
    
    // 2. å¤„ç†æ”¯ä»˜
    if err := s.paymentGate.ProcessPayment(order); err != nil {
        return fmt.Errorf("payment failed: %w", err)
    }
    
    // 3. ä¿å­˜è®¢å•
    if err := s.orderRepo.Save(order); err != nil {
        return fmt.Errorf("save order failed: %w", err)
    }
    
    // 4. å‘é€é€šçŸ¥
    if err := s.notifier.SendOrderConfirmation(order); err != nil {
        log.Printf("notification failed: %v", err)
    }
    
    return nil
}

// Adapter - PostgreSQLå®ç°
package postgres

type PostgresOrderRepository struct {
    db *sql.DB
}

func (r *PostgresOrderRepository) Save(order *core.Order) error {
    // PostgreSQLå…·ä½“å®ç°
    return nil
}

// Adapter - Stripeæ”¯ä»˜å®ç°
package stripe

type StripePaymentGateway struct {
    apiKey string
}

func (g *StripePaymentGateway) ProcessPayment(order *core.Order) error {
    // Stripe APIè°ƒç”¨
    return nil
}

// Adapter - Emailé€šçŸ¥å®ç°
package email

type EmailNotifier struct {
    smtp *smtp.Client
}

func (n *EmailNotifier) SendOrderConfirmation(order *core.Order) error {
    // å‘é€é‚®ä»¶
    return nil
}

// ä¾èµ–æ³¨å…¥ - ç»„è£…åº”ç”¨
func main() {
    db := connectDB()
    
    orderService := &core.OrderService{
        orderRepo:   &postgres.PostgresOrderRepository{db: db},
        paymentGate: &stripe.StripePaymentGateway{apiKey: "sk_test_xxx"},
        notifier:    &email.EmailNotifier{smtp: setupSMTP()},
    }
    
    // ä½¿ç”¨æœåŠ¡
    order := &core.Order{/* ... */}
    orderService.PlaceOrder(order)
}
```

### 1.3 Clean Architecture

**åˆ†å±‚**:

```text
Entities (Domain)
    â†“
Use Cases (Application)
    â†“
Interface Adapters (Presentation/Infrastructure)
    â†“
Frameworks & Drivers (External)
```

**ä¾èµ–è§„åˆ™**: ä¾èµ–åªèƒ½ä»å¤–å‘å†…

```go
// Entities Layer
package entity

type Article struct {
    ID        string
    Title     string
    Content   string
    AuthorID  string
    CreatedAt time.Time
}

func (a *Article) Validate() error {
    if a.Title == "" {
        return errors.New("title required")
    }
    return nil
}

// Use Cases Layer
package usecase

type ArticleUseCase struct {
    repo ArticleRepository
}

type ArticleRepository interface {
    Store(article *entity.Article) error
    GetByID(id string) (*entity.Article, error)
}

func (uc *ArticleUseCase) CreateArticle(title, content, authorID string) (*entity.Article, error) {
    article := &entity.Article{
        ID:        uuid.New().String(),
        Title:     title,
        Content:   content,
        AuthorID:  authorID,
        CreatedAt: time.Now(),
    }
    
    if err := article.Validate(); err != nil {
        return nil, err
    }
    
    if err := uc.repo.Store(article); err != nil {
        return nil, err
    }
    
    return article, nil
}

// Interface Adapters Layer
package repository

type PostgresArticleRepository struct {
    db *sqlx.DB
}

func (r *PostgresArticleRepository) Store(article *entity.Article) error {
    query := `
        INSERT INTO articles (id, title, content, author_id, created_at)
        VALUES ($1, $2, $3, $4, $5)
    `
    _, err := r.db.Exec(query, 
        article.ID, article.Title, article.Content, article.AuthorID, article.CreatedAt)
    return err
}

// Presentation Layer
package handler

type ArticleHandler struct {
    useCase *usecase.ArticleUseCase
}

func (h *ArticleHandler) Create(c *gin.Context) {
    var req CreateArticleRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": err.Error()})
        return
    }
    
    article, err := h.useCase.CreateArticle(req.Title, req.Content, req.AuthorID)
    if err != nil {
        c.JSON(500, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(201, article)
}
```

### 1.4 DDD (Domain-Driven Design) æ¨¡å¼

**æ ¸å¿ƒæ¦‚å¿µ**:

- Entity (å®ä½“)
- Value Object (å€¼å¯¹è±¡)
- Aggregate (èšåˆ)
- Repository (ä»“å‚¨)
- Domain Service (é¢†åŸŸæœåŠ¡)

```go
// Value Object - ä¸å¯å˜
package domain

type Money struct {
    amount   int64  // åˆ†ä¸ºå•ä½
    currency string
}

func NewMoney(amount int64, currency string) Money {
    return Money{amount: amount, currency: currency}
}

func (m Money) Add(other Money) (Money, error) {
    if m.currency != other.currency {
        return Money{}, errors.New("currency mismatch")
    }
    return Money{amount: m.amount + other.amount, currency: m.currency}, nil
}

func (m Money) Amount() int64 {
    return m.amount
}

// Entity - æœ‰å”¯ä¸€æ ‡è¯†
type Order struct {
    id         string
    customerID string
    items      []OrderItem
    total      Money
    status     OrderStatus
    createdAt  time.Time
}

func (o *Order) ID() string {
    return o.id
}

func (o *Order) AddItem(productID string, quantity int, price Money) error {
    if o.status != OrderStatusDraft {
        return errors.New("cannot modify confirmed order")
    }
    
    item := OrderItem{
        productID: productID,
        quantity:  quantity,
        price:     price,
    }
    
    o.items = append(o.items, item)
    o.recalculateTotal()
    return nil
}

func (o *Order) Confirm() error {
    if len(o.items) == 0 {
        return errors.New("order has no items")
    }
    o.status = OrderStatusConfirmed
    return nil
}

func (o *Order) recalculateTotal() {
    // é‡æ–°è®¡ç®—æ€»é¢
    var total Money
    for _, item := range o.items {
        itemTotal, _ := item.price.Multiply(item.quantity)
        total, _ = total.Add(itemTotal)
    }
    o.total = total
}

// Aggregate Root
type Customer struct {
    id      string
    name    string
    email   string
    orders  []*Order  // èšåˆæ ¹ç®¡ç†å…¶ä¸‹çš„å®ä½“
}

func (c *Customer) PlaceOrder() *Order {
    order := &Order{
        id:         uuid.New().String(),
        customerID: c.id,
        status:     OrderStatusDraft,
        createdAt:  time.Now(),
    }
    c.orders = append(c.orders, order)
    return order
}

// Repository Interface
type OrderRepository interface {
    Save(order *Order) error
    FindByID(id string) (*Order, error)
    FindByCustomerID(customerID string) ([]*Order, error)
}

// Domain Service - è·¨èšåˆçš„ä¸šåŠ¡é€»è¾‘
type OrderPricingService struct {
    discountRepo DiscountRepository
}

func (s *OrderPricingService) ApplyDiscounts(order *Order) error {
    discounts, err := s.discountRepo.FindApplicable(order.customerID)
    if err != nil {
        return err
    }
    
    for _, discount := range discounts {
        order.ApplyDiscount(discount)
    }
    
    return nil
}
```

---

## 2. åˆ›å»ºå‹æ¨¡å¼

### 2.1 å•ä¾‹æ¨¡å¼ (Singleton)

**ä½¿ç”¨åœºæ™¯**: æ•°æ®åº“è¿æ¥æ± ã€é…ç½®ç®¡ç†å™¨

```go
// æ–¹å¼1: ä½¿ç”¨sync.Once (æ¨è)
package database

import "sync"

var (
    instance *Database
    once     sync.Once
)

type Database struct {
    conn *sql.DB
}

func GetInstance() *Database {
    once.Do(func() {
        instance = &Database{
            conn: connectDB(),
        }
    })
    return instance
}

// æ–¹å¼2: åŒ…çº§å˜é‡åˆå§‹åŒ–
var db = &Database{
    conn: connectDB(),
}

func GetDB() *Database {
    return db
}
```

### 2.2 å·¥å‚æ¨¡å¼ (Factory)

**ç®€å•å·¥å‚**:

```go
package storage

type StorageType string

const (
    StorageTypeLocal StorageType = "local"
    StorageTypeS3    StorageType = "s3"
    StorageTypeCOS   StorageType = "cos"
)

type Storage interface {
    Upload(key string, data []byte) error
    Download(key string) ([]byte, error)
}

// ç®€å•å·¥å‚
func NewStorage(storageType StorageType, config map[string]string) (Storage, error) {
    switch storageType {
    case StorageTypeLocal:
        return &LocalStorage{basePath: config["base_path"]}, nil
    case StorageTypeS3:
        return &S3Storage{
            bucket: config["bucket"],
            region: config["region"],
        }, nil
    case StorageTypeCOS:
        return &COSStorage{
            bucket: config["bucket"],
        }, nil
    default:
        return nil, fmt.Errorf("unknown storage type: %s", storageType)
    }
}
```

**å·¥å‚æ–¹æ³•**:

```go
// æŠ½è±¡å·¥å‚æ¥å£
type LoggerFactory interface {
    CreateLogger() Logger
}

// å…·ä½“å·¥å‚
type FileLoggerFactory struct {
    filePath string
}

func (f *FileLoggerFactory) CreateLogger() Logger {
    return &FileLogger{path: f.filePath}
}

type CloudLoggerFactory struct {
    endpoint string
}

func (f *CloudLoggerFactory) CreateLogger() Logger {
    return &CloudLogger{endpoint: f.endpoint}
}

// ä½¿ç”¨
func InitLogging(factory LoggerFactory) {
    logger := factory.CreateLogger()
    logger.Info("Application started")
}
```

### 2.3 å»ºé€ è€…æ¨¡å¼ (Builder)

**å‡½æ•°é€‰é¡¹æ¨¡å¼** (Goæƒ¯ç”¨æ–¹å¼):

```go
package server

type Server struct {
    addr         string
    timeout      time.Duration
    maxConn      int
    tlsConfig    *tls.Config
    middleware   []Middleware
}

type Option func(*Server)

func WithAddr(addr string) Option {
    return func(s *Server) {
        s.addr = addr
    }
}

func WithTimeout(timeout time.Duration) Option {
    return func(s *Server) {
        s.timeout = timeout
    }
}

func WithTLS(config *tls.Config) Option {
    return func(s *Server) {
        s.tlsConfig = config
    }
}

func WithMiddleware(mw ...Middleware) Option {
    return func(s *Server) {
        s.middleware = append(s.middleware, mw...)
    }
}

func NewServer(opts ...Option) *Server {
    // é»˜è®¤å€¼
    s := &Server{
        addr:    ":8080",
        timeout: 30 * time.Second,
        maxConn: 100,
    }
    
    // åº”ç”¨é€‰é¡¹
    for _, opt := range opts {
        opt(s)
    }
    
    return s
}

// ä½¿ç”¨
server := NewServer(
    WithAddr(":9000"),
    WithTimeout(60*time.Second),
    WithTLS(tlsConfig),
    WithMiddleware(logging, recovery),
)
```

**é“¾å¼å»ºé€ è€…**:

```go
type QueryBuilder struct {
    table      string
    columns    []string
    where      []string
    orderBy    string
    limit      int
    args       []interface{}
}

func NewQueryBuilder(table string) *QueryBuilder {
    return &QueryBuilder{table: table}
}

func (b *QueryBuilder) Select(columns ...string) *QueryBuilder {
    b.columns = columns
    return b
}

func (b *QueryBuilder) Where(condition string, args ...interface{}) *QueryBuilder {
    b.where = append(b.where, condition)
    b.args = append(b.args, args...)
    return b
}

func (b *QueryBuilder) OrderBy(column string) *QueryBuilder {
    b.orderBy = column
    return b
}

func (b *QueryBuilder) Limit(n int) *QueryBuilder {
    b.limit = n
    return b
}

func (b *QueryBuilder) Build() (string, []interface{}) {
    query := fmt.Sprintf("SELECT %s FROM %s", 
        strings.Join(b.columns, ", "), b.table)
    
    if len(b.where) > 0 {
        query += " WHERE " + strings.Join(b.where, " AND ")
    }
    
    if b.orderBy != "" {
        query += " ORDER BY " + b.orderBy
    }
    
    if b.limit > 0 {
        query += fmt.Sprintf(" LIMIT %d", b.limit)
    }
    
    return query, b.args
}

// ä½¿ç”¨
query, args := NewQueryBuilder("users").
    Select("id", "name", "email").
    Where("age > ?", 18).
    Where("status = ?", "active").
    OrderBy("created_at DESC").
    Limit(10).
    Build()
```

### 2.4 åŸå‹æ¨¡å¼ (Prototype)

```go
// æ·±æ‹·è´æ¥å£
type Cloneable interface {
    Clone() Cloneable
}

type Configuration struct {
    Database DatabaseConfig
    Redis    RedisConfig
    Features map[string]bool
}

func (c *Configuration) Clone() *Configuration {
    clone := &Configuration{
        Database: c.Database,  // å€¼ç±»å‹è‡ªåŠ¨æ‹·è´
        Redis:    c.Redis,
        Features: make(map[string]bool, len(c.Features)),
    }
    
    // æ·±æ‹·è´map
    for k, v := range c.Features {
        clone.Features[k] = v
    }
    
    return clone
}

// ä½¿ç”¨
baseConfig := &Configuration{
    Database: DatabaseConfig{Host: "localhost"},
    Features: map[string]bool{"feature_a": true},
}

testConfig := baseConfig.Clone()
testConfig.Database.Host = "test-db"  // ä¸å½±å“baseConfig
```

---

## 3. ç»“æ„å‹æ¨¡å¼

### 3.1 é€‚é…å™¨æ¨¡å¼ (Adapter)

```go
// æ—§æ¥å£
type LegacyLogger struct{}

func (l *LegacyLogger) LogMessage(msg string) {
    fmt.Println("[LEGACY]", msg)
}

// æ–°æ¥å£
type Logger interface {
    Info(msg string)
    Error(msg string)
}

// é€‚é…å™¨
type LegacyLoggerAdapter struct {
    legacy *LegacyLogger
}

func (a *LegacyLoggerAdapter) Info(msg string) {
    a.legacy.LogMessage("[INFO] " + msg)
}

func (a *LegacyLoggerAdapter) Error(msg string) {
    a.legacy.LogMessage("[ERROR] " + msg)
}

// ä½¿ç”¨
func UseLogger(logger Logger) {
    logger.Info("Application started")
    logger.Error("Something went wrong")
}

legacyLogger := &LegacyLogger{}
adapter := &LegacyLoggerAdapter{legacy: legacyLogger}
UseLogger(adapter)
```

### 3.2 è£…é¥°å™¨æ¨¡å¼ (Decorator)

```go
// ä¸­é—´ä»¶è£…é¥°å™¨
type HandlerFunc func(http.ResponseWriter, *http.Request)

// æ—¥å¿—è£…é¥°å™¨
func LoggingMiddleware(next HandlerFunc) HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        log.Printf("Started %s %s", r.Method, r.URL.Path)
        
        next(w, r)
        
        log.Printf("Completed in %v", time.Since(start))
    }
}

// è®¤è¯è£…é¥°å™¨
func AuthMiddleware(next HandlerFunc) HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        token := r.Header.Get("Authorization")
        if token == "" {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        
        // éªŒè¯token
        if !validateToken(token) {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }
        
        next(w, r)
    }
}

// ä½¿ç”¨ - é“¾å¼è£…é¥°
handler := LoggingMiddleware(
    AuthMiddleware(
        func(w http.ResponseWriter, r *http.Request) {
            w.Write([]byte("Hello, World!"))
        },
    ),
)
```

### 3.3 ä»£ç†æ¨¡å¼ (Proxy)

**ç¼“å­˜ä»£ç†**:

```go
type DataService interface {
    GetData(key string) (string, error)
}

// çœŸå®æœåŠ¡
type RealDataService struct {
    db *sql.DB
}

func (s *RealDataService) GetData(key string) (string, error) {
    // ä»æ•°æ®åº“è·å–ï¼ˆè€—æ—¶æ“ä½œï¼‰
    time.Sleep(100 * time.Millisecond)
    return "data-" + key, nil
}

// ç¼“å­˜ä»£ç†
type CachedDataService struct {
    real  DataService
    cache map[string]string
    mu    sync.RWMutex
}

func (s *CachedDataService) GetData(key string) (string, error) {
    // å…ˆæŸ¥ç¼“å­˜
    s.mu.RLock()
    if cached, ok := s.cache[key]; ok {
        s.mu.RUnlock()
        return cached, nil
    }
    s.mu.RUnlock()
    
    // ç¼“å­˜æœªå‘½ä¸­ï¼Œè°ƒç”¨çœŸå®æœåŠ¡
    data, err := s.real.GetData(key)
    if err != nil {
        return "", err
    }
    
    // å†™å…¥ç¼“å­˜
    s.mu.Lock()
    s.cache[key] = data
    s.mu.Unlock()
    
    return data, nil
}
```

### 3.4 å¤–è§‚æ¨¡å¼ (Facade)

```go
// å¤æ‚çš„å­ç³»ç»Ÿ
type AuthService struct{}
func (s *AuthService) Authenticate(token string) (*User, error) { /* ... */ }

type OrderService struct{}
func (s *OrderService) CreateOrder(userID string, items []Item) (*Order, error) { /* ... */ }

type PaymentService struct{}
func (s *PaymentService) ProcessPayment(order *Order) error { /* ... */ }

type NotificationService struct{}
func (s *NotificationService) SendConfirmation(user *User, order *Order) error { /* ... */ }

// å¤–è§‚ - ç®€åŒ–æ¥å£
type CheckoutFacade struct {
    auth     *AuthService
    order    *OrderService
    payment  *PaymentService
    notifier *NotificationService
}

func (f *CheckoutFacade) Checkout(token string, items []Item) (*Order, error) {
    // 1. è®¤è¯
    user, err := f.auth.Authenticate(token)
    if err != nil {
        return nil, err
    }
    
    // 2. åˆ›å»ºè®¢å•
    order, err := f.order.CreateOrder(user.ID, items)
    if err != nil {
        return nil, err
    }
    
    // 3. å¤„ç†æ”¯ä»˜
    if err := f.payment.ProcessPayment(order); err != nil {
        return nil, err
    }
    
    // 4. å‘é€é€šçŸ¥
    f.notifier.SendConfirmation(user, order)
    
    return order, nil
}
```

### 3.5 ç»„åˆæ¨¡å¼ (Composite)

```go
// ç»„ä»¶æ¥å£
type Component interface {
    Execute() error
}

// å¶å­èŠ‚ç‚¹
type SimpleTask struct {
    name string
    fn   func() error
}

func (t *SimpleTask) Execute() error {
    fmt.Printf("Executing task: %s\n", t.name)
    return t.fn()
}

// ç»„åˆèŠ‚ç‚¹
type TaskGroup struct {
    name  string
    tasks []Component
}

func (g *TaskGroup) Add(task Component) {
    g.tasks = append(g.tasks, task)
}

func (g *TaskGroup) Execute() error {
    fmt.Printf("Executing task group: %s\n", g.name)
    for _, task := range g.tasks {
        if err := task.Execute(); err != nil {
            return err
        }
    }
    return nil
}

// ä½¿ç”¨
root := &TaskGroup{name: "Deployment"}
root.Add(&SimpleTask{name: "Build", fn: build})
root.Add(&SimpleTask{name: "Test", fn: test})

deploy := &TaskGroup{name: "Deploy"}
deploy.Add(&SimpleTask{name: "Push Image", fn: pushImage})
deploy.Add(&SimpleTask{name: "Update K8s", fn: updateK8s})

root.Add(deploy)
root.Execute()
```

---

## 4. è¡Œä¸ºå‹æ¨¡å¼

### 4.1 ç­–ç•¥æ¨¡å¼ (Strategy)

```go
// ç­–ç•¥æ¥å£
type CompressionStrategy interface {
    Compress(data []byte) ([]byte, error)
}

// å…·ä½“ç­–ç•¥
type GzipCompression struct{}
func (g *GzipCompression) Compress(data []byte) ([]byte, error) {
    var buf bytes.Buffer
    gw := gzip.NewWriter(&buf)
    gw.Write(data)
    gw.Close()
    return buf.Bytes(), nil
}

type ZlibCompression struct{}
func (z *ZlibCompression) Compress(data []byte) ([]byte, error) {
    var buf bytes.Buffer
    zw := zlib.NewWriter(&buf)
    zw.Write(data)
    zw.Close()
    return buf.Bytes(), nil
}

// ä¸Šä¸‹æ–‡
type FileCompressor struct {
    strategy CompressionStrategy
}

func (fc *FileCompressor) SetStrategy(strategy CompressionStrategy) {
    fc.strategy = strategy
}

func (fc *FileCompressor) CompressFile(filename string) error {
    data, _ := os.ReadFile(filename)
    compressed, err := fc.strategy.Compress(data)
    if err != nil {
        return err
    }
    return os.WriteFile(filename+".compressed", compressed, 0644)
}

// ä½¿ç”¨
compressor := &FileCompressor{}
compressor.SetStrategy(&GzipCompression{})
compressor.CompressFile("data.txt")
```

### 4.2 è§‚å¯Ÿè€…æ¨¡å¼ (Observer)

```go
// äº‹ä»¶ç±»å‹
type Event struct {
    Type string
    Data interface{}
}

// è§‚å¯Ÿè€…æ¥å£
type Observer interface {
    OnEvent(event Event)
}

// ä¸»é¢˜
type EventBus struct {
    observers map[string][]Observer
    mu        sync.RWMutex
}

func NewEventBus() *EventBus {
    return &EventBus{
        observers: make(map[string][]Observer),
    }
}

func (eb *EventBus) Subscribe(eventType string, observer Observer) {
    eb.mu.Lock()
    defer eb.mu.Unlock()
    eb.observers[eventType] = append(eb.observers[eventType], observer)
}

func (eb *EventBus) Publish(event Event) {
    eb.mu.RLock()
    observers := eb.observers[event.Type]
    eb.mu.RUnlock()
    
    for _, observer := range observers {
        go observer.OnEvent(event)  // å¼‚æ­¥é€šçŸ¥
    }
}

// å…·ä½“è§‚å¯Ÿè€…
type EmailNotifier struct{}
func (n *EmailNotifier) OnEvent(event Event) {
    fmt.Printf("Sending email for event: %s\n", event.Type)
}

type LogObserver struct{}
func (l *LogObserver) OnEvent(event Event) {
    fmt.Printf("Logging event: %s - %v\n", event.Type, event.Data)
}

// ä½¿ç”¨
bus := NewEventBus()
bus.Subscribe("user.created", &EmailNotifier{})
bus.Subscribe("user.created", &LogObserver{})

bus.Publish(Event{Type: "user.created", Data: User{ID: "123"}})
```

### 4.3 è´£ä»»é“¾æ¨¡å¼ (Chain of Responsibility)

```go
// å¤„ç†å™¨æ¥å£
type Handler interface {
    SetNext(handler Handler) Handler
    Handle(request *Request) error
}

// åŸºç¡€å¤„ç†å™¨
type BaseHandler struct {
    next Handler
}

func (h *BaseHandler) SetNext(handler Handler) Handler {
    h.next = handler
    return handler
}

func (h *BaseHandler) HandleNext(request *Request) error {
    if h.next != nil {
        return h.next.Handle(request)
    }
    return nil
}

// å…·ä½“å¤„ç†å™¨
type AuthHandler struct {
    BaseHandler
}

func (h *AuthHandler) Handle(request *Request) error {
    if request.Token == "" {
        return errors.New("missing auth token")
    }
    fmt.Println("Auth: OK")
    return h.HandleNext(request)
}

type ValidationHandler struct {
    BaseHandler
}

func (h *ValidationHandler) Handle(request *Request) error {
    if request.Data == nil {
        return errors.New("missing request data")
    }
    fmt.Println("Validation: OK")
    return h.HandleNext(request)
}

type LoggingHandler struct {
    BaseHandler
}

func (h *LoggingHandler) Handle(request *Request) error {
    fmt.Printf("Logging request: %+v\n", request)
    return h.HandleNext(request)
}

// ä½¿ç”¨
auth := &AuthHandler{}
validation := &ValidationHandler{}
logging := &LoggingHandler{}

auth.SetNext(validation).SetNext(logging)

request := &Request{Token: "abc123", Data: map[string]string{"key": "value"}}
auth.Handle(request)
```

### 4.4 æ¨¡æ¿æ–¹æ³•æ¨¡å¼ (Template Method)

```go
// æŠ½è±¡æ¥å£
type DataProcessor interface {
    FetchData() ([]byte, error)
    ProcessData([]byte) ([]byte, error)
    SaveData([]byte) error
}

// æ¨¡æ¿æ–¹æ³•
func ProcessPipeline(processor DataProcessor) error {
    // 1. è·å–æ•°æ®
    data, err := processor.FetchData()
    if err != nil {
        return fmt.Errorf("fetch failed: %w", err)
    }
    
    // 2. å¤„ç†æ•°æ®
    processed, err := processor.ProcessData(data)
    if err != nil {
        return fmt.Errorf("process failed: %w", err)
    }
    
    // 3. ä¿å­˜æ•°æ®
    if err := processor.SaveData(processed); err != nil {
        return fmt.Errorf("save failed: %w", err)
    }
    
    return nil
}

// å…·ä½“å®ç°
type CSVProcessor struct{}

func (p *CSVProcessor) FetchData() ([]byte, error) {
    return os.ReadFile("data.csv")
}

func (p *CSVProcessor) ProcessData(data []byte) ([]byte, error) {
    // CSVç‰¹å®šå¤„ç†
    lines := bytes.Split(data, []byte("\n"))
    return bytes.Join(lines, []byte(",")), nil
}

func (p *CSVProcessor) SaveData(data []byte) error {
    return os.WriteFile("processed.csv", data, 0644)
}

// ä½¿ç”¨
processor := &CSVProcessor{}
ProcessPipeline(processor)
```

---

## 5. Goç‰¹æœ‰æ¨¡å¼

### 5.1 æ¥å£ç»„åˆ

```go
// å°æ¥å£
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type Closer interface {
    Close() error
}

// æ¥å£ç»„åˆ
type ReadWriter interface {
    Reader
    Writer
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}

// ä½¿ç”¨
func Process(rw ReadWriter) {
    data := make([]byte, 1024)
    n, _ := rw.Read(data)
    rw.Write(data[:n])
}
```

### 5.2 å‡½æ•°å¼é€‰é¡¹æ¨¡å¼ (è§2.3)

### 5.3 é”™è¯¯åŒ…è£…æ¨¡å¼

```go
// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
type ValidationError struct {
    Field string
    Value interface{}
    Err   error
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation failed for field %s: %v", e.Field, e.Err)
}

func (e *ValidationError) Unwrap() error {
    return e.Err
}

// é”™è¯¯åŒ…è£…
func ValidateUser(user *User) error {
    if user.Email == "" {
        return &ValidationError{
            Field: "email",
            Value: user.Email,
            Err:   errors.New("required"),
        }
    }
    
    if !strings.Contains(user.Email, "@") {
        return &ValidationError{
            Field: "email",
            Value: user.Email,
            Err:   errors.New("invalid format"),
        }
    }
    
    return nil
}

// é”™è¯¯æ£€æŸ¥
err := ValidateUser(user)
var valErr *ValidationError
if errors.As(err, &valErr) {
    fmt.Printf("Field: %s, Error: %v\n", valErr.Field, valErr.Err)
}
```

### 5.4 ä¸Šä¸‹æ–‡ä¼ é€’æ¨¡å¼

```go
type contextKey string

const (
    userIDKey    contextKey = "userID"
    requestIDKey contextKey = "requestID"
)

// è®¾ç½®ä¸Šä¸‹æ–‡
func WithUserID(ctx context.Context, userID string) context.Context {
    return context.WithValue(ctx, userIDKey, userID)
}

// è·å–ä¸Šä¸‹æ–‡
func GetUserID(ctx context.Context) (string, bool) {
    userID, ok := ctx.Value(userIDKey).(string)
    return userID, ok
}

// ä½¿ç”¨
func HandleRequest(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    ctx = WithUserID(ctx, "user123")
    ctx = context.WithValue(ctx, requestIDKey, uuid.New().String())
    
    ProcessRequest(ctx)
}

func ProcessRequest(ctx context.Context) {
    userID, _ := GetUserID(ctx)
    requestID := ctx.Value(requestIDKey).(string)
    
    log.Printf("Processing request %s for user %s", requestID, userID)
}
```

---

## 6. å¹¶å‘æ¨¡å¼

### 6.1 Worker Pool

```go
type Job struct {
    ID   int
    Data interface{}
}

type Result struct {
    Job   Job
    Value interface{}
    Err   error
}

func WorkerPool(jobs <-chan Job, results chan<- Result, numWorkers int) {
    var wg sync.WaitGroup
    
    // å¯åŠ¨workers
    for i := 0; i < numWorkers; i++ {
        wg.Add(1)
        go func(workerID int) {
            defer wg.Done()
            for job := range jobs {
                // å¤„ç†ä»»åŠ¡
                value, err := process(job.Data)
                results <- Result{
                    Job:   job,
                    Value: value,
                    Err:   err,
                }
            }
        }(i)
    }
    
    // ç­‰å¾…æ‰€æœ‰workerså®Œæˆ
    go func() {
        wg.Wait()
        close(results)
    }()
}

// ä½¿ç”¨
jobs := make(chan Job, 100)
results := make(chan Result, 100)

go WorkerPool(jobs, results, 10)

// å‘é€ä»»åŠ¡
for i := 0; i < 100; i++ {
    jobs <- Job{ID: i, Data: fmt.Sprintf("task-%d", i)}
}
close(jobs)

// æ¥æ”¶ç»“æœ
for result := range results {
    if result.Err != nil {
        log.Printf("Job %d failed: %v", result.Job.ID, result.Err)
    } else {
        log.Printf("Job %d completed: %v", result.Job.ID, result.Value)
    }
}
```

### 6.2 Pipeline æ¨¡å¼

```go
// é˜¶æ®µ1: ç”Ÿæˆæ•°æ®
func generate(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for _, n := range nums {
            out <- n
        }
    }()
    return out
}

// é˜¶æ®µ2: å¹³æ–¹
func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            out <- n * n
        }
    }()
    return out
}

// é˜¶æ®µ3: è¿‡æ»¤
func filter(in <-chan int, threshold int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            if n > threshold {
                out <- n
            }
        }
    }()
    return out
}

// ä½¿ç”¨ - é“¾å¼è°ƒç”¨
nums := generate(1, 2, 3, 4, 5)
squared := square(nums)
filtered := filter(squared, 10)

for n := range filtered {
    fmt.Println(n)  // 16, 25
}
```

### 6.3 Fan-Out, Fan-In æ¨¡å¼

```go
// Fan-Out: ä¸€ä¸ªè¾“å…¥ï¼Œå¤šä¸ªå¤„ç†å™¨
func FanOut(in <-chan int, workers int) []<-chan int {
    outputs := make([]<-chan int, workers)
    for i := 0; i < workers; i++ {
        outputs[i] = process(in)
    }
    return outputs
}

func process(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            // è€—æ—¶å¤„ç†
            time.Sleep(100 * time.Millisecond)
            out <- n * 2
        }
    }()
    return out
}

// Fan-In: å¤šä¸ªè¾“å…¥ï¼Œåˆå¹¶ä¸ºä¸€ä¸ª
func FanIn(channels ...<-chan int) <-chan int {
    out := make(chan int)
    var wg sync.WaitGroup
    
    for _, ch := range channels {
        wg.Add(1)
        go func(c <-chan int) {
            defer wg.Done()
            for n := range c {
                out <- n
            }
        }(ch)
    }
    
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}

// ä½¿ç”¨
input := generate(1, 2, 3, 4, 5, 6, 7, 8)
outputs := FanOut(input, 3)  // 3ä¸ªworkerå¹¶è¡Œå¤„ç†
result := FanIn(outputs...)  // åˆå¹¶ç»“æœ

for n := range result {
    fmt.Println(n)
}
```

### 6.4 è¶…æ—¶å’Œå–æ¶ˆæ¨¡å¼

```go
func DoWorkWithTimeout(ctx context.Context, timeout time.Duration) error {
    ctx, cancel := context.WithTimeout(ctx, timeout)
    defer cancel()
    
    resultCh := make(chan error)
    
    go func() {
        // æ‰§è¡Œè€—æ—¶æ“ä½œ
        time.Sleep(2 * time.Second)
        resultCh <- nil
    }()
    
    select {
    case err := <-resultCh:
        return err
    case <-ctx.Done():
        return ctx.Err()  // è¶…æ—¶æˆ–å–æ¶ˆ
    }
}

// ä½¿ç”¨
ctx := context.Background()
if err := DoWorkWithTimeout(ctx, 1*time.Second); err != nil {
    if errors.Is(err, context.DeadlineExceeded) {
        log.Println("Operation timed out")
    }
}
```

---

## 7. å·¥ç¨‹æœ€ä½³å®è·µ

### 7.1 é¡¹ç›®ç»“æ„

**æ ‡å‡†å¸ƒå±€**:

```text
myproject/
â”œâ”€â”€ cmd/                    # åº”ç”¨ç¨‹åºå…¥å£
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ main.go
â”œâ”€â”€ internal/               # ç§æœ‰ä»£ç 
â”‚   â”œâ”€â”€ domain/            # é¢†åŸŸæ¨¡å‹
â”‚   â”œâ”€â”€ usecase/           # ä¸šåŠ¡é€»è¾‘
â”‚   â”œâ”€â”€ repository/        # æ•°æ®è®¿é—®
â”‚   â””â”€â”€ handler/           # HTTPå¤„ç†å™¨
â”œâ”€â”€ pkg/                    # å¯å…¬å¼€çš„åº“
â”‚   â”œâ”€â”€ logger/
â”‚   â””â”€â”€ validator/
â”œâ”€â”€ api/                    # APIå®šä¹‰
â”‚   â”œâ”€â”€ openapi.yaml
â”‚   â””â”€â”€ proto/
â”œâ”€â”€ configs/                # é…ç½®æ–‡ä»¶
â”‚   â””â”€â”€ config.yaml
â”œâ”€â”€ scripts/                # æ„å»ºè„šæœ¬
â”œâ”€â”€ deployments/            # éƒ¨ç½²é…ç½®
â”‚   â””â”€â”€ k8s/
â”œâ”€â”€ docs/                   # æ–‡æ¡£
â”œâ”€â”€ tests/                  # é¢å¤–çš„æµ‹è¯•
â”œâ”€â”€ go.mod
â”œâ”€â”€ go.sum
â”œâ”€â”€ Makefile
â””â”€â”€ README.md
```

### 7.2 ä¾èµ–æ³¨å…¥

**Wire (Google)**:

```go
// +build wireinject

package main

import "github.com/google/wire"

func InitializeServer() (*Server, error) {
    wire.Build(
        NewDatabase,
        NewRepository,
        NewService,
        NewHandler,
        NewServer,
    )
    return nil, nil
}

// å®ç°
func NewDatabase(config *Config) (*sql.DB, error) {
    return sql.Open("postgres", config.DSN)
}

func NewRepository(db *sql.DB) *Repository {
    return &Repository{db: db}
}

func NewService(repo *Repository) *Service {
    return &Service{repo: repo}
}

func NewHandler(service *Service) *Handler {
    return &Handler{service: service}
}

func NewServer(handler *Handler) *Server {
    return &Server{handler: handler}
}
```

**æ‰‹åŠ¨ä¾èµ–æ³¨å…¥**:

```go
type Container struct {
    DB      *sql.DB
    Repo    *Repository
    Service *Service
    Handler *Handler
}

func NewContainer(config *Config) (*Container, error) {
    c := &Container{}
    
    // åˆå§‹åŒ–ä¾èµ–
    db, err := sql.Open("postgres", config.DSN)
    if err != nil {
        return nil, err
    }
    c.DB = db
    
    c.Repo = &Repository{db: db}
    c.Service = &Service{repo: c.Repo}
    c.Handler = &Handler{service: c.Service}
    
    return c, nil
}

func (c *Container) Close() error {
    return c.DB.Close()
}
```

### 7.3 é…ç½®ç®¡ç†

```go
package config

import (
    "github.com/spf13/viper"
)

type Config struct {
    Server   ServerConfig
    Database DatabaseConfig
    Redis    RedisConfig
    Log      LogConfig
}

type ServerConfig struct {
    Port         int
    ReadTimeout  time.Duration
    WriteTimeout time.Duration
}

type DatabaseConfig struct {
    Host     string
    Port     int
    User     string
    Password string
    Database string
}

func Load() (*Config, error) {
    viper.SetConfigName("config")
    viper.SetConfigType("yaml")
    viper.AddConfigPath("./configs")
    viper.AddConfigPath(".")
    
    // ç¯å¢ƒå˜é‡è¦†ç›–
    viper.AutomaticEnv()
    viper.SetEnvPrefix("APP")
    
    if err := viper.ReadInConfig(); err != nil {
        return nil, err
    }
    
    var config Config
    if err := viper.Unmarshal(&config); err != nil {
        return nil, err
    }
    
    return &config, nil
}

// config.yaml
/*
server:
  port: 8080
  read_timeout: 30s
  write_timeout: 30s

database:
  host: localhost
  port: 5432
  user: postgres
  password: secret
  database: myapp
*/
```

### 7.4 æ—¥å¿—è§„èŒƒ

```go
package logger

import (
    "go.uber.org/zap"
    "go.uber.org/zap/zapcore"
)

var Logger *zap.Logger

func Init(env string) {
    var config zap.Config
    
    if env == "production" {
        config = zap.NewProductionConfig()
    } else {
        config = zap.NewDevelopmentConfig()
        config.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
    }
    
    logger, _ := config.Build()
    Logger = logger
}

// ä½¿ç”¨
func BusinessLogic() {
    logger.Logger.Info("Processing order",
        zap.String("order_id", "123"),
        zap.Int("items", 5),
        zap.Duration("elapsed", time.Since(start)),
    )
}
```

### 7.5 ä¼˜é›…å…³é—­

```go
package main

import (
    "context"
    "os"
    "os/signal"
    "syscall"
    "time"
)

func main() {
    server := &http.Server{Addr: ":8080"}
    
    // å¯åŠ¨æœåŠ¡å™¨
    go func() {
        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatal(err)
        }
    }()
    
    // ç­‰å¾…ä¸­æ–­ä¿¡å·
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Println("Shutting down server...")
    
    // ä¼˜é›…å…³é—­ï¼ˆ5ç§’è¶…æ—¶ï¼‰
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := server.Shutdown(ctx); err != nil {
        log.Fatal("Server forced to shutdown:", err)
    }
    
    log.Println("Server exited")
}
```

---

## 8. æ€§èƒ½ä¼˜åŒ–æ¨¡å¼

### 8.1 å¯¹è±¡æ± 

```go
import "sync"

var bufferPool = sync.Pool{
    New: func() interface{} {
        return new(bytes.Buffer)
    },
}

func ProcessData(data []byte) []byte {
    // ä»æ± ä¸­è·å–
    buf := bufferPool.Get().(*bytes.Buffer)
    defer func() {
        buf.Reset()
        bufferPool.Put(buf)  // å½’è¿˜æ± ä¸­
    }()
    
    // ä½¿ç”¨buffer
    buf.Write(data)
    buf.WriteString(" processed")
    
    return buf.Bytes()
}
```

### 8.2 æ‡’åŠ è½½

```go
type HeavyObject struct {
    data []byte
    once sync.Once
}

func (h *HeavyObject) GetData() []byte {
    h.once.Do(func() {
        // åªåˆå§‹åŒ–ä¸€æ¬¡
        h.data = loadHeavyData()
    })
    return h.data
}
```

### 8.3 æ‰¹é‡å¤„ç†

```go
type BatchProcessor struct {
    batch     []Item
    batchSize int
    flushFn   func([]Item) error
    mu        sync.Mutex
}

func (bp *BatchProcessor) Add(item Item) error {
    bp.mu.Lock()
    defer bp.mu.Unlock()
    
    bp.batch = append(bp.batch, item)
    
    if len(bp.batch) >= bp.batchSize {
        return bp.flush()
    }
    
    return nil
}

func (bp *BatchProcessor) flush() error {
    if len(bp.batch) == 0 {
        return nil
    }
    
    err := bp.flushFn(bp.batch)
    bp.batch = bp.batch[:0]  // æ¸…ç©ºä½†ä¿ç•™å®¹é‡
    return err
}
```

---

## ğŸ“š å‚è€ƒèµ„æº

- [Effective Go](https://go.dev/doc/effective_go)
- [Go Code Review Comments](https://github.com/golang/go/wiki/CodeReviewComments)
- [Uber Go Style Guide](https://github.com/uber-go/guide)
- [Go Proverbs](https://go-proverbs.github.io/)

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Best Practices Team  
**æœ€åæ›´æ–°**: 2025-10-23  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+

---

<div align="center">

**ğŸ¨ ä¼˜é›…è®¾è®¡ Â· ç®€æ´å®ç° Â· é«˜æ•ˆè¿è¡Œ ğŸ¨**-

</div>
