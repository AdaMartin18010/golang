# Go 1.25.3 编程设计模式与最佳实践 (2025)

> **简介**: 系统梳理Go语言的架构模式、设计模式和工程实践，对标2025年10月最新实践  
> **版本**: Go 1.25.3  
> **更新日期**: 2025-10-23  
> **标签**: #设计模式 #架构模式 #最佳实践 #Go惯例

---

## 📋 目录


- [1. 架构模式](#1-架构模式)
  - [1.1 分层架构 (Layered Architecture)](#11-分层架构-layered-architecture)
  - [1.2 六边形架构 (Hexagonal Architecture / Ports & Adapters)](#12-六边形架构-hexagonal-architecture--ports--adapters)
  - [1.3 Clean Architecture](#13-clean-architecture)
  - [1.4 DDD (Domain-Driven Design) 模式](#14-ddd-domain-driven-design-模式)
- [2. 创建型模式](#2-创建型模式)
  - [2.1 单例模式 (Singleton)](#21-单例模式-singleton)
  - [2.2 工厂模式 (Factory)](#22-工厂模式-factory)
  - [2.3 建造者模式 (Builder)](#23-建造者模式-builder)
  - [2.4 原型模式 (Prototype)](#24-原型模式-prototype)
- [3. 结构型模式](#3-结构型模式)
  - [3.1 适配器模式 (Adapter)](#31-适配器模式-adapter)
  - [3.2 装饰器模式 (Decorator)](#32-装饰器模式-decorator)
  - [3.3 代理模式 (Proxy)](#33-代理模式-proxy)
  - [3.4 外观模式 (Facade)](#34-外观模式-facade)
  - [3.5 组合模式 (Composite)](#35-组合模式-composite)
- [4. 行为型模式](#4-行为型模式)
  - [4.1 策略模式 (Strategy)](#41-策略模式-strategy)
  - [4.2 观察者模式 (Observer)](#42-观察者模式-observer)
  - [4.3 责任链模式 (Chain of Responsibility)](#43-责任链模式-chain-of-responsibility)
  - [4.4 模板方法模式 (Template Method)](#44-模板方法模式-template-method)
- [5. Go特有模式](#5-go特有模式)
  - [5.1 接口组合](#51-接口组合)
  - [5.2 函数式选项模式 (见2.3)](#52-函数式选项模式-见23)
  - [5.3 错误包装模式](#53-错误包装模式)
  - [5.4 上下文传递模式](#54-上下文传递模式)
- [6. 并发模式](#6-并发模式)
  - [6.1 Worker Pool](#61-worker-pool)
  - [6.2 Pipeline 模式](#62-pipeline-模式)
  - [6.3 Fan-Out, Fan-In 模式](#63-fan-out-fan-in-模式)
  - [6.4 超时和取消模式](#64-超时和取消模式)
- [7. 工程最佳实践](#7-工程最佳实践)
  - [7.1 项目结构](#71-项目结构)
  - [7.2 依赖注入](#72-依赖注入)
  - [7.3 配置管理](#73-配置管理)
  - [7.4 日志规范](#74-日志规范)
  - [7.5 优雅关闭](#75-优雅关闭)
- [8. 性能优化模式](#8-性能优化模式)
  - [8.1 对象池](#81-对象池)
  - [8.2 懒加载](#82-懒加载)
  - [8.3 批量处理](#83-批量处理)
- [📚 参考资源](#-参考资源)

## 1. 架构模式

### 1.1 分层架构 (Layered Architecture)

**结构**:

```text
┌─────────────────────────────────┐
│  Presentation Layer (API/UI)    │  ← HTTP Handlers, Controllers
├─────────────────────────────────┤
│  Application Layer (Use Cases)  │  ← Business Logic
├─────────────────────────────────┤
│  Domain Layer (Entities)        │  ← Core Business Models
├─────────────────────────────────┤
│  Infrastructure Layer           │  ← Database, External Services
└─────────────────────────────────┘
```

**示例**:

```go
// Domain Layer - 领域实体
package domain

type User struct {
    ID       string
    Email    string
    Name     string
    Password string
}

type UserRepository interface {
    Create(user *User) error
    FindByID(id string) (*User, error)
    FindByEmail(email string) (*User, error)
}

// Application Layer - 用例/服务
package service

type UserService struct {
    repo domain.UserRepository
}

func NewUserService(repo domain.UserRepository) *UserService {
    return &UserService{repo: repo}
}

func (s *UserService) RegisterUser(email, name, password string) (*domain.User, error) {
    // 检查用户是否存在
    existing, _ := s.repo.FindByEmail(email)
    if existing != nil {
        return nil, errors.New("user already exists")
    }
    
    // 创建用户
    user := &domain.User{
        ID:       generateID(),
        Email:    email,
        Name:     name,
        Password: hashPassword(password),
    }
    
    if err := s.repo.Create(user); err != nil {
        return nil, err
    }
    
    return user, nil
}

// Infrastructure Layer - 仓储实现
package postgres

type PostgresUserRepository struct {
    db *sql.DB
}

func (r *PostgresUserRepository) Create(user *domain.User) error {
    query := `INSERT INTO users (id, email, name, password) VALUES ($1, $2, $3, $4)`
    _, err := r.db.Exec(query, user.ID, user.Email, user.Name, user.Password)
    return err
}

// Presentation Layer - HTTP处理器
package handler

type UserHandler struct {
    service *service.UserService
}

func (h *UserHandler) Register(w http.ResponseWriter, r *http.Request) {
    var req RegisterRequest
    json.NewDecoder(r.Body).Decode(&req)
    
    user, err := h.service.RegisterUser(req.Email, req.Name, req.Password)
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    json.NewEncoder(w).Encode(user)
}
```

### 1.2 六边形架构 (Hexagonal Architecture / Ports & Adapters)

**核心思想**: 业务逻辑与外部依赖解耦

```go
// 核心业务逻辑（六边形的中心）
package core

type OrderService struct {
    orderRepo   OrderRepository   // Port (接口)
    paymentGate PaymentGateway    // Port (接口)
    notifier    Notifier          // Port (接口)
}

// Port - 定义抽象接口
type OrderRepository interface {
    Save(order *Order) error
    FindByID(id string) (*Order, error)
}

type PaymentGateway interface {
    ProcessPayment(order *Order) error
}

type Notifier interface {
    SendOrderConfirmation(order *Order) error
}

// 业务逻辑
func (s *OrderService) PlaceOrder(order *Order) error {
    // 1. 验证订单
    if err := order.Validate(); err != nil {
        return err
    }
    
    // 2. 处理支付
    if err := s.paymentGate.ProcessPayment(order); err != nil {
        return fmt.Errorf("payment failed: %w", err)
    }
    
    // 3. 保存订单
    if err := s.orderRepo.Save(order); err != nil {
        return fmt.Errorf("save order failed: %w", err)
    }
    
    // 4. 发送通知
    if err := s.notifier.SendOrderConfirmation(order); err != nil {
        log.Printf("notification failed: %v", err)
    }
    
    return nil
}

// Adapter - PostgreSQL实现
package postgres

type PostgresOrderRepository struct {
    db *sql.DB
}

func (r *PostgresOrderRepository) Save(order *core.Order) error {
    // PostgreSQL具体实现
    return nil
}

// Adapter - Stripe支付实现
package stripe

type StripePaymentGateway struct {
    apiKey string
}

func (g *StripePaymentGateway) ProcessPayment(order *core.Order) error {
    // Stripe API调用
    return nil
}

// Adapter - Email通知实现
package email

type EmailNotifier struct {
    smtp *smtp.Client
}

func (n *EmailNotifier) SendOrderConfirmation(order *core.Order) error {
    // 发送邮件
    return nil
}

// 依赖注入 - 组装应用
func main() {
    db := connectDB()
    
    orderService := &core.OrderService{
        orderRepo:   &postgres.PostgresOrderRepository{db: db},
        paymentGate: &stripe.StripePaymentGateway{apiKey: "sk_test_xxx"},
        notifier:    &email.EmailNotifier{smtp: setupSMTP()},
    }
    
    // 使用服务
    order := &core.Order{/* ... */}
    orderService.PlaceOrder(order)
}
```

### 1.3 Clean Architecture

**分层**:

```text
Entities (Domain)
    ↓
Use Cases (Application)
    ↓
Interface Adapters (Presentation/Infrastructure)
    ↓
Frameworks & Drivers (External)
```

**依赖规则**: 依赖只能从外向内

```go
// Entities Layer
package entity

type Article struct {
    ID        string
    Title     string
    Content   string
    AuthorID  string
    CreatedAt time.Time
}

func (a *Article) Validate() error {
    if a.Title == "" {
        return errors.New("title required")
    }
    return nil
}

// Use Cases Layer
package usecase

type ArticleUseCase struct {
    repo ArticleRepository
}

type ArticleRepository interface {
    Store(article *entity.Article) error
    GetByID(id string) (*entity.Article, error)
}

func (uc *ArticleUseCase) CreateArticle(title, content, authorID string) (*entity.Article, error) {
    article := &entity.Article{
        ID:        uuid.New().String(),
        Title:     title,
        Content:   content,
        AuthorID:  authorID,
        CreatedAt: time.Now(),
    }
    
    if err := article.Validate(); err != nil {
        return nil, err
    }
    
    if err := uc.repo.Store(article); err != nil {
        return nil, err
    }
    
    return article, nil
}

// Interface Adapters Layer
package repository

type PostgresArticleRepository struct {
    db *sqlx.DB
}

func (r *PostgresArticleRepository) Store(article *entity.Article) error {
    query := `
        INSERT INTO articles (id, title, content, author_id, created_at)
        VALUES ($1, $2, $3, $4, $5)
    `
    _, err := r.db.Exec(query, 
        article.ID, article.Title, article.Content, article.AuthorID, article.CreatedAt)
    return err
}

// Presentation Layer
package handler

type ArticleHandler struct {
    useCase *usecase.ArticleUseCase
}

func (h *ArticleHandler) Create(c *gin.Context) {
    var req CreateArticleRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": err.Error()})
        return
    }
    
    article, err := h.useCase.CreateArticle(req.Title, req.Content, req.AuthorID)
    if err != nil {
        c.JSON(500, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(201, article)
}
```

### 1.4 DDD (Domain-Driven Design) 模式

**核心概念**:

- Entity (实体)
- Value Object (值对象)
- Aggregate (聚合)
- Repository (仓储)
- Domain Service (领域服务)

```go
// Value Object - 不可变
package domain

type Money struct {
    amount   int64  // 分为单位
    currency string
}

func NewMoney(amount int64, currency string) Money {
    return Money{amount: amount, currency: currency}
}

func (m Money) Add(other Money) (Money, error) {
    if m.currency != other.currency {
        return Money{}, errors.New("currency mismatch")
    }
    return Money{amount: m.amount + other.amount, currency: m.currency}, nil
}

func (m Money) Amount() int64 {
    return m.amount
}

// Entity - 有唯一标识
type Order struct {
    id         string
    customerID string
    items      []OrderItem
    total      Money
    status     OrderStatus
    createdAt  time.Time
}

func (o *Order) ID() string {
    return o.id
}

func (o *Order) AddItem(productID string, quantity int, price Money) error {
    if o.status != OrderStatusDraft {
        return errors.New("cannot modify confirmed order")
    }
    
    item := OrderItem{
        productID: productID,
        quantity:  quantity,
        price:     price,
    }
    
    o.items = append(o.items, item)
    o.recalculateTotal()
    return nil
}

func (o *Order) Confirm() error {
    if len(o.items) == 0 {
        return errors.New("order has no items")
    }
    o.status = OrderStatusConfirmed
    return nil
}

func (o *Order) recalculateTotal() {
    // 重新计算总额
    var total Money
    for _, item := range o.items {
        itemTotal, _ := item.price.Multiply(item.quantity)
        total, _ = total.Add(itemTotal)
    }
    o.total = total
}

// Aggregate Root
type Customer struct {
    id      string
    name    string
    email   string
    orders  []*Order  // 聚合根管理其下的实体
}

func (c *Customer) PlaceOrder() *Order {
    order := &Order{
        id:         uuid.New().String(),
        customerID: c.id,
        status:     OrderStatusDraft,
        createdAt:  time.Now(),
    }
    c.orders = append(c.orders, order)
    return order
}

// Repository Interface
type OrderRepository interface {
    Save(order *Order) error
    FindByID(id string) (*Order, error)
    FindByCustomerID(customerID string) ([]*Order, error)
}

// Domain Service - 跨聚合的业务逻辑
type OrderPricingService struct {
    discountRepo DiscountRepository
}

func (s *OrderPricingService) ApplyDiscounts(order *Order) error {
    discounts, err := s.discountRepo.FindApplicable(order.customerID)
    if err != nil {
        return err
    }
    
    for _, discount := range discounts {
        order.ApplyDiscount(discount)
    }
    
    return nil
}
```

---

## 2. 创建型模式

### 2.1 单例模式 (Singleton)

**使用场景**: 数据库连接池、配置管理器

```go
// 方式1: 使用sync.Once (推荐)
package database

import "sync"

var (
    instance *Database
    once     sync.Once
)

type Database struct {
    conn *sql.DB
}

func GetInstance() *Database {
    once.Do(func() {
        instance = &Database{
            conn: connectDB(),
        }
    })
    return instance
}

// 方式2: 包级变量初始化
var db = &Database{
    conn: connectDB(),
}

func GetDB() *Database {
    return db
}
```

### 2.2 工厂模式 (Factory)

**简单工厂**:

```go
package storage

type StorageType string

const (
    StorageTypeLocal StorageType = "local"
    StorageTypeS3    StorageType = "s3"
    StorageTypeCOS   StorageType = "cos"
)

type Storage interface {
    Upload(key string, data []byte) error
    Download(key string) ([]byte, error)
}

// 简单工厂
func NewStorage(storageType StorageType, config map[string]string) (Storage, error) {
    switch storageType {
    case StorageTypeLocal:
        return &LocalStorage{basePath: config["base_path"]}, nil
    case StorageTypeS3:
        return &S3Storage{
            bucket: config["bucket"],
            region: config["region"],
        }, nil
    case StorageTypeCOS:
        return &COSStorage{
            bucket: config["bucket"],
        }, nil
    default:
        return nil, fmt.Errorf("unknown storage type: %s", storageType)
    }
}
```

**工厂方法**:

```go
// 抽象工厂接口
type LoggerFactory interface {
    CreateLogger() Logger
}

// 具体工厂
type FileLoggerFactory struct {
    filePath string
}

func (f *FileLoggerFactory) CreateLogger() Logger {
    return &FileLogger{path: f.filePath}
}

type CloudLoggerFactory struct {
    endpoint string
}

func (f *CloudLoggerFactory) CreateLogger() Logger {
    return &CloudLogger{endpoint: f.endpoint}
}

// 使用
func InitLogging(factory LoggerFactory) {
    logger := factory.CreateLogger()
    logger.Info("Application started")
}
```

### 2.3 建造者模式 (Builder)

**函数选项模式** (Go惯用方式):

```go
package server

type Server struct {
    addr         string
    timeout      time.Duration
    maxConn      int
    tlsConfig    *tls.Config
    middleware   []Middleware
}

type Option func(*Server)

func WithAddr(addr string) Option {
    return func(s *Server) {
        s.addr = addr
    }
}

func WithTimeout(timeout time.Duration) Option {
    return func(s *Server) {
        s.timeout = timeout
    }
}

func WithTLS(config *tls.Config) Option {
    return func(s *Server) {
        s.tlsConfig = config
    }
}

func WithMiddleware(mw ...Middleware) Option {
    return func(s *Server) {
        s.middleware = append(s.middleware, mw...)
    }
}

func NewServer(opts ...Option) *Server {
    // 默认值
    s := &Server{
        addr:    ":8080",
        timeout: 30 * time.Second,
        maxConn: 100,
    }
    
    // 应用选项
    for _, opt := range opts {
        opt(s)
    }
    
    return s
}

// 使用
server := NewServer(
    WithAddr(":9000"),
    WithTimeout(60*time.Second),
    WithTLS(tlsConfig),
    WithMiddleware(logging, recovery),
)
```

**链式建造者**:

```go
type QueryBuilder struct {
    table      string
    columns    []string
    where      []string
    orderBy    string
    limit      int
    args       []interface{}
}

func NewQueryBuilder(table string) *QueryBuilder {
    return &QueryBuilder{table: table}
}

func (b *QueryBuilder) Select(columns ...string) *QueryBuilder {
    b.columns = columns
    return b
}

func (b *QueryBuilder) Where(condition string, args ...interface{}) *QueryBuilder {
    b.where = append(b.where, condition)
    b.args = append(b.args, args...)
    return b
}

func (b *QueryBuilder) OrderBy(column string) *QueryBuilder {
    b.orderBy = column
    return b
}

func (b *QueryBuilder) Limit(n int) *QueryBuilder {
    b.limit = n
    return b
}

func (b *QueryBuilder) Build() (string, []interface{}) {
    query := fmt.Sprintf("SELECT %s FROM %s", 
        strings.Join(b.columns, ", "), b.table)
    
    if len(b.where) > 0 {
        query += " WHERE " + strings.Join(b.where, " AND ")
    }
    
    if b.orderBy != "" {
        query += " ORDER BY " + b.orderBy
    }
    
    if b.limit > 0 {
        query += fmt.Sprintf(" LIMIT %d", b.limit)
    }
    
    return query, b.args
}

// 使用
query, args := NewQueryBuilder("users").
    Select("id", "name", "email").
    Where("age > ?", 18).
    Where("status = ?", "active").
    OrderBy("created_at DESC").
    Limit(10).
    Build()
```

### 2.4 原型模式 (Prototype)

```go
// 深拷贝接口
type Cloneable interface {
    Clone() Cloneable
}

type Configuration struct {
    Database DatabaseConfig
    Redis    RedisConfig
    Features map[string]bool
}

func (c *Configuration) Clone() *Configuration {
    clone := &Configuration{
        Database: c.Database,  // 值类型自动拷贝
        Redis:    c.Redis,
        Features: make(map[string]bool, len(c.Features)),
    }
    
    // 深拷贝map
    for k, v := range c.Features {
        clone.Features[k] = v
    }
    
    return clone
}

// 使用
baseConfig := &Configuration{
    Database: DatabaseConfig{Host: "localhost"},
    Features: map[string]bool{"feature_a": true},
}

testConfig := baseConfig.Clone()
testConfig.Database.Host = "test-db"  // 不影响baseConfig
```

---

## 3. 结构型模式

### 3.1 适配器模式 (Adapter)

```go
// 旧接口
type LegacyLogger struct{}

func (l *LegacyLogger) LogMessage(msg string) {
    fmt.Println("[LEGACY]", msg)
}

// 新接口
type Logger interface {
    Info(msg string)
    Error(msg string)
}

// 适配器
type LegacyLoggerAdapter struct {
    legacy *LegacyLogger
}

func (a *LegacyLoggerAdapter) Info(msg string) {
    a.legacy.LogMessage("[INFO] " + msg)
}

func (a *LegacyLoggerAdapter) Error(msg string) {
    a.legacy.LogMessage("[ERROR] " + msg)
}

// 使用
func UseLogger(logger Logger) {
    logger.Info("Application started")
    logger.Error("Something went wrong")
}

legacyLogger := &LegacyLogger{}
adapter := &LegacyLoggerAdapter{legacy: legacyLogger}
UseLogger(adapter)
```

### 3.2 装饰器模式 (Decorator)

```go
// 中间件装饰器
type HandlerFunc func(http.ResponseWriter, *http.Request)

// 日志装饰器
func LoggingMiddleware(next HandlerFunc) HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        log.Printf("Started %s %s", r.Method, r.URL.Path)
        
        next(w, r)
        
        log.Printf("Completed in %v", time.Since(start))
    }
}

// 认证装饰器
func AuthMiddleware(next HandlerFunc) HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        token := r.Header.Get("Authorization")
        if token == "" {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        
        // 验证token
        if !validateToken(token) {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }
        
        next(w, r)
    }
}

// 使用 - 链式装饰
handler := LoggingMiddleware(
    AuthMiddleware(
        func(w http.ResponseWriter, r *http.Request) {
            w.Write([]byte("Hello, World!"))
        },
    ),
)
```

### 3.3 代理模式 (Proxy)

**缓存代理**:

```go
type DataService interface {
    GetData(key string) (string, error)
}

// 真实服务
type RealDataService struct {
    db *sql.DB
}

func (s *RealDataService) GetData(key string) (string, error) {
    // 从数据库获取（耗时操作）
    time.Sleep(100 * time.Millisecond)
    return "data-" + key, nil
}

// 缓存代理
type CachedDataService struct {
    real  DataService
    cache map[string]string
    mu    sync.RWMutex
}

func (s *CachedDataService) GetData(key string) (string, error) {
    // 先查缓存
    s.mu.RLock()
    if cached, ok := s.cache[key]; ok {
        s.mu.RUnlock()
        return cached, nil
    }
    s.mu.RUnlock()
    
    // 缓存未命中，调用真实服务
    data, err := s.real.GetData(key)
    if err != nil {
        return "", err
    }
    
    // 写入缓存
    s.mu.Lock()
    s.cache[key] = data
    s.mu.Unlock()
    
    return data, nil
}
```

### 3.4 外观模式 (Facade)

```go
// 复杂的子系统
type AuthService struct{}
func (s *AuthService) Authenticate(token string) (*User, error) { /* ... */ }

type OrderService struct{}
func (s *OrderService) CreateOrder(userID string, items []Item) (*Order, error) { /* ... */ }

type PaymentService struct{}
func (s *PaymentService) ProcessPayment(order *Order) error { /* ... */ }

type NotificationService struct{}
func (s *NotificationService) SendConfirmation(user *User, order *Order) error { /* ... */ }

// 外观 - 简化接口
type CheckoutFacade struct {
    auth     *AuthService
    order    *OrderService
    payment  *PaymentService
    notifier *NotificationService
}

func (f *CheckoutFacade) Checkout(token string, items []Item) (*Order, error) {
    // 1. 认证
    user, err := f.auth.Authenticate(token)
    if err != nil {
        return nil, err
    }
    
    // 2. 创建订单
    order, err := f.order.CreateOrder(user.ID, items)
    if err != nil {
        return nil, err
    }
    
    // 3. 处理支付
    if err := f.payment.ProcessPayment(order); err != nil {
        return nil, err
    }
    
    // 4. 发送通知
    f.notifier.SendConfirmation(user, order)
    
    return order, nil
}
```

### 3.5 组合模式 (Composite)

```go
// 组件接口
type Component interface {
    Execute() error
}

// 叶子节点
type SimpleTask struct {
    name string
    fn   func() error
}

func (t *SimpleTask) Execute() error {
    fmt.Printf("Executing task: %s\n", t.name)
    return t.fn()
}

// 组合节点
type TaskGroup struct {
    name  string
    tasks []Component
}

func (g *TaskGroup) Add(task Component) {
    g.tasks = append(g.tasks, task)
}

func (g *TaskGroup) Execute() error {
    fmt.Printf("Executing task group: %s\n", g.name)
    for _, task := range g.tasks {
        if err := task.Execute(); err != nil {
            return err
        }
    }
    return nil
}

// 使用
root := &TaskGroup{name: "Deployment"}
root.Add(&SimpleTask{name: "Build", fn: build})
root.Add(&SimpleTask{name: "Test", fn: test})

deploy := &TaskGroup{name: "Deploy"}
deploy.Add(&SimpleTask{name: "Push Image", fn: pushImage})
deploy.Add(&SimpleTask{name: "Update K8s", fn: updateK8s})

root.Add(deploy)
root.Execute()
```

---

## 4. 行为型模式

### 4.1 策略模式 (Strategy)

```go
// 策略接口
type CompressionStrategy interface {
    Compress(data []byte) ([]byte, error)
}

// 具体策略
type GzipCompression struct{}
func (g *GzipCompression) Compress(data []byte) ([]byte, error) {
    var buf bytes.Buffer
    gw := gzip.NewWriter(&buf)
    gw.Write(data)
    gw.Close()
    return buf.Bytes(), nil
}

type ZlibCompression struct{}
func (z *ZlibCompression) Compress(data []byte) ([]byte, error) {
    var buf bytes.Buffer
    zw := zlib.NewWriter(&buf)
    zw.Write(data)
    zw.Close()
    return buf.Bytes(), nil
}

// 上下文
type FileCompressor struct {
    strategy CompressionStrategy
}

func (fc *FileCompressor) SetStrategy(strategy CompressionStrategy) {
    fc.strategy = strategy
}

func (fc *FileCompressor) CompressFile(filename string) error {
    data, _ := os.ReadFile(filename)
    compressed, err := fc.strategy.Compress(data)
    if err != nil {
        return err
    }
    return os.WriteFile(filename+".compressed", compressed, 0644)
}

// 使用
compressor := &FileCompressor{}
compressor.SetStrategy(&GzipCompression{})
compressor.CompressFile("data.txt")
```

### 4.2 观察者模式 (Observer)

```go
// 事件类型
type Event struct {
    Type string
    Data interface{}
}

// 观察者接口
type Observer interface {
    OnEvent(event Event)
}

// 主题
type EventBus struct {
    observers map[string][]Observer
    mu        sync.RWMutex
}

func NewEventBus() *EventBus {
    return &EventBus{
        observers: make(map[string][]Observer),
    }
}

func (eb *EventBus) Subscribe(eventType string, observer Observer) {
    eb.mu.Lock()
    defer eb.mu.Unlock()
    eb.observers[eventType] = append(eb.observers[eventType], observer)
}

func (eb *EventBus) Publish(event Event) {
    eb.mu.RLock()
    observers := eb.observers[event.Type]
    eb.mu.RUnlock()
    
    for _, observer := range observers {
        go observer.OnEvent(event)  // 异步通知
    }
}

// 具体观察者
type EmailNotifier struct{}
func (n *EmailNotifier) OnEvent(event Event) {
    fmt.Printf("Sending email for event: %s\n", event.Type)
}

type LogObserver struct{}
func (l *LogObserver) OnEvent(event Event) {
    fmt.Printf("Logging event: %s - %v\n", event.Type, event.Data)
}

// 使用
bus := NewEventBus()
bus.Subscribe("user.created", &EmailNotifier{})
bus.Subscribe("user.created", &LogObserver{})

bus.Publish(Event{Type: "user.created", Data: User{ID: "123"}})
```

### 4.3 责任链模式 (Chain of Responsibility)

```go
// 处理器接口
type Handler interface {
    SetNext(handler Handler) Handler
    Handle(request *Request) error
}

// 基础处理器
type BaseHandler struct {
    next Handler
}

func (h *BaseHandler) SetNext(handler Handler) Handler {
    h.next = handler
    return handler
}

func (h *BaseHandler) HandleNext(request *Request) error {
    if h.next != nil {
        return h.next.Handle(request)
    }
    return nil
}

// 具体处理器
type AuthHandler struct {
    BaseHandler
}

func (h *AuthHandler) Handle(request *Request) error {
    if request.Token == "" {
        return errors.New("missing auth token")
    }
    fmt.Println("Auth: OK")
    return h.HandleNext(request)
}

type ValidationHandler struct {
    BaseHandler
}

func (h *ValidationHandler) Handle(request *Request) error {
    if request.Data == nil {
        return errors.New("missing request data")
    }
    fmt.Println("Validation: OK")
    return h.HandleNext(request)
}

type LoggingHandler struct {
    BaseHandler
}

func (h *LoggingHandler) Handle(request *Request) error {
    fmt.Printf("Logging request: %+v\n", request)
    return h.HandleNext(request)
}

// 使用
auth := &AuthHandler{}
validation := &ValidationHandler{}
logging := &LoggingHandler{}

auth.SetNext(validation).SetNext(logging)

request := &Request{Token: "abc123", Data: map[string]string{"key": "value"}}
auth.Handle(request)
```

### 4.4 模板方法模式 (Template Method)

```go
// 抽象接口
type DataProcessor interface {
    FetchData() ([]byte, error)
    ProcessData([]byte) ([]byte, error)
    SaveData([]byte) error
}

// 模板方法
func ProcessPipeline(processor DataProcessor) error {
    // 1. 获取数据
    data, err := processor.FetchData()
    if err != nil {
        return fmt.Errorf("fetch failed: %w", err)
    }
    
    // 2. 处理数据
    processed, err := processor.ProcessData(data)
    if err != nil {
        return fmt.Errorf("process failed: %w", err)
    }
    
    // 3. 保存数据
    if err := processor.SaveData(processed); err != nil {
        return fmt.Errorf("save failed: %w", err)
    }
    
    return nil
}

// 具体实现
type CSVProcessor struct{}

func (p *CSVProcessor) FetchData() ([]byte, error) {
    return os.ReadFile("data.csv")
}

func (p *CSVProcessor) ProcessData(data []byte) ([]byte, error) {
    // CSV特定处理
    lines := bytes.Split(data, []byte("\n"))
    return bytes.Join(lines, []byte(",")), nil
}

func (p *CSVProcessor) SaveData(data []byte) error {
    return os.WriteFile("processed.csv", data, 0644)
}

// 使用
processor := &CSVProcessor{}
ProcessPipeline(processor)
```

---

## 5. Go特有模式

### 5.1 接口组合

```go
// 小接口
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type Closer interface {
    Close() error
}

// 接口组合
type ReadWriter interface {
    Reader
    Writer
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}

// 使用
func Process(rw ReadWriter) {
    data := make([]byte, 1024)
    n, _ := rw.Read(data)
    rw.Write(data[:n])
}
```

### 5.2 函数式选项模式 (见2.3)

### 5.3 错误包装模式

```go
// 自定义错误类型
type ValidationError struct {
    Field string
    Value interface{}
    Err   error
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation failed for field %s: %v", e.Field, e.Err)
}

func (e *ValidationError) Unwrap() error {
    return e.Err
}

// 错误包装
func ValidateUser(user *User) error {
    if user.Email == "" {
        return &ValidationError{
            Field: "email",
            Value: user.Email,
            Err:   errors.New("required"),
        }
    }
    
    if !strings.Contains(user.Email, "@") {
        return &ValidationError{
            Field: "email",
            Value: user.Email,
            Err:   errors.New("invalid format"),
        }
    }
    
    return nil
}

// 错误检查
err := ValidateUser(user)
var valErr *ValidationError
if errors.As(err, &valErr) {
    fmt.Printf("Field: %s, Error: %v\n", valErr.Field, valErr.Err)
}
```

### 5.4 上下文传递模式

```go
type contextKey string

const (
    userIDKey    contextKey = "userID"
    requestIDKey contextKey = "requestID"
)

// 设置上下文
func WithUserID(ctx context.Context, userID string) context.Context {
    return context.WithValue(ctx, userIDKey, userID)
}

// 获取上下文
func GetUserID(ctx context.Context) (string, bool) {
    userID, ok := ctx.Value(userIDKey).(string)
    return userID, ok
}

// 使用
func HandleRequest(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    ctx = WithUserID(ctx, "user123")
    ctx = context.WithValue(ctx, requestIDKey, uuid.New().String())
    
    ProcessRequest(ctx)
}

func ProcessRequest(ctx context.Context) {
    userID, _ := GetUserID(ctx)
    requestID := ctx.Value(requestIDKey).(string)
    
    log.Printf("Processing request %s for user %s", requestID, userID)
}
```

---

## 6. 并发模式

### 6.1 Worker Pool

```go
type Job struct {
    ID   int
    Data interface{}
}

type Result struct {
    Job   Job
    Value interface{}
    Err   error
}

func WorkerPool(jobs <-chan Job, results chan<- Result, numWorkers int) {
    var wg sync.WaitGroup
    
    // 启动workers
    for i := 0; i < numWorkers; i++ {
        wg.Add(1)
        go func(workerID int) {
            defer wg.Done()
            for job := range jobs {
                // 处理任务
                value, err := process(job.Data)
                results <- Result{
                    Job:   job,
                    Value: value,
                    Err:   err,
                }
            }
        }(i)
    }
    
    // 等待所有workers完成
    go func() {
        wg.Wait()
        close(results)
    }()
}

// 使用
jobs := make(chan Job, 100)
results := make(chan Result, 100)

go WorkerPool(jobs, results, 10)

// 发送任务
for i := 0; i < 100; i++ {
    jobs <- Job{ID: i, Data: fmt.Sprintf("task-%d", i)}
}
close(jobs)

// 接收结果
for result := range results {
    if result.Err != nil {
        log.Printf("Job %d failed: %v", result.Job.ID, result.Err)
    } else {
        log.Printf("Job %d completed: %v", result.Job.ID, result.Value)
    }
}
```

### 6.2 Pipeline 模式

```go
// 阶段1: 生成数据
func generate(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for _, n := range nums {
            out <- n
        }
    }()
    return out
}

// 阶段2: 平方
func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            out <- n * n
        }
    }()
    return out
}

// 阶段3: 过滤
func filter(in <-chan int, threshold int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            if n > threshold {
                out <- n
            }
        }
    }()
    return out
}

// 使用 - 链式调用
nums := generate(1, 2, 3, 4, 5)
squared := square(nums)
filtered := filter(squared, 10)

for n := range filtered {
    fmt.Println(n)  // 16, 25
}
```

### 6.3 Fan-Out, Fan-In 模式

```go
// Fan-Out: 一个输入，多个处理器
func FanOut(in <-chan int, workers int) []<-chan int {
    outputs := make([]<-chan int, workers)
    for i := 0; i < workers; i++ {
        outputs[i] = process(in)
    }
    return outputs
}

func process(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            // 耗时处理
            time.Sleep(100 * time.Millisecond)
            out <- n * 2
        }
    }()
    return out
}

// Fan-In: 多个输入，合并为一个
func FanIn(channels ...<-chan int) <-chan int {
    out := make(chan int)
    var wg sync.WaitGroup
    
    for _, ch := range channels {
        wg.Add(1)
        go func(c <-chan int) {
            defer wg.Done()
            for n := range c {
                out <- n
            }
        }(ch)
    }
    
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}

// 使用
input := generate(1, 2, 3, 4, 5, 6, 7, 8)
outputs := FanOut(input, 3)  // 3个worker并行处理
result := FanIn(outputs...)  // 合并结果

for n := range result {
    fmt.Println(n)
}
```

### 6.4 超时和取消模式

```go
func DoWorkWithTimeout(ctx context.Context, timeout time.Duration) error {
    ctx, cancel := context.WithTimeout(ctx, timeout)
    defer cancel()
    
    resultCh := make(chan error)
    
    go func() {
        // 执行耗时操作
        time.Sleep(2 * time.Second)
        resultCh <- nil
    }()
    
    select {
    case err := <-resultCh:
        return err
    case <-ctx.Done():
        return ctx.Err()  // 超时或取消
    }
}

// 使用
ctx := context.Background()
if err := DoWorkWithTimeout(ctx, 1*time.Second); err != nil {
    if errors.Is(err, context.DeadlineExceeded) {
        log.Println("Operation timed out")
    }
}
```

---

## 7. 工程最佳实践

### 7.1 项目结构

**标准布局**:

```text
myproject/
├── cmd/                    # 应用程序入口
│   └── server/
│       └── main.go
├── internal/               # 私有代码
│   ├── domain/            # 领域模型
│   ├── usecase/           # 业务逻辑
│   ├── repository/        # 数据访问
│   └── handler/           # HTTP处理器
├── pkg/                    # 可公开的库
│   ├── logger/
│   └── validator/
├── api/                    # API定义
│   ├── openapi.yaml
│   └── proto/
├── configs/                # 配置文件
│   └── config.yaml
├── scripts/                # 构建脚本
├── deployments/            # 部署配置
│   └── k8s/
├── docs/                   # 文档
├── tests/                  # 额外的测试
├── go.mod
├── go.sum
├── Makefile
└── README.md
```

### 7.2 依赖注入

**Wire (Google)**:

```go
// +build wireinject

package main

import "github.com/google/wire"

func InitializeServer() (*Server, error) {
    wire.Build(
        NewDatabase,
        NewRepository,
        NewService,
        NewHandler,
        NewServer,
    )
    return nil, nil
}

// 实现
func NewDatabase(config *Config) (*sql.DB, error) {
    return sql.Open("postgres", config.DSN)
}

func NewRepository(db *sql.DB) *Repository {
    return &Repository{db: db}
}

func NewService(repo *Repository) *Service {
    return &Service{repo: repo}
}

func NewHandler(service *Service) *Handler {
    return &Handler{service: service}
}

func NewServer(handler *Handler) *Server {
    return &Server{handler: handler}
}
```

**手动依赖注入**:

```go
type Container struct {
    DB      *sql.DB
    Repo    *Repository
    Service *Service
    Handler *Handler
}

func NewContainer(config *Config) (*Container, error) {
    c := &Container{}
    
    // 初始化依赖
    db, err := sql.Open("postgres", config.DSN)
    if err != nil {
        return nil, err
    }
    c.DB = db
    
    c.Repo = &Repository{db: db}
    c.Service = &Service{repo: c.Repo}
    c.Handler = &Handler{service: c.Service}
    
    return c, nil
}

func (c *Container) Close() error {
    return c.DB.Close()
}
```

### 7.3 配置管理

```go
package config

import (
    "github.com/spf13/viper"
)

type Config struct {
    Server   ServerConfig
    Database DatabaseConfig
    Redis    RedisConfig
    Log      LogConfig
}

type ServerConfig struct {
    Port         int
    ReadTimeout  time.Duration
    WriteTimeout time.Duration
}

type DatabaseConfig struct {
    Host     string
    Port     int
    User     string
    Password string
    Database string
}

func Load() (*Config, error) {
    viper.SetConfigName("config")
    viper.SetConfigType("yaml")
    viper.AddConfigPath("./configs")
    viper.AddConfigPath(".")
    
    // 环境变量覆盖
    viper.AutomaticEnv()
    viper.SetEnvPrefix("APP")
    
    if err := viper.ReadInConfig(); err != nil {
        return nil, err
    }
    
    var config Config
    if err := viper.Unmarshal(&config); err != nil {
        return nil, err
    }
    
    return &config, nil
}

// config.yaml
/*
server:
  port: 8080
  read_timeout: 30s
  write_timeout: 30s

database:
  host: localhost
  port: 5432
  user: postgres
  password: secret
  database: myapp
*/
```

### 7.4 日志规范

```go
package logger

import (
    "go.uber.org/zap"
    "go.uber.org/zap/zapcore"
)

var Logger *zap.Logger

func Init(env string) {
    var config zap.Config
    
    if env == "production" {
        config = zap.NewProductionConfig()
    } else {
        config = zap.NewDevelopmentConfig()
        config.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
    }
    
    logger, _ := config.Build()
    Logger = logger
}

// 使用
func BusinessLogic() {
    logger.Logger.Info("Processing order",
        zap.String("order_id", "123"),
        zap.Int("items", 5),
        zap.Duration("elapsed", time.Since(start)),
    )
}
```

### 7.5 优雅关闭

```go
package main

import (
    "context"
    "os"
    "os/signal"
    "syscall"
    "time"
)

func main() {
    server := &http.Server{Addr: ":8080"}
    
    // 启动服务器
    go func() {
        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatal(err)
        }
    }()
    
    // 等待中断信号
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Println("Shutting down server...")
    
    // 优雅关闭（5秒超时）
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := server.Shutdown(ctx); err != nil {
        log.Fatal("Server forced to shutdown:", err)
    }
    
    log.Println("Server exited")
}
```

---

## 8. 性能优化模式

### 8.1 对象池

```go
import "sync"

var bufferPool = sync.Pool{
    New: func() interface{} {
        return new(bytes.Buffer)
    },
}

func ProcessData(data []byte) []byte {
    // 从池中获取
    buf := bufferPool.Get().(*bytes.Buffer)
    defer func() {
        buf.Reset()
        bufferPool.Put(buf)  // 归还池中
    }()
    
    // 使用buffer
    buf.Write(data)
    buf.WriteString(" processed")
    
    return buf.Bytes()
}
```

### 8.2 懒加载

```go
type HeavyObject struct {
    data []byte
    once sync.Once
}

func (h *HeavyObject) GetData() []byte {
    h.once.Do(func() {
        // 只初始化一次
        h.data = loadHeavyData()
    })
    return h.data
}
```

### 8.3 批量处理

```go
type BatchProcessor struct {
    batch     []Item
    batchSize int
    flushFn   func([]Item) error
    mu        sync.Mutex
}

func (bp *BatchProcessor) Add(item Item) error {
    bp.mu.Lock()
    defer bp.mu.Unlock()
    
    bp.batch = append(bp.batch, item)
    
    if len(bp.batch) >= bp.batchSize {
        return bp.flush()
    }
    
    return nil
}

func (bp *BatchProcessor) flush() error {
    if len(bp.batch) == 0 {
        return nil
    }
    
    err := bp.flushFn(bp.batch)
    bp.batch = bp.batch[:0]  // 清空但保留容量
    return err
}
```

---

## 📚 参考资源

- [Effective Go](https://go.dev/doc/effective_go)
- [Go Code Review Comments](https://github.com/golang/go/wiki/CodeReviewComments)
- [Uber Go Style Guide](https://github.com/uber-go/guide)
- [Go Proverbs](https://go-proverbs.github.io/)

---

**文档维护者**: Go Best Practices Team  
**最后更新**: 2025-10-23  
**适用版本**: Go 1.25.3+

---

<div align="center">

**🎨 优雅设计 · 简洁实现 · 高效运行 🎨**-

</div>
