# Goè®¾è®¡æ¨¡å¼è¿›é˜¶ä¸“é¢˜ä¸å­¦ä¹ è·¯çº¿å›¾

> **ç®€ä»‹**: Goè®¾è®¡æ¨¡å¼è¿›é˜¶ä¸“é¢˜ï¼ˆæ³›å‹ã€å¹¶å‘ã€åˆ†å¸ƒå¼ã€äº‘åŸç”Ÿï¼‰ä¸å®Œæ•´å­¦ä¹ è·¯çº¿å›¾
> **ç‰ˆæœ¬**: Go 1.23+  
> **éš¾åº¦**: â­â­â­â­â­  
> **æ ‡ç­¾**: #è®¾è®¡æ¨¡å¼ #è¿›é˜¶ä¸“é¢˜ #å­¦ä¹ è·¯çº¿ #æ³›å‹

<!-- TOC START -->
- [Goè®¾è®¡æ¨¡å¼è¿›é˜¶ä¸“é¢˜ä¸å­¦ä¹ è·¯çº¿å›¾](#goè®¾è®¡æ¨¡å¼è¿›é˜¶ä¸“é¢˜ä¸å­¦ä¹ è·¯çº¿å›¾)
  - [1. è¿›é˜¶ä¸“é¢˜](#1-è¿›é˜¶ä¸“é¢˜)
    - [æ³›å‹ä¸è®¾è®¡æ¨¡å¼](#æ³›å‹ä¸è®¾è®¡æ¨¡å¼)
    - [å¹¶å‘/åˆ†å¸ƒå¼/äº‘åŸç”Ÿæ¨¡å¼è¿›é˜¶](#å¹¶å‘åˆ†å¸ƒå¼äº‘åŸç”Ÿæ¨¡å¼è¿›é˜¶)
    - [è®¾è®¡æ¨¡å¼ä¸æ¶æ„æ¼”è¿›](#è®¾è®¡æ¨¡å¼ä¸æ¶æ„æ¼”è¿›)
  - [2. å­¦ä¹ è·¯çº¿å›¾](#2-å­¦ä¹ è·¯çº¿å›¾)
  - [3. èµ„æºæ¨è](#3-èµ„æºæ¨è)
<!-- TOC END -->


## ğŸ“‹ ç›®å½•



- [1. è¿›é˜¶ä¸“é¢˜](#1-è¿›é˜¶ä¸“é¢˜)
  - [æ³›å‹ä¸è®¾è®¡æ¨¡å¼](#æ³›å‹ä¸è®¾è®¡æ¨¡å¼)
    - [æ³›å‹å·¥å‚æ¨¡å¼](#æ³›å‹å·¥å‚æ¨¡å¼)
    - [æ³›å‹ç­–ç•¥æ¨¡å¼](#æ³›å‹ç­–ç•¥æ¨¡å¼)
    - [æ³›å‹ç¼“å­˜ä¸è£…é¥°å™¨](#æ³›å‹ç¼“å­˜ä¸è£…é¥°å™¨)
    - [å·¥ç¨‹å»ºè®®](#å·¥ç¨‹å»ºè®®)
  - [å¹¶å‘/åˆ†å¸ƒå¼/äº‘åŸç”Ÿæ¨¡å¼è¿›é˜¶](#å¹¶å‘åˆ†å¸ƒå¼äº‘åŸç”Ÿæ¨¡å¼è¿›é˜¶)
    - [é«˜çº§å¹¶å‘æ¨¡å¼](#é«˜çº§å¹¶å‘æ¨¡å¼)
    - [åˆ†å¸ƒå¼æ¨¡å¼å®æˆ˜](#åˆ†å¸ƒå¼æ¨¡å¼å®æˆ˜)
    - [äº‘åŸç”Ÿæ¨¡å¼](#äº‘åŸç”Ÿæ¨¡å¼)
    - [å·¥ç¨‹å»ºè®®](#å·¥ç¨‹å»ºè®®)
  - [è®¾è®¡æ¨¡å¼ä¸æ¶æ„æ¼”è¿›](#è®¾è®¡æ¨¡å¼ä¸æ¶æ„æ¼”è¿›)
    - [ä»å•ä½“åˆ°å¾®æœåŠ¡](#ä»å•ä½“åˆ°å¾®æœåŠ¡)
    - [é¢†åŸŸé©±åŠ¨è®¾è®¡ï¼ˆDDDï¼‰ä¸Go](#é¢†åŸŸé©±åŠ¨è®¾è®¡dddä¸go)
    - [CQRSä¸äº‹ä»¶æº¯æº](#cqrsä¸äº‹ä»¶æº¯æº)
    - [æ¶æ„æ¼”è¿›ä¸­çš„æ¨¡å¼é€‰æ‹©](#æ¶æ„æ¼”è¿›ä¸­çš„æ¨¡å¼é€‰æ‹©)
    - [å·¥ç¨‹å»ºè®®](#å·¥ç¨‹å»ºè®®)
- [2. å­¦ä¹ è·¯çº¿å›¾](#2-å­¦ä¹ è·¯çº¿å›¾)
- [3. èµ„æºæ¨è](#3-èµ„æºæ¨è)

## 1. è¿›é˜¶ä¸“é¢˜

### æ³›å‹ä¸è®¾è®¡æ¨¡å¼

Go 1.18+å¼•å…¥æ³›å‹ï¼Œæå¤§ä¸°å¯Œäº†è®¾è®¡æ¨¡å¼çš„ç±»å‹å®‰å…¨ä¸å¤ç”¨èƒ½åŠ›ã€‚

#### æ³›å‹å·¥å‚æ¨¡å¼

```go
// æ³›å‹å·¥å‚æ¥å£
type Factory[T any] interface {
    Create() T
}

// æ³›å‹å¯¹è±¡æ± 
type Pool[T any] struct {
    pool sync.Pool
    new  func() T
}

func NewPool[T any](newFunc func() T) *Pool[T] {
    return &Pool[T]{
        pool: sync.Pool{New: func() any { return newFunc() }},
        new:  newFunc,
    }
}

func (p *Pool[T]) Get() T {
    return p.pool.Get().(T)
}

func (p *Pool[T]) Put(x T) {
    p.pool.Put(x)
}

// ä½¿ç”¨ç¤ºä¾‹
bufferPool := NewPool(func() *bytes.Buffer { return new(bytes.Buffer) })
buf := bufferPool.Get()
defer bufferPool.Put(buf)
```

#### æ³›å‹ç­–ç•¥æ¨¡å¼

```go
// æ³›å‹ç­–ç•¥æ¥å£
type Strategy[T, R any] interface {
    Execute(T) R
}

// ç­–ç•¥ä¸Šä¸‹æ–‡
type Context[T, R any] struct {
    strategy Strategy[T, R]
}

func (c *Context[T, R]) SetStrategy(s Strategy[T, R]) {
    c.strategy = s
}

func (c *Context[T, R]) Execute(input T) R {
    return c.strategy.Execute(input)
}

// ç¤ºä¾‹ï¼šæ’åºç­–ç•¥
type SortStrategy[T constraints.Ordered] interface {
    Sort([]T) []T
}

type QuickSort[T constraints.Ordered] struct{}

func (q QuickSort[T]) Sort(arr []T) []T {
    // å¿«é€Ÿæ’åºå®ç°
    return arr
}
```

#### æ³›å‹ç¼“å­˜ä¸è£…é¥°å™¨

```go
// æ³›å‹LRUç¼“å­˜
type LRUCache[K comparable, V any] struct {
    capacity int
    cache    map[K]*list.Element
    list     *list.List
}

func NewLRUCache[K comparable, V any](capacity int) *LRUCache[K, V] {
    return &LRUCache[K, V]{
        capacity: capacity,
        cache:    make(map[K]*list.Element),
        list:     list.New(),
    }
}

func (c *LRUCache[K, V]) Get(key K) (V, bool) {
    if elem, ok := c.cache[key]; ok {
        c.list.MoveToFront(elem)
        return elem.Value.(V), true
    }
    var zero V
    return zero, false
}
```

#### å·¥ç¨‹å»ºè®®

- **é€‚åº¦ä½¿ç”¨æ³›å‹**ï¼šé¿å…è¿‡åº¦æŠ½è±¡ï¼Œä¼˜å…ˆä½¿ç”¨æ¥å£
- **æ€§èƒ½è€ƒé‡**ï¼šæ³›å‹ç¼–è¯‘æ—¶ä¼šç”Ÿæˆå¤šä»½ä»£ç ï¼Œæ³¨æ„äºŒè¿›åˆ¶å¤§å°
- **ç±»å‹çº¦æŸ**ï¼šåˆç†ä½¿ç”¨`comparable`ã€`constraints.Ordered`ç­‰çº¦æŸ
- **ä¸åå°„å¯¹æ¯”**ï¼šæ³›å‹æä¾›ç¼–è¯‘æœŸç±»å‹å®‰å…¨ï¼Œæ€§èƒ½ä¼˜äºåå°„

---

### å¹¶å‘/åˆ†å¸ƒå¼/äº‘åŸç”Ÿæ¨¡å¼è¿›é˜¶

#### é«˜çº§å¹¶å‘æ¨¡å¼

**1. æ— é”å¹¶å‘æ•°æ®ç»“æ„**

```go
import "sync/atomic"

// æ— é”é˜Ÿåˆ—ï¼ˆç®€åŒ–ç‰ˆï¼‰
type LockFreeQueue struct {
    head atomic.Pointer[node]
    tail atomic.Pointer[node]
}

type node struct {
    value any
    next  atomic.Pointer[node]
}

func (q *LockFreeQueue) Enqueue(v any) {
    n := &node{value: v}
    for {
        tail := q.tail.Load()
        next := tail.next.Load()
        if next == nil {
            if tail.next.CompareAndSwap(nil, n) {
                q.tail.CompareAndSwap(tail, n)
                return
            }
        } else {
            q.tail.CompareAndSwap(tail, next)
        }
    }
}
```

**2. Actoræ¨¡å¼è¿›é˜¶**

```go
// æ”¯æŒä¼˜å…ˆçº§å’Œè¶…æ—¶çš„Actor
type PriorityActor struct {
    mailbox chan Message
    timeout time.Duration
    handler func(Message)
}

type Message struct {
    Priority int
    Data     any
}

func (a *PriorityActor) Start(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            return
        case msg := <-a.mailbox:
            a.handler(msg)
        case <-time.After(a.timeout):
            // å¤„ç†è¶…æ—¶
        }
    }
}
```

#### åˆ†å¸ƒå¼æ¨¡å¼å®æˆ˜

**1. Sagaæ¨¡å¼ä¸åˆ†å¸ƒå¼äº‹åŠ¡**

```go
// Sagaåè°ƒå™¨
type SagaCoordinator struct {
    steps       []SagaStep
    compensates []CompensateFunc
}

type SagaStep func(context.Context) error
type CompensateFunc func(context.Context) error

func (s *SagaCoordinator) Execute(ctx context.Context) error {
    for i, step := range s.steps {
        if err := step(ctx); err != nil {
            // æ‰§è¡Œè¡¥å¿
            for j := i - 1; j >= 0; j-- {
                s.compensates[j](ctx)
            }
            return err
        }
    }
    return nil
}
```

**2. æœåŠ¡ç½‘æ ¼é›†æˆ**

```go
// Istio Sidecaré›†æˆç¤ºä¾‹
type ServiceMeshClient struct {
    client     *http.Client
    traceID    string
    retryPolicy RetryPolicy
}

func (c *ServiceMeshClient) CallWithRetry(ctx context.Context, req *http.Request) (*http.Response, error) {
    // æ³¨å…¥trace header
    req.Header.Set("X-Request-ID", c.traceID)
    req.Header.Set("X-B3-TraceId", c.traceID)
    
    // ç†”æ–­ä¸é‡è¯•
    return c.retryPolicy.Execute(func() (*http.Response, error) {
        return c.client.Do(req.WithContext(ctx))
    })
}
```

#### äº‘åŸç”Ÿæ¨¡å¼

**1. Kubernetes Operatoræ¨¡å¼**

```go
// è‡ªå®šä¹‰CRDæ§åˆ¶å™¨
type MyController struct {
    client    kubernetes.Interface
    workqueue workqueue.RateLimitingInterface
}

func (c *MyController) Reconcile(ctx context.Context, req reconcile.Request) (reconcile.Result, error) {
    // è·å–CRDå®ä¾‹
    obj := &myv1.MyResource{}
    if err := c.client.Get(ctx, req.NamespacedName, obj); err != nil {
        return reconcile.Result{}, err
    }
    
    // è°ƒè°é€»è¾‘ï¼šç¡®ä¿å®é™…çŠ¶æ€ä¸æœŸæœ›çŠ¶æ€ä¸€è‡´
    return c.reconcileResource(ctx, obj)
}
```

**2. å¾®æœåŠ¡å¯è§‚æµ‹æ€§**

```go
import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

// åˆ†å¸ƒå¼è¿½è¸ªé›†æˆ
func handleRequest(ctx context.Context) {
    tracer := otel.Tracer("my-service")
    ctx, span := tracer.Start(ctx, "handleRequest")
    defer span.End()
    
    // ä¸šåŠ¡é€»è¾‘
    span.SetAttributes(attribute.String("user.id", "123"))
    span.AddEvent("processing started")
}
```

#### å·¥ç¨‹å»ºè®®

- **å¹¶å‘**ï¼šä¼˜å…ˆä½¿ç”¨Channelå’ŒMutexï¼Œè°¨æ…ä½¿ç”¨atomicå’Œæ— é”ç»“æ„
- **åˆ†å¸ƒå¼**ï¼šå…³æ³¨ä¸€è‡´æ€§ï¼ˆRaft/Paxosï¼‰ã€å¹‚ç­‰ã€è¡¥å¿ã€ç†”æ–­
- **äº‘åŸç”Ÿ**ï¼šåˆ©ç”¨Kubernetes CRDã€æœåŠ¡ç½‘æ ¼ã€å¯è§‚æµ‹æ€§ä¸‰å¤§æ”¯æŸ±
- **æ€§èƒ½ä¸å¯é æ€§**ï¼šå¼•å…¥OpenTelemetryã€Prometheusã€Jaegerç­‰å·¥å…·

---

### è®¾è®¡æ¨¡å¼ä¸æ¶æ„æ¼”è¿›

#### ä»å•ä½“åˆ°å¾®æœåŠ¡

```mermaid
graph LR
    A[å•ä½“åº”ç”¨] -->|å‚ç›´æ‹†åˆ†| B[åˆ†å±‚æ¶æ„]
    B -->|æ°´å¹³æ‹†åˆ†| C[å¾®æœåŠ¡]
    C -->|æœåŠ¡ç½‘æ ¼| D[Service Mesh]
    D -->|äº‹ä»¶é©±åŠ¨| E[äº‹ä»¶é©±åŠ¨æ¶æ„]
    E -->|æ— æœåŠ¡å™¨| F[Serverless]
```

#### é¢†åŸŸé©±åŠ¨è®¾è®¡ï¼ˆDDDï¼‰ä¸Go

```go
// èšåˆæ ¹
type Order struct {
    id     OrderID
    items  []OrderItem
    status OrderStatus
    events []DomainEvent
}

// é¢†åŸŸäº‹ä»¶
type OrderCreated struct {
    OrderID   OrderID
    Timestamp time.Time
}

// é¢†åŸŸæœåŠ¡
type OrderService struct {
    repo OrderRepository
    bus  EventBus
}

func (s *OrderService) CreateOrder(cmd CreateOrderCommand) error {
    order := NewOrder(cmd)
    order.AddEvent(OrderCreated{OrderID: order.ID()})
    
    if err := s.repo.Save(order); err != nil {
        return err
    }
    
    // å‘å¸ƒé¢†åŸŸäº‹ä»¶
    for _, event := range order.Events() {
        s.bus.Publish(event)
    }
    return nil
}
```

#### CQRSä¸äº‹ä»¶æº¯æº

```go
// å‘½ä»¤æ¨¡å‹ï¼ˆå†™ï¼‰
type WriteModel struct {
    eventStore EventStore
}

func (w *WriteModel) Handle(cmd Command) error {
    events := cmd.Execute()
    return w.eventStore.Append(events...)
}

// æŸ¥è¯¢æ¨¡å‹ï¼ˆè¯»ï¼‰
type ReadModel struct {
    db Database
}

func (r *ReadModel) GetOrderDetail(id OrderID) (*OrderDetail, error) {
    // ä»ä¼˜åŒ–çš„è¯»æ¨¡å‹æŸ¥è¯¢
    return r.db.QueryOrderDetail(id)
}
```

#### æ¶æ„æ¼”è¿›ä¸­çš„æ¨¡å¼é€‰æ‹©

| æ¶æ„é˜¶æ®µ | æ ¸å¿ƒæ¨¡å¼ | Goå®ç°è¦ç‚¹ |
|---------|---------|-----------|
| å•ä½“åº”ç”¨ | åˆ†å±‚ã€å·¥å‚ã€å•ä¾‹ | æ¥å£è§£è€¦ã€ä¾èµ–æ³¨å…¥ |
| å¾®æœåŠ¡ | æœåŠ¡æ³¨å†Œå‘ç°ã€ç†”æ–­ã€é™æµ | gRPCã€etcdã€Hystrix-go |
| äº‹ä»¶é©±åŠ¨ | å‘å¸ƒè®¢é˜…ã€Sagaã€CQRS | Kafkaã€NATSã€EventStore |
| Serverless | å‡½æ•°å¼ã€æ— çŠ¶æ€ã€å†·å¯åŠ¨ä¼˜åŒ– | AWS Lambdaã€å‡å°‘ä¾èµ– |

#### å·¥ç¨‹å»ºè®®

- **æ¸è¿›å¼æ¼”è¿›**ï¼šé¿å…è¿‡æ—©ä¼˜åŒ–ï¼Œæ ¹æ®ä¸šåŠ¡è§„æ¨¡é€‰æ‹©æ¶æ„
- **æ¨¡å¼ç»„åˆ**ï¼šDDD+å¾®æœåŠ¡+äº‹ä»¶é©±åŠ¨æ˜¯æˆç†Ÿç»„åˆ
- **Goä¼˜åŠ¿**ï¼šå¹¶å‘åŸè¯­ã€gRPCåŸç”Ÿæ”¯æŒã€å¿«é€Ÿç¼–è¯‘é€‚åˆäº‘åŸç”Ÿ
- **é¿å…é™·é˜±**ï¼šå¾®æœåŠ¡ä¸æ˜¯é“¶å¼¹ï¼Œå°å›¢é˜Ÿæ…ç”¨

---

## 2. å­¦ä¹ è·¯çº¿å›¾

```mermaid
    A["Goè®¾è®¡æ¨¡å¼å­¦ä¹ è·¯çº¿"]
    A --> B1["åŸºç¡€åŸè¯­"]
    B1 --> C1["æ¥å£/ç»„åˆ"]
    B1 --> C2["å¹¶å‘åŸè¯­"]
    A --> B2["ç»å…¸æ¨¡å¼"]
    B2 --> D1["åˆ›å»ºå‹"]
    B2 --> D2["ç»“æ„å‹"]
    B2 --> D3["è¡Œä¸ºå‹"]
    A --> B3["Goç‰¹è‰²æ¨¡å¼"]
    B3 --> E1["å¹¶å‘å‹"]
    B3 --> E2["åˆ†å¸ƒå¼å‹"]
    B3 --> E3["å·¥ä½œæµå‹"]
    A --> B4["è¿›é˜¶ä¸“é¢˜"]
    B4 --> F1["æ³›å‹ä¸æ¨¡å¼"]
    B4 --> F2["äº‘åŸç”Ÿ/å¾®æœåŠ¡"]
    B4 --> F3["æ¶æ„æ¼”è¿›"]
```

---

## 3. èµ„æºæ¨è

- Goå®˜æ–¹æ–‡æ¡£ï¼š<https://golang.org/doc/>
- Goè®¾è®¡æ¨¡å¼å®æˆ˜ï¼š<https://github.com/senghoo/golang-design-pattern>
- Goå¤œè¯»è®¾è®¡æ¨¡å¼ä¸“æ ï¼š<https://github.com/developer-learning/night-reading-go>
- Goæ³›å‹æœ€ä½³å®è·µï¼š<https://github.com/tkrajina/generic>
- Goå¼€æºé¡¹ç›®å¯¼èˆªï¼š<https://github.com/avelino/awesome-go>
- Goç¤¾åŒºä¸æ¶æ„ä¸“æ ï¼š<https://studygolang.com/ã€https://gocn.vip/>

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ20æ—¥  
**æ–‡æ¡£çŠ¶æ€**: å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
