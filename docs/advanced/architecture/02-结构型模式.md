# Go结构型设计模式

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.23+

---

**字数**: ~18,000字  
**代码示例**: 40+个完整示例  
**实战案例**: 5个端到端案例  
**适用人群**: 中高级Go开发者

---

## 📋 目录


- [第一部分：理论基础](#第一部分理论基础)
  - [结构型模式的价值](#结构型模式的价值)
    - [为什么需要结构型模式？](#为什么需要结构型模式)
  - [结构型模式分类](#结构型模式分类)
  - [选择结构型模式的决策树](#选择结构型模式的决策树)
- [第二部分：适配器模式深度实战](#第二部分适配器模式深度实战)
  - [适配器模式核心原理](#适配器模式核心原理)
    - [什么是适配器模式？](#什么是适配器模式)
  - [适配器模式的3种实现](#适配器模式的3种实现)
    - [实现1：对象适配器（推荐⭐⭐⭐⭐⭐）](#实现1对象适配器推荐)
    - [实现2：类适配器（Go中不推荐）](#实现2类适配器go中不推荐)
    - [实现3：双向适配器](#实现3双向适配器)
  - [实战案例1：数据库适配器](#实战案例1数据库适配器)
    - [场景](#场景)
    - [[完整实现](#完整实现)    - [优势](#优势)
  - [适配器模式最佳实践](#适配器模式最佳实践)
    - [✅[✅ DO](#do)   - [❌ DON'T](#dont)
- [第三部分：装饰器模式深度实战](#第三部分装饰器模式深度实战)
  - [装饰器模式核心原理](#装饰器模式核心原理)
    - [什么是装饰器模式？](#什么是装饰器模式)
  - [装饰器模式完整实现](#装饰器模式完整实现)
    - [基础装饰器](#基础装饰器)
  - [实战案例2：HTTP客户端装饰器](#实战案例2http客户端装饰器)
    - [场景3](#场景3)
    - [完整实现3](#完整实现3)
    - [输出示例](#输出示例)
  - [装饰器模式最佳实践](#装饰器模式最佳实践)
    - [✅ DO4](#do4)
    - [❌ DON'T4](#dont4)
- [第四部分：代理模式深度实战](#第四部分代理模式深度实战)
  - [代理模式核心原理](#代理模式核心原理)
    - [什么是代理模式？](#什么是代理模式)
  - [实战案例3：数据库查询代理（缓存+延迟加载）](#实战案例3数据库查询代理缓存+延迟加载)
    - [场景5](#场景5)
    - [完整实现5](#完整实现5)
    - [性能提升](#性能提升)
  - [实战案例4：RPC服务代理](#实战案例4rpc服务代理)
    - [场景6](#场景6)
    - [完整实现6](#完整实现6)
- [第五部分：外观模式与组合模式](#第五部分外观模式与组合模式)
  - [外观模式（Facade）](#外观模式facade)
    - [什么是外观模式？](#什么是外观模式)
    - [实战案例5：订单处理外观](#实战案例5订单处理外观)
  - [组合模式（Composite）](#组合模式composite)
    - [什么是组合模式？](#什么是组合模式)
    - [实战：文件系统](#实战文件系统)
- [第六部分：其他结构型模式](#第六部分其他结构型模式)
  - [桥接模式（Bridge）](#桥接模式bridge)
    - [简要说明](#简要说明)
    - [示例：跨平台通知](#示例跨平台通知)
  - [享元模式（Flyweight）](#享元模式flyweight)
    - [简要说明7](#简要说明7)
    - [示例：图标缓存](#示例图标缓存)
- [第七部分：实战案例](#第七部分实战案例)
  - [综合案例：微服务网关](#综合案例微服务网关)
    - [场景8](#场景8)
    - [完整实现8](#完整实现8)
- [第八部分：最佳实践](#第八部分最佳实践)
  - [结构型模式选择指南](#结构型模式选择指南)
    - [决策表](#决策表)
  - [常见陷阱](#常见陷阱)
    - [陷阱1：过度使用装饰器](#陷阱1过度使用装饰器)
    - [陷阱2：适配器包含业务逻辑](#陷阱2适配器包含业务逻辑)
    - [陷阱3：外观过于复杂](#陷阱3外观过于复杂)
- [🎯 总结](#总结)
  - [核心要点](#核心要点)
  - [性能对比](#性能对比)
- [📚 参考资源](#参考资源)

## 第一部分：理论基础

### 结构型模式的价值

#### 为什么需要结构型模式？

**问题示例**:

```go
// ❌ 直接依赖具体实现的问题
type OrderService struct {
    mysqlDB *MySQLDatabase  // 硬编码MySQL
    redisCache *RedisCache   // 硬编码Redis
    logger *FileLogger       // 硬编码文件日志
}

// 问题：
// 1. 难以切换实现（如从MySQL切到PostgreSQL）
// 2. 难以添加功能（如添加日志）
// 3. 难以测试（依赖真实数据库）
// 4. 组件间紧耦合
```

**使用结构型模式后**:

```go
// ✅ 使用接口+适配器+装饰器
type OrderService struct {
    db Database         // 接口，可适配任何数据库
    cache Cache         // 接口，可适配任何缓存
    logger Logger       // 接口，可装饰增强
}

// 优势：
// 1. 可以轻松切换实现
// 2. 可以动态添加功能
// 3. 易于mock测试
// 4. 松耦合设计
```

---

### 结构型模式分类

| 模式 | 意图 | 适用场景 | 复杂度 |
|------|------|---------|--------|
| **适配器** | 接口转换 | 系统集成、遗留代码 | ⭐⭐ |
| **装饰器** | 动态扩展功能 | 日志、缓存、权限 | ⭐⭐⭐ |
| **代理** | 控制访问 | 延迟加载、缓存、RPC | ⭐⭐⭐ |
| **外观** | 简化接口 | 复杂子系统封装 | ⭐⭐ |
| **组合** | 树形结构 | 文件系统、组织架构 | ⭐⭐⭐ |
| **桥接** | 抽象与实现分离 | 多维度变化 | ⭐⭐⭐⭐ |
| **享元** | 共享对象 | 内存优化、对象池 | ⭐⭐⭐ |

---

### 选择结构型模式的决策树

```text
你的需求是什么？
│
├─ 需要接口转换/兼容？
│  └─ 是 → 适配器模式
│      - 集成第三方库
│      - 适配遗留代码
│
├─ 需要动态添加功能？
│  └─ 是 → 装饰器模式
│      - 添加日志
│      - 添加缓存
│      - 添加权限检查
│
├─ 需要控制对象访问？
│  └─ 是 → 代理模式
│      - 延迟加载
│      - 访问控制
│      - 远程调用
│
├─ 需要简化复杂子系统？
│  └─ 是 → 外观模式
│      - 封装复杂API
│      - 统一入口
│
├─ 需要处理树形结构？
│  └─ 是 → 组合模式
│      - 文件系统
│      - UI组件树
│
└─ 需要共享大量对象？
   └─ 是 → 享元模式
       - 对象池
       - 缓存复用
```

---

## 第二部分：适配器模式深度实战

### 适配器模式核心原理

#### 什么是适配器模式？

**定义**: 将一个类的接口转换成客户希望的另一个接口，使原本接口不兼容的类可以一起工作。

**现实类比**:

- 电源适配器（220V → 5V）
- Type-C转USB转接头
- 语言翻译器

**UML结构**:

```text
Target Interface  ←← Client
     ↑
     │ implements
  Adapter
     │ has-a
     ↓
  Adaptee
```

---

### 适配器模式的3种实现

#### 实现1：对象适配器（推荐⭐⭐⭐⭐⭐）

```go
package adapter

// Target 目标接口（客户期望的接口）
type Target interface {
    Request() string
}

// Adaptee 被适配者（现有的不兼容接口）
type Adaptee struct {
    specificData string
}

func (a *Adaptee) SpecificRequest() string {
    return "Adaptee: " + a.specificData
}

// Adapter 适配器（对象组合方式）
type Adapter struct {
    adaptee *Adaptee
}

func NewAdapter(adaptee *Adaptee) Target {
    return &Adapter{adaptee: adaptee}
}

func (a *Adapter) Request() string {
    // 转换接口调用
    return a.adaptee.SpecificRequest()
}

// 使用示例
func Example() {
    adaptee := &Adaptee{specificData: "Some Data"}
    adapter := NewAdapter(adaptee)
    
    // 客户端使用统一的Target接口
    result := adapter.Request()
    fmt.Println(result)  // 输出: Adaptee: Some Data
}
```

**优点**:

- ✅ 灵活，符合组合优于继承原则
- ✅ 可以适配多个Adaptee
- ✅ 易于测试和mock

---

#### 实现2：类适配器（Go中不推荐）

```go
// Go没有继承，用嵌入模拟类适配器
type ClassAdapter struct {
    Adaptee  // 嵌入
}

func (c *ClassAdapter) Request() string {
    return c.SpecificRequest()
}
```

**问题**:

- ⚠️ Go没有多继承
- ⚠️ 不够灵活
- ⚠️ 违反组合优于继承原则

---

#### 实现3：双向适配器

```go
// 双向适配器（支持Target和Adaptee互相调用）
type TwoWayAdapter struct {
    adaptee *Adaptee
}

func (t *TwoWayAdapter) Request() string {
    return t.adaptee.SpecificRequest()
}

func (t *TwoWayAdapter) SpecificRequest() string {
    return t.Request()
}
```

---

### 实战案例1：数据库适配器

#### 场景

- 系统使用MySQL数据库
- 需要支持PostgreSQL、MongoDB
- 不修改业务代码

#### 完整实现

```go
package database

import (
    "context"
    "database/sql"
    "errors"
    
    _ "github.com/go-sql-driver/mysql"
    _ "github.com/lib/pq"
    "go.mongodb.org/mongo-driver/mongo"
)

// Database 统一数据库接口
type Database interface {
    Query(ctx context.Context, query string, args ...interface{}) ([]map[string]interface{}, error)
    Exec(ctx context.Context, query string, args ...interface{}) error
    Close() error
}

// ===== MySQL适配器 =====
type MySQLAdapter struct {
    db *sql.DB
}

func NewMySQLAdapter(dsn string) (Database, error) {
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        return nil, err
    }
    return &MySQLAdapter{db: db}, nil
}

func (m *MySQLAdapter) Query(ctx context.Context, query string, args ...interface{}) ([]map[string]interface{}, error) {
    rows, err := m.db.QueryContext(ctx, query, args...)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    columns, _ := rows.Columns()
    results := make([]map[string]interface{}, 0)
    
    for rows.Next() {
        values := make([]interface{}, len(columns))
        valuePtrs := make([]interface{}, len(columns))
        for i := range values {
            valuePtrs[i] = &values[i]
        }
        
        if err := rows.Scan(valuePtrs...); err != nil {
            return nil, err
        }
        
        row := make(map[string]interface{})
        for i, col := range columns {
            row[col] = values[i]
        }
        results = append(results, row)
    }
    
    return results, nil
}

func (m *MySQLAdapter) Exec(ctx context.Context, query string, args ...interface{}) error {
    _, err := m.db.ExecContext(ctx, query, args...)
    return err
}

func (m *MySQLAdapter) Close() error {
    return m.db.Close()
}

// ===== PostgreSQL适配器 =====
type PostgreSQLAdapter struct {
    db *sql.DB
}

func NewPostgreSQLAdapter(dsn string) (Database, error) {
    db, err := sql.Open("postgres", dsn)
    if err != nil {
        return nil, err
    }
    return &PostgreSQLAdapter{db: db}, nil
}

func (p *PostgreSQLAdapter) Query(ctx context.Context, query string, args ...interface{}) ([]map[string]interface{}, error) {
    // 实现与MySQL类似，但可能有PostgreSQL特定的优化
    rows, err := p.db.QueryContext(ctx, query, args...)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    // ... 类似MySQL的实现
    return nil, nil
}

func (p *PostgreSQLAdapter) Exec(ctx context.Context, query string, args ...interface{}) error {
    _, err := p.db.ExecContext(ctx, query, args...)
    return err
}

func (p *PostgreSQLAdapter) Close() error {
    return p.db.Close()
}

// ===== MongoDB适配器 =====
type MongoDBAdapter struct {
    client *mongo.Client
    dbName string
}

func NewMongoDBAdapter(uri, dbName string) (Database, error) {
    ctx := context.Background()
    client, err := mongo.Connect(ctx, options.Client().ApplyURI(uri))
    if err != nil {
        return nil, err
    }
    return &MongoDBAdapter{client: client, dbName: dbName}, nil
}

func (m *MongoDBAdapter) Query(ctx context.Context, query string, args ...interface{}) ([]map[string]interface{}, error) {
    // MongoDB使用不同的查询语法，适配器负责转换
    // 这里简化处理
    return nil, errors.New("MongoDB adapter: query not implemented")
}

func (m *MongoDBAdapter) Exec(ctx context.Context, query string, args ...interface{}) error {
    return errors.New("MongoDB adapter: exec not implemented")
}

func (m *MongoDBAdapter) Close() error {
    return m.client.Disconnect(context.Background())
}

// ===== 数据库工厂 =====
func NewDatabase(dbType, dsn string) (Database, error) {
    switch dbType {
    case "mysql":
        return NewMySQLAdapter(dsn)
    case "postgres":
        return NewPostgreSQLAdapter(dsn)
    case "mongodb":
        return NewMongoDBAdapter(dsn, "mydb")
    default:
        return nil, errors.New("unsupported database type")
    }
}

// ===== 业务代码（无需修改）=====
type UserRepository struct {
    db Database
}

func NewUserRepository(db Database) *UserRepository {
    return &UserRepository{db: db}
}

func (r *UserRepository) GetUser(ctx context.Context, id int) (map[string]interface{}, error) {
    results, err := r.db.Query(ctx, "SELECT * FROM users WHERE id = ?", id)
    if err != nil {
        return nil, err
    }
    if len(results) == 0 {
        return nil, errors.New("user not found")
    }
    return results[0], nil
}

// ===== 使用示例 =====
func main() {
    ctx := context.Background()
    
    // 方式1：使用MySQL
    mysqlDB, _ := NewDatabase("mysql", "user:pass@tcp(localhost:3306)/mydb")
    defer mysqlDB.Close()
    
    repo := NewUserRepository(mysqlDB)
    user, _ := repo.GetUser(ctx, 123)
    fmt.Println("MySQL User:", user)
    
    // 方式2：切换到PostgreSQL（业务代码无需修改）
    pgDB, _ := NewDatabase("postgres", "postgres://user:pass@localhost/mydb")
    defer pgDB.Close()
    
    repo = NewUserRepository(pgDB)
    user, _ = repo.GetUser(ctx, 123)
    fmt.Println("PostgreSQL User:", user)
}
```

#### 优势

- ✅ 业务代码完全解耦
- ✅ 可以轻松切换数据库
- ✅ 易于添加新数据库支持
- ✅ 统一的错误处理

---

### 适配器模式最佳实践

#### ✅ DO

1. **使用接口定义契约**:

    ```go
    // ✅ 正确：定义清晰的接口
    type PaymentGateway interface {
        Pay(amount float64) error
        Refund(transactionID string) error
    }
    ```

2. **保持适配器简单**:

    ```go
    // ✅ 正确：适配器只做转换
    type StripeAdapter struct {
        client *stripe.Client
    }
    
    func (s *StripeAdapter) Pay(amount float64) error {
        // 只做参数转换和调用
        return s.client.Charges.New(&stripe.ChargeParams{
            Amount: stripe.Int64(int64(amount * 100)),
        })
    }
    ```

#### ❌ DON'T

1. **不要在适配器中添加业务逻辑**:

    ```go
    // ❌ 错误：适配器不应包含业务逻辑
    func (s *StripeAdapter) Pay(amount float64) error {
        if amount < 10 {  // ← 业务规则应该在service层
            return errors.New("amount too small")
        }
        return s.client.Pay(amount)
    }
    ```

---

## 第三部分：装饰器模式深度实战

### 装饰器模式核心原理

#### 什么是装饰器模式？

**定义**: 动态地给对象添加额外的职责，就增加功能来说，装饰器模式比生成子类更为灵活。

**核心思想**:

- 对象组合而非继承
- 透明包装（装饰器和原对象实现相同接口）
- 可以多层嵌套

**UML结构**:

```text
Component Interface
     ↑
     ├─ ConcreteComponent
     └─ Decorator (has-a Component)
            ↑
            ├─ ConcreteDecoratorA
            └─ ConcreteDecoratorB
```

---

### 装饰器模式完整实现

#### 基础装饰器

```go
package decorator

import (
    "fmt"
    "time"
)

// Component 组件接口
type Component interface {
    Operation() string
}

// ConcreteComponent 具体组件
type ConcreteComponent struct {
    data string
}

func (c *ConcreteComponent) Operation() string {
    return c.data
}

// Decorator 装饰器基类
type Decorator struct {
    component Component
}

func (d *Decorator) Operation() string {
    if d.component != nil {
        return d.component.Operation()
    }
    return ""
}

// ===== 具体装饰器1：日志装饰器 =====
type LoggingDecorator struct {
    Decorator
}

func NewLoggingDecorator(c Component) Component {
    return &LoggingDecorator{
        Decorator: Decorator{component: c},
    }
}

func (l *LoggingDecorator) Operation() string {
    start := time.Now()
    result := l.Decorator.Operation()
    elapsed := time.Since(start)
    
    fmt.Printf("[LOG] Operation took %v, result: %s\n", elapsed, result)
    return result
}

// ===== 具体装饰器2：缓存装饰器 =====
type CachingDecorator struct {
    Decorator
    cache map[string]string
}

func NewCachingDecorator(c Component) Component {
    return &CachingDecorator{
        Decorator: Decorator{component: c},
        cache:     make(map[string]string),
    }
}

func (c *CachingDecorator) Operation() string {
    key := "operation"
    if cached, exists := c.cache[key]; exists {
        fmt.Println("[CACHE] Hit!")
        return cached
    }
    
    result := c.Decorator.Operation()
    c.cache[key] = result
    fmt.Println("[CACHE] Miss, cached result")
    return result
}

// ===== 使用示例：多层装饰 =====
func Example() {
    // 原始组件
    component := &ConcreteComponent{data: "Hello World"}
    
    // 添加日志装饰
    logged := NewLoggingDecorator(component)
    
    // 再添加缓存装饰
    cached := NewCachingDecorator(logged)
    
    // 调用
    fmt.Println(cached.Operation())  // 第一次：CACHE Miss → LOG
    fmt.Println(cached.Operation())  // 第二次：CACHE Hit
}
```

---

### 实战案例2：HTTP客户端装饰器

#### 场景3

- 基础HTTP客户端
- 需要添加：重试、日志、监控、超时
- 功能可灵活组合

#### 完整实现3

```go
package httpclient

import (
    "context"
    "fmt"
    "io"
    "net/http"
    "time"
)

// HTTPClient HTTP客户端接口
type HTTPClient interface {
    Do(ctx context.Context, req *http.Request) (*http.Response, error)
}

// ===== 基础HTTP客户端 =====
type BaseHTTPClient struct {
    client *http.Client
}

func NewBaseHTTPClient(timeout time.Duration) HTTPClient {
    return &BaseHTTPClient{
        client: &http.Client{
            Timeout: timeout,
        },
    }
}

func (b *BaseHTTPClient) Do(ctx context.Context, req *http.Request) (*http.Response, error) {
    return b.client.Do(req.WithContext(ctx))
}

// ===== 装饰器1：重试装饰器 =====
type RetryDecorator struct {
    client     HTTPClient
    maxRetries int
    retryDelay time.Duration
}

func NewRetryDecorator(client HTTPClient, maxRetries int, retryDelay time.Duration) HTTPClient {
    return &RetryDecorator{
        client:     client,
        maxRetries: maxRetries,
        retryDelay: retryDelay,
    }
}

func (r *RetryDecorator) Do(ctx context.Context, req *http.Request) (*http.Response, error) {
    var lastErr error
    
    for i := 0; i <= r.maxRetries; i++ {
        resp, err := r.client.Do(ctx, req)
        
        // 成功或非临时错误，直接返回
        if err == nil || !isTemporaryError(err) {
            return resp, err
        }
        
        lastErr = err
        
        // 最后一次不重试
        if i < r.maxRetries {
            fmt.Printf("[RETRY] Attempt %d failed, retrying after %v...\n", i+1, r.retryDelay)
            time.Sleep(r.retryDelay)
        }
    }
    
    return nil, fmt.Errorf("max retries exceeded: %w", lastErr)
}

func isTemporaryError(err error) bool {
    // 简化：实际应判断具体错误类型
    return true
}

// ===== 装饰器2：日志装饰器 =====
type LoggingDecorator struct {
    client HTTPClient
}

func NewLoggingDecorator(client HTTPClient) HTTPClient {
    return &LoggingDecorator{client: client}
}

func (l *LoggingDecorator) Do(ctx context.Context, req *http.Request) (*http.Response, error) {
    start := time.Now()
    
    fmt.Printf("[HTTP] --> %s %s\n", req.Method, req.URL)
    
    resp, err := l.client.Do(ctx, req)
    
    elapsed := time.Since(start)
    if err != nil {
        fmt.Printf("[HTTP] <-- ERROR: %v (took %v)\n", err, elapsed)
        return nil, err
    }
    
    fmt.Printf("[HTTP] <-- %d %s (took %v)\n", resp.StatusCode, resp.Status, elapsed)
    return resp, nil
}

// ===== 装饰器3：监控装饰器 =====
type MetricsDecorator struct {
    client         HTTPClient
    requestCount   int64
    totalDuration  time.Duration
}

func NewMetricsDecorator(client HTTPClient) HTTPClient {
    return &MetricsDecorator{client: client}
}

func (m *MetricsDecorator) Do(ctx context.Context, req *http.Request) (*http.Response, error) {
    start := time.Now()
    resp, err := m.client.Do(ctx, req)
    duration := time.Since(start)
    
    m.requestCount++
    m.totalDuration += duration
    
    fmt.Printf("[METRICS] Total requests: %d, Avg duration: %v\n", 
        m.requestCount, m.totalDuration/time.Duration(m.requestCount))
    
    return resp, err
}

// ===== 装饰器4：缓存装饰器 =====
type CacheDecorator struct {
    client HTTPClient
    cache  map[string]*http.Response
}

func NewCacheDecorator(client HTTPClient) HTTPClient {
    return &CacheDecorator{
        client: client,
        cache:  make(map[string]*http.Response),
    }
}

func (c *CacheDecorator) Do(ctx context.Context, req *http.Request) (*http.Response, error) {
    // 只缓存GET请求
    if req.Method != http.MethodGet {
        return c.client.Do(ctx, req)
    }
    
    key := req.URL.String()
    if cached, exists := c.cache[key]; exists {
        fmt.Println("[CACHE] Hit!")
        return cached, nil
    }
    
    resp, err := c.client.Do(ctx, req)
    if err == nil && resp.StatusCode == http.StatusOK {
        c.cache[key] = resp
        fmt.Println("[CACHE] Stored")
    }
    
    return resp, err
}

// ===== 使用示例：灵活组合装饰器 =====
func Example() {
    ctx := context.Background()
    
    // 场景1：基础客户端 + 日志
    client1 := NewLoggingDecorator(
        NewBaseHTTPClient(30 * time.Second),
    )
    
    // 场景2：基础客户端 + 重试 + 日志
    client2 := NewLoggingDecorator(
        NewRetryDecorator(
            NewBaseHTTPClient(30 * time.Second),
            3,              // 最多重试3次
            2 * time.Second, // 重试间隔2秒
        ),
    )
    
    // 场景3：完整装饰链（基础 + 缓存 + 重试 + 日志 + 监控）
    client3 := NewMetricsDecorator(
        NewLoggingDecorator(
            NewRetryDecorator(
                NewCacheDecorator(
                    NewBaseHTTPClient(30 * time.Second),
                ),
                3,
                2 * time.Second,
            ),
        ),
    )
    
    // 发送请求
    req, _ := http.NewRequest("GET", "https://api.example.com/users", nil)
    resp, err := client3.Do(ctx, req)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    defer resp.Body.Close()
    
    body, _ := io.ReadAll(resp.Body)
    fmt.Println("Response:", string(body))
}
```

#### 输出示例

```text
[CACHE] Stored
[RETRY] Attempt 1 failed, retrying after 2s...
[HTTP] --> GET https://api.example.com/users
[HTTP] <-- 200 OK (took 1.2s)
[METRICS] Total requests: 1, Avg duration: 1.2s
```

---

### 装饰器模式最佳实践

#### ✅ DO4

1. **保持装饰器单一职责**:

    ```go
    // ✅ 正确：每个装饰器只做一件事
    type LoggingDecorator struct { ... }
    type CachingDecorator struct { ... }
    ```

2. **装饰器可以组合**:

    ```go
    // ✅ 正确：多层装饰
    client := NewLogging(NewRetry(NewCache(baseClient)))
    ```

#### ❌ DON'T4

1. **不要在装饰器中修改核心行为**:

    ```go
    // ❌ 错误：装饰器改变了返回值类型
    func (d *BadDecorator) Operation() int {  // 返回类型变了
        result := d.component.Operation()  // string
        return len(result)  // ← 改变了行为
    }
    ```

---

## 第四部分：代理模式深度实战

### 代理模式核心原理

#### 什么是代理模式？

**定义**: 为其他对象提供一种代理以控制对这个对象的访问。

**代理类型**:

1. **远程代理** - RPC、gRPC
2. **虚拟代理** - 延迟加载
3. **保护代理** - 权限控制
4. **缓存代理** - 结果缓存

---

### 实战案例3：数据库查询代理（缓存+延迟加载）

#### 场景5

- 数据库查询性能瓶颈
- 需要添加缓存层
- 需要延迟连接

#### 完整实现5

```go
package dbproxy

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// Database 数据库接口
type Database interface {
    Query(ctx context.Context, sql string, args ...interface{}) ([]map[string]interface{}, error)
}

// ===== 真实数据库 =====
type RealDatabase struct {
    dsn string
    conn interface{}  // 实际的数据库连接
}

func NewRealDatabase(dsn string) *RealDatabase {
    return &RealDatabase{dsn: dsn}
}

func (r *RealDatabase) connect() error {
    if r.conn != nil {
        return nil
    }
    
    fmt.Println("[DB] Connecting to database...")
    time.Sleep(100 * time.Millisecond)  // 模拟连接延迟
    r.conn = "fake connection"
    fmt.Println("[DB] Connected!")
    return nil
}

func (r *RealDatabase) Query(ctx context.Context, sql string, args ...interface{}) ([]map[string]interface{}, error) {
    if err := r.connect(); err != nil {
        return nil, err
    }
    
    fmt.Printf("[DB] Executing query: %s\n", sql)
    time.Sleep(50 * time.Millisecond)  // 模拟查询延迟
    
    // 模拟返回结果
    return []map[string]interface{}{
        {"id": 1, "name": "User1"},
    }, nil
}

// ===== 缓存代理 =====
type CacheProxy struct {
    realDB    Database
    cache     map[string]cacheEntry
    mu        sync.RWMutex
    ttl       time.Duration
}

type cacheEntry struct {
    data      []map[string]interface{}
    timestamp time.Time
}

func NewCacheProxy(realDB Database, ttl time.Duration) Database {
    return &CacheProxy{
        realDB: realDB,
        cache:  make(map[string]cacheEntry),
        ttl:    ttl,
    }
}

func (c *CacheProxy) Query(ctx context.Context, sql string, args ...interface{}) ([]map[string]interface{}, error) {
    cacheKey := fmt.Sprintf("%s:%v", sql, args)
    
    // 检查缓存
    c.mu.RLock()
    if entry, exists := c.cache[cacheKey]; exists {
        if time.Since(entry.timestamp) < c.ttl {
            c.mu.RUnlock()
            fmt.Println("[CACHE] Hit!")
            return entry.data, nil
        }
    }
    c.mu.RUnlock()
    
    // 缓存未命中，查询真实数据库
    fmt.Println("[CACHE] Miss, querying database...")
    data, err := c.realDB.Query(ctx, sql, args...)
    if err != nil {
        return nil, err
    }
    
    // 存入缓存
    c.mu.Lock()
    c.cache[cacheKey] = cacheEntry{
        data:      data,
        timestamp: time.Now(),
    }
    c.mu.Unlock()
    
    return data, nil
}

// ===== 延迟加载代理 =====
type LazyLoadProxy struct {
    realDB Database
    once   sync.Once
}

func NewLazyLoadProxy(dsn string) Database {
    return &LazyLoadProxy{}
}

func (l *LazyLoadProxy) initDB() {
    l.once.Do(func() {
        fmt.Println("[LAZY] Initializing database...")
        l.realDB = NewRealDatabase("dsn")
    })
}

func (l *LazyLoadProxy) Query(ctx context.Context, sql string, args ...interface{}) ([]map[string]interface{}, error) {
    l.initDB()  // 第一次调用时才初始化
    return l.realDB.Query(ctx, sql, args...)
}

// ===== 使用示例 =====
func Example() {
    ctx := context.Background()
    
    // 1. 基础数据库
    realDB := NewRealDatabase("mysql://localhost:3306/mydb")
    
    // 2. 添加缓存代理
    cachedDB := NewCacheProxy(realDB, 5*time.Second)
    
    // 3. 第一次查询（缓存未命中）
    start := time.Now()
    data1, _ := cachedDB.Query(ctx, "SELECT * FROM users WHERE id = ?", 1)
    fmt.Printf("First query took %v, data: %v\n", time.Since(start), data1)
    
    // 4. 第二次查询（缓存命中）
    start = time.Now()
    data2, _ := cachedDB.Query(ctx, "SELECT * FROM users WHERE id = ?", 1)
    fmt.Printf("Second query took %v, data: %v\n", time.Since(start), data2)
}

// 输出：
// [DB] Connecting to database...
// [DB] Connected!
// [CACHE] Miss, querying database...
// [DB] Executing query: SELECT * FROM users WHERE id = ?
// First query took 150ms, data: [{id:1 name:User1}]
// [CACHE] Hit!
// Second query took 0.1ms, data: [{id:1 name:User1}]
```

#### 性能提升

```text
第一次查询: 150ms (连接+查询)
第二次查询: 0.1ms (缓存命中)
性能提升: 1500倍
```

---

### 实战案例4：RPC服务代理

#### 场景6

- 微服务RPC调用
- 需要：重试、熔断、负载均衡

#### 完整实现6

```go
package rpcproxy

import (
    "context"
    "errors"
    "fmt"
    "math/rand"
    "sync"
    "time"
)

// RPCClient RPC客户端接口
type RPCClient interface {
    Call(ctx context.Context, method string, args interface{}) (interface{}, error)
}

// ===== 真实RPC客户端 =====
type RealRPCClient struct {
    address string
}

func NewRealRPCClient(address string) RPCClient {
    return &RealRPCClient{address: address}
}

func (r *RealRPCClient) Call(ctx context.Context, method string, args interface{}) (interface{}, error) {
    fmt.Printf("[RPC] Calling %s@%s with args %v\n", method, r.address, args)
    time.Sleep(10 * time.Millisecond)  // 模拟网络延迟
    
    // 模拟偶尔失败
    if rand.Float32() < 0.2 {
        return nil, errors.New("network error")
    }
    
    return "success", nil
}

// ===== 熔断器代理 =====
type CircuitBreakerProxy struct {
    client           RPCClient
    failureThreshold int
    resetTimeout     time.Duration
    
    state         string  // "closed", "open", "half-open"
    failureCount  int
    lastFailTime  time.Time
    mu            sync.Mutex
}

func NewCircuitBreakerProxy(client RPCClient, threshold int, resetTimeout time.Duration) RPCClient {
    return &CircuitBreakerProxy{
        client:           client,
        failureThreshold: threshold,
        resetTimeout:     resetTimeout,
        state:            "closed",
    }
}

func (c *CircuitBreakerProxy) Call(ctx context.Context, method string, args interface{}) (interface{}, error) {
    c.mu.Lock()
    
    // 检查熔断器状态
    if c.state == "open" {
        if time.Since(c.lastFailTime) > c.resetTimeout {
            c.state = "half-open"
            fmt.Println("[CIRCUIT] Half-open, trying request...")
        } else {
            c.mu.Unlock()
            return nil, errors.New("circuit breaker is open")
        }
    }
    
    c.mu.Unlock()
    
    // 执行调用
    result, err := c.client.Call(ctx, method, args)
    
    c.mu.Lock()
    defer c.mu.Unlock()
    
    if err != nil {
        c.failureCount++
        c.lastFailTime = time.Now()
        
        if c.failureCount >= c.failureThreshold {
            c.state = "open"
            fmt.Printf("[CIRCUIT] OPEN! Failures: %d\n", c.failureCount)
        }
        
        return nil, err
    }
    
    // 成功，重置计数
    c.failureCount = 0
    c.state = "closed"
    return result, nil
}

// ===== 负载均衡代理 =====
type LoadBalancerProxy struct {
    clients []RPCClient
    current int
    mu      sync.Mutex
}

func NewLoadBalancerProxy(addresses []string) RPCClient {
    clients := make([]RPCClient, len(addresses))
    for i, addr := range addresses {
        clients[i] = NewRealRPCClient(addr)
    }
    
    return &LoadBalancerProxy{
        clients: clients,
        current: 0,
    }
}

func (l *LoadBalancerProxy) Call(ctx context.Context, method string, args interface{}) (interface{}, error) {
    l.mu.Lock()
    client := l.clients[l.current]
    l.current = (l.current + 1) % len(l.clients)
    l.mu.Unlock()
    
    return client.Call(ctx, method, args)
}

// ===== 使用示例 =====
func Example() {
    ctx := context.Background()
    
    // 1. 创建负载均衡代理（3个实例）
    lbProxy := NewLoadBalancerProxy([]string{
        "server1:8080",
        "server2:8080",
        "server3:8080",
    })
    
    // 2. 添加熔断器代理
    cbProxy := NewCircuitBreakerProxy(lbProxy, 3, 5*time.Second)
    
    // 3. 连续调用（观察负载均衡和熔断）
    for i := 0; i < 10; i++ {
        result, err := cbProxy.Call(ctx, "GetUser", map[string]interface{}{"id": i})
        if err != nil {
            fmt.Printf("Call %d failed: %v\n", i, err)
        } else {
            fmt.Printf("Call %d succeeded: %v\n", i, result)
        }
        time.Sleep(100 * time.Millisecond)
    }
}
```

---

## 第五部分：外观模式与组合模式

### 外观模式（Facade）

#### 什么是外观模式？

**定义**: 为子系统中的一组接口提供一个统一的接口，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

#### 实战案例5：订单处理外观

```go
package facade

import (
    "context"
    "fmt"
)

// ===== 复杂的子系统 =====

// 库存系统
type InventorySystem struct{}

func (i *InventorySystem) CheckStock(productID string, quantity int) bool {
    fmt.Printf("[Inventory] Checking stock for %s...\n", productID)
    return true
}

func (i *InventorySystem) ReserveStock(productID string, quantity int) error {
    fmt.Printf("[Inventory] Reserving %d units of %s\n", quantity, productID)
    return nil
}

// 支付系统
type PaymentSystem struct{}

func (p *PaymentSystem) ProcessPayment(userID string, amount float64) (string, error) {
    fmt.Printf("[Payment] Processing payment $%.2f for user %s\n", amount, userID)
    return "txn_123456", nil
}

// 物流系统
type ShippingSystem struct{}

func (s *ShippingSystem) CreateShipment(orderID, address string) error {
    fmt.Printf("[Shipping] Creating shipment for order %s to %s\n", orderID, address)
    return nil
}

// 通知系统
type NotificationSystem struct{}

func (n *NotificationSystem) SendEmail(userID, message string) error {
    fmt.Printf("[Notification] Sending email to %s: %s\n", userID, message)
    return nil
}

// ===== 外观：订单处理外观 =====
type OrderFacade struct {
    inventory    *InventorySystem
    payment      *PaymentSystem
    shipping     *ShippingSystem
    notification *NotificationSystem
}

func NewOrderFacade() *OrderFacade {
    return &OrderFacade{
        inventory:    &InventorySystem{},
        payment:      &PaymentSystem{},
        shipping:     &ShippingSystem{},
        notification: &NotificationSystem{},
    }
}

// PlaceOrder 一站式下单（隐藏所有子系统复杂性）
func (o *OrderFacade) PlaceOrder(ctx context.Context, userID, productID string, quantity int, amount float64, address string) error {
    fmt.Println("=== Starting Order Process ===")
    
    // 1. 检查库存
    if !o.inventory.CheckStock(productID, quantity) {
        return fmt.Errorf("insufficient stock")
    }
    
    // 2. 预留库存
    if err := o.inventory.ReserveStock(productID, quantity); err != nil {
        return fmt.Errorf("failed to reserve stock: %w", err)
    }
    
    // 3. 处理支付
    txnID, err := o.payment.ProcessPayment(userID, amount)
    if err != nil {
        return fmt.Errorf("payment failed: %w", err)
    }
    
    // 4. 创建物流订单
    orderID := fmt.Sprintf("order_%s", txnID)
    if err := o.shipping.CreateShipment(orderID, address); err != nil {
        return fmt.Errorf("failed to create shipment: %w", err)
    }
    
    // 5. 发送通知
    message := fmt.Sprintf("Your order %s has been placed successfully!", orderID)
    o.notification.SendEmail(userID, message)
    
    fmt.Println("=== Order Process Completed ===")
    return nil
}

// ===== 使用示例 =====
func Example() {
    ctx := context.Background()
    
    // 客户端只需调用一个方法
    facade := NewOrderFacade()
    
    err := facade.PlaceOrder(
        ctx,
        "user123",
        "product456",
        2,
        99.99,
        "123 Main St",
    )
    
    if err != nil {
        fmt.Printf("Order failed: %v\n", err)
    }
}

// 输出：
// === Starting Order Process ===
// [Inventory] Checking stock for product456...
// [Inventory] Reserving 2 units of product456
// [Payment] Processing payment $99.99 for user user123
// [Shipping] Creating shipment for order order_txn_123456 to 123 Main St
// [Notification] Sending email to user123: Your order order_txn_123456 has been placed successfully!
// === Order Process Completed ===
```

**优势**:

- ✅ 客户端只需一个方法调用
- ✅ 隐藏子系统复杂性
- ✅ 易于维护和测试

---

### 组合模式（Composite）

#### 什么是组合模式？

**定义**: 将对象组合成树形结构以表示"部分-整体"的层次结构，使得用户对单个对象和组合对象的使用具有一致性。

#### 实战：文件系统

```go
package composite

import "fmt"

// Component 组件接口
type FileSystemNode interface {
    Name() string
    Size() int
    Display(indent int)
}

// ===== 叶子节点：文件 =====
type File struct {
    name string
    size int
}

func NewFile(name string, size int) *File {
    return &File{name: name, size: size}
}

func (f *File) Name() string {
    return f.name
}

func (f *File) Size() int {
    return f.size
}

func (f *File) Display(indent int) {
    fmt.Printf("%s📄 %s (%d KB)\n", getIndent(indent), f.name, f.size)
}

// ===== 组合节点：目录 =====
type Directory struct {
    name     string
    children []FileSystemNode
}

func NewDirectory(name string) *Directory {
    return &Directory{
        name:     name,
        children: make([]FileSystemNode, 0),
    }
}

func (d *Directory) Name() string {
    return d.name
}

func (d *Directory) Size() int {
    total := 0
    for _, child := range d.children {
        total += child.Size()
    }
    return total
}

func (d *Directory) Add(node FileSystemNode) {
    d.children = append(d.children, node)
}

func (d *Directory) Display(indent int) {
    fmt.Printf("%s📁 %s/ (%d KB)\n", getIndent(indent), d.name, d.Size())
    for _, child := range d.children {
        child.Display(indent + 2)
    }
}

func getIndent(level int) string {
    result := ""
    for i := 0; i < level; i++ {
        result += " "
    }
    return result
}

// ===== 使用示例 =====
func Example() {
    // 构建文件树
    root := NewDirectory("root")
    
    docs := NewDirectory("documents")
    docs.Add(NewFile("resume.pdf", 200))
    docs.Add(NewFile("report.docx", 500))
    
    photos := NewDirectory("photos")
    photos.Add(NewFile("vacation.jpg", 3000))
    photos.Add(NewFile("family.jpg", 2500))
    
    root.Add(docs)
    root.Add(photos)
    root.Add(NewFile("readme.txt", 10))
    
    // 统一接口操作（无论文件还是目录）
    root.Display(0)
    
    fmt.Printf("\nTotal size: %d KB\n", root.Size())
}

// 输出：
// 📁 root/ (6210 KB)
//   📁 documents/ (700 KB)
//     📄 resume.pdf (200 KB)
//     📄 report.docx (500 KB)
//   📁 photos/ (5500 KB)
//     📄 vacation.jpg (3000 KB)
//     📄 family.jpg (2500 KB)
//   📄 readme.txt (10 KB)
// 
// Total size: 6210 KB
```

---

## 第六部分：其他结构型模式

### 桥接模式（Bridge）

#### 简要说明

**定义**: 将抽象部分与实现部分分离，使它们都可以独立变化。

**适用场景**:

- 多维度变化（如：不同形状 × 不同颜色）
- 跨平台系统

#### 示例：跨平台通知

```go
// 实现接口
type MessageSender interface {
    Send(message string)
}

// 具体实现1：邮件
type EmailSender struct{}

func (e *EmailSender) Send(message string) {
    fmt.Println("Email:", message)
}

// 具体实现2：短信
type SMSSender struct{}

func (s *SMSSender) Send(message string) {
    fmt.Println("SMS:", message)
}

// 抽象接口
type Notification struct {
    sender MessageSender
}

func (n *Notification) Notify(message string) {
    n.sender.Send(message)
}

// 扩展抽象：紧急通知
type UrgentNotification struct {
    Notification
}

func (u *UrgentNotification) Notify(message string) {
    u.sender.Send("[URGENT] " + message)
}

// 使用
func Example() {
    // 组合1：普通通知 + 邮件
    notification := &Notification{sender: &EmailSender{}}
    notification.Notify("Hello")
    
    // 组合2：紧急通知 + 短信
    urgent := &UrgentNotification{Notification{sender: &SMSSender{}}}
    urgent.Notify("Server Down!")
}
```

---

### 享元模式（Flyweight）

#### 简要说明7

**定义**: 运用共享技术有效支持大量细粒度对象。

**适用场景**:

- 大量相似对象
- 对象池
- 缓存

#### 示例：图标缓存

```go
type Icon struct {
    data []byte
}

type IconFactory struct {
    cache map[string]*Icon
    mu    sync.Mutex
}

func (f *IconFactory) GetIcon(name string) *Icon {
    f.mu.Lock()
    defer f.mu.Unlock()
    
    if icon, exists := f.cache[name]; exists {
        fmt.Println("Icon cache hit:", name)
        return icon
    }
    
    // 加载图标（模拟）
    icon := &Icon{data: []byte("icon data for " + name)}
    f.cache[name] = icon
    fmt.Println("Icon loaded:", name)
    return icon
}

// 使用
func Example() {
    factory := &IconFactory{cache: make(map[string]*Icon)}
    
    // 多次请求相同图标，只加载一次
    icon1 := factory.GetIcon("save.png")
    icon2 := factory.GetIcon("save.png")  // 缓存命中
    
    fmt.Println("Same icon?", icon1 == icon2)  // true
}
```

---

## 第七部分：实战案例

### 综合案例：微服务网关

#### 场景8

- API网关需要：认证、限流、日志、监控、路由
- 使用多种结构型模式组合

#### 完整实现8

```go
package gateway

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// Handler 处理器接口
type Handler interface {
    Handle(ctx context.Context, req *Request) (*Response, error)
}

// Request 请求
type Request struct {
    Method string
    Path   string
    Body   interface{}
    UserID string
}

// Response 响应
type Response struct {
    StatusCode int
    Body       interface{}
}

// ===== 基础处理器 =====
type BaseHandler struct{}

func (b *BaseHandler) Handle(ctx context.Context, req *Request) (*Response, error) {
    fmt.Printf("[Handler] Processing %s %s\n", req.Method, req.Path)
    return &Response{
        StatusCode: 200,
        Body:       "Success",
    }, nil
}

// ===== 装饰器1：认证 =====
type AuthDecorator struct {
    handler Handler
}

func NewAuthDecorator(h Handler) Handler {
    return &AuthDecorator{handler: h}
}

func (a *AuthDecorator) Handle(ctx context.Context, req *Request) (*Response, error) {
    fmt.Println("[Auth] Checking authentication...")
    
    if req.UserID == "" {
        return &Response{StatusCode: 401, Body: "Unauthorized"}, nil
    }
    
    return a.handler.Handle(ctx, req)
}

// ===== 装饰器2：限流 =====
type RateLimitDecorator struct {
    handler    Handler
    tokens     int
    maxTokens  int
    lastRefill time.Time
    mu         sync.Mutex
}

func NewRateLimitDecorator(h Handler, maxTokens int) Handler {
    return &RateLimitDecorator{
        handler:    h,
        tokens:     maxTokens,
        maxTokens:  maxTokens,
        lastRefill: time.Now(),
    }
}

func (r *RateLimitDecorator) Handle(ctx context.Context, req *Request) (*Response, error) {
    r.mu.Lock()
    
    // 令牌桶算法：每秒补充令牌
    elapsed := time.Since(r.lastRefill)
    if elapsed > time.Second {
        r.tokens = r.maxTokens
        r.lastRefill = time.Now()
    }
    
    if r.tokens <= 0 {
        r.mu.Unlock()
        fmt.Println("[RateLimit] Request rejected - too many requests")
        return &Response{StatusCode: 429, Body: "Too Many Requests"}, nil
    }
    
    r.tokens--
    r.mu.Unlock()
    
    fmt.Printf("[RateLimit] Request allowed, tokens left: %d\n", r.tokens)
    return r.handler.Handle(ctx, req)
}

// ===== 装饰器3：日志 =====
type LoggingDecorator struct {
    handler Handler
}

func NewLoggingDecorator(h Handler) Handler {
    return &LoggingDecorator{handler: h}
}

func (l *LoggingDecorator) Handle(ctx context.Context, req *Request) (*Response, error) {
    start := time.Now()
    
    fmt.Printf("[Log] --> %s %s (user: %s)\n", req.Method, req.Path, req.UserID)
    
    resp, err := l.handler.Handle(ctx, req)
    
    elapsed := time.Since(start)
    fmt.Printf("[Log] <-- %d (took %v)\n", resp.StatusCode, elapsed)
    
    return resp, err
}

// ===== 外观：网关外观 =====
type GatewayFacade struct {
    handler Handler
}

func NewGatewayFacade() *GatewayFacade {
    // 组合所有装饰器
    baseHandler := &BaseHandler{}
    
    handler := NewLoggingDecorator(
        NewRateLimitDecorator(
            NewAuthDecorator(baseHandler),
            10,  // 每秒10个请求
        ),
    )
    
    return &GatewayFacade{handler: handler}
}

func (g *GatewayFacade) ProcessRequest(req *Request) (*Response, error) {
    ctx := context.Background()
    return g.handler.Handle(ctx, req)
}

// ===== 使用示例 =====
func Example() {
    gateway := NewGatewayFacade()
    
    // 测试请求
    requests := []*Request{
        {Method: "GET", Path: "/api/users", UserID: "user123"},
        {Method: "POST", Path: "/api/orders", UserID: "user123"},
        {Method: "GET", Path: "/api/products", UserID: ""},  // 无认证
    }
    
    for i, req := range requests {
        fmt.Printf("\n=== Request %d ===\n", i+1)
        resp, err := gateway.ProcessRequest(req)
        if err != nil {
            fmt.Printf("Error: %v\n", err)
        } else {
            fmt.Printf("Response: %d - %v\n", resp.StatusCode, resp.Body)
        }
    }
}
```

---

## 第八部分：最佳实践

### 结构型模式选择指南

#### 决策表

| 场景 | 推荐模式 | 原因 |
|------|---------|------|
| 接口不兼容 | 适配器 | 接口转换 |
| 添加功能 | 装饰器 | 动态扩展 |
| 控制访问 | 代理 | 访问控制 |
| 简化复杂系统 | 外观 | 统一入口 |
| 树形结构 | 组合 | 递归处理 |
| 多维度变化 | 桥接 | 解耦维度 |
| 对象复用 | 享元 | 内存优化 |

---

### 常见陷阱

#### 陷阱1：过度使用装饰器

```go
// ❌ 错误：装饰层次太深
client := NewMetrics(
    NewLogging(
        NewRetry(
            NewCache(
                NewTimeout(
                    NewCircuitBreaker(
                        NewLoadBalancer(baseClient),
                    ),
                ),
            ),
        ),
    ),
)  // 7层！太复杂

// ✅ 正确：合理组合（2-3层）
client := NewLogging(
    NewRetry(baseClient),
)
```

#### 陷阱2：适配器包含业务逻辑

```go
// ❌ 错误
func (a *PaymentAdapter) Pay(amount float64) error {
    if amount < 10 {  // 业务规则
        return errors.New("amount too small")
    }
    return a.gateway.Pay(amount)
}

// ✅ 正确：适配器只做转换
func (a *PaymentAdapter) Pay(amount float64) error {
    return a.gateway.Pay(amount)  // 纯转换
}
```

#### 陷阱3：外观过于复杂

```go
// ❌ 错误：外观暴露太多方法
type Facade struct {
    // 30+ public methods
}

// ✅ 正确：外观提供少量高层接口
type Facade struct {
    // 3-5 methods
}
```

---

## 🎯 总结

### 核心要点

1. **适配器模式**: 接口转换，系统集成
2. **装饰器模式**: 动态扩展，灵活组合
3. **代理模式**: 控制访问，增强功能
4. **外观模式**: 简化接口，统一入口
5. **组合模式**: 树形结构，一致接口

### 性能对比

```text
适配器: 几乎无开销（只是接口转换）
装饰器: 轻微开销（函数调用链）
代理: 取决于代理逻辑（缓存可大幅提升性能）
外观: 几乎无开销（只是封装）
组合: 递归开销（深度过大时注意性能）
```

---

## 📚 参考资源

**书籍**:

- 《Design Patterns: Elements of Reusable Object-Oriented Software》
- 《Head First Design Patterns》

**在线资源**:

- [Refactoring Guru - Structural Patterns](https://refactoring.guru/design-patterns/structural-patterns)
- [Go Patterns](https://github.com/tmrts/go-patterns)

---

**文档版本**: v3.0  

<div align="center">

Made with ❤️ for Go Developers

[⬆ 回[⬆ 回到顶部](#回到顶部)</div>

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025-10-29  
**文档状态**: 完成  
**适用版本**: Go 1.25.3+
