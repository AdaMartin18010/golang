# Goç»“æ„å‹è®¾è®¡æ¨¡å¼

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.23+

---

**å­—æ•°**: ~18,000å­—
**ä»£ç ç¤ºä¾‹**: 40+ä¸ªå®Œæ•´ç¤ºä¾‹
**å®æˆ˜æ¡ˆä¾‹**: 5ä¸ªç«¯åˆ°ç«¯æ¡ˆä¾‹
**é€‚ç”¨äººç¾¤**: ä¸­é«˜çº§Goå¼€å‘è€…

---

## ğŸ“‹ ç›®å½•

- [Goç»“æ„å‹è®¾è®¡æ¨¡å¼](#goç»“æ„å‹è®¾è®¡æ¨¡å¼)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ç¬¬ä¸€éƒ¨åˆ†ï¼šç†è®ºåŸºç¡€](#ç¬¬ä¸€éƒ¨åˆ†ç†è®ºåŸºç¡€)
    - [ç»“æ„å‹æ¨¡å¼çš„ä»·å€¼](#ç»“æ„å‹æ¨¡å¼çš„ä»·å€¼)
      - [ä¸ºä»€ä¹ˆéœ€è¦ç»“æ„å‹æ¨¡å¼ï¼Ÿ](#ä¸ºä»€ä¹ˆéœ€è¦ç»“æ„å‹æ¨¡å¼)
    - [ç»“æ„å‹æ¨¡å¼åˆ†ç±»](#ç»“æ„å‹æ¨¡å¼åˆ†ç±»)
    - [é€‰æ‹©ç»“æ„å‹æ¨¡å¼çš„å†³ç­–æ ‘](#é€‰æ‹©ç»“æ„å‹æ¨¡å¼çš„å†³ç­–æ ‘)
  - [ç¬¬äºŒéƒ¨åˆ†ï¼šé€‚é…å™¨æ¨¡å¼æ·±åº¦å®æˆ˜](#ç¬¬äºŒéƒ¨åˆ†é€‚é…å™¨æ¨¡å¼æ·±åº¦å®æˆ˜)
    - [é€‚é…å™¨æ¨¡å¼æ ¸å¿ƒåŸç†](#é€‚é…å™¨æ¨¡å¼æ ¸å¿ƒåŸç†)
      - [ä»€ä¹ˆæ˜¯é€‚é…å™¨æ¨¡å¼ï¼Ÿ](#ä»€ä¹ˆæ˜¯é€‚é…å™¨æ¨¡å¼)
    - [é€‚é…å™¨æ¨¡å¼çš„3ç§å®ç°](#é€‚é…å™¨æ¨¡å¼çš„3ç§å®ç°)
      - [å®ç°1ï¼šå¯¹è±¡é€‚é…å™¨ï¼ˆæ¨èâ­â­â­â­â­ï¼‰](#å®ç°1å¯¹è±¡é€‚é…å™¨æ¨è)
      - [å®ç°2ï¼šç±»é€‚é…å™¨ï¼ˆGoä¸­ä¸æ¨èï¼‰](#å®ç°2ç±»é€‚é…å™¨goä¸­ä¸æ¨è)
      - [å®ç°3ï¼šåŒå‘é€‚é…å™¨](#å®ç°3åŒå‘é€‚é…å™¨)
    - [å®æˆ˜æ¡ˆä¾‹1ï¼šæ•°æ®åº“é€‚é…å™¨](#å®æˆ˜æ¡ˆä¾‹1æ•°æ®åº“é€‚é…å™¨)
      - [åœºæ™¯](#åœºæ™¯)
      - [å®Œæ•´å®ç°](#å®Œæ•´å®ç°)
      - [ä¼˜åŠ¿](#ä¼˜åŠ¿)
    - [é€‚é…å™¨æ¨¡å¼æœ€ä½³å®è·µ](#é€‚é…å™¨æ¨¡å¼æœ€ä½³å®è·µ)
      - [âœ… DO](#-do)
      - [âŒ DON'T](#-dont)
  - [ç¬¬ä¸‰éƒ¨åˆ†ï¼šè£…é¥°å™¨æ¨¡å¼æ·±åº¦å®æˆ˜](#ç¬¬ä¸‰éƒ¨åˆ†è£…é¥°å™¨æ¨¡å¼æ·±åº¦å®æˆ˜)
    - [è£…é¥°å™¨æ¨¡å¼æ ¸å¿ƒåŸç†](#è£…é¥°å™¨æ¨¡å¼æ ¸å¿ƒåŸç†)
      - [ä»€ä¹ˆæ˜¯è£…é¥°å™¨æ¨¡å¼ï¼Ÿ](#ä»€ä¹ˆæ˜¯è£…é¥°å™¨æ¨¡å¼)
    - [è£…é¥°å™¨æ¨¡å¼å®Œæ•´å®ç°](#è£…é¥°å™¨æ¨¡å¼å®Œæ•´å®ç°)
      - [åŸºç¡€è£…é¥°å™¨](#åŸºç¡€è£…é¥°å™¨)
    - [å®æˆ˜æ¡ˆä¾‹2ï¼šHTTPå®¢æˆ·ç«¯è£…é¥°å™¨](#å®æˆ˜æ¡ˆä¾‹2httpå®¢æˆ·ç«¯è£…é¥°å™¨)
      - [åœºæ™¯3](#åœºæ™¯3)
      - [å®Œæ•´å®ç°3](#å®Œæ•´å®ç°3)
      - [è¾“å‡ºç¤ºä¾‹](#è¾“å‡ºç¤ºä¾‹)
    - [è£…é¥°å™¨æ¨¡å¼æœ€ä½³å®è·µ](#è£…é¥°å™¨æ¨¡å¼æœ€ä½³å®è·µ)
      - [âœ… DO4](#-do4)
      - [âŒ DON'T4](#-dont4)
  - [ç¬¬å››éƒ¨åˆ†ï¼šä»£ç†æ¨¡å¼æ·±åº¦å®æˆ˜](#ç¬¬å››éƒ¨åˆ†ä»£ç†æ¨¡å¼æ·±åº¦å®æˆ˜)
    - [ä»£ç†æ¨¡å¼æ ¸å¿ƒåŸç†](#ä»£ç†æ¨¡å¼æ ¸å¿ƒåŸç†)
      - [ä»€ä¹ˆæ˜¯ä»£ç†æ¨¡å¼ï¼Ÿ](#ä»€ä¹ˆæ˜¯ä»£ç†æ¨¡å¼)
    - [å®æˆ˜æ¡ˆä¾‹3ï¼šæ•°æ®åº“æŸ¥è¯¢ä»£ç†ï¼ˆç¼“å­˜+å»¶è¿ŸåŠ è½½ï¼‰](#å®æˆ˜æ¡ˆä¾‹3æ•°æ®åº“æŸ¥è¯¢ä»£ç†ç¼“å­˜å»¶è¿ŸåŠ è½½)
      - [åœºæ™¯5](#åœºæ™¯5)
      - [å®Œæ•´å®ç°5](#å®Œæ•´å®ç°5)
      - [æ€§èƒ½æå‡](#æ€§èƒ½æå‡)
    - [å®æˆ˜æ¡ˆä¾‹4ï¼šRPCæœåŠ¡ä»£ç†](#å®æˆ˜æ¡ˆä¾‹4rpcæœåŠ¡ä»£ç†)
      - [åœºæ™¯6](#åœºæ™¯6)
      - [å®Œæ•´å®ç°6](#å®Œæ•´å®ç°6)
  - [ç¬¬äº”éƒ¨åˆ†ï¼šå¤–è§‚æ¨¡å¼ä¸ç»„åˆæ¨¡å¼](#ç¬¬äº”éƒ¨åˆ†å¤–è§‚æ¨¡å¼ä¸ç»„åˆæ¨¡å¼)
    - [å¤–è§‚æ¨¡å¼ï¼ˆFacadeï¼‰](#å¤–è§‚æ¨¡å¼facade)
      - [ä»€ä¹ˆæ˜¯å¤–è§‚æ¨¡å¼ï¼Ÿ](#ä»€ä¹ˆæ˜¯å¤–è§‚æ¨¡å¼)
      - [å®æˆ˜æ¡ˆä¾‹5ï¼šè®¢å•å¤„ç†å¤–è§‚](#å®æˆ˜æ¡ˆä¾‹5è®¢å•å¤„ç†å¤–è§‚)
    - [ç»„åˆæ¨¡å¼ï¼ˆCompositeï¼‰](#ç»„åˆæ¨¡å¼composite)
      - [ä»€ä¹ˆæ˜¯ç»„åˆæ¨¡å¼ï¼Ÿ](#ä»€ä¹ˆæ˜¯ç»„åˆæ¨¡å¼)
      - [å®æˆ˜ï¼šæ–‡ä»¶ç³»ç»Ÿ](#å®æˆ˜æ–‡ä»¶ç³»ç»Ÿ)
  - [ç¬¬å…­éƒ¨åˆ†ï¼šå…¶ä»–ç»“æ„å‹æ¨¡å¼](#ç¬¬å…­éƒ¨åˆ†å…¶ä»–ç»“æ„å‹æ¨¡å¼)
    - [æ¡¥æ¥æ¨¡å¼ï¼ˆBridgeï¼‰](#æ¡¥æ¥æ¨¡å¼bridge)
      - [ç®€è¦è¯´æ˜](#ç®€è¦è¯´æ˜)
      - [ç¤ºä¾‹ï¼šè·¨å¹³å°é€šçŸ¥](#ç¤ºä¾‹è·¨å¹³å°é€šçŸ¥)
    - [äº«å…ƒæ¨¡å¼ï¼ˆFlyweightï¼‰](#äº«å…ƒæ¨¡å¼flyweight)
      - [ç®€è¦è¯´æ˜7](#ç®€è¦è¯´æ˜7)
      - [ç¤ºä¾‹ï¼šå›¾æ ‡ç¼“å­˜](#ç¤ºä¾‹å›¾æ ‡ç¼“å­˜)
  - [ç¬¬ä¸ƒéƒ¨åˆ†ï¼šå®æˆ˜æ¡ˆä¾‹](#ç¬¬ä¸ƒéƒ¨åˆ†å®æˆ˜æ¡ˆä¾‹)
    - [ç»¼åˆæ¡ˆä¾‹ï¼šå¾®æœåŠ¡ç½‘å…³](#ç»¼åˆæ¡ˆä¾‹å¾®æœåŠ¡ç½‘å…³)
      - [åœºæ™¯8](#åœºæ™¯8)
      - [å®Œæ•´å®ç°8](#å®Œæ•´å®ç°8)
  - [ç¬¬å…«éƒ¨åˆ†ï¼šæœ€ä½³å®è·µ](#ç¬¬å…«éƒ¨åˆ†æœ€ä½³å®è·µ)
    - [ç»“æ„å‹æ¨¡å¼é€‰æ‹©æŒ‡å—](#ç»“æ„å‹æ¨¡å¼é€‰æ‹©æŒ‡å—)
      - [å†³ç­–è¡¨](#å†³ç­–è¡¨)
    - [å¸¸è§é™·é˜±](#å¸¸è§é™·é˜±)
      - [é™·é˜±1ï¼šè¿‡åº¦ä½¿ç”¨è£…é¥°å™¨](#é™·é˜±1è¿‡åº¦ä½¿ç”¨è£…é¥°å™¨)
      - [é™·é˜±2ï¼šé€‚é…å™¨åŒ…å«ä¸šåŠ¡é€»è¾‘](#é™·é˜±2é€‚é…å™¨åŒ…å«ä¸šåŠ¡é€»è¾‘)
      - [é™·é˜±3ï¼šå¤–è§‚è¿‡äºå¤æ‚](#é™·é˜±3å¤–è§‚è¿‡äºå¤æ‚)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [æ€§èƒ½å¯¹æ¯”](#æ€§èƒ½å¯¹æ¯”)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

## ç¬¬ä¸€éƒ¨åˆ†ï¼šç†è®ºåŸºç¡€

### ç»“æ„å‹æ¨¡å¼çš„ä»·å€¼

#### ä¸ºä»€ä¹ˆéœ€è¦ç»“æ„å‹æ¨¡å¼ï¼Ÿ

**é—®é¢˜ç¤ºä¾‹**:

```go
// âŒ ç›´æ¥ä¾èµ–å…·ä½“å®ç°çš„é—®é¢˜
type OrderService struct {
    mysqlDB *MySQLDatabase  // ç¡¬ç¼–ç MySQL
    redisCache *RedisCache   // ç¡¬ç¼–ç Redis
    logger *FileLogger       // ç¡¬ç¼–ç æ–‡ä»¶æ—¥å¿—
}

// é—®é¢˜ï¼š
// 1. éš¾ä»¥åˆ‡æ¢å®ç°ï¼ˆå¦‚ä»MySQLåˆ‡åˆ°PostgreSQLï¼‰
// 2. éš¾ä»¥æ·»åŠ åŠŸèƒ½ï¼ˆå¦‚æ·»åŠ æ—¥å¿—ï¼‰
// 3. éš¾ä»¥æµ‹è¯•ï¼ˆä¾èµ–çœŸå®æ•°æ®åº“ï¼‰
// 4. ç»„ä»¶é—´ç´§è€¦åˆ
```

**ä½¿ç”¨ç»“æ„å‹æ¨¡å¼å**:

```go
// âœ… ä½¿ç”¨æ¥å£+é€‚é…å™¨+è£…é¥°å™¨
type OrderService struct {
    db Database         // æ¥å£ï¼Œå¯é€‚é…ä»»ä½•æ•°æ®åº“
    cache Cache         // æ¥å£ï¼Œå¯é€‚é…ä»»ä½•ç¼“å­˜
    logger Logger       // æ¥å£ï¼Œå¯è£…é¥°å¢å¼º
}

// ä¼˜åŠ¿ï¼š
// 1. å¯ä»¥è½»æ¾åˆ‡æ¢å®ç°
// 2. å¯ä»¥åŠ¨æ€æ·»åŠ åŠŸèƒ½
// 3. æ˜“äºmockæµ‹è¯•
// 4. æ¾è€¦åˆè®¾è®¡
```

---

### ç»“æ„å‹æ¨¡å¼åˆ†ç±»

| æ¨¡å¼ | æ„å›¾ | é€‚ç”¨åœºæ™¯ | å¤æ‚åº¦ |
|------|------|---------|--------|
| **é€‚é…å™¨** | æ¥å£è½¬æ¢ | ç³»ç»Ÿé›†æˆã€é—ç•™ä»£ç  | â­â­ |
| **è£…é¥°å™¨** | åŠ¨æ€æ‰©å±•åŠŸèƒ½ | æ—¥å¿—ã€ç¼“å­˜ã€æƒé™ | â­â­â­ |
| **ä»£ç†** | æ§åˆ¶è®¿é—® | å»¶è¿ŸåŠ è½½ã€ç¼“å­˜ã€RPC | â­â­â­ |
| **å¤–è§‚** | ç®€åŒ–æ¥å£ | å¤æ‚å­ç³»ç»Ÿå°è£… | â­â­ |
| **ç»„åˆ** | æ ‘å½¢ç»“æ„ | æ–‡ä»¶ç³»ç»Ÿã€ç»„ç»‡æ¶æ„ | â­â­â­ |
| **æ¡¥æ¥** | æŠ½è±¡ä¸å®ç°åˆ†ç¦» | å¤šç»´åº¦å˜åŒ– | â­â­â­â­ |
| **äº«å…ƒ** | å…±äº«å¯¹è±¡ | å†…å­˜ä¼˜åŒ–ã€å¯¹è±¡æ±  | â­â­â­ |

---

### é€‰æ‹©ç»“æ„å‹æ¨¡å¼çš„å†³ç­–æ ‘

```text
ä½ çš„éœ€æ±‚æ˜¯ä»€ä¹ˆï¼Ÿ
â”‚
â”œâ”€ éœ€è¦æ¥å£è½¬æ¢/å…¼å®¹ï¼Ÿ
â”‚  â””â”€ æ˜¯ â†’ é€‚é…å™¨æ¨¡å¼
â”‚      - é›†æˆç¬¬ä¸‰æ–¹åº“
â”‚      - é€‚é…é—ç•™ä»£ç 
â”‚
â”œâ”€ éœ€è¦åŠ¨æ€æ·»åŠ åŠŸèƒ½ï¼Ÿ
â”‚  â””â”€ æ˜¯ â†’ è£…é¥°å™¨æ¨¡å¼
â”‚      - æ·»åŠ æ—¥å¿—
â”‚      - æ·»åŠ ç¼“å­˜
â”‚      - æ·»åŠ æƒé™æ£€æŸ¥
â”‚
â”œâ”€ éœ€è¦æ§åˆ¶å¯¹è±¡è®¿é—®ï¼Ÿ
â”‚  â””â”€ æ˜¯ â†’ ä»£ç†æ¨¡å¼
â”‚      - å»¶è¿ŸåŠ è½½
â”‚      - è®¿é—®æ§åˆ¶
â”‚      - è¿œç¨‹è°ƒç”¨
â”‚
â”œâ”€ éœ€è¦ç®€åŒ–å¤æ‚å­ç³»ç»Ÿï¼Ÿ
â”‚  â””â”€ æ˜¯ â†’ å¤–è§‚æ¨¡å¼
â”‚      - å°è£…å¤æ‚API
â”‚      - ç»Ÿä¸€å…¥å£
â”‚
â”œâ”€ éœ€è¦å¤„ç†æ ‘å½¢ç»“æ„ï¼Ÿ
â”‚  â””â”€ æ˜¯ â†’ ç»„åˆæ¨¡å¼
â”‚      - æ–‡ä»¶ç³»ç»Ÿ
â”‚      - UIç»„ä»¶æ ‘
â”‚
â””â”€ éœ€è¦å…±äº«å¤§é‡å¯¹è±¡ï¼Ÿ
   â””â”€ æ˜¯ â†’ äº«å…ƒæ¨¡å¼
       - å¯¹è±¡æ± 
       - ç¼“å­˜å¤ç”¨
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šé€‚é…å™¨æ¨¡å¼æ·±åº¦å®æˆ˜

### é€‚é…å™¨æ¨¡å¼æ ¸å¿ƒåŸç†

#### ä»€ä¹ˆæ˜¯é€‚é…å™¨æ¨¡å¼ï¼Ÿ

**å®šä¹‰**: å°†ä¸€ä¸ªç±»çš„æ¥å£è½¬æ¢æˆå®¢æˆ·å¸Œæœ›çš„å¦ä¸€ä¸ªæ¥å£ï¼Œä½¿åŸæœ¬æ¥å£ä¸å…¼å®¹çš„ç±»å¯ä»¥ä¸€èµ·å·¥ä½œã€‚

**ç°å®ç±»æ¯”**:

- ç”µæºé€‚é…å™¨ï¼ˆ220V â†’ 5Vï¼‰
- Type-Cè½¬USBè½¬æ¥å¤´
- è¯­è¨€ç¿»è¯‘å™¨

**UMLç»“æ„**:

```text
Target Interface  â†â† Client
     â†‘
     â”‚ implements
  Adapter
     â”‚ has-a
     â†“
  Adaptee
```

---

### é€‚é…å™¨æ¨¡å¼çš„3ç§å®ç°

#### å®ç°1ï¼šå¯¹è±¡é€‚é…å™¨ï¼ˆæ¨èâ­â­â­â­â­ï¼‰

```go
package adapter

// Target ç›®æ ‡æ¥å£ï¼ˆå®¢æˆ·æœŸæœ›çš„æ¥å£ï¼‰
type Target interface {
    Request() string
}

// Adaptee è¢«é€‚é…è€…ï¼ˆç°æœ‰çš„ä¸å…¼å®¹æ¥å£ï¼‰
type Adaptee struct {
    specificData string
}

func (a *Adaptee) SpecificRequest() string {
    return "Adaptee: " + a.specificData
}

// Adapter é€‚é…å™¨ï¼ˆå¯¹è±¡ç»„åˆæ–¹å¼ï¼‰
type Adapter struct {
    adaptee *Adaptee
}

func NewAdapter(adaptee *Adaptee) Target {
    return &Adapter{adaptee: adaptee}
}

func (a *Adapter) Request() string {
    // è½¬æ¢æ¥å£è°ƒç”¨
    return a.adaptee.SpecificRequest()
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    adaptee := &Adaptee{specificData: "Some Data"}
    adapter := NewAdapter(adaptee)

    // å®¢æˆ·ç«¯ä½¿ç”¨ç»Ÿä¸€çš„Targetæ¥å£
    result := adapter.Request()
    fmt.Println(result)  // è¾“å‡º: Adaptee: Some Data
}
```

**ä¼˜ç‚¹**:

- âœ… çµæ´»ï¼Œç¬¦åˆç»„åˆä¼˜äºç»§æ‰¿åŸåˆ™
- âœ… å¯ä»¥é€‚é…å¤šä¸ªAdaptee
- âœ… æ˜“äºæµ‹è¯•å’Œmock

---

#### å®ç°2ï¼šç±»é€‚é…å™¨ï¼ˆGoä¸­ä¸æ¨èï¼‰

```go
// Goæ²¡æœ‰ç»§æ‰¿ï¼Œç”¨åµŒå…¥æ¨¡æ‹Ÿç±»é€‚é…å™¨
type ClassAdapter struct {
    Adaptee  // åµŒå…¥
}

func (c *ClassAdapter) Request() string {
    return c.SpecificRequest()
}
```

**é—®é¢˜**:

- âš ï¸ Goæ²¡æœ‰å¤šç»§æ‰¿
- âš ï¸ ä¸å¤Ÿçµæ´»
- âš ï¸ è¿åç»„åˆä¼˜äºç»§æ‰¿åŸåˆ™

---

#### å®ç°3ï¼šåŒå‘é€‚é…å™¨

```go
// åŒå‘é€‚é…å™¨ï¼ˆæ”¯æŒTargetå’ŒAdapteeäº’ç›¸è°ƒç”¨ï¼‰
type TwoWayAdapter struct {
    adaptee *Adaptee
}

func (t *TwoWayAdapter) Request() string {
    return t.adaptee.SpecificRequest()
}

func (t *TwoWayAdapter) SpecificRequest() string {
    return t.Request()
}
```

---

### å®æˆ˜æ¡ˆä¾‹1ï¼šæ•°æ®åº“é€‚é…å™¨

#### åœºæ™¯

- ç³»ç»Ÿä½¿ç”¨MySQLæ•°æ®åº“
- éœ€è¦æ”¯æŒPostgreSQLã€MongoDB
- ä¸ä¿®æ”¹ä¸šåŠ¡ä»£ç 

#### å®Œæ•´å®ç°

```go
package database

import (
    "context"
    "database/sql"
    "errors"

    _ "github.com/go-sql-driver/mysql"
    _ "github.com/lib/pq"
    "go.mongodb.org/mongo-driver/mongo"
)

// Database ç»Ÿä¸€æ•°æ®åº“æ¥å£
type Database interface {
    Query(ctx context.Context, query string, args ...interface{}) ([]map[string]interface{}, error)
    Exec(ctx context.Context, query string, args ...interface{}) error
    Close() error
}

// ===== MySQLé€‚é…å™¨ =====
type MySQLAdapter struct {
    db *sql.DB
}

func NewMySQLAdapter(dsn string) (Database, error) {
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        return nil, err
    }
    return &MySQLAdapter{db: db}, nil
}

func (m *MySQLAdapter) Query(ctx context.Context, query string, args ...interface{}) ([]map[string]interface{}, error) {
    rows, err := m.db.QueryContext(ctx, query, args...)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    columns, _ := rows.Columns()
    results := make([]map[string]interface{}, 0)

    for rows.Next() {
        values := make([]interface{}, len(columns))
        valuePtrs := make([]interface{}, len(columns))
        for i := range values {
            valuePtrs[i] = &values[i]
        }

        if err := rows.Scan(valuePtrs...); err != nil {
            return nil, err
        }

        row := make(map[string]interface{})
        for i, col := range columns {
            row[col] = values[i]
        }
        results = append(results, row)
    }

    return results, nil
}

func (m *MySQLAdapter) Exec(ctx context.Context, query string, args ...interface{}) error {
    _, err := m.db.ExecContext(ctx, query, args...)
    return err
}

func (m *MySQLAdapter) Close() error {
    return m.db.Close()
}

// ===== PostgreSQLé€‚é…å™¨ =====
type PostgreSQLAdapter struct {
    db *sql.DB
}

func NewPostgreSQLAdapter(dsn string) (Database, error) {
    db, err := sql.Open("postgres", dsn)
    if err != nil {
        return nil, err
    }
    return &PostgreSQLAdapter{db: db}, nil
}

func (p *PostgreSQLAdapter) Query(ctx context.Context, query string, args ...interface{}) ([]map[string]interface{}, error) {
    // å®ç°ä¸MySQLç±»ä¼¼ï¼Œä½†å¯èƒ½æœ‰PostgreSQLç‰¹å®šçš„ä¼˜åŒ–
    rows, err := p.db.QueryContext(ctx, query, args...)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    // ... ç±»ä¼¼MySQLçš„å®ç°
    return nil, nil
}

func (p *PostgreSQLAdapter) Exec(ctx context.Context, query string, args ...interface{}) error {
    _, err := p.db.ExecContext(ctx, query, args...)
    return err
}

func (p *PostgreSQLAdapter) Close() error {
    return p.db.Close()
}

// ===== MongoDBé€‚é…å™¨ =====
type MongoDBAdapter struct {
    client *mongo.Client
    dbName string
}

func NewMongoDBAdapter(uri, dbName string) (Database, error) {
    ctx := context.Background()
    client, err := mongo.Connect(ctx, options.Client().ApplyURI(uri))
    if err != nil {
        return nil, err
    }
    return &MongoDBAdapter{client: client, dbName: dbName}, nil
}

func (m *MongoDBAdapter) Query(ctx context.Context, query string, args ...interface{}) ([]map[string]interface{}, error) {
    // MongoDBä½¿ç”¨ä¸åŒçš„æŸ¥è¯¢è¯­æ³•ï¼Œé€‚é…å™¨è´Ÿè´£è½¬æ¢
    // è¿™é‡Œç®€åŒ–å¤„ç†
    return nil, errors.New("MongoDB adapter: query not implemented")
}

func (m *MongoDBAdapter) Exec(ctx context.Context, query string, args ...interface{}) error {
    return errors.New("MongoDB adapter: exec not implemented")
}

func (m *MongoDBAdapter) Close() error {
    return m.client.Disconnect(context.Background())
}

// ===== æ•°æ®åº“å·¥å‚ =====
func NewDatabase(dbType, dsn string) (Database, error) {
    switch dbType {
    case "mysql":
        return NewMySQLAdapter(dsn)
    case "postgres":
        return NewPostgreSQLAdapter(dsn)
    case "mongodb":
        return NewMongoDBAdapter(dsn, "mydb")
    default:
        return nil, errors.New("unsupported database type")
    }
}

// ===== ä¸šåŠ¡ä»£ç ï¼ˆæ— éœ€ä¿®æ”¹ï¼‰=====
type UserRepository struct {
    db Database
}

func NewUserRepository(db Database) *UserRepository {
    return &UserRepository{db: db}
}

func (r *UserRepository) GetUser(ctx context.Context, id int) (map[string]interface{}, error) {
    results, err := r.db.Query(ctx, "SELECT * FROM users WHERE id = ?", id)
    if err != nil {
        return nil, err
    }
    if len(results) == 0 {
        return nil, errors.New("user not found")
    }
    return results[0], nil
}

// ===== ä½¿ç”¨ç¤ºä¾‹ =====
func main() {
    ctx := context.Background()

    // æ–¹å¼1ï¼šä½¿ç”¨MySQL
    mysqlDB, _ := NewDatabase("mysql", "user:pass@tcp(localhost:3306)/mydb")
    defer mysqlDB.Close()

    repo := NewUserRepository(mysqlDB)
    user, _ := repo.GetUser(ctx, 123)
    fmt.Println("MySQL User:", user)

    // æ–¹å¼2ï¼šåˆ‡æ¢åˆ°PostgreSQLï¼ˆä¸šåŠ¡ä»£ç æ— éœ€ä¿®æ”¹ï¼‰
    pgDB, _ := NewDatabase("postgres", "postgres://user:pass@localhost/mydb")
    defer pgDB.Close()

    repo = NewUserRepository(pgDB)
    user, _ = repo.GetUser(ctx, 123)
    fmt.Println("PostgreSQL User:", user)
}
```

#### ä¼˜åŠ¿

- âœ… ä¸šåŠ¡ä»£ç å®Œå…¨è§£è€¦
- âœ… å¯ä»¥è½»æ¾åˆ‡æ¢æ•°æ®åº“
- âœ… æ˜“äºæ·»åŠ æ–°æ•°æ®åº“æ”¯æŒ
- âœ… ç»Ÿä¸€çš„é”™è¯¯å¤„ç†

---

### é€‚é…å™¨æ¨¡å¼æœ€ä½³å®è·µ

#### âœ… DO

1. **ä½¿ç”¨æ¥å£å®šä¹‰å¥‘çº¦**:

    ```go
    // âœ… æ­£ç¡®ï¼šå®šä¹‰æ¸…æ™°çš„æ¥å£
    type PaymentGateway interface {
        Pay(amount float64) error
        Refund(transactionID string) error
    }
    ```

2. **ä¿æŒé€‚é…å™¨ç®€å•**:

    ```go
    // âœ… æ­£ç¡®ï¼šé€‚é…å™¨åªåšè½¬æ¢
    type StripeAdapter struct {
        client *stripe.Client
    }

    func (s *StripeAdapter) Pay(amount float64) error {
        // åªåšå‚æ•°è½¬æ¢å’Œè°ƒç”¨
        return s.client.Charges.New(&stripe.ChargeParams{
            Amount: stripe.Int64(int64(amount * 100)),
        })
    }
    ```

#### âŒ DON'T

1. **ä¸è¦åœ¨é€‚é…å™¨ä¸­æ·»åŠ ä¸šåŠ¡é€»è¾‘**:

    ```go
    // âŒ é”™è¯¯ï¼šé€‚é…å™¨ä¸åº”åŒ…å«ä¸šåŠ¡é€»è¾‘
    func (s *StripeAdapter) Pay(amount float64) error {
        if amount < 10 {  // â† ä¸šåŠ¡è§„åˆ™åº”è¯¥åœ¨serviceå±‚
            return errors.New("amount too small")
        }
        return s.client.Pay(amount)
    }
    ```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šè£…é¥°å™¨æ¨¡å¼æ·±åº¦å®æˆ˜

### è£…é¥°å™¨æ¨¡å¼æ ¸å¿ƒåŸç†

#### ä»€ä¹ˆæ˜¯è£…é¥°å™¨æ¨¡å¼ï¼Ÿ

**å®šä¹‰**: åŠ¨æ€åœ°ç»™å¯¹è±¡æ·»åŠ é¢å¤–çš„èŒè´£ï¼Œå°±å¢åŠ åŠŸèƒ½æ¥è¯´ï¼Œè£…é¥°å™¨æ¨¡å¼æ¯”ç”Ÿæˆå­ç±»æ›´ä¸ºçµæ´»ã€‚

**æ ¸å¿ƒæ€æƒ³**:

- å¯¹è±¡ç»„åˆè€Œéç»§æ‰¿
- é€æ˜åŒ…è£…ï¼ˆè£…é¥°å™¨å’ŒåŸå¯¹è±¡å®ç°ç›¸åŒæ¥å£ï¼‰
- å¯ä»¥å¤šå±‚åµŒå¥—

**UMLç»“æ„**:

```text
Component Interface
     â†‘
     â”œâ”€ ConcreteComponent
     â””â”€ Decorator (has-a Component)
            â†‘
            â”œâ”€ ConcreteDecoratorA
            â””â”€ ConcreteDecoratorB
```

---

### è£…é¥°å™¨æ¨¡å¼å®Œæ•´å®ç°

#### åŸºç¡€è£…é¥°å™¨

```go
package decorator

import (
    "fmt"
    "time"
)

// Component ç»„ä»¶æ¥å£
type Component interface {
    Operation() string
}

// ConcreteComponent å…·ä½“ç»„ä»¶
type ConcreteComponent struct {
    data string
}

func (c *ConcreteComponent) Operation() string {
    return c.data
}

// Decorator è£…é¥°å™¨åŸºç±»
type Decorator struct {
    component Component
}

func (d *Decorator) Operation() string {
    if d.component != nil {
        return d.component.Operation()
    }
    return ""
}

// ===== å…·ä½“è£…é¥°å™¨1ï¼šæ—¥å¿—è£…é¥°å™¨ =====
type LoggingDecorator struct {
    Decorator
}

func NewLoggingDecorator(c Component) Component {
    return &LoggingDecorator{
        Decorator: Decorator{component: c},
    }
}

func (l *LoggingDecorator) Operation() string {
    start := time.Now()
    result := l.Decorator.Operation()
    elapsed := time.Since(start)

    fmt.Printf("[LOG] Operation took %v, result: %s\n", elapsed, result)
    return result
}

// ===== å…·ä½“è£…é¥°å™¨2ï¼šç¼“å­˜è£…é¥°å™¨ =====
type CachingDecorator struct {
    Decorator
    cache map[string]string
}

func NewCachingDecorator(c Component) Component {
    return &CachingDecorator{
        Decorator: Decorator{component: c},
        cache:     make(map[string]string),
    }
}

func (c *CachingDecorator) Operation() string {
    key := "operation"
    if cached, exists := c.cache[key]; exists {
        fmt.Println("[CACHE] Hit!")
        return cached
    }

    result := c.Decorator.Operation()
    c.cache[key] = result
    fmt.Println("[CACHE] Miss, cached result")
    return result
}

// ===== ä½¿ç”¨ç¤ºä¾‹ï¼šå¤šå±‚è£…é¥° =====
func Example() {
    // åŸå§‹ç»„ä»¶
    component := &ConcreteComponent{data: "Hello World"}

    // æ·»åŠ æ—¥å¿—è£…é¥°
    logged := NewLoggingDecorator(component)

    // å†æ·»åŠ ç¼“å­˜è£…é¥°
    cached := NewCachingDecorator(logged)

    // è°ƒç”¨
    fmt.Println(cached.Operation())  // ç¬¬ä¸€æ¬¡ï¼šCACHE Miss â†’ LOG
    fmt.Println(cached.Operation())  // ç¬¬äºŒæ¬¡ï¼šCACHE Hit
}
```

---

### å®æˆ˜æ¡ˆä¾‹2ï¼šHTTPå®¢æˆ·ç«¯è£…é¥°å™¨

#### åœºæ™¯3

- åŸºç¡€HTTPå®¢æˆ·ç«¯
- éœ€è¦æ·»åŠ ï¼šé‡è¯•ã€æ—¥å¿—ã€ç›‘æ§ã€è¶…æ—¶
- åŠŸèƒ½å¯çµæ´»ç»„åˆ

#### å®Œæ•´å®ç°3

```go
package httpclient

import (
    "context"
    "fmt"
    "io"
    "net/http"
    "time"
)

// HTTPClient HTTPå®¢æˆ·ç«¯æ¥å£
type HTTPClient interface {
    Do(ctx context.Context, req *http.Request) (*http.Response, error)
}

// ===== åŸºç¡€HTTPå®¢æˆ·ç«¯ =====
type BaseHTTPClient struct {
    client *http.Client
}

func NewBaseHTTPClient(timeout time.Duration) HTTPClient {
    return &BaseHTTPClient{
        client: &http.Client{
            Timeout: timeout,
        },
    }
}

func (b *BaseHTTPClient) Do(ctx context.Context, req *http.Request) (*http.Response, error) {
    return b.client.Do(req.WithContext(ctx))
}

// ===== è£…é¥°å™¨1ï¼šé‡è¯•è£…é¥°å™¨ =====
type RetryDecorator struct {
    client     HTTPClient
    maxRetries int
    retryDelay time.Duration
}

func NewRetryDecorator(client HTTPClient, maxRetries int, retryDelay time.Duration) HTTPClient {
    return &RetryDecorator{
        client:     client,
        maxRetries: maxRetries,
        retryDelay: retryDelay,
    }
}

func (r *RetryDecorator) Do(ctx context.Context, req *http.Request) (*http.Response, error) {
    var lastErr error

    for i := 0; i <= r.maxRetries; i++ {
        resp, err := r.client.Do(ctx, req)

        // æˆåŠŸæˆ–éä¸´æ—¶é”™è¯¯ï¼Œç›´æ¥è¿”å›
        if err == nil || !isTemporaryError(err) {
            return resp, err
        }

        lastErr = err

        // æœ€åä¸€æ¬¡ä¸é‡è¯•
        if i < r.maxRetries {
            fmt.Printf("[RETRY] Attempt %d failed, retrying after %v...\n", i+1, r.retryDelay)
            time.Sleep(r.retryDelay)
        }
    }

    return nil, fmt.Errorf("max retries exceeded: %w", lastErr)
}

func isTemporaryError(err error) bool {
    // ç®€åŒ–ï¼šå®é™…åº”åˆ¤æ–­å…·ä½“é”™è¯¯ç±»å‹
    return true
}

// ===== è£…é¥°å™¨2ï¼šæ—¥å¿—è£…é¥°å™¨ =====
type LoggingDecorator struct {
    client HTTPClient
}

func NewLoggingDecorator(client HTTPClient) HTTPClient {
    return &LoggingDecorator{client: client}
}

func (l *LoggingDecorator) Do(ctx context.Context, req *http.Request) (*http.Response, error) {
    start := time.Now()

    fmt.Printf("[HTTP] --> %s %s\n", req.Method, req.URL)

    resp, err := l.client.Do(ctx, req)

    elapsed := time.Since(start)
    if err != nil {
        fmt.Printf("[HTTP] <-- ERROR: %v (took %v)\n", err, elapsed)
        return nil, err
    }

    fmt.Printf("[HTTP] <-- %d %s (took %v)\n", resp.StatusCode, resp.Status, elapsed)
    return resp, nil
}

// ===== è£…é¥°å™¨3ï¼šç›‘æ§è£…é¥°å™¨ =====
type MetricsDecorator struct {
    client         HTTPClient
    requestCount   int64
    totalDuration  time.Duration
}

func NewMetricsDecorator(client HTTPClient) HTTPClient {
    return &MetricsDecorator{client: client}
}

func (m *MetricsDecorator) Do(ctx context.Context, req *http.Request) (*http.Response, error) {
    start := time.Now()
    resp, err := m.client.Do(ctx, req)
    duration := time.Since(start)

    m.requestCount++
    m.totalDuration += duration

    fmt.Printf("[METRICS] Total requests: %d, Avg duration: %v\n",
        m.requestCount, m.totalDuration/time.Duration(m.requestCount))

    return resp, err
}

// ===== è£…é¥°å™¨4ï¼šç¼“å­˜è£…é¥°å™¨ =====
type CacheDecorator struct {
    client HTTPClient
    cache  map[string]*http.Response
}

func NewCacheDecorator(client HTTPClient) HTTPClient {
    return &CacheDecorator{
        client: client,
        cache:  make(map[string]*http.Response),
    }
}

func (c *CacheDecorator) Do(ctx context.Context, req *http.Request) (*http.Response, error) {
    // åªç¼“å­˜GETè¯·æ±‚
    if req.Method != http.MethodGet {
        return c.client.Do(ctx, req)
    }

    key := req.URL.String()
    if cached, exists := c.cache[key]; exists {
        fmt.Println("[CACHE] Hit!")
        return cached, nil
    }

    resp, err := c.client.Do(ctx, req)
    if err == nil && resp.StatusCode == http.StatusOK {
        c.cache[key] = resp
        fmt.Println("[CACHE] Stored")
    }

    return resp, err
}

// ===== ä½¿ç”¨ç¤ºä¾‹ï¼šçµæ´»ç»„åˆè£…é¥°å™¨ =====
func Example() {
    ctx := context.Background()

    // åœºæ™¯1ï¼šåŸºç¡€å®¢æˆ·ç«¯ + æ—¥å¿—
    client1 := NewLoggingDecorator(
        NewBaseHTTPClient(30 * time.Second),
    )

    // åœºæ™¯2ï¼šåŸºç¡€å®¢æˆ·ç«¯ + é‡è¯• + æ—¥å¿—
    client2 := NewLoggingDecorator(
        NewRetryDecorator(
            NewBaseHTTPClient(30 * time.Second),
            3,              // æœ€å¤šé‡è¯•3æ¬¡
            2 * time.Second, // é‡è¯•é—´éš”2ç§’
        ),
    )

    // åœºæ™¯3ï¼šå®Œæ•´è£…é¥°é“¾ï¼ˆåŸºç¡€ + ç¼“å­˜ + é‡è¯• + æ—¥å¿— + ç›‘æ§ï¼‰
    client3 := NewMetricsDecorator(
        NewLoggingDecorator(
            NewRetryDecorator(
                NewCacheDecorator(
                    NewBaseHTTPClient(30 * time.Second),
                ),
                3,
                2 * time.Second,
            ),
        ),
    )

    // å‘é€è¯·æ±‚
    req, _ := http.NewRequest("GET", "https://api.example.com/users", nil)
    resp, err := client3.Do(ctx, req)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    defer resp.Body.Close()

    body, _ := io.ReadAll(resp.Body)
    fmt.Println("Response:", string(body))
}
```

#### è¾“å‡ºç¤ºä¾‹

```text
[CACHE] Stored
[RETRY] Attempt 1 failed, retrying after 2s...
[HTTP] --> GET https://api.example.com/users
[HTTP] <-- 200 OK (took 1.2s)
[METRICS] Total requests: 1, Avg duration: 1.2s
```

---

### è£…é¥°å™¨æ¨¡å¼æœ€ä½³å®è·µ

#### âœ… DO4

1. **ä¿æŒè£…é¥°å™¨å•ä¸€èŒè´£**:

    ```go
    // âœ… æ­£ç¡®ï¼šæ¯ä¸ªè£…é¥°å™¨åªåšä¸€ä»¶äº‹
    type LoggingDecorator struct { ... }
    type CachingDecorator struct { ... }
    ```

2. **è£…é¥°å™¨å¯ä»¥ç»„åˆ**:

    ```go
    // âœ… æ­£ç¡®ï¼šå¤šå±‚è£…é¥°
    client := NewLogging(NewRetry(NewCache(baseClient)))
    ```

#### âŒ DON'T4

1. **ä¸è¦åœ¨è£…é¥°å™¨ä¸­ä¿®æ”¹æ ¸å¿ƒè¡Œä¸º**:

    ```go
    // âŒ é”™è¯¯ï¼šè£…é¥°å™¨æ”¹å˜äº†è¿”å›å€¼ç±»å‹
    func (d *BadDecorator) Operation() int {  // è¿”å›ç±»å‹å˜äº†
        result := d.component.Operation()  // string
        return len(result)  // â† æ”¹å˜äº†è¡Œä¸º
    }
    ```

---

## ç¬¬å››éƒ¨åˆ†ï¼šä»£ç†æ¨¡å¼æ·±åº¦å®æˆ˜

### ä»£ç†æ¨¡å¼æ ¸å¿ƒåŸç†

#### ä»€ä¹ˆæ˜¯ä»£ç†æ¨¡å¼ï¼Ÿ

**å®šä¹‰**: ä¸ºå…¶ä»–å¯¹è±¡æä¾›ä¸€ç§ä»£ç†ä»¥æ§åˆ¶å¯¹è¿™ä¸ªå¯¹è±¡çš„è®¿é—®ã€‚

**ä»£ç†ç±»å‹**:

1. **è¿œç¨‹ä»£ç†** - RPCã€gRPC
2. **è™šæ‹Ÿä»£ç†** - å»¶è¿ŸåŠ è½½
3. **ä¿æŠ¤ä»£ç†** - æƒé™æ§åˆ¶
4. **ç¼“å­˜ä»£ç†** - ç»“æœç¼“å­˜

---

### å®æˆ˜æ¡ˆä¾‹3ï¼šæ•°æ®åº“æŸ¥è¯¢ä»£ç†ï¼ˆç¼“å­˜+å»¶è¿ŸåŠ è½½ï¼‰

#### åœºæ™¯5

- æ•°æ®åº“æŸ¥è¯¢æ€§èƒ½ç“¶é¢ˆ
- éœ€è¦æ·»åŠ ç¼“å­˜å±‚
- éœ€è¦å»¶è¿Ÿè¿æ¥

#### å®Œæ•´å®ç°5

```go
package dbproxy

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// Database æ•°æ®åº“æ¥å£
type Database interface {
    Query(ctx context.Context, sql string, args ...interface{}) ([]map[string]interface{}, error)
}

// ===== çœŸå®æ•°æ®åº“ =====
type RealDatabase struct {
    dsn string
    conn interface{}  // å®é™…çš„æ•°æ®åº“è¿æ¥
}

func NewRealDatabase(dsn string) *RealDatabase {
    return &RealDatabase{dsn: dsn}
}

func (r *RealDatabase) connect() error {
    if r.conn != nil {
        return nil
    }

    fmt.Println("[DB] Connecting to database...")
    time.Sleep(100 * time.Millisecond)  // æ¨¡æ‹Ÿè¿æ¥å»¶è¿Ÿ
    r.conn = "fake connection"
    fmt.Println("[DB] Connected!")
    return nil
}

func (r *RealDatabase) Query(ctx context.Context, sql string, args ...interface{}) ([]map[string]interface{}, error) {
    if err := r.connect(); err != nil {
        return nil, err
    }

    fmt.Printf("[DB] Executing query: %s\n", sql)
    time.Sleep(50 * time.Millisecond)  // æ¨¡æ‹ŸæŸ¥è¯¢å»¶è¿Ÿ

    // æ¨¡æ‹Ÿè¿”å›ç»“æœ
    return []map[string]interface{}{
        {"id": 1, "name": "User1"},
    }, nil
}

// ===== ç¼“å­˜ä»£ç† =====
type CacheProxy struct {
    realDB    Database
    cache     map[string]cacheEntry
    mu        sync.RWMutex
    ttl       time.Duration
}

type cacheEntry struct {
    data      []map[string]interface{}
    timestamp time.Time
}

func NewCacheProxy(realDB Database, ttl time.Duration) Database {
    return &CacheProxy{
        realDB: realDB,
        cache:  make(map[string]cacheEntry),
        ttl:    ttl,
    }
}

func (c *CacheProxy) Query(ctx context.Context, sql string, args ...interface{}) ([]map[string]interface{}, error) {
    cacheKey := fmt.Sprintf("%s:%v", sql, args)

    // æ£€æŸ¥ç¼“å­˜
    c.mu.RLock()
    if entry, exists := c.cache[cacheKey]; exists {
        if time.Since(entry.timestamp) < c.ttl {
            c.mu.RUnlock()
            fmt.Println("[CACHE] Hit!")
            return entry.data, nil
        }
    }
    c.mu.RUnlock()

    // ç¼“å­˜æœªå‘½ä¸­ï¼ŒæŸ¥è¯¢çœŸå®æ•°æ®åº“
    fmt.Println("[CACHE] Miss, querying database...")
    data, err := c.realDB.Query(ctx, sql, args...)
    if err != nil {
        return nil, err
    }

    // å­˜å…¥ç¼“å­˜
    c.mu.Lock()
    c.cache[cacheKey] = cacheEntry{
        data:      data,
        timestamp: time.Now(),
    }
    c.mu.Unlock()

    return data, nil
}

// ===== å»¶è¿ŸåŠ è½½ä»£ç† =====
type LazyLoadProxy struct {
    realDB Database
    once   sync.Once
}

func NewLazyLoadProxy(dsn string) Database {
    return &LazyLoadProxy{}
}

func (l *LazyLoadProxy) initDB() {
    l.once.Do(func() {
        fmt.Println("[LAZY] Initializing database...")
        l.realDB = NewRealDatabase("dsn")
    })
}

func (l *LazyLoadProxy) Query(ctx context.Context, sql string, args ...interface{}) ([]map[string]interface{}, error) {
    l.initDB()  // ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶æ‰åˆå§‹åŒ–
    return l.realDB.Query(ctx, sql, args...)
}

// ===== ä½¿ç”¨ç¤ºä¾‹ =====
func Example() {
    ctx := context.Background()

    // 1. åŸºç¡€æ•°æ®åº“
    realDB := NewRealDatabase("mysql://localhost:3306/mydb")

    // 2. æ·»åŠ ç¼“å­˜ä»£ç†
    cachedDB := NewCacheProxy(realDB, 5*time.Second)

    // 3. ç¬¬ä¸€æ¬¡æŸ¥è¯¢ï¼ˆç¼“å­˜æœªå‘½ä¸­ï¼‰
    start := time.Now()
    data1, _ := cachedDB.Query(ctx, "SELECT * FROM users WHERE id = ?", 1)
    fmt.Printf("First query took %v, data: %v\n", time.Since(start), data1)

    // 4. ç¬¬äºŒæ¬¡æŸ¥è¯¢ï¼ˆç¼“å­˜å‘½ä¸­ï¼‰
    start = time.Now()
    data2, _ := cachedDB.Query(ctx, "SELECT * FROM users WHERE id = ?", 1)
    fmt.Printf("Second query took %v, data: %v\n", time.Since(start), data2)
}

// è¾“å‡ºï¼š
// [DB] Connecting to database...
// [DB] Connected!
// [CACHE] Miss, querying database...
// [DB] Executing query: SELECT * FROM users WHERE id = ?
// First query took 150ms, data: [{id:1 name:User1}]
// [CACHE] Hit!
// Second query took 0.1ms, data: [{id:1 name:User1}]
```

#### æ€§èƒ½æå‡

```text
ç¬¬ä¸€æ¬¡æŸ¥è¯¢: 150ms (è¿æ¥+æŸ¥è¯¢)
ç¬¬äºŒæ¬¡æŸ¥è¯¢: 0.1ms (ç¼“å­˜å‘½ä¸­)
æ€§èƒ½æå‡: 1500å€
```

---

### å®æˆ˜æ¡ˆä¾‹4ï¼šRPCæœåŠ¡ä»£ç†

#### åœºæ™¯6

- å¾®æœåŠ¡RPCè°ƒç”¨
- éœ€è¦ï¼šé‡è¯•ã€ç†”æ–­ã€è´Ÿè½½å‡è¡¡

#### å®Œæ•´å®ç°6

```go
package rpcproxy

import (
    "context"
    "errors"
    "fmt"
    "math/rand"
    "sync"
    "time"
)

// RPCClient RPCå®¢æˆ·ç«¯æ¥å£
type RPCClient interface {
    Call(ctx context.Context, method string, args interface{}) (interface{}, error)
}

// ===== çœŸå®RPCå®¢æˆ·ç«¯ =====
type RealRPCClient struct {
    address string
}

func NewRealRPCClient(address string) RPCClient {
    return &RealRPCClient{address: address}
}

func (r *RealRPCClient) Call(ctx context.Context, method string, args interface{}) (interface{}, error) {
    fmt.Printf("[RPC] Calling %s@%s with args %v\n", method, r.address, args)
    time.Sleep(10 * time.Millisecond)  // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ

    // æ¨¡æ‹Ÿå¶å°”å¤±è´¥
    if rand.Float32() < 0.2 {
        return nil, errors.New("network error")
    }

    return "success", nil
}

// ===== ç†”æ–­å™¨ä»£ç† =====
type CircuitBreakerProxy struct {
    client           RPCClient
    failureThreshold int
    resetTimeout     time.Duration

    state         string  // "closed", "open", "half-open"
    failureCount  int
    lastFailTime  time.Time
    mu            sync.Mutex
}

func NewCircuitBreakerProxy(client RPCClient, threshold int, resetTimeout time.Duration) RPCClient {
    return &CircuitBreakerProxy{
        client:           client,
        failureThreshold: threshold,
        resetTimeout:     resetTimeout,
        state:            "closed",
    }
}

func (c *CircuitBreakerProxy) Call(ctx context.Context, method string, args interface{}) (interface{}, error) {
    c.mu.Lock()

    // æ£€æŸ¥ç†”æ–­å™¨çŠ¶æ€
    if c.state == "open" {
        if time.Since(c.lastFailTime) > c.resetTimeout {
            c.state = "half-open"
            fmt.Println("[CIRCUIT] Half-open, trying request...")
        } else {
            c.mu.Unlock()
            return nil, errors.New("circuit breaker is open")
        }
    }

    c.mu.Unlock()

    // æ‰§è¡Œè°ƒç”¨
    result, err := c.client.Call(ctx, method, args)

    c.mu.Lock()
    defer c.mu.Unlock()

    if err != nil {
        c.failureCount++
        c.lastFailTime = time.Now()

        if c.failureCount >= c.failureThreshold {
            c.state = "open"
            fmt.Printf("[CIRCUIT] OPEN! Failures: %d\n", c.failureCount)
        }

        return nil, err
    }

    // æˆåŠŸï¼Œé‡ç½®è®¡æ•°
    c.failureCount = 0
    c.state = "closed"
    return result, nil
}

// ===== è´Ÿè½½å‡è¡¡ä»£ç† =====
type LoadBalancerProxy struct {
    clients []RPCClient
    current int
    mu      sync.Mutex
}

func NewLoadBalancerProxy(addresses []string) RPCClient {
    clients := make([]RPCClient, len(addresses))
    for i, addr := range addresses {
        clients[i] = NewRealRPCClient(addr)
    }

    return &LoadBalancerProxy{
        clients: clients,
        current: 0,
    }
}

func (l *LoadBalancerProxy) Call(ctx context.Context, method string, args interface{}) (interface{}, error) {
    l.mu.Lock()
    client := l.clients[l.current]
    l.current = (l.current + 1) % len(l.clients)
    l.mu.Unlock()

    return client.Call(ctx, method, args)
}

// ===== ä½¿ç”¨ç¤ºä¾‹ =====
func Example() {
    ctx := context.Background()

    // 1. åˆ›å»ºè´Ÿè½½å‡è¡¡ä»£ç†ï¼ˆ3ä¸ªå®ä¾‹ï¼‰
    lbProxy := NewLoadBalancerProxy([]string{
        "server1:8080",
        "server2:8080",
        "server3:8080",
    })

    // 2. æ·»åŠ ç†”æ–­å™¨ä»£ç†
    cbProxy := NewCircuitBreakerProxy(lbProxy, 3, 5*time.Second)

    // 3. è¿ç»­è°ƒç”¨ï¼ˆè§‚å¯Ÿè´Ÿè½½å‡è¡¡å’Œç†”æ–­ï¼‰
    for i := 0; i < 10; i++ {
        result, err := cbProxy.Call(ctx, "GetUser", map[string]interface{}{"id": i})
        if err != nil {
            fmt.Printf("Call %d failed: %v\n", i, err)
        } else {
            fmt.Printf("Call %d succeeded: %v\n", i, result)
        }
        time.Sleep(100 * time.Millisecond)
    }
}
```

---

## ç¬¬äº”éƒ¨åˆ†ï¼šå¤–è§‚æ¨¡å¼ä¸ç»„åˆæ¨¡å¼

### å¤–è§‚æ¨¡å¼ï¼ˆFacadeï¼‰

#### ä»€ä¹ˆæ˜¯å¤–è§‚æ¨¡å¼ï¼Ÿ

**å®šä¹‰**: ä¸ºå­ç³»ç»Ÿä¸­çš„ä¸€ç»„æ¥å£æä¾›ä¸€ä¸ªç»Ÿä¸€çš„æ¥å£ï¼Œå¤–è§‚æ¨¡å¼å®šä¹‰äº†ä¸€ä¸ªé«˜å±‚æ¥å£ï¼Œè¿™ä¸ªæ¥å£ä½¿å¾—è¿™ä¸€å­ç³»ç»Ÿæ›´åŠ å®¹æ˜“ä½¿ç”¨ã€‚

#### å®æˆ˜æ¡ˆä¾‹5ï¼šè®¢å•å¤„ç†å¤–è§‚

```go
package facade

import (
    "context"
    "fmt"
)

// ===== å¤æ‚çš„å­ç³»ç»Ÿ =====

// åº“å­˜ç³»ç»Ÿ
type InventorySystem struct{}

func (i *InventorySystem) CheckStock(productID string, quantity int) bool {
    fmt.Printf("[Inventory] Checking stock for %s...\n", productID)
    return true
}

func (i *InventorySystem) ReserveStock(productID string, quantity int) error {
    fmt.Printf("[Inventory] Reserving %d units of %s\n", quantity, productID)
    return nil
}

// æ”¯ä»˜ç³»ç»Ÿ
type PaymentSystem struct{}

func (p *PaymentSystem) ProcessPayment(userID string, amount float64) (string, error) {
    fmt.Printf("[Payment] Processing payment $%.2f for user %s\n", amount, userID)
    return "txn_123456", nil
}

// ç‰©æµç³»ç»Ÿ
type ShippingSystem struct{}

func (s *ShippingSystem) CreateShipment(orderID, address string) error {
    fmt.Printf("[Shipping] Creating shipment for order %s to %s\n", orderID, address)
    return nil
}

// é€šçŸ¥ç³»ç»Ÿ
type NotificationSystem struct{}

func (n *NotificationSystem) SendEmail(userID, message string) error {
    fmt.Printf("[Notification] Sending email to %s: %s\n", userID, message)
    return nil
}

// ===== å¤–è§‚ï¼šè®¢å•å¤„ç†å¤–è§‚ =====
type OrderFacade struct {
    inventory    *InventorySystem
    payment      *PaymentSystem
    shipping     *ShippingSystem
    notification *NotificationSystem
}

func NewOrderFacade() *OrderFacade {
    return &OrderFacade{
        inventory:    &InventorySystem{},
        payment:      &PaymentSystem{},
        shipping:     &ShippingSystem{},
        notification: &NotificationSystem{},
    }
}

// PlaceOrder ä¸€ç«™å¼ä¸‹å•ï¼ˆéšè—æ‰€æœ‰å­ç³»ç»Ÿå¤æ‚æ€§ï¼‰
func (o *OrderFacade) PlaceOrder(ctx context.Context, userID, productID string, quantity int, amount float64, address string) error {
    fmt.Println("=== Starting Order Process ===")

    // 1. æ£€æŸ¥åº“å­˜
    if !o.inventory.CheckStock(productID, quantity) {
        return fmt.Errorf("insufficient stock")
    }

    // 2. é¢„ç•™åº“å­˜
    if err := o.inventory.ReserveStock(productID, quantity); err != nil {
        return fmt.Errorf("failed to reserve stock: %w", err)
    }

    // 3. å¤„ç†æ”¯ä»˜
    txnID, err := o.payment.ProcessPayment(userID, amount)
    if err != nil {
        return fmt.Errorf("payment failed: %w", err)
    }

    // 4. åˆ›å»ºç‰©æµè®¢å•
    orderID := fmt.Sprintf("order_%s", txnID)
    if err := o.shipping.CreateShipment(orderID, address); err != nil {
        return fmt.Errorf("failed to create shipment: %w", err)
    }

    // 5. å‘é€é€šçŸ¥
    message := fmt.Sprintf("Your order %s has been placed successfully!", orderID)
    o.notification.SendEmail(userID, message)

    fmt.Println("=== Order Process Completed ===")
    return nil
}

// ===== ä½¿ç”¨ç¤ºä¾‹ =====
func Example() {
    ctx := context.Background()

    // å®¢æˆ·ç«¯åªéœ€è°ƒç”¨ä¸€ä¸ªæ–¹æ³•
    facade := NewOrderFacade()

    err := facade.PlaceOrder(
        ctx,
        "user123",
        "product456",
        2,
        99.99,
        "123 Main St",
    )

    if err != nil {
        fmt.Printf("Order failed: %v\n", err)
    }
}

// è¾“å‡ºï¼š
// === Starting Order Process ===
// [Inventory] Checking stock for product456...
// [Inventory] Reserving 2 units of product456
// [Payment] Processing payment $99.99 for user user123
// [Shipping] Creating shipment for order order_txn_123456 to 123 Main St
// [Notification] Sending email to user123: Your order order_txn_123456 has been placed successfully!
// === Order Process Completed ===
```

**ä¼˜åŠ¿**:

- âœ… å®¢æˆ·ç«¯åªéœ€ä¸€ä¸ªæ–¹æ³•è°ƒç”¨
- âœ… éšè—å­ç³»ç»Ÿå¤æ‚æ€§
- âœ… æ˜“äºç»´æŠ¤å’Œæµ‹è¯•

---

### ç»„åˆæ¨¡å¼ï¼ˆCompositeï¼‰

#### ä»€ä¹ˆæ˜¯ç»„åˆæ¨¡å¼ï¼Ÿ

**å®šä¹‰**: å°†å¯¹è±¡ç»„åˆæˆæ ‘å½¢ç»“æ„ä»¥è¡¨ç¤º"éƒ¨åˆ†-æ•´ä½“"çš„å±‚æ¬¡ç»“æ„ï¼Œä½¿å¾—ç”¨æˆ·å¯¹å•ä¸ªå¯¹è±¡å’Œç»„åˆå¯¹è±¡çš„ä½¿ç”¨å…·æœ‰ä¸€è‡´æ€§ã€‚

#### å®æˆ˜ï¼šæ–‡ä»¶ç³»ç»Ÿ

```go
package composite

import "fmt"

// Component ç»„ä»¶æ¥å£
type FileSystemNode interface {
    Name() string
    Size() int
    Display(indent int)
}

// ===== å¶å­èŠ‚ç‚¹ï¼šæ–‡ä»¶ =====
type File struct {
    name string
    size int
}

func NewFile(name string, size int) *File {
    return &File{name: name, size: size}
}

func (f *File) Name() string {
    return f.name
}

func (f *File) Size() int {
    return f.size
}

func (f *File) Display(indent int) {
    fmt.Printf("%sğŸ“„ %s (%d KB)\n", getIndent(indent), f.name, f.size)
}

// ===== ç»„åˆèŠ‚ç‚¹ï¼šç›®å½• =====
type Directory struct {
    name     string
    children []FileSystemNode
}

func NewDirectory(name string) *Directory {
    return &Directory{
        name:     name,
        children: make([]FileSystemNode, 0),
    }
}

func (d *Directory) Name() string {
    return d.name
}

func (d *Directory) Size() int {
    total := 0
    for _, child := range d.children {
        total += child.Size()
    }
    return total
}

func (d *Directory) Add(node FileSystemNode) {
    d.children = append(d.children, node)
}

func (d *Directory) Display(indent int) {
    fmt.Printf("%sğŸ“ %s/ (%d KB)\n", getIndent(indent), d.name, d.Size())
    for _, child := range d.children {
        child.Display(indent + 2)
    }
}

func getIndent(level int) string {
    result := ""
    for i := 0; i < level; i++ {
        result += " "
    }
    return result
}

// ===== ä½¿ç”¨ç¤ºä¾‹ =====
func Example() {
    // æ„å»ºæ–‡ä»¶æ ‘
    root := NewDirectory("root")

    docs := NewDirectory("documents")
    docs.Add(NewFile("resume.pdf", 200))
    docs.Add(NewFile("report.docx", 500))

    photos := NewDirectory("photos")
    photos.Add(NewFile("vacation.jpg", 3000))
    photos.Add(NewFile("family.jpg", 2500))

    root.Add(docs)
    root.Add(photos)
    root.Add(NewFile("readme.txt", 10))

    // ç»Ÿä¸€æ¥å£æ“ä½œï¼ˆæ— è®ºæ–‡ä»¶è¿˜æ˜¯ç›®å½•ï¼‰
    root.Display(0)

    fmt.Printf("\nTotal size: %d KB\n", root.Size())
}

// è¾“å‡ºï¼š
// ğŸ“ root/ (6210 KB)
//   ğŸ“ documents/ (700 KB)
//     ğŸ“„ resume.pdf (200 KB)
//     ğŸ“„ report.docx (500 KB)
//   ğŸ“ photos/ (5500 KB)
//     ğŸ“„ vacation.jpg (3000 KB)
//     ğŸ“„ family.jpg (2500 KB)
//   ğŸ“„ readme.txt (10 KB)
//
// Total size: 6210 KB
```

---

## ç¬¬å…­éƒ¨åˆ†ï¼šå…¶ä»–ç»“æ„å‹æ¨¡å¼

### æ¡¥æ¥æ¨¡å¼ï¼ˆBridgeï¼‰

#### ç®€è¦è¯´æ˜

**å®šä¹‰**: å°†æŠ½è±¡éƒ¨åˆ†ä¸å®ç°éƒ¨åˆ†åˆ†ç¦»ï¼Œä½¿å®ƒä»¬éƒ½å¯ä»¥ç‹¬ç«‹å˜åŒ–ã€‚

**é€‚ç”¨åœºæ™¯**:

- å¤šç»´åº¦å˜åŒ–ï¼ˆå¦‚ï¼šä¸åŒå½¢çŠ¶ Ã— ä¸åŒé¢œè‰²ï¼‰
- è·¨å¹³å°ç³»ç»Ÿ

#### ç¤ºä¾‹ï¼šè·¨å¹³å°é€šçŸ¥

```go
// å®ç°æ¥å£
type MessageSender interface {
    Send(message string)
}

// å…·ä½“å®ç°1ï¼šé‚®ä»¶
type EmailSender struct{}

func (e *EmailSender) Send(message string) {
    fmt.Println("Email:", message)
}

// å…·ä½“å®ç°2ï¼šçŸ­ä¿¡
type SMSSender struct{}

func (s *SMSSender) Send(message string) {
    fmt.Println("SMS:", message)
}

// æŠ½è±¡æ¥å£
type Notification struct {
    sender MessageSender
}

func (n *Notification) Notify(message string) {
    n.sender.Send(message)
}

// æ‰©å±•æŠ½è±¡ï¼šç´§æ€¥é€šçŸ¥
type UrgentNotification struct {
    Notification
}

func (u *UrgentNotification) Notify(message string) {
    u.sender.Send("[URGENT] " + message)
}

// ä½¿ç”¨
func Example() {
    // ç»„åˆ1ï¼šæ™®é€šé€šçŸ¥ + é‚®ä»¶
    notification := &Notification{sender: &EmailSender{}}
    notification.Notify("Hello")

    // ç»„åˆ2ï¼šç´§æ€¥é€šçŸ¥ + çŸ­ä¿¡
    urgent := &UrgentNotification{Notification{sender: &SMSSender{}}}
    urgent.Notify("Server Down!")
}
```

---

### äº«å…ƒæ¨¡å¼ï¼ˆFlyweightï¼‰

#### ç®€è¦è¯´æ˜7

**å®šä¹‰**: è¿ç”¨å…±äº«æŠ€æœ¯æœ‰æ•ˆæ”¯æŒå¤§é‡ç»†ç²’åº¦å¯¹è±¡ã€‚

**é€‚ç”¨åœºæ™¯**:

- å¤§é‡ç›¸ä¼¼å¯¹è±¡
- å¯¹è±¡æ± 
- ç¼“å­˜

#### ç¤ºä¾‹ï¼šå›¾æ ‡ç¼“å­˜

```go
type Icon struct {
    data []byte
}

type IconFactory struct {
    cache map[string]*Icon
    mu    sync.Mutex
}

func (f *IconFactory) GetIcon(name string) *Icon {
    f.mu.Lock()
    defer f.mu.Unlock()

    if icon, exists := f.cache[name]; exists {
        fmt.Println("Icon cache hit:", name)
        return icon
    }

    // åŠ è½½å›¾æ ‡ï¼ˆæ¨¡æ‹Ÿï¼‰
    icon := &Icon{data: []byte("icon data for " + name)}
    f.cache[name] = icon
    fmt.Println("Icon loaded:", name)
    return icon
}

// ä½¿ç”¨
func Example() {
    factory := &IconFactory{cache: make(map[string]*Icon)}

    // å¤šæ¬¡è¯·æ±‚ç›¸åŒå›¾æ ‡ï¼ŒåªåŠ è½½ä¸€æ¬¡
    icon1 := factory.GetIcon("save.png")
    icon2 := factory.GetIcon("save.png")  // ç¼“å­˜å‘½ä¸­

    fmt.Println("Same icon?", icon1 == icon2)  // true
}
```

---

## ç¬¬ä¸ƒéƒ¨åˆ†ï¼šå®æˆ˜æ¡ˆä¾‹

### ç»¼åˆæ¡ˆä¾‹ï¼šå¾®æœåŠ¡ç½‘å…³

#### åœºæ™¯8

- APIç½‘å…³éœ€è¦ï¼šè®¤è¯ã€é™æµã€æ—¥å¿—ã€ç›‘æ§ã€è·¯ç”±
- ä½¿ç”¨å¤šç§ç»“æ„å‹æ¨¡å¼ç»„åˆ

#### å®Œæ•´å®ç°8

```go
package gateway

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// Handler å¤„ç†å™¨æ¥å£
type Handler interface {
    Handle(ctx context.Context, req *Request) (*Response, error)
}

// Request è¯·æ±‚
type Request struct {
    Method string
    Path   string
    Body   interface{}
    UserID string
}

// Response å“åº”
type Response struct {
    StatusCode int
    Body       interface{}
}

// ===== åŸºç¡€å¤„ç†å™¨ =====
type BaseHandler struct{}

func (b *BaseHandler) Handle(ctx context.Context, req *Request) (*Response, error) {
    fmt.Printf("[Handler] Processing %s %s\n", req.Method, req.Path)
    return &Response{
        StatusCode: 200,
        Body:       "Success",
    }, nil
}

// ===== è£…é¥°å™¨1ï¼šè®¤è¯ =====
type AuthDecorator struct {
    handler Handler
}

func NewAuthDecorator(h Handler) Handler {
    return &AuthDecorator{handler: h}
}

func (a *AuthDecorator) Handle(ctx context.Context, req *Request) (*Response, error) {
    fmt.Println("[Auth] Checking authentication...")

    if req.UserID == "" {
        return &Response{StatusCode: 401, Body: "Unauthorized"}, nil
    }

    return a.handler.Handle(ctx, req)
}

// ===== è£…é¥°å™¨2ï¼šé™æµ =====
type RateLimitDecorator struct {
    handler    Handler
    tokens     int
    maxTokens  int
    lastRefill time.Time
    mu         sync.Mutex
}

func NewRateLimitDecorator(h Handler, maxTokens int) Handler {
    return &RateLimitDecorator{
        handler:    h,
        tokens:     maxTokens,
        maxTokens:  maxTokens,
        lastRefill: time.Now(),
    }
}

func (r *RateLimitDecorator) Handle(ctx context.Context, req *Request) (*Response, error) {
    r.mu.Lock()

    // ä»¤ç‰Œæ¡¶ç®—æ³•ï¼šæ¯ç§’è¡¥å……ä»¤ç‰Œ
    elapsed := time.Since(r.lastRefill)
    if elapsed > time.Second {
        r.tokens = r.maxTokens
        r.lastRefill = time.Now()
    }

    if r.tokens <= 0 {
        r.mu.Unlock()
        fmt.Println("[RateLimit] Request rejected - too many requests")
        return &Response{StatusCode: 429, Body: "Too Many Requests"}, nil
    }

    r.tokens--
    r.mu.Unlock()

    fmt.Printf("[RateLimit] Request allowed, tokens left: %d\n", r.tokens)
    return r.handler.Handle(ctx, req)
}

// ===== è£…é¥°å™¨3ï¼šæ—¥å¿— =====
type LoggingDecorator struct {
    handler Handler
}

func NewLoggingDecorator(h Handler) Handler {
    return &LoggingDecorator{handler: h}
}

func (l *LoggingDecorator) Handle(ctx context.Context, req *Request) (*Response, error) {
    start := time.Now()

    fmt.Printf("[Log] --> %s %s (user: %s)\n", req.Method, req.Path, req.UserID)

    resp, err := l.handler.Handle(ctx, req)

    elapsed := time.Since(start)
    fmt.Printf("[Log] <-- %d (took %v)\n", resp.StatusCode, elapsed)

    return resp, err
}

// ===== å¤–è§‚ï¼šç½‘å…³å¤–è§‚ =====
type GatewayFacade struct {
    handler Handler
}

func NewGatewayFacade() *GatewayFacade {
    // ç»„åˆæ‰€æœ‰è£…é¥°å™¨
    baseHandler := &BaseHandler{}

    handler := NewLoggingDecorator(
        NewRateLimitDecorator(
            NewAuthDecorator(baseHandler),
            10,  // æ¯ç§’10ä¸ªè¯·æ±‚
        ),
    )

    return &GatewayFacade{handler: handler}
}

func (g *GatewayFacade) ProcessRequest(req *Request) (*Response, error) {
    ctx := context.Background()
    return g.handler.Handle(ctx, req)
}

// ===== ä½¿ç”¨ç¤ºä¾‹ =====
func Example() {
    gateway := NewGatewayFacade()

    // æµ‹è¯•è¯·æ±‚
    requests := []*Request{
        {Method: "GET", Path: "/api/users", UserID: "user123"},
        {Method: "POST", Path: "/api/orders", UserID: "user123"},
        {Method: "GET", Path: "/api/products", UserID: ""},  // æ— è®¤è¯
    }

    for i, req := range requests {
        fmt.Printf("\n=== Request %d ===\n", i+1)
        resp, err := gateway.ProcessRequest(req)
        if err != nil {
            fmt.Printf("Error: %v\n", err)
        } else {
            fmt.Printf("Response: %d - %v\n", resp.StatusCode, resp.Body)
        }
    }
}
```

---

## ç¬¬å…«éƒ¨åˆ†ï¼šæœ€ä½³å®è·µ

### ç»“æ„å‹æ¨¡å¼é€‰æ‹©æŒ‡å—

#### å†³ç­–è¡¨

| åœºæ™¯ | æ¨èæ¨¡å¼ | åŸå›  |
|------|---------|------|
| æ¥å£ä¸å…¼å®¹ | é€‚é…å™¨ | æ¥å£è½¬æ¢ |
| æ·»åŠ åŠŸèƒ½ | è£…é¥°å™¨ | åŠ¨æ€æ‰©å±• |
| æ§åˆ¶è®¿é—® | ä»£ç† | è®¿é—®æ§åˆ¶ |
| ç®€åŒ–å¤æ‚ç³»ç»Ÿ | å¤–è§‚ | ç»Ÿä¸€å…¥å£ |
| æ ‘å½¢ç»“æ„ | ç»„åˆ | é€’å½’å¤„ç† |
| å¤šç»´åº¦å˜åŒ– | æ¡¥æ¥ | è§£è€¦ç»´åº¦ |
| å¯¹è±¡å¤ç”¨ | äº«å…ƒ | å†…å­˜ä¼˜åŒ– |

---

### å¸¸è§é™·é˜±

#### é™·é˜±1ï¼šè¿‡åº¦ä½¿ç”¨è£…é¥°å™¨

```go
// âŒ é”™è¯¯ï¼šè£…é¥°å±‚æ¬¡å¤ªæ·±
client := NewMetrics(
    NewLogging(
        NewRetry(
            NewCache(
                NewTimeout(
                    NewCircuitBreaker(
                        NewLoadBalancer(baseClient),
                    ),
                ),
            ),
        ),
    ),
)  // 7å±‚ï¼å¤ªå¤æ‚

// âœ… æ­£ç¡®ï¼šåˆç†ç»„åˆï¼ˆ2-3å±‚ï¼‰
client := NewLogging(
    NewRetry(baseClient),
)
```

#### é™·é˜±2ï¼šé€‚é…å™¨åŒ…å«ä¸šåŠ¡é€»è¾‘

```go
// âŒ é”™è¯¯
func (a *PaymentAdapter) Pay(amount float64) error {
    if amount < 10 {  // ä¸šåŠ¡è§„åˆ™
        return errors.New("amount too small")
    }
    return a.gateway.Pay(amount)
}

// âœ… æ­£ç¡®ï¼šé€‚é…å™¨åªåšè½¬æ¢
func (a *PaymentAdapter) Pay(amount float64) error {
    return a.gateway.Pay(amount)  // çº¯è½¬æ¢
}
```

#### é™·é˜±3ï¼šå¤–è§‚è¿‡äºå¤æ‚

```go
// âŒ é”™è¯¯ï¼šå¤–è§‚æš´éœ²å¤ªå¤šæ–¹æ³•
type Facade struct {
    // 30+ public methods
}

// âœ… æ­£ç¡®ï¼šå¤–è§‚æä¾›å°‘é‡é«˜å±‚æ¥å£
type Facade struct {
    // 3-5 methods
}
```

---

## ğŸ¯ æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **é€‚é…å™¨æ¨¡å¼**: æ¥å£è½¬æ¢ï¼Œç³»ç»Ÿé›†æˆ
2. **è£…é¥°å™¨æ¨¡å¼**: åŠ¨æ€æ‰©å±•ï¼Œçµæ´»ç»„åˆ
3. **ä»£ç†æ¨¡å¼**: æ§åˆ¶è®¿é—®ï¼Œå¢å¼ºåŠŸèƒ½
4. **å¤–è§‚æ¨¡å¼**: ç®€åŒ–æ¥å£ï¼Œç»Ÿä¸€å…¥å£
5. **ç»„åˆæ¨¡å¼**: æ ‘å½¢ç»“æ„ï¼Œä¸€è‡´æ¥å£

### æ€§èƒ½å¯¹æ¯”

```text
é€‚é…å™¨: å‡ ä¹æ— å¼€é”€ï¼ˆåªæ˜¯æ¥å£è½¬æ¢ï¼‰
è£…é¥°å™¨: è½»å¾®å¼€é”€ï¼ˆå‡½æ•°è°ƒç”¨é“¾ï¼‰
ä»£ç†: å–å†³äºä»£ç†é€»è¾‘ï¼ˆç¼“å­˜å¯å¤§å¹…æå‡æ€§èƒ½ï¼‰
å¤–è§‚: å‡ ä¹æ— å¼€é”€ï¼ˆåªæ˜¯å°è£…ï¼‰
ç»„åˆ: é€’å½’å¼€é”€ï¼ˆæ·±åº¦è¿‡å¤§æ—¶æ³¨æ„æ€§èƒ½ï¼‰
```

---

## ğŸ“š å‚è€ƒèµ„æº

**ä¹¦ç±**:

- ã€ŠDesign Patterns: Elements of Reusable Object-Oriented Softwareã€‹
- ã€ŠHead First Design Patternsã€‹

**åœ¨çº¿èµ„æº**:

- [Refactoring Guru - Structural Patterns](https://refactoring.guru/design-patterns/structural-patterns)
- [Go Patterns](https://github.com/tmrts/go-patterns)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v3.0

<div align="center">

Made with â¤ï¸ for Go Developers

[â¬† å›[â¬† å›åˆ°é¡¶éƒ¨](#å›åˆ°é¡¶éƒ¨)</div>

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team
**æœ€åæ›´æ–°**: 2025-10-29
**æ–‡æ¡£çŠ¶æ€**: å®Œæˆ
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
