# Goåˆ†å¸ƒå¼å‹è®¾è®¡æ¨¡å¼

> **ç®€ä»‹**: æŒæ¡Goåˆ†å¸ƒå¼ç³»ç»Ÿè®¾è®¡æ¨¡å¼ï¼ŒåŒ…æ‹¬æœåŠ¡å‘ç°ã€ç†”æ–­å™¨ã€åˆ†å¸ƒå¼é”ã€é™æµå’ŒSagaæ¨¡å¼
> **ç‰ˆæœ¬**: Go 1.23+  
> **éš¾åº¦**: â­â­â­â­â­  
> **æ ‡ç­¾**: #è®¾è®¡æ¨¡å¼ #åˆ†å¸ƒå¼æ¨¡å¼ #å¾®æœåŠ¡ #æ¶æ„è®¾è®¡

<!-- TOC START -->
- [Goåˆ†å¸ƒå¼å‹è®¾è®¡æ¨¡å¼](#goåˆ†å¸ƒå¼å‹è®¾è®¡æ¨¡å¼)
  - [ç†è®ºåŸºç¡€ä¸åˆ†ç±»](#ç†è®ºåŸºç¡€ä¸åˆ†ç±»)
  - [æœåŠ¡æ³¨å†Œä¸å‘ç°](#æœåŠ¡æ³¨å†Œä¸å‘ç°)
  - [ç†”æ–­å™¨æ¨¡å¼](#ç†”æ–­å™¨æ¨¡å¼)
  - [åˆ†å¸ƒå¼é”](#åˆ†å¸ƒå¼é”)
  - [é™æµæ¨¡å¼](#é™æµæ¨¡å¼)
  - [å¹‚ç­‰æ¨¡å¼](#å¹‚ç­‰æ¨¡å¼)
  - [Saga/è¡¥å¿äº‹åŠ¡](#sagaè¡¥å¿äº‹åŠ¡)
  - [é‡è¯•æ¨¡å¼](#é‡è¯•æ¨¡å¼)
  - [æœ€ä½³å®è·µä¸å¸¸è§é™·é˜±](#æœ€ä½³å®è·µä¸å¸¸è§é™·é˜±)
<!-- TOC END -->


## ğŸ“‹ ç›®å½•


- [ç†è®ºåŸºç¡€ä¸åˆ†ç±»](#ç†è®ºåŸºç¡€ä¸åˆ†ç±»)
  - [åˆ†å¸ƒå¼ç³»ç»Ÿçš„æŒ‘æˆ˜](#åˆ†å¸ƒå¼ç³»ç»Ÿçš„æŒ‘æˆ˜)
  - [CAPå®šç†](#capå®šç†)
  - [æ¨¡å¼åˆ†ç±»](#æ¨¡å¼åˆ†ç±»)
- [æœåŠ¡æ³¨å†Œä¸å‘ç°](#æœåŠ¡æ³¨å†Œä¸å‘ç°)
  - [å®šä¹‰](#å®šä¹‰)
  - [å®ç°](#å®ç°)
- [ç†”æ–­å™¨æ¨¡å¼](#ç†”æ–­å™¨æ¨¡å¼)
  - [å®šä¹‰](#å®šä¹‰)
  - [çŠ¶æ€æœº](#çŠ¶æ€æœº)
  - [å®ç°](#å®ç°)
- [åˆ†å¸ƒå¼é”](#åˆ†å¸ƒå¼é”)
  - [å®šä¹‰](#å®šä¹‰)
  - [åŸºäºRediså®ç°](#åŸºäºrediså®ç°)
- [é™æµæ¨¡å¼](#é™æµæ¨¡å¼)
  - [å®šä¹‰](#å®šä¹‰)
  - [ä»¤ç‰Œæ¡¶ç®—æ³•](#ä»¤ç‰Œæ¡¶ç®—æ³•)
- [å¹‚ç­‰æ¨¡å¼](#å¹‚ç­‰æ¨¡å¼)
  - [å®šä¹‰](#å®šä¹‰)
  - [å®ç°](#å®ç°)
- [Saga/è¡¥å¿äº‹åŠ¡](#sagaè¡¥å¿äº‹åŠ¡)
  - [å®šä¹‰](#å®šä¹‰)
  - [å®ç°](#å®ç°)
- [é‡è¯•æ¨¡å¼](#é‡è¯•æ¨¡å¼)
  - [å®šä¹‰](#å®šä¹‰)
  - [æŒ‡æ•°é€€é¿é‡è¯•](#æŒ‡æ•°é€€é¿é‡è¯•)
- [æœ€ä½³å®è·µä¸å¸¸è§é™·é˜±](#æœ€ä½³å®è·µä¸å¸¸è§é™·é˜±)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [å¸¸è§é™·é˜±](#å¸¸è§é™·é˜±)
  - [å¼€æºå·¥å…·æ¨è](#å¼€æºå·¥å…·æ¨è)

## ç†è®ºåŸºç¡€ä¸åˆ†ç±»

### åˆ†å¸ƒå¼ç³»ç»Ÿçš„æŒ‘æˆ˜

åˆ†å¸ƒå¼ç³»ç»Ÿé¢ä¸´çš„æ ¸å¿ƒæŒ‘æˆ˜ï¼š
- **ç½‘ç»œä¸å¯é **ï¼šå»¶è¿Ÿã€ä¸¢åŒ…ã€åˆ†åŒº
- **éƒ¨åˆ†å¤±è´¥**ï¼šèŠ‚ç‚¹æ•…éšœã€ç½‘ç»œåˆ†åŒº
- **ä¸€è‡´æ€§é—®é¢˜**ï¼šCAPå®šç†çš„æƒè¡¡
- **æ—¶é’Ÿä¸åŒæ­¥**ï¼šåˆ†å¸ƒå¼æ—¶åºé—®é¢˜

### CAPå®šç†

```
CAPå®šç†ï¼šåˆ†å¸ƒå¼ç³»ç»Ÿæœ€å¤šåŒæ—¶æ»¡è¶³ä¸¤ä¸ªï¼š
- Consistency (ä¸€è‡´æ€§)
- Availability (å¯ç”¨æ€§)
- Partition Tolerance (åˆ†åŒºå®¹é”™)

å¸¸è§é€‰æ‹©ï¼š
- CP: Consul, etcd, Zookeeper
- AP: Cassandra, DynamoDB, Eureka
```

### æ¨¡å¼åˆ†ç±»

| æ¨¡å¼ | æ ¸å¿ƒç›®æ ‡ | é€‚ç”¨åœºæ™¯ |
|------|---------|----------|
| **æœåŠ¡å‘ç°** | åŠ¨æ€æœåŠ¡å®šä½ | å¾®æœåŠ¡ã€å¼¹æ€§ä¼¸ç¼© |
| **ç†”æ–­å™¨** | æ•…éšœéš”ç¦» | é˜²æ­¢çº§è”å¤±è´¥ |
| **åˆ†å¸ƒå¼é”** | å…¨å±€äº’æ–¥ | åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦ |
| **é™æµ** | è¿‡è½½ä¿æŠ¤ | æµé‡æ§åˆ¶ |
| **å¹‚ç­‰** | é˜²é‡å¤æ‰§è¡Œ | æ¶ˆæ¯ã€æ”¯ä»˜ |
| **Saga** | åˆ†å¸ƒå¼äº‹åŠ¡ | è·¨æœåŠ¡ä¸€è‡´æ€§ |
| **é‡è¯•** | æ•…éšœå®¹é”™ | ä¸´æ—¶æ€§å¤±è´¥ |

---

## æœåŠ¡æ³¨å†Œä¸å‘ç°

### å®šä¹‰

æœåŠ¡æ³¨å†Œä¸å‘ç°ï¼ˆService Registry & Discoveryï¼‰å…è®¸æœåŠ¡åŠ¨æ€æ³¨å†Œå’Œå‘ç°å½¼æ­¤ï¼Œæ”¯æŒå¼¹æ€§ä¼¸ç¼©ã€‚

### å®ç°

```go
package main

import (
    "sync"
    "time"
)

// ServiceInstance æœåŠ¡å®ä¾‹
type ServiceInstance struct {
    ID      string
    Name    string
    Address string
    Port    int
    Health  bool
    LastSeen time.Time
}

// ServiceRegistry æœåŠ¡æ³¨å†Œä¸­å¿ƒ
type ServiceRegistry struct {
    services map[string]map[string]*ServiceInstance
    mu       sync.RWMutex
    ttl      time.Duration
}

// NewServiceRegistry åˆ›å»ºæ³¨å†Œä¸­å¿ƒ
func NewServiceRegistry(ttl time.Duration) *ServiceRegistry {
    sr := &ServiceRegistry{
        services: make(map[string]map[string]*ServiceInstance),
        ttl:      ttl,
    }
    go sr.healthCheck()
    return sr
}

// Register æ³¨å†ŒæœåŠ¡
func (sr *ServiceRegistry) Register(instance *ServiceInstance) {
    sr.mu.Lock()
    defer sr.mu.Unlock()
    
    if sr.services[instance.Name] == nil {
        sr.services[instance.Name] = make(map[string]*ServiceInstance)
    }
    
    instance.LastSeen = time.Now()
    instance.Health = true
    sr.services[instance.Name][instance.ID] = instance
}

// Deregister æ³¨é”€æœåŠ¡
func (sr *ServiceRegistry) Deregister(serviceName, instanceID string) {
    sr.mu.Lock()
    defer sr.mu.Unlock()
    
    if instances, ok := sr.services[serviceName]; ok {
        delete(instances, instanceID)
    }
}

// Discover å‘ç°æœåŠ¡
func (sr *ServiceRegistry) Discover(serviceName string) []*ServiceInstance {
    sr.mu.RLock()
    defer sr.mu.RUnlock()
    
    instances := sr.services[serviceName]
    result := make([]*ServiceInstance, 0, len(instances))
    
    for _, instance := range instances {
        if instance.Health {
            result = append(result, instance)
        }
    }
    
    return result
}

// Heartbeat å¿ƒè·³
func (sr *ServiceRegistry) Heartbeat(serviceName, instanceID string) {
    sr.mu.Lock()
    defer sr.mu.Unlock()
    
    if instances, ok := sr.services[serviceName]; ok {
        if instance, ok := instances[instanceID]; ok {
            instance.LastSeen = time.Now()
            instance.Health = true
        }
    }
}

// healthCheck å¥åº·æ£€æŸ¥
func (sr *ServiceRegistry) healthCheck() {
    ticker := time.NewTicker(sr.ttl / 2)
    defer ticker.Stop()
    
    for range ticker.C {
        sr.mu.Lock()
        now := time.Now()
        
        for _, instances := range sr.services {
            for _, instance := range instances {
                if now.Sub(instance.LastSeen) > sr.ttl {
                    instance.Health = false
                }
            }
        }
        sr.mu.Unlock()
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    registry := NewServiceRegistry(10 * time.Second)
    
    // æ³¨å†ŒæœåŠ¡
    registry.Register(&ServiceInstance{
        ID:      "service-1",
        Name:    "user-service",
        Address: "192.168.1.10",
        Port:    8080,
    })
    
    // å‘ç°æœåŠ¡
    instances := registry.Discover("user-service")
    for _, inst := range instances {
        println(inst.Address, inst.Port)
    }
    
    // å¿ƒè·³
    registry.Heartbeat("user-service", "service-1")
}
```

---

## ç†”æ–­å™¨æ¨¡å¼

### å®šä¹‰

ç†”æ–­å™¨ï¼ˆCircuit Breakerï¼‰ç›‘æ§æœåŠ¡è°ƒç”¨å¤±è´¥ç‡ï¼Œè‡ªåŠ¨æ–­å¼€æ•…éšœæœåŠ¡ï¼Œé˜²æ­¢çº§è”æ•…éšœã€‚

### çŠ¶æ€æœº

```
Closed (é—­åˆ) --[å¤±è´¥ç‡>é˜ˆå€¼]--> Open (å¼€è·¯)
     ^                               |
     |                               v
     +--------[ç­‰å¾…è¶…æ—¶]------ Half-Open (åŠå¼€)
```

### å®ç°

```go
package main

import (
    "errors"
    "sync"
    "time"
)

// State ç†”æ–­å™¨çŠ¶æ€
type State int

const (
    StateClosed State = iota
    StateOpen
    StateHalfOpen
)

// CircuitBreaker ç†”æ–­å™¨
type CircuitBreaker struct {
    state        State
    failureCount int
    successCount int
    threshold    int           // å¤±è´¥é˜ˆå€¼
    timeout      time.Duration // å¼€è·¯è¶…æ—¶
    lastFailTime time.Time
    mu           sync.Mutex
}

// NewCircuitBreaker åˆ›å»ºç†”æ–­å™¨
func NewCircuitBreaker(threshold int, timeout time.Duration) *CircuitBreaker {
    return &CircuitBreaker{
        state:     StateClosed,
        threshold: threshold,
        timeout:   timeout,
    }
}

// Call æ‰§è¡Œè°ƒç”¨
func (cb *CircuitBreaker) Call(fn func() error) error {
    cb.mu.Lock()
    
    // æ£€æŸ¥æ˜¯å¦åº”è¯¥ä»å¼€è·¯è½¬ä¸ºåŠå¼€
    if cb.state == StateOpen {
        if time.Since(cb.lastFailTime) > cb.timeout {
            cb.state = StateHalfOpen
            cb.successCount = 0
        } else {
            cb.mu.Unlock()
            return errors.New("circuit breaker is open")
        }
    }
    
    cb.mu.Unlock()
    
    // æ‰§è¡Œè°ƒç”¨
    err := fn()
    
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    if err != nil {
        cb.onFailure()
        return err
    }
    
    cb.onSuccess()
    return nil
}

// onFailure å¤„ç†å¤±è´¥
func (cb *CircuitBreaker) onFailure() {
    cb.failureCount++
    cb.lastFailTime = time.Now()
    
    if cb.state == StateHalfOpen {
        cb.state = StateOpen
        return
    }
    
    if cb.failureCount >= cb.threshold {
        cb.state = StateOpen
    }
}

// onSuccess å¤„ç†æˆåŠŸ
func (cb *CircuitBreaker) onSuccess() {
    if cb.state == StateHalfOpen {
        cb.successCount++
        if cb.successCount >= cb.threshold {
            cb.state = StateClosed
            cb.failureCount = 0
        }
    } else {
        cb.failureCount = 0
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    cb := NewCircuitBreaker(3, 10*time.Second)
    
    for i := 0; i < 10; i++ {
        err := cb.Call(func() error {
            // æ¨¡æ‹ŸæœåŠ¡è°ƒç”¨
            return callRemoteService()
        })
        
        if err != nil {
            println("Call failed:", err.Error())
        }
    }
}
```

---

## åˆ†å¸ƒå¼é”

### å®šä¹‰

åˆ†å¸ƒå¼é”ä¿è¯å¤šä¸ªèŠ‚ç‚¹é—´å¯¹å…±äº«èµ„æºçš„äº’æ–¥è®¿é—®ã€‚

### åŸºäºRediså®ç°

```go
package main

import (
    "context"
    "errors"
    "time"
    
    "github.com/go-redis/redis/v8"
)

// DistributedLock åˆ†å¸ƒå¼é”
type DistributedLock struct {
    client *redis.Client
    key    string
    value  string
    ttl    time.Duration
}

// NewDistributedLock åˆ›å»ºåˆ†å¸ƒå¼é”
func NewDistributedLock(client *redis.Client, key string, ttl time.Duration) *DistributedLock {
    return &DistributedLock{
        client: client,
        key:    key,
        value:  generateUniqueID(),
        ttl:    ttl,
    }
}

// Lock è·å–é”
func (dl *DistributedLock) Lock(ctx context.Context) error {
    // ä½¿ç”¨SET NX EXå‘½ä»¤
    ok, err := dl.client.SetNX(ctx, dl.key, dl.value, dl.ttl).Result()
    if err != nil {
        return err
    }
    
    if !ok {
        return errors.New("failed to acquire lock")
    }
    
    // å¯åŠ¨ç»­æœŸgoroutine
    go dl.renew(ctx)
    
    return nil
}

// Unlock é‡Šæ”¾é”
func (dl *DistributedLock) Unlock(ctx context.Context) error {
    // Luaè„šæœ¬ç¡®ä¿åªåˆ é™¤è‡ªå·±çš„é”
    script := `
        if redis.call("get", KEYS[1]) == ARGV[1] then
            return redis.call("del", KEYS[1])
        else
            return 0
        end
    `
    
    result, err := dl.client.Eval(ctx, script, []string{dl.key}, dl.value).Result()
    if err != nil {
        return err
    }
    
    if result == int64(0) {
        return errors.New("lock not held")
    }
    
    return nil
}

// renew è‡ªåŠ¨ç»­æœŸ
func (dl *DistributedLock) renew(ctx context.Context) {
    ticker := time.NewTicker(dl.ttl / 3)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            dl.client.Expire(ctx, dl.key, dl.ttl)
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    client := redis.NewClient(&redis.Options{
        Addr: "localhost:6379",
    })
    
    lock := NewDistributedLock(client, "my-lock", 10*time.Second)
    ctx := context.Background()
    
    if err := lock.Lock(ctx); err != nil {
        panic(err)
    }
    defer lock.Unlock(ctx)
    
    // æ‰§è¡Œå…³é”®æ“ä½œ
    performCriticalSection()
}
```

---

## é™æµæ¨¡å¼

### å®šä¹‰

é™æµï¼ˆRate Limitingï¼‰æ§åˆ¶ç³»ç»Ÿå¤„ç†è¯·æ±‚çš„é€Ÿç‡ï¼Œé˜²æ­¢è¿‡è½½ã€‚

### ä»¤ç‰Œæ¡¶ç®—æ³•

```go
package main

import (
    "context"
    "sync"
    "time"
)

// TokenBucket ä»¤ç‰Œæ¡¶
type TokenBucket struct {
    capacity  int           // æ¡¶å®¹é‡
    rate      int           // ä»¤ç‰Œç”Ÿæˆé€Ÿç‡ï¼ˆä¸ª/ç§’ï¼‰
    tokens    int           // å½“å‰ä»¤ç‰Œæ•°
    lastToken time.Time     // ä¸Šæ¬¡æ·»åŠ ä»¤ç‰Œæ—¶é—´
    mu        sync.Mutex
}

// NewTokenBucket åˆ›å»ºä»¤ç‰Œæ¡¶
func NewTokenBucket(capacity, rate int) *TokenBucket {
    tb := &TokenBucket{
        capacity:  capacity,
        rate:      rate,
        tokens:    capacity,
        lastToken: time.Now(),
    }
    go tb.refill()
    return tb
}

// Allow è¯·æ±‚æ˜¯å¦å…è®¸
func (tb *TokenBucket) Allow() bool {
    tb.mu.Lock()
    defer tb.mu.Unlock()
    
    if tb.tokens > 0 {
        tb.tokens--
        return true
    }
    
    return false
}

// refill å®šæœŸè¡¥å……ä»¤ç‰Œ
func (tb *TokenBucket) refill() {
    ticker := time.NewTicker(time.Second / time.Duration(tb.rate))
    defer ticker.Stop()
    
    for range ticker.C {
        tb.mu.Lock()
        if tb.tokens < tb.capacity {
            tb.tokens++
        }
        tb.mu.Unlock()
    }
}

// ä½¿ç”¨golang.org/x/time/rateï¼ˆæ¨èï¼‰
import "golang.org/x/time/rate"

func main() {
    // é™åˆ¶ï¼šæ¯ç§’10ä¸ªè¯·æ±‚ï¼Œçªå‘20ä¸ª
    limiter := rate.NewLimiter(10, 20)
    
    for i := 0; i < 100; i++ {
        if limiter.Allow() {
            handleRequest()
        } else {
            rejectRequest()
        }
    }
    
    // å¸¦è¶…æ—¶çš„é™æµ
    ctx, cancel := context.WithTimeout(context.Background(), time.Second)
    defer cancel()
    
    if err := limiter.Wait(ctx); err != nil {
        // è¶…æ—¶
    } else {
        handleRequest()
    }
}
```

---

## å¹‚ç­‰æ¨¡å¼

### å®šä¹‰

å¹‚ç­‰ï¼ˆIdempotencyï¼‰ç¡®ä¿å¤šæ¬¡æ‰§è¡Œäº§ç”Ÿç›¸åŒç»“æœï¼Œé˜²æ­¢é‡å¤æ“ä½œã€‚

### å®ç°

```go
package main

import (
    "context"
    "sync"
    "time"
)

// IdempotencyKey å¹‚ç­‰é”®
type IdempotencyKey struct {
    key    string
    result interface{}
    err    error
    done   bool
}

// IdempotencyManager å¹‚ç­‰ç®¡ç†å™¨
type IdempotencyManager struct {
    store map[string]*IdempotencyKey
    mu    sync.RWMutex
    ttl   time.Duration
}

// NewIdempotencyManager åˆ›å»ºç®¡ç†å™¨
func NewIdempotencyManager(ttl time.Duration) *IdempotencyManager {
    im := &IdempotencyManager{
        store: make(map[string]*IdempotencyKey),
        ttl:   ttl,
    }
    go im.cleanup()
    return im
}

// Execute å¹‚ç­‰æ‰§è¡Œ
func (im *IdempotencyManager) Execute(
    key string,
    fn func() (interface{}, error),
) (interface{}, error) {
    // æ£€æŸ¥æ˜¯å¦å·²æ‰§è¡Œ
    im.mu.RLock()
    if ik, ok := im.store[key]; ok {
        if ik.done {
            im.mu.RUnlock()
            return ik.result, ik.err
        }
    }
    im.mu.RUnlock()
    
    // æ‰§è¡Œæ“ä½œ
    im.mu.Lock()
    ik, ok := im.store[key]
    if !ok {
        ik = &IdempotencyKey{key: key}
        im.store[key] = ik
    }
    im.mu.Unlock()
    
    // æ‰§è¡Œ
    result, err := fn()
    
    im.mu.Lock()
    ik.result = result
    ik.err = err
    ik.done = true
    im.mu.Unlock()
    
    return result, err
}

// cleanup æ¸…ç†è¿‡æœŸé”®
func (im *IdempotencyManager) cleanup() {
    ticker := time.NewTicker(im.ttl)
    defer ticker.Stop()
    
    for range ticker.C {
        im.mu.Lock()
        for key := range im.store {
            delete(im.store, key)
        }
        im.mu.Unlock()
    }
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šæ”¯ä»˜å¹‚ç­‰
func processPayment(orderID string, amount int) error {
    im := NewIdempotencyManager(time.Hour)
    
    result, err := im.Execute(orderID, func() (interface{}, error) {
        // å®é™…æ”¯ä»˜é€»è¾‘
        return chargeCard(orderID, amount)
    })
    
    return err
}
```

---

## Saga/è¡¥å¿äº‹åŠ¡

### å®šä¹‰

Sagaæ¨¡å¼å°†é•¿äº‹åŠ¡æ‹†åˆ†ä¸ºä¸€ç³»åˆ—æœ¬åœ°äº‹åŠ¡ï¼Œå¤±è´¥æ—¶æŒ‰é¡ºåºæ‰§è¡Œè¡¥å¿æ“ä½œã€‚

### å®ç°

```go
package main

import (
    "fmt"
)

// SagaStep Sagaæ­¥éª¤
type SagaStep struct {
    Name       string
    Action     func() error
    Compensate func() error
}

// Saga Sagaç¼–æ’å™¨
type Saga struct {
    steps []SagaStep
}

// NewSaga åˆ›å»ºSaga
func NewSaga() *Saga {
    return &Saga{
        steps: make([]SagaStep, 0),
    }
}

// AddStep æ·»åŠ æ­¥éª¤
func (s *Saga) AddStep(step SagaStep) {
    s.steps = append(s.steps, step)
}

// Execute æ‰§è¡ŒSaga
func (s *Saga) Execute() error {
    executed := 0
    
    // æ­£å‘æ‰§è¡Œ
    for i, step := range s.steps {
        fmt.Printf("Executing step: %s\n", step.Name)
        if err := step.Action(); err != nil {
            fmt.Printf("Step %s failed: %v\n", step.Name, err)
            
            // è¡¥å¿å·²æ‰§è¡Œçš„æ­¥éª¤
            s.compensate(executed)
            return err
        }
        executed = i + 1
    }
    
    return nil
}

// compensate æ‰§è¡Œè¡¥å¿
func (s *Saga) compensate(until int) {
    for i := until - 1; i >= 0; i-- {
        step := s.steps[i]
        fmt.Printf("Compensating step: %s\n", step.Name)
        if err := step.Compensate(); err != nil {
            fmt.Printf("Compensation failed for %s: %v\n", step.Name, err)
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šè®¢å•å¤„ç†Saga
func main() {
    saga := NewSaga()
    
    // æ­¥éª¤1ï¼šåˆ›å»ºè®¢å•
    saga.AddStep(SagaStep{
        Name: "CreateOrder",
        Action: func() error {
            return createOrder()
        },
        Compensate: func() error {
            return deleteOrder()
        },
    })
    
    // æ­¥éª¤2ï¼šæ‰£å‡åº“å­˜
    saga.AddStep(SagaStep{
        Name: "DeductInventory",
        Action: func() error {
            return deductInventory()
        },
        Compensate: func() error {
            return restoreInventory()
        },
    })
    
    // æ­¥éª¤3ï¼šæ‰£æ¬¾
    saga.AddStep(SagaStep{
        Name: "ChargePayment",
        Action: func() error {
            return chargePayment()
        },
        Compensate: func() error {
            return refundPayment()
        },
    })
    
    // æ‰§è¡Œ
    if err := saga.Execute(); err != nil {
        fmt.Println("Saga failed:", err)
    } else {
        fmt.Println("Saga succeeded")
    }
}
```

---

## é‡è¯•æ¨¡å¼

### å®šä¹‰

é‡è¯•æ¨¡å¼åœ¨ä¸´æ—¶æ€§å¤±è´¥æ—¶è‡ªåŠ¨é‡è¯•æ“ä½œï¼Œæé«˜ç³»ç»Ÿå®¹é”™æ€§ã€‚

### æŒ‡æ•°é€€é¿é‡è¯•

```go
package main

import (
    "context"
    "errors"
    "time"
)

// RetryConfig é‡è¯•é…ç½®
type RetryConfig struct {
    MaxRetries  int
    InitialWait time.Duration
    MaxWait     time.Duration
    Multiplier  float64
}

// Retry æ‰§è¡Œé‡è¯•
func Retry(ctx context.Context, config RetryConfig, fn func() error) error {
    var lastErr error
    wait := config.InitialWait
    
    for i := 0; i <= config.MaxRetries; i++ {
        if i > 0 {
            select {
            case <-ctx.Done():
                return ctx.Err()
            case <-time.After(wait):
            }
            
            wait = time.Duration(float64(wait) * config.Multiplier)
            if wait > config.MaxWait {
                wait = config.MaxWait
            }
        }
        
        if err := fn(); err != nil {
            lastErr = err
            if !isRetryable(err) {
                return err
            }
            continue
        }
        
        return nil
    }
    
    return lastErr
}

// isRetryable åˆ¤æ–­é”™è¯¯æ˜¯å¦å¯é‡è¯•
func isRetryable(err error) bool {
    // åˆ¤æ–­æ˜¯å¦ä¸ºä¸´æ—¶æ€§é”™è¯¯
    return true
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    config := RetryConfig{
        MaxRetries:  3,
        InitialWait: time.Second,
        MaxWait:     10 * time.Second,
        Multiplier:  2.0,
    }
    
    ctx := context.Background()
    
    err := Retry(ctx, config, func() error {
        return callRemoteService()
    })
    
    if err != nil {
        println("Failed after retries:", err.Error())
    }
}
```

---

## æœ€ä½³å®è·µä¸å¸¸è§é™·é˜±

### æœ€ä½³å®è·µ

1. **æœåŠ¡å‘ç°**
   - ä½¿ç”¨æˆç†Ÿä¸­é—´ä»¶ï¼ˆConsulã€etcdã€Eurekaï¼‰
   - å®ç°å¥åº·æ£€æŸ¥
   - è€ƒè™‘AP vs CPæƒè¡¡

2. **ç†”æ–­å™¨**
   - åˆç†è®¾ç½®é˜ˆå€¼å’Œè¶…æ—¶
   - è®°å½•ç†”æ–­äº‹ä»¶
   - æä¾›é™çº§æ–¹æ¡ˆ

3. **åˆ†å¸ƒå¼é”**
   - è®¾ç½®åˆç†TTL
   - å®ç°è‡ªåŠ¨ç»­æœŸ
   - ä½¿ç”¨å”¯ä¸€IDé˜²æ­¢è¯¯åˆ 

4. **é™æµ**
   - å¤šå±‚é™æµï¼ˆç½‘å…³ã€æœåŠ¡ã€æ¥å£ï¼‰
   - åŒºåˆ†ç”¨æˆ·/IPç»´åº¦
   - æä¾›é™çº§å“åº”

5. **å¹‚ç­‰**
   - ä½¿ç”¨å…¨å±€å”¯ä¸€ID
   - è®¾ç½®åˆç†è¿‡æœŸæ—¶é—´
   - è€ƒè™‘å¹¶å‘åœºæ™¯

### å¸¸è§é™·é˜±

**1. åˆ†å¸ƒå¼é”æ­»é”**

```go
// âŒ æœªè®¾ç½®TTLå¯¼è‡´æ­»é”
lock.Lock()
// å¦‚æœè¿›ç¨‹å´©æºƒï¼Œé”æ°¸è¿œä¸é‡Šæ”¾

// âœ… è®¾ç½®TTLè‡ªåŠ¨è¿‡æœŸ
lock.LockWithTTL(30 * time.Second)
```

**2. ç†”æ–­å™¨è¯¯åˆ¤**

```go
// âŒ é˜ˆå€¼è¿‡ä½å¯¼è‡´é¢‘ç¹ç†”æ–­
cb := NewCircuitBreaker(1, 1*time.Second)

// âœ… åˆç†è®¾ç½®é˜ˆå€¼
cb := NewCircuitBreaker(5, 10*time.Second)
```

**3. Sagaè¡¥å¿å¤±è´¥**

```go
// âœ… è¡¥å¿æ“ä½œå¿…é¡»å¹‚ç­‰
func compensate() error {
    // ç¡®ä¿å¤šæ¬¡æ‰§è¡Œç»“æœä¸€è‡´
}
```

### å¼€æºå·¥å…·æ¨è

- **æœåŠ¡å‘ç°**: Consul, etcd, Eureka
- **ç†”æ–­å™¨**: hystrix-go, gobreaker
- **åˆ†å¸ƒå¼é”**: redislock, etcd/clientv3
- **é™æµ**: golang.org/x/time/rate, Sentinel
- **Saga**: go-saga

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ27æ—¥  
**æ–‡æ¡£çŠ¶æ€**: å·²ä¼˜åŒ–  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
