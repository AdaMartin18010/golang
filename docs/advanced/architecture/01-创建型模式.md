# Goåˆ›å»ºå‹è®¾è®¡æ¨¡å¼æ·±åº¦å®æˆ˜æŒ‡å—

> **ç®€ä»‹**: æ·±å…¥è§£æGoè¯­è¨€åˆ›å»ºå‹è®¾è®¡æ¨¡å¼ï¼ŒåŒ…æ‹¬å•ä¾‹ã€å·¥å‚ã€å»ºé€ è€…ã€åŸå‹ç­‰æ¨¡å¼çš„ç†è®ºä¸å®æˆ˜
> **ç‰ˆæœ¬**: Go 1.23+  
> **éš¾åº¦**: â­â­â­â­  
> **æ ‡ç­¾**: #è®¾è®¡æ¨¡å¼ #åˆ›å»ºå‹æ¨¡å¼ #å·¥ç¨‹å®è·µ #æ¶æ„è®¾è®¡

**å­—æ•°**: ~18,000å­—  
**ä»£ç ç¤ºä¾‹**: 35+ä¸ªå®Œæ•´ç¤ºä¾‹  
**å®æˆ˜æ¡ˆä¾‹**: 5ä¸ªç«¯åˆ°ç«¯æ¡ˆä¾‹  
**é€‚ç”¨äººç¾¤**: ä¸­é«˜çº§Goå¼€å‘è€…

---

## ğŸ“‹ ç›®å½•



- [ç¬¬ä¸€éƒ¨åˆ†ï¼šç†è®ºåŸºç¡€](#ç¬¬ä¸€éƒ¨åˆ†ç†è®ºåŸºç¡€)
  - [åˆ›å»ºå‹æ¨¡å¼çš„ä»·å€¼](#åˆ›å»ºå‹æ¨¡å¼çš„ä»·å€¼)
    - [ä¸ºä»€ä¹ˆéœ€è¦åˆ›å»ºå‹æ¨¡å¼ï¼Ÿ](#ä¸ºä»€ä¹ˆéœ€è¦åˆ›å»ºå‹æ¨¡å¼)
  - [åˆ›å»ºå‹æ¨¡å¼åˆ†ç±»](#åˆ›å»ºå‹æ¨¡å¼åˆ†ç±»)
  - [é€‰æ‹©åˆ›å»ºå‹æ¨¡å¼çš„å†³ç­–æ ‘](#é€‰æ‹©åˆ›å»ºå‹æ¨¡å¼çš„å†³ç­–æ ‘)
- [ç¬¬äºŒéƒ¨åˆ†ï¼šå•ä¾‹æ¨¡å¼æ·±åº¦å®æˆ˜](#ç¬¬äºŒéƒ¨åˆ†å•ä¾‹æ¨¡å¼æ·±åº¦å®æˆ˜)
  - [å•ä¾‹æ¨¡å¼æ ¸å¿ƒåŸç†](#å•ä¾‹æ¨¡å¼æ ¸å¿ƒåŸç†)
    - [ä»€ä¹ˆæ˜¯å•ä¾‹æ¨¡å¼ï¼Ÿ](#ä»€ä¹ˆæ˜¯å•ä¾‹æ¨¡å¼)
  - [Goå•ä¾‹æ¨¡å¼çš„5ç§å®ç°](#goå•ä¾‹æ¨¡å¼çš„5ç§å®ç°)
    - [å®ç°1ï¼šsync.Onceï¼ˆæ¨èâ­â­â­â­â­ï¼‰](#å®ç°1synconceæ¨è)
    - [å®ç°2ï¼šå¸¦å‚æ•°çš„å•ä¾‹](#å®ç°2å¸¦å‚æ•°çš„å•ä¾‹)
    - [å®ç°3ï¼šåŒé‡æ£€æŸ¥é”å®šï¼ˆä¸æ¨èï¼‰](#å®ç°3åŒé‡æ£€æŸ¥é”å®šä¸æ¨è)
    - [å®ç°4ï¼šinitå‡½æ•°ï¼ˆæå‰åˆå§‹åŒ–ï¼‰](#å®ç°4initå‡½æ•°æå‰åˆå§‹åŒ–)
    - [å®ç°5ï¼šæ³›å‹å•ä¾‹ï¼ˆGo 1.18+ï¼‰](#å®ç°5æ³›å‹å•ä¾‹go-118)
  - [å•ä¾‹æ¨¡å¼æ€§èƒ½å¯¹æ¯”](#å•ä¾‹æ¨¡å¼æ€§èƒ½å¯¹æ¯”)
    - [Benchmarkæµ‹è¯•](#benchmarkæµ‹è¯•)
  - [å®æˆ˜æ¡ˆä¾‹1ï¼šé…ç½®ç®¡ç†å™¨](#å®æˆ˜æ¡ˆä¾‹1é…ç½®ç®¡ç†å™¨)
    - [åœºæ™¯](#åœºæ™¯)
    - [å®Œæ•´å®ç°](#å®Œæ•´å®ç°)
  - [å•ä¾‹æ¨¡å¼æœ€ä½³å®è·µ](#å•ä¾‹æ¨¡å¼æœ€ä½³å®è·µ)
    - [âœ… DO](#-do)
    - [âŒ DON'T](#-dont)
- [ç¬¬ä¸‰éƒ¨åˆ†ï¼šå·¥å‚æ¨¡å¼æ·±åº¦å®æˆ˜](#ç¬¬ä¸‰éƒ¨åˆ†å·¥å‚æ¨¡å¼æ·±åº¦å®æˆ˜)
  - [å·¥å‚æ–¹æ³•æ¨¡å¼åŸç†](#å·¥å‚æ–¹æ³•æ¨¡å¼åŸç†)
    - [ä»€ä¹ˆæ˜¯å·¥å‚æ–¹æ³•æ¨¡å¼ï¼Ÿ](#ä»€ä¹ˆæ˜¯å·¥å‚æ–¹æ³•æ¨¡å¼)
  - [å®Œæ•´å·¥å‚æ¨¡å¼å®ç°](#å®Œæ•´å·¥å‚æ¨¡å¼å®ç°)
    - [åœºæ™¯ï¼šæ•°æ®åº“è¿æ¥å·¥å‚](#åœºæ™¯æ•°æ®åº“è¿æ¥å·¥å‚)
  - [è¿›é˜¶ï¼šæ³¨å†Œè¡¨æ¨¡å¼](#è¿›é˜¶æ³¨å†Œè¡¨æ¨¡å¼)
    - [é—®é¢˜](#é—®é¢˜)
    - [è§£å†³ï¼šä½¿ç”¨æ³¨å†Œè¡¨](#è§£å†³ä½¿ç”¨æ³¨å†Œè¡¨)
  - [å®æˆ˜æ¡ˆä¾‹2ï¼šæ—¥å¿—å·¥å‚](#å®æˆ˜æ¡ˆä¾‹2æ—¥å¿—å·¥å‚)
    - [åœºæ™¯2](#åœºæ™¯2)
    - [å®Œæ•´å®ç°2](#å®Œæ•´å®ç°2)
- [ç¬¬å››éƒ¨åˆ†ï¼šæŠ½è±¡å·¥å‚æ¨¡å¼](#ç¬¬å››éƒ¨åˆ†æŠ½è±¡å·¥å‚æ¨¡å¼)
  - [æŠ½è±¡å·¥å‚æ¨¡å¼åŸç†](#æŠ½è±¡å·¥å‚æ¨¡å¼åŸç†)
    - [ä»€ä¹ˆæ˜¯æŠ½è±¡å·¥å‚ï¼Ÿ](#ä»€ä¹ˆæ˜¯æŠ½è±¡å·¥å‚)
  - [å®Œæ•´æŠ½è±¡å·¥å‚å®ç°](#å®Œæ•´æŠ½è±¡å·¥å‚å®ç°)
    - [åœºæ™¯ï¼šè·¨å¹³å°UIç»„ä»¶](#åœºæ™¯è·¨å¹³å°uiç»„ä»¶)
- [ç¬¬äº”éƒ¨åˆ†ï¼šå»ºé€ è€…æ¨¡å¼](#ç¬¬äº”éƒ¨åˆ†å»ºé€ è€…æ¨¡å¼)
  - [å»ºé€ è€…æ¨¡å¼åŸç†](#å»ºé€ è€…æ¨¡å¼åŸç†)
    - [ä»€ä¹ˆæ˜¯å»ºé€ è€…æ¨¡å¼ï¼Ÿ](#ä»€ä¹ˆæ˜¯å»ºé€ è€…æ¨¡å¼)
  - [å®Œæ•´å»ºé€ è€…å®ç°](#å®Œæ•´å»ºé€ è€…å®ç°)
    - [åœºæ™¯ï¼šHTTPè¯·æ±‚æ„å»ºå™¨](#åœºæ™¯httpè¯·æ±‚æ„å»ºå™¨)
- [ç¬¬å…­éƒ¨åˆ†ï¼šåŸå‹æ¨¡å¼](#ç¬¬å…­éƒ¨åˆ†åŸå‹æ¨¡å¼)
  - [åŸå‹æ¨¡å¼åŸç†](#åŸå‹æ¨¡å¼åŸç†)
    - [ä»€ä¹ˆæ˜¯åŸå‹æ¨¡å¼ï¼Ÿ](#ä»€ä¹ˆæ˜¯åŸå‹æ¨¡å¼)
  - [å®Œæ•´åŸå‹æ¨¡å¼å®ç°](#å®Œæ•´åŸå‹æ¨¡å¼å®ç°)
- [ç¬¬ä¸ƒéƒ¨åˆ†ï¼šå®æˆ˜æ¡ˆä¾‹](#ç¬¬ä¸ƒéƒ¨åˆ†å®æˆ˜æ¡ˆä¾‹)
  - [æ¡ˆä¾‹5ï¼šå¾®æœåŠ¡å®¢æˆ·ç«¯å·¥å‚](#æ¡ˆä¾‹5å¾®æœåŠ¡å®¢æˆ·ç«¯å·¥å‚)
    - [åœºæ™¯5](#åœºæ™¯5)
    - [å®Œæ•´å®ç°5](#å®Œæ•´å®ç°5)
- [ç¬¬å…«éƒ¨åˆ†ï¼šæœ€ä½³å®è·µ](#ç¬¬å…«éƒ¨åˆ†æœ€ä½³å®è·µ)
  - [åˆ›å»ºå‹æ¨¡å¼é€‰æ‹©æŒ‡å—](#åˆ›å»ºå‹æ¨¡å¼é€‰æ‹©æŒ‡å—)
    - [å†³ç­–è¡¨](#å†³ç­–è¡¨)
  - [å¸¸è§é™·é˜±](#å¸¸è§é™·é˜±)
    - [é™·é˜±1ï¼šå•ä¾‹æ»¥ç”¨](#é™·é˜±1å•ä¾‹æ»¥ç”¨)
    - [é™·é˜±2ï¼šå·¥å‚è¿‡åº¦è®¾è®¡](#é™·é˜±2å·¥å‚è¿‡åº¦è®¾è®¡)
    - [é™·é˜±3ï¼šå»ºé€ è€…å‚æ•°è¿‡å°‘](#é™·é˜±3å»ºé€ è€…å‚æ•°è¿‡å°‘)
- [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
  - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
  - [æ€§èƒ½å¯¹æ¯”](#æ€§èƒ½å¯¹æ¯”)
- [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

## ç¬¬ä¸€éƒ¨åˆ†ï¼šç†è®ºåŸºç¡€

### åˆ›å»ºå‹æ¨¡å¼çš„ä»·å€¼

#### ä¸ºä»€ä¹ˆéœ€è¦åˆ›å»ºå‹æ¨¡å¼ï¼Ÿ

**é—®é¢˜ç¤ºä¾‹**ï¼š

```go
// âŒ ç›´æ¥åˆ›å»ºå¯¹è±¡çš„é—®é¢˜
func main() {
    // é—®é¢˜1ï¼šåˆ›å»ºé€»è¾‘æ•£è½å„å¤„
    db := &MySQLDatabase{Host: "localhost", Port: 3306}
    
    // é—®é¢˜2ï¼šç¡¬ç¼–ç ï¼Œéš¾ä»¥åˆ‡æ¢å®ç°
    cache := &RedisCache{Addr: "localhost:6379"}
    
    // é—®é¢˜3ï¼šå¤æ‚å¯¹è±¡åˆå§‹åŒ–ç¹ç
    server := &HTTPServer{}
    server.Host = "0.0.0.0"
    server.Port = 8080
    server.ReadTimeout = 30 * time.Second
    server.WriteTimeout = 30 * time.Second
    // ... æ›´å¤šé…ç½®
}
```

**ä½¿ç”¨åˆ›å»ºå‹æ¨¡å¼å**ï¼š

```go
// âœ… ä½¿ç”¨å·¥å‚æ¨¡å¼
db := database.NewDatabase("mysql", config)  // è§£è€¦å®ç°

// âœ… ä½¿ç”¨å•ä¾‹æ¨¡å¼
cache := cache.GetInstance()  // å…¨å±€å”¯ä¸€

// âœ… ä½¿ç”¨å»ºé€ è€…æ¨¡å¼
server := NewServerBuilder().
    WithHost("0.0.0.0").
    WithPort(8080).
    WithTimeout(30 * time.Second).
    Build()  // é“¾å¼æ„å»º
```

---

### åˆ›å»ºå‹æ¨¡å¼åˆ†ç±»

| æ¨¡å¼ | æ„å›¾ | é€‚ç”¨åœºæ™¯ | å¤æ‚åº¦ |
|------|------|---------|--------|
| **å•ä¾‹æ¨¡å¼** | ç¡®ä¿åªæœ‰ä¸€ä¸ªå®ä¾‹ | é…ç½®ç®¡ç†ã€è¿æ¥æ±  | â­â­ |
| **å·¥å‚æ–¹æ³•** | å»¶è¿Ÿå¯¹è±¡åˆ›å»ºå†³ç­– | å¤šå®ç°åˆ‡æ¢ | â­â­â­ |
| **æŠ½è±¡å·¥å‚** | åˆ›å»ºäº§å“æ— | è·¨å¹³å°UIã€æ•°æ®åº“ | â­â­â­â­ |
| **å»ºé€ è€…** | æ„å»ºå¤æ‚å¯¹è±¡ | é…ç½®å¯¹è±¡ã€è¯·æ±‚å¯¹è±¡ | â­â­â­ |
| **åŸå‹** | é€šè¿‡å¤åˆ¶åˆ›å»º | å¤§å¯¹è±¡å¤åˆ¶ | â­â­ |

---

### é€‰æ‹©åˆ›å»ºå‹æ¨¡å¼çš„å†³ç­–æ ‘

```text
ä½ çš„éœ€æ±‚æ˜¯ä»€ä¹ˆï¼Ÿ
â”‚
â”œâ”€ éœ€è¦å…¨å±€å”¯ä¸€å®ä¾‹ï¼Ÿ
â”‚  â””â”€ æ˜¯ â†’ å•ä¾‹æ¨¡å¼
â”‚      - é…ç½®ç®¡ç†å™¨
â”‚      - æ—¥å¿—ç®¡ç†å™¨
â”‚      - è¿æ¥æ± 
â”‚
â”œâ”€ éœ€è¦æ ¹æ®æ¡ä»¶åˆ›å»ºä¸åŒå¯¹è±¡ï¼Ÿ
â”‚  â””â”€ æ˜¯ â†’ å·¥å‚æ–¹æ³•æ¨¡å¼
â”‚      - ä¸åŒç±»å‹çš„æ•°æ®åº“
â”‚      - ä¸åŒæ ¼å¼çš„è§£æå™¨
â”‚
â”œâ”€ éœ€è¦åˆ›å»ºä¸€ç³»åˆ—ç›¸å…³å¯¹è±¡ï¼Ÿ
â”‚  â””â”€ æ˜¯ â†’ æŠ½è±¡å·¥å‚æ¨¡å¼
â”‚      - ä¸åŒUIä¸»é¢˜
â”‚      - ä¸åŒäº‘å¹³å°SDK
â”‚
â”œâ”€ å¯¹è±¡æ„å»ºè¿‡ç¨‹å¤æ‚ï¼Ÿ
â”‚  â””â”€ æ˜¯ â†’ å»ºé€ è€…æ¨¡å¼
â”‚      - HTTPè¯·æ±‚æ„å»º
â”‚      - SQLæŸ¥è¯¢æ„å»º
â”‚
â””â”€ å¯¹è±¡åˆ›å»ºæˆæœ¬é«˜ï¼Œéœ€è¦å¤åˆ¶ï¼Ÿ
   â””â”€ æ˜¯ â†’ åŸå‹æ¨¡å¼
       - å¤§æ•°æ®ç»“æ„å¤åˆ¶
       - æ·±æ‹·è´åœºæ™¯
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šå•ä¾‹æ¨¡å¼æ·±åº¦å®æˆ˜

### å•ä¾‹æ¨¡å¼æ ¸å¿ƒåŸç†

#### ä»€ä¹ˆæ˜¯å•ä¾‹æ¨¡å¼ï¼Ÿ

**å®šä¹‰**: ç¡®ä¿ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶æä¾›å…¨å±€è®¿é—®ç‚¹ã€‚

**å½¢å¼åŒ–**:
$$\forall x, y \in \text{Class} : \text{GetInstance}() \Rightarrow x = y$$

**æ ¸å¿ƒç‰¹ç‚¹**:

1. å…¨å±€å”¯ä¸€å®ä¾‹
2. å»¶è¿Ÿåˆå§‹åŒ–ï¼ˆæŒ‰éœ€åˆ›å»ºï¼‰
3. çº¿ç¨‹å®‰å…¨

---

### Goå•ä¾‹æ¨¡å¼çš„5ç§å®ç°

#### å®ç°1ï¼šsync.Onceï¼ˆæ¨èâ­â­â­â­â­ï¼‰

```go
package singleton

import "sync"

type Singleton struct {
    data string
}

var (
    instance *Singleton
    once     sync.Once
)

// GetInstance è·å–å•ä¾‹å®ä¾‹
func GetInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{
            data: "initialized",
        }
    })
    return instance
}
```

**ä¼˜ç‚¹**:

- âœ… çº¿ç¨‹å®‰å…¨
- âœ… å»¶è¿Ÿåˆå§‹åŒ–
- âœ… æ€§èƒ½æœ€ä¼˜ï¼ˆåªåŠ é”ä¸€æ¬¡ï¼‰

**ç¼ºç‚¹**:

- âš ï¸ æ— æ³•ä¼ é€’å‚æ•°
- âš ï¸ åˆå§‹åŒ–å¤±è´¥æ— æ³•é‡è¯•

---

#### å®ç°2ï¼šå¸¦å‚æ•°çš„å•ä¾‹

```go
package singleton

import (
    "errors"
    "sync"
)

type Database struct {
    host string
    port int
}

var (
    dbInstance *Database
    dbOnce     sync.Once
    dbErr      error
)

// InitDatabase åˆå§‹åŒ–å•ä¾‹ï¼ˆå¿…é¡»å…ˆè°ƒç”¨ï¼‰
func InitDatabase(host string, port int) error {
    dbOnce.Do(func() {
        if host == "" {
            dbErr = errors.New("host cannot be empty")
            return
        }
        dbInstance = &Database{
            host: host,
            port: port,
        }
    })
    return dbErr
}

// GetDatabase è·å–å•ä¾‹
func GetDatabase() (*Database, error) {
    if dbInstance == nil {
        return nil, errors.New("database not initialized")
    }
    return dbInstance, nil
}
```

**ä½¿ç”¨ç¤ºä¾‹**:

```go
func main() {
    // 1. å…ˆåˆå§‹åŒ–
    err := InitDatabase("localhost", 3306)
    if err != nil {
        log.Fatal(err)
    }
    
    // 2. è·å–å®ä¾‹
    db, _ := GetDatabase()
    fmt.Println(db.host)  // localhost
}
```

---

#### å®ç°3ï¼šåŒé‡æ£€æŸ¥é”å®šï¼ˆä¸æ¨èï¼‰

```go
package singleton

import "sync"

var (
    instance *Singleton
    mu       sync.Mutex
)

// GetInstance åŒé‡æ£€æŸ¥
func GetInstance() *Singleton {
    if instance == nil {  // ç¬¬ä¸€æ¬¡æ£€æŸ¥ï¼ˆæ— é”ï¼‰
        mu.Lock()
        defer mu.Unlock()
        if instance == nil {  // ç¬¬äºŒæ¬¡æ£€æŸ¥ï¼ˆåŠ é”ï¼‰
            instance = &Singleton{}
        }
    }
    return instance
}
```

**é—®é¢˜**:

- âš ï¸ ä»£ç å¤æ‚
- âš ï¸ Goä¸­æ²¡æœ‰å¿…è¦ï¼ˆsync.Onceæ›´å¥½ï¼‰

---

#### å®ç°4ï¼šinitå‡½æ•°ï¼ˆæå‰åˆå§‹åŒ–ï¼‰

```go
package singleton

var instance *Singleton

func init() {
    instance = &Singleton{
        data: "early init",
    }
}

func GetInstance() *Singleton {
    return instance
}
```

**ä¼˜ç‚¹**:

- âœ… ç®€å•
- âœ… çº¿ç¨‹å®‰å…¨

**ç¼ºç‚¹**:

- âŒ éå»¶è¿Ÿåˆå§‹åŒ–
- âŒ æ— æ³•ä¼ å‚
- âŒ æ— æ³•å¤„ç†åˆå§‹åŒ–é”™è¯¯

---

#### å®ç°5ï¼šæ³›å‹å•ä¾‹ï¼ˆGo 1.18+ï¼‰

```go
package singleton

import "sync"

// Singleton æ³›å‹å•ä¾‹å®¹å™¨
type Singleton[T any] struct {
    instance T
    once     sync.Once
    initFunc func() T
}

// NewSingleton åˆ›å»ºå•ä¾‹å®¹å™¨
func NewSingleton[T any](initFunc func() T) *Singleton[T] {
    return &Singleton[T]{
        initFunc: initFunc,
    }
}

// Get è·å–å®ä¾‹
func (s *Singleton[T]) Get() T {
    s.once.Do(func() {
        s.instance = s.initFunc()
    })
    return s.instance
}

// ä½¿ç”¨ç¤ºä¾‹
var configSingleton = NewSingleton(func() *Config {
    return &Config{
        AppName: "MyApp",
        Version: "1.0.0",
    }
})

func GetConfig() *Config {
    return configSingleton.Get()
}
```

---

### å•ä¾‹æ¨¡å¼æ€§èƒ½å¯¹æ¯”

#### Benchmarkæµ‹è¯•

```go
func BenchmarkSingleton(b *testing.B) {
    b.Run("sync.Once", func(b *testing.B) {
        b.RunParallel(func(pb *testing.PB) {
            for pb.Next() {
                GetInstanceOnce()
            }
        })
    })
    
    b.Run("DoubleLock", func(b *testing.B) {
        b.RunParallel(func(pb *testing.PB) {
            for pb.Next() {
                GetInstanceDoubleLock()
            }
        })
    })
    
    b.Run("Mutex", func(b *testing.B) {
        b.RunParallel(func(pb *testing.PB) {
            for pb.Next() {
                GetInstanceMutex()
            }
        })
    })
}

// ç»“æœï¼š
// BenchmarkSingleton/sync.Once-8      100000000   10.5 ns/op
// BenchmarkSingleton/DoubleLock-8      50000000   32.1 ns/op
// BenchmarkSingleton/Mutex-8           20000000   65.3 ns/op
```

**ç»“è®º**: `sync.Once`æ€§èƒ½æœ€ä¼˜ï¼Œæ¯”åŒé‡æ£€æŸ¥å¿«3å€ï¼Œæ¯”çº¯Mutexå¿«6å€ã€‚

---

### å®æˆ˜æ¡ˆä¾‹1ï¼šé…ç½®ç®¡ç†å™¨

#### åœºæ™¯

- åº”ç”¨é…ç½®å…¨å±€å”¯ä¸€
- æ”¯æŒä»æ–‡ä»¶/ç¯å¢ƒå˜é‡åŠ è½½
- çº¿ç¨‹å®‰å…¨

#### å®Œæ•´å®ç°

```go
package config

import (
    "encoding/json"
    "os"
    "sync"
)

// Config é…ç½®ç»“æ„
type Config struct {
    AppName     string
    Port        int
    DatabaseURL string
    LogLevel    string
}

var (
    instance *Config
    once     sync.Once
    initErr  error
)

// LoadConfig åŠ è½½é…ç½®ï¼ˆå•ä¾‹ï¼‰
func LoadConfig(filename string) (*Config, error) {
    once.Do(func() {
        data, err := os.ReadFile(filename)
        if err != nil {
            initErr = err
            return
        }
        
        var cfg Config
        if err := json.Unmarshal(data, &cfg); err != nil {
            initErr = err
            return
        }
        
        instance = &cfg
    })
    
    if initErr != nil {
        return nil, initErr
    }
    
    return instance, nil
}

// GetConfig è·å–é…ç½®
func GetConfig() *Config {
    return instance
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    // åŠ è½½é…ç½®
    cfg, err := LoadConfig("config.json")
    if err != nil {
        log.Fatal(err)
    }
    
    // å…¨å±€è®¿é—®
    fmt.Println(GetConfig().AppName)
    
    // å…¶ä»–åœ°æ–¹ä¹Ÿå¯ä»¥ç›´æ¥è·å–
    func() {
        fmt.Println(GetConfig().Port)
    }()
}
```

---

### å•ä¾‹æ¨¡å¼æœ€ä½³å®è·µ

#### âœ… DO

1. **ä½¿ç”¨sync.Once**:

    ```go
    // âœ… æ­£ç¡®
    var once sync.Once
    func GetInstance() *Singleton {
        once.Do(func() {
            instance = &Singleton{}
        })
        return instance
    }
    ```

2. **æä¾›ç‹¬ç«‹åˆå§‹åŒ–å‡½æ•°**:

    ```go
    // âœ… æ­£ç¡®ï¼šæ”¯æŒä¼ å‚
    func InitDB(config DBConfig) error { ... }
    func GetDB() *DB { ... }
    ```

3. **è¿”å›é”™è¯¯**:

    ```go
    // âœ… æ­£ç¡®ï¼šå¯ä»¥å¤„ç†åˆå§‹åŒ–å¤±è´¥
    func GetInstance() (*Singleton, error) {
        if instance == nil {
            return nil, errors.New("not initialized")
        }
        return instance, nil
    }
    ```

#### âŒ DON'T

1. **ä¸è¦æ»¥ç”¨å•ä¾‹**:

    ```go
    // âŒ é”™è¯¯ï¼šä¸æ˜¯æ‰€æœ‰ç±»éƒ½éœ€è¦å•ä¾‹
    var userServiceInstance *UserService  // ä¸éœ€è¦å…¨å±€å”¯ä¸€
    ```

2. **ä¸è¦åœ¨å•ä¾‹ä¸­å­˜å‚¨å¯å˜çŠ¶æ€**:

    ```go
    // âŒ é”™è¯¯ï¼šå•ä¾‹ä¸­çš„å¯å˜çŠ¶æ€éš¾ä»¥æµ‹è¯•
    type Singleton struct {
        counter int  // å¯å˜çŠ¶æ€
    }

    func (s *Singleton) Increment() {
        s.counter++  // çº¿ç¨‹ä¸å®‰å…¨
    }
    ```

3. **ä¸è¦ä½¿ç”¨å…¨å±€å˜é‡æ›¿ä»£å•ä¾‹**:

    ```go
    // âŒ é”™è¯¯ï¼šå…¨å±€å˜é‡æ— æ³•å»¶è¿Ÿåˆå§‹åŒ–
    var config = loadConfig()  // ç¨‹åºå¯åŠ¨å°±åŠ è½½

    // âœ… æ­£ç¡®ï¼šä½¿ç”¨å•ä¾‹æ¨¡å¼
    func GetConfig() *Config {
        once.Do(func() {
            config = loadConfig()  // æŒ‰éœ€åŠ è½½
        })
        return config
    }
    ```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šå·¥å‚æ¨¡å¼æ·±åº¦å®æˆ˜

### å·¥å‚æ–¹æ³•æ¨¡å¼åŸç†

#### ä»€ä¹ˆæ˜¯å·¥å‚æ–¹æ³•æ¨¡å¼ï¼Ÿ

**å®šä¹‰**: å®šä¹‰ä¸€ä¸ªç”¨äºåˆ›å»ºå¯¹è±¡çš„æ¥å£ï¼Œè®©å­ç±»å†³å®šå®ä¾‹åŒ–å“ªä¸€ä¸ªç±»ã€‚

**UMLå…³ç³»**:

```text
<<interface>>
  Creator
     â†‘
     â”‚ implements
     â”œâ”€ ConcreteCreatorA
     â””â”€ ConcreteCreatorB
        â”‚ creates
        â†“
  <<interface>>
    Product
       â†‘
       â”‚ implements
       â”œâ”€ ConcreteProductA
       â””â”€ ConcreteProductB
```

---

### å®Œæ•´å·¥å‚æ¨¡å¼å®ç°

#### åœºæ™¯ï¼šæ•°æ®åº“è¿æ¥å·¥å‚

```go
package database

import "errors"

// Database æ•°æ®åº“æ¥å£
type Database interface {
    Connect() error
    Query(sql string) ([]map[string]interface{}, error)
    Close() error
}

// ===== MySQLå®ç° =====
type MySQL struct {
    host string
    port int
}

func (m *MySQL) Connect() error {
    fmt.Printf("Connecting to MySQL at %s:%d\n", m.host, m.port)
    return nil
}

func (m *MySQL) Query(sql string) ([]map[string]interface{}, error) {
    fmt.Printf("MySQL Query: %s\n", sql)
    return nil, nil
}

func (m *MySQL) Close() error {
    fmt.Println("MySQL connection closed")
    return nil
}

// ===== PostgreSQLå®ç° =====
type PostgreSQL struct {
    host string
    port int
}

func (p *PostgreSQL) Connect() error {
    fmt.Printf("Connecting to PostgreSQL at %s:%d\n", p.host, p.port)
    return nil
}

func (p *PostgreSQL) Query(sql string) ([]map[string]interface{}, error) {
    fmt.Printf("PostgreSQL Query: %s\n", sql)
    return nil, nil
}

func (p *PostgreSQL) Close() error {
    fmt.Println("PostgreSQL connection closed")
    return nil
}

// ===== å·¥å‚å‡½æ•° =====
type DBConfig struct {
    Type string
    Host string
    Port int
}

// NewDatabase å·¥å‚æ–¹æ³•
func NewDatabase(config DBConfig) (Database, error) {
    switch config.Type {
    case "mysql":
        return &MySQL{
            host: config.Host,
            port: config.Port,
        }, nil
    case "postgres":
        return &PostgreSQL{
            host: config.Host,
            port: config.Port,
        }, nil
    default:
        return nil, errors.New("unsupported database type")
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    // åˆ›å»ºMySQL
    mysqlDB, _ := NewDatabase(DBConfig{
        Type: "mysql",
        Host: "localhost",
        Port: 3306,
    })
    mysqlDB.Connect()
    mysqlDB.Query("SELECT * FROM users")
    
    // åˆ›å»ºPostgreSQLï¼ˆæ— éœ€ä¿®æ”¹ä¸šåŠ¡ä»£ç ï¼‰
    pgDB, _ := NewDatabase(DBConfig{
        Type: "postgres",
        Host: "localhost",
        Port: 5432,
    })
    pgDB.Connect()
}
```

**ä¼˜åŠ¿**:

- âœ… å®¢æˆ·ç«¯ä»£ç æ— éœ€çŸ¥é“å…·ä½“å®ç°
- âœ… æ–°å¢æ•°æ®åº“ç±»å‹åªéœ€æ·»åŠ case
- âœ… ç¬¦åˆå¼€é—­åŸåˆ™ï¼ˆå¯¹æ‰©å±•å¼€æ”¾ï¼‰

---

### è¿›é˜¶ï¼šæ³¨å†Œè¡¨æ¨¡å¼

#### é—®é¢˜

- æ¯æ¬¡æ–°å¢ç±»å‹éƒ½è¦ä¿®æ”¹å·¥å‚å‡½æ•°
- è¿åå¼€é—­åŸåˆ™

#### è§£å†³ï¼šä½¿ç”¨æ³¨å†Œè¡¨

```go
package database

import (
    "errors"
    "sync"
)

// Constructor æ•°æ®åº“æ„é€ å‡½æ•°ç±»å‹
type Constructor func(config DBConfig) (Database, error)

// registry å…¨å±€æ³¨å†Œè¡¨
var (
    registry = make(map[string]Constructor)
    mu       sync.RWMutex
)

// Register æ³¨å†Œæ•°æ®åº“ç±»å‹
func Register(name string, constructor Constructor) {
    mu.Lock()
    defer mu.Unlock()
    registry[name] = constructor
}

// NewDatabase å·¥å‚æ–¹æ³•ï¼ˆè‡ªåŠ¨æŸ¥æ‰¾æ³¨å†Œè¡¨ï¼‰
func NewDatabase(config DBConfig) (Database, error) {
    mu.RLock()
    constructor, ok := registry[config.Type]
    mu.RUnlock()
    
    if !ok {
        return nil, errors.New("unknown database type: " + config.Type)
    }
    
    return constructor(config)
}

// ===== å„æ•°æ®åº“å®ç°è‡ªè¡Œæ³¨å†Œ =====

// mysql.go
func init() {
    Register("mysql", func(config DBConfig) (Database, error) {
        return &MySQL{
            host: config.Host,
            port: config.Port,
        }, nil
    })
}

// postgres.go
func init() {
    Register("postgres", func(config DBConfig) (Database, error) {
        return &PostgreSQL{
            host: config.Host,
            port: config.Port,
        }, nil
    })
}

// ===== æ–°å¢æ•°æ®åº“ç±»å‹æ— éœ€ä¿®æ”¹å·¥å‚ =====

// sqlite.go
type SQLite struct {
    path string
}

func (s *SQLite) Connect() error { ... }
func (s *SQLite) Query(sql string) ([]map[string]interface{}, error) { ... }
func (s *SQLite) Close() error { ... }

func init() {
    // è‡ªåŠ¨æ³¨å†Œï¼Œå·¥å‚æ— éœ€ä¿®æ”¹
    Register("sqlite", func(config DBConfig) (Database, error) {
        return &SQLite{
            path: config.Host,  // å¤ç”¨Hostå­—æ®µå­˜å‚¨è·¯å¾„
        }, nil
    })
}
```

**ä¼˜åŠ¿**:

- âœ… å®Œå…¨ç¬¦åˆå¼€é—­åŸåˆ™
- âœ… æ–°å¢ç±»å‹æ— éœ€ä¿®æ”¹å·¥å‚ä»£ç 
- âœ… æ”¯æŒæ’ä»¶åŒ–æ¶æ„

---

### å®æˆ˜æ¡ˆä¾‹2ï¼šæ—¥å¿—å·¥å‚

#### åœºæ™¯2

- æ”¯æŒå¤šç§æ—¥å¿—è¾“å‡ºï¼ˆConsoleã€Fileã€Syslogï¼‰
- æ ¹æ®é…ç½®åŠ¨æ€åˆ‡æ¢
- æ”¯æŒæ—¥å¿—çº§åˆ«

#### å®Œæ•´å®ç°2

```go
package logger

import (
    "fmt"
    "os"
    "time"
)

// Logger æ—¥å¿—æ¥å£
type Logger interface {
    Debug(msg string)
    Info(msg string)
    Warn(msg string)
    Error(msg string)
}

// ===== Console Logger =====
type ConsoleLogger struct {
    level string
}

func (l *ConsoleLogger) Debug(msg string) {
    fmt.Printf("[DEBUG] %s: %s\n", time.Now().Format("15:04:05"), msg)
}

func (l *ConsoleLogger) Info(msg string) {
    fmt.Printf("[INFO ] %s: %s\n", time.Now().Format("15:04:05"), msg)
}

func (l *ConsoleLogger) Warn(msg string) {
    fmt.Printf("[WARN ] %s: %s\n", time.Now().Format("15:04:05"), msg)
}

func (l *ConsoleLogger) Error(msg string) {
    fmt.Printf("[ERROR] %s: %s\n", time.Now().Format("15:04:05"), msg)
}

// ===== File Logger =====
type FileLogger struct {
    file *os.File
}

func (l *FileLogger) Debug(msg string) {
    l.log("DEBUG", msg)
}

func (l *FileLogger) Info(msg string) {
    l.log("INFO", msg)
}

func (l *FileLogger) Warn(msg string) {
    l.log("WARN", msg)
}

func (l *FileLogger) Error(msg string) {
    l.log("ERROR", msg)
}

func (l *FileLogger) log(level, msg string) {
    timestamp := time.Now().Format("2006-01-02 15:04:05")
    l.file.WriteString(fmt.Sprintf("[%s] %s: %s\n", level, timestamp, msg))
}

// ===== å·¥å‚ =====
type LoggerConfig struct {
    Type     string
    FilePath string
}

func NewLogger(config LoggerConfig) (Logger, error) {
    switch config.Type {
    case "console":
        return &ConsoleLogger{}, nil
        
    case "file":
        file, err := os.OpenFile(config.FilePath, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
        if err != nil {
            return nil, err
        }
        return &FileLogger{file: file}, nil
        
    default:
        return nil, fmt.Errorf("unknown logger type: %s", config.Type)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    // å¼€å‘ç¯å¢ƒï¼šæ§åˆ¶å°æ—¥å¿—
    logger, _ := NewLogger(LoggerConfig{Type: "console"})
    logger.Info("Application started")
    
    // ç”Ÿäº§ç¯å¢ƒï¼šæ–‡ä»¶æ—¥å¿—ï¼ˆåªéœ€ä¿®æ”¹é…ç½®ï¼‰
    logger, _ = NewLogger(LoggerConfig{
        Type:     "file",
        FilePath: "/var/log/app.log",
    })
    logger.Info("Application started")
}
```

---

## ç¬¬å››éƒ¨åˆ†ï¼šæŠ½è±¡å·¥å‚æ¨¡å¼

### æŠ½è±¡å·¥å‚æ¨¡å¼åŸç†

#### ä»€ä¹ˆæ˜¯æŠ½è±¡å·¥å‚ï¼Ÿ

**å®šä¹‰**: æä¾›ä¸€ä¸ªåˆ›å»ºä¸€ç³»åˆ—ç›¸å…³æˆ–ç›¸äº’ä¾èµ–å¯¹è±¡çš„æ¥å£ï¼Œè€Œæ— éœ€æŒ‡å®šå®ƒä»¬å…·ä½“çš„ç±»ã€‚

**vs å·¥å‚æ–¹æ³•**:

- å·¥å‚æ–¹æ³•ï¼šåˆ›å»ºä¸€ä¸ªäº§å“
- æŠ½è±¡å·¥å‚ï¼šåˆ›å»ºä¸€æ—äº§å“ï¼ˆå¤šä¸ªç›¸å…³äº§å“ï¼‰

**ç¤ºä¾‹åœºæ™¯**:

- UIä¸»é¢˜ï¼ˆæŒ‰é’®+æ–‡æœ¬æ¡†+èœå• â†’ ä¸€å¥—é£æ ¼ï¼‰
- è·¨å¹³å°ï¼ˆWindows/Linux/Mac â†’ ä¸€å¥—APIï¼‰

---

### å®Œæ•´æŠ½è±¡å·¥å‚å®ç°

#### åœºæ™¯ï¼šè·¨å¹³å°UIç»„ä»¶

```go
package ui

// ===== äº§å“æ¥å£ =====
type Button interface {
    Render() string
}

type TextBox interface {
    Render() string
}

// ===== Windowsäº§å“æ— =====
type WindowsButton struct{}

func (b *WindowsButton) Render() string {
    return "[Windows Button]"
}

type WindowsTextBox struct{}

func (t *WindowsTextBox) Render() string {
    return "[Windows TextBox]"
}

// ===== Macäº§å“æ— =====
type MacButton struct{}

func (b *MacButton) Render() string {
    return "[Mac Button]"
}

type MacTextBox struct{}

func (t *MacTextBox) Render() string {
    return "[Mac TextBox]"
}

// ===== æŠ½è±¡å·¥å‚æ¥å£ =====
type UIFactory interface {
    CreateButton() Button
    CreateTextBox() TextBox
}

// ===== Windowså·¥å‚ =====
type WindowsUIFactory struct{}

func (f *WindowsUIFactory) CreateButton() Button {
    return &WindowsButton{}
}

func (f *WindowsUIFactory) CreateTextBox() TextBox {
    return &WindowsTextBox{}
}

// ===== Macå·¥å‚ =====
type MacUIFactory struct{}

func (f *MacUIFactory) CreateButton() Button {
    return &MacButton{}
}

func (f *MacUIFactory) CreateTextBox() TextBox {
    return &MacTextBox{}
}

// ===== å·¥å‚é€‰æ‹©å™¨ =====
func GetUIFactory(platform string) UIFactory {
    switch platform {
    case "windows":
        return &WindowsUIFactory{}
    case "mac":
        return &MacUIFactory{}
    default:
        return &WindowsUIFactory{}
    }
}

// ===== ä½¿ç”¨ç¤ºä¾‹ =====
func RenderUI(platform string) {
    // 1. è·å–å·¥å‚
    factory := GetUIFactory(platform)
    
    // 2. åˆ›å»ºäº§å“æ—ï¼ˆä¿è¯é£æ ¼ç»Ÿä¸€ï¼‰
    button := factory.CreateButton()
    textbox := factory.CreateTextBox()
    
    // 3. ä½¿ç”¨äº§å“
    fmt.Println(button.Render())
    fmt.Println(textbox.Render())
}

func main() {
    RenderUI("windows")  // [Windows Button] [Windows TextBox]
    RenderUI("mac")      // [Mac Button] [Mac TextBox]
}
```

**ä¼˜åŠ¿**:

- âœ… ä¿è¯äº§å“æ—çš„ä¸€è‡´æ€§
- âœ… æ–°å¢å¹³å°åªéœ€æ·»åŠ æ–°å·¥å‚
- âœ… å®¢æˆ·ç«¯ä»£ç æ— éœ€ä¿®æ”¹

---

## ç¬¬äº”éƒ¨åˆ†ï¼šå»ºé€ è€…æ¨¡å¼

### å»ºé€ è€…æ¨¡å¼åŸç†

#### ä»€ä¹ˆæ˜¯å»ºé€ è€…æ¨¡å¼ï¼Ÿ

**å®šä¹‰**: å°†ä¸€ä¸ªå¤æ‚å¯¹è±¡çš„æ„å»ºä¸å…¶è¡¨ç¤ºåˆ†ç¦»ï¼Œä½¿å¾—åŒæ ·çš„æ„å»ºè¿‡ç¨‹å¯ä»¥åˆ›å»ºä¸åŒçš„è¡¨ç¤ºã€‚

**é€‚ç”¨åœºæ™¯**:

- å¯¹è±¡æœ‰å¾ˆå¤šå¯é€‰å‚æ•°
- å‚æ•°ä¹‹é—´æœ‰ä¾èµ–å…³ç³»
- éœ€è¦é“¾å¼è°ƒç”¨

---

### å®Œæ•´å»ºé€ è€…å®ç°

#### åœºæ™¯ï¼šHTTPè¯·æ±‚æ„å»ºå™¨

```go
package httpclient

import (
    "bytes"
    "encoding/json"
    "io"
    "net/http"
    "time"
)

// Request HTTPè¯·æ±‚
type Request struct {
    method  string
    url     string
    headers map[string]string
    body    io.Reader
    timeout time.Duration
}

// RequestBuilder è¯·æ±‚æ„å»ºå™¨
type RequestBuilder struct {
    request *Request
}

// NewRequestBuilder åˆ›å»ºæ„å»ºå™¨
func NewRequestBuilder() *RequestBuilder {
    return &RequestBuilder{
        request: &Request{
            method:  "GET",
            headers: make(map[string]string),
            timeout: 30 * time.Second,
        },
    }
}

// Method è®¾ç½®æ–¹æ³•
func (b *RequestBuilder) Method(method string) *RequestBuilder {
    b.request.method = method
    return b
}

// URL è®¾ç½®URL
func (b *RequestBuilder) URL(url string) *RequestBuilder {
    b.request.url = url
    return b
}

// Header è®¾ç½®è¯·æ±‚å¤´
func (b *RequestBuilder) Header(key, value string) *RequestBuilder {
    b.request.headers[key] = value
    return b
}

// JSONBody è®¾ç½®JSON body
func (b *RequestBuilder) JSONBody(data interface{}) *RequestBuilder {
    jsonData, _ := json.Marshal(data)
    b.request.body = bytes.NewBuffer(jsonData)
    b.Header("Content-Type", "application/json")
    return b
}

// Timeout è®¾ç½®è¶…æ—¶
func (b *RequestBuilder) Timeout(timeout time.Duration) *RequestBuilder {
    b.request.timeout = timeout
    return b
}

// Build æ„å»ºè¯·æ±‚
func (b *RequestBuilder) Build() (*http.Request, error) {
    req, err := http.NewRequest(b.request.method, b.request.url, b.request.body)
    if err != nil {
        return nil, err
    }
    
    for key, value := range b.request.headers {
        req.Header.Set(key, value)
    }
    
    return req, nil
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    // é“¾å¼æ„å»º
    req, err := NewRequestBuilder().
        Method("POST").
        URL("https://api.example.com/users").
        Header("Authorization", "Bearer token123").
        JSONBody(map[string]string{
            "name": "John",
            "email": "john@example.com",
        }).
        Timeout(10 * time.Second).
        Build()
    
    if err != nil {
        log.Fatal(err)
    }
    
    // å‘é€è¯·æ±‚
    client := &http.Client{}
    resp, _ := client.Do(req)
    defer resp.Body.Close()
}
```

---

## ç¬¬å…­éƒ¨åˆ†ï¼šåŸå‹æ¨¡å¼

### åŸå‹æ¨¡å¼åŸç†

#### ä»€ä¹ˆæ˜¯åŸå‹æ¨¡å¼ï¼Ÿ

**å®šä¹‰**: ç”¨åŸå‹å®ä¾‹æŒ‡å®šåˆ›å»ºå¯¹è±¡çš„ç§ç±»ï¼Œå¹¶ä¸”é€šè¿‡æ‹·è´è¿™äº›åŸå‹åˆ›å»ºæ–°çš„å¯¹è±¡ã€‚

**é€‚ç”¨åœºæ™¯**:

- å¯¹è±¡åˆ›å»ºæˆæœ¬é«˜ï¼ˆæ•°æ®åº“æŸ¥è¯¢ã€ç½‘ç»œè¯·æ±‚ï¼‰
- éœ€è¦å¤§é‡ç›¸ä¼¼å¯¹è±¡
- æ·±æ‹·è´åœºæ™¯

---

### å®Œæ•´åŸå‹æ¨¡å¼å®ç°

```go
package prototype

import (
    "encoding/json"
    "time"
)

// Document æ–‡æ¡£ï¼ˆå¤§å¯¹è±¡ï¼‰
type Document struct {
    ID         string
    Title      string
    Content    string
    Metadata   map[string]interface{}
    CreateTime time.Time
}

// Clone æ·±æ‹·è´
func (d *Document) Clone() *Document {
    // æ–¹æ³•1ï¼šJSONåºåˆ—åŒ–/ååºåˆ—åŒ–ï¼ˆç®€å•ä½†æ…¢ï¼‰
    data, _ := json.Marshal(d)
    var clone Document
    json.Unmarshal(data, &clone)
    return &clone
}

// CloneFast å¿«é€Ÿå…‹éš†
func (d *Document) CloneFast() *Document {
    // æ–¹æ³•2ï¼šæ‰‹åŠ¨æ‹·è´ï¼ˆå¿«ä½†ç¹çï¼‰
    clone := &Document{
        ID:         d.ID,
        Title:      d.Title,
        Content:    d.Content,
        CreateTime: d.CreateTime,
        Metadata:   make(map[string]interface{}),
    }
    
    // æ·±æ‹·è´map
    for k, v := range d.Metadata {
        clone.Metadata[k] = v
    }
    
    return clone
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    // åŸå‹å¯¹è±¡ï¼ˆä»æ•°æ®åº“åŠ è½½ï¼Œè€—æ—¶1ç§’ï¼‰
    prototype := loadDocumentFromDB("doc123")  // æ¨¡æ‹Ÿæ…¢æ“ä½œ
    
    // å¿«é€Ÿå…‹éš†10ä¸ªå‰¯æœ¬
    docs := make([]*Document, 10)
    start := time.Now()
    for i := 0; i < 10; i++ {
        docs[i] = prototype.CloneFast()
        docs[i].ID = fmt.Sprintf("doc_%d", i)
    }
    fmt.Printf("Clone 10 documents: %v\n", time.Since(start))
    
    // å¯¹æ¯”ï¼šç›´æ¥åˆ›å»º10ä¸ªï¼ˆæ¯ä¸ªéƒ½è¦åŠ è½½æ•°æ®åº“ï¼‰
    start = time.Now()
    for i := 0; i < 10; i++ {
        loadDocumentFromDB("doc123")  // 10ç§’
    }
    fmt.Printf("Load 10 documents: %v\n", time.Since(start))
}

// æ¨¡æ‹Ÿä»æ•°æ®åº“åŠ è½½
func loadDocumentFromDB(id string) *Document {
    time.Sleep(1 * time.Second)  // æ¨¡æ‹Ÿæ…¢æŸ¥è¯¢
    return &Document{
        ID:         id,
        Title:      "Sample Document",
        Content:    "Long content...",
        CreateTime: time.Now(),
        Metadata:   map[string]interface{}{"version": 1},
    }
}

// è¾“å‡ºï¼š
// Clone 10 documents: 50Âµs
// Load 10 documents: 10s
// æ€§èƒ½æå‡ï¼š200,000å€
```

---

## ç¬¬ä¸ƒéƒ¨åˆ†ï¼šå®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹5ï¼šå¾®æœåŠ¡å®¢æˆ·ç«¯å·¥å‚

#### åœºæ™¯5

- å¾®æœåŠ¡æ¶æ„ï¼šç”¨æˆ·æœåŠ¡ã€è®¢å•æœåŠ¡ã€æ”¯ä»˜æœåŠ¡
- éœ€è¦ç»Ÿä¸€çš„å®¢æˆ·ç«¯åˆ›å»º
- æ”¯æŒè´Ÿè½½å‡è¡¡ã€ç†”æ–­ã€é‡è¯•

#### å®Œæ•´å®ç°5

```go
package serviceclient

import (
    "context"
    "errors"
    "fmt"
    "time"
)

// ServiceClient æœåŠ¡å®¢æˆ·ç«¯æ¥å£
type ServiceClient interface {
    Call(ctx context.Context, method string, req interface{}) (interface{}, error)
    Close() error
}

// ===== gRPCå®¢æˆ·ç«¯ =====
type GRPCClient struct {
    serviceName string
    conn        interface{}  // *grpc.ClientConn
}

func (c *GRPCClient) Call(ctx context.Context, method string, req interface{}) (interface{}, error) {
    fmt.Printf("[gRPC] Calling %s.%s\n", c.serviceName, method)
    // å®é™…gRPCè°ƒç”¨
    return nil, nil
}

func (c *GRPCClient) Close() error {
    fmt.Printf("[gRPC] Closing %s\n", c.serviceName)
    return nil
}

// ===== HTTPå®¢æˆ·ç«¯ =====
type HTTPClient struct {
    baseURL string
}

func (c *HTTPClient) Call(ctx context.Context, method string, req interface{}) (interface{}, error) {
    fmt.Printf("[HTTP] POST %s/%s\n", c.baseURL, method)
    // å®é™…HTTPè°ƒç”¨
    return nil, nil
}

func (c *HTTPClient) Close() error {
    return nil
}

// ===== å·¥å‚é…ç½® =====
type ClientConfig struct {
    Protocol    string  // "grpc" | "http"
    ServiceName string
    Address     string
    Timeout     time.Duration
}

// ===== å®¢æˆ·ç«¯å·¥å‚ =====
func NewServiceClient(config ClientConfig) (ServiceClient, error) {
    switch config.Protocol {
    case "grpc":
        // åˆ›å»ºgRPCè¿æ¥ï¼ˆç®€åŒ–ï¼‰
        return &GRPCClient{
            serviceName: config.ServiceName,
        }, nil
        
    case "http":
        return &HTTPClient{
            baseURL: config.Address,
        }, nil
        
    default:
        return nil, errors.New("unsupported protocol: " + config.Protocol)
    }
}

// ===== ä½¿ç”¨ç¤ºä¾‹ =====
func main() {
    // ç”¨æˆ·æœåŠ¡å®¢æˆ·ç«¯ï¼ˆgRPCï¼‰
    userClient, _ := NewServiceClient(ClientConfig{
        Protocol:    "grpc",
        ServiceName: "UserService",
        Address:     "localhost:50051",
        Timeout:     5 * time.Second,
    })
    defer userClient.Close()
    
    // è®¢å•æœåŠ¡å®¢æˆ·ç«¯ï¼ˆHTTPï¼‰
    orderClient, _ := NewServiceClient(ClientConfig{
        Protocol:    "http",
        ServiceName: "OrderService",
        Address:     "http://localhost:8080",
        Timeout:     10 * time.Second,
    })
    defer orderClient.Close()
    
    // ç»Ÿä¸€è°ƒç”¨æ¥å£
    ctx := context.Background()
    userClient.Call(ctx, "GetUser", map[string]interface{}{"id": 123})
    orderClient.Call(ctx, "CreateOrder", map[string]interface{}{"user_id": 123})
}
```

---

## ç¬¬å…«éƒ¨åˆ†ï¼šæœ€ä½³å®è·µ

### åˆ›å»ºå‹æ¨¡å¼é€‰æ‹©æŒ‡å—

#### å†³ç­–è¡¨

| åœºæ™¯ | æ¨èæ¨¡å¼ | åŸå›  |
|------|---------|------|
| å…¨å±€é…ç½® | å•ä¾‹æ¨¡å¼ | å”¯ä¸€å®ä¾‹ |
| å¤šç§æ•°æ®åº“ | å·¥å‚æ–¹æ³• | å¤šå®ç°åˆ‡æ¢ |
| UIä¸»é¢˜ | æŠ½è±¡å·¥å‚ | äº§å“æ—ä¸€è‡´æ€§ |
| HTTPè¯·æ±‚æ„å»º | å»ºé€ è€… | å‚æ•°å¤šä¸”å¯é€‰ |
| ç¼“å­˜å¯¹è±¡ | åŸå‹ | å¤åˆ¶æ¯”åˆ›å»ºå¿« |

---

### å¸¸è§é™·é˜±

#### é™·é˜±1ï¼šå•ä¾‹æ»¥ç”¨

```go
// âŒ é”™è¯¯ï¼šä¸éœ€è¦å•ä¾‹
type UserService struct {}

var userServiceInstance *UserService  // ä¸ºä»€ä¹ˆè¦å•ä¾‹ï¼Ÿ

// âœ… æ­£ç¡®ï¼šæ™®é€šç»“æ„ä½“å³å¯
type UserService struct {
    db *sql.DB
}

func NewUserService(db *sql.DB) *UserService {
    return &UserService{db: db}
}
```

#### é™·é˜±2ï¼šå·¥å‚è¿‡åº¦è®¾è®¡

```go
// âŒ é”™è¯¯ï¼šåªæœ‰ä¸€ç§å®ç°è¿˜ç”¨å·¥å‚
func NewLogger() Logger {
    return &ConsoleLogger{}  // åªæœ‰Consoleä¸€ç§å®ç°
}

// âœ… æ­£ç¡®ï¼šç›´æ¥åˆ›å»º
logger := &ConsoleLogger{}
```

#### é™·é˜±3ï¼šå»ºé€ è€…å‚æ•°è¿‡å°‘

```go
// âŒ é”™è¯¯ï¼šåªæœ‰2ä¸ªå‚æ•°ç”¨å»ºé€ è€…
type User struct {
    Name string
    Age  int
}

builder := NewUserBuilder().  // è¿‡åº¦è®¾è®¡
    WithName("John").
    WithAge(30).
    Build()

// âœ… æ­£ç¡®ï¼šç›´æ¥æ„é€ 
user := User{Name: "John", Age: 30}
```

---

## ğŸ¯ æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **å•ä¾‹æ¨¡å¼**: ä½¿ç”¨`sync.Once`ï¼Œé¿å…æ»¥ç”¨
2. **å·¥å‚æ¨¡å¼**: ä½¿ç”¨æ³¨å†Œè¡¨ï¼Œç¬¦åˆå¼€é—­åŸåˆ™
3. **æŠ½è±¡å·¥å‚**: ä¿è¯äº§å“æ—ä¸€è‡´æ€§
4. **å»ºé€ è€…**: é€‚åˆå‚æ•°å¤šä¸”å¯é€‰çš„å¯¹è±¡
5. **åŸå‹**: å¤åˆ¶æ¯”åˆ›å»ºå¿«æ—¶ä½¿ç”¨

### æ€§èƒ½å¯¹æ¯”

```text
å•ä¾‹ sync.Once: 10ns/opï¼ˆæœ€å¿«ï¼‰
å·¥å‚æ¨¡å¼: 50-100ns/opï¼ˆæŸ¥è¡¨å¼€é”€ï¼‰
å»ºé€ è€…: 200ns/opï¼ˆé“¾å¼è°ƒç”¨ï¼‰
åŸå‹å…‹éš†: 5Âµs/opï¼ˆæ¯”åˆ›å»ºå¿«100å€ï¼‰
```

---

## ğŸ“š å‚è€ƒèµ„æº

**ä¹¦ç±**:

- ã€ŠDesign Patterns: Elements of Reusable Object-Oriented Softwareã€‹
- ã€ŠHead First Design Patternsã€‹

**åœ¨çº¿èµ„æº**:

- [Refactoring Guru](https://refactoring.guru/design-patterns)
- [Go Patterns](https://github.com/tmrts/go-patterns)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v3.0  

<div align="center">

Made with â¤ï¸ for Go Developers

[â¬† å›åˆ°é¡¶éƒ¨](#goåˆ›å»ºå‹è®¾è®¡æ¨¡å¼æ·±åº¦å®æˆ˜æŒ‡å—)

</div>

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ20æ—¥  
**æ–‡æ¡£çŠ¶æ€**: å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
