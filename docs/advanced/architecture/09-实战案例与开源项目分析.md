# Goè®¾è®¡æ¨¡å¼å®æˆ˜æ¡ˆä¾‹ä¸å¼€æºé¡¹ç›®åˆ†æ

> **ç®€ä»‹**: Goè®¾è®¡æ¨¡å¼åœ¨å…¸å‹ä¸šåŠ¡åœºæ™¯ä¸­çš„å®æˆ˜æ¡ˆä¾‹ï¼Œä»¥åŠetcdã€gRPC-Goã€Go kitç­‰å¼€æºé¡¹ç›®çš„è®¾è®¡æ¨¡å¼åˆ†æ
> **ç‰ˆæœ¬**: Go 1.23+  
> **éš¾åº¦**: â­â­â­â­â­  
> **æ ‡ç­¾**: #è®¾è®¡æ¨¡å¼ #å®æˆ˜æ¡ˆä¾‹ #å¼€æºé¡¹ç›® #æ¶æ„åˆ†æ

<!-- TOC START -->
- [Goè®¾è®¡æ¨¡å¼å®æˆ˜æ¡ˆä¾‹ä¸å¼€æºé¡¹ç›®åˆ†æ](#goè®¾è®¡æ¨¡å¼å®æˆ˜æ¡ˆä¾‹ä¸å¼€æºé¡¹ç›®åˆ†æ)
  - [1. å…¸å‹ä¸šåŠ¡åœºæ™¯å®æˆ˜æ¡ˆä¾‹](#1-å…¸å‹ä¸šåŠ¡åœºæ™¯å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1ï¼šWebæ¡†æ¶ä¸­çš„å·¥å‚ä¸å•ä¾‹](#æ¡ˆä¾‹1webæ¡†æ¶ä¸­çš„å·¥å‚ä¸å•ä¾‹)
    - [æ¡ˆä¾‹2ï¼šè´£ä»»é“¾ä¸ç­–ç•¥åœ¨è¯·æ±‚å¤„ç†ä¸­çš„åº”ç”¨](#æ¡ˆä¾‹2è´£ä»»é“¾ä¸ç­–ç•¥åœ¨è¯·æ±‚å¤„ç†ä¸­çš„åº”ç”¨)
    - [æ¡ˆä¾‹3ï¼šäº‹ä»¶é©±åŠ¨ä¸è§‚å¯Ÿè€…åœ¨å¾®æœåŠ¡ä¸­çš„åº”ç”¨](#æ¡ˆä¾‹3äº‹ä»¶é©±åŠ¨ä¸è§‚å¯Ÿè€…åœ¨å¾®æœåŠ¡ä¸­çš„åº”ç”¨)
  - [2. ä¸»æµå¼€æºé¡¹ç›®è®¾è®¡æ¨¡å¼åˆ†æ](#2-ä¸»æµå¼€æºé¡¹ç›®è®¾è®¡æ¨¡å¼åˆ†æ)
    - [1. etcd](#1-etcd)
    - [2. gRPC-Go](#2-grpc-go)
    - [3. Go kit](#3-go-kit)
  - [3. å·¥ç¨‹æ€»ç»“](#3-å·¥ç¨‹æ€»ç»“)
  - [4. å‚è€ƒæ–‡çŒ®](#4-å‚è€ƒæ–‡çŒ®)
<!-- TOC END -->


## ğŸ“‹ ç›®å½•


- [1. å…¸å‹ä¸šåŠ¡åœºæ™¯å®æˆ˜æ¡ˆä¾‹](#1-å…¸å‹ä¸šåŠ¡åœºæ™¯å®æˆ˜æ¡ˆä¾‹)
  - [æ¡ˆä¾‹1ï¼šWebæ¡†æ¶ä¸­çš„å·¥å‚ä¸å•ä¾‹](#æ¡ˆä¾‹1webæ¡†æ¶ä¸­çš„å·¥å‚ä¸å•ä¾‹)
  - [æ¡ˆä¾‹2ï¼šè´£ä»»é“¾ä¸ç­–ç•¥åœ¨è¯·æ±‚å¤„ç†ä¸­çš„åº”ç”¨](#æ¡ˆä¾‹2è´£ä»»é“¾ä¸ç­–ç•¥åœ¨è¯·æ±‚å¤„ç†ä¸­çš„åº”ç”¨)
  - [æ¡ˆä¾‹3ï¼šäº‹ä»¶é©±åŠ¨ä¸è§‚å¯Ÿè€…åœ¨å¾®æœåŠ¡ä¸­çš„åº”ç”¨](#æ¡ˆä¾‹3äº‹ä»¶é©±åŠ¨ä¸è§‚å¯Ÿè€…åœ¨å¾®æœåŠ¡ä¸­çš„åº”ç”¨)
- [2. ä¸»æµå¼€æºé¡¹ç›®è®¾è®¡æ¨¡å¼åˆ†æ](#2-ä¸»æµå¼€æºé¡¹ç›®è®¾è®¡æ¨¡å¼åˆ†æ)
  - [1. [etcd](https://github.com/etcd-io/etcd) - åˆ†å¸ƒå¼é”®å€¼å­˜å‚¨](#1-etcdhttpsgithubcometcd-ioetcd---åˆ†å¸ƒå¼é”®å€¼å­˜å‚¨)
  - [2. [gRPC-Go](https://github.com/grpc/grpc-go) - RPCæ¡†æ¶](#2-grpc-gohttpsgithubcomgrpcgrpc-go---rpcæ¡†æ¶)
  - [3. [Go kit](https://github.com/go-kit/kit) - å¾®æœåŠ¡å·¥å…·åŒ…](#3-go-kithttpsgithubcomgo-kitkit---å¾®æœåŠ¡å·¥å…·åŒ…)
- [3. å·¥ç¨‹æ€»ç»“](#3-å·¥ç¨‹æ€»ç»“)
- [4. å‚è€ƒæ–‡çŒ®](#4-å‚è€ƒæ–‡çŒ®)

## 1. å…¸å‹ä¸šåŠ¡åœºæ™¯å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1ï¼šWebæ¡†æ¶ä¸­çš„å·¥å‚ä¸å•ä¾‹

**åœºæ™¯èƒŒæ™¯**ï¼š
Ginã€Echoç­‰Webæ¡†æ¶éœ€è¦å…¨å±€å¼•æ“å®ä¾‹ã€è·¯ç”±æ³¨å†Œã€ä¸­é—´ä»¶ç®¡ç†ï¼Œæ¶‰åŠå•ä¾‹æ¨¡å¼ä¿è¯å…¨å±€å”¯ä¸€æ€§ï¼Œå·¥å‚æ¨¡å¼åˆ›å»ºè·¯ç”±å’Œä¸­é—´ä»¶ã€‚

**æ¨¡å¼åº”ç”¨**ï¼š
- **å•ä¾‹æ¨¡å¼**ï¼šå…¨å±€Engineå®ä¾‹ï¼Œç¡®ä¿é…ç½®ä¸€è‡´æ€§
- **å·¥å‚æ¨¡å¼**ï¼šè·¯ç”±ç»„ã€ä¸­é—´ä»¶å·¥å‚å‡½æ•°
- **å»ºé€ è€…æ¨¡å¼**ï¼šé“¾å¼é…ç½®å¼•æ“å‚æ•°

**å®Œæ•´å®ç°**ï¼š

```go
package web

import (
    "sync"
    "github.com/gin-gonic/gin"
)

// å•ä¾‹å¼•æ“ï¼ˆå¹¶å‘å®‰å…¨ï¼‰
var (
    engine *gin.Engine
    once   sync.Once
)

func GetEngine() *gin.Engine {
    once.Do(func() {
        engine = gin.New()
        engine.Use(gin.Recovery()) // å…¨å±€ä¸­é—´ä»¶
        engine.Use(gin.Logger())
    })
    return engine
}

// è·¯ç”±å·¥å‚
type RouteFactory struct {
    engine *gin.Engine
}

func NewRouteFactory(e *gin.Engine) *RouteFactory {
    return &RouteFactory{engine: e}
}

func (f *RouteFactory) CreateAPIRoutes() {
    api := f.engine.Group("/api")
    {
        api.GET("/users", GetUsers)
        api.POST("/users", CreateUser)
    }
}

func (f *RouteFactory) CreateAdminRoutes() {
    admin := f.engine.Group("/admin")
    admin.Use(AuthMiddleware()) // è·¯ç”±ç»„ä¸­é—´ä»¶
    {
        admin.GET("/dashboard", AdminDashboard)
    }
}

// ä¸­é—´ä»¶å·¥å‚
func LoggerMiddlewareFactory(logLevel string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // æ ¹æ®logLevelå®šåˆ¶æ—¥å¿—è¡Œä¸º
        c.Next()
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    engine := GetEngine()
    factory := NewRouteFactory(engine)
    factory.CreateAPIRoutes()
    factory.CreateAdminRoutes()
    engine.Run(":8080")
}
```

**æ€§èƒ½æŒ‡æ ‡**ï¼š
- å¯åŠ¨æ—¶é—´ï¼š< 100ms
- å†…å­˜å ç”¨ï¼šåŸºç¡€å¼•æ“çº¦10MB
- è·¯ç”±æŸ¥æ‰¾ï¼šO(1)ï¼ˆåŸºäºRadix Treeï¼‰

**å·¥ç¨‹å¯ç¤º**ï¼š
- å•ä¾‹+å·¥å‚ç®€åŒ–å…¨å±€èµ„æºç®¡ç†ï¼Œæå‡å¯ç»´æŠ¤æ€§
- å»ºé€ è€…æ¨¡å¼æ”¯æŒçµæ´»é…ç½®
- å·¥å‚æ–¹æ³•è§£è€¦è·¯ç”±åˆ›å»ºä¸ä¸šåŠ¡é€»è¾‘
- ä¸­é—´ä»¶å·¥å‚æ”¯æŒåŠ¨æ€é…ç½®

---

### æ¡ˆä¾‹2ï¼šè´£ä»»é“¾ä¸ç­–ç•¥åœ¨è¯·æ±‚å¤„ç†ä¸­çš„åº”ç”¨

**åœºæ™¯èƒŒæ™¯**ï¼š
APIç½‘å…³éœ€è¦å¯¹è¯·æ±‚è¿›è¡Œå¤šå±‚å¤„ç†ï¼šé‰´æƒã€å‚æ•°æ ¡éªŒã€é™æµã€æ—¥å¿—è®°å½•ç­‰ã€‚æ¯å±‚å¤„ç†ç›¸å¯¹ç‹¬ç«‹ï¼Œä¸”éœ€è¦æ”¯æŒåŠ¨æ€æ‰©å±•å’Œé¡ºåºè°ƒæ•´ã€‚

**æ¨¡å¼åº”ç”¨**ï¼š
- **è´£ä»»é“¾æ¨¡å¼**ï¼šä¸­é—´ä»¶é“¾å¼å¤„ç†è¯·æ±‚
- **ç­–ç•¥æ¨¡å¼**ï¼šæ”¯æŒå¤šç§é‰´æƒç®—æ³•ï¼ˆJWTã€OAuth2ã€API Keyï¼‰

**å®Œæ•´å®ç°**ï¼š

```go
package middleware

import (
    "context"
    "fmt"
    "time"
)

// è¯·æ±‚ä¸Šä¸‹æ–‡
type Request struct {
    Method  string
    Path    string
    Headers map[string]string
    UserID  string
    Context context.Context
}

// è´£ä»»é“¾Handleræ¥å£
type Handler interface {
    Handle(*Request) error
    SetNext(Handler)
}

// åŸºç¡€Handler
type BaseHandler struct {
    next Handler
}

func (h *BaseHandler) SetNext(next Handler) {
    h.next = next
}

func (h *BaseHandler) CallNext(req *Request) error {
    if h.next != nil {
        return h.next.Handle(req)
    }
    return nil
}

// é‰´æƒHandlerï¼ˆä½¿ç”¨ç­–ç•¥æ¨¡å¼ï¼‰
type AuthHandler struct {
    BaseHandler
    strategy AuthStrategy
}

// é‰´æƒç­–ç•¥æ¥å£
type AuthStrategy interface {
    Authenticate(*Request) (string, error)
}

// JWTç­–ç•¥
type JWTStrategy struct{}

func (s *JWTStrategy) Authenticate(req *Request) (string, error) {
    token := req.Headers["Authorization"]
    if token == "" {
        return "", fmt.Errorf("missing token")
    }
    // JWTéªŒè¯é€»è¾‘
    userID := "user123" // è§£æå‡ºçš„ç”¨æˆ·ID
    return userID, nil
}

// API Keyç­–ç•¥
type APIKeyStrategy struct{}

func (s *APIKeyStrategy) Authenticate(req *Request) (string, error) {
    apiKey := req.Headers["X-API-Key"]
    if apiKey == "" {
        return "", fmt.Errorf("missing api key")
    }
    // API KeyéªŒè¯é€»è¾‘
    return "api_user", nil
}

func (h *AuthHandler) Handle(req *Request) error {
    userID, err := h.strategy.Authenticate(req)
    if err != nil {
        return fmt.Errorf("auth failed: %w", err)
    }
    req.UserID = userID
    return h.CallNext(req)
}

// é™æµHandler
type RateLimitHandler struct {
    BaseHandler
    limiter map[string]*rateLimiter
}

type rateLimiter struct {
    tokens    int
    maxTokens int
    lastRefill time.Time
}

func (h *RateLimitHandler) Handle(req *Request) error {
    if !h.checkRateLimit(req.UserID) {
        return fmt.Errorf("rate limit exceeded")
    }
    return h.CallNext(req)
}

func (h *RateLimitHandler) checkRateLimit(userID string) bool {
    // ä»¤ç‰Œæ¡¶ç®—æ³•å®ç°
    return true // ç®€åŒ–
}

// æ—¥å¿—Handler
type LogHandler struct {
    BaseHandler
}

func (h *LogHandler) Handle(req *Request) error {
    start := time.Now()
    fmt.Printf("[%s] %s %s - User: %s\n", 
        start.Format(time.RFC3339), req.Method, req.Path, req.UserID)
    
    err := h.CallNext(req)
    
    duration := time.Since(start)
    status := "OK"
    if err != nil {
        status = "FAILED"
    }
    fmt.Printf("[%s] %s %s - Status: %s, Duration: %v\n",
        time.Now().Format(time.RFC3339), req.Method, req.Path, status, duration)
    return err
}

// æ„å»ºè´£ä»»é“¾
func BuildMiddlewareChain() Handler {
    auth := &AuthHandler{strategy: &JWTStrategy{}}
    rateLimit := &RateLimitHandler{limiter: make(map[string]*rateLimiter)}
    log := &LogHandler{}
    
    // ä¸²è”ï¼šæ—¥å¿— -> é‰´æƒ -> é™æµ
    log.SetNext(auth)
    auth.SetNext(rateLimit)
    
    return log
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    chain := BuildMiddlewareChain()
    
    req := &Request{
        Method:  "GET",
        Path:    "/api/users",
        Headers: map[string]string{"Authorization": "Bearer token123"},
        Context: context.Background(),
    }
    
    if err := chain.Handle(req); err != nil {
        fmt.Printf("Request failed: %v\n", err)
    }
}
```

**æ€§èƒ½æŒ‡æ ‡**ï¼š
- ä¸­é—´ä»¶é“¾è°ƒç”¨å¼€é”€ï¼š< 1Î¼s/å±‚
- æ”¯æŒåŠ¨æ€æ’æ‹”ä¸­é—´ä»¶
- å†…å­˜å ç”¨ï¼šæ¯ä¸ªHandlerçº¦50B

**å·¥ç¨‹å¯ç¤º**ï¼š
- è´£ä»»é“¾è§£è€¦å¤„ç†æµç¨‹ï¼Œæ˜“äºæ‰©å±•å’Œç»´æŠ¤
- ç­–ç•¥æ¨¡å¼ä¾¿äºç®—æ³•åˆ‡æ¢ï¼ˆJWT/OAuth2/API Keyï¼‰
- æ¯å±‚Handlerç‹¬ç«‹æµ‹è¯•
- æ”¯æŒä¸­é—´ä»¶çƒ­æ’æ‹”å’Œé¡ºåºè°ƒæ•´

---

### æ¡ˆä¾‹3ï¼šäº‹ä»¶é©±åŠ¨ä¸è§‚å¯Ÿè€…åœ¨å¾®æœåŠ¡ä¸­çš„åº”ç”¨

**åœºæ™¯èƒŒæ™¯**ï¼š
ç”µå•†è®¢å•æœåŠ¡éœ€è¦åœ¨è®¢å•åˆ›å»ºåè§¦å‘å¤šä¸ªä¸‹æ¸¸æ“ä½œï¼šå‘é€é‚®ä»¶ã€æ›´æ–°åº“å­˜ã€ç”Ÿæˆç‰©æµå•ã€é€šçŸ¥ç”¨æˆ·ã€‚è¿™äº›æ“ä½œç›¸å¯¹ç‹¬ç«‹ï¼Œä¸”å¯èƒ½éšæ—¶æ–°å¢ã€‚

**æ¨¡å¼åº”ç”¨**ï¼š
- **äº‹ä»¶é©±åŠ¨æ¶æ„**ï¼šè®¢å•æœåŠ¡å‘å¸ƒäº‹ä»¶ï¼Œä¸‹æ¸¸æœåŠ¡è®¢é˜…
- **è§‚å¯Ÿè€…æ¨¡å¼**ï¼šå¤šä¸ªObserverç›‘å¬OrderCreatedäº‹ä»¶
- **å‘å¸ƒè®¢é˜…æ¨¡å¼**ï¼šé€šè¿‡EventBusè§£è€¦

**å®Œæ•´å®ç°**ï¼š

```go
package eventbus

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// äº‹ä»¶æ¥å£
type Event interface {
    Type() string
    Timestamp() time.Time
    Data() interface{}
}

// è®¢å•åˆ›å»ºäº‹ä»¶
type OrderCreatedEvent struct {
    OrderID   string
    UserID    string
    Amount    float64
    Items     []string
    timestamp time.Time
}

func (e *OrderCreatedEvent) Type() string        { return "order.created" }
func (e *OrderCreatedEvent) Timestamp() time.Time { return e.timestamp }
func (e *OrderCreatedEvent) Data() interface{}   { return e }

// äº‹ä»¶å¤„ç†å™¨æ¥å£
type EventHandler func(context.Context, Event) error

// äº‹ä»¶æ€»çº¿
type EventBus struct {
    handlers map[string][]EventHandler
    mu       sync.RWMutex
    wg       sync.WaitGroup
}

func NewEventBus() *EventBus {
    return &EventBus{
        handlers: make(map[string][]EventHandler),
    }
}

// è®¢é˜…äº‹ä»¶
func (eb *EventBus) Subscribe(eventType string, handler EventHandler) {
    eb.mu.Lock()
    defer eb.mu.Unlock()
    eb.handlers[eventType] = append(eb.handlers[eventType], handler)
}

// å‘å¸ƒäº‹ä»¶ï¼ˆå¼‚æ­¥ï¼‰
func (eb *EventBus) Publish(ctx context.Context, event Event) {
    eb.mu.RLock()
    handlers := eb.handlers[event.Type()]
    eb.mu.RUnlock()
    
    for _, handler := range handlers {
        eb.wg.Add(1)
        go func(h EventHandler) {
            defer eb.wg.Done()
            if err := h(ctx, event); err != nil {
                fmt.Printf("Handler error: %v\n", err)
            }
        }(handler)
    }
}

// ç­‰å¾…æ‰€æœ‰Handlerå®Œæˆ
func (eb *EventBus) Wait() {
    eb.wg.Wait()
}

// é‚®ä»¶æœåŠ¡Observer
func EmailServiceHandler(ctx context.Context, event Event) error {
    orderEvent := event.Data().(*OrderCreatedEvent)
    fmt.Printf("[EmailService] Sending email for order %s to user %s\n",
        orderEvent.OrderID, orderEvent.UserID)
    time.Sleep(100 * time.Millisecond) // æ¨¡æ‹Ÿå‘é€é‚®ä»¶
    return nil
}

// åº“å­˜æœåŠ¡Observer
func InventoryServiceHandler(ctx context.Context, event Event) error {
    orderEvent := event.Data().(*OrderCreatedEvent)
    fmt.Printf("[InventoryService] Updating inventory for order %s\n",
        orderEvent.OrderID)
    time.Sleep(50 * time.Millisecond) // æ¨¡æ‹Ÿæ›´æ–°åº“å­˜
    return nil
}

// ç‰©æµæœåŠ¡Observer
func ShippingServiceHandler(ctx context.Context, event Event) error {
    orderEvent := event.Data().(*OrderCreatedEvent)
    fmt.Printf("[ShippingService] Creating shipping label for order %s\n",
        orderEvent.OrderID)
    time.Sleep(150 * time.Millisecond) // æ¨¡æ‹Ÿç”Ÿæˆç‰©æµå•
    return nil
}

// è®¢å•æœåŠ¡
type OrderService struct {
    eventBus *EventBus
}

func NewOrderService(bus *EventBus) *OrderService {
    return &OrderService{eventBus: bus}
}

func (s *OrderService) CreateOrder(ctx context.Context, userID string, amount float64, items []string) (string, error) {
    orderID := fmt.Sprintf("ORD-%d", time.Now().Unix())
    
    // æŒä¹…åŒ–è®¢å•...
    
    // å‘å¸ƒè®¢å•åˆ›å»ºäº‹ä»¶
    event := &OrderCreatedEvent{
        OrderID:   orderID,
        UserID:    userID,
        Amount:    amount,
        Items:     items,
        timestamp: time.Now(),
    }
    s.eventBus.Publish(ctx, event)
    
    return orderID, nil
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    // åˆå§‹åŒ–EventBus
    bus := NewEventBus()
    
    // è®¢é˜…äº‹ä»¶
    bus.Subscribe("order.created", EmailServiceHandler)
    bus.Subscribe("order.created", InventoryServiceHandler)
    bus.Subscribe("order.created", ShippingServiceHandler)
    
    // è®¢å•æœåŠ¡
    orderService := NewOrderService(bus)
    
    // åˆ›å»ºè®¢å•
    ctx := context.Background()
    orderID, _ := orderService.CreateOrder(ctx, "user123", 299.99, []string{"item1", "item2"})
    fmt.Printf("Order created: %s\n", orderID)
    
    // ç­‰å¾…æ‰€æœ‰Handlerå®Œæˆ
    bus.Wait()
    fmt.Println("All handlers completed")
}
```

**æ€§èƒ½æŒ‡æ ‡**ï¼š
- äº‹ä»¶å‘å¸ƒå»¶è¿Ÿï¼š< 10Î¼s
- Handlerå¹¶å‘æ‰§è¡Œï¼Œäº’ä¸é˜»å¡
- æ”¯æŒç™¾ä¸‡çº§äº‹ä»¶/ç§’ï¼ˆåŸºäºin-memoryå®ç°ï¼‰
- å¯æ‰©å±•åˆ°Kafka/RabbitMQç­‰æ¶ˆæ¯é˜Ÿåˆ—

**å·¥ç¨‹å¯ç¤º**ï¼š
- äº‹ä»¶é©±åŠ¨è§£è€¦æœåŠ¡ï¼Œæå‡ç³»ç»Ÿå¼¹æ€§ä¸å¯æ‰©å±•æ€§
- è§‚å¯Ÿè€…æ¨¡å¼æ”¯æŒåŠ¨æ€æ·»åŠ Handler
- å¼‚æ­¥å¤„ç†æå‡å“åº”é€Ÿåº¦
- ç»“åˆæ¶ˆæ¯é˜Ÿåˆ—ï¼ˆKafkaï¼‰å®ç°è·¨æœåŠ¡è§£è€¦
- éœ€è¦è€ƒè™‘å¹‚ç­‰æ€§ã€é‡è¯•ã€æ­»ä¿¡é˜Ÿåˆ—

---

## 2. ä¸»æµå¼€æºé¡¹ç›®è®¾è®¡æ¨¡å¼åˆ†æ

### 1. [etcd](https://github.com/etcd-io/etcd) - åˆ†å¸ƒå¼é”®å€¼å­˜å‚¨

**é¡¹ç›®ç®€ä»‹**ï¼š
etcdæ˜¯CoreOSå¼€å‘çš„åˆ†å¸ƒå¼ä¸€è‡´æ€§é”®å€¼å­˜å‚¨ï¼ŒåŸºäºRaftåè®®ï¼Œå¹¿æ³›ç”¨äºKubernetesé›†ç¾¤é…ç½®å­˜å‚¨å’ŒæœåŠ¡å‘ç°ã€‚

**æ ¸å¿ƒè®¾è®¡æ¨¡å¼**ï¼š

**1. è§‚å¯Ÿè€…æ¨¡å¼ - Watchæœºåˆ¶**

```go
// etcd watchæœºåˆ¶ç®€åŒ–å®ç°
type Watcher interface {
    Watch(ctx context.Context, key string) chan Event
}

type Event struct {
    Type  EventType // PUT, DELETE
    Key   string
    Value string
}

// å®¢æˆ·ç«¯ä½¿ç”¨
watchChan := client.Watch(ctx, "/config/")
for event := range watchChan {
    fmt.Printf("Event: %s on %s\n", event.Type, event.Key)
}
```

**2. çŠ¶æ€æ¨¡å¼ - RaftçŠ¶æ€æœº**

```go
// RaftèŠ‚ç‚¹çŠ¶æ€
type NodeState int

const (
    Follower NodeState = iota
    Candidate
    Leader
)

type RaftNode struct {
    state NodeState
    // ... å…¶ä»–å­—æ®µ
}

func (n *RaftNode) TransitionTo(newState NodeState) {
    n.state = newState
    switch newState {
    case Leader:
        n.startHeartbeat()
    case Follower:
        n.resetElectionTimer()
    }
}
```

**3. å‘½ä»¤æ¨¡å¼ - Raftæ—¥å¿—**

```go
type LogEntry struct {
    Index   uint64
    Term    uint64
    Command Command
}

type Command interface {
    Execute() error
}

type PutCommand struct {
    Key   string
    Value string
}

func (c *PutCommand) Execute() error {
    // åº”ç”¨åˆ°çŠ¶æ€æœº
    return store.Put(c.Key, c.Value)
}
```

**4. å·¥å‚æ¨¡å¼ - å­˜å‚¨åç«¯**

```go
type Backend interface {
    Put(key, value string) error
    Get(key string) (string, error)
}

func NewBackend(typ string) Backend {
    switch typ {
    case "boltdb":
        return &BoltDBBackend{}
    case "memory":
        return &MemoryBackend{}
    default:
        panic("unknown backend")
    }
}
```

**å·¥ç¨‹å¯ç¤º**ï¼š
- Watchæœºåˆ¶é€šè¿‡è§‚å¯Ÿè€…æ¨¡å¼å®ç°é«˜æ•ˆäº‹ä»¶é€šçŸ¥
- RaftçŠ¶æ€æœºç”¨çŠ¶æ€æ¨¡å¼æ¸…æ™°è¡¨è¾¾èŠ‚ç‚¹è§’è‰²è½¬æ¢
- å‘½ä»¤æ¨¡å¼å°è£…Raftæ—¥å¿—æ“ä½œï¼Œä¾¿äºå›æ”¾å’ŒæŒä¹…åŒ–
- å¤šæ¨¡å¼ç»„åˆæå‡åˆ†å¸ƒå¼ç³»ç»Ÿçš„å¯ç»´æŠ¤æ€§ä¸æ‰©å±•æ€§

---

### 2. [gRPC-Go](https://github.com/grpc/grpc-go) - RPCæ¡†æ¶

**é¡¹ç›®ç®€ä»‹**ï¼š
Googleå¼€æºçš„é«˜æ€§èƒ½RPCæ¡†æ¶ï¼ŒåŸºäºHTTP/2å’ŒProtocol Buffersï¼Œæ”¯æŒå¤šç§è¯­è¨€ã€‚

**æ ¸å¿ƒè®¾è®¡æ¨¡å¼**ï¼š

**1. è´£ä»»é“¾æ¨¡å¼ - æ‹¦æˆªå™¨ï¼ˆInterceptorï¼‰**

```go
// ä¸€å…ƒæ‹¦æˆªå™¨
type UnaryServerInterceptor func(
    ctx context.Context,
    req interface{},
    info *UnaryServerInfo,
    handler UnaryHandler,
) (interface{}, error)

// æ—¥å¿—æ‹¦æˆªå™¨
func LoggingInterceptor(
    ctx context.Context,
    req interface{},
    info *UnaryServerInfo,
    handler UnaryHandler,
) (interface{}, error) {
    start := time.Now()
    resp, err := handler(ctx, req) // è°ƒç”¨ä¸‹ä¸€ä¸ª
    log.Printf("Method: %s, Duration: %v", info.FullMethod, time.Since(start))
    return resp, err
}

// æ³¨å†Œæ‹¦æˆªå™¨é“¾
grpc.NewServer(
    grpc.UnaryInterceptor(LoggingInterceptor),
    grpc.ChainUnaryInterceptor(AuthInterceptor, RateLimitInterceptor),
)
```

**2. ç­–ç•¥æ¨¡å¼ - è´Ÿè½½å‡è¡¡**

```go
// è´Ÿè½½å‡è¡¡ç­–ç•¥æ¥å£
type Balancer interface {
    Pick([]string) (string, error)
}

// è½®è¯¢ç­–ç•¥
type RoundRobinBalancer struct {
    next int
}

func (b *RoundRobinBalancer) Pick(addresses []string) (string, error) {
    addr := addresses[b.next%len(addresses)]
    b.next++
    return addr, nil
}

// ä½¿ç”¨
conn, _ := grpc.Dial(
    "my-service",
    grpc.WithBalancerName("round_robin"),
)
```

**3. å·¥å‚æ¨¡å¼ - è¿æ¥å’Œæµç®¡ç†**

```go
// è¿æ¥å·¥å‚
type ClientConnInterface interface {
    Invoke(ctx context.Context, method string, args, reply interface{}, opts ...CallOption) error
    NewStream(ctx context.Context, desc *StreamDesc, method string, opts ...CallOption) (ClientStream, error)
}

// åˆ›å»ºè¿æ¥
conn, err := grpc.Dial("localhost:50051",
    grpc.WithInsecure(),
    grpc.WithBlock(),
)
defer conn.Close()

client := pb.NewGreeterClient(conn)
```

**4. ä»£ç†æ¨¡å¼ - å®¢æˆ·ç«¯å­˜æ ¹**

```go
// gRPCè‡ªåŠ¨ç”Ÿæˆçš„å®¢æˆ·ç«¯ä»£ç†
type GreeterClient interface {
    SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error)
}

type greeterClient struct {
    cc grpc.ClientConnInterface
}

func (c *greeterClient) SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error) {
    out := new(HelloReply)
    err := c.cc.Invoke(ctx, "/helloworld.Greeter/SayHello", in, out, opts...)
    return out, err
}
```

**å·¥ç¨‹å¯ç¤º**ï¼š
- æ‹¦æˆªå™¨é“¾å®ç°AOPå¼åˆ‡é¢ç¼–ç¨‹ï¼Œæ”¯æŒé‰´æƒã€æ—¥å¿—ã€ç›‘æ§
- ç­–ç•¥æ¨¡å¼è§£è€¦è´Ÿè½½å‡è¡¡ç®—æ³•ï¼Œæ”¯æŒè½®è¯¢ã€åŠ æƒã€ä¸€è‡´æ€§å“ˆå¸Œ
- å·¥å‚æ¨¡å¼ç»Ÿä¸€è¿æ¥å’Œæµåˆ›å»ºï¼Œä¾¿äºè¿æ¥æ± ç®¡ç†
- ä»£ç†æ¨¡å¼å°è£…RPCè°ƒç”¨ç»†èŠ‚ï¼Œæä¾›ç±»å‹å®‰å…¨æ¥å£

---

### 3. [Go kit](https://github.com/go-kit/kit) - å¾®æœåŠ¡å·¥å…·åŒ…

**é¡¹ç›®ç®€ä»‹**ï¼š
Go kitæ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿç¼–ç¨‹å·¥å…·åŒ…ï¼Œæä¾›å¾®æœåŠ¡å¼€å‘çš„å„ç§ç»„ä»¶ï¼šæœåŠ¡å‘ç°ã€è´Ÿè½½å‡è¡¡ã€ç†”æ–­ã€é™æµã€è¿½è¸ªç­‰ã€‚

**æ ¸å¿ƒè®¾è®¡æ¨¡å¼**ï¼š

**1. è£…é¥°å™¨æ¨¡å¼ - ä¸­é—´ä»¶ï¼ˆEndpoint Middlewareï¼‰**

```go
// Endpointå®šä¹‰
type Endpoint func(ctx context.Context, request interface{}) (response interface{}, err error)

// ä¸­é—´ä»¶ç±»å‹
type Middleware func(Endpoint) Endpoint

// æ—¥å¿—ä¸­é—´ä»¶
func LoggingMiddleware(logger log.Logger) Middleware {
    return func(next Endpoint) Endpoint {
        return func(ctx context.Context, request interface{}) (interface{}, error) {
            logger.Log("msg", "calling endpoint")
            defer logger.Log("msg", "called endpoint")
            return next(ctx, request)
        }
    }
}

// é™æµä¸­é—´ä»¶
func RateLimitMiddleware(limiter *rate.Limiter) Middleware {
    return func(next Endpoint) Endpoint {
        return func(ctx context.Context, request interface{}) (interface{}, error) {
            if !limiter.Allow() {
                return nil, ErrRateLimited
            }
            return next(ctx, request)
        }
    }
}

// åº”ç”¨ä¸­é—´ä»¶
endpoint = LoggingMiddleware(logger)(endpoint)
endpoint = RateLimitMiddleware(limiter)(endpoint)
```

**2. ç­–ç•¥æ¨¡å¼ - ç†”æ–­å™¨**

```go
import "github.com/sony/gobreaker"

// ç†”æ–­ç­–ç•¥
settings := gobreaker.Settings{
    Name:        "MyService",
    MaxRequests: 3,
    Interval:    10 * time.Second,
    Timeout:     30 * time.Second,
    ReadyToTrip: func(counts gobreaker.Counts) bool {
        failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)
        return counts.Requests >= 3 && failureRatio >= 0.6
    },
}

cb := gobreaker.NewCircuitBreaker(settings)

// ä½¿ç”¨ç†”æ–­å™¨
_, err := cb.Execute(func() (interface{}, error) {
    return client.Call(ctx, req)
})
```

**3. é€‚é…å™¨æ¨¡å¼ - ä¼ è¾“å±‚é€‚é…**

```go
// HTTPä¼ è¾“é€‚é…å™¨
func MakeHTTPHandler(endpoint Endpoint) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        ctx := r.Context()
        request := decodeHTTPRequest(r)
        response, err := endpoint(ctx, request)
        if err != nil {
            encodeError(w, err)
            return
        }
        encodeHTTPResponse(w, response)
    })
}

// gRPCä¼ è¾“é€‚é…å™¨
type grpcServer struct {
    endpoint Endpoint
}

func (s *grpcServer) SayHello(ctx context.Context, req *pb.HelloRequest) (*pb.HelloReply, error) {
    response, err := s.endpoint(ctx, req)
    if err != nil {
        return nil, err
    }
    return response.(*pb.HelloReply), nil
}
```

**4. æœåŠ¡å‘ç° - å·¥å‚+ç­–ç•¥ç»„åˆ**

```go
import (
    "github.com/go-kit/kit/sd"
    "github.com/go-kit/kit/sd/lb"
)

// æœåŠ¡å‘ç°+è´Ÿè½½å‡è¡¡
subscriber := sd.FixedSubscriber{} // æˆ–etcdã€consul
balancer := lb.NewRoundRobin(subscriber)

// åˆ›å»ºendpointå·¥å‚
factory := func(instance string) (endpoint.Endpoint, io.Closer, error) {
    conn, _ := grpc.Dial(instance, grpc.WithInsecure())
    return MakeClientEndpoint(conn), conn, nil
}

// é›†æˆ
endpointer := sd.NewEndpointer(subscriber, factory, logger)
balancedEndpoint := lb.Retry(3, 500*time.Millisecond, lb.NewRoundRobin(endpointer))
```

**å·¥ç¨‹å¯ç¤º**ï¼š
- è£…é¥°å™¨æ¨¡å¼æ„å»ºçµæ´»çš„ä¸­é—´ä»¶é“¾ï¼Œè§£è€¦æ¨ªåˆ‡å…³æ³¨ç‚¹
- ç†”æ–­å™¨ã€é™æµç­‰ç­–ç•¥æ¨¡å¼ä¿éšœæœåŠ¡ç¨³å®šæ€§
- é€‚é…å™¨æ¨¡å¼ç»Ÿä¸€HTTP/gRPC/Thriftç­‰ä¼ è¾“å±‚
- æœåŠ¡å‘ç°+è´Ÿè½½å‡è¡¡é€šè¿‡å·¥å‚+ç­–ç•¥ç»„åˆå®ç°é«˜å¯ç”¨
- è®¾è®¡æ¨¡å¼æ”¯æ’‘å¾®æœåŠ¡çš„å¯è§‚æµ‹æ€§ã€å¼¹æ€§å’Œæ‰©å±•æ€§

---

## 3. å·¥ç¨‹æ€»ç»“

- ç»“åˆä¸šåŠ¡åœºæ™¯é€‰ç”¨åˆé€‚è®¾è®¡æ¨¡å¼ï¼Œæå‡ç³»ç»Ÿè§£è€¦ã€å¯ç»´æŠ¤æ€§ä¸æ‰©å±•æ€§ã€‚
- å¤šæ¨¡å¼ç»„åˆå¸¸è§äºå¤æ‚ç³»ç»Ÿï¼Œå…³æ³¨æ¥å£è®¾è®¡ä¸ç»„åˆä¼˜å…ˆã€‚
- å–„ç”¨Go idiomaticå®ç°ï¼Œç»“åˆå¹¶å‘ã€åˆ†å¸ƒå¼ã€äº‘åŸç”Ÿç­‰ç°ä»£å·¥ç¨‹éœ€æ±‚ã€‚

---

## 4. å‚è€ƒæ–‡çŒ®

- Goå®˜æ–¹æ–‡æ¡£ï¼š<https://golang.org/doc/>
- Ginæºç ï¼š<https://github.com/gin-gonic/gin>
- etcdæºç ï¼š<https://github.com/etcd-io/etcd>
- gRPC-Goæºç ï¼š<https://github.com/grpc/grpc-go>
- Go kitæºç ï¼š<https://github.com/go-kit/kit>
- Goè®¾è®¡æ¨¡å¼å®æˆ˜ï¼š<https://github.com/senghoo/golang-design-pattern>

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ20æ—¥  
**æ–‡æ¡£çŠ¶æ€**: å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
