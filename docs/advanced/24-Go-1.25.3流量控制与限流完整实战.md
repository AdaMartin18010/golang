# Go 1.25.3 æµé‡æ§åˆ¶ä¸é™æµå®Œæ•´å®æˆ˜

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.25.3

---

## ğŸ“‹ ç›®å½•

- [Go 1.25.3 æµé‡æ§åˆ¶ä¸é™æµå®Œæ•´å®æˆ˜](#go-1253-æµé‡æ§åˆ¶ä¸é™æµå®Œæ•´å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“– æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. ä»¤ç‰Œæ¡¶é™æµ](#1-ä»¤ç‰Œæ¡¶é™æµ)
    - [1.1 åŸºç¡€ä»¤ç‰Œæ¡¶](#11-åŸºç¡€ä»¤ç‰Œæ¡¶)
    - [1.2 ä»¤ç‰Œæ¡¶ä¸­é—´ä»¶](#12-ä»¤ç‰Œæ¡¶ä¸­é—´ä»¶)
  - [2. æ¼æ¡¶é™æµ](#2-æ¼æ¡¶é™æµ)
    - [2.1 æ¼æ¡¶å®ç°](#21-æ¼æ¡¶å®ç°)
    - [2.2 æ¼æ¡¶ä¸­é—´ä»¶](#22-æ¼æ¡¶ä¸­é—´ä»¶)
  - [3. æ»‘åŠ¨çª—å£é™æµ](#3-æ»‘åŠ¨çª—å£é™æµ)
    - [3.1 å›ºå®šçª—å£](#31-å›ºå®šçª—å£)
    - [3.2 æ»‘åŠ¨çª—å£](#32-æ»‘åŠ¨çª—å£)
  - [4. åˆ†å¸ƒå¼é™æµ](#4-åˆ†å¸ƒå¼é™æµ)
    - [4.1 Redisé™æµ](#41-redisé™æµ)
    - [4.2 åˆ†å¸ƒå¼æ»‘åŠ¨çª—å£](#42-åˆ†å¸ƒå¼æ»‘åŠ¨çª—å£)
  - [5. ç†”æ–­é™çº§](#5-ç†”æ–­é™çº§)
    - [5.1 ç†”æ–­å™¨](#51-ç†”æ–­å™¨)
    - [5.2 ç†”æ–­ä¸­é—´ä»¶](#52-ç†”æ–­ä¸­é—´ä»¶)
  - [6. è‡ªé€‚åº”é™æµ](#6-è‡ªé€‚åº”é™æµ)
    - [6.1 åŸºäºç³»ç»Ÿè´Ÿè½½](#61-åŸºäºç³»ç»Ÿè´Ÿè½½)
    - [6.2 åŠ¨æ€è°ƒæ•´](#62-åŠ¨æ€è°ƒæ•´)
  - [7. æµé‡æ•´å½¢](#7-æµé‡æ•´å½¢)
    - [7.1 ä¼˜å…ˆçº§é˜Ÿåˆ—](#71-ä¼˜å…ˆçº§é˜Ÿåˆ—)
    - [7.2 æµé‡è°ƒåº¦](#72-æµé‡è°ƒåº¦)
  - [8. å®Œæ•´æ¡ˆä¾‹](#8-å®Œæ•´æ¡ˆä¾‹)
    - [8.1 å¤šçº§é™æµç³»ç»Ÿ](#81-å¤šçº§é™æµç³»ç»Ÿ)
  - [ğŸ“š é™æµæœ€ä½³å®è·µ](#-é™æµæœ€ä½³å®è·µ)
    - [ç®—æ³•é€‰æ‹©](#ç®—æ³•é€‰æ‹©)
    - [é™æµç­–ç•¥](#é™æµç­–ç•¥)
    - [ç†”æ–­ç­–ç•¥](#ç†”æ–­ç­–ç•¥)
    - [ç›‘æ§å‘Šè­¦](#ç›‘æ§å‘Šè­¦)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

## ğŸ“– æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£å±•ç¤ºGo 1.25.3çš„**æµé‡æ§åˆ¶ä¸é™æµå®Œæ•´æ–¹æ¡ˆ**ï¼Œæ„å»ºé«˜å¯ç”¨ç³»ç»Ÿï¼š

- âœ… ä»¤ç‰Œæ¡¶ç®—æ³•
- âœ… æ¼æ¡¶ç®—æ³•
- âœ… æ»‘åŠ¨çª—å£é™æµ
- âœ… åˆ†å¸ƒå¼é™æµ
- âœ… ç†”æ–­é™çº§
- âœ… æµé‡æ•´å½¢
- âœ… åŠ¨æ€é™æµ
- âœ… è¿‡è½½ä¿æŠ¤

---

## ç›®å½•

- [Go 1.25.3 æµé‡æ§åˆ¶ä¸é™æµå®Œæ•´å®æˆ˜](#go-1253-æµé‡æ§åˆ¶ä¸é™æµå®Œæ•´å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“– æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. ä»¤ç‰Œæ¡¶é™æµ](#1-ä»¤ç‰Œæ¡¶é™æµ)
    - [1.1 åŸºç¡€ä»¤ç‰Œæ¡¶](#11-åŸºç¡€ä»¤ç‰Œæ¡¶)
    - [1.2 ä»¤ç‰Œæ¡¶ä¸­é—´ä»¶](#12-ä»¤ç‰Œæ¡¶ä¸­é—´ä»¶)
  - [2. æ¼æ¡¶é™æµ](#2-æ¼æ¡¶é™æµ)
    - [2.1 æ¼æ¡¶å®ç°](#21-æ¼æ¡¶å®ç°)
    - [2.2 æ¼æ¡¶ä¸­é—´ä»¶](#22-æ¼æ¡¶ä¸­é—´ä»¶)
  - [3. æ»‘åŠ¨çª—å£é™æµ](#3-æ»‘åŠ¨çª—å£é™æµ)
    - [3.1 å›ºå®šçª—å£](#31-å›ºå®šçª—å£)
    - [3.2 æ»‘åŠ¨çª—å£](#32-æ»‘åŠ¨çª—å£)
  - [4. åˆ†å¸ƒå¼é™æµ](#4-åˆ†å¸ƒå¼é™æµ)
    - [4.1 Redisé™æµ](#41-redisé™æµ)
    - [4.2 åˆ†å¸ƒå¼æ»‘åŠ¨çª—å£](#42-åˆ†å¸ƒå¼æ»‘åŠ¨çª—å£)
  - [5. ç†”æ–­é™çº§](#5-ç†”æ–­é™çº§)
    - [5.1 ç†”æ–­å™¨](#51-ç†”æ–­å™¨)
    - [5.2 ç†”æ–­ä¸­é—´ä»¶](#52-ç†”æ–­ä¸­é—´ä»¶)
  - [6. è‡ªé€‚åº”é™æµ](#6-è‡ªé€‚åº”é™æµ)
    - [6.1 åŸºäºç³»ç»Ÿè´Ÿè½½](#61-åŸºäºç³»ç»Ÿè´Ÿè½½)
    - [6.2 åŠ¨æ€è°ƒæ•´](#62-åŠ¨æ€è°ƒæ•´)
  - [7. æµé‡æ•´å½¢](#7-æµé‡æ•´å½¢)
    - [7.1 ä¼˜å…ˆçº§é˜Ÿåˆ—](#71-ä¼˜å…ˆçº§é˜Ÿåˆ—)
    - [7.2 æµé‡è°ƒåº¦](#72-æµé‡è°ƒåº¦)
  - [8. å®Œæ•´æ¡ˆä¾‹](#8-å®Œæ•´æ¡ˆä¾‹)
    - [8.1 å¤šçº§é™æµç³»ç»Ÿ](#81-å¤šçº§é™æµç³»ç»Ÿ)
  - [ğŸ“š é™æµæœ€ä½³å®è·µ](#-é™æµæœ€ä½³å®è·µ)
    - [ç®—æ³•é€‰æ‹©](#ç®—æ³•é€‰æ‹©)
    - [é™æµç­–ç•¥](#é™æµç­–ç•¥)
    - [ç†”æ–­ç­–ç•¥](#ç†”æ–­ç­–ç•¥)
    - [ç›‘æ§å‘Šè­¦](#ç›‘æ§å‘Šè­¦)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

---

## 1. ä»¤ç‰Œæ¡¶é™æµ

### 1.1 åŸºç¡€ä»¤ç‰Œæ¡¶

```go
package ratelimit

import (
 "context"
 "sync"
 "time"
)

// TokenBucket ä»¤ç‰Œæ¡¶
type TokenBucket struct {
 rate       float64       // ä»¤ç‰Œç”Ÿæˆé€Ÿç‡ï¼ˆæ¯ç§’ï¼‰
 capacity   float64       // æ¡¶å®¹é‡
 tokens     float64       // å½“å‰ä»¤ç‰Œæ•°
 lastRefill time.Time     // ä¸Šæ¬¡å¡«å……æ—¶é—´
 mu         sync.Mutex
}

// NewTokenBucket åˆ›å»ºä»¤ç‰Œæ¡¶
func NewTokenBucket(rate, capacity float64) *TokenBucket {
 return &TokenBucket{
  rate:       rate,
  capacity:   capacity,
  tokens:     capacity,
  lastRefill: time.Now(),
 }
}

// Allow å°è¯•è·å–ä»¤ç‰Œ
func (tb *TokenBucket) Allow() bool {
 tb.mu.Lock()
 defer tb.mu.Unlock()

 // å¡«å……ä»¤ç‰Œ
 now := time.Now()
 elapsed := now.Sub(tb.lastRefill).Seconds()
 tb.tokens += elapsed * tb.rate

 if tb.tokens > tb.capacity {
  tb.tokens = tb.capacity
 }

 tb.lastRefill = now

 // æ¶ˆè´¹ä»¤ç‰Œ
 if tb.tokens >= 1.0 {
  tb.tokens -= 1.0
  return true
 }

 return false
}

// AllowN å°è¯•è·å–Nä¸ªä»¤ç‰Œ
func (tb *TokenBucket) AllowN(n int) bool {
 tb.mu.Lock()
 defer tb.mu.Unlock()

 // å¡«å……ä»¤ç‰Œ
 now := time.Now()
 elapsed := now.Sub(tb.lastRefill).Seconds()
 tb.tokens += elapsed * tb.rate

 if tb.tokens > tb.capacity {
  tb.tokens = tb.capacity
 }

 tb.lastRefill = now

 // æ¶ˆè´¹ä»¤ç‰Œ
 needed := float64(n)
 if tb.tokens >= needed {
  tb.tokens -= needed
  return true
 }

 return false
}

// Wait ç­‰å¾…è·å–ä»¤ç‰Œ
func (tb *TokenBucket) Wait(ctx context.Context) error {
 for {
  if tb.Allow() {
   return nil
  }

  select {
  case <-ctx.Done():
   return ctx.Err()
  case <-time.After(time.Millisecond * 10):
   // ç»§ç»­å°è¯•
  }
 }
}

// Available è·å–å¯ç”¨ä»¤ç‰Œæ•°
func (tb *TokenBucket) Available() float64 {
 tb.mu.Lock()
 defer tb.mu.Unlock()

 // å¡«å……ä»¤ç‰Œ
 now := time.Now()
 elapsed := now.Sub(tb.lastRefill).Seconds()
 tokens := tb.tokens + elapsed*tb.rate

 if tokens > tb.capacity {
  tokens = tb.capacity
 }

 return tokens
}
```

---

### 1.2 ä»¤ç‰Œæ¡¶ä¸­é—´ä»¶

```go
package middleware

import (
 "net/http"
)

// RateLimitMiddleware é™æµä¸­é—´ä»¶
func RateLimitMiddleware(limiter *ratelimit.TokenBucket) func(http.Handler) http.Handler {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   if !limiter.Allow() {
    http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
    return
   }

   next.ServeHTTP(w, r)
  })
 }
}

// PerIPRateLimitMiddleware æŒ‰IPé™æµ
func PerIPRateLimitMiddleware(rate, capacity float64) func(http.Handler) http.Handler {
 limiters := &sync.Map{}

 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   ip := getClientIP(r)

   // è·å–æˆ–åˆ›å»ºé™æµå™¨
   limiter, _ := limiters.LoadOrStore(ip, ratelimit.NewTokenBucket(rate, capacity))

   if !limiter.(*ratelimit.TokenBucket).Allow() {
    http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
    return
   }

   next.ServeHTTP(w, r)
  })
 }
}

// getClientIP è·å–å®¢æˆ·ç«¯IP
func getClientIP(r *http.Request) string {
 // å°è¯•ä»X-Forwarded-Forè·å–
 if xff := r.Header.Get("X-Forwarded-For"); xff != "" {
  return xff
 }

 // å°è¯•ä»X-Real-IPè·å–
 if xri := r.Header.Get("X-Real-IP"); xri != "" {
  return xri
 }

 // ä½¿ç”¨RemoteAddr
 return r.RemoteAddr
}
```

---

## 2. æ¼æ¡¶é™æµ

### 2.1 æ¼æ¡¶å®ç°

```go
package ratelimit

import (
 "sync"
 "time"
)

// LeakyBucket æ¼æ¡¶
type LeakyBucket struct {
 rate       float64   // æ¼å‡ºé€Ÿç‡ï¼ˆæ¯ç§’ï¼‰
 capacity   int       // æ¡¶å®¹é‡
 queue      []time.Time // è¯·æ±‚é˜Ÿåˆ—
 mu         sync.Mutex
}

// NewLeakyBucket åˆ›å»ºæ¼æ¡¶
func NewLeakyBucket(rate float64, capacity int) *LeakyBucket {
 return &LeakyBucket{
  rate:     rate,
  capacity: capacity,
  queue:    make([]time.Time, 0, capacity),
 }
}

// Allow å°è¯•æ·»åŠ è¯·æ±‚
func (lb *LeakyBucket) Allow() bool {
 lb.mu.Lock()
 defer lb.mu.Unlock()

 now := time.Now()

 // ç§»é™¤å·²å¤„ç†çš„è¯·æ±‚
 lb.leak(now)

 // æ£€æŸ¥å®¹é‡
 if len(lb.queue) >= lb.capacity {
  return false
 }

 // æ·»åŠ è¯·æ±‚
 lb.queue = append(lb.queue, now)
 return true
}

// leak æ¼å‡ºè¯·æ±‚
func (lb *LeakyBucket) leak(now time.Time) {
 // è®¡ç®—åº”è¯¥å¤„ç†çš„è¯·æ±‚æ•°
 if len(lb.queue) == 0 {
  return
 }

 // è®¡ç®—ä»ç¬¬ä¸€ä¸ªè¯·æ±‚åˆ°ç°åœ¨å¯ä»¥å¤„ç†çš„è¯·æ±‚æ•°
 firstReq := lb.queue[0]
 elapsed := now.Sub(firstReq).Seconds()
 processed := int(elapsed * lb.rate)

 if processed > 0 {
  if processed >= len(lb.queue) {
   lb.queue = lb.queue[:0]
  } else {
   lb.queue = lb.queue[processed:]
  }
 }
}

// Size è·å–é˜Ÿåˆ—å¤§å°
func (lb *LeakyBucket) Size() int {
 lb.mu.Lock()
 defer lb.mu.Unlock()

 lb.leak(time.Now())
 return len(lb.queue)
}
```

---

### 2.2 æ¼æ¡¶ä¸­é—´ä»¶

```go
// LeakyBucketMiddleware æ¼æ¡¶é™æµä¸­é—´ä»¶
func LeakyBucketMiddleware(limiter *ratelimit.LeakyBucket) func(http.Handler) http.Handler {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   if !limiter.Allow() {
    http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
    return
   }

   next.ServeHTTP(w, r)
  })
 }
}
```

---

## 3. æ»‘åŠ¨çª—å£é™æµ

### 3.1 å›ºå®šçª—å£

```go
package ratelimit

import (
 "sync"
 "time"
)

// FixedWindow å›ºå®šçª—å£é™æµ
type FixedWindow struct {
 limit    int           // é™æµé˜ˆå€¼
 window   time.Duration // çª—å£å¤§å°
 count    int           // å½“å‰è®¡æ•°
 reset    time.Time     // é‡ç½®æ—¶é—´
 mu       sync.Mutex
}

// NewFixedWindow åˆ›å»ºå›ºå®šçª—å£
func NewFixedWindow(limit int, window time.Duration) *FixedWindow {
 return &FixedWindow{
  limit:  limit,
  window: window,
  reset:  time.Now().Add(window),
 }
}

// Allow å°è¯•é€šè¿‡
func (fw *FixedWindow) Allow() bool {
 fw.mu.Lock()
 defer fw.mu.Unlock()

 now := time.Now()

 // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡ç½®
 if now.After(fw.reset) {
  fw.count = 0
  fw.reset = now.Add(fw.window)
 }

 // æ£€æŸ¥é™æµ
 if fw.count >= fw.limit {
  return false
 }

 fw.count++
 return true
}
```

---

### 3.2 æ»‘åŠ¨çª—å£

```go
// SlidingWindow æ»‘åŠ¨çª—å£é™æµ
type SlidingWindow struct {
 limit    int           // é™æµé˜ˆå€¼
 window   time.Duration // çª—å£å¤§å°
 requests []time.Time   // è¯·æ±‚æ—¶é—´æˆ³
 mu       sync.Mutex
}

// NewSlidingWindow åˆ›å»ºæ»‘åŠ¨çª—å£
func NewSlidingWindow(limit int, window time.Duration) *SlidingWindow {
 return &SlidingWindow{
  limit:    limit,
  window:   window,
  requests: make([]time.Time, 0, limit),
 }
}

// Allow å°è¯•é€šè¿‡
func (sw *SlidingWindow) Allow() bool {
 sw.mu.Lock()
 defer sw.mu.Unlock()

 now := time.Now()
 cutoff := now.Add(-sw.window)

 // ç§»é™¤è¿‡æœŸè¯·æ±‚
 valid := 0
 for _, req := range sw.requests {
  if req.After(cutoff) {
   sw.requests[valid] = req
   valid++
  }
 }
 sw.requests = sw.requests[:valid]

 // æ£€æŸ¥é™æµ
 if len(sw.requests) >= sw.limit {
  return false
 }

 // æ·»åŠ è¯·æ±‚
 sw.requests = append(sw.requests, now)
 return true
}

// Count è·å–å½“å‰è¯·æ±‚æ•°
func (sw *SlidingWindow) Count() int {
 sw.mu.Lock()
 defer sw.mu.Unlock()

 now := time.Now()
 cutoff := now.Add(-sw.window)

 count := 0
 for _, req := range sw.requests {
  if req.After(cutoff) {
   count++
  }
 }

 return count
}
```

---

## 4. åˆ†å¸ƒå¼é™æµ

### 4.1 Redisé™æµ

```go
package ratelimit

import (
 "context"
 "time"

 "github.com/redis/go-redis/v9"
)

// RedisRateLimiter Redisé™æµå™¨
type RedisRateLimiter struct {
 client *redis.Client
 key    string
 limit  int
 window time.Duration
}

// NewRedisRateLimiter åˆ›å»ºRedisé™æµå™¨
func NewRedisRateLimiter(client *redis.Client, key string, limit int, window time.Duration) *RedisRateLimiter {
 return &RedisRateLimiter{
  client: client,
  key:    key,
  limit:  limit,
  window: window,
 }
}

// Allow å°è¯•é€šè¿‡ï¼ˆä½¿ç”¨Luaè„šæœ¬ä¿è¯åŸå­æ€§ï¼‰
func (rrl *RedisRateLimiter) Allow(ctx context.Context) (bool, error) {
 // Luaè„šæœ¬å®ç°æ»‘åŠ¨çª—å£
 script := `
  local key = KEYS[1]
  local limit = tonumber(ARGV[1])
  local window = tonumber(ARGV[2])
  local now = tonumber(ARGV[3])
  local cutoff = now - window

  -- ç§»é™¤è¿‡æœŸè®°å½•
  redis.call('ZREMRANGEBYSCORE', key, 0, cutoff)

  -- è·å–å½“å‰æ•°é‡
  local count = redis.call('ZCARD', key)

  if count < limit then
   -- æ·»åŠ å½“å‰è¯·æ±‚
   redis.call('ZADD', key, now, now)
   redis.call('EXPIRE', key, window)
   return 1
  else
   return 0
  end
 `

 now := time.Now().UnixNano()
 result, err := rrl.client.Eval(ctx, script, []string{rrl.key},
  rrl.limit, rrl.window.Nanoseconds(), now).Int()

 if err != nil {
  return false, err
 }

 return result == 1, nil
}

// Count è·å–å½“å‰è¯·æ±‚æ•°
func (rrl *RedisRateLimiter) Count(ctx context.Context) (int64, error) {
 now := time.Now().UnixNano()
 cutoff := now - rrl.window.Nanoseconds()

 // ç§»é™¤è¿‡æœŸè®°å½•
 rrl.client.ZRemRangeByScore(ctx, rrl.key, "0", fmt.Sprint(cutoff))

 // è·å–å½“å‰æ•°é‡
 return rrl.client.ZCard(ctx, rrl.key).Result()
}
```

---

### 4.2 åˆ†å¸ƒå¼æ»‘åŠ¨çª—å£

```go
// RedisTokenBucket Redisä»¤ç‰Œæ¡¶
type RedisTokenBucket struct {
 client   *redis.Client
 key      string
 rate     float64
 capacity float64
}

// NewRedisTokenBucket åˆ›å»ºRedisä»¤ç‰Œæ¡¶
func NewRedisTokenBucket(client *redis.Client, key string, rate, capacity float64) *RedisTokenBucket {
 return &RedisTokenBucket{
  client:   client,
  key:      key,
  rate:     rate,
  capacity: capacity,
 }
}

// Allow å°è¯•è·å–ä»¤ç‰Œ
func (rtb *RedisTokenBucket) Allow(ctx context.Context) (bool, error) {
 // Luaè„šæœ¬å®ç°ä»¤ç‰Œæ¡¶
 script := `
  local key = KEYS[1]
  local rate = tonumber(ARGV[1])
  local capacity = tonumber(ARGV[2])
  local now = tonumber(ARGV[3])

  -- è·å–å½“å‰çŠ¶æ€
  local tokens = tonumber(redis.call('HGET', key, 'tokens') or capacity)
  local last_refill = tonumber(redis.call('HGET', key, 'last_refill') or now)

  -- è®¡ç®—æ–°ä»¤ç‰Œ
  local elapsed = (now - last_refill) / 1000000000
  tokens = tokens + elapsed * rate

  if tokens > capacity then
   tokens = capacity
  end

  -- å°è¯•æ¶ˆè´¹ä»¤ç‰Œ
  if tokens >= 1 then
   tokens = tokens - 1
   redis.call('HSET', key, 'tokens', tokens)
   redis.call('HSET', key, 'last_refill', now)
   redis.call('EXPIRE', key, 60)
   return 1
  else
   redis.call('HSET', key, 'tokens', tokens)
   redis.call('HSET', key, 'last_refill', now)
   return 0
  end
 `

 now := time.Now().UnixNano()
 result, err := rtb.client.Eval(ctx, script, []string{rtb.key},
  rtb.rate, rtb.capacity, now).Int()

 if err != nil {
  return false, err
 }

 return result == 1, nil
}
```

---

## 5. ç†”æ–­é™çº§

### 5.1 ç†”æ–­å™¨

```go
package circuitbreaker

import (
 "errors"
 "sync"
 "time"
)

// State ç†”æ–­å™¨çŠ¶æ€
type State int

const (
 StateClosed State = iota // å…³é—­ï¼ˆæ­£å¸¸ï¼‰
 StateOpen                // æ‰“å¼€ï¼ˆç†”æ–­ï¼‰
 StateHalfOpen            // åŠå¼€ï¼ˆå°è¯•æ¢å¤ï¼‰
)

// CircuitBreaker ç†”æ–­å™¨
type CircuitBreaker struct {
 maxRequests  uint32        // åŠå¼€çŠ¶æ€æœ€å¤§è¯·æ±‚æ•°
 interval     time.Duration // ç»Ÿè®¡å‘¨æœŸ
 timeout      time.Duration // ç†”æ–­è¶…æ—¶æ—¶é—´
 readyToTrip  func(counts Counts) bool // åˆ¤æ–­æ˜¯å¦ç†”æ–­
 onStateChange func(from, to State)    // çŠ¶æ€å˜åŒ–å›è°ƒ

 mu          sync.Mutex
 state       State
 generation  uint64
 counts      Counts
 expiry      time.Time
}

// Counts ç»Ÿè®¡æ•°æ®
type Counts struct {
 Requests             uint32
 TotalSuccesses       uint32
 TotalFailures        uint32
 ConsecutiveSuccesses uint32
 ConsecutiveFailures  uint32
}

// NewCircuitBreaker åˆ›å»ºç†”æ–­å™¨
func NewCircuitBreaker(settings Settings) *CircuitBreaker {
 cb := &CircuitBreaker{
  maxRequests: settings.MaxRequests,
  interval:    settings.Interval,
  timeout:     settings.Timeout,
  readyToTrip: settings.ReadyToTrip,
  onStateChange: settings.OnStateChange,
  state:       StateClosed,
 }

 if cb.maxRequests == 0 {
  cb.maxRequests = 1
 }

 if cb.interval == 0 {
  cb.interval = time.Minute
 }

 if cb.timeout == 0 {
  cb.timeout = time.Minute
 }

 if cb.readyToTrip == nil {
  cb.readyToTrip = defaultReadyToTrip
 }

 return cb
}

// Settings ç†”æ–­å™¨é…ç½®
type Settings struct {
 MaxRequests   uint32
 Interval      time.Duration
 Timeout       time.Duration
 ReadyToTrip   func(counts Counts) bool
 OnStateChange func(from, to State)
}

// Execute æ‰§è¡Œå‡½æ•°
func (cb *CircuitBreaker) Execute(req func() (interface{}, error)) (interface{}, error) {
 generation, err := cb.beforeRequest()
 if err != nil {
  return nil, err
 }

 defer func() {
  e := recover()
  if e != nil {
   cb.afterRequest(generation, false)
   panic(e)
  }
 }()

 result, err := req()
 cb.afterRequest(generation, err == nil)
 return result, err
}

// beforeRequest è¯·æ±‚å‰æ£€æŸ¥
func (cb *CircuitBreaker) beforeRequest() (uint64, error) {
 cb.mu.Lock()
 defer cb.mu.Unlock()

 now := time.Now()
 state, generation := cb.currentState(now)

 if state == StateOpen {
  return generation, errors.New("circuit breaker is open")
 } else if state == StateHalfOpen && cb.counts.Requests >= cb.maxRequests {
  return generation, errors.New("too many requests")
 }

 cb.counts.Requests++
 return generation, nil
}

// afterRequest è¯·æ±‚åå¤„ç†
func (cb *CircuitBreaker) afterRequest(before uint64, success bool) {
 cb.mu.Lock()
 defer cb.mu.Unlock()

 now := time.Now()
 state, generation := cb.currentState(now)

 if generation != before {
  return
 }

 if success {
  cb.onSuccess(state, now)
 } else {
  cb.onFailure(state, now)
 }
}

// onSuccess æˆåŠŸå¤„ç†
func (cb *CircuitBreaker) onSuccess(state State, now time.Time) {
 cb.counts.TotalSuccesses++
 cb.counts.ConsecutiveSuccesses++
 cb.counts.ConsecutiveFailures = 0

 if state == StateHalfOpen {
  // åŠå¼€çŠ¶æ€ï¼Œå°è¯•å…³é—­
  cb.setState(StateClosed, now)
 }
}

// onFailure å¤±è´¥å¤„ç†
func (cb *CircuitBreaker) onFailure(state State, now time.Time) {
 cb.counts.TotalFailures++
 cb.counts.ConsecutiveFailures++
 cb.counts.ConsecutiveSuccesses = 0

 if cb.readyToTrip(cb.counts) {
  cb.setState(StateOpen, now)
 }
}

// currentState è·å–å½“å‰çŠ¶æ€
func (cb *CircuitBreaker) currentState(now time.Time) (State, uint64) {
 switch cb.state {
 case StateClosed:
  if !cb.expiry.IsZero() && cb.expiry.Before(now) {
   cb.toNewGeneration(now)
  }
 case StateOpen:
  if cb.expiry.Before(now) {
   cb.setState(StateHalfOpen, now)
  }
 }

 return cb.state, cb.generation
}

// setState è®¾ç½®çŠ¶æ€
func (cb *CircuitBreaker) setState(state State, now time.Time) {
 if cb.state == state {
  return
 }

 prev := cb.state
 cb.state = state

 cb.toNewGeneration(now)

 if cb.onStateChange != nil {
  cb.onStateChange(prev, state)
 }
}

// toNewGeneration è¿›å…¥æ–°å‘¨æœŸ
func (cb *CircuitBreaker) toNewGeneration(now time.Time) {
 cb.generation++
 cb.counts = Counts{}

 var zero time.Time
 switch cb.state {
 case StateClosed:
  if cb.interval == 0 {
   cb.expiry = zero
  } else {
   cb.expiry = now.Add(cb.interval)
  }
 case StateOpen:
  cb.expiry = now.Add(cb.timeout)
 default:
  cb.expiry = zero
 }
}

// defaultReadyToTrip é»˜è®¤ç†”æ–­åˆ¤æ–­
func defaultReadyToTrip(counts Counts) bool {
 return counts.ConsecutiveFailures > 5
}

// State è·å–çŠ¶æ€
func (cb *CircuitBreaker) State() State {
 cb.mu.Lock()
 defer cb.mu.Unlock()

 now := time.Now()
 state, _ := cb.currentState(now)
 return state
}
```

---

### 5.2 ç†”æ–­ä¸­é—´ä»¶

```go
// CircuitBreakerMiddleware ç†”æ–­ä¸­é—´ä»¶
func CircuitBreakerMiddleware(cb *circuitbreaker.CircuitBreaker) func(http.Handler) http.Handler {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   _, err := cb.Execute(func() (interface{}, error) {
    recorder := &statusRecorder{
     ResponseWriter: w,
     statusCode:     http.StatusOK,
    }

    next.ServeHTTP(recorder, r)

    if recorder.statusCode >= 500 {
     return nil, errors.New("server error")
    }

    return nil, nil
   })

   if err != nil {
    http.Error(w, "Service unavailable", http.StatusServiceUnavailable)
    return
   }
  })
 }
}
```

---

## 6. è‡ªé€‚åº”é™æµ

### 6.1 åŸºäºç³»ç»Ÿè´Ÿè½½

```go
package adaptive

import (
 "runtime"
 "sync"
 "time"
)

// AdaptiveLimiter è‡ªé€‚åº”é™æµå™¨
type AdaptiveLimiter struct {
 minRate      float64
 maxRate      float64
 currentRate  float64
 targetCPU    float64
 adjustPeriod time.Duration

 mu sync.RWMutex
 tb *ratelimit.TokenBucket
}

// NewAdaptiveLimiter åˆ›å»ºè‡ªé€‚åº”é™æµå™¨
func NewAdaptiveLimiter(minRate, maxRate, targetCPU float64) *AdaptiveLimiter {
 al := &AdaptiveLimiter{
  minRate:      minRate,
  maxRate:      maxRate,
  currentRate:  maxRate,
  targetCPU:    targetCPU,
  adjustPeriod: time.Second,
  tb:           ratelimit.NewTokenBucket(maxRate, maxRate),
 }

 go al.adjustRate()

 return al
}

// Allow å°è¯•é€šè¿‡
func (al *AdaptiveLimiter) Allow() bool {
 al.mu.RLock()
 defer al.mu.RUnlock()

 return al.tb.Allow()
}

// adjustRate è°ƒæ•´é€Ÿç‡
func (al *AdaptiveLimiter) adjustRate() {
 ticker := time.NewTicker(al.adjustPeriod)
 defer ticker.Stop()

 for range ticker.C {
  cpuPercent := getCPUUsage()

  al.mu.Lock()

  if cpuPercent > al.targetCPU {
   // CPUä½¿ç”¨ç‡é«˜ï¼Œé™ä½é€Ÿç‡
   al.currentRate *= 0.9
   if al.currentRate < al.minRate {
    al.currentRate = al.minRate
   }
  } else if cpuPercent < al.targetCPU*0.8 {
   // CPUä½¿ç”¨ç‡ä½ï¼Œæé«˜é€Ÿç‡
   al.currentRate *= 1.1
   if al.currentRate > al.maxRate {
    al.currentRate = al.maxRate
   }
  }

  // æ›´æ–°ä»¤ç‰Œæ¡¶é€Ÿç‡
  al.tb = ratelimit.NewTokenBucket(al.currentRate, al.currentRate)

  al.mu.Unlock()
 }
}

// getCPUUsage è·å–CPUä½¿ç”¨ç‡
func getCPUUsage() float64 {
 var m runtime.MemStats
 runtime.ReadMemStats(&m)

 // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥ä½¿ç”¨æ›´å‡†ç¡®çš„CPUç›‘æ§
 return float64(runtime.NumGoroutine()) / float64(runtime.NumCPU()) * 10
}

// CurrentRate è·å–å½“å‰é€Ÿç‡
func (al *AdaptiveLimiter) CurrentRate() float64 {
 al.mu.RLock()
 defer al.mu.RUnlock()

 return al.currentRate
}
```

---

### 6.2 åŠ¨æ€è°ƒæ•´

```go
// DynamicLimiter åŠ¨æ€é™æµå™¨
type DynamicLimiter struct {
 rates       map[string]float64 // ä¸åŒçº§åˆ«çš„é€Ÿç‡
 currentTier string

 mu sync.RWMutex
 tb *ratelimit.TokenBucket
}

// NewDynamicLimiter åˆ›å»ºåŠ¨æ€é™æµå™¨
func NewDynamicLimiter(rates map[string]float64, initialTier string) *DynamicLimiter {
 rate := rates[initialTier]

 return &DynamicLimiter{
  rates:       rates,
  currentTier: initialTier,
  tb:          ratelimit.NewTokenBucket(rate, rate),
 }
}

// Allow å°è¯•é€šè¿‡
func (dl *DynamicLimiter) Allow() bool {
 dl.mu.RLock()
 defer dl.mu.RUnlock()

 return dl.tb.Allow()
}

// SetTier è®¾ç½®çº§åˆ«
func (dl *DynamicLimiter) SetTier(tier string) {
 dl.mu.Lock()
 defer dl.mu.Unlock()

 rate, ok := dl.rates[tier]
 if !ok {
  return
 }

 dl.currentTier = tier
 dl.tb = ratelimit.NewTokenBucket(rate, rate)
}

// CurrentTier è·å–å½“å‰çº§åˆ«
func (dl *DynamicLimiter) CurrentTier() string {
 dl.mu.RLock()
 defer dl.mu.RUnlock()

 return dl.currentTier
}
```

---

## 7. æµé‡æ•´å½¢

### 7.1 ä¼˜å…ˆçº§é˜Ÿåˆ—

```go
package trafficshaping

import (
 "container/heap"
 "sync"
 "time"
)

// Request è¯·æ±‚
type Request struct {
 ID        string
 Priority  int
 Timestamp time.Time
 Handler   func()
 index     int
}

// PriorityQueue ä¼˜å…ˆçº§é˜Ÿåˆ—
type PriorityQueue []*Request

func (pq PriorityQueue) Len() int { return len(pq) }

func (pq PriorityQueue) Less(i, j int) bool {
 // ä¼˜å…ˆçº§é«˜çš„åœ¨å‰
 if pq[i].Priority != pq[j].Priority {
  return pq[i].Priority > pq[j].Priority
 }
 // ä¼˜å…ˆçº§ç›¸åŒï¼Œæ—¶é—´æ—©çš„åœ¨å‰
 return pq[i].Timestamp.Before(pq[j].Timestamp)
}

func (pq PriorityQueue) Swap(i, j int) {
 pq[i], pq[j] = pq[j], pq[i]
 pq[i].index = i
 pq[j].index = j
}

func (pq *PriorityQueue) Push(x interface{}) {
 n := len(*pq)
 item := x.(*Request)
 item.index = n
 *pq = append(*pq, item)
}

func (pq *PriorityQueue) Pop() interface{} {
 old := *pq
 n := len(old)
 item := old[n-1]
 old[n-1] = nil
 item.index = -1
 *pq = old[0 : n-1]
 return item
}

// TrafficShaper æµé‡æ•´å½¢å™¨
type TrafficShaper struct {
 concurrency int
 queue       PriorityQueue
 mu          sync.Mutex
 cond        *sync.Cond
 active      int
 closed      bool
}

// NewTrafficShaper åˆ›å»ºæµé‡æ•´å½¢å™¨
func NewTrafficShaper(concurrency int) *TrafficShaper {
 ts := &TrafficShaper{
  concurrency: concurrency,
  queue:       make(PriorityQueue, 0),
 }
 ts.cond = sync.NewCond(&ts.mu)

 heap.Init(&ts.queue)

 go ts.process()

 return ts
}

// Submit æäº¤è¯·æ±‚
func (ts *TrafficShaper) Submit(req *Request) {
 ts.mu.Lock()
 defer ts.mu.Unlock()

 heap.Push(&ts.queue, req)
 ts.cond.Signal()
}

// process å¤„ç†è¯·æ±‚
func (ts *TrafficShaper) process() {
 for {
  ts.mu.Lock()

  // ç­‰å¾…è¯·æ±‚æˆ–æ§½ä½
  for len(ts.queue) == 0 || ts.active >= ts.concurrency {
   if ts.closed {
    ts.mu.Unlock()
    return
   }
   ts.cond.Wait()
  }

  // è·å–è¯·æ±‚
  req := heap.Pop(&ts.queue).(*Request)
  ts.active++
  ts.mu.Unlock()

  // æ‰§è¡Œè¯·æ±‚
  go func(r *Request) {
   defer func() {
    ts.mu.Lock()
    ts.active--
    ts.cond.Signal()
    ts.mu.Unlock()
   }()

   r.Handler()
  }(req)
 }
}

// Close å…³é—­
func (ts *TrafficShaper) Close() {
 ts.mu.Lock()
 defer ts.mu.Unlock()

 ts.closed = true
 ts.cond.Broadcast()
}
```

---

### 7.2 æµé‡è°ƒåº¦

```go
// Scheduler æµé‡è°ƒåº¦å™¨
type Scheduler struct {
 shapers map[string]*TrafficShaper
 mu      sync.RWMutex
}

// NewScheduler åˆ›å»ºè°ƒåº¦å™¨
func NewScheduler() *Scheduler {
 return &Scheduler{
  shapers: make(map[string]*TrafficShaper),
 }
}

// RegisterShaper æ³¨å†Œæ•´å½¢å™¨
func (s *Scheduler) RegisterShaper(name string, concurrency int) {
 s.mu.Lock()
 defer s.mu.Unlock()

 s.shapers[name] = NewTrafficShaper(concurrency)
}

// Submit æäº¤è¯·æ±‚
func (s *Scheduler) Submit(shaper string, req *Request) error {
 s.mu.RLock()
 ts, ok := s.shapers[shaper]
 s.mu.RUnlock()

 if !ok {
  return errors.New("shaper not found")
 }

 ts.Submit(req)
 return nil
}
```

---

## 8. å®Œæ•´æ¡ˆä¾‹

### 8.1 å¤šçº§é™æµç³»ç»Ÿ

```go
package main

import (
 "context"
 "log"
 "net/http"
 "time"
)

// MultiLevelRateLimiter å¤šçº§é™æµç³»ç»Ÿ
type MultiLevelRateLimiter struct {
 // å…¨å±€é™æµ
 global *ratelimit.TokenBucket

 // IPé™æµ
 perIP *sync.Map

 // ç”¨æˆ·é™æµ
 perUser *sync.Map

 // Redisåˆ†å¸ƒå¼é™æµ
 redis *ratelimit.RedisRateLimiter

 // ç†”æ–­å™¨
 breaker *circuitbreaker.CircuitBreaker

 // è‡ªé€‚åº”é™æµ
 adaptive *adaptive.AdaptiveLimiter
}

// NewMultiLevelRateLimiter åˆ›å»ºå¤šçº§é™æµç³»ç»Ÿ
func NewMultiLevelRateLimiter(redisClient *redis.Client) *MultiLevelRateLimiter {
 return &MultiLevelRateLimiter{
  global:   ratelimit.NewTokenBucket(10000, 10000), // å…¨å±€10000 QPS
  perIP:    &sync.Map{},
  perUser:  &sync.Map{},
  redis:    ratelimit.NewRedisRateLimiter(redisClient, "global", 50000, time.Minute),
  breaker:  circuitbreaker.NewCircuitBreaker(circuitbreaker.Settings{
   MaxRequests: 100,
   Interval:    time.Minute,
   Timeout:     time.Minute,
  }),
  adaptive: adaptive.NewAdaptiveLimiter(1000, 10000, 70.0), // ç›®æ ‡CPU 70%
 }
}

// Middleware é™æµä¸­é—´ä»¶
func (mlrl *MultiLevelRateLimiter) Middleware(next http.Handler) http.Handler {
 return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()

  // 1. æ£€æŸ¥å…¨å±€é™æµ
  if !mlrl.global.Allow() {
   http.Error(w, "Global rate limit exceeded", http.StatusTooManyRequests)
   return
  }

  // 2. æ£€æŸ¥åˆ†å¸ƒå¼é™æµ
  allowed, err := mlrl.redis.Allow(ctx)
  if err != nil || !allowed {
   http.Error(w, "Distributed rate limit exceeded", http.StatusTooManyRequests)
   return
  }

  // 3. æ£€æŸ¥IPé™æµ
  ip := getClientIP(r)
  ipLimiter, _ := mlrl.perIP.LoadOrStore(ip, ratelimit.NewTokenBucket(100, 100))
  if !ipLimiter.(*ratelimit.TokenBucket).Allow() {
   http.Error(w, "IP rate limit exceeded", http.StatusTooManyRequests)
   return
  }

  // 4. æ£€æŸ¥ç”¨æˆ·é™æµ
  userID := getUserID(r)
  if userID != "" {
   userLimiter, _ := mlrl.perUser.LoadOrStore(userID, ratelimit.NewTokenBucket(1000, 1000))
   if !userLimiter.(*ratelimit.TokenBucket).Allow() {
    http.Error(w, "User rate limit exceeded", http.StatusTooManyRequests)
    return
   }
  }

  // 5. æ£€æŸ¥è‡ªé€‚åº”é™æµ
  if !mlrl.adaptive.Allow() {
   http.Error(w, "System overload", http.StatusServiceUnavailable)
   return
  }

  // 6. ç†”æ–­æ£€æŸ¥
  _, err = mlrl.breaker.Execute(func() (interface{}, error) {
   recorder := &statusRecorder{
    ResponseWriter: w,
    statusCode:     http.StatusOK,
   }

   next.ServeHTTP(recorder, r)

   if recorder.statusCode >= 500 {
    return nil, errors.New("server error")
   }

   return nil, nil
  })

  if err != nil {
   http.Error(w, "Service unavailable", http.StatusServiceUnavailable)
   return
  }
 })
}

func main() {
 // 1. åˆ›å»ºRediså®¢æˆ·ç«¯
 redisClient := redis.NewClient(&redis.Options{
  Addr: "localhost:6379",
 })

 // 2. åˆ›å»ºå¤šçº§é™æµç³»ç»Ÿ
 limiter := NewMultiLevelRateLimiter(redisClient)

 // 3. åˆ›å»ºHTTPæœåŠ¡å™¨
 mux := http.NewServeMux()

 mux.HandleFunc("/api/users", func(w http.ResponseWriter, r *http.Request) {
  w.WriteHeader(http.StatusOK)
  w.Write([]byte(`{"status":"ok"}`))
 })

 // åº”ç”¨é™æµä¸­é—´ä»¶
 handler := limiter.Middleware(mux)

 // 4. å¯åŠ¨æœåŠ¡å™¨
 server := &http.Server{
  Addr:    ":8080",
  Handler: handler,
 }

 log.Println("Server starting on :8080")
 log.Fatal(server.ListenAndServe())
}

func getUserID(r *http.Request) string {
 // ä»è¯·æ±‚ä¸­è·å–ç”¨æˆ·IDï¼ˆä¾‹å¦‚ä»JWTä¸­ï¼‰
 // ç®€åŒ–å®ç°
 return r.Header.Get("X-User-ID")
}

type statusRecorder struct {
 http.ResponseWriter
 statusCode int
}

func (sr *statusRecorder) WriteHeader(code int) {
 sr.statusCode = code
 sr.ResponseWriter.WriteHeader(code)
}
```

---

## ğŸ“š é™æµæœ€ä½³å®è·µ

### ç®—æ³•é€‰æ‹©

- âœ… **ä»¤ç‰Œæ¡¶**: å…è®¸çªå‘æµé‡ï¼Œé€‚åˆAPIç½‘å…³
- âœ… **æ¼æ¡¶**: å¹³æ»‘è¾“å‡ºï¼Œé€‚åˆæ¶ˆæ¯é˜Ÿåˆ—
- âœ… **æ»‘åŠ¨çª—å£**: ç²¾ç¡®é™æµï¼Œé€‚åˆé«˜ç²¾åº¦åœºæ™¯
- âœ… **åˆ†å¸ƒå¼é™æµ**: é›†ç¾¤ç¯å¢ƒå¿…å¤‡

### é™æµç­–ç•¥

- âœ… å…¨å±€é™æµ + IPé™æµ + ç”¨æˆ·é™æµ
- âœ… åŒºåˆ†è¯»å†™æ“ä½œ
- âœ… ä¸åŒæ¥å£ä¸åŒé™åˆ¶
- âœ… VIPç”¨æˆ·ç‰¹æ®Šå¯¹å¾…

### ç†”æ–­ç­–ç•¥

- âœ… é”™è¯¯ç‡é˜ˆå€¼
- âœ… å“åº”æ—¶é—´é˜ˆå€¼
- âœ… åŠå¼€çŠ¶æ€å°è¯•
- âœ… é™çº§æ–¹æ¡ˆ

### ç›‘æ§å‘Šè­¦

- âœ… é™æµè§¦å‘ç‡
- âœ… ç†”æ–­å™¨çŠ¶æ€
- âœ… ç³»ç»Ÿè´Ÿè½½
- âœ… å“åº”æ—¶é—´

---

## ğŸ¯ æ€»ç»“

Go 1.25.3æµé‡æ§åˆ¶å…³é”®ç‚¹ï¼š

1. **ä»¤ç‰Œæ¡¶**: å…è®¸çªå‘ã€å¹³æ»‘é™æµ
2. **æ¼æ¡¶**: å¹³æ»‘è¾“å‡ºã€é˜Ÿåˆ—å¤„ç†
3. **æ»‘åŠ¨çª—å£**: ç²¾ç¡®é™æµã€å®æ—¶ç»Ÿè®¡
4. **åˆ†å¸ƒå¼é™æµ**: Redisã€Luaè„šæœ¬ã€åŸå­æ€§
5. **ç†”æ–­é™çº§**: çŠ¶æ€æœºã€è‡ªåŠ¨æ¢å¤ã€é™çº§ç­–ç•¥
6. **è‡ªé€‚åº”é™æµ**: åŠ¨æ€è°ƒæ•´ã€è´Ÿè½½æ„ŸçŸ¥
7. **æµé‡æ•´å½¢**: ä¼˜å…ˆçº§é˜Ÿåˆ—ã€å¹¶å‘æ§åˆ¶

**æµé‡æ§åˆ¶æ˜¯é«˜å¯ç”¨ç³»ç»Ÿçš„ç¬¬ä¸€é“é˜²çº¿ï¼**

---

<div align="center">

**æ„å»ºç¨³å®šå¯é çš„GoæœåŠ¡**:

[ğŸ“š è¿”å›ç›®å½•](../README.md) | [ğŸ“– ä¸‹ä¸€ç« ](25-APIç½‘å…³å®Œæ•´å®æˆ˜.md)

Made with â¤ï¸ for Go Developers

</div>

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2025-10-29
**Goç‰ˆæœ¬**: Go 1.25.3
**ç”Ÿäº§å°±ç»ª**: âœ…
