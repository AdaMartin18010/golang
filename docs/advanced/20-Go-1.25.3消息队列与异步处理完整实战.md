# Go 1.25.3 消息队列与异步处理完整实战

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---


## 📋 目录


- [📖 文档说明](#文档说明)
- [目录](#目录)
- [1. RabbitMQ实战](#1.-rabbitmq实战)
  - [1.1 基础连接与配置](#11-基础连接与配置)
  - [1.2 生产者实现](#12-生产者实现)
  - [1.3 消费者实现](#13-消费者实现)
  - [1.4 延迟队列实现](#14-延迟队列实现)
- [2. Kafka流处理](#2.-kafka流处理)
  - [2.1 Kafka生产者](#21-kafka生产者)
  - [2.2 Kafka消费者组](#22-kafka消费者组)
- [3. Redis Stream](#3.-redis-stream)
  - [3.1 Redis Stream生产者](#31-redis-stream生产者)
  - [3.2 Redis Stream消费者组](#32-redis-stream消费者组)
- [4. 异步任务处理](#4.-异步任务处理)
  - [4.1 Asynq任务队列](#41-asynq任务队列)
  - [4.2 任务处理器](#42-任务处理器)
- [5. 事件驱动架构](#5.-事件驱动架构)
  - [5.1 事件总线](#51-事件总线)
  - [5.2 具体事件实现](#52-具体事件实现)
- [6. 消息可靠性](#6.-消息可靠性)
  - [6.1 重试机制](#61-重试机制)
  - [6.2 幂等性保证](#62-幂等性保证)
- [7. 分布式事务](#7.-分布式事务)
  - [7.1 Saga模式](#71-saga模式)
- [8. 完整案例](#8.-完整案例)
  - [8.1 电商订单处理系统](#81-电商订单处理系统)
- [📚 消息队列最佳实践](#消息队列最佳实践)
  - [技术选型](#技术选型)
  - [可靠性保证](#可靠性保证)
  - [性能优化](#性能优化)
- [🎯 总结](#总结)

## 📖 文档说明

本文档展示Go 1.25.3的**消息队列与异步处理完整方案**，构建高可用分布式系统：

- ✅ RabbitMQ深度实战
- ✅ Kafka流处理
- ✅ Redis Stream实战
- ✅ 异步任务处理
- ✅ 事件驱动架构
- ✅ 消息可靠性保证
- ✅ 分布式事务

---

## 目录

- [Go 1.25.3 消息队列与异步处理完整实战](#go-1.25.3-消息队列与异步处理完整实战)
  - [📖 文档说明](#文档说明)
  - [目录](#目录)
  - [1. RabbitMQ实战](#1.-rabbitmq实战)
    - [1.1 基础连接与配置](#11-基础连接与配置)
    - [1.2 生产者实现](#12-生产者实现)
    - [1.3 消费者实现](#13-消费者实现)
    - [1.4 延迟队列实现](#14-延迟队列实现)
  - [2. Kafka流处理](#2.-kafka流处理)
    - [2.1 Kafka生产者](#21-kafka生产者)
    - [2.2 Kafka消费者组](#22-kafka消费者组)
  - [3. Redis Stream](#3.-redis-stream)
    - [3.1 Redis Stream生产者](#31-redis-stream生产者)
    - [3.2 Redis Stream消费者组](#32-redis-stream消费者组)
  - [4. 异步任务处理](#4.-异步任务处理)
    - [4.1 Asynq任务队列](#41-asynq任务队列)
    - [4.2 任务处理器](#42-任务处理器)
  - [5. 事件驱动架构](#5.-事件驱动架构)
    - [5.1 事件总线](#51-事件总线)
    - [5.2 具体事件实现](#52-具体事件实现)
  - [6. 消息可靠性](#6.-消息可靠性)
    - [6.1 重试机制](#61-重试机制)
    - [6.2 幂等性保证](#62-幂等性保证)
  - [7. 分布式事务](#7.-分布式事务)
    - [7.1 Saga模式](#71-saga模式)
  - [8. 完整案例](#8.-完整案例)
    - [8.1 电商订单处理系统](#81-电商订单处理系统)
  - [📚 消息队列最佳实践](#消息队列最佳实践)
    - [技术选型](#技术选型)
    - [可靠性保证](#可靠性保证)
    - [性能优化](#性能优化)
  - [🎯 总结](#总结)

---

## 1. RabbitMQ实战

### 1.1 基础连接与配置

```go
package rabbitmq

import (
 "context"
 "fmt"
 "time"
 
 amqp "github.com/rabbitmq/amqp091-go"
)

// RabbitMQ 客户端
type RabbitMQ struct {
 conn    *amqp.Connection
 channel *amqp.Channel
 config  *Config
}

// Config 配置
type Config struct {
 URL          string
 Exchange     string
 ExchangeType string
 Queue        string
 RoutingKey   string
 Durable      bool
 AutoAck      bool
 Prefetch     int
}

// NewRabbitMQ 创建RabbitMQ客户端
func NewRabbitMQ(config *Config) (*RabbitMQ, error) {
 // 连接RabbitMQ
 conn, err := amqp.Dial(config.URL)
 if err != nil {
  return nil, fmt.Errorf("failed to connect: %w", err)
 }
 
 // 创建channel
 ch, err := conn.Channel()
 if err != nil {
  conn.Close()
  return nil, fmt.Errorf("failed to open channel: %w", err)
 }
 
 // 设置QoS
 if err := ch.Qos(config.Prefetch, 0, false); err != nil {
  ch.Close()
  conn.Close()
  return nil, fmt.Errorf("failed to set QoS: %w", err)
 }
 
 // 声明exchange
 if config.Exchange != "" {
  err = ch.ExchangeDeclare(
   config.Exchange,     // name
   config.ExchangeType, // type
   config.Durable,      // durable
   false,               // auto-deleted
   false,               // internal
   false,               // no-wait
   nil,                 // arguments
  )
  if err != nil {
   ch.Close()
   conn.Close()
   return nil, fmt.Errorf("failed to declare exchange: %w", err)
  }
 }
 
 // 声明队列
 if config.Queue != "" {
  _, err = ch.QueueDeclare(
   config.Queue,    // name
   config.Durable,  // durable
   false,           // delete when unused
   false,           // exclusive
   false,           // no-wait
   nil,             // arguments
  )
  if err != nil {
   ch.Close()
   conn.Close()
   return nil, fmt.Errorf("failed to declare queue: %w", err)
  }
  
  // 绑定队列到exchange
  if config.Exchange != "" {
   err = ch.QueueBind(
    config.Queue,      // queue name
    config.RoutingKey, // routing key
    config.Exchange,   // exchange
    false,
    nil,
   )
   if err != nil {
    ch.Close()
    conn.Close()
    return nil, fmt.Errorf("failed to bind queue: %w", err)
   }
  }
 }
 
 return &RabbitMQ{
  conn:    conn,
  channel: ch,
  config:  config,
 }, nil
}

// Close 关闭连接
func (r *RabbitMQ) Close() error {
 if r.channel != nil {
  r.channel.Close()
 }
 if r.conn != nil {
  return r.conn.Close()
 }
 return nil
}
```

---

### 1.2 生产者实现

```go
// Producer 生产者
type Producer struct {
 mq *RabbitMQ
}

// NewProducer 创建生产者
func NewProducer(config *Config) (*Producer, error) {
 mq, err := NewRabbitMQ(config)
 if err != nil {
  return nil, err
 }
 
 return &Producer{mq: mq}, nil
}

// Publish 发布消息
func (p *Producer) Publish(ctx context.Context, body []byte) error {
 return p.mq.channel.PublishWithContext(
  ctx,
  p.mq.config.Exchange,    // exchange
  p.mq.config.RoutingKey,  // routing key
  false,                    // mandatory
  false,                    // immediate
  amqp.Publishing{
   ContentType:  "application/json",
   Body:         body,
   DeliveryMode: amqp.Persistent, // 持久化
   Timestamp:    time.Now(),
  },
 )
}

// PublishWithConfirm 带确认的发布
func (p *Producer) PublishWithConfirm(ctx context.Context, body []byte) error {
 // 开启确认模式
 if err := p.mq.channel.Confirm(false); err != nil {
  return fmt.Errorf("failed to enable confirm mode: %w", err)
 }
 
 // 注册确认监听
 confirms := p.mq.channel.NotifyPublish(make(chan amqp.Confirmation, 1))
 
 // 发布消息
 if err := p.Publish(ctx, body); err != nil {
  return err
 }
 
 // 等待确认
 select {
 case confirm := <-confirms:
  if !confirm.Ack {
   return fmt.Errorf("message not confirmed")
  }
  return nil
 case <-ctx.Done():
  return ctx.Err()
 }
}
```

---

### 1.3 消费者实现

```go
// Consumer 消费者
type Consumer struct {
 mq      *RabbitMQ
 handler MessageHandler
}

// MessageHandler 消息处理函数
type MessageHandler func(ctx context.Context, body []byte) error

// NewConsumer 创建消费者
func NewConsumer(config *Config, handler MessageHandler) (*Consumer, error) {
 mq, err := NewRabbitMQ(config)
 if err != nil {
  return nil, err
 }
 
 return &Consumer{
  mq:      mq,
  handler: handler,
 }, nil
}

// Start 开始消费
func (c *Consumer) Start(ctx context.Context) error {
 // 开始消费
 msgs, err := c.mq.channel.Consume(
  c.mq.config.Queue,   // queue
  "",                  // consumer
  c.mq.config.AutoAck, // auto-ack
  false,               // exclusive
  false,               // no-local
  false,               // no-wait
  nil,                 // args
 )
 if err != nil {
  return fmt.Errorf("failed to register consumer: %w", err)
 }
 
 // 处理消息
 for {
  select {
  case msg, ok := <-msgs:
   if !ok {
    return nil
   }
   
   // 处理消息
   if err := c.handler(ctx, msg.Body); err != nil {
    log.Printf("Failed to handle message: %v", err)
    
    // 拒绝消息并重新入队
    if !c.mq.config.AutoAck {
     msg.Nack(false, true)
    }
    continue
   }
   
   // 确认消息
   if !c.mq.config.AutoAck {
    msg.Ack(false)
   }
   
  case <-ctx.Done():
   return ctx.Err()
  }
 }
}
```

---

### 1.4 延迟队列实现

```go
// DelayQueue 延迟队列
type DelayQueue struct {
 mq *RabbitMQ
}

// NewDelayQueue 创建延迟队列
func NewDelayQueue(config *Config) (*DelayQueue, error) {
 mq, err := NewRabbitMQ(config)
 if err != nil {
  return nil, err
 }
 
 // 声明死信exchange
 err = mq.channel.ExchangeDeclare(
  "dlx.exchange",
  "direct",
  true,
  false,
  false,
  false,
  nil,
 )
 if err != nil {
  return nil, err
 }
 
 // 声明延迟队列（带死信配置）
 _, err = mq.channel.QueueDeclare(
  "delay.queue",
  true,
  false,
  false,
  false,
  amqp.Table{
   "x-dead-letter-exchange":    "dlx.exchange",
   "x-dead-letter-routing-key": "delay.route",
  },
 )
 if err != nil {
  return nil, err
 }
 
 // 声明实际工作队列
 _, err = mq.channel.QueueDeclare(
  "work.queue",
  true,
  false,
  false,
  false,
  nil,
 )
 if err != nil {
  return nil, err
 }
 
 // 绑定工作队列到死信exchange
 err = mq.channel.QueueBind(
  "work.queue",
  "delay.route",
  "dlx.exchange",
  false,
  nil,
 )
 if err != nil {
  return nil, err
 }
 
 return &DelayQueue{mq: mq}, nil
}

// PublishDelay 发布延迟消息
func (d *DelayQueue) PublishDelay(ctx context.Context, body []byte, delay time.Duration) error {
 return d.mq.channel.PublishWithContext(
  ctx,
  "",              // exchange
  "delay.queue",   // routing key
  false,
  false,
  amqp.Publishing{
   ContentType:  "application/json",
   Body:         body,
   DeliveryMode: amqp.Persistent,
   Expiration:   fmt.Sprintf("%d", delay.Milliseconds()),
  },
 )
}
```

---

## 2. Kafka流处理

### 2.1 Kafka生产者

```go
package kafka

import (
 "context"
 "fmt"
 
 "github.com/IBM/sarama"
)

// Producer Kafka生产者
type Producer struct {
 producer sarama.SyncProducer
 config   *sarama.Config
}

// NewProducer 创建生产者
func NewProducer(brokers []string) (*Producer, error) {
 config := sarama.NewConfig()
 config.Producer.RequiredAcks = sarama.WaitForAll
 config.Producer.Retry.Max = 5
 config.Producer.Return.Successes = true
 config.Producer.Partitioner = sarama.NewHashPartitioner
 
 producer, err := sarama.NewSyncProducer(brokers, config)
 if err != nil {
  return nil, fmt.Errorf("failed to create producer: %w", err)
 }
 
 return &Producer{
  producer: producer,
  config:   config,
 }, nil
}

// Send 发送消息
func (p *Producer) Send(topic string, key, value []byte) (partition int32, offset int64, err error) {
 msg := &sarama.ProducerMessage{
  Topic: topic,
  Key:   sarama.ByteEncoder(key),
  Value: sarama.ByteEncoder(value),
 }
 
 return p.producer.SendMessage(msg)
}

// SendBatch 批量发送
func (p *Producer) SendBatch(topic string, messages [][]byte) error {
 msgs := make([]*sarama.ProducerMessage, len(messages))
 
 for i, msg := range messages {
  msgs[i] = &sarama.ProducerMessage{
   Topic: topic,
   Value: sarama.ByteEncoder(msg),
  }
 }
 
 return p.producer.SendMessages(msgs)
}

// Close 关闭生产者
func (p *Producer) Close() error {
 return p.producer.Close()
}
```

---

### 2.2 Kafka消费者组

```go
// ConsumerGroup Kafka消费者组
type ConsumerGroup struct {
 group   sarama.ConsumerGroup
 handler ConsumerGroupHandler
}

// ConsumerGroupHandler 消费者组处理器
type ConsumerGroupHandler struct {
 handler func(ctx context.Context, message *sarama.ConsumerMessage) error
}

// Setup 初始化
func (h ConsumerGroupHandler) Setup(sarama.ConsumerGroupSession) error {
 return nil
}

// Cleanup 清理
func (h ConsumerGroupHandler) Cleanup(sarama.ConsumerGroupSession) error {
 return nil
}

// ConsumeClaim 消费
func (h ConsumerGroupHandler) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
 for message := range claim.Messages() {
  ctx := session.Context()
  
  // 处理消息
  if err := h.handler(ctx, message); err != nil {
   log.Printf("Failed to handle message: %v", err)
   continue
  }
  
  // 标记消息已处理
  session.MarkMessage(message, "")
 }
 
 return nil
}

// NewConsumerGroup 创建消费者组
func NewConsumerGroup(brokers []string, groupID string, topics []string, handler func(context.Context, *sarama.ConsumerMessage) error) (*ConsumerGroup, error) {
 config := sarama.NewConfig()
 config.Consumer.Group.Rebalance.Strategy = sarama.NewBalanceStrategyRoundRobin()
 config.Consumer.Offsets.Initial = sarama.OffsetNewest
 
 group, err := sarama.NewConsumerGroup(brokers, groupID, config)
 if err != nil {
  return nil, fmt.Errorf("failed to create consumer group: %w", err)
 }
 
 return &ConsumerGroup{
  group: group,
  handler: ConsumerGroupHandler{
   handler: handler,
  },
 }, nil
}

// Start 开始消费
func (c *ConsumerGroup) Start(ctx context.Context, topics []string) error {
 for {
  if err := c.group.Consume(ctx, topics, c.handler); err != nil {
   return fmt.Errorf("consumer error: %w", err)
  }
  
  if ctx.Err() != nil {
   return ctx.Err()
  }
 }
}

// Close 关闭消费者组
func (c *ConsumerGroup) Close() error {
 return c.group.Close()
}
```

---

## 3. Redis Stream

### 3.1 Redis Stream生产者

```go
package redisstream

import (
 "context"
 "fmt"
 
 "github.com/redis/go-redis/v9"
)

// Producer Redis Stream生产者
type Producer struct {
 client *redis.Client
 stream string
}

// NewProducer 创建生产者
func NewProducer(client *redis.Client, stream string) *Producer {
 return &Producer{
  client: client,
  stream: stream,
 }
}

// Send 发送消息
func (p *Producer) Send(ctx context.Context, values map[string]interface{}) (string, error) {
 id, err := p.client.XAdd(ctx, &redis.XAddArgs{
  Stream: p.stream,
  Values: values,
 }).Result()
 
 if err != nil {
  return "", fmt.Errorf("failed to send message: %w", err)
 }
 
 return id, nil
}

// SendWithMaxLen 发送消息（限制长度）
func (p *Producer) SendWithMaxLen(ctx context.Context, values map[string]interface{}, maxLen int64) (string, error) {
 id, err := p.client.XAdd(ctx, &redis.XAddArgs{
  Stream: p.stream,
  MaxLen: maxLen,
  Approx: true,
  Values: values,
 }).Result()
 
 if err != nil {
  return "", fmt.Errorf("failed to send message: %w", err)
 }
 
 return id, nil
}
```

---

### 3.2 Redis Stream消费者组

```go
// ConsumerGroup Redis Stream消费者组
type ConsumerGroup struct {
 client   *redis.Client
 stream   string
 group    string
 consumer string
 handler  func(context.Context, redis.XMessage) error
}

// NewConsumerGroup 创建消费者组
func NewConsumerGroup(client *redis.Client, stream, group, consumer string, handler func(context.Context, redis.XMessage) error) (*ConsumerGroup, error) {
 // 创建消费者组（如果不存在）
 err := client.XGroupCreateMkStream(context.Background(), stream, group, "0").Err()
 if err != nil && err.Error() != "BUSYGROUP Consumer Group name already exists" {
  return nil, fmt.Errorf("failed to create consumer group: %w", err)
 }
 
 return &ConsumerGroup{
  client:   client,
  stream:   stream,
  group:    group,
  consumer: consumer,
  handler:  handler,
 }, nil
}

// Start 开始消费
func (c *ConsumerGroup) Start(ctx context.Context) error {
 for {
  // 读取消息
  streams, err := c.client.XReadGroup(ctx, &redis.XReadGroupArgs{
   Group:    c.group,
   Consumer: c.consumer,
   Streams:  []string{c.stream, ">"},
   Count:    10,
   Block:    0,
  }).Result()
  
  if err != nil {
   if err == redis.Nil {
    continue
   }
   return fmt.Errorf("failed to read messages: %w", err)
  }
  
  // 处理消息
  for _, stream := range streams {
   for _, message := range stream.Messages {
    if err := c.handler(ctx, message); err != nil {
     log.Printf("Failed to handle message: %v", err)
     continue
    }
    
    // 确认消息
    c.client.XAck(ctx, c.stream, c.group, message.ID)
   }
  }
  
  if ctx.Err() != nil {
   return ctx.Err()
  }
 }
}

// GetPending 获取待处理消息
func (c *ConsumerGroup) GetPending(ctx context.Context) ([]redis.XPendingExt, error) {
 pending, err := c.client.XPendingExt(ctx, &redis.XPendingExtArgs{
  Stream: c.stream,
  Group:  c.group,
  Start:  "-",
  End:    "+",
  Count:  100,
 }).Result()
 
 if err != nil {
  return nil, err
 }
 
 return pending, nil
}

// Claim 认领超时消息
func (c *ConsumerGroup) Claim(ctx context.Context, minIdleTime time.Duration) error {
 pending, err := c.GetPending(ctx)
 if err != nil {
  return err
 }
 
 for _, p := range pending {
  if p.Idle < minIdleTime {
   continue
  }
  
  // 认领消息
  messages, err := c.client.XClaim(ctx, &redis.XClaimArgs{
   Stream:   c.stream,
   Group:    c.group,
   Consumer: c.consumer,
   MinIdle:  minIdleTime,
   Messages: []string{p.ID},
  }).Result()
  
  if err != nil {
   log.Printf("Failed to claim message: %v", err)
   continue
  }
  
  // 处理认领的消息
  for _, msg := range messages {
   if err := c.handler(ctx, msg); err != nil {
    log.Printf("Failed to handle claimed message: %v", err)
    continue
   }
   
   c.client.XAck(ctx, c.stream, c.group, msg.ID)
  }
 }
 
 return nil
}
```

---

## 4. 异步任务处理

### 4.1 Asynq任务队列

```go
package async

import (
 "context"
 "encoding/json"
 "fmt"
 "time"
 
 "github.com/hibiken/asynq"
)

// TaskType 任务类型
const (
 TypeEmailDelivery   = "email:deliver"
 TypeImageResize     = "image:resize"
 TypeDataBackup      = "data:backup"
)

// EmailDeliveryPayload 邮件发送任务载荷
type EmailDeliveryPayload struct {
 To      string `json:"to"`
 Subject string `json:"subject"`
 Body    string `json:"body"`
}

// TaskClient 任务客户端
type TaskClient struct {
 client *asynq.Client
}

// NewTaskClient 创建任务客户端
func NewTaskClient(redisAddr string) *TaskClient {
 client := asynq.NewClient(asynq.RedisClientOpt{
  Addr: redisAddr,
 })
 
 return &TaskClient{client: client}
}

// EnqueueEmailDelivery 入队邮件发送任务
func (c *TaskClient) EnqueueEmailDelivery(payload *EmailDeliveryPayload) error {
 data, err := json.Marshal(payload)
 if err != nil {
  return err
 }
 
 task := asynq.NewTask(TypeEmailDelivery, data)
 
 info, err := c.client.Enqueue(task,
  asynq.MaxRetry(3),
  asynq.Timeout(5*time.Minute),
 )
 
 if err != nil {
  return fmt.Errorf("failed to enqueue task: %w", err)
 }
 
 log.Printf("Enqueued task: id=%s queue=%s", info.ID, info.Queue)
 return nil
}

// EnqueueScheduled 入队定时任务
func (c *TaskClient) EnqueueScheduled(taskType string, payload []byte, processAt time.Time) error {
 task := asynq.NewTask(taskType, payload)
 
 info, err := c.client.Enqueue(task,
  asynq.ProcessAt(processAt),
 )
 
 if err != nil {
  return fmt.Errorf("failed to enqueue scheduled task: %w", err)
 }
 
 log.Printf("Enqueued scheduled task: id=%s", info.ID)
 return nil
}

// Close 关闭客户端
func (c *TaskClient) Close() error {
 return c.client.Close()
}
```

---

### 4.2 任务处理器

```go
// TaskServer 任务服务器
type TaskServer struct {
 server *asynq.Server
 mux    *asynq.ServeMux
}

// NewTaskServer 创建任务服务器
func NewTaskServer(redisAddr string) *TaskServer {
 server := asynq.NewServer(
  asynq.RedisClientOpt{Addr: redisAddr},
  asynq.Config{
   Concurrency: 10,
   Queues: map[string]int{
    "critical": 6,
    "default":  3,
    "low":      1,
   },
  },
 )
 
 mux := asynq.NewServeMux()
 
 return &TaskServer{
  server: server,
  mux:    mux,
 }
}

// HandleEmailDelivery 处理邮件发送任务
func (s *TaskServer) HandleEmailDelivery(ctx context.Context, task *asynq.Task) error {
 var payload EmailDeliveryPayload
 if err := json.Unmarshal(task.Payload(), &payload); err != nil {
  return fmt.Errorf("failed to unmarshal payload: %w", err)
 }
 
 log.Printf("Sending email to: %s", payload.To)
 
 // 发送邮件逻辑
 if err := sendEmail(payload.To, payload.Subject, payload.Body); err != nil {
  return fmt.Errorf("failed to send email: %w", err)
 }
 
 log.Printf("Email sent successfully to: %s", payload.To)
 return nil
}

// RegisterHandlers 注册处理器
func (s *TaskServer) RegisterHandlers() {
 s.mux.HandleFunc(TypeEmailDelivery, s.HandleEmailDelivery)
 // 注册其他处理器...
}

// Start 启动服务器
func (s *TaskServer) Start() error {
 s.RegisterHandlers()
 return s.server.Run(s.mux)
}

// Shutdown 关闭服务器
func (s *TaskServer) Shutdown() {
 s.server.Shutdown()
}
```

---

## 5. 事件驱动架构

### 5.1 事件总线

```go
package eventbus

import (
 "context"
 "sync"
)

// Event 事件接口
type Event interface {
 Type() string
 Data() interface{}
}

// Handler 事件处理器
type Handler func(context.Context, Event) error

// EventBus 事件总线
type EventBus struct {
 handlers map[string][]Handler
 mu       sync.RWMutex
}

// NewEventBus 创建事件总线
func NewEventBus() *EventBus {
 return &EventBus{
  handlers: make(map[string][]Handler),
 }
}

// Subscribe 订阅事件
func (eb *EventBus) Subscribe(eventType string, handler Handler) {
 eb.mu.Lock()
 defer eb.mu.Unlock()
 
 eb.handlers[eventType] = append(eb.handlers[eventType], handler)
}

// Publish 发布事件
func (eb *EventBus) Publish(ctx context.Context, event Event) error {
 eb.mu.RLock()
 handlers, ok := eb.handlers[event.Type()]
 eb.mu.RUnlock()
 
 if !ok {
  return nil
 }
 
 // 异步处理所有处理器
 var wg sync.WaitGroup
 errCh := make(chan error, len(handlers))
 
 for _, handler := range handlers {
  wg.Add(1)
  
  go func(h Handler) {
   defer wg.Done()
   
   if err := h(ctx, event); err != nil {
    errCh <- err
   }
  }(handler)
 }
 
 wg.Wait()
 close(errCh)
 
 // 收集错误
 var errors []error
 for err := range errCh {
  errors = append(errors, err)
 }
 
 if len(errors) > 0 {
  return errors[0]
 }
 
 return nil
}
```

---

### 5.2 具体事件实现

```go
// UserCreatedEvent 用户创建事件
type UserCreatedEvent struct {
 UserID   string
 Email    string
 Username string
}

func (e UserCreatedEvent) Type() string {
 return "user.created"
}

func (e UserCreatedEvent) Data() interface{} {
 return e
}

// OrderPlacedEvent 订单创建事件
type OrderPlacedEvent struct {
 OrderID  string
 UserID   string
 Amount   float64
 Products []string
}

func (e OrderPlacedEvent) Type() string {
 return "order.placed"
}

func (e OrderPlacedEvent) Data() interface{} {
 return e
}

// 使用示例
func ExampleEventBus() {
 bus := NewEventBus()
 
 // 订阅用户创建事件
 bus.Subscribe("user.created", func(ctx context.Context, event Event) error {
  e := event.Data().(UserCreatedEvent)
  log.Printf("Sending welcome email to: %s", e.Email)
  return sendWelcomeEmail(e.Email)
 })
 
 bus.Subscribe("user.created", func(ctx context.Context, event Event) error {
  e := event.Data().(UserCreatedEvent)
  log.Printf("Creating user profile for: %s", e.UserID)
  return createUserProfile(e.UserID)
 })
 
 // 发布事件
 event := UserCreatedEvent{
  UserID:   "123",
  Email:    "user@example.com",
  Username: "john",
 }
 
 bus.Publish(context.Background(), event)
}
```

---

## 6. 消息可靠性

### 6.1 重试机制

```go
package reliability

import (
 "context"
 "fmt"
 "math"
 "time"
)

// RetryPolicy 重试策略
type RetryPolicy struct {
 MaxAttempts int
 InitialDelay time.Duration
 MaxDelay     time.Duration
 Multiplier   float64
}

// DefaultRetryPolicy 默认重试策略
func DefaultRetryPolicy() *RetryPolicy {
 return &RetryPolicy{
  MaxAttempts:  3,
  InitialDelay: 1 * time.Second,
  MaxDelay:     30 * time.Second,
  Multiplier:   2.0,
 }
}

// RetryWithBackoff 带退避的重试
func RetryWithBackoff(ctx context.Context, policy *RetryPolicy, fn func() error) error {
 var lastErr error
 
 for attempt := 0; attempt < policy.MaxAttempts; attempt++ {
  // 执行函数
  if err := fn(); err == nil {
   return nil
  } else {
   lastErr = err
  }
  
  // 最后一次尝试不需要等待
  if attempt == policy.MaxAttempts-1 {
   break
  }
  
  // 计算退避时间
  delay := calculateBackoff(attempt, policy)
  
  // 等待
  select {
  case <-time.After(delay):
  case <-ctx.Done():
   return ctx.Err()
  }
 }
 
 return fmt.Errorf("max retry attempts reached: %w", lastErr)
}

// calculateBackoff 计算退避时间
func calculateBackoff(attempt int, policy *RetryPolicy) time.Duration {
 delay := float64(policy.InitialDelay) * math.Pow(policy.Multiplier, float64(attempt))
 
 if time.Duration(delay) > policy.MaxDelay {
  return policy.MaxDelay
 }
 
 return time.Duration(delay)
}
```

---

### 6.2 幂等性保证

```go
// IdempotencyManager 幂等性管理器
type IdempotencyManager struct {
 cache *redis.Client
 ttl   time.Duration
}

// NewIdempotencyManager 创建幂等性管理器
func NewIdempotencyManager(cache *redis.Client, ttl time.Duration) *IdempotencyManager {
 return &IdempotencyManager{
  cache: cache,
  ttl:   ttl,
 }
}

// IsProcessed 检查是否已处理
func (im *IdempotencyManager) IsProcessed(ctx context.Context, key string) (bool, error) {
 exists, err := im.cache.Exists(ctx, key).Result()
 if err != nil {
  return false, err
 }
 
 return exists > 0, nil
}

// MarkAsProcessed 标记为已处理
func (im *IdempotencyManager) MarkAsProcessed(ctx context.Context, key string) error {
 return im.cache.Set(ctx, key, "1", im.ttl).Err()
}

// WithIdempotency 幂等性包装器
func (im *IdempotencyManager) WithIdempotency(ctx context.Context, key string, fn func() error) error {
 // 检查是否已处理
 processed, err := im.IsProcessed(ctx, key)
 if err != nil {
  return fmt.Errorf("failed to check idempotency: %w", err)
 }
 
 if processed {
  log.Printf("Message already processed: %s", key)
  return nil
 }
 
 // 执行函数
 if err := fn(); err != nil {
  return err
 }
 
 // 标记为已处理
 if err := im.MarkAsProcessed(ctx, key); err != nil {
  return fmt.Errorf("failed to mark as processed: %w", err)
 }
 
 return nil
}
```

---

## 7. 分布式事务

### 7.1 Saga模式

```go
package saga

import (
 "context"
 "fmt"
)

// Step Saga步骤
type Step struct {
 Name        string
 Action      func(context.Context) error
 Compensate  func(context.Context) error
}

// Saga Saga协调器
type Saga struct {
 steps []Step
}

// NewSaga 创建Saga
func NewSaga() *Saga {
 return &Saga{
  steps: make([]Step, 0),
 }
}

// AddStep 添加步骤
func (s *Saga) AddStep(name string, action, compensate func(context.Context) error) *Saga {
 s.steps = append(s.steps, Step{
  Name:       name,
  Action:     action,
  Compensate: compensate,
 })
 return s
}

// Execute 执行Saga
func (s *Saga) Execute(ctx context.Context) error {
 executedSteps := make([]Step, 0)
 
 // 执行所有步骤
 for _, step := range s.steps {
  log.Printf("Executing step: %s", step.Name)
  
  if err := step.Action(ctx); err != nil {
   log.Printf("Step %s failed: %v", step.Name, err)
   
   // 补偿已执行的步骤
   if err := s.compensate(ctx, executedSteps); err != nil {
    return fmt.Errorf("compensation failed: %w", err)
   }
   
   return fmt.Errorf("saga failed at step %s: %w", step.Name, err)
  }
  
  executedSteps = append(executedSteps, step)
  log.Printf("Step %s completed", step.Name)
 }
 
 log.Println("Saga completed successfully")
 return nil
}

// compensate 补偿操作
func (s *Saga) compensate(ctx context.Context, steps []Step) error {
 log.Println("Starting compensation")
 
 // 逆序补偿
 for i := len(steps) - 1; i >= 0; i-- {
  step := steps[i]
  log.Printf("Compensating step: %s", step.Name)
  
  if err := step.Compensate(ctx); err != nil {
   log.Printf("Compensation failed for step %s: %v", step.Name, err)
   return err
  }
  
  log.Printf("Step %s compensated", step.Name)
 }
 
 log.Println("Compensation completed")
 return nil
}

// 使用示例：订单处理Saga
func ExampleOrderSaga() {
 saga := NewSaga()
 
 // 1. 创建订单
 saga.AddStep("create_order",
  func(ctx context.Context) error {
   return createOrder(ctx)
  },
  func(ctx context.Context) error {
   return cancelOrder(ctx)
  },
 )
 
 // 2. 扣减库存
 saga.AddStep("reduce_inventory",
  func(ctx context.Context) error {
   return reduceInventory(ctx)
  },
  func(ctx context.Context) error {
   return restoreInventory(ctx)
  },
 )
 
 // 3. 扣款
 saga.AddStep("process_payment",
  func(ctx context.Context) error {
   return processPayment(ctx)
  },
  func(ctx context.Context) error {
   return refundPayment(ctx)
  },
 )
 
 // 4. 发送通知
 saga.AddStep("send_notification",
  func(ctx context.Context) error {
   return sendOrderConfirmation(ctx)
  },
  func(ctx context.Context) error {
   return sendCancellationNotification(ctx)
  },
 )
 
 // 执行Saga
 if err := saga.Execute(context.Background()); err != nil {
  log.Fatalf("Saga failed: %v", err)
 }
}
```

---

## 8. 完整案例

### 8.1 电商订单处理系统

```go
package orderprocessing

import (
 "context"
 "encoding/json"
 "time"
)

// OrderService 订单服务
type OrderService struct {
 producer      *rabbitmq.Producer
 eventBus      *eventbus.EventBus
 idempotency   *reliability.IdempotencyManager
}

// NewOrderService 创建订单服务
func NewOrderService() (*OrderService, error) {
 // 初始化RabbitMQ
 producer, err := rabbitmq.NewProducer(&rabbitmq.Config{
  URL:          "amqp://localhost",
  Exchange:     "orders",
  ExchangeType: "topic",
  RoutingKey:   "order.created",
  Durable:      true,
 })
 if err != nil {
  return nil, err
 }
 
 // 初始化事件总线
 eventBus := eventbus.NewEventBus()
 
 // 初始化幂等性管理器
 redisClient := redis.NewClient(&redis.Options{
  Addr: "localhost:6379",
 })
 idempotency := reliability.NewIdempotencyManager(redisClient, 24*time.Hour)
 
 service := &OrderService{
  producer:    producer,
  eventBus:    eventBus,
  idempotency: idempotency,
 }
 
 // 注册事件处理器
 service.registerEventHandlers()
 
 return service, nil
}

// registerEventHandlers 注册事件处理器
func (s *OrderService) registerEventHandlers() {
 // 订单创建事件
 s.eventBus.Subscribe("order.created", s.handleOrderCreated)
 
 // 支付完成事件
 s.eventBus.Subscribe("payment.completed", s.handlePaymentCompleted)
 
 // 库存扣减事件
 s.eventBus.Subscribe("inventory.reduced", s.handleInventoryReduced)
}

// CreateOrder 创建订单
func (s *OrderService) CreateOrder(ctx context.Context, order *Order) error {
 // 幂等性检查
 idempotencyKey := fmt.Sprintf("order:create:%s", order.ID)
 
 return s.idempotency.WithIdempotency(ctx, idempotencyKey, func() error {
  // 1. 保存订单到数据库
  if err := saveOrder(order); err != nil {
   return err
  }
  
  // 2. 发布消息到RabbitMQ
  data, _ := json.Marshal(order)
  if err := s.producer.PublishWithConfirm(ctx, data); err != nil {
   return err
  }
  
  // 3. 发布事件到事件总线
  event := OrderCreatedEvent{
   OrderID:  order.ID,
   UserID:   order.UserID,
   Amount:   order.Amount,
   Products: order.Products,
  }
  
  return s.eventBus.Publish(ctx, event)
 })
}

// handleOrderCreated 处理订单创建事件
func (s *OrderService) handleOrderCreated(ctx context.Context, event eventbus.Event) error {
 e := event.Data().(OrderCreatedEvent)
 
 log.Printf("Processing order created event: %s", e.OrderID)
 
 // 创建Saga
 saga := saga.NewSaga()
 
 saga.AddStep("reduce_inventory",
  func(ctx context.Context) error {
   return reduceInventory(ctx, e.Products)
  },
  func(ctx context.Context) error {
   return restoreInventory(ctx, e.Products)
  },
 )
 
 saga.AddStep("process_payment",
  func(ctx context.Context) error {
   return processPayment(ctx, e.UserID, e.Amount)
  },
  func(ctx context.Context) error {
   return refundPayment(ctx, e.UserID, e.Amount)
  },
 )
 
 return saga.Execute(ctx)
}

// handlePaymentCompleted 处理支付完成事件
func (s *OrderService) handlePaymentCompleted(ctx context.Context, event eventbus.Event) error {
 // 发送订单确认邮件
 // 更新订单状态
 // 触发物流流程
 return nil
}

// handleInventoryReduced 处理库存扣减事件
func (s *OrderService) handleInventoryReduced(ctx context.Context, event eventbus.Event) error {
 // 更新订单状态
 // 记录库存变更日志
 return nil
}
```

---

## 📚 消息队列最佳实践

### 技术选型

- **RabbitMQ**: 复杂路由、事务支持、延迟队列
- **Kafka**: 高吞吐量、流处理、日志收集
- **Redis Stream**: 轻量级、简单场景、实时性

### 可靠性保证

- ✅ 消息持久化
- ✅ 生产者确认
- ✅ 消费者手动ACK
- ✅ 死信队列
- ✅ 重试机制
- ✅ 幂等性保证

### 性能优化

- ✅ 批量发送
- ✅ 预取数量控制
- ✅ 连接池管理
- ✅ 消息压缩
- ✅ 分区策略

---

## 🎯 总结

Go 1.25.3消息队列关键点：

1. **RabbitMQ**: 可靠消息传递、延迟队列、死信
2. **Kafka**: 高吞吐流处理、消费者组
3. **Redis Stream**: 轻量级流处理
4. **异步任务**: Asynq任务队列
5. **事件驱动**: 事件总线、发布订阅
6. **可靠性**: 重试、幂等、补偿
7. **分布式事务**: Saga模式

**消息队列是分布式系统的神经网络！**

---

<div align="center">

**掌握消息队列，构建高可用分布式系统**-

[📚 返回目录](../README.md) | [📖 下一章](21-缓存架构实战.md)

Made with ❤️ for Go Developers

</div>

---

**文档版本**: v1.0  
**最后更新**: 2025-10-29  
**Go版本**: Go 1.25.3  
**生产就绪**: ✅
