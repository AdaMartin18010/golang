# Go 1.25.3 æ¶ˆæ¯é˜Ÿåˆ—ä¸å¼‚æ­¥å¤„ç†å®Œæ•´å®æˆ˜

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.25.3

---

## ğŸ“‹ ç›®å½•

- [Go 1.25.3 æ¶ˆæ¯é˜Ÿåˆ—ä¸å¼‚æ­¥å¤„ç†å®Œæ•´å®æˆ˜](#go-1253-æ¶ˆæ¯é˜Ÿåˆ—ä¸å¼‚æ­¥å¤„ç†å®Œæ•´å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“– æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. RabbitMQå®æˆ˜](#1-rabbitmqå®æˆ˜)
    - [1.1 åŸºç¡€è¿æ¥ä¸é…ç½®](#11-åŸºç¡€è¿æ¥ä¸é…ç½®)
    - [1.2 ç”Ÿäº§è€…å®ç°](#12-ç”Ÿäº§è€…å®ç°)
    - [1.3 æ¶ˆè´¹è€…å®ç°](#13-æ¶ˆè´¹è€…å®ç°)
    - [1.4 å»¶è¿Ÿé˜Ÿåˆ—å®ç°](#14-å»¶è¿Ÿé˜Ÿåˆ—å®ç°)
  - [2. Kafkaæµå¤„ç†](#2-kafkaæµå¤„ç†)
    - [2.1 Kafkaç”Ÿäº§è€…](#21-kafkaç”Ÿäº§è€…)
    - [2.2 Kafkaæ¶ˆè´¹è€…ç»„](#22-kafkaæ¶ˆè´¹è€…ç»„)
  - [3. Redis Stream](#3-redis-stream)
    - [3.1 Redis Streamç”Ÿäº§è€…](#31-redis-streamç”Ÿäº§è€…)
    - [3.2 Redis Streamæ¶ˆè´¹è€…ç»„](#32-redis-streamæ¶ˆè´¹è€…ç»„)
  - [4. å¼‚æ­¥ä»»åŠ¡å¤„ç†](#4-å¼‚æ­¥ä»»åŠ¡å¤„ç†)
    - [4.1 Asynqä»»åŠ¡é˜Ÿåˆ—](#41-asynqä»»åŠ¡é˜Ÿåˆ—)
    - [4.2 ä»»åŠ¡å¤„ç†å™¨](#42-ä»»åŠ¡å¤„ç†å™¨)
  - [5. äº‹ä»¶é©±åŠ¨æ¶æ„](#5-äº‹ä»¶é©±åŠ¨æ¶æ„)
    - [5.1 äº‹ä»¶æ€»çº¿](#51-äº‹ä»¶æ€»çº¿)
    - [5.2 å…·ä½“äº‹ä»¶å®ç°](#52-å…·ä½“äº‹ä»¶å®ç°)
  - [6. æ¶ˆæ¯å¯é æ€§](#6-æ¶ˆæ¯å¯é æ€§)
    - [6.1 é‡è¯•æœºåˆ¶](#61-é‡è¯•æœºåˆ¶)
    - [6.2 å¹‚ç­‰æ€§ä¿è¯](#62-å¹‚ç­‰æ€§ä¿è¯)
  - [7. åˆ†å¸ƒå¼äº‹åŠ¡](#7-åˆ†å¸ƒå¼äº‹åŠ¡)
    - [7.1 Sagaæ¨¡å¼](#71-sagaæ¨¡å¼)
  - [8. å®Œæ•´æ¡ˆä¾‹](#8-å®Œæ•´æ¡ˆä¾‹)
    - [8.1 ç”µå•†è®¢å•å¤„ç†ç³»ç»Ÿ](#81-ç”µå•†è®¢å•å¤„ç†ç³»ç»Ÿ)
  - [ğŸ“š æ¶ˆæ¯é˜Ÿåˆ—æœ€ä½³å®è·µ](#-æ¶ˆæ¯é˜Ÿåˆ—æœ€ä½³å®è·µ)
    - [æŠ€æœ¯é€‰å‹](#æŠ€æœ¯é€‰å‹)
    - [å¯é æ€§ä¿è¯](#å¯é æ€§ä¿è¯)
    - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

## ğŸ“– æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£å±•ç¤ºGo 1.25.3çš„**æ¶ˆæ¯é˜Ÿåˆ—ä¸å¼‚æ­¥å¤„ç†å®Œæ•´æ–¹æ¡ˆ**ï¼Œæ„å»ºé«˜å¯ç”¨åˆ†å¸ƒå¼ç³»ç»Ÿï¼š

- âœ… RabbitMQæ·±åº¦å®æˆ˜
- âœ… Kafkaæµå¤„ç†
- âœ… Redis Streamå®æˆ˜
- âœ… å¼‚æ­¥ä»»åŠ¡å¤„ç†
- âœ… äº‹ä»¶é©±åŠ¨æ¶æ„
- âœ… æ¶ˆæ¯å¯é æ€§ä¿è¯
- âœ… åˆ†å¸ƒå¼äº‹åŠ¡

---

## ç›®å½•

- [Go 1.25.3 æ¶ˆæ¯é˜Ÿåˆ—ä¸å¼‚æ­¥å¤„ç†å®Œæ•´å®æˆ˜](#go-1253-æ¶ˆæ¯é˜Ÿåˆ—ä¸å¼‚æ­¥å¤„ç†å®Œæ•´å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“– æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. RabbitMQå®æˆ˜](#1-rabbitmqå®æˆ˜)
    - [1.1 åŸºç¡€è¿æ¥ä¸é…ç½®](#11-åŸºç¡€è¿æ¥ä¸é…ç½®)
    - [1.2 ç”Ÿäº§è€…å®ç°](#12-ç”Ÿäº§è€…å®ç°)
    - [1.3 æ¶ˆè´¹è€…å®ç°](#13-æ¶ˆè´¹è€…å®ç°)
    - [1.4 å»¶è¿Ÿé˜Ÿåˆ—å®ç°](#14-å»¶è¿Ÿé˜Ÿåˆ—å®ç°)
  - [2. Kafkaæµå¤„ç†](#2-kafkaæµå¤„ç†)
    - [2.1 Kafkaç”Ÿäº§è€…](#21-kafkaç”Ÿäº§è€…)
    - [2.2 Kafkaæ¶ˆè´¹è€…ç»„](#22-kafkaæ¶ˆè´¹è€…ç»„)
  - [3. Redis Stream](#3-redis-stream)
    - [3.1 Redis Streamç”Ÿäº§è€…](#31-redis-streamç”Ÿäº§è€…)
    - [3.2 Redis Streamæ¶ˆè´¹è€…ç»„](#32-redis-streamæ¶ˆè´¹è€…ç»„)
  - [4. å¼‚æ­¥ä»»åŠ¡å¤„ç†](#4-å¼‚æ­¥ä»»åŠ¡å¤„ç†)
    - [4.1 Asynqä»»åŠ¡é˜Ÿåˆ—](#41-asynqä»»åŠ¡é˜Ÿåˆ—)
    - [4.2 ä»»åŠ¡å¤„ç†å™¨](#42-ä»»åŠ¡å¤„ç†å™¨)
  - [5. äº‹ä»¶é©±åŠ¨æ¶æ„](#5-äº‹ä»¶é©±åŠ¨æ¶æ„)
    - [5.1 äº‹ä»¶æ€»çº¿](#51-äº‹ä»¶æ€»çº¿)
    - [5.2 å…·ä½“äº‹ä»¶å®ç°](#52-å…·ä½“äº‹ä»¶å®ç°)
  - [6. æ¶ˆæ¯å¯é æ€§](#6-æ¶ˆæ¯å¯é æ€§)
    - [6.1 é‡è¯•æœºåˆ¶](#61-é‡è¯•æœºåˆ¶)
    - [6.2 å¹‚ç­‰æ€§ä¿è¯](#62-å¹‚ç­‰æ€§ä¿è¯)
  - [7. åˆ†å¸ƒå¼äº‹åŠ¡](#7-åˆ†å¸ƒå¼äº‹åŠ¡)
    - [7.1 Sagaæ¨¡å¼](#71-sagaæ¨¡å¼)
  - [8. å®Œæ•´æ¡ˆä¾‹](#8-å®Œæ•´æ¡ˆä¾‹)
    - [8.1 ç”µå•†è®¢å•å¤„ç†ç³»ç»Ÿ](#81-ç”µå•†è®¢å•å¤„ç†ç³»ç»Ÿ)
  - [ğŸ“š æ¶ˆæ¯é˜Ÿåˆ—æœ€ä½³å®è·µ](#-æ¶ˆæ¯é˜Ÿåˆ—æœ€ä½³å®è·µ)
    - [æŠ€æœ¯é€‰å‹](#æŠ€æœ¯é€‰å‹)
    - [å¯é æ€§ä¿è¯](#å¯é æ€§ä¿è¯)
    - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

---

## 1. RabbitMQå®æˆ˜

### 1.1 åŸºç¡€è¿æ¥ä¸é…ç½®

```go
package rabbitmq

import (
 "context"
 "fmt"
 "time"

 amqp "github.com/rabbitmq/amqp091-go"
)

// RabbitMQ å®¢æˆ·ç«¯
type RabbitMQ struct {
 conn    *amqp.Connection
 channel *amqp.Channel
 config  *Config
}

// Config é…ç½®
type Config struct {
 URL          string
 Exchange     string
 ExchangeType string
 Queue        string
 RoutingKey   string
 Durable      bool
 AutoAck      bool
 Prefetch     int
}

// NewRabbitMQ åˆ›å»ºRabbitMQå®¢æˆ·ç«¯
func NewRabbitMQ(config *Config) (*RabbitMQ, error) {
 // è¿æ¥RabbitMQ
 conn, err := amqp.Dial(config.URL)
 if err != nil {
  return nil, fmt.Errorf("failed to connect: %w", err)
 }

 // åˆ›å»ºchannel
 ch, err := conn.Channel()
 if err != nil {
  conn.Close()
  return nil, fmt.Errorf("failed to open channel: %w", err)
 }

 // è®¾ç½®QoS
 if err := ch.Qos(config.Prefetch, 0, false); err != nil {
  ch.Close()
  conn.Close()
  return nil, fmt.Errorf("failed to set QoS: %w", err)
 }

 // å£°æ˜exchange
 if config.Exchange != "" {
  err = ch.ExchangeDeclare(
   config.Exchange,     // name
   config.ExchangeType, // type
   config.Durable,      // durable
   false,               // auto-deleted
   false,               // internal
   false,               // no-wait
   nil,                 // arguments
  )
  if err != nil {
   ch.Close()
   conn.Close()
   return nil, fmt.Errorf("failed to declare exchange: %w", err)
  }
 }

 // å£°æ˜é˜Ÿåˆ—
 if config.Queue != "" {
  _, err = ch.QueueDeclare(
   config.Queue,    // name
   config.Durable,  // durable
   false,           // delete when unused
   false,           // exclusive
   false,           // no-wait
   nil,             // arguments
  )
  if err != nil {
   ch.Close()
   conn.Close()
   return nil, fmt.Errorf("failed to declare queue: %w", err)
  }

  // ç»‘å®šé˜Ÿåˆ—åˆ°exchange
  if config.Exchange != "" {
   err = ch.QueueBind(
    config.Queue,      // queue name
    config.RoutingKey, // routing key
    config.Exchange,   // exchange
    false,
    nil,
   )
   if err != nil {
    ch.Close()
    conn.Close()
    return nil, fmt.Errorf("failed to bind queue: %w", err)
   }
  }
 }

 return &RabbitMQ{
  conn:    conn,
  channel: ch,
  config:  config,
 }, nil
}

// Close å…³é—­è¿æ¥
func (r *RabbitMQ) Close() error {
 if r.channel != nil {
  r.channel.Close()
 }
 if r.conn != nil {
  return r.conn.Close()
 }
 return nil
}
```

---

### 1.2 ç”Ÿäº§è€…å®ç°

```go
// Producer ç”Ÿäº§è€…
type Producer struct {
 mq *RabbitMQ
}

// NewProducer åˆ›å»ºç”Ÿäº§è€…
func NewProducer(config *Config) (*Producer, error) {
 mq, err := NewRabbitMQ(config)
 if err != nil {
  return nil, err
 }

 return &Producer{mq: mq}, nil
}

// Publish å‘å¸ƒæ¶ˆæ¯
func (p *Producer) Publish(ctx context.Context, body []byte) error {
 return p.mq.channel.PublishWithContext(
  ctx,
  p.mq.config.Exchange,    // exchange
  p.mq.config.RoutingKey,  // routing key
  false,                    // mandatory
  false,                    // immediate
  amqp.Publishing{
   ContentType:  "application/json",
   Body:         body,
   DeliveryMode: amqp.Persistent, // æŒä¹…åŒ–
   Timestamp:    time.Now(),
  },
 )
}

// PublishWithConfirm å¸¦ç¡®è®¤çš„å‘å¸ƒ
func (p *Producer) PublishWithConfirm(ctx context.Context, body []byte) error {
 // å¼€å¯ç¡®è®¤æ¨¡å¼
 if err := p.mq.channel.Confirm(false); err != nil {
  return fmt.Errorf("failed to enable confirm mode: %w", err)
 }

 // æ³¨å†Œç¡®è®¤ç›‘å¬
 confirms := p.mq.channel.NotifyPublish(make(chan amqp.Confirmation, 1))

 // å‘å¸ƒæ¶ˆæ¯
 if err := p.Publish(ctx, body); err != nil {
  return err
 }

 // ç­‰å¾…ç¡®è®¤
 select {
 case confirm := <-confirms:
  if !confirm.Ack {
   return fmt.Errorf("message not confirmed")
  }
  return nil
 case <-ctx.Done():
  return ctx.Err()
 }
}
```

---

### 1.3 æ¶ˆè´¹è€…å®ç°

```go
// Consumer æ¶ˆè´¹è€…
type Consumer struct {
 mq      *RabbitMQ
 handler MessageHandler
}

// MessageHandler æ¶ˆæ¯å¤„ç†å‡½æ•°
type MessageHandler func(ctx context.Context, body []byte) error

// NewConsumer åˆ›å»ºæ¶ˆè´¹è€…
func NewConsumer(config *Config, handler MessageHandler) (*Consumer, error) {
 mq, err := NewRabbitMQ(config)
 if err != nil {
  return nil, err
 }

 return &Consumer{
  mq:      mq,
  handler: handler,
 }, nil
}

// Start å¼€å§‹æ¶ˆè´¹
func (c *Consumer) Start(ctx context.Context) error {
 // å¼€å§‹æ¶ˆè´¹
 msgs, err := c.mq.channel.Consume(
  c.mq.config.Queue,   // queue
  "",                  // consumer
  c.mq.config.AutoAck, // auto-ack
  false,               // exclusive
  false,               // no-local
  false,               // no-wait
  nil,                 // args
 )
 if err != nil {
  return fmt.Errorf("failed to register consumer: %w", err)
 }

 // å¤„ç†æ¶ˆæ¯
 for {
  select {
  case msg, ok := <-msgs:
   if !ok {
    return nil
   }

   // å¤„ç†æ¶ˆæ¯
   if err := c.handler(ctx, msg.Body); err != nil {
    log.Printf("Failed to handle message: %v", err)

    // æ‹’ç»æ¶ˆæ¯å¹¶é‡æ–°å…¥é˜Ÿ
    if !c.mq.config.AutoAck {
     msg.Nack(false, true)
    }
    continue
   }

   // ç¡®è®¤æ¶ˆæ¯
   if !c.mq.config.AutoAck {
    msg.Ack(false)
   }

  case <-ctx.Done():
   return ctx.Err()
  }
 }
}
```

---

### 1.4 å»¶è¿Ÿé˜Ÿåˆ—å®ç°

```go
// DelayQueue å»¶è¿Ÿé˜Ÿåˆ—
type DelayQueue struct {
 mq *RabbitMQ
}

// NewDelayQueue åˆ›å»ºå»¶è¿Ÿé˜Ÿåˆ—
func NewDelayQueue(config *Config) (*DelayQueue, error) {
 mq, err := NewRabbitMQ(config)
 if err != nil {
  return nil, err
 }

 // å£°æ˜æ­»ä¿¡exchange
 err = mq.channel.ExchangeDeclare(
  "dlx.exchange",
  "direct",
  true,
  false,
  false,
  false,
  nil,
 )
 if err != nil {
  return nil, err
 }

 // å£°æ˜å»¶è¿Ÿé˜Ÿåˆ—ï¼ˆå¸¦æ­»ä¿¡é…ç½®ï¼‰
 _, err = mq.channel.QueueDeclare(
  "delay.queue",
  true,
  false,
  false,
  false,
  amqp.Table{
   "x-dead-letter-exchange":    "dlx.exchange",
   "x-dead-letter-routing-key": "delay.route",
  },
 )
 if err != nil {
  return nil, err
 }

 // å£°æ˜å®é™…å·¥ä½œé˜Ÿåˆ—
 _, err = mq.channel.QueueDeclare(
  "work.queue",
  true,
  false,
  false,
  false,
  nil,
 )
 if err != nil {
  return nil, err
 }

 // ç»‘å®šå·¥ä½œé˜Ÿåˆ—åˆ°æ­»ä¿¡exchange
 err = mq.channel.QueueBind(
  "work.queue",
  "delay.route",
  "dlx.exchange",
  false,
  nil,
 )
 if err != nil {
  return nil, err
 }

 return &DelayQueue{mq: mq}, nil
}

// PublishDelay å‘å¸ƒå»¶è¿Ÿæ¶ˆæ¯
func (d *DelayQueue) PublishDelay(ctx context.Context, body []byte, delay time.Duration) error {
 return d.mq.channel.PublishWithContext(
  ctx,
  "",              // exchange
  "delay.queue",   // routing key
  false,
  false,
  amqp.Publishing{
   ContentType:  "application/json",
   Body:         body,
   DeliveryMode: amqp.Persistent,
   Expiration:   fmt.Sprintf("%d", delay.Milliseconds()),
  },
 )
}
```

---

## 2. Kafkaæµå¤„ç†

### 2.1 Kafkaç”Ÿäº§è€…

```go
package kafka

import (
 "context"
 "fmt"

 "github.com/IBM/sarama"
)

// Producer Kafkaç”Ÿäº§è€…
type Producer struct {
 producer sarama.SyncProducer
 config   *sarama.Config
}

// NewProducer åˆ›å»ºç”Ÿäº§è€…
func NewProducer(brokers []string) (*Producer, error) {
 config := sarama.NewConfig()
 config.Producer.RequiredAcks = sarama.WaitForAll
 config.Producer.Retry.Max = 5
 config.Producer.Return.Successes = true
 config.Producer.Partitioner = sarama.NewHashPartitioner

 producer, err := sarama.NewSyncProducer(brokers, config)
 if err != nil {
  return nil, fmt.Errorf("failed to create producer: %w", err)
 }

 return &Producer{
  producer: producer,
  config:   config,
 }, nil
}

// Send å‘é€æ¶ˆæ¯
func (p *Producer) Send(topic string, key, value []byte) (partition int32, offset int64, err error) {
 msg := &sarama.ProducerMessage{
  Topic: topic,
  Key:   sarama.ByteEncoder(key),
  Value: sarama.ByteEncoder(value),
 }

 return p.producer.SendMessage(msg)
}

// SendBatch æ‰¹é‡å‘é€
func (p *Producer) SendBatch(topic string, messages [][]byte) error {
 msgs := make([]*sarama.ProducerMessage, len(messages))

 for i, msg := range messages {
  msgs[i] = &sarama.ProducerMessage{
   Topic: topic,
   Value: sarama.ByteEncoder(msg),
  }
 }

 return p.producer.SendMessages(msgs)
}

// Close å…³é—­ç”Ÿäº§è€…
func (p *Producer) Close() error {
 return p.producer.Close()
}
```

---

### 2.2 Kafkaæ¶ˆè´¹è€…ç»„

```go
// ConsumerGroup Kafkaæ¶ˆè´¹è€…ç»„
type ConsumerGroup struct {
 group   sarama.ConsumerGroup
 handler ConsumerGroupHandler
}

// ConsumerGroupHandler æ¶ˆè´¹è€…ç»„å¤„ç†å™¨
type ConsumerGroupHandler struct {
 handler func(ctx context.Context, message *sarama.ConsumerMessage) error
}

// Setup åˆå§‹åŒ–
func (h ConsumerGroupHandler) Setup(sarama.ConsumerGroupSession) error {
 return nil
}

// Cleanup æ¸…ç†
func (h ConsumerGroupHandler) Cleanup(sarama.ConsumerGroupSession) error {
 return nil
}

// ConsumeClaim æ¶ˆè´¹
func (h ConsumerGroupHandler) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
 for message := range claim.Messages() {
  ctx := session.Context()

  // å¤„ç†æ¶ˆæ¯
  if err := h.handler(ctx, message); err != nil {
   log.Printf("Failed to handle message: %v", err)
   continue
  }

  // æ ‡è®°æ¶ˆæ¯å·²å¤„ç†
  session.MarkMessage(message, "")
 }

 return nil
}

// NewConsumerGroup åˆ›å»ºæ¶ˆè´¹è€…ç»„
func NewConsumerGroup(brokers []string, groupID string, topics []string, handler func(context.Context, *sarama.ConsumerMessage) error) (*ConsumerGroup, error) {
 config := sarama.NewConfig()
 config.Consumer.Group.Rebalance.Strategy = sarama.NewBalanceStrategyRoundRobin()
 config.Consumer.Offsets.Initial = sarama.OffsetNewest

 group, err := sarama.NewConsumerGroup(brokers, groupID, config)
 if err != nil {
  return nil, fmt.Errorf("failed to create consumer group: %w", err)
 }

 return &ConsumerGroup{
  group: group,
  handler: ConsumerGroupHandler{
   handler: handler,
  },
 }, nil
}

// Start å¼€å§‹æ¶ˆè´¹
func (c *ConsumerGroup) Start(ctx context.Context, topics []string) error {
 for {
  if err := c.group.Consume(ctx, topics, c.handler); err != nil {
   return fmt.Errorf("consumer error: %w", err)
  }

  if ctx.Err() != nil {
   return ctx.Err()
  }
 }
}

// Close å…³é—­æ¶ˆè´¹è€…ç»„
func (c *ConsumerGroup) Close() error {
 return c.group.Close()
}
```

---

## 3. Redis Stream

### 3.1 Redis Streamç”Ÿäº§è€…

```go
package redisstream

import (
 "context"
 "fmt"

 "github.com/redis/go-redis/v9"
)

// Producer Redis Streamç”Ÿäº§è€…
type Producer struct {
 client *redis.Client
 stream string
}

// NewProducer åˆ›å»ºç”Ÿäº§è€…
func NewProducer(client *redis.Client, stream string) *Producer {
 return &Producer{
  client: client,
  stream: stream,
 }
}

// Send å‘é€æ¶ˆæ¯
func (p *Producer) Send(ctx context.Context, values map[string]interface{}) (string, error) {
 id, err := p.client.XAdd(ctx, &redis.XAddArgs{
  Stream: p.stream,
  Values: values,
 }).Result()

 if err != nil {
  return "", fmt.Errorf("failed to send message: %w", err)
 }

 return id, nil
}

// SendWithMaxLen å‘é€æ¶ˆæ¯ï¼ˆé™åˆ¶é•¿åº¦ï¼‰
func (p *Producer) SendWithMaxLen(ctx context.Context, values map[string]interface{}, maxLen int64) (string, error) {
 id, err := p.client.XAdd(ctx, &redis.XAddArgs{
  Stream: p.stream,
  MaxLen: maxLen,
  Approx: true,
  Values: values,
 }).Result()

 if err != nil {
  return "", fmt.Errorf("failed to send message: %w", err)
 }

 return id, nil
}
```

---

### 3.2 Redis Streamæ¶ˆè´¹è€…ç»„

```go
// ConsumerGroup Redis Streamæ¶ˆè´¹è€…ç»„
type ConsumerGroup struct {
 client   *redis.Client
 stream   string
 group    string
 consumer string
 handler  func(context.Context, redis.XMessage) error
}

// NewConsumerGroup åˆ›å»ºæ¶ˆè´¹è€…ç»„
func NewConsumerGroup(client *redis.Client, stream, group, consumer string, handler func(context.Context, redis.XMessage) error) (*ConsumerGroup, error) {
 // åˆ›å»ºæ¶ˆè´¹è€…ç»„ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
 err := client.XGroupCreateMkStream(context.Background(), stream, group, "0").Err()
 if err != nil && err.Error() != "BUSYGROUP Consumer Group name already exists" {
  return nil, fmt.Errorf("failed to create consumer group: %w", err)
 }

 return &ConsumerGroup{
  client:   client,
  stream:   stream,
  group:    group,
  consumer: consumer,
  handler:  handler,
 }, nil
}

// Start å¼€å§‹æ¶ˆè´¹
func (c *ConsumerGroup) Start(ctx context.Context) error {
 for {
  // è¯»å–æ¶ˆæ¯
  streams, err := c.client.XReadGroup(ctx, &redis.XReadGroupArgs{
   Group:    c.group,
   Consumer: c.consumer,
   Streams:  []string{c.stream, ">"},
   Count:    10,
   Block:    0,
  }).Result()

  if err != nil {
   if err == redis.Nil {
    continue
   }
   return fmt.Errorf("failed to read messages: %w", err)
  }

  // å¤„ç†æ¶ˆæ¯
  for _, stream := range streams {
   for _, message := range stream.Messages {
    if err := c.handler(ctx, message); err != nil {
     log.Printf("Failed to handle message: %v", err)
     continue
    }

    // ç¡®è®¤æ¶ˆæ¯
    c.client.XAck(ctx, c.stream, c.group, message.ID)
   }
  }

  if ctx.Err() != nil {
   return ctx.Err()
  }
 }
}

// GetPending è·å–å¾…å¤„ç†æ¶ˆæ¯
func (c *ConsumerGroup) GetPending(ctx context.Context) ([]redis.XPendingExt, error) {
 pending, err := c.client.XPendingExt(ctx, &redis.XPendingExtArgs{
  Stream: c.stream,
  Group:  c.group,
  Start:  "-",
  End:    "+",
  Count:  100,
 }).Result()

 if err != nil {
  return nil, err
 }

 return pending, nil
}

// Claim è®¤é¢†è¶…æ—¶æ¶ˆæ¯
func (c *ConsumerGroup) Claim(ctx context.Context, minIdleTime time.Duration) error {
 pending, err := c.GetPending(ctx)
 if err != nil {
  return err
 }

 for _, p := range pending {
  if p.Idle < minIdleTime {
   continue
  }

  // è®¤é¢†æ¶ˆæ¯
  messages, err := c.client.XClaim(ctx, &redis.XClaimArgs{
   Stream:   c.stream,
   Group:    c.group,
   Consumer: c.consumer,
   MinIdle:  minIdleTime,
   Messages: []string{p.ID},
  }).Result()

  if err != nil {
   log.Printf("Failed to claim message: %v", err)
   continue
  }

  // å¤„ç†è®¤é¢†çš„æ¶ˆæ¯
  for _, msg := range messages {
   if err := c.handler(ctx, msg); err != nil {
    log.Printf("Failed to handle claimed message: %v", err)
    continue
   }

   c.client.XAck(ctx, c.stream, c.group, msg.ID)
  }
 }

 return nil
}
```

---

## 4. å¼‚æ­¥ä»»åŠ¡å¤„ç†

### 4.1 Asynqä»»åŠ¡é˜Ÿåˆ—

```go
package async

import (
 "context"
 "encoding/json"
 "fmt"
 "time"

 "github.com/hibiken/asynq"
)

// TaskType ä»»åŠ¡ç±»å‹
const (
 TypeEmailDelivery   = "email:deliver"
 TypeImageResize     = "image:resize"
 TypeDataBackup      = "data:backup"
)

// EmailDeliveryPayload é‚®ä»¶å‘é€ä»»åŠ¡è½½è·
type EmailDeliveryPayload struct {
 To      string `json:"to"`
 Subject string `json:"subject"`
 Body    string `json:"body"`
}

// TaskClient ä»»åŠ¡å®¢æˆ·ç«¯
type TaskClient struct {
 client *asynq.Client
}

// NewTaskClient åˆ›å»ºä»»åŠ¡å®¢æˆ·ç«¯
func NewTaskClient(redisAddr string) *TaskClient {
 client := asynq.NewClient(asynq.RedisClientOpt{
  Addr: redisAddr,
 })

 return &TaskClient{client: client}
}

// EnqueueEmailDelivery å…¥é˜Ÿé‚®ä»¶å‘é€ä»»åŠ¡
func (c *TaskClient) EnqueueEmailDelivery(payload *EmailDeliveryPayload) error {
 data, err := json.Marshal(payload)
 if err != nil {
  return err
 }

 task := asynq.NewTask(TypeEmailDelivery, data)

 info, err := c.client.Enqueue(task,
  asynq.MaxRetry(3),
  asynq.Timeout(5*time.Minute),
 )

 if err != nil {
  return fmt.Errorf("failed to enqueue task: %w", err)
 }

 log.Printf("Enqueued task: id=%s queue=%s", info.ID, info.Queue)
 return nil
}

// EnqueueScheduled å…¥é˜Ÿå®šæ—¶ä»»åŠ¡
func (c *TaskClient) EnqueueScheduled(taskType string, payload []byte, processAt time.Time) error {
 task := asynq.NewTask(taskType, payload)

 info, err := c.client.Enqueue(task,
  asynq.ProcessAt(processAt),
 )

 if err != nil {
  return fmt.Errorf("failed to enqueue scheduled task: %w", err)
 }

 log.Printf("Enqueued scheduled task: id=%s", info.ID)
 return nil
}

// Close å…³é—­å®¢æˆ·ç«¯
func (c *TaskClient) Close() error {
 return c.client.Close()
}
```

---

### 4.2 ä»»åŠ¡å¤„ç†å™¨

```go
// TaskServer ä»»åŠ¡æœåŠ¡å™¨
type TaskServer struct {
 server *asynq.Server
 mux    *asynq.ServeMux
}

// NewTaskServer åˆ›å»ºä»»åŠ¡æœåŠ¡å™¨
func NewTaskServer(redisAddr string) *TaskServer {
 server := asynq.NewServer(
  asynq.RedisClientOpt{Addr: redisAddr},
  asynq.Config{
   Concurrency: 10,
   Queues: map[string]int{
    "critical": 6,
    "default":  3,
    "low":      1,
   },
  },
 )

 mux := asynq.NewServeMux()

 return &TaskServer{
  server: server,
  mux:    mux,
 }
}

// HandleEmailDelivery å¤„ç†é‚®ä»¶å‘é€ä»»åŠ¡
func (s *TaskServer) HandleEmailDelivery(ctx context.Context, task *asynq.Task) error {
 var payload EmailDeliveryPayload
 if err := json.Unmarshal(task.Payload(), &payload); err != nil {
  return fmt.Errorf("failed to unmarshal payload: %w", err)
 }

 log.Printf("Sending email to: %s", payload.To)

 // å‘é€é‚®ä»¶é€»è¾‘
 if err := sendEmail(payload.To, payload.Subject, payload.Body); err != nil {
  return fmt.Errorf("failed to send email: %w", err)
 }

 log.Printf("Email sent successfully to: %s", payload.To)
 return nil
}

// RegisterHandlers æ³¨å†Œå¤„ç†å™¨
func (s *TaskServer) RegisterHandlers() {
 s.mux.HandleFunc(TypeEmailDelivery, s.HandleEmailDelivery)
 // æ³¨å†Œå…¶ä»–å¤„ç†å™¨...
}

// Start å¯åŠ¨æœåŠ¡å™¨
func (s *TaskServer) Start() error {
 s.RegisterHandlers()
 return s.server.Run(s.mux)
}

// Shutdown å…³é—­æœåŠ¡å™¨
func (s *TaskServer) Shutdown() {
 s.server.Shutdown()
}
```

---

## 5. äº‹ä»¶é©±åŠ¨æ¶æ„

### 5.1 äº‹ä»¶æ€»çº¿

```go
package eventbus

import (
 "context"
 "sync"
)

// Event äº‹ä»¶æ¥å£
type Event interface {
 Type() string
 Data() interface{}
}

// Handler äº‹ä»¶å¤„ç†å™¨
type Handler func(context.Context, Event) error

// EventBus äº‹ä»¶æ€»çº¿
type EventBus struct {
 handlers map[string][]Handler
 mu       sync.RWMutex
}

// NewEventBus åˆ›å»ºäº‹ä»¶æ€»çº¿
func NewEventBus() *EventBus {
 return &EventBus{
  handlers: make(map[string][]Handler),
 }
}

// Subscribe è®¢é˜…äº‹ä»¶
func (eb *EventBus) Subscribe(eventType string, handler Handler) {
 eb.mu.Lock()
 defer eb.mu.Unlock()

 eb.handlers[eventType] = append(eb.handlers[eventType], handler)
}

// Publish å‘å¸ƒäº‹ä»¶
func (eb *EventBus) Publish(ctx context.Context, event Event) error {
 eb.mu.RLock()
 handlers, ok := eb.handlers[event.Type()]
 eb.mu.RUnlock()

 if !ok {
  return nil
 }

 // å¼‚æ­¥å¤„ç†æ‰€æœ‰å¤„ç†å™¨
 var wg sync.WaitGroup
 errCh := make(chan error, len(handlers))

 for _, handler := range handlers {
  wg.Add(1)

  go func(h Handler) {
   defer wg.Done()

   if err := h(ctx, event); err != nil {
    errCh <- err
   }
  }(handler)
 }

 wg.Wait()
 close(errCh)

 // æ”¶é›†é”™è¯¯
 var errors []error
 for err := range errCh {
  errors = append(errors, err)
 }

 if len(errors) > 0 {
  return errors[0]
 }

 return nil
}
```

---

### 5.2 å…·ä½“äº‹ä»¶å®ç°

```go
// UserCreatedEvent ç”¨æˆ·åˆ›å»ºäº‹ä»¶
type UserCreatedEvent struct {
 UserID   string
 Email    string
 Username string
}

func (e UserCreatedEvent) Type() string {
 return "user.created"
}

func (e UserCreatedEvent) Data() interface{} {
 return e
}

// OrderPlacedEvent è®¢å•åˆ›å»ºäº‹ä»¶
type OrderPlacedEvent struct {
 OrderID  string
 UserID   string
 Amount   float64
 Products []string
}

func (e OrderPlacedEvent) Type() string {
 return "order.placed"
}

func (e OrderPlacedEvent) Data() interface{} {
 return e
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleEventBus() {
 bus := NewEventBus()

 // è®¢é˜…ç”¨æˆ·åˆ›å»ºäº‹ä»¶
 bus.Subscribe("user.created", func(ctx context.Context, event Event) error {
  e := event.Data().(UserCreatedEvent)
  log.Printf("Sending welcome email to: %s", e.Email)
  return sendWelcomeEmail(e.Email)
 })

 bus.Subscribe("user.created", func(ctx context.Context, event Event) error {
  e := event.Data().(UserCreatedEvent)
  log.Printf("Creating user profile for: %s", e.UserID)
  return createUserProfile(e.UserID)
 })

 // å‘å¸ƒäº‹ä»¶
 event := UserCreatedEvent{
  UserID:   "123",
  Email:    "user@example.com",
  Username: "john",
 }

 bus.Publish(context.Background(), event)
}
```

---

## 6. æ¶ˆæ¯å¯é æ€§

### 6.1 é‡è¯•æœºåˆ¶

```go
package reliability

import (
 "context"
 "fmt"
 "math"
 "time"
)

// RetryPolicy é‡è¯•ç­–ç•¥
type RetryPolicy struct {
 MaxAttempts int
 InitialDelay time.Duration
 MaxDelay     time.Duration
 Multiplier   float64
}

// DefaultRetryPolicy é»˜è®¤é‡è¯•ç­–ç•¥
func DefaultRetryPolicy() *RetryPolicy {
 return &RetryPolicy{
  MaxAttempts:  3,
  InitialDelay: 1 * time.Second,
  MaxDelay:     30 * time.Second,
  Multiplier:   2.0,
 }
}

// RetryWithBackoff å¸¦é€€é¿çš„é‡è¯•
func RetryWithBackoff(ctx context.Context, policy *RetryPolicy, fn func() error) error {
 var lastErr error

 for attempt := 0; attempt < policy.MaxAttempts; attempt++ {
  // æ‰§è¡Œå‡½æ•°
  if err := fn(); err == nil {
   return nil
  } else {
   lastErr = err
  }

  // æœ€åä¸€æ¬¡å°è¯•ä¸éœ€è¦ç­‰å¾…
  if attempt == policy.MaxAttempts-1 {
   break
  }

  // è®¡ç®—é€€é¿æ—¶é—´
  delay := calculateBackoff(attempt, policy)

  // ç­‰å¾…
  select {
  case <-time.After(delay):
  case <-ctx.Done():
   return ctx.Err()
  }
 }

 return fmt.Errorf("max retry attempts reached: %w", lastErr)
}

// calculateBackoff è®¡ç®—é€€é¿æ—¶é—´
func calculateBackoff(attempt int, policy *RetryPolicy) time.Duration {
 delay := float64(policy.InitialDelay) * math.Pow(policy.Multiplier, float64(attempt))

 if time.Duration(delay) > policy.MaxDelay {
  return policy.MaxDelay
 }

 return time.Duration(delay)
}
```

---

### 6.2 å¹‚ç­‰æ€§ä¿è¯

```go
// IdempotencyManager å¹‚ç­‰æ€§ç®¡ç†å™¨
type IdempotencyManager struct {
 cache *redis.Client
 ttl   time.Duration
}

// NewIdempotencyManager åˆ›å»ºå¹‚ç­‰æ€§ç®¡ç†å™¨
func NewIdempotencyManager(cache *redis.Client, ttl time.Duration) *IdempotencyManager {
 return &IdempotencyManager{
  cache: cache,
  ttl:   ttl,
 }
}

// IsProcessed æ£€æŸ¥æ˜¯å¦å·²å¤„ç†
func (im *IdempotencyManager) IsProcessed(ctx context.Context, key string) (bool, error) {
 exists, err := im.cache.Exists(ctx, key).Result()
 if err != nil {
  return false, err
 }

 return exists > 0, nil
}

// MarkAsProcessed æ ‡è®°ä¸ºå·²å¤„ç†
func (im *IdempotencyManager) MarkAsProcessed(ctx context.Context, key string) error {
 return im.cache.Set(ctx, key, "1", im.ttl).Err()
}

// WithIdempotency å¹‚ç­‰æ€§åŒ…è£…å™¨
func (im *IdempotencyManager) WithIdempotency(ctx context.Context, key string, fn func() error) error {
 // æ£€æŸ¥æ˜¯å¦å·²å¤„ç†
 processed, err := im.IsProcessed(ctx, key)
 if err != nil {
  return fmt.Errorf("failed to check idempotency: %w", err)
 }

 if processed {
  log.Printf("Message already processed: %s", key)
  return nil
 }

 // æ‰§è¡Œå‡½æ•°
 if err := fn(); err != nil {
  return err
 }

 // æ ‡è®°ä¸ºå·²å¤„ç†
 if err := im.MarkAsProcessed(ctx, key); err != nil {
  return fmt.Errorf("failed to mark as processed: %w", err)
 }

 return nil
}
```

---

## 7. åˆ†å¸ƒå¼äº‹åŠ¡

### 7.1 Sagaæ¨¡å¼

```go
package saga

import (
 "context"
 "fmt"
)

// Step Sagaæ­¥éª¤
type Step struct {
 Name        string
 Action      func(context.Context) error
 Compensate  func(context.Context) error
}

// Saga Sagaåè°ƒå™¨
type Saga struct {
 steps []Step
}

// NewSaga åˆ›å»ºSaga
func NewSaga() *Saga {
 return &Saga{
  steps: make([]Step, 0),
 }
}

// AddStep æ·»åŠ æ­¥éª¤
func (s *Saga) AddStep(name string, action, compensate func(context.Context) error) *Saga {
 s.steps = append(s.steps, Step{
  Name:       name,
  Action:     action,
  Compensate: compensate,
 })
 return s
}

// Execute æ‰§è¡ŒSaga
func (s *Saga) Execute(ctx context.Context) error {
 executedSteps := make([]Step, 0)

 // æ‰§è¡Œæ‰€æœ‰æ­¥éª¤
 for _, step := range s.steps {
  log.Printf("Executing step: %s", step.Name)

  if err := step.Action(ctx); err != nil {
   log.Printf("Step %s failed: %v", step.Name, err)

   // è¡¥å¿å·²æ‰§è¡Œçš„æ­¥éª¤
   if err := s.compensate(ctx, executedSteps); err != nil {
    return fmt.Errorf("compensation failed: %w", err)
   }

   return fmt.Errorf("saga failed at step %s: %w", step.Name, err)
  }

  executedSteps = append(executedSteps, step)
  log.Printf("Step %s completed", step.Name)
 }

 log.Println("Saga completed successfully")
 return nil
}

// compensate è¡¥å¿æ“ä½œ
func (s *Saga) compensate(ctx context.Context, steps []Step) error {
 log.Println("Starting compensation")

 // é€†åºè¡¥å¿
 for i := len(steps) - 1; i >= 0; i-- {
  step := steps[i]
  log.Printf("Compensating step: %s", step.Name)

  if err := step.Compensate(ctx); err != nil {
   log.Printf("Compensation failed for step %s: %v", step.Name, err)
   return err
  }

  log.Printf("Step %s compensated", step.Name)
 }

 log.Println("Compensation completed")
 return nil
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šè®¢å•å¤„ç†Saga
func ExampleOrderSaga() {
 saga := NewSaga()

 // 1. åˆ›å»ºè®¢å•
 saga.AddStep("create_order",
  func(ctx context.Context) error {
   return createOrder(ctx)
  },
  func(ctx context.Context) error {
   return cancelOrder(ctx)
  },
 )

 // 2. æ‰£å‡åº“å­˜
 saga.AddStep("reduce_inventory",
  func(ctx context.Context) error {
   return reduceInventory(ctx)
  },
  func(ctx context.Context) error {
   return restoreInventory(ctx)
  },
 )

 // 3. æ‰£æ¬¾
 saga.AddStep("process_payment",
  func(ctx context.Context) error {
   return processPayment(ctx)
  },
  func(ctx context.Context) error {
   return refundPayment(ctx)
  },
 )

 // 4. å‘é€é€šçŸ¥
 saga.AddStep("send_notification",
  func(ctx context.Context) error {
   return sendOrderConfirmation(ctx)
  },
  func(ctx context.Context) error {
   return sendCancellationNotification(ctx)
  },
 )

 // æ‰§è¡ŒSaga
 if err := saga.Execute(context.Background()); err != nil {
  log.Fatalf("Saga failed: %v", err)
 }
}
```

---

## 8. å®Œæ•´æ¡ˆä¾‹

### 8.1 ç”µå•†è®¢å•å¤„ç†ç³»ç»Ÿ

```go
package orderprocessing

import (
 "context"
 "encoding/json"
 "time"
)

// OrderService è®¢å•æœåŠ¡
type OrderService struct {
 producer      *rabbitmq.Producer
 eventBus      *eventbus.EventBus
 idempotency   *reliability.IdempotencyManager
}

// NewOrderService åˆ›å»ºè®¢å•æœåŠ¡
func NewOrderService() (*OrderService, error) {
 // åˆå§‹åŒ–RabbitMQ
 producer, err := rabbitmq.NewProducer(&rabbitmq.Config{
  URL:          "amqp://localhost",
  Exchange:     "orders",
  ExchangeType: "topic",
  RoutingKey:   "order.created",
  Durable:      true,
 })
 if err != nil {
  return nil, err
 }

 // åˆå§‹åŒ–äº‹ä»¶æ€»çº¿
 eventBus := eventbus.NewEventBus()

 // åˆå§‹åŒ–å¹‚ç­‰æ€§ç®¡ç†å™¨
 redisClient := redis.NewClient(&redis.Options{
  Addr: "localhost:6379",
 })
 idempotency := reliability.NewIdempotencyManager(redisClient, 24*time.Hour)

 service := &OrderService{
  producer:    producer,
  eventBus:    eventBus,
  idempotency: idempotency,
 }

 // æ³¨å†Œäº‹ä»¶å¤„ç†å™¨
 service.registerEventHandlers()

 return service, nil
}

// registerEventHandlers æ³¨å†Œäº‹ä»¶å¤„ç†å™¨
func (s *OrderService) registerEventHandlers() {
 // è®¢å•åˆ›å»ºäº‹ä»¶
 s.eventBus.Subscribe("order.created", s.handleOrderCreated)

 // æ”¯ä»˜å®Œæˆäº‹ä»¶
 s.eventBus.Subscribe("payment.completed", s.handlePaymentCompleted)

 // åº“å­˜æ‰£å‡äº‹ä»¶
 s.eventBus.Subscribe("inventory.reduced", s.handleInventoryReduced)
}

// CreateOrder åˆ›å»ºè®¢å•
func (s *OrderService) CreateOrder(ctx context.Context, order *Order) error {
 // å¹‚ç­‰æ€§æ£€æŸ¥
 idempotencyKey := fmt.Sprintf("order:create:%s", order.ID)

 return s.idempotency.WithIdempotency(ctx, idempotencyKey, func() error {
  // 1. ä¿å­˜è®¢å•åˆ°æ•°æ®åº“
  if err := saveOrder(order); err != nil {
   return err
  }

  // 2. å‘å¸ƒæ¶ˆæ¯åˆ°RabbitMQ
  data, _ := json.Marshal(order)
  if err := s.producer.PublishWithConfirm(ctx, data); err != nil {
   return err
  }

  // 3. å‘å¸ƒäº‹ä»¶åˆ°äº‹ä»¶æ€»çº¿
  event := OrderCreatedEvent{
   OrderID:  order.ID,
   UserID:   order.UserID,
   Amount:   order.Amount,
   Products: order.Products,
  }

  return s.eventBus.Publish(ctx, event)
 })
}

// handleOrderCreated å¤„ç†è®¢å•åˆ›å»ºäº‹ä»¶
func (s *OrderService) handleOrderCreated(ctx context.Context, event eventbus.Event) error {
 e := event.Data().(OrderCreatedEvent)

 log.Printf("Processing order created event: %s", e.OrderID)

 // åˆ›å»ºSaga
 saga := saga.NewSaga()

 saga.AddStep("reduce_inventory",
  func(ctx context.Context) error {
   return reduceInventory(ctx, e.Products)
  },
  func(ctx context.Context) error {
   return restoreInventory(ctx, e.Products)
  },
 )

 saga.AddStep("process_payment",
  func(ctx context.Context) error {
   return processPayment(ctx, e.UserID, e.Amount)
  },
  func(ctx context.Context) error {
   return refundPayment(ctx, e.UserID, e.Amount)
  },
 )

 return saga.Execute(ctx)
}

// handlePaymentCompleted å¤„ç†æ”¯ä»˜å®Œæˆäº‹ä»¶
func (s *OrderService) handlePaymentCompleted(ctx context.Context, event eventbus.Event) error {
 // å‘é€è®¢å•ç¡®è®¤é‚®ä»¶
 // æ›´æ–°è®¢å•çŠ¶æ€
 // è§¦å‘ç‰©æµæµç¨‹
 return nil
}

// handleInventoryReduced å¤„ç†åº“å­˜æ‰£å‡äº‹ä»¶
func (s *OrderService) handleInventoryReduced(ctx context.Context, event eventbus.Event) error {
 // æ›´æ–°è®¢å•çŠ¶æ€
 // è®°å½•åº“å­˜å˜æ›´æ—¥å¿—
 return nil
}
```

---

## ğŸ“š æ¶ˆæ¯é˜Ÿåˆ—æœ€ä½³å®è·µ

### æŠ€æœ¯é€‰å‹

- **RabbitMQ**: å¤æ‚è·¯ç”±ã€äº‹åŠ¡æ”¯æŒã€å»¶è¿Ÿé˜Ÿåˆ—
- **Kafka**: é«˜ååé‡ã€æµå¤„ç†ã€æ—¥å¿—æ”¶é›†
- **Redis Stream**: è½»é‡çº§ã€ç®€å•åœºæ™¯ã€å®æ—¶æ€§

### å¯é æ€§ä¿è¯

- âœ… æ¶ˆæ¯æŒä¹…åŒ–
- âœ… ç”Ÿäº§è€…ç¡®è®¤
- âœ… æ¶ˆè´¹è€…æ‰‹åŠ¨ACK
- âœ… æ­»ä¿¡é˜Ÿåˆ—
- âœ… é‡è¯•æœºåˆ¶
- âœ… å¹‚ç­‰æ€§ä¿è¯

### æ€§èƒ½ä¼˜åŒ–

- âœ… æ‰¹é‡å‘é€
- âœ… é¢„å–æ•°é‡æ§åˆ¶
- âœ… è¿æ¥æ± ç®¡ç†
- âœ… æ¶ˆæ¯å‹ç¼©
- âœ… åˆ†åŒºç­–ç•¥

---

## ğŸ¯ æ€»ç»“

Go 1.25.3æ¶ˆæ¯é˜Ÿåˆ—å…³é”®ç‚¹ï¼š

1. **RabbitMQ**: å¯é æ¶ˆæ¯ä¼ é€’ã€å»¶è¿Ÿé˜Ÿåˆ—ã€æ­»ä¿¡
2. **Kafka**: é«˜ååæµå¤„ç†ã€æ¶ˆè´¹è€…ç»„
3. **Redis Stream**: è½»é‡çº§æµå¤„ç†
4. **å¼‚æ­¥ä»»åŠ¡**: Asynqä»»åŠ¡é˜Ÿåˆ—
5. **äº‹ä»¶é©±åŠ¨**: äº‹ä»¶æ€»çº¿ã€å‘å¸ƒè®¢é˜…
6. **å¯é æ€§**: é‡è¯•ã€å¹‚ç­‰ã€è¡¥å¿
7. **åˆ†å¸ƒå¼äº‹åŠ¡**: Sagaæ¨¡å¼

**æ¶ˆæ¯é˜Ÿåˆ—æ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿçš„ç¥ç»ç½‘ç»œï¼**

---

<div align="center">

**æŒæ¡æ¶ˆæ¯é˜Ÿåˆ—ï¼Œæ„å»ºé«˜å¯ç”¨åˆ†å¸ƒå¼ç³»ç»Ÿ**-

[ğŸ“š è¿”å›ç›®å½•](../README.md) | [ğŸ“– ä¸‹ä¸€ç« ](21-ç¼“å­˜æ¶æ„å®æˆ˜.md)

Made with â¤ï¸ for Go Developers

</div>

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2025-10-29
**Goç‰ˆæœ¬**: Go 1.25.3
**ç”Ÿäº§å°±ç»ª**: âœ…
