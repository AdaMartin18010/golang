# Go 1.25.3 API网关完整实战

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---


## 📋 目录


- [📖 文档说明](#文档说明)
- [目录](#目录)
- [1. 基础架构](#1.-基础架构)
  - [1.1 网关核心](#1.1-网关核心)
  - [1.2 路由配置](#1.2-路由配置)
- [2. 路由转发](#2.-路由转发)
  - [2.1 路由匹配](#2.1-路由匹配)
  - [2.2 反向代理](#2.2-反向代理)
- [3. 负载均衡](#3.-负载均衡)
  - [3.1 轮询策略](#3.1-轮询策略)
  - [3.2 加权轮询](#3.2-加权轮询)
  - [3.3 一致性哈希](#3.3-一致性哈希)
- [4. 服务发现](#4.-服务发现)
  - [4.1 Consul集成](#4.1-consul集成)
  - [4.2 健康检查](#4.2-健康检查)
- [5. 认证鉴权](#5.-认证鉴权)
  - [5.1 JWT验证](#5.1-jwt验证)
  - [5.2 API Key](#5.2-api-key)
- [6. 协议转换](#6.-协议转换)
  - [6.1 HTTP转gRPC](#6.1-http转grpc)
  - [6.2 WebSocket支持](#6.2-websocket支持)
- [7. API聚合](#7.-api聚合)
  - [7.1 请求聚合](#7.1-请求聚合)
  - [7.2 响应合并](#7.2-响应合并)
- [8. 完整案例](#8.-完整案例)
  - [8.1 生产级网关](#8.1-生产级网关)
- [📚 网关最佳实践](#网关最佳实践)
  - [架构设计](#架构设计)
  - [性能优化](#性能优化)
  - [安全加固](#安全加固)
  - [可观测性](#可观测性)
- [🎯 总结](#总结)

## 📖 文档说明

本文档展示Go 1.25.3的**API网关完整方案**，构建统一入口：

- ✅ 路由转发
- ✅ 负载均衡
- ✅ 服务发现
- ✅ 认证鉴权
- ✅ 限流熔断
- ✅ 协议转换
- ✅ API聚合
- ✅ 监控日志

---

## 目录

- [Go 1.25.3 API网关完整实战](#go-1.25.3-api网关完整实战)
  - [📖 文档说明](#文档说明)
  - [目录](#目录)
  - [1. 基础架构](#1.-基础架构)
    - [1.1 网关核心](#1.1-网关核心)
    - [1.2 路由配置](#1.2-路由配置)
  - [2. 路由转发](#2.-路由转发)
    - [2.1 路由匹配](#2.1-路由匹配)
    - [2.2 反向代理](#2.2-反向代理)
  - [3. 负载均衡](#3.-负载均衡)
    - [3.1 轮询策略](#3.1-轮询策略)
    - [3.2 加权轮询](#3.2-加权轮询)
    - [3.3 一致性哈希](#3.3-一致性哈希)
  - [4. 服务发现](#4.-服务发现)
    - [4.1 Consul集成](#4.1-consul集成)
    - [4.2 健康检查](#4.2-健康检查)
  - [5. 认证鉴权](#5.-认证鉴权)
    - [5.1 JWT验证](#5.1-jwt验证)
    - [5.2 API Key](#5.2-api-key)
  - [6. 协议转换](#6.-协议转换)
    - [6.1 HTTP转gRPC](#6.1-http转grpc)
    - [6.2 WebSocket支持](#6.2-websocket支持)
  - [7. API聚合](#7.-api聚合)
    - [7.1 请求聚合](#7.1-请求聚合)
    - [7.2 响应合并](#7.2-响应合并)
  - [8. 完整案例](#8.-完整案例)
    - [8.1 生产级网关](#8.1-生产级网关)
  - [📚 网关最佳实践](#网关最佳实践)
    - [架构设计](#架构设计)
    - [性能优化](#性能优化)
    - [安全加固](#安全加固)
    - [可观测性](#可观测性)
  - [🎯 总结](#总结)

---

## 1. 基础架构

### 1.1 网关核心

```go
package gateway

import (
 "context"
 "net/http"
 "sync"
)

// Gateway API网关
type Gateway struct {
 router        *Router
 balancer      LoadBalancer
 discovery     ServiceDiscovery
 authenticator Authenticator
 limiter       RateLimiter
 middleware    []Middleware
 
 mu sync.RWMutex
}

// NewGateway 创建网关
func NewGateway(config Config) *Gateway {
 return &Gateway{
  router:        NewRouter(),
  balancer:      NewLoadBalancer(config.BalanceStrategy),
  discovery:     NewServiceDiscovery(config.DiscoveryConfig),
  authenticator: NewAuthenticator(config.AuthConfig),
  limiter:       NewRateLimiter(config.LimitConfig),
  middleware:    make([]Middleware, 0),
 }
}

// ServeHTTP 处理请求
func (g *Gateway) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 ctx := r.Context()
 
 // 查找路由
 route, params, ok := g.router.Match(r.Method, r.URL.Path)
 if !ok {
  http.Error(w, "Not Found", http.StatusNotFound)
  return
 }
 
 // 设置路径参数
 ctx = context.WithValue(ctx, "params", params)
 
 // 构建处理链
 handler := g.buildHandler(route)
 
 // 执行处理
 handler.ServeHTTP(w, r.WithContext(ctx))
}

// buildHandler 构建处理链
func (g *Gateway) buildHandler(route *Route) http.Handler {
 handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  g.proxyRequest(w, r, route)
 })
 
 // 应用中间件（倒序）
 for i := len(g.middleware) - 1; i >= 0; i-- {
  handler = g.middleware[i](handler)
 }
 
 return handler
}

// Use 添加中间件
func (g *Gateway) Use(middleware ...Middleware) {
 g.middleware = append(g.middleware, middleware...)
}

// AddRoute 添加路由
func (g *Gateway) AddRoute(method, pattern string, backend *Backend) {
 g.router.Add(method, pattern, &Route{
  Backend: backend,
 })
}
```

---

### 1.2 路由配置

```go
// Route 路由
type Route struct {
 Backend     *Backend
 Rewrite     string
 Timeout     time.Duration
 RetryCount  int
 CacheTTL    time.Duration
}

// Backend 后端服务
type Backend struct {
 Name      string
 Endpoints []string
 Protocol  string
 Timeout   time.Duration
 HealthCheck *HealthCheck
}

// Config 网关配置
type Config struct {
 BalanceStrategy string
 DiscoveryConfig *DiscoveryConfig
 AuthConfig      *AuthConfig
 LimitConfig     *LimitConfig
}

// DiscoveryConfig 服务发现配置
type DiscoveryConfig struct {
 Type    string // consul, etcd, etc.
 Address string
}

// AuthConfig 认证配置
type AuthConfig struct {
 Type      string // jwt, apikey, oauth2
 SecretKey string
}

// LimitConfig 限流配置
type LimitConfig struct {
 Global  int // 全局限流
 PerIP   int // 每IP限流
 PerUser int // 每用户限流
}
```

---

## 2. 路由转发

### 2.1 路由匹配

```go
package gateway

import (
 "strings"
)

// Router 路由器
type Router struct {
 routes map[string]*routeNode
}

type routeNode struct {
 pattern  string
 handlers map[string]*Route // method -> route
 params   []string
}

// NewRouter 创建路由器
func NewRouter() *Router {
 return &Router{
  routes: make(map[string]*routeNode),
 }
}

// Add 添加路由
func (r *Router) Add(method, pattern string, route *Route) {
 node, ok := r.routes[pattern]
 if !ok {
  node = &routeNode{
   pattern:  pattern,
   handlers: make(map[string]*Route),
   params:   extractParams(pattern),
  }
  r.routes[pattern] = node
 }
 
 node.handlers[method] = route
}

// Match 匹配路由
func (r *Router) Match(method, path string) (*Route, map[string]string, bool) {
 for pattern, node := range r.routes {
  if params, ok := matchPattern(pattern, path); ok {
   if route, ok := node.handlers[method]; ok {
    return route, params, true
   }
  }
 }
 
 return nil, nil, false
}

// extractParams 提取参数
func extractParams(pattern string) []string {
 params := make([]string, 0)
 parts := strings.Split(pattern, "/")
 
 for _, part := range parts {
  if strings.HasPrefix(part, ":") {
   params = append(params, part[1:])
  }
 }
 
 return params
}

// matchPattern 匹配模式
func matchPattern(pattern, path string) (map[string]string, bool) {
 patternParts := strings.Split(pattern, "/")
 pathParts := strings.Split(path, "/")
 
 if len(patternParts) != len(pathParts) {
  return nil, false
 }
 
 params := make(map[string]string)
 
 for i, part := range patternParts {
  if strings.HasPrefix(part, ":") {
   params[part[1:]] = pathParts[i]
  } else if part != pathParts[i] {
   return nil, false
  }
 }
 
 return params, true
}
```

---

### 2.2 反向代理

```go
// proxyRequest 代理请求
func (g *Gateway) proxyRequest(w http.ResponseWriter, r *http.Request, route *Route) {
 // 1. 选择后端
 endpoint, err := g.balancer.Select(route.Backend.Endpoints)
 if err != nil {
  http.Error(w, "No available backend", http.StatusServiceUnavailable)
  return
 }
 
 // 2. 创建代理请求
 proxyReq, err := http.NewRequest(r.Method, endpoint+r.URL.Path, r.Body)
 if err != nil {
  http.Error(w, "Internal Server Error", http.StatusInternalServerError)
  return
 }
 
 // 3. 复制请求头
 copyHeaders(proxyReq.Header, r.Header)
 
 // 4. 添加X-Forwarded-*头
 proxyReq.Header.Set("X-Forwarded-For", r.RemoteAddr)
 proxyReq.Header.Set("X-Forwarded-Proto", r.URL.Scheme)
 proxyReq.Header.Set("X-Forwarded-Host", r.Host)
 
 // 5. 发送请求
 client := &http.Client{
  Timeout: route.Timeout,
 }
 
 resp, err := client.Do(proxyReq)
 if err != nil {
  http.Error(w, "Bad Gateway", http.StatusBadGateway)
  return
 }
 defer resp.Body.Close()
 
 // 6. 复制响应头
 copyHeaders(w.Header(), resp.Header)
 
 // 7. 写入响应
 w.WriteHeader(resp.StatusCode)
 io.Copy(w, resp.Body)
}

// copyHeaders 复制HTTP头
func copyHeaders(dst, src http.Header) {
 for key, values := range src {
  for _, value := range values {
   dst.Add(key, value)
  }
 }
}
```

---

## 3. 负载均衡

### 3.1 轮询策略

```go
package loadbalancer

import (
 "errors"
 "sync"
)

// RoundRobinBalancer 轮询负载均衡
type RoundRobinBalancer struct {
 current int
 mu      sync.Mutex
}

// NewRoundRobinBalancer 创建轮询负载均衡
func NewRoundRobinBalancer() *RoundRobinBalancer {
 return &RoundRobinBalancer{}
}

// Select 选择后端
func (rrb *RoundRobinBalancer) Select(endpoints []string) (string, error) {
 if len(endpoints) == 0 {
  return "", errors.New("no endpoints available")
 }
 
 rrb.mu.Lock()
 defer rrb.mu.Unlock()
 
 endpoint := endpoints[rrb.current%len(endpoints)]
 rrb.current++
 
 return endpoint, nil
}
```

---

### 3.2 加权轮询

```go
// WeightedRoundRobinBalancer 加权轮询
type WeightedRoundRobinBalancer struct {
 endpoints []WeightedEndpoint
 current   int
 gcd       int
 maxWeight int
 mu        sync.Mutex
}

// WeightedEndpoint 加权端点
type WeightedEndpoint struct {
 URL    string
 Weight int
}

// NewWeightedRoundRobinBalancer 创建加权轮询
func NewWeightedRoundRobinBalancer(endpoints []WeightedEndpoint) *WeightedRoundRobinBalancer {
 gcd := calculateGCD(endpoints)
 maxWeight := getMaxWeight(endpoints)
 
 return &WeightedRoundRobinBalancer{
  endpoints: endpoints,
  gcd:       gcd,
  maxWeight: maxWeight,
 }
}

// Select 选择后端
func (wrrb *WeightedRoundRobinBalancer) Select(endpoints []string) (string, error) {
 wrrb.mu.Lock()
 defer wrrb.mu.Unlock()
 
 for {
  wrrb.current = (wrrb.current + 1) % len(wrrb.endpoints)
  
  if wrrb.current == 0 {
   wrrb.maxWeight -= wrrb.gcd
   if wrrb.maxWeight <= 0 {
    wrrb.maxWeight = getMaxWeight(wrrb.endpoints)
   }
  }
  
  if wrrb.endpoints[wrrb.current].Weight >= wrrb.maxWeight {
   return wrrb.endpoints[wrrb.current].URL, nil
  }
 }
}

// calculateGCD 计算最大公约数
func calculateGCD(endpoints []WeightedEndpoint) int {
 divisor := 0
 for _, ep := range endpoints {
  divisor = gcd(divisor, ep.Weight)
 }
 return divisor
}

func gcd(a, b int) int {
 if b == 0 {
  return a
 }
 return gcd(b, a%b)
}

// getMaxWeight 获取最大权重
func getMaxWeight(endpoints []WeightedEndpoint) int {
 max := 0
 for _, ep := range endpoints {
  if ep.Weight > max {
   max = ep.Weight
  }
 }
 return max
}
```

---

### 3.3 一致性哈希

```go
// ConsistentHashBalancer 一致性哈希
type ConsistentHashBalancer struct {
 circle       map[uint32]string
 sortedHashes []uint32
 replicas     int
 mu           sync.RWMutex
}

// NewConsistentHashBalancer 创建一致性哈希
func NewConsistentHashBalancer(replicas int) *ConsistentHashBalancer {
 return &ConsistentHashBalancer{
  circle:   make(map[uint32]string),
  replicas: replicas,
 }
}

// AddNode 添加节点
func (chb *ConsistentHashBalancer) AddNode(endpoint string) {
 chb.mu.Lock()
 defer chb.mu.Unlock()
 
 for i := 0; i < chb.replicas; i++ {
  hash := crc32.ChecksumIEEE([]byte(fmt.Sprintf("%s:%d", endpoint, i)))
  chb.circle[hash] = endpoint
  chb.sortedHashes = append(chb.sortedHashes, hash)
 }
 
 sort.Slice(chb.sortedHashes, func(i, j int) bool {
  return chb.sortedHashes[i] < chb.sortedHashes[j]
 })
}

// Select 选择后端
func (chb *ConsistentHashBalancer) Select(key string) (string, error) {
 chb.mu.RLock()
 defer chb.mu.RUnlock()
 
 if len(chb.circle) == 0 {
  return "", errors.New("no endpoints available")
 }
 
 hash := crc32.ChecksumIEEE([]byte(key))
 
 // 二分查找
 idx := sort.Search(len(chb.sortedHashes), func(i int) bool {
  return chb.sortedHashes[i] >= hash
 })
 
 if idx == len(chb.sortedHashes) {
  idx = 0
 }
 
 return chb.circle[chb.sortedHashes[idx]], nil
}
```

---

## 4. 服务发现

### 4.1 Consul集成

```go
package discovery

import (
 "fmt"
 
 "github.com/hashicorp/consul/api"
)

// ConsulDiscovery Consul服务发现
type ConsulDiscovery struct {
 client *api.Client
}

// NewConsulDiscovery 创建Consul服务发现
func NewConsulDiscovery(address string) (*ConsulDiscovery, error) {
 config := api.DefaultConfig()
 config.Address = address
 
 client, err := api.NewClient(config)
 if err != nil {
  return nil, err
 }
 
 return &ConsulDiscovery{
  client: client,
 }, nil
}

// GetService 获取服务实例
func (cd *ConsulDiscovery) GetService(serviceName string) ([]string, error) {
 services, _, err := cd.client.Health().Service(serviceName, "", true, nil)
 if err != nil {
  return nil, err
 }
 
 endpoints := make([]string, 0, len(services))
 for _, service := range services {
  endpoint := fmt.Sprintf("http://%s:%d", service.Service.Address, service.Service.Port)
  endpoints = append(endpoints, endpoint)
 }
 
 return endpoints, nil
}

// WatchService 监听服务变化
func (cd *ConsulDiscovery) WatchService(serviceName string, callback func([]string)) {
 go func() {
  var lastIndex uint64
  
  for {
   services, meta, err := cd.client.Health().Service(
    serviceName, "", true, &api.QueryOptions{
     WaitIndex: lastIndex,
     WaitTime:  time.Minute,
    })
   
   if err != nil {
    time.Sleep(time.Second * 5)
    continue
   }
   
   lastIndex = meta.LastIndex
   
   endpoints := make([]string, 0, len(services))
   for _, service := range services {
    endpoint := fmt.Sprintf("http://%s:%d", service.Service.Address, service.Service.Port)
    endpoints = append(endpoints, endpoint)
   }
   
   callback(endpoints)
  }
 }()
}
```

---

### 4.2 健康检查

```go
// HealthChecker 健康检查器
type HealthChecker struct {
 endpoints map[string]*EndpointHealth
 mu        sync.RWMutex
}

// EndpointHealth 端点健康状态
type EndpointHealth struct {
 URL           string
 Healthy       bool
 LastCheck     time.Time
 FailureCount  int
 SuccessCount  int
}

// NewHealthChecker 创建健康检查器
func NewHealthChecker() *HealthChecker {
 hc := &HealthChecker{
  endpoints: make(map[string]*EndpointHealth),
 }
 
 go hc.startChecking()
 
 return hc
}

// AddEndpoint 添加端点
func (hc *HealthChecker) AddEndpoint(url string) {
 hc.mu.Lock()
 defer hc.mu.Unlock()
 
 hc.endpoints[url] = &EndpointHealth{
  URL:     url,
  Healthy: true,
 }
}

// IsHealthy 检查是否健康
func (hc *HealthChecker) IsHealthy(url string) bool {
 hc.mu.RLock()
 defer hc.mu.RUnlock()
 
 if health, ok := hc.endpoints[url]; ok {
  return health.Healthy
 }
 
 return false
}

// startChecking 开始检查
func (hc *HealthChecker) startChecking() {
 ticker := time.NewTicker(10 * time.Second)
 defer ticker.Stop()
 
 for range ticker.C {
  hc.mu.RLock()
  endpoints := make([]*EndpointHealth, 0, len(hc.endpoints))
  for _, ep := range hc.endpoints {
   endpoints = append(endpoints, ep)
  }
  hc.mu.RUnlock()
  
  for _, ep := range endpoints {
   go hc.checkEndpoint(ep)
  }
 }
}

// checkEndpoint 检查端点
func (hc *HealthChecker) checkEndpoint(ep *EndpointHealth) {
 client := &http.Client{
  Timeout: 5 * time.Second,
 }
 
 resp, err := client.Get(ep.URL + "/health")
 
 hc.mu.Lock()
 defer hc.mu.Unlock()
 
 ep.LastCheck = time.Now()
 
 if err != nil || resp.StatusCode != http.StatusOK {
  ep.FailureCount++
  ep.SuccessCount = 0
  
  if ep.FailureCount >= 3 {
   ep.Healthy = false
  }
 } else {
  ep.SuccessCount++
  ep.FailureCount = 0
  
  if ep.SuccessCount >= 2 {
   ep.Healthy = true
  }
 }
}
```

---

## 5. 认证鉴权

### 5.1 JWT验证

```go
// JWTAuthMiddleware JWT认证中间件
func JWTAuthMiddleware(jwtManager *auth.JWTManager) Middleware {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   // 获取token
   token := r.Header.Get("Authorization")
   if token == "" {
    http.Error(w, "Missing authorization", http.StatusUnauthorized)
    return
   }
   
   // 移除Bearer前缀
   if len(token) > 7 && token[:7] == "Bearer " {
    token = token[7:]
   }
   
   // 验证token
   claims, err := jwtManager.ValidateToken(token)
   if err != nil {
    http.Error(w, "Invalid token", http.StatusUnauthorized)
    return
   }
   
   // 设置用户信息到context
   ctx := context.WithValue(r.Context(), "user", claims)
   next.ServeHTTP(w, r.WithContext(ctx))
  })
 }
}
```

---

### 5.2 API Key

```go
// APIKeyAuthMiddleware API Key认证中间件
func APIKeyAuthMiddleware(store APIKeyStore) Middleware {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   // 获取API Key
   apiKey := r.Header.Get("X-API-Key")
   if apiKey == "" {
    http.Error(w, "Missing API key", http.StatusUnauthorized)
    return
   }
   
   // 验证API Key
   user, err := store.Validate(r.Context(), apiKey)
   if err != nil {
    http.Error(w, "Invalid API key", http.StatusUnauthorized)
    return
   }
   
   // 设置用户信息到context
   ctx := context.WithValue(r.Context(), "user", user)
   next.ServeHTTP(w, r.WithContext(ctx))
  })
 }
}

// APIKeyStore API Key存储接口
type APIKeyStore interface {
 Validate(ctx context.Context, apiKey string) (*User, error)
}
```

---

## 6. 协议转换

### 6.1 HTTP转gRPC

```go
package protocol

import (
 "context"
 "encoding/json"
 "net/http"
 
 "google.golang.org/grpc"
)

// HTTPToGRPCHandler HTTP转gRPC处理器
type HTTPToGRPCHandler struct {
 conn *grpc.ClientConn
}

// NewHTTPToGRPCHandler 创建HTTP转gRPC处理器
func NewHTTPToGRPCHandler(target string) (*HTTPToGRPCHandler, error) {
 conn, err := grpc.Dial(target, grpc.WithInsecure())
 if err != nil {
  return nil, err
 }
 
 return &HTTPToGRPCHandler{
  conn: conn,
 }, nil
}

// ServeHTTP 处理HTTP请求
func (h *HTTPToGRPCHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 // 1. 解析HTTP请求体
 var reqData map[string]interface{}
 if err := json.NewDecoder(r.Body).Decode(&reqData); err != nil {
  http.Error(w, "Invalid request body", http.StatusBadRequest)
  return
 }
 
 // 2. 转换为gRPC请求
 // 这里需要根据具体的proto定义进行转换
 // ...
 
 // 3. 调用gRPC服务
 ctx := r.Context()
 // resp, err := grpcClient.Method(ctx, grpcReq)
 
 // 4. 转换gRPC响应为HTTP响应
 // ...
 
 // 5. 返回HTTP响应
 w.Header().Set("Content-Type", "application/json")
 // json.NewEncoder(w).Encode(httpResp)
}
```

---

### 6.2 WebSocket支持

```go
// WebSocketProxy WebSocket代理
type WebSocketProxy struct {
 target string
}

// NewWebSocketProxy 创建WebSocket代理
func NewWebSocketProxy(target string) *WebSocketProxy {
 return &WebSocketProxy{
  target: target,
 }
}

// ServeHTTP 处理WebSocket请求
func (wsp *WebSocketProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 // 升级到WebSocket
 upgrader := websocket.Upgrader{
  CheckOrigin: func(r *http.Request) bool {
   return true
  },
 }
 
 clientConn, err := upgrader.Upgrade(w, r, nil)
 if err != nil {
  return
 }
 defer clientConn.Close()
 
 // 连接后端WebSocket
 backendConn, _, err := websocket.DefaultDialer.Dial(wsp.target, nil)
 if err != nil {
  return
 }
 defer backendConn.Close()
 
 // 双向转发
 go func() {
  for {
   messageType, data, err := clientConn.ReadMessage()
   if err != nil {
    return
   }
   
   if err := backendConn.WriteMessage(messageType, data); err != nil {
    return
   }
  }
 }()
 
 for {
  messageType, data, err := backendConn.ReadMessage()
  if err != nil {
   return
  }
  
  if err := clientConn.WriteMessage(messageType, data); err != nil {
   return
  }
 }
}
```

---

## 7. API聚合

### 7.1 请求聚合

```go
package aggregator

import (
 "context"
 "encoding/json"
 "net/http"
 "sync"
)

// Aggregator API聚合器
type Aggregator struct {
 requests []AggregateRequest
}

// AggregateRequest 聚合请求
type AggregateRequest struct {
 Name   string
 URL    string
 Method string
}

// NewAggregator 创建聚合器
func NewAggregator(requests []AggregateRequest) *Aggregator {
 return &Aggregator{
  requests: requests,
 }
}

// Execute 执行聚合请求
func (a *Aggregator) Execute(ctx context.Context) (map[string]interface{}, error) {
 results := make(map[string]interface{})
 var mu sync.Mutex
 var wg sync.WaitGroup
 
 errChan := make(chan error, len(a.requests))
 
 for _, req := range a.requests {
  wg.Add(1)
  
  go func(r AggregateRequest) {
   defer wg.Done()
   
   // 发送HTTP请求
   httpReq, err := http.NewRequestWithContext(ctx, r.Method, r.URL, nil)
   if err != nil {
    errChan <- err
    return
   }
   
   client := &http.Client{
    Timeout: 5 * time.Second,
   }
   
   resp, err := client.Do(httpReq)
   if err != nil {
    errChan <- err
    return
   }
   defer resp.Body.Close()
   
   // 解析响应
   var data interface{}
   if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
    errChan <- err
    return
   }
   
   // 保存结果
   mu.Lock()
   results[r.Name] = data
   mu.Unlock()
  }(req)
 }
 
 wg.Wait()
 close(errChan)
 
 // 检查错误
 for err := range errChan {
  if err != nil {
   return nil, err
  }
 }
 
 return results, nil
}
```

---

### 7.2 响应合并

```go
// AggregatorMiddleware 聚合中间件
func AggregatorMiddleware() Middleware {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   // 检查是否需要聚合
   if r.Header.Get("X-Aggregate") != "true" {
    next.ServeHTTP(w, r)
    return
   }
   
   // 解析聚合请求
   var aggReqs []AggregateRequest
   if err := json.NewDecoder(r.Body).Decode(&aggReqs); err != nil {
    http.Error(w, "Invalid aggregate request", http.StatusBadRequest)
    return
   }
   
   // 执行聚合
   aggregator := NewAggregator(aggReqs)
   results, err := aggregator.Execute(r.Context())
   if err != nil {
    http.Error(w, "Aggregation failed", http.StatusInternalServerError)
    return
   }
   
   // 返回结果
   w.Header().Set("Content-Type", "application/json")
   json.NewEncoder(w).Encode(results)
  })
 }
}
```

---

## 8. 完整案例

### 8.1 生产级网关

```go
package main

import (
 "log"
 "net/http"
 "time"
)

func main() {
 // 1. 创建网关配置
 config := gateway.Config{
  BalanceStrategy: "round_robin",
  DiscoveryConfig: &gateway.DiscoveryConfig{
   Type:    "consul",
   Address: "localhost:8500",
  },
  AuthConfig: &gateway.AuthConfig{
   Type:      "jwt",
   SecretKey: "my-secret-key",
  },
  LimitConfig: &gateway.LimitConfig{
   Global:  10000,
   PerIP:   100,
   PerUser: 1000,
  },
 }
 
 // 2. 创建网关
 gw := gateway.NewGateway(config)
 
 // 3. 添加全局中间件
 gw.Use(
  LoggingMiddleware(),
  RecoveryMiddleware(),
  CORSMiddleware(),
  RateLimitMiddleware(config.LimitConfig),
  JWTAuthMiddleware(jwtManager),
  TracingMiddleware(),
 )
 
 // 4. 添加路由
 gw.AddRoute("GET", "/api/users/:id", &gateway.Backend{
  Name:      "user-service",
  Endpoints: []string{"http://localhost:8081"},
  Protocol:  "http",
  Timeout:   5 * time.Second,
 })
 
 gw.AddRoute("POST", "/api/orders", &gateway.Backend{
  Name:      "order-service",
  Endpoints: []string{"http://localhost:8082"},
  Protocol:  "http",
  Timeout:   10 * time.Second,
 })
 
 // 5. 启动服务发现监听
 discovery, _ := discovery.NewConsulDiscovery("localhost:8500")
 discovery.WatchService("user-service", func(endpoints []string) {
  log.Printf("User service endpoints updated: %v", endpoints)
  // 更新后端端点
 })
 
 // 6. 启动网关
 server := &http.Server{
  Addr:         ":8080",
  Handler:      gw,
  ReadTimeout:  10 * time.Second,
  WriteTimeout: 10 * time.Second,
  IdleTimeout:  120 * time.Second,
 }
 
 log.Println("API Gateway starting on :8080")
 log.Fatal(server.ListenAndServe())
}

// LoggingMiddleware 日志中间件
func LoggingMiddleware() gateway.Middleware {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   start := time.Now()
   
   recorder := &statusRecorder{
    ResponseWriter: w,
    statusCode:     http.StatusOK,
   }
   
   next.ServeHTTP(recorder, r)
   
   log.Printf("%s %s %d %v", r.Method, r.URL.Path, recorder.statusCode, time.Since(start))
  })
 }
}

// RecoveryMiddleware 恢复中间件
func RecoveryMiddleware() gateway.Middleware {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   defer func() {
    if err := recover(); err != nil {
     log.Printf("Panic recovered: %v", err)
     http.Error(w, "Internal Server Error", http.StatusInternalServerError)
    }
   }()
   
   next.ServeHTTP(w, r)
  })
 }
}

// CORSMiddleware CORS中间件
func CORSMiddleware() gateway.Middleware {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   w.Header().Set("Access-Control-Allow-Origin", "*")
   w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
   w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
   
   if r.Method == "OPTIONS" {
    w.WriteHeader(http.StatusOK)
    return
   }
   
   next.ServeHTTP(w, r)
  })
 }
}

type statusRecorder struct {
 http.ResponseWriter
 statusCode int
}

func (sr *statusRecorder) WriteHeader(code int) {
 sr.statusCode = code
 sr.ResponseWriter.WriteHeader(code)
}
```

---

## 📚 网关最佳实践

### 架构设计

- ✅ 无状态设计，易于水平扩展
- ✅ 服务发现，动态路由
- ✅ 异步日志，提升性能
- ✅ 熔断降级，保护后端

### 性能优化

- ✅ 连接池复用
- ✅ 响应缓存
- ✅ 请求批处理
- ✅ 协议优化（HTTP/2、gRPC）

### 安全加固

- ✅ 认证鉴权
- ✅ 限流防刷
- ✅ DDoS防护
- ✅ 数据加密

### 可观测性

- ✅ 请求追踪
- ✅ 性能监控
- ✅ 错误告警
- ✅ 审计日志

---

## 🎯 总结

Go 1.25.3 API网关关键点：

1. **路由转发**: 模式匹配、反向代理、请求重写
2. **负载均衡**: 轮询、加权、一致性哈希
3. **服务发现**: Consul集成、健康检查、动态更新
4. **认证鉴权**: JWT、API Key、OAuth 2.0
5. **限流熔断**: 多级限流、熔断降级、过载保护
6. **协议转换**: HTTP/gRPC、WebSocket、双向流
7. **API聚合**: 并发请求、响应合并、超时控制

**API网关是微服务架构的统一入口！**

---

<div align="center">

**构建高性能API网关**:

[📚 返回目录](../README.md) | [📖 下一章](26-下一主题.md)

Made with ❤️ for Go Developers

</div>

---

**文档版本**: v1.0  
**最后更新**: 2025-10-29  
**Go版本**: Go 1.25.3  
**生产就绪**: ✅
