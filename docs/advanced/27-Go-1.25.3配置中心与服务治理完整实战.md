# Go 1.25.3 配置中心与服务治理完整实战

**版本**: v1.0
**更新日期**: 2025-10-29
**适用于**: Go 1.25.3

---

## 📋 目录

- [Go 1.25.3 配置中心与服务治理完整实战](#go-1253-配置中心与服务治理完整实战)
  - [📋 目录](#-目录)
  - [📖 文档说明](#-文档说明)
  - [1. 配置中心](#1-配置中心)
    - [1.1 本地配置管理](#11-本地配置管理)
    - [1.2 配置文件加载](#12-配置文件加载)
  - [2. Consul配置中心](#2-consul配置中心)
    - [2.1 Consul客户端](#21-consul客户端)
    - [2.2 配置监听](#22-配置监听)
  - [3. Nacos配置中心](#3-nacos配置中心)
    - [3.1 Nacos集成](#31-nacos集成)
    - [3.2 配置变更监听](#32-配置变更监听)
  - [4. 配置热更新](#4-配置热更新)
    - [4.1 配置观察者](#41-配置观察者)
    - [4.2 自动重载](#42-自动重载)
  - [5. 灰度发布](#5-灰度发布)
    - [5.1 灰度策略](#51-灰度策略)
    - [5.2 流量分发](#52-流量分发)
  - [6. 服务注册](#6-服务注册)
    - [6.1 服务注册器](#61-服务注册器)
    - [6.2 自动注册](#62-自动注册)
  - [7. 服务发现](#7-服务发现)
    - [7.1 服务发现器](#71-服务发现器)
    - [7.2 负载均衡](#72-负载均衡)
  - [8. 完整案例](#8-完整案例)
    - [8.1 微服务治理平台](#81-微服务治理平台)
  - [📚 配置中心最佳实践](#-配置中心最佳实践)
    - [配置管理](#配置管理)
    - [服务治理](#服务治理)
    - [灰度策略](#灰度策略)
    - [监控告警](#监控告警)
  - [🎯 总结](#-总结)

---

## 📖 文档说明

本文档展示Go 1.25.3的**配置中心与服务治理完整方案**，实现动态配置：

- ✅ 配置中心
- ✅ 动态配置
- ✅ 配置热更新
- ✅ 灰度发布
- ✅ 服务注册
- ✅ 服务发现
- ✅ 健康检查
- ✅ 元数据管理

---

## 1. 配置中心

### 1.1 本地配置管理

```go
package config

import (
 "sync"
 "time"
)

// Config 配置结构
type Config struct {
 Server   ServerConfig   `json:"server" yaml:"server"`
 Database DatabaseConfig `json:"database" yaml:"database"`
 Redis    RedisConfig    `json:"redis" yaml:"redis"`
 Log      LogConfig      `json:"log" yaml:"log"`
}

// ServerConfig 服务器配置
type ServerConfig struct {
 Host         string        `json:"host" yaml:"host"`
 Port         int           `json:"port" yaml:"port"`
 ReadTimeout  time.Duration `json:"read_timeout" yaml:"read_timeout"`
 WriteTimeout time.Duration `json:"write_timeout" yaml:"write_timeout"`
}

// DatabaseConfig 数据库配置
type DatabaseConfig struct {
 Driver          string `json:"driver" yaml:"driver"`
 DSN             string `json:"dsn" yaml:"dsn"`
 MaxOpenConns    int    `json:"max_open_conns" yaml:"max_open_conns"`
 MaxIdleConns    int    `json:"max_idle_conns" yaml:"max_idle_conns"`
 ConnMaxLifetime time.Duration `json:"conn_max_lifetime" yaml:"conn_max_lifetime"`
}

// RedisConfig Redis配置
type RedisConfig struct {
 Addr     string `json:"addr" yaml:"addr"`
 Password string `json:"password" yaml:"password"`
 DB       int    `json:"db" yaml:"db"`
}

// LogConfig 日志配置
type LogConfig struct {
 Level  string `json:"level" yaml:"level"`
 Format string `json:"format" yaml:"format"`
 Output string `json:"output" yaml:"output"`
}

// Manager 配置管理器
type Manager struct {
 config    *Config
 mu        sync.RWMutex
 observers []Observer
}

// Observer 配置观察者
type Observer interface {
 OnConfigChange(config *Config)
}

// NewManager 创建配置管理器
func NewManager() *Manager {
 return &Manager{
  config:    &Config{},
  observers: make([]Observer, 0),
 }
}

// Load 加载配置
func (m *Manager) Load(config *Config) {
 m.mu.Lock()
 defer m.mu.Unlock()

 oldConfig := m.config
 m.config = config

 // 通知观察者
 if oldConfig != nil {
  m.notifyObservers()
 }
}

// Get 获取配置
func (m *Manager) Get() *Config {
 m.mu.RLock()
 defer m.mu.RUnlock()

 return m.config
}

// AddObserver 添加观察者
func (m *Manager) AddObserver(observer Observer) {
 m.mu.Lock()
 defer m.mu.Unlock()

 m.observers = append(m.observers, observer)
}

// notifyObservers 通知所有观察者
func (m *Manager) notifyObservers() {
 for _, observer := range m.observers {
  go observer.OnConfigChange(m.config)
 }
}
```

---

### 1.2 配置文件加载

```go
package config

import (
 "fmt"
 "os"

 "gopkg.in/yaml.v3"
)

// Loader 配置加载器
type Loader struct {
 filePath string
}

// NewLoader 创建配置加载器
func NewLoader(filePath string) *Loader {
 return &Loader{
  filePath: filePath,
 }
}

// Load 加载配置文件
func (l *Loader) Load() (*Config, error) {
 data, err := os.ReadFile(l.filePath)
 if err != nil {
  return nil, fmt.Errorf("read config file: %w", err)
 }

 var config Config
 if err := yaml.Unmarshal(data, &config); err != nil {
  return nil, fmt.Errorf("unmarshal config: %w", err)
 }

 return &config, nil
}

// Watch 监听配置文件变化
func (l *Loader) Watch(callback func(*Config)) error {
 watcher, err := fsnotify.NewWatcher()
 if err != nil {
  return err
 }

 go func() {
  defer watcher.Close()

  for {
   select {
   case event := <-watcher.Events:
    if event.Op&fsnotify.Write == fsnotify.Write {
     config, err := l.Load()
     if err != nil {
      fmt.Printf("Failed to reload config: %v\n", err)
      continue
     }

     callback(config)
    }
   case err := <-watcher.Errors:
    fmt.Printf("Watcher error: %v\n", err)
   }
  }
 }()

 return watcher.Add(l.filePath)
}
```

---

## 2. Consul配置中心

### 2.1 Consul客户端

```go
package consul

import (
 "Context"
 "encoding/json"
 "fmt"

 "github.com/hashicorp/consul/api"
)

// ConfigCenter Consul配置中心
type ConfigCenter struct {
 client *api.Client
 prefix string
}

// NewConfigCenter 创建Consul配置中心
func NewConfigCenter(address, prefix string) (*ConfigCenter, error) {
 config := api.DefaultConfig()
 config.Address = address

 client, err := api.NewClient(config)
 if err != nil {
  return nil, err
 }

 return &ConfigCenter{
  client: client,
  prefix: prefix,
 }, nil
}

// Get 获取配置
func (cc *ConfigCenter) Get(ctx Context.Context, key string) ([]byte, error) {
 fullKey := fmt.Sprintf("%s/%s", cc.prefix, key)

 pair, _, err := cc.client.KV().Get(fullKey, nil)
 if err != nil {
  return nil, err
 }

 if pair == nil {
  return nil, fmt.Errorf("config not found: %s", key)
 }

 return pair.Value, nil
}

// Set 设置配置
func (cc *ConfigCenter) Set(ctx Context.Context, key string, value []byte) error {
 fullKey := fmt.Sprintf("%s/%s", cc.prefix, key)

 pair := &api.KVPair{
  Key:   fullKey,
  Value: value,
 }

 _, err := cc.client.KV().Put(pair, nil)
 return err
}

// GetConfig 获取配置对象
func (cc *ConfigCenter) GetConfig(ctx Context.Context, key string, config interface{}) error {
 data, err := cc.Get(ctx, key)
 if err != nil {
  return err
 }

 return json.Unmarshal(data, config)
}

// SetConfig 设置配置对象
func (cc *ConfigCenter) SetConfig(ctx Context.Context, key string, config interface{}) error {
 data, err := json.Marshal(config)
 if err != nil {
  return err
 }

 return cc.Set(ctx, key, data)
}
```

---

### 2.2 配置监听

```go
// Watch 监听配置变化
func (cc *ConfigCenter) Watch(ctx Context.Context, key string, callback func([]byte)) error {
 fullKey := fmt.Sprintf("%s/%s", cc.prefix, key)

 go func() {
  var lastIndex uint64

  for {
   select {
   case <-ctx.Done():
    return
   default:
    pair, meta, err := cc.client.KV().Get(fullKey, &api.QueryOptions{
     WaitIndex: lastIndex,
     WaitTime:  time.Minute,
    })

    if err != nil {
     fmt.Printf("Watch error: %v\n", err)
     time.Sleep(time.Second * 5)
     continue
    }

    if meta.LastIndex == lastIndex {
     continue
    }

    lastIndex = meta.LastIndex

    if pair != nil {
     callback(pair.Value)
    }
   }
  }
 }()

 return nil
}

// WatchConfig 监听配置对象变化
func (cc *ConfigCenter) WatchConfig(ctx Context.Context, key string, config interface{}, callback func()) error {
 return cc.Watch(ctx, key, func(data []byte) {
  if err := json.Unmarshal(data, config); err != nil {
   fmt.Printf("Unmarshal config error: %v\n", err)
   return
  }

  callback()
 })
}
```

---

## 3. Nacos配置中心

### 3.1 Nacos集成

```go
package nacos

import (
 "github.com/nacos-group/nacos-sdk-go/clients"
 "github.com/nacos-group/nacos-sdk-go/clients/config_client"
 "github.com/nacos-group/nacos-sdk-go/common/constant"
 "github.com/nacos-group/nacos-sdk-go/vo"
)

// ConfigCenter Nacos配置中心
type ConfigCenter struct {
 client    config_client.IConfigClient
 namespace string
 group     string
}

// NewConfigCenter 创建Nacos配置中心
func NewConfigCenter(serverAddr, namespace, group string) (*ConfigCenter, error) {
 // 创建ServerConfig
 sc := []constant.ServerConfig{
  *constant.NewServerConfig(serverAddr, 8848),
 }

 // 创建ClientConfig
 cc := *constant.NewClientConfig(
  constant.WithNamespaceId(namespace),
  constant.WithTimeoutMs(5000),
  constant.WithNotLoadCacheAtStart(true),
 )

 // 创建配置客户端
 client, err := clients.NewConfigClient(
  vo.NacosClientParam{
   ClientConfig:  &cc,
   ServerConfigs: sc,
  },
 )

 if err != nil {
  return nil, err
 }

 return &ConfigCenter{
  client:    client,
  namespace: namespace,
  group:     group,
 }, nil
}

// GetConfig 获取配置
func (nc *ConfigCenter) GetConfig(dataID string) (string, error) {
 content, err := nc.client.GetConfig(vo.ConfigParam{
  DataId: dataID,
  Group:  nc.group,
 })

 return content, err
}

// PublishConfig 发布配置
func (nc *ConfigCenter) PublishConfig(dataID, content string) error {
 _, err := nc.client.PublishConfig(vo.ConfigParam{
  DataId:  dataID,
  Group:   nc.group,
  Content: content,
 })

 return err
}

// DeleteConfig 删除配置
func (nc *ConfigCenter) DeleteConfig(dataID string) error {
 _, err := nc.client.DeleteConfig(vo.ConfigParam{
  DataId: dataID,
  Group:  nc.group,
 })

 return err
}
```

---

### 3.2 配置变更监听

```go
// ListenConfig 监听配置变化
func (nc *ConfigCenter) ListenConfig(dataID string, callback func(string)) error {
 return nc.client.ListenConfig(vo.ConfigParam{
  DataId: dataID,
  Group:  nc.group,
  OnChange: func(namespace, group, dataId, data string) {
   callback(data)
  },
 })
}

// CancelListenConfig 取消监听
func (nc *ConfigCenter) CancelListenConfig(dataID string) error {
 return nc.client.CancelListenConfig(vo.ConfigParam{
  DataId: dataID,
  Group:  nc.group,
 })
}
```

---

## 4. 配置热更新

### 4.1 配置观察者

```go
package hotreload

import (
 "fmt"
 "sync"
)

// Reloader 配置重载器
type Reloader struct {
 handlers map[string][]ReloadHandler
 mu       sync.RWMutex
}

// ReloadHandler 重载处理器
type ReloadHandler func(config interface{}) error

// NewReloader 创建配置重载器
func NewReloader() *Reloader {
 return &Reloader{
  handlers: make(map[string][]ReloadHandler),
 }
}

// Register 注册重载处理器
func (r *Reloader) Register(key string, handler ReloadHandler) {
 r.mu.Lock()
 defer r.mu.Unlock()

 if r.handlers[key] == nil {
  r.handlers[key] = make([]ReloadHandler, 0)
 }

 r.handlers[key] = append(r.handlers[key], handler)
}

// Reload 触发重载
func (r *Reloader) Reload(key string, config interface{}) error {
 r.mu.RLock()
 handlers, ok := r.handlers[key]
 r.mu.RUnlock()

 if !ok {
  return nil
 }

 for _, handler := range handlers {
  if err := handler(config); err != nil {
   return fmt.Errorf("reload handler error: %w", err)
  }
 }

 return nil
}

// DatabaseReloader 数据库连接重载器
type DatabaseReloader struct {
 db *sql.DB
 mu sync.Mutex
}

// NewDatabaseReloader 创建数据库重载器
func NewDatabaseReloader(db *sql.DB) *DatabaseReloader {
 return &DatabaseReloader{
  db: db,
 }
}

// Reload 重载数据库连接
func (dr *DatabaseReloader) Reload(config interface{}) error {
 dr.mu.Lock()
 defer dr.mu.Unlock()

 dbConfig := config.(*DatabaseConfig)

 // 设置新的连接参数
 dr.db.SetMaxOpenConns(dbConfig.MaxOpenConns)
 dr.db.SetMaxIdleConns(dbConfig.MaxIdleConns)
 dr.db.SetConnMaxLifetime(dbConfig.ConnMaxLifetime)

 return nil
}
```

---

### 4.2 自动重载

```go
// AutoReloader 自动重载器
type AutoReloader struct {
 configCenter ConfigCenter
 reloader     *Reloader
 manager      *config.Manager
}

// NewAutoReloader 创建自动重载器
func NewAutoReloader(
 configCenter ConfigCenter,
 reloader *Reloader,
 manager *config.Manager,
) *AutoReloader {
 return &AutoReloader{
  configCenter: configCenter,
  reloader:     reloader,
  manager:      manager,
 }
}

// Start 启动自动重载
func (ar *AutoReloader) Start(ctx Context.Context, keys []string) error {
 for _, key := range keys {
  if err := ar.watchKey(ctx, key); err != nil {
   return err
  }
 }

 return nil
}

// watchKey 监听配置键
func (ar *AutoReloader) watchKey(ctx Context.Context, key string) error {
 return ar.configCenter.Watch(ctx, key, func(data []byte) {
  var config interface{}

  switch key {
  case "database":
   config = &DatabaseConfig{}
  case "redis":
   config = &RedisConfig{}
  case "server":
   config = &ServerConfig{}
  default:
   return
  }

  if err := json.Unmarshal(data, config); err != nil {
   fmt.Printf("Unmarshal config error: %v\n", err)
   return
  }

  // 触发重载
  if err := ar.reloader.Reload(key, config); err != nil {
   fmt.Printf("Reload error: %v\n", err)
   return
  }

  // 更新配置管理器
  fullConfig := ar.manager.Get()
  switch key {
  case "database":
   fullConfig.Database = *config.(*DatabaseConfig)
  case "redis":
   fullConfig.Redis = *config.(*RedisConfig)
  case "server":
   fullConfig.Server = *config.(*ServerConfig)
  }

  ar.manager.Load(fullConfig)

  fmt.Printf("Config reloaded: %s\n", key)
 })
}
```

---

## 5. 灰度发布

### 5.1 灰度策略

```go
package grayscale

import (
 "hash/fnv"
 "math/rand"
)

// Strategy 灰度策略接口
type Strategy interface {
 ShouldUseGray(userID string) bool
}

// PercentageStrategy 百分比策略
type PercentageStrategy struct {
 percentage int // 0-100
}

// NewPercentageStrategy 创建百分比策略
func NewPercentageStrategy(percentage int) *PercentageStrategy {
 return &PercentageStrategy{
  percentage: percentage,
 }
}

// ShouldUseGray 判断是否使用灰度版本
func (ps *PercentageStrategy) ShouldUseGray(userID string) bool {
 h := fnv.New32a()
 h.Write([]byte(userID))
 hash := h.Sum32()

 return int(hash%100) < ps.percentage
}

// WhitelistStrategy 白名单策略
type WhitelistStrategy struct {
 whitelist map[string]bool
}

// NewWhitelistStrategy 创建白名单策略
func NewWhitelistStrategy(users []string) *WhitelistStrategy {
 whitelist := make(map[string]bool)
 for _, user := range users {
  whitelist[user] = true
 }

 return &WhitelistStrategy{
  whitelist: whitelist,
 }
}

// ShouldUseGray 判断是否使用灰度版本
func (ws *WhitelistStrategy) ShouldUseGray(userID string) bool {
 return ws.whitelist[userID]
}

// CompositeStrategy 组合策略
type CompositeStrategy struct {
 strategies []Strategy
 mode       CompositeMode
}

// CompositeMode 组合模式
type CompositeMode int

const (
 ModeAny CompositeMode = iota // 任意一个满足
 ModeAll                       // 全部满足
)

// NewCompositeStrategy 创建组合策略
func NewCompositeStrategy(mode CompositeMode, strategies ...Strategy) *CompositeStrategy {
 return &CompositeStrategy{
  strategies: strategies,
  mode:       mode,
 }
}

// ShouldUseGray 判断是否使用灰度版本
func (cs *CompositeStrategy) ShouldUseGray(userID string) bool {
 if cs.mode == ModeAll {
  for _, strategy := range cs.strategies {
   if !strategy.ShouldUseGray(userID) {
    return false
   }
  }
  return true
 }

 // ModeAny
 for _, strategy := range cs.strategies {
  if strategy.ShouldUseGray(userID) {
   return true
  }
 }
 return false
}
```

---

### 5.2 流量分发

```go
// TrafficRouter 流量路由器
type TrafficRouter struct {
 strategy      Strategy
 stableBackend []string
 grayBackend   []string
 mu            sync.RWMutex
}

// NewTrafficRouter 创建流量路由器
func NewTrafficRouter(
 strategy Strategy,
 stableBackend, grayBackend []string,
) *TrafficRouter {
 return &TrafficRouter{
  strategy:      strategy,
  stableBackend: stableBackend,
  grayBackend:   grayBackend,
 }
}

// Route 路由选择后端
func (tr *TrafficRouter) Route(userID string) []string {
 tr.mu.RLock()
 defer tr.mu.RUnlock()

 if tr.strategy.ShouldUseGray(userID) {
  return tr.grayBackend
 }

 return tr.stableBackend
}

// UpdateStrategy 更新策略
func (tr *TrafficRouter) UpdateStrategy(strategy Strategy) {
 tr.mu.Lock()
 defer tr.mu.Unlock()

 tr.strategy = strategy
}

// UpdateBackends 更新后端列表
func (tr *TrafficRouter) UpdateBackends(stable, gray []string) {
 tr.mu.Lock()
 defer tr.mu.Unlock()

 tr.stableBackend = stable
 tr.grayBackend = gray
}

// GrayMiddleware 灰度中间件
func GrayMiddleware(router *TrafficRouter) func(http.Handler) http.Handler {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   // 获取用户ID
   userID := r.Header.Get("X-User-ID")
   if userID == "" {
    userID = r.RemoteAddr
   }

   // 选择后端
   backends := router.Route(userID)

   // 设置到context
   ctx := Context.WithValue(r.Context(), "backends", backends)

   next.ServeHTTP(w, r.WithContext(ctx))
  })
 }
}
```

---

## 6. 服务注册

### 6.1 服务注册器

```go
package registry

import (
 "Context"
 "fmt"
 "time"

 "github.com/hashicorp/consul/api"
)

// ServiceRegistry 服务注册器
type ServiceRegistry struct {
 client *api.Client
}

// ServiceInfo 服务信息
type ServiceInfo struct {
 ID      string
 Name    string
 Address string
 Port    int
 Tags    []string
 Meta    map[string]string
 Check   *HealthCheck
}

// HealthCheck 健康检查
type HealthCheck struct {
 HTTP                           string
 Interval                       time.Duration
 Timeout                        time.Duration
 DeregisterCriticalServiceAfter time.Duration
}

// NewServiceRegistry 创建服务注册器
func NewServiceRegistry(address string) (*ServiceRegistry, error) {
 config := api.DefaultConfig()
 config.Address = address

 client, err := api.NewClient(config)
 if err != nil {
  return nil, err
 }

 return &ServiceRegistry{
  client: client,
 }, nil
}

// Register 注册服务
func (sr *ServiceRegistry) Register(ctx Context.Context, info *ServiceInfo) error {
 registration := &api.AgentServiceRegistration{
  ID:      info.ID,
  Name:    info.Name,
  Address: info.Address,
  Port:    info.Port,
  Tags:    info.Tags,
  Meta:    info.Meta,
 }

 // 添加健康检查
 if info.Check != nil {
  registration.Check = &api.AgentServiceCheck{
   HTTP:                           info.Check.HTTP,
   Interval:                       info.Check.Interval.String(),
   Timeout:                        info.Check.Timeout.String(),
   DeregisterCriticalServiceAfter: info.Check.DeregisterCriticalServiceAfter.String(),
  }
 }

 return sr.client.Agent().ServiceRegister(registration)
}

// Deregister 注销服务
func (sr *ServiceRegistry) Deregister(ctx Context.Context, serviceID string) error {
 return sr.client.Agent().ServiceDeregister(serviceID)
}
```

---

### 6.2 自动注册

```go
// AutoRegistry 自动注册器
type AutoRegistry struct {
 registry *ServiceRegistry
 info     *ServiceInfo
}

// NewAutoRegistry 创建自动注册器
func NewAutoRegistry(registry *ServiceRegistry, info *ServiceInfo) *AutoRegistry {
 return &AutoRegistry{
  registry: registry,
  info:     info,
 }
}

// Start 启动自动注册
func (ar *AutoRegistry) Start(ctx Context.Context) error {
 // 注册服务
 if err := ar.registry.Register(ctx, ar.info); err != nil {
  return fmt.Errorf("register service: %w", err)
 }

 // 启动心跳
 go ar.heartbeat(ctx)

 return nil
}

// Stop 停止自动注册
func (ar *AutoRegistry) Stop(ctx Context.Context) error {
 return ar.registry.Deregister(ctx, ar.info.ID)
}

// heartbeat 心跳维持
func (ar *AutoRegistry) heartbeat(ctx Context.Context) {
 ticker := time.NewTicker(time.Second * 10)
 defer ticker.Stop()

 for {
  select {
  case <-ctx.Done():
   return
  case <-ticker.C:
   // 更新TTL
   // Consul的健康检查会自动维持，这里可以添加额外的逻辑
  }
 }
}
```

---

## 7. 服务发现

### 7.1 服务发现器

```go
// ServiceDiscovery 服务发现器
type ServiceDiscovery struct {
 client *api.Client
 cache  map[string][]*api.ServiceEntry
 mu     sync.RWMutex
}

// NewServiceDiscovery 创建服务发现器
func NewServiceDiscovery(address string) (*ServiceDiscovery, error) {
 config := api.DefaultConfig()
 config.Address = address

 client, err := api.NewClient(config)
 if err != nil {
  return nil, err
 }

 return &ServiceDiscovery{
  client: client,
  cache:  make(map[string][]*api.ServiceEntry),
 }, nil
}

// DiscoverService 发现服务
func (sd *ServiceDiscovery) DiscoverService(serviceName string) ([]*api.ServiceEntry, error) {
 sd.mu.RLock()
 cached, ok := sd.cache[serviceName]
 sd.mu.RUnlock()

 if ok {
  return cached, nil
 }

 services, _, err := sd.client.Health().Service(serviceName, "", true, nil)
 if err != nil {
  return nil, err
 }

 sd.mu.Lock()
 sd.cache[serviceName] = services
 sd.mu.Unlock()

 return services, nil
}

// WatchService 监听服务变化
func (sd *ServiceDiscovery) WatchService(ctx Context.Context, serviceName string) (<-Channel []*api.ServiceEntry, error) {
 ch := make(Channel []*api.ServiceEntry, 1)

 go func() {
  defer close(ch)

  var lastIndex uint64

  for {
   select {
   case <-ctx.Done():
    return
   default:
    services, meta, err := sd.client.Health().Service(
     serviceName, "", true,
     &api.QueryOptions{
      WaitIndex: lastIndex,
      WaitTime:  time.Minute,
     },
    )

    if err != nil {
     time.Sleep(time.Second * 5)
     continue
    }

    if meta.LastIndex != lastIndex {
     lastIndex = meta.LastIndex

     sd.mu.Lock()
     sd.cache[serviceName] = services
     sd.mu.Unlock()

     ch <- services
    }
   }
  }
 }()

 return ch, nil
}
```

---

### 7.2 负载均衡

```go
// Balancer 负载均衡器
type Balancer interface {
 Select(services []*api.ServiceEntry) *api.ServiceEntry
}

// RoundRobinBalancer 轮询负载均衡
type RoundRobinBalancer struct {
 current int
 mu      sync.Mutex
}

// Select 选择服务实例
func (rrb *RoundRobinBalancer) Select(services []*api.ServiceEntry) *api.ServiceEntry {
 if len(services) == 0 {
  return nil
 }

 rrb.mu.Lock()
 defer rrb.mu.Unlock()

 service := services[rrb.current%len(services)]
 rrb.current++

 return service
}

// ServiceResolver 服务解析器
type ServiceResolver struct {
 discovery *ServiceDiscovery
 balancer  Balancer
}

// NewServiceResolver 创建服务解析器
func NewServiceResolver(discovery *ServiceDiscovery, balancer Balancer) *ServiceResolver {
 return &ServiceResolver{
  discovery: discovery,
  balancer:  balancer,
 }
}

// Resolve 解析服务地址
func (sr *ServiceResolver) Resolve(serviceName string) (string, error) {
 services, err := sr.discovery.DiscoverService(serviceName)
 if err != nil {
  return "", err
 }

 if len(services) == 0 {
  return "", fmt.Errorf("no available service: %s", serviceName)
 }

 selected := sr.balancer.Select(services)
 if selected == nil {
  return "", fmt.Errorf("failed to select service")
 }

 return fmt.Sprintf("%s:%d", selected.Service.Address, selected.Service.Port), nil
}
```

---

## 8. 完整案例

### 8.1 微服务治理平台

```go
package main

import (
 "Context"
 "fmt"
 "log"
 "net/http"
 "os"
 "os/signal"
 "syscall"
 "time"
)

func main() {
 ctx, cancel := Context.WithCancel(Context.Background())
 defer cancel()

 // 1. 初始化配置管理器
 configManager := config.NewManager()

 // 2. 创建Consul配置中心
 consulConfig, err := consul.NewConfigCenter("localhost:8500", "myapp")
 if err != nil {
  log.Fatal(err)
 }

 // 3. 加载初始配置
 var appConfig config.Config
 if err := consulConfig.GetConfig(ctx, "config", &appConfig); err != nil {
  log.Fatal(err)
 }
 configManager.Load(&appConfig)

 // 4. 创建服务注册器
 registry, err := registry.NewServiceRegistry("localhost:8500")
 if err != nil {
  log.Fatal(err)
 }

 serviceInfo := &registry.ServiceInfo{
  ID:      "myapp-001",
  Name:    "myapp",
  Address: "192.168.1.100",
  Port:    8080,
  Tags:    []string{"v1.0.0", "production"},
  Meta: map[string]string{
   "version": "1.0.0",
   "region":  "us-west-1",
  },
  Check: &registry.HealthCheck{
   HTTP:                           "http://192.168.1.100:8080/health",
   Interval:                       time.Second * 10,
   Timeout:                        time.Second * 5,
   DeregisterCriticalServiceAfter: time.Minute * 1,
  },
 }

 // 5. 自动注册服务
 autoRegistry := registry.NewAutoRegistry(registry, serviceInfo)
 if err := autoRegistry.Start(ctx); err != nil {
  log.Fatal(err)
 }
 defer autoRegistry.Stop(ctx)

 // 6. 创建配置重载器
 reloader := hotreload.NewReloader()

 // 注册数据库重载器
 dbReloader := hotreload.NewDatabaseReloader(db)
 reloader.Register("database", dbReloader.Reload)

 // 7. 启动配置监听
 autoReloader := hotreload.NewAutoReloader(consulConfig, reloader, configManager)
 if err := autoReloader.Start(ctx, []string{"database", "redis", "server"}); err != nil {
  log.Fatal(err)
 }

 // 8. 创建灰度策略
 percentageStrategy := grayscale.NewPercentageStrategy(10) // 10%流量
 whitelistStrategy := grayscale.NewWhitelistStrategy([]string{"user123", "user456"})

 compositeStrategy := grayscale.NewCompositeStrategy(
  grayscale.ModeAny,
  percentageStrategy,
  whitelistStrategy,
 )

 // 9. 创建流量路由器
 trafficRouter := grayscale.NewTrafficRouter(
  compositeStrategy,
  []string{"stable-backend-1:8080", "stable-backend-2:8080"},
  []string{"gray-backend-1:8080"},
 )

 // 10. 创建HTTP服务器
 mux := http.NewServeMux()

 mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
  w.WriteHeader(http.StatusOK)
  w.Write([]byte("OK"))
 })

 mux.HandleFunc("/api/user", func(w http.ResponseWriter, r *http.Request) {
  w.WriteHeader(http.StatusOK)
  w.Write([]byte(`{"status":"ok"}`))
 })

 // 应用灰度中间件
 handler := grayscale.GrayMiddleware(trafficRouter)(mux)

 server := &http.Server{
  Addr:    ":8080",
  Handler: handler,
 }

 // 11. 启动服务器
 go func() {
  log.Println("Server starting on :8080")
  if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
   log.Fatal(err)
  }
 }()

 // 12. 优雅退出
 quit := make(Channel os.Signal, 1)
 signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
 <-quit

 log.Println("Shutting down server...")

 ctx, cancel = Context.WithTimeout(Context.Background(), 30*time.Second)
 defer cancel()

 if err := server.Shutdown(ctx); err != nil {
  log.Fatal("Server forced to shutdown:", err)
 }

 log.Println("Server exited")
}
```

---

## 📚 配置中心最佳实践

### 配置管理

- ✅ 环境隔离（dev/test/prod）
- ✅ 版本管理
- ✅ 配置审计
- ✅ 权限控制
- ✅ 配置备份

### 服务治理

- ✅ 服务注册与发现
- ✅ 健康检查
- ✅ 负载均衡
- ✅ 服务降级
- ✅ 服务监控

### 灰度策略

- ✅ 百分比灰度
- ✅ 白名单灰度
- ✅ 地域灰度
- ✅ 时间窗口灰度
- ✅ AB测试

### 监控告警

- ✅ 配置变更监控
- ✅ 服务健康监控
- ✅ 灰度效果监控
- ✅ 异常告警
- ✅ 审计日志

---

## 🎯 总结
