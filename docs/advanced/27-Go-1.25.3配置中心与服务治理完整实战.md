# Go 1.25.3 é…ç½®ä¸­å¿ƒä¸æœåŠ¡æ²»ç†å®Œæ•´å®æˆ˜

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.25.3

---

## ğŸ“‹ ç›®å½•

- [Go 1.25.3 é…ç½®ä¸­å¿ƒä¸æœåŠ¡æ²»ç†å®Œæ•´å®æˆ˜](#go-1253-é…ç½®ä¸­å¿ƒä¸æœåŠ¡æ²»ç†å®Œæ•´å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“– æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. é…ç½®ä¸­å¿ƒ](#1-é…ç½®ä¸­å¿ƒ)
    - [1.1 æœ¬åœ°é…ç½®ç®¡ç†](#11-æœ¬åœ°é…ç½®ç®¡ç†)
    - [1.2 é…ç½®æ–‡ä»¶åŠ è½½](#12-é…ç½®æ–‡ä»¶åŠ è½½)
  - [2. Consulé…ç½®ä¸­å¿ƒ](#2-consulé…ç½®ä¸­å¿ƒ)
    - [2.1 Consulå®¢æˆ·ç«¯](#21-consulå®¢æˆ·ç«¯)
    - [2.2 é…ç½®ç›‘å¬](#22-é…ç½®ç›‘å¬)
  - [3. Nacosé…ç½®ä¸­å¿ƒ](#3-nacosé…ç½®ä¸­å¿ƒ)
    - [3.1 Nacosé›†æˆ](#31-nacosé›†æˆ)
    - [3.2 é…ç½®å˜æ›´ç›‘å¬](#32-é…ç½®å˜æ›´ç›‘å¬)
  - [4. é…ç½®çƒ­æ›´æ–°](#4-é…ç½®çƒ­æ›´æ–°)
    - [4.1 é…ç½®è§‚å¯Ÿè€…](#41-é…ç½®è§‚å¯Ÿè€…)
    - [4.2 è‡ªåŠ¨é‡è½½](#42-è‡ªåŠ¨é‡è½½)
  - [5. ç°åº¦å‘å¸ƒ](#5-ç°åº¦å‘å¸ƒ)
    - [5.1 ç°åº¦ç­–ç•¥](#51-ç°åº¦ç­–ç•¥)
    - [5.2 æµé‡åˆ†å‘](#52-æµé‡åˆ†å‘)
  - [6. æœåŠ¡æ³¨å†Œ](#6-æœåŠ¡æ³¨å†Œ)
    - [6.1 æœåŠ¡æ³¨å†Œå™¨](#61-æœåŠ¡æ³¨å†Œå™¨)
    - [6.2 è‡ªåŠ¨æ³¨å†Œ](#62-è‡ªåŠ¨æ³¨å†Œ)
  - [7. æœåŠ¡å‘ç°](#7-æœåŠ¡å‘ç°)
    - [7.1 æœåŠ¡å‘ç°å™¨](#71-æœåŠ¡å‘ç°å™¨)
    - [7.2 è´Ÿè½½å‡è¡¡](#72-è´Ÿè½½å‡è¡¡)
  - [8. å®Œæ•´æ¡ˆä¾‹](#8-å®Œæ•´æ¡ˆä¾‹)
    - [8.1 å¾®æœåŠ¡æ²»ç†å¹³å°](#81-å¾®æœåŠ¡æ²»ç†å¹³å°)
  - [ğŸ“š é…ç½®ä¸­å¿ƒæœ€ä½³å®è·µ](#-é…ç½®ä¸­å¿ƒæœ€ä½³å®è·µ)
    - [é…ç½®ç®¡ç†](#é…ç½®ç®¡ç†)
    - [æœåŠ¡æ²»ç†](#æœåŠ¡æ²»ç†)
    - [ç°åº¦ç­–ç•¥](#ç°åº¦ç­–ç•¥)
    - [ç›‘æ§å‘Šè­¦](#ç›‘æ§å‘Šè­¦)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

## ğŸ“– æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£å±•ç¤ºGo 1.25.3çš„**é…ç½®ä¸­å¿ƒä¸æœåŠ¡æ²»ç†å®Œæ•´æ–¹æ¡ˆ**ï¼Œå®ç°åŠ¨æ€é…ç½®ï¼š

- âœ… é…ç½®ä¸­å¿ƒ
- âœ… åŠ¨æ€é…ç½®
- âœ… é…ç½®çƒ­æ›´æ–°
- âœ… ç°åº¦å‘å¸ƒ
- âœ… æœåŠ¡æ³¨å†Œ
- âœ… æœåŠ¡å‘ç°
- âœ… å¥åº·æ£€æŸ¥
- âœ… å…ƒæ•°æ®ç®¡ç†

---

## ç›®å½•

- [Go 1.25.3 é…ç½®ä¸­å¿ƒä¸æœåŠ¡æ²»ç†å®Œæ•´å®æˆ˜](#go-1253-é…ç½®ä¸­å¿ƒä¸æœåŠ¡æ²»ç†å®Œæ•´å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“– æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. é…ç½®ä¸­å¿ƒ](#1-é…ç½®ä¸­å¿ƒ)
    - [1.1 æœ¬åœ°é…ç½®ç®¡ç†](#11-æœ¬åœ°é…ç½®ç®¡ç†)
    - [1.2 é…ç½®æ–‡ä»¶åŠ è½½](#12-é…ç½®æ–‡ä»¶åŠ è½½)
  - [2. Consulé…ç½®ä¸­å¿ƒ](#2-consulé…ç½®ä¸­å¿ƒ)
    - [2.1 Consulå®¢æˆ·ç«¯](#21-consulå®¢æˆ·ç«¯)
    - [2.2 é…ç½®ç›‘å¬](#22-é…ç½®ç›‘å¬)
  - [3. Nacosé…ç½®ä¸­å¿ƒ](#3-nacosé…ç½®ä¸­å¿ƒ)
    - [3.1 Nacosé›†æˆ](#31-nacosé›†æˆ)
    - [3.2 é…ç½®å˜æ›´ç›‘å¬](#32-é…ç½®å˜æ›´ç›‘å¬)
  - [4. é…ç½®çƒ­æ›´æ–°](#4-é…ç½®çƒ­æ›´æ–°)
    - [4.1 é…ç½®è§‚å¯Ÿè€…](#41-é…ç½®è§‚å¯Ÿè€…)
    - [4.2 è‡ªåŠ¨é‡è½½](#42-è‡ªåŠ¨é‡è½½)
  - [5. ç°åº¦å‘å¸ƒ](#5-ç°åº¦å‘å¸ƒ)
    - [5.1 ç°åº¦ç­–ç•¥](#51-ç°åº¦ç­–ç•¥)
    - [5.2 æµé‡åˆ†å‘](#52-æµé‡åˆ†å‘)
  - [6. æœåŠ¡æ³¨å†Œ](#6-æœåŠ¡æ³¨å†Œ)
    - [6.1 æœåŠ¡æ³¨å†Œå™¨](#61-æœåŠ¡æ³¨å†Œå™¨)
    - [6.2 è‡ªåŠ¨æ³¨å†Œ](#62-è‡ªåŠ¨æ³¨å†Œ)
  - [7. æœåŠ¡å‘ç°](#7-æœåŠ¡å‘ç°)
    - [7.1 æœåŠ¡å‘ç°å™¨](#71-æœåŠ¡å‘ç°å™¨)
    - [7.2 è´Ÿè½½å‡è¡¡](#72-è´Ÿè½½å‡è¡¡)
  - [8. å®Œæ•´æ¡ˆä¾‹](#8-å®Œæ•´æ¡ˆä¾‹)
    - [8.1 å¾®æœåŠ¡æ²»ç†å¹³å°](#81-å¾®æœåŠ¡æ²»ç†å¹³å°)
  - [ğŸ“š é…ç½®ä¸­å¿ƒæœ€ä½³å®è·µ](#-é…ç½®ä¸­å¿ƒæœ€ä½³å®è·µ)
    - [é…ç½®ç®¡ç†](#é…ç½®ç®¡ç†)
    - [æœåŠ¡æ²»ç†](#æœåŠ¡æ²»ç†)
    - [ç°åº¦ç­–ç•¥](#ç°åº¦ç­–ç•¥)
    - [ç›‘æ§å‘Šè­¦](#ç›‘æ§å‘Šè­¦)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

---

## 1. é…ç½®ä¸­å¿ƒ

### 1.1 æœ¬åœ°é…ç½®ç®¡ç†

```go
package config

import (
 "sync"
 "time"
)

// Config é…ç½®ç»“æ„
type Config struct {
 Server   ServerConfig   `json:"server" yaml:"server"`
 Database DatabaseConfig `json:"database" yaml:"database"`
 Redis    RedisConfig    `json:"redis" yaml:"redis"`
 Log      LogConfig      `json:"log" yaml:"log"`
}

// ServerConfig æœåŠ¡å™¨é…ç½®
type ServerConfig struct {
 Host         string        `json:"host" yaml:"host"`
 Port         int           `json:"port" yaml:"port"`
 ReadTimeout  time.Duration `json:"read_timeout" yaml:"read_timeout"`
 WriteTimeout time.Duration `json:"write_timeout" yaml:"write_timeout"`
}

// DatabaseConfig æ•°æ®åº“é…ç½®
type DatabaseConfig struct {
 Driver          string `json:"driver" yaml:"driver"`
 DSN             string `json:"dsn" yaml:"dsn"`
 MaxOpenConns    int    `json:"max_open_conns" yaml:"max_open_conns"`
 MaxIdleConns    int    `json:"max_idle_conns" yaml:"max_idle_conns"`
 ConnMaxLifetime time.Duration `json:"conn_max_lifetime" yaml:"conn_max_lifetime"`
}

// RedisConfig Redisé…ç½®
type RedisConfig struct {
 Addr     string `json:"addr" yaml:"addr"`
 Password string `json:"password" yaml:"password"`
 DB       int    `json:"db" yaml:"db"`
}

// LogConfig æ—¥å¿—é…ç½®
type LogConfig struct {
 Level  string `json:"level" yaml:"level"`
 Format string `json:"format" yaml:"format"`
 Output string `json:"output" yaml:"output"`
}

// Manager é…ç½®ç®¡ç†å™¨
type Manager struct {
 config    *Config
 mu        sync.RWMutex
 observers []Observer
}

// Observer é…ç½®è§‚å¯Ÿè€…
type Observer interface {
 OnConfigChange(config *Config)
}

// NewManager åˆ›å»ºé…ç½®ç®¡ç†å™¨
func NewManager() *Manager {
 return &Manager{
  config:    &Config{},
  observers: make([]Observer, 0),
 }
}

// Load åŠ è½½é…ç½®
func (m *Manager) Load(config *Config) {
 m.mu.Lock()
 defer m.mu.Unlock()

 oldConfig := m.config
 m.config = config

 // é€šçŸ¥è§‚å¯Ÿè€…
 if oldConfig != nil {
  m.notifyObservers()
 }
}

// Get è·å–é…ç½®
func (m *Manager) Get() *Config {
 m.mu.RLock()
 defer m.mu.RUnlock()

 return m.config
}

// AddObserver æ·»åŠ è§‚å¯Ÿè€…
func (m *Manager) AddObserver(observer Observer) {
 m.mu.Lock()
 defer m.mu.Unlock()

 m.observers = append(m.observers, observer)
}

// notifyObservers é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€…
func (m *Manager) notifyObservers() {
 for _, observer := range m.observers {
  go observer.OnConfigChange(m.config)
 }
}
```

---

### 1.2 é…ç½®æ–‡ä»¶åŠ è½½

```go
package config

import (
 "fmt"
 "os"

 "gopkg.in/yaml.v3"
)

// Loader é…ç½®åŠ è½½å™¨
type Loader struct {
 filePath string
}

// NewLoader åˆ›å»ºé…ç½®åŠ è½½å™¨
func NewLoader(filePath string) *Loader {
 return &Loader{
  filePath: filePath,
 }
}

// Load åŠ è½½é…ç½®æ–‡ä»¶
func (l *Loader) Load() (*Config, error) {
 data, err := os.ReadFile(l.filePath)
 if err != nil {
  return nil, fmt.Errorf("read config file: %w", err)
 }

 var config Config
 if err := yaml.Unmarshal(data, &config); err != nil {
  return nil, fmt.Errorf("unmarshal config: %w", err)
 }

 return &config, nil
}

// Watch ç›‘å¬é…ç½®æ–‡ä»¶å˜åŒ–
func (l *Loader) Watch(callback func(*Config)) error {
 watcher, err := fsnotify.NewWatcher()
 if err != nil {
  return err
 }

 go func() {
  defer watcher.Close()

  for {
   select {
   case event := <-watcher.Events:
    if event.Op&fsnotify.Write == fsnotify.Write {
     config, err := l.Load()
     if err != nil {
      fmt.Printf("Failed to reload config: %v\n", err)
      continue
     }

     callback(config)
    }
   case err := <-watcher.Errors:
    fmt.Printf("Watcher error: %v\n", err)
   }
  }
 }()

 return watcher.Add(l.filePath)
}
```

---

## 2. Consulé…ç½®ä¸­å¿ƒ

### 2.1 Consulå®¢æˆ·ç«¯

```go
package consul

import (
 "context"
 "encoding/json"
 "fmt"

 "github.com/hashicorp/consul/api"
)

// ConfigCenter Consulé…ç½®ä¸­å¿ƒ
type ConfigCenter struct {
 client *api.Client
 prefix string
}

// NewConfigCenter åˆ›å»ºConsulé…ç½®ä¸­å¿ƒ
func NewConfigCenter(address, prefix string) (*ConfigCenter, error) {
 config := api.DefaultConfig()
 config.Address = address

 client, err := api.NewClient(config)
 if err != nil {
  return nil, err
 }

 return &ConfigCenter{
  client: client,
  prefix: prefix,
 }, nil
}

// Get è·å–é…ç½®
func (cc *ConfigCenter) Get(ctx context.Context, key string) ([]byte, error) {
 fullKey := fmt.Sprintf("%s/%s", cc.prefix, key)

 pair, _, err := cc.client.KV().Get(fullKey, nil)
 if err != nil {
  return nil, err
 }

 if pair == nil {
  return nil, fmt.Errorf("config not found: %s", key)
 }

 return pair.Value, nil
}

// Set è®¾ç½®é…ç½®
func (cc *ConfigCenter) Set(ctx context.Context, key string, value []byte) error {
 fullKey := fmt.Sprintf("%s/%s", cc.prefix, key)

 pair := &api.KVPair{
  Key:   fullKey,
  Value: value,
 }

 _, err := cc.client.KV().Put(pair, nil)
 return err
}

// GetConfig è·å–é…ç½®å¯¹è±¡
func (cc *ConfigCenter) GetConfig(ctx context.Context, key string, config interface{}) error {
 data, err := cc.Get(ctx, key)
 if err != nil {
  return err
 }

 return json.Unmarshal(data, config)
}

// SetConfig è®¾ç½®é…ç½®å¯¹è±¡
func (cc *ConfigCenter) SetConfig(ctx context.Context, key string, config interface{}) error {
 data, err := json.Marshal(config)
 if err != nil {
  return err
 }

 return cc.Set(ctx, key, data)
}
```

---

### 2.2 é…ç½®ç›‘å¬

```go
// Watch ç›‘å¬é…ç½®å˜åŒ–
func (cc *ConfigCenter) Watch(ctx context.Context, key string, callback func([]byte)) error {
 fullKey := fmt.Sprintf("%s/%s", cc.prefix, key)

 go func() {
  var lastIndex uint64

  for {
   select {
   case <-ctx.Done():
    return
   default:
    pair, meta, err := cc.client.KV().Get(fullKey, &api.QueryOptions{
     WaitIndex: lastIndex,
     WaitTime:  time.Minute,
    })

    if err != nil {
     fmt.Printf("Watch error: %v\n", err)
     time.Sleep(time.Second * 5)
     continue
    }

    if meta.LastIndex == lastIndex {
     continue
    }

    lastIndex = meta.LastIndex

    if pair != nil {
     callback(pair.Value)
    }
   }
  }
 }()

 return nil
}

// WatchConfig ç›‘å¬é…ç½®å¯¹è±¡å˜åŒ–
func (cc *ConfigCenter) WatchConfig(ctx context.Context, key string, config interface{}, callback func()) error {
 return cc.Watch(ctx, key, func(data []byte) {
  if err := json.Unmarshal(data, config); err != nil {
   fmt.Printf("Unmarshal config error: %v\n", err)
   return
  }

  callback()
 })
}
```

---

## 3. Nacosé…ç½®ä¸­å¿ƒ

### 3.1 Nacosé›†æˆ

```go
package nacos

import (
 "github.com/nacos-group/nacos-sdk-go/clients"
 "github.com/nacos-group/nacos-sdk-go/clients/config_client"
 "github.com/nacos-group/nacos-sdk-go/common/constant"
 "github.com/nacos-group/nacos-sdk-go/vo"
)

// ConfigCenter Nacosé…ç½®ä¸­å¿ƒ
type ConfigCenter struct {
 client    config_client.IConfigClient
 namespace string
 group     string
}

// NewConfigCenter åˆ›å»ºNacosé…ç½®ä¸­å¿ƒ
func NewConfigCenter(serverAddr, namespace, group string) (*ConfigCenter, error) {
 // åˆ›å»ºServerConfig
 sc := []constant.ServerConfig{
  *constant.NewServerConfig(serverAddr, 8848),
 }

 // åˆ›å»ºClientConfig
 cc := *constant.NewClientConfig(
  constant.WithNamespaceId(namespace),
  constant.WithTimeoutMs(5000),
  constant.WithNotLoadCacheAtStart(true),
 )

 // åˆ›å»ºé…ç½®å®¢æˆ·ç«¯
 client, err := clients.NewConfigClient(
  vo.NacosClientParam{
   ClientConfig:  &cc,
   ServerConfigs: sc,
  },
 )

 if err != nil {
  return nil, err
 }

 return &ConfigCenter{
  client:    client,
  namespace: namespace,
  group:     group,
 }, nil
}

// GetConfig è·å–é…ç½®
func (nc *ConfigCenter) GetConfig(dataID string) (string, error) {
 content, err := nc.client.GetConfig(vo.ConfigParam{
  DataId: dataID,
  Group:  nc.group,
 })

 return content, err
}

// PublishConfig å‘å¸ƒé…ç½®
func (nc *ConfigCenter) PublishConfig(dataID, content string) error {
 _, err := nc.client.PublishConfig(vo.ConfigParam{
  DataId:  dataID,
  Group:   nc.group,
  Content: content,
 })

 return err
}

// DeleteConfig åˆ é™¤é…ç½®
func (nc *ConfigCenter) DeleteConfig(dataID string) error {
 _, err := nc.client.DeleteConfig(vo.ConfigParam{
  DataId: dataID,
  Group:  nc.group,
 })

 return err
}
```

---

### 3.2 é…ç½®å˜æ›´ç›‘å¬

```go
// ListenConfig ç›‘å¬é…ç½®å˜åŒ–
func (nc *ConfigCenter) ListenConfig(dataID string, callback func(string)) error {
 return nc.client.ListenConfig(vo.ConfigParam{
  DataId: dataID,
  Group:  nc.group,
  OnChange: func(namespace, group, dataId, data string) {
   callback(data)
  },
 })
}

// CancelListenConfig å–æ¶ˆç›‘å¬
func (nc *ConfigCenter) CancelListenConfig(dataID string) error {
 return nc.client.CancelListenConfig(vo.ConfigParam{
  DataId: dataID,
  Group:  nc.group,
 })
}
```

---

## 4. é…ç½®çƒ­æ›´æ–°

### 4.1 é…ç½®è§‚å¯Ÿè€…

```go
package hotreload

import (
 "fmt"
 "sync"
)

// Reloader é…ç½®é‡è½½å™¨
type Reloader struct {
 handlers map[string][]ReloadHandler
 mu       sync.RWMutex
}

// ReloadHandler é‡è½½å¤„ç†å™¨
type ReloadHandler func(config interface{}) error

// NewReloader åˆ›å»ºé…ç½®é‡è½½å™¨
func NewReloader() *Reloader {
 return &Reloader{
  handlers: make(map[string][]ReloadHandler),
 }
}

// Register æ³¨å†Œé‡è½½å¤„ç†å™¨
func (r *Reloader) Register(key string, handler ReloadHandler) {
 r.mu.Lock()
 defer r.mu.Unlock()

 if r.handlers[key] == nil {
  r.handlers[key] = make([]ReloadHandler, 0)
 }

 r.handlers[key] = append(r.handlers[key], handler)
}

// Reload è§¦å‘é‡è½½
func (r *Reloader) Reload(key string, config interface{}) error {
 r.mu.RLock()
 handlers, ok := r.handlers[key]
 r.mu.RUnlock()

 if !ok {
  return nil
 }

 for _, handler := range handlers {
  if err := handler(config); err != nil {
   return fmt.Errorf("reload handler error: %w", err)
  }
 }

 return nil
}

// DatabaseReloader æ•°æ®åº“è¿æ¥é‡è½½å™¨
type DatabaseReloader struct {
 db *sql.DB
 mu sync.Mutex
}

// NewDatabaseReloader åˆ›å»ºæ•°æ®åº“é‡è½½å™¨
func NewDatabaseReloader(db *sql.DB) *DatabaseReloader {
 return &DatabaseReloader{
  db: db,
 }
}

// Reload é‡è½½æ•°æ®åº“è¿æ¥
func (dr *DatabaseReloader) Reload(config interface{}) error {
 dr.mu.Lock()
 defer dr.mu.Unlock()

 dbConfig := config.(*DatabaseConfig)

 // è®¾ç½®æ–°çš„è¿æ¥å‚æ•°
 dr.db.SetMaxOpenConns(dbConfig.MaxOpenConns)
 dr.db.SetMaxIdleConns(dbConfig.MaxIdleConns)
 dr.db.SetConnMaxLifetime(dbConfig.ConnMaxLifetime)

 return nil
}
```

---

### 4.2 è‡ªåŠ¨é‡è½½

```go
// AutoReloader è‡ªåŠ¨é‡è½½å™¨
type AutoReloader struct {
 configCenter ConfigCenter
 reloader     *Reloader
 manager      *config.Manager
}

// NewAutoReloader åˆ›å»ºè‡ªåŠ¨é‡è½½å™¨
func NewAutoReloader(
 configCenter ConfigCenter,
 reloader *Reloader,
 manager *config.Manager,
) *AutoReloader {
 return &AutoReloader{
  configCenter: configCenter,
  reloader:     reloader,
  manager:      manager,
 }
}

// Start å¯åŠ¨è‡ªåŠ¨é‡è½½
func (ar *AutoReloader) Start(ctx context.Context, keys []string) error {
 for _, key := range keys {
  if err := ar.watchKey(ctx, key); err != nil {
   return err
  }
 }

 return nil
}

// watchKey ç›‘å¬é…ç½®é”®
func (ar *AutoReloader) watchKey(ctx context.Context, key string) error {
 return ar.configCenter.Watch(ctx, key, func(data []byte) {
  var config interface{}

  switch key {
  case "database":
   config = &DatabaseConfig{}
  case "redis":
   config = &RedisConfig{}
  case "server":
   config = &ServerConfig{}
  default:
   return
  }

  if err := json.Unmarshal(data, config); err != nil {
   fmt.Printf("Unmarshal config error: %v\n", err)
   return
  }

  // è§¦å‘é‡è½½
  if err := ar.reloader.Reload(key, config); err != nil {
   fmt.Printf("Reload error: %v\n", err)
   return
  }

  // æ›´æ–°é…ç½®ç®¡ç†å™¨
  fullConfig := ar.manager.Get()
  switch key {
  case "database":
   fullConfig.Database = *config.(*DatabaseConfig)
  case "redis":
   fullConfig.Redis = *config.(*RedisConfig)
  case "server":
   fullConfig.Server = *config.(*ServerConfig)
  }

  ar.manager.Load(fullConfig)

  fmt.Printf("Config reloaded: %s\n", key)
 })
}
```

---

## 5. ç°åº¦å‘å¸ƒ

### 5.1 ç°åº¦ç­–ç•¥

```go
package grayscale

import (
 "hash/fnv"
 "math/rand"
)

// Strategy ç°åº¦ç­–ç•¥æ¥å£
type Strategy interface {
 ShouldUseGray(userID string) bool
}

// PercentageStrategy ç™¾åˆ†æ¯”ç­–ç•¥
type PercentageStrategy struct {
 percentage int // 0-100
}

// NewPercentageStrategy åˆ›å»ºç™¾åˆ†æ¯”ç­–ç•¥
func NewPercentageStrategy(percentage int) *PercentageStrategy {
 return &PercentageStrategy{
  percentage: percentage,
 }
}

// ShouldUseGray åˆ¤æ–­æ˜¯å¦ä½¿ç”¨ç°åº¦ç‰ˆæœ¬
func (ps *PercentageStrategy) ShouldUseGray(userID string) bool {
 h := fnv.New32a()
 h.Write([]byte(userID))
 hash := h.Sum32()

 return int(hash%100) < ps.percentage
}

// WhitelistStrategy ç™½åå•ç­–ç•¥
type WhitelistStrategy struct {
 whitelist map[string]bool
}

// NewWhitelistStrategy åˆ›å»ºç™½åå•ç­–ç•¥
func NewWhitelistStrategy(users []string) *WhitelistStrategy {
 whitelist := make(map[string]bool)
 for _, user := range users {
  whitelist[user] = true
 }

 return &WhitelistStrategy{
  whitelist: whitelist,
 }
}

// ShouldUseGray åˆ¤æ–­æ˜¯å¦ä½¿ç”¨ç°åº¦ç‰ˆæœ¬
func (ws *WhitelistStrategy) ShouldUseGray(userID string) bool {
 return ws.whitelist[userID]
}

// CompositeStrategy ç»„åˆç­–ç•¥
type CompositeStrategy struct {
 strategies []Strategy
 mode       CompositeMode
}

// CompositeMode ç»„åˆæ¨¡å¼
type CompositeMode int

const (
 ModeAny CompositeMode = iota // ä»»æ„ä¸€ä¸ªæ»¡è¶³
 ModeAll                       // å…¨éƒ¨æ»¡è¶³
)

// NewCompositeStrategy åˆ›å»ºç»„åˆç­–ç•¥
func NewCompositeStrategy(mode CompositeMode, strategies ...Strategy) *CompositeStrategy {
 return &CompositeStrategy{
  strategies: strategies,
  mode:       mode,
 }
}

// ShouldUseGray åˆ¤æ–­æ˜¯å¦ä½¿ç”¨ç°åº¦ç‰ˆæœ¬
func (cs *CompositeStrategy) ShouldUseGray(userID string) bool {
 if cs.mode == ModeAll {
  for _, strategy := range cs.strategies {
   if !strategy.ShouldUseGray(userID) {
    return false
   }
  }
  return true
 }

 // ModeAny
 for _, strategy := range cs.strategies {
  if strategy.ShouldUseGray(userID) {
   return true
  }
 }
 return false
}
```

---

### 5.2 æµé‡åˆ†å‘

```go
// TrafficRouter æµé‡è·¯ç”±å™¨
type TrafficRouter struct {
 strategy      Strategy
 stableBackend []string
 grayBackend   []string
 mu            sync.RWMutex
}

// NewTrafficRouter åˆ›å»ºæµé‡è·¯ç”±å™¨
func NewTrafficRouter(
 strategy Strategy,
 stableBackend, grayBackend []string,
) *TrafficRouter {
 return &TrafficRouter{
  strategy:      strategy,
  stableBackend: stableBackend,
  grayBackend:   grayBackend,
 }
}

// Route è·¯ç”±é€‰æ‹©åç«¯
func (tr *TrafficRouter) Route(userID string) []string {
 tr.mu.RLock()
 defer tr.mu.RUnlock()

 if tr.strategy.ShouldUseGray(userID) {
  return tr.grayBackend
 }

 return tr.stableBackend
}

// UpdateStrategy æ›´æ–°ç­–ç•¥
func (tr *TrafficRouter) UpdateStrategy(strategy Strategy) {
 tr.mu.Lock()
 defer tr.mu.Unlock()

 tr.strategy = strategy
}

// UpdateBackends æ›´æ–°åç«¯åˆ—è¡¨
func (tr *TrafficRouter) UpdateBackends(stable, gray []string) {
 tr.mu.Lock()
 defer tr.mu.Unlock()

 tr.stableBackend = stable
 tr.grayBackend = gray
}

// GrayMiddleware ç°åº¦ä¸­é—´ä»¶
func GrayMiddleware(router *TrafficRouter) func(http.Handler) http.Handler {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   // è·å–ç”¨æˆ·ID
   userID := r.Header.Get("X-User-ID")
   if userID == "" {
    userID = r.RemoteAddr
   }

   // é€‰æ‹©åç«¯
   backends := router.Route(userID)

   // è®¾ç½®åˆ°context
   ctx := context.WithValue(r.Context(), "backends", backends)

   next.ServeHTTP(w, r.WithContext(ctx))
  })
 }
}
```

---

## 6. æœåŠ¡æ³¨å†Œ

### 6.1 æœåŠ¡æ³¨å†Œå™¨

```go
package registry

import (
 "context"
 "fmt"
 "time"

 "github.com/hashicorp/consul/api"
)

// ServiceRegistry æœåŠ¡æ³¨å†Œå™¨
type ServiceRegistry struct {
 client *api.Client
}

// ServiceInfo æœåŠ¡ä¿¡æ¯
type ServiceInfo struct {
 ID      string
 Name    string
 Address string
 Port    int
 Tags    []string
 Meta    map[string]string
 Check   *HealthCheck
}

// HealthCheck å¥åº·æ£€æŸ¥
type HealthCheck struct {
 HTTP                           string
 Interval                       time.Duration
 Timeout                        time.Duration
 DeregisterCriticalServiceAfter time.Duration
}

// NewServiceRegistry åˆ›å»ºæœåŠ¡æ³¨å†Œå™¨
func NewServiceRegistry(address string) (*ServiceRegistry, error) {
 config := api.DefaultConfig()
 config.Address = address

 client, err := api.NewClient(config)
 if err != nil {
  return nil, err
 }

 return &ServiceRegistry{
  client: client,
 }, nil
}

// Register æ³¨å†ŒæœåŠ¡
func (sr *ServiceRegistry) Register(ctx context.Context, info *ServiceInfo) error {
 registration := &api.AgentServiceRegistration{
  ID:      info.ID,
  Name:    info.Name,
  Address: info.Address,
  Port:    info.Port,
  Tags:    info.Tags,
  Meta:    info.Meta,
 }

 // æ·»åŠ å¥åº·æ£€æŸ¥
 if info.Check != nil {
  registration.Check = &api.AgentServiceCheck{
   HTTP:                           info.Check.HTTP,
   Interval:                       info.Check.Interval.String(),
   Timeout:                        info.Check.Timeout.String(),
   DeregisterCriticalServiceAfter: info.Check.DeregisterCriticalServiceAfter.String(),
  }
 }

 return sr.client.Agent().ServiceRegister(registration)
}

// Deregister æ³¨é”€æœåŠ¡
func (sr *ServiceRegistry) Deregister(ctx context.Context, serviceID string) error {
 return sr.client.Agent().ServiceDeregister(serviceID)
}
```

---

### 6.2 è‡ªåŠ¨æ³¨å†Œ

```go
// AutoRegistry è‡ªåŠ¨æ³¨å†Œå™¨
type AutoRegistry struct {
 registry *ServiceRegistry
 info     *ServiceInfo
}

// NewAutoRegistry åˆ›å»ºè‡ªåŠ¨æ³¨å†Œå™¨
func NewAutoRegistry(registry *ServiceRegistry, info *ServiceInfo) *AutoRegistry {
 return &AutoRegistry{
  registry: registry,
  info:     info,
 }
}

// Start å¯åŠ¨è‡ªåŠ¨æ³¨å†Œ
func (ar *AutoRegistry) Start(ctx context.Context) error {
 // æ³¨å†ŒæœåŠ¡
 if err := ar.registry.Register(ctx, ar.info); err != nil {
  return fmt.Errorf("register service: %w", err)
 }

 // å¯åŠ¨å¿ƒè·³
 go ar.heartbeat(ctx)

 return nil
}

// Stop åœæ­¢è‡ªåŠ¨æ³¨å†Œ
func (ar *AutoRegistry) Stop(ctx context.Context) error {
 return ar.registry.Deregister(ctx, ar.info.ID)
}

// heartbeat å¿ƒè·³ç»´æŒ
func (ar *AutoRegistry) heartbeat(ctx context.Context) {
 ticker := time.NewTicker(time.Second * 10)
 defer ticker.Stop()

 for {
  select {
  case <-ctx.Done():
   return
  case <-ticker.C:
   // æ›´æ–°TTL
   // Consulçš„å¥åº·æ£€æŸ¥ä¼šè‡ªåŠ¨ç»´æŒï¼Œè¿™é‡Œå¯ä»¥æ·»åŠ é¢å¤–çš„é€»è¾‘
  }
 }
}
```

---

## 7. æœåŠ¡å‘ç°

### 7.1 æœåŠ¡å‘ç°å™¨

```go
// ServiceDiscovery æœåŠ¡å‘ç°å™¨
type ServiceDiscovery struct {
 client *api.Client
 cache  map[string][]*api.ServiceEntry
 mu     sync.RWMutex
}

// NewServiceDiscovery åˆ›å»ºæœåŠ¡å‘ç°å™¨
func NewServiceDiscovery(address string) (*ServiceDiscovery, error) {
 config := api.DefaultConfig()
 config.Address = address

 client, err := api.NewClient(config)
 if err != nil {
  return nil, err
 }

 return &ServiceDiscovery{
  client: client,
  cache:  make(map[string][]*api.ServiceEntry),
 }, nil
}

// DiscoverService å‘ç°æœåŠ¡
func (sd *ServiceDiscovery) DiscoverService(serviceName string) ([]*api.ServiceEntry, error) {
 sd.mu.RLock()
 cached, ok := sd.cache[serviceName]
 sd.mu.RUnlock()

 if ok {
  return cached, nil
 }

 services, _, err := sd.client.Health().Service(serviceName, "", true, nil)
 if err != nil {
  return nil, err
 }

 sd.mu.Lock()
 sd.cache[serviceName] = services
 sd.mu.Unlock()

 return services, nil
}

// WatchService ç›‘å¬æœåŠ¡å˜åŒ–
func (sd *ServiceDiscovery) WatchService(ctx context.Context, serviceName string) (<-chan []*api.ServiceEntry, error) {
 ch := make(chan []*api.ServiceEntry, 1)

 go func() {
  defer close(ch)

  var lastIndex uint64

  for {
   select {
   case <-ctx.Done():
    return
   default:
    services, meta, err := sd.client.Health().Service(
     serviceName, "", true,
     &api.QueryOptions{
      WaitIndex: lastIndex,
      WaitTime:  time.Minute,
     },
    )

    if err != nil {
     time.Sleep(time.Second * 5)
     continue
    }

    if meta.LastIndex != lastIndex {
     lastIndex = meta.LastIndex

     sd.mu.Lock()
     sd.cache[serviceName] = services
     sd.mu.Unlock()

     ch <- services
    }
   }
  }
 }()

 return ch, nil
}
```

---

### 7.2 è´Ÿè½½å‡è¡¡

```go
// Balancer è´Ÿè½½å‡è¡¡å™¨
type Balancer interface {
 Select(services []*api.ServiceEntry) *api.ServiceEntry
}

// RoundRobinBalancer è½®è¯¢è´Ÿè½½å‡è¡¡
type RoundRobinBalancer struct {
 current int
 mu      sync.Mutex
}

// Select é€‰æ‹©æœåŠ¡å®ä¾‹
func (rrb *RoundRobinBalancer) Select(services []*api.ServiceEntry) *api.ServiceEntry {
 if len(services) == 0 {
  return nil
 }

 rrb.mu.Lock()
 defer rrb.mu.Unlock()

 service := services[rrb.current%len(services)]
 rrb.current++

 return service
}

// ServiceResolver æœåŠ¡è§£æå™¨
type ServiceResolver struct {
 discovery *ServiceDiscovery
 balancer  Balancer
}

// NewServiceResolver åˆ›å»ºæœåŠ¡è§£æå™¨
func NewServiceResolver(discovery *ServiceDiscovery, balancer Balancer) *ServiceResolver {
 return &ServiceResolver{
  discovery: discovery,
  balancer:  balancer,
 }
}

// Resolve è§£ææœåŠ¡åœ°å€
func (sr *ServiceResolver) Resolve(serviceName string) (string, error) {
 services, err := sr.discovery.DiscoverService(serviceName)
 if err != nil {
  return "", err
 }

 if len(services) == 0 {
  return "", fmt.Errorf("no available service: %s", serviceName)
 }

 selected := sr.balancer.Select(services)
 if selected == nil {
  return "", fmt.Errorf("failed to select service")
 }

 return fmt.Sprintf("%s:%d", selected.Service.Address, selected.Service.Port), nil
}
```

---

## 8. å®Œæ•´æ¡ˆä¾‹

### 8.1 å¾®æœåŠ¡æ²»ç†å¹³å°

```go
package main

import (
 "context"
 "fmt"
 "log"
 "net/http"
 "os"
 "os/signal"
 "syscall"
 "time"
)

func main() {
 ctx, cancel := context.WithCancel(context.Background())
 defer cancel()

 // 1. åˆå§‹åŒ–é…ç½®ç®¡ç†å™¨
 configManager := config.NewManager()

 // 2. åˆ›å»ºConsulé…ç½®ä¸­å¿ƒ
 consulConfig, err := consul.NewConfigCenter("localhost:8500", "myapp")
 if err != nil {
  log.Fatal(err)
 }

 // 3. åŠ è½½åˆå§‹é…ç½®
 var appConfig config.Config
 if err := consulConfig.GetConfig(ctx, "config", &appConfig); err != nil {
  log.Fatal(err)
 }
 configManager.Load(&appConfig)

 // 4. åˆ›å»ºæœåŠ¡æ³¨å†Œå™¨
 registry, err := registry.NewServiceRegistry("localhost:8500")
 if err != nil {
  log.Fatal(err)
 }

 serviceInfo := &registry.ServiceInfo{
  ID:      "myapp-001",
  Name:    "myapp",
  Address: "192.168.1.100",
  Port:    8080,
  Tags:    []string{"v1.0.0", "production"},
  Meta: map[string]string{
   "version": "1.0.0",
   "region":  "us-west-1",
  },
  Check: &registry.HealthCheck{
   HTTP:                           "http://192.168.1.100:8080/health",
   Interval:                       time.Second * 10,
   Timeout:                        time.Second * 5,
   DeregisterCriticalServiceAfter: time.Minute * 1,
  },
 }

 // 5. è‡ªåŠ¨æ³¨å†ŒæœåŠ¡
 autoRegistry := registry.NewAutoRegistry(registry, serviceInfo)
 if err := autoRegistry.Start(ctx); err != nil {
  log.Fatal(err)
 }
 defer autoRegistry.Stop(ctx)

 // 6. åˆ›å»ºé…ç½®é‡è½½å™¨
 reloader := hotreload.NewReloader()

 // æ³¨å†Œæ•°æ®åº“é‡è½½å™¨
 dbReloader := hotreload.NewDatabaseReloader(db)
 reloader.Register("database", dbReloader.Reload)

 // 7. å¯åŠ¨é…ç½®ç›‘å¬
 autoReloader := hotreload.NewAutoReloader(consulConfig, reloader, configManager)
 if err := autoReloader.Start(ctx, []string{"database", "redis", "server"}); err != nil {
  log.Fatal(err)
 }

 // 8. åˆ›å»ºç°åº¦ç­–ç•¥
 percentageStrategy := grayscale.NewPercentageStrategy(10) // 10%æµé‡
 whitelistStrategy := grayscale.NewWhitelistStrategy([]string{"user123", "user456"})

 compositeStrategy := grayscale.NewCompositeStrategy(
  grayscale.ModeAny,
  percentageStrategy,
  whitelistStrategy,
 )

 // 9. åˆ›å»ºæµé‡è·¯ç”±å™¨
 trafficRouter := grayscale.NewTrafficRouter(
  compositeStrategy,
  []string{"stable-backend-1:8080", "stable-backend-2:8080"},
  []string{"gray-backend-1:8080"},
 )

 // 10. åˆ›å»ºHTTPæœåŠ¡å™¨
 mux := http.NewServeMux()

 mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
  w.WriteHeader(http.StatusOK)
  w.Write([]byte("OK"))
 })

 mux.HandleFunc("/api/user", func(w http.ResponseWriter, r *http.Request) {
  w.WriteHeader(http.StatusOK)
  w.Write([]byte(`{"status":"ok"}`))
 })

 // åº”ç”¨ç°åº¦ä¸­é—´ä»¶
 handler := grayscale.GrayMiddleware(trafficRouter)(mux)

 server := &http.Server{
  Addr:    ":8080",
  Handler: handler,
 }

 // 11. å¯åŠ¨æœåŠ¡å™¨
 go func() {
  log.Println("Server starting on :8080")
  if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
   log.Fatal(err)
  }
 }()

 // 12. ä¼˜é›…é€€å‡º
 quit := make(chan os.Signal, 1)
 signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
 <-quit

 log.Println("Shutting down server...")

 ctx, cancel = context.WithTimeout(context.Background(), 30*time.Second)
 defer cancel()

 if err := server.Shutdown(ctx); err != nil {
  log.Fatal("Server forced to shutdown:", err)
 }

 log.Println("Server exited")
}
```

---

## ğŸ“š é…ç½®ä¸­å¿ƒæœ€ä½³å®è·µ

### é…ç½®ç®¡ç†

- âœ… ç¯å¢ƒéš”ç¦»ï¼ˆdev/test/prodï¼‰
- âœ… ç‰ˆæœ¬ç®¡ç†
- âœ… é…ç½®å®¡è®¡
- âœ… æƒé™æ§åˆ¶
- âœ… é…ç½®å¤‡ä»½

### æœåŠ¡æ²»ç†

- âœ… æœåŠ¡æ³¨å†Œä¸å‘ç°
- âœ… å¥åº·æ£€æŸ¥
- âœ… è´Ÿè½½å‡è¡¡
- âœ… æœåŠ¡é™çº§
- âœ… æœåŠ¡ç›‘æ§

### ç°åº¦ç­–ç•¥

- âœ… ç™¾åˆ†æ¯”ç°åº¦
- âœ… ç™½åå•ç°åº¦
- âœ… åœ°åŸŸç°åº¦
- âœ… æ—¶é—´çª—å£ç°åº¦
- âœ… ABæµ‹è¯•

### ç›‘æ§å‘Šè­¦

- âœ… é…ç½®å˜æ›´ç›‘æ§
- âœ… æœåŠ¡å¥åº·ç›‘æ§
- âœ… ç°åº¦æ•ˆæœç›‘æ§
- âœ… å¼‚å¸¸å‘Šè­¦
- âœ… å®¡è®¡æ—¥å¿—

---

## ğŸ¯ æ€»ç»“

Go 1.25.3é…ç½®ä¸­å¿ƒä¸æœåŠ¡æ²»ç†å…³é”®ç‚¹ï¼š

1. **é…ç½®ä¸­å¿ƒ**: Consul/Nacosã€åŠ¨æ€é…ç½®ã€é…ç½®ç›‘å¬
2. **é…ç½®çƒ­æ›´æ–°**: è§‚å¯Ÿè€…æ¨¡å¼ã€è‡ªåŠ¨é‡è½½ã€æ— æ„Ÿåˆ‡æ¢
3. **ç°åº¦å‘å¸ƒ**: ç™¾åˆ†æ¯”ç­–ç•¥ã€ç™½åå•ã€æµé‡è·¯ç”±
4. **æœåŠ¡æ³¨å†Œ**: è‡ªåŠ¨æ³¨å†Œã€å¥åº·æ£€æŸ¥ã€å…ƒæ•°æ®
5. **æœåŠ¡å‘ç°**: åŠ¨æ€å‘ç°ã€ç¼“å­˜æ›´æ–°ã€ç›‘å¬å˜åŒ–
6. **è´Ÿè½½å‡è¡¡**: è½®è¯¢ã€åŠ æƒã€ä¸€è‡´æ€§å“ˆå¸Œ
7. **æœåŠ¡æ²»ç†**: æ³¨å†Œä¸­å¿ƒã€é…ç½®ä¸­å¿ƒã€ç°åº¦å‘å¸ƒ

**é…ç½®ä¸­å¿ƒæ˜¯å¾®æœåŠ¡æ²»ç†çš„æ ¸å¿ƒåŸºç¡€è®¾æ–½ï¼**

---

<div align="center">

**æ„å»ºçµæ´»çš„é…ç½®ç®¡ç†ç³»ç»Ÿ**:

[ğŸ“š è¿”å›ç›®å½•](../README.md) | [ğŸ“– ä¸‹ä¸€ç« ](28-ä¸‹ä¸€ä¸»é¢˜.md)

Made with â¤ï¸ for Go Developers

</div>

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2025-10-29
**Goç‰ˆæœ¬**: Go 1.25.3
**ç”Ÿäº§å°±ç»ª**: âœ…
