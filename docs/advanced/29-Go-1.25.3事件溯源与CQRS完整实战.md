# Go 1.25.3事件溯源与CQRS完整实战

> **难度**: ⭐⭐⭐⭐⭐
> **标签**: `Event Sourcing` `CQRS` `DDD` `EventStore` `Projection` `最终一致性` `事件驱动`

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---


## 📋 目录


- [1. Event Sourcing与CQRS概述](#1.-event-sourcing与cqrs概述)
  - [1.1 什么是Event Sourcing](#1.1-什么是event-sourcing)
  - [1.2 什么是CQRS](#1.2-什么是cqrs)
- [2. Event Sourcing实现](#2.-event-sourcing实现)
  - [2.1 Event定义](#2.1-event定义)
  - [2.2 Aggregate聚合根](#2.2-aggregate聚合根)
  - [2.3 Event Store实现](#2.3-event-store实现)
- [3. CQRS模式实现](#3.-cqrs模式实现)
  - [3.1 Command端 (写模型)](#3.1-command端-写模型)
  - [3.2 Query端 (读模型)](#3.2-query端-读模型)
- [4. Event Store设计](#4.-event-store设计)
  - [4.1 数据库Schema](#4.1-数据库schema)
- [5. Projection与Read Model](#5.-projection与read-model)
  - [5.1 Projection实现](#5.1-projection实现)
  - [5.2 Projection Manager](#5.2-projection-manager)
- [6. Saga与Process Manager](#6.-saga与process-manager)
  - [6.1 Saga实现](#6.1-saga实现)
- [7. 快照与性能优化](#7.-快照与性能优化)
  - [7.1 Snapshot实现](#7.1-snapshot实现)
- [8. 最终一致性与幂等性](#8.-最终一致性与幂等性)
  - [8.1 幂等性保证](#8.1-幂等性保证)
  - [8.2 最终一致性检测](#8.2-最终一致性检测)
- [9. 完整示例](#9.-完整示例)
- [10. 总结](#10.-总结)
  - [10.1 优势与劣势](#10.1-优势与劣势)
  - [10.2 最佳实践](#10.2-最佳实践)
- [📚 参考资料](#参考资料)

## 1. Event Sourcing与CQRS概述

### 1.1 什么是Event Sourcing

```go
// Event Sourcing核心思想
/*
传统CRUD模型:
┌──────────────┐
│  User Table  │
│ ┌──────────┐ │
│ │ id: 123  │ │  ← 只存储当前状态
│ │ name: Bob│ │
│ │ age: 30  │ │
│ └──────────┘ │
└──────────────┘
问题: 无法回溯历史,无法审计

Event Sourcing模型:
┌──────────────────────────────────────────┐
│        Event Store (Event Stream)        │
├──────────────────────────────────────────┤
│ Event 1: UserCreated {id:123, name:Alice} │
│ Event 2: UserRenamed {id:123, name:Bob}   │
│ Event 3: UserAged {id:123, age:30}        │
│ Event 4: UserEmailUpdated {id:123, ...}   │
└──────────────────────────────────────────┘
              ↓ (Replay Events)
┌──────────────┐
│ Current State│
│ id: 123      │
│ name: Bob    │
│ age: 30      │
└──────────────┘

优势:
1. 完整审计日志
2. 时间旅行 (Time Travel)
3. 事件溯源 (Debug)
4. 事件重放 (Replay)
*/
```

### 1.2 什么是CQRS

```go
// CQRS (Command Query Responsibility Segregation)
/*
传统模型:
┌─────────┐    ┌──────────┐
│  Client │───▶│   Model  │
└─────────┘    │  (CRUD)  │
               └──────────┘
               读写共用同一模型

CQRS模型:
┌─────────┐
│  Client │
└────┬────┘
     │
     ├─────────────────────────────┐
     │                             │
     ▼                             ▼
┌─────────┐                  ┌─────────┐
│ Command │                  │  Query  │
│  Model  │                  │  Model  │
│ (Write) │                  │  (Read) │
└────┬────┘                  └────▲────┘
     │                             │
     │ Events                      │
     └─────────────────────────────┘
                    
优势:
1. 读写分离
2. 独立扩展
3. 性能优化
4. 复杂查询优化
*/

// Example: 电商订单系统
type TraditionalModel struct {
    // 读写混合,难以优化
    CreateOrder(order Order) error
    UpdateOrder(orderId string, updates OrderUpdates) error
    GetOrder(orderId string) (Order, error)
    ListOrders(userId string, filters Filters) ([]Order, error)
    GetOrderStatistics(userId string) (Statistics, error)
}

type CQRSModel struct {
    // 命令端 (Write Model)
    CommandHandler struct {
        CreateOrder CreateOrderCommand
        CancelOrder CancelOrderCommand
        ShipOrder   ShipOrderCommand
    }
    
    // 查询端 (Read Model)
    QueryHandler struct {
        GetOrderDetail       GetOrderDetailQuery
        ListUserOrders       ListUserOrdersQuery
        GetOrderStatistics   GetOrderStatisticsQuery
        GetRecommendations   GetRecommendationsQuery
    }
}
```

---

## 2. Event Sourcing实现

### 2.1 Event定义

```go
// domain/event.go
package domain

import (
    "encoding/json"
    "time"
    "github.com/google/uuid"
)

// Event 事件接口
type Event interface {
    EventID() string
    EventType() string
    AggregateID() string
    AggregateType() string
    Version() int64
    Timestamp() time.Time
    Data() interface{}
}

// BaseEvent 事件基类
type BaseEvent struct {
    ID            string      `json:"id"`
    Type          string      `json:"type"`
    AggregateIdVal   string      `json:"aggregate_id"`
    AggregateTypeVal string      `json:"aggregate_type"`
    Ver           int64       `json:"version"`
    Time          time.Time   `json:"timestamp"`
    Metadata      map[string]string `json:"metadata"`
    Payload       json.RawMessage `json:"payload"`
}

func (e BaseEvent) EventID() string         { return e.ID }
func (e BaseEvent) EventType() string       { return e.Type }
func (e BaseEvent) AggregateID() string     { return e.AggregateIdVal }
func (e BaseEvent) AggregateType() string   { return e.AggregateTypeVal }
func (e BaseEvent) Version() int64          { return e.Ver }
func (e BaseEvent) Timestamp() time.Time    { return e.Time }
func (e BaseEvent) Data() interface{}       { return e.Payload }

// NewBaseEvent 创建基础事件
func NewBaseEvent(eventType, aggregateID, aggregateType string, version int64, payload interface{}) (*BaseEvent, error) {
    data, err := json.Marshal(payload)
    if err != nil {
        return nil, err
    }
    
    return &BaseEvent{
        ID:            uuid.New().String(),
        Type:          eventType,
        AggregateIdVal:   aggregateID,
        AggregateTypeVal: aggregateType,
        Ver:           version,
        Time:          time.Now().UTC(),
        Metadata:      make(map[string]string),
        Payload:       data,
    }, nil
}

// 具体事件类型
// 用户事件
type UserCreatedEvent struct {
    UserID   string `json:"user_id"`
    Username string `json:"username"`
    Email    string `json:"email"`
}

type UserEmailUpdatedEvent struct {
    UserID   string `json:"user_id"`
    OldEmail string `json:"old_email"`
    NewEmail string `json:"new_email"`
}

type UserDeletedEvent struct {
    UserID string `json:"user_id"`
    Reason string `json:"reason"`
}

// 订单事件
type OrderCreatedEvent struct {
    OrderID      string    `json:"order_id"`
    UserID       string    `json:"user_id"`
    Items        []OrderItem `json:"items"`
    TotalAmount  float64   `json:"total_amount"`
    CreatedAt    time.Time `json:"created_at"`
}

type OrderItem struct {
    ProductID string  `json:"product_id"`
    Quantity  int     `json:"quantity"`
    Price     float64 `json:"price"`
}

type OrderPaidEvent struct {
    OrderID       string    `json:"order_id"`
    PaymentMethod string    `json:"payment_method"`
    Amount        float64   `json:"amount"`
    PaidAt        time.Time `json:"paid_at"`
}

type OrderShippedEvent struct {
    OrderID        string    `json:"order_id"`
    TrackingNumber string    `json:"tracking_number"`
    ShippedAt      time.Time `json:"shipped_at"`
}

type OrderCancelledEvent struct {
    OrderID   string `json:"order_id"`
    Reason    string `json:"reason"`
    CancelledAt time.Time `json:"cancelled_at"`
}
```

### 2.2 Aggregate聚合根

```go
// domain/aggregate.go
package domain

import (
    "fmt"
)

// Aggregate 聚合根接口
type Aggregate interface {
    AggregateID() string
    AggregateType() string
    Version() int64
    UncommittedEvents() []Event
    ClearUncommittedEvents()
    ApplyEvent(event Event) error
}

// BaseAggregate 聚合根基类
type BaseAggregate struct {
    ID                string
    Type              string
    Ver               int64
    uncommittedEvents []Event
}

func (a *BaseAggregate) AggregateID() string   { return a.ID }
func (a *BaseAggregate) AggregateType() string { return a.Type }
func (a *BaseAggregate) Version() int64        { return a.Ver }
func (a *BaseAggregate) UncommittedEvents() []Event { return a.uncommittedEvents }

func (a *BaseAggregate) ClearUncommittedEvents() {
    a.uncommittedEvents = nil
}

func (a *BaseAggregate) raiseEvent(event Event) {
    a.uncommittedEvents = append(a.uncommittedEvents, event)
    a.Ver++
}

// OrderAggregate 订单聚合根
type OrderAggregate struct {
    BaseAggregate
    
    // 状态字段
    UserID       string
    Items        []OrderItem
    TotalAmount  float64
    Status       OrderStatus
    PaymentInfo  *PaymentInfo
    ShippingInfo *ShippingInfo
}

type OrderStatus string

const (
    OrderStatusPending   OrderStatus = "PENDING"
    OrderStatusPaid      OrderStatus = "PAID"
    OrderStatusShipped   OrderStatus = "SHIPPED"
    OrderStatusDelivered OrderStatus = "DELIVERED"
    OrderStatusCancelled OrderStatus = "CANCELLED"
)

type PaymentInfo struct {
    Method string
    Amount float64
    PaidAt time.Time
}

type ShippingInfo struct {
    TrackingNumber string
    ShippedAt      time.Time
}

// NewOrderAggregate 创建订单聚合
func NewOrderAggregate(orderID string) *OrderAggregate {
    return &OrderAggregate{
        BaseAggregate: BaseAggregate{
            ID:   orderID,
            Type: "Order",
            Ver:  0,
        },
        Status: OrderStatusPending,
    }
}

// CreateOrder 创建订单命令
func (o *OrderAggregate) CreateOrder(userID string, items []OrderItem) error {
    if o.Status != "" && o.Status != OrderStatusPending {
        return fmt.Errorf("order already created")
    }
    
    // 计算总额
    var totalAmount float64
    for _, item := range items {
        totalAmount += item.Price * float64(item.Quantity)
    }
    
    // 创建事件
    event, err := NewBaseEvent(
        "OrderCreated",
        o.ID,
        o.Type,
        o.Ver+1,
        OrderCreatedEvent{
            OrderID:     o.ID,
            UserID:      userID,
            Items:       items,
            TotalAmount: totalAmount,
            CreatedAt:   time.Now().UTC(),
        },
    )
    if err != nil {
        return err
    }
    
    // 应用事件
    if err := o.ApplyEvent(event); err != nil {
        return err
    }
    
    o.raiseEvent(event)
    return nil
}

// Pay 支付订单
func (o *OrderAggregate) Pay(paymentMethod string, amount float64) error {
    if o.Status != OrderStatusPending {
        return fmt.Errorf("order is not in pending status")
    }
    
    if amount != o.TotalAmount {
        return fmt.Errorf("payment amount mismatch")
    }
    
    event, err := NewBaseEvent(
        "OrderPaid",
        o.ID,
        o.Type,
        o.Ver+1,
        OrderPaidEvent{
            OrderID:       o.ID,
            PaymentMethod: paymentMethod,
            Amount:        amount,
            PaidAt:        time.Now().UTC(),
        },
    )
    if err != nil {
        return err
    }
    
    if err := o.ApplyEvent(event); err != nil {
        return err
    }
    
    o.raiseEvent(event)
    return nil
}

// Ship 发货
func (o *OrderAggregate) Ship(trackingNumber string) error {
    if o.Status != OrderStatusPaid {
        return fmt.Errorf("order is not paid")
    }
    
    event, err := NewBaseEvent(
        "OrderShipped",
        o.ID,
        o.Type,
        o.Ver+1,
        OrderShippedEvent{
            OrderID:        o.ID,
            TrackingNumber: trackingNumber,
            ShippedAt:      time.Now().UTC(),
        },
    )
    if err != nil {
        return err
    }
    
    if err := o.ApplyEvent(event); err != nil {
        return err
    }
    
    o.raiseEvent(event)
    return nil
}

// Cancel 取消订单
func (o *OrderAggregate) Cancel(reason string) error {
    if o.Status == OrderStatusShipped || o.Status == OrderStatusDelivered {
        return fmt.Errorf("cannot cancel shipped/delivered order")
    }
    
    if o.Status == OrderStatusCancelled {
        return fmt.Errorf("order already cancelled")
    }
    
    event, err := NewBaseEvent(
        "OrderCancelled",
        o.ID,
        o.Type,
        o.Ver+1,
        OrderCancelledEvent{
            OrderID:     o.ID,
            Reason:      reason,
            CancelledAt: time.Now().UTC(),
        },
    )
    if err != nil {
        return err
    }
    
    if err := o.ApplyEvent(event); err != nil {
        return err
    }
    
    o.raiseEvent(event)
    return nil
}

// ApplyEvent 应用事件 (更新状态)
func (o *OrderAggregate) ApplyEvent(event Event) error {
    var payload interface{}
    
    switch event.EventType() {
    case "OrderCreated":
        var e OrderCreatedEvent
        if err := json.Unmarshal(event.(*BaseEvent).Payload, &e); err != nil {
            return err
        }
        payload = e
        o.UserID = e.UserID
        o.Items = e.Items
        o.TotalAmount = e.TotalAmount
        o.Status = OrderStatusPending
        
    case "OrderPaid":
        var e OrderPaidEvent
        if err := json.Unmarshal(event.(*BaseEvent).Payload, &e); err != nil {
            return err
        }
        payload = e
        o.PaymentInfo = &PaymentInfo{
            Method: e.PaymentMethod,
            Amount: e.Amount,
            PaidAt: e.PaidAt,
        }
        o.Status = OrderStatusPaid
        
    case "OrderShipped":
        var e OrderShippedEvent
        if err := json.Unmarshal(event.(*BaseEvent).Payload, &e); err != nil {
            return err
        }
        payload = e
        o.ShippingInfo = &ShippingInfo{
            TrackingNumber: e.TrackingNumber,
            ShippedAt:      e.ShippedAt,
        }
        o.Status = OrderStatusShipped
        
    case "OrderCancelled":
        var e OrderCancelledEvent
        if err := json.Unmarshal(event.(*BaseEvent).Payload, &e); err != nil {
            return err
        }
        payload = e
        o.Status = OrderStatusCancelled
        
    default:
        return fmt.Errorf("unknown event type: %s", event.EventType())
    }
    
    o.Ver = event.Version()
    _ = payload
    return nil
}
```

### 2.3 Event Store实现

```go
// eventstore/store.go
package eventstore

import (
    "context"
    "database/sql"
    "encoding/json"
    "fmt"
    "time"
    
    "github.com/lib/pq"
    "yourapp/domain"
)

// EventStore 事件存储接口
type EventStore interface {
    SaveEvents(ctx context.Context, aggregateID string, events []domain.Event, expectedVersion int64) error
    LoadEvents(ctx context.Context, aggregateID string) ([]domain.Event, error)
    LoadEventsAfterVersion(ctx context.Context, aggregateID string, version int64) ([]domain.Event, error)
    SubscribeToStream(ctx context.Context, streamName string, handler EventHandler) error
}

// EventHandler 事件处理器
type EventHandler func(event domain.Event) error

// PostgresEventStore PostgreSQL实现
type PostgresEventStore struct {
    db *sql.DB
}

// NewPostgresEventStore 创建EventStore
func NewPostgresEventStore(db *sql.DB) (*PostgresEventStore, error) {
    // 创建表
    schema := `
    CREATE TABLE IF NOT EXISTS events (
        id SERIAL PRIMARY KEY,
        event_id UUID NOT NULL UNIQUE,
        event_type VARCHAR(255) NOT NULL,
        aggregate_id VARCHAR(255) NOT NULL,
        aggregate_type VARCHAR(255) NOT NULL,
        version BIGINT NOT NULL,
        timestamp TIMESTAMP NOT NULL,
        metadata JSONB,
        payload JSONB NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(aggregate_id, version)
    );
    
    CREATE INDEX IF NOT EXISTS idx_events_aggregate ON events(aggregate_id, version);
    CREATE INDEX IF NOT EXISTS idx_events_timestamp ON events(timestamp);
    CREATE INDEX IF NOT EXISTS idx_events_type ON events(event_type);
    `
    
    if _, err := db.Exec(schema); err != nil {
        return nil, err
    }
    
    return &PostgresEventStore{db: db}, nil
}

// SaveEvents 保存事件 (原子操作)
func (s *PostgresEventStore) SaveEvents(ctx context.Context, aggregateID string, events []domain.Event, expectedVersion int64) error {
    if len(events) == 0 {
        return nil
    }
    
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    // 乐观锁: 检查版本
    var currentVersion int64
    err = tx.QueryRowContext(ctx,
        "SELECT COALESCE(MAX(version), 0) FROM events WHERE aggregate_id = $1",
        aggregateID,
    ).Scan(&currentVersion)
    if err != nil {
        return err
    }
    
    if currentVersion != expectedVersion {
        return fmt.Errorf("concurrency conflict: expected version %d, got %d", expectedVersion, currentVersion)
    }
    
    // 插入事件
    stmt, err := tx.PrepareContext(ctx, `
        INSERT INTO events (event_id, event_type, aggregate_id, aggregate_type, version, timestamp, metadata, payload)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    `)
    if err != nil {
        return err
    }
    defer stmt.Close()
    
    for _, event := range events {
        baseEvent := event.(*domain.BaseEvent)
        metadata, _ := json.Marshal(baseEvent.Metadata)
        
        _, err = stmt.ExecContext(ctx,
            baseEvent.ID,
            baseEvent.Type,
            baseEvent.AggregateIdVal,
            baseEvent.AggregateTypeVal,
            baseEvent.Ver,
            baseEvent.Time,
            metadata,
            baseEvent.Payload,
        )
        if err != nil {
            return err
        }
    }
    
    return tx.Commit()
}

// LoadEvents 加载所有事件
func (s *PostgresEventStore) LoadEvents(ctx context.Context, aggregateID string) ([]domain.Event, error) {
    return s.LoadEventsAfterVersion(ctx, aggregateID, 0)
}

// LoadEventsAfterVersion 加载指定版本之后的事件
func (s *PostgresEventStore) LoadEventsAfterVersion(ctx context.Context, aggregateID string, version int64) ([]domain.Event, error) {
    rows, err := s.db.QueryContext(ctx, `
        SELECT event_id, event_type, aggregate_id, aggregate_type, version, timestamp, metadata, payload
        FROM events
        WHERE aggregate_id = $1 AND version > $2
        ORDER BY version ASC
    `, aggregateID, version)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var events []domain.Event
    for rows.Next() {
        var e domain.BaseEvent
        var metadata []byte
        
        err := rows.Scan(
            &e.ID,
            &e.Type,
            &e.AggregateIdVal,
            &e.AggregateTypeVal,
            &e.Ver,
            &e.Time,
            &metadata,
            &e.Payload,
        )
        if err != nil {
            return nil, err
        }
        
        json.Unmarshal(metadata, &e.Metadata)
        events = append(events, &e)
    }
    
    return events, rows.Err()
}

// SubscribeToStream 订阅事件流 (使用PostgreSQL LISTEN/NOTIFY)
func (s *PostgresEventStore) SubscribeToStream(ctx context.Context, streamName string, handler EventHandler) error {
    listener := pq.NewListener(
        s.db.(*sql.DB).Driver().(*pq.Driver).ConnStr(),
        10*time.Second,
        time.Minute,
        func(ev pq.ListenerEventType, err error) {
            if err != nil {
                fmt.Printf("Listener error: %v\n", err)
            }
        },
    )
    defer listener.Close()
    
    if err := listener.Listen(streamName); err != nil {
        return err
    }
    
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        case notification := <-listener.Notify:
            if notification == nil {
                continue
            }
            
            // 解析事件
            var event domain.BaseEvent
            if err := json.Unmarshal([]byte(notification.Extra), &event); err != nil {
                fmt.Printf("Failed to unmarshal event: %v\n", err)
                continue
            }
            
            // 处理事件
            if err := handler(&event); err != nil {
                fmt.Printf("Handler error: %v\n", err)
            }
        }
    }
}
```

---

## 3. CQRS模式实现

### 3.1 Command端 (写模型)

```go
// cqrs/command.go
package cqrs

import (
    "context"
    "fmt"
    "yourapp/domain"
    "yourapp/eventstore"
)

// Command 命令接口
type Command interface {
    CommandID() string
    AggregateID() string
}

// CommandHandler 命令处理器
type CommandHandler interface {
    Handle(ctx context.Context, command Command) error
}

// CreateOrderCommand 创建订单命令
type CreateOrderCommand struct {
    OrderID string
    UserID  string
    Items   []domain.OrderItem
}

func (c CreateOrderCommand) CommandID() string   { return "CreateOrder" }
func (c CreateOrderCommand) AggregateID() string { return c.OrderID }

// PayOrderCommand 支付订单命令
type PayOrderCommand struct {
    OrderID       string
    PaymentMethod string
    Amount        float64
}

func (c PayOrderCommand) CommandID() string   { return "PayOrder" }
func (c PayOrderCommand) AggregateID() string { return c.OrderID }

// OrderCommandHandler 订单命令处理器
type OrderCommandHandler struct {
    eventStore eventstore.EventStore
}

func NewOrderCommandHandler(eventStore eventstore.EventStore) *OrderCommandHandler {
    return &OrderCommandHandler{eventStore: eventStore}
}

// Handle 处理命令
func (h *OrderCommandHandler) Handle(ctx context.Context, command Command) error {
    switch cmd := command.(type) {
    case CreateOrderCommand:
        return h.handleCreateOrder(ctx, cmd)
    case PayOrderCommand:
        return h.handlePayOrder(ctx, cmd)
    default:
        return fmt.Errorf("unknown command type: %T", command)
    }
}

func (h *OrderCommandHandler) handleCreateOrder(ctx context.Context, cmd CreateOrderCommand) error {
    // 1. 创建聚合根
    order := domain.NewOrderAggregate(cmd.OrderID)
    
    // 2. 执行业务逻辑
    if err := order.CreateOrder(cmd.UserID, cmd.Items); err != nil {
        return err
    }
    
    // 3. 保存事件
    events := order.UncommittedEvents()
    if err := h.eventStore.SaveEvents(ctx, order.AggregateID(), events, 0); err != nil {
        return err
    }
    
    order.ClearUncommittedEvents()
    return nil
}

func (h *OrderCommandHandler) handlePayOrder(ctx context.Context, cmd PayOrderCommand) error {
    // 1. 加载聚合根 (事件溯源)
    order, err := h.loadOrderAggregate(ctx, cmd.OrderID)
    if err != nil {
        return err
    }
    
    // 2. 执行业务逻辑
    if err := order.Pay(cmd.PaymentMethod, cmd.Amount); err != nil {
        return err
    }
    
    // 3. 保存新事件
    events := order.UncommittedEvents()
    if err := h.eventStore.SaveEvents(ctx, order.AggregateID(), events, order.Version()-int64(len(events))); err != nil {
        return err
    }
    
    order.ClearUncommittedEvents()
    return nil
}

// loadOrderAggregate 从事件流重建聚合根
func (h *OrderCommandHandler) loadOrderAggregate(ctx context.Context, orderID string) (*domain.OrderAggregate, error) {
    // 加载事件
    events, err := h.eventStore.LoadEvents(ctx, orderID)
    if err != nil {
        return nil, err
    }
    
    if len(events) == 0 {
        return nil, fmt.Errorf("order not found: %s", orderID)
    }
    
    // 重放事件
    order := domain.NewOrderAggregate(orderID)
    for _, event := range events {
        if err := order.ApplyEvent(event); err != nil {
            return nil, err
        }
    }
    
    return order, nil
}
```

### 3.2 Query端 (读模型)

```go
// cqrs/query.go
package cqrs

import (
    "context"
    "database/sql"
    "time"
)

// Query 查询接口
type Query interface {
    QueryID() string
}

// QueryHandler 查询处理器
type QueryHandler interface {
    Handle(ctx context.Context, query Query) (interface{}, error)
}

// GetOrderDetailQuery 查询订单详情
type GetOrderDetailQuery struct {
    OrderID string
}

func (q GetOrderDetailQuery) QueryID() string { return "GetOrderDetail" }

// ListUserOrdersQuery 查询用户订单列表
type ListUserOrdersQuery struct {
    UserID string
    Status string
    Limit  int
    Offset int
}

func (q ListUserOrdersQuery) QueryID() string { return "ListUserOrders" }

// GetOrderStatisticsQuery 查询订单统计
type GetOrderStatisticsQuery struct {
    UserID    string
    StartDate time.Time
    EndDate   time.Time
}

func (q GetOrderStatisticsQuery) QueryID() string { return "GetOrderStatistics" }

// OrderQueryHandler 订单查询处理器
type OrderQueryHandler struct {
    readDB *sql.DB  // 读库 (可以是不同的数据库)
}

func NewOrderQueryHandler(readDB *sql.DB) *OrderQueryHandler {
    return &OrderQueryHandler{readDB: readDB}
}

// OrderDetailDTO 订单详情DTO
type OrderDetailDTO struct {
    OrderID        string      `json:"order_id"`
    UserID         string      `json:"user_id"`
    Items          []OrderItemDTO `json:"items"`
    TotalAmount    float64     `json:"total_amount"`
    Status         string      `json:"status"`
    PaymentMethod  string      `json:"payment_method,omitempty"`
    TrackingNumber string      `json:"tracking_number,omitempty"`
    CreatedAt      time.Time   `json:"created_at"`
    UpdatedAt      time.Time   `json:"updated_at"`
}

type OrderItemDTO struct {
    ProductID   string  `json:"product_id"`
    ProductName string  `json:"product_name"`
    Quantity    int     `json:"quantity"`
    Price       float64 `json:"price"`
}

// Handle 处理查询
func (h *OrderQueryHandler) Handle(ctx context.Context, query Query) (interface{}, error) {
    switch q := query.(type) {
    case GetOrderDetailQuery:
        return h.handleGetOrderDetail(ctx, q)
    case ListUserOrdersQuery:
        return h.handleListUserOrders(ctx, q)
    case GetOrderStatisticsQuery:
        return h.handleGetOrderStatistics(ctx, q)
    default:
        return nil, fmt.Errorf("unknown query type: %T", query)
    }
}

func (h *OrderQueryHandler) handleGetOrderDetail(ctx context.Context, query GetOrderDetailQuery) (*OrderDetailDTO, error) {
    var dto OrderDetailDTO
    
    // 查询优化的读模型
    err := h.readDB.QueryRowContext(ctx, `
        SELECT 
            order_id, user_id, total_amount, status,
            payment_method, tracking_number,
            created_at, updated_at
        FROM order_read_model
        WHERE order_id = $1
    `, query.OrderID).Scan(
        &dto.OrderID,
        &dto.UserID,
        &dto.TotalAmount,
        &dto.Status,
        &dto.PaymentMethod,
        &dto.TrackingNumber,
        &dto.CreatedAt,
        &dto.UpdatedAt,
    )
    if err != nil {
        return nil, err
    }
    
    // 查询订单明细
    rows, err := h.readDB.QueryContext(ctx, `
        SELECT product_id, product_name, quantity, price
        FROM order_items_read_model
        WHERE order_id = $1
    `, query.OrderID)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    for rows.Next() {
        var item OrderItemDTO
        if err := rows.Scan(&item.ProductID, &item.ProductName, &item.Quantity, &item.Price); err != nil {
            return nil, err
        }
        dto.Items = append(dto.Items, item)
    }
    
    return &dto, nil
}

func (h *OrderQueryHandler) handleListUserOrders(ctx context.Context, query ListUserOrdersQuery) ([]OrderDetailDTO, error) {
    querySQL := `
        SELECT 
            order_id, user_id, total_amount, status,
            payment_method, tracking_number,
            created_at, updated_at
        FROM order_read_model
        WHERE user_id = $1
    `
    
    args := []interface{}{query.UserID}
    
    if query.Status != "" {
        querySQL += " AND status = $2"
        args = append(args, query.Status)
    }
    
    querySQL += " ORDER BY created_at DESC LIMIT $3 OFFSET $4"
    args = append(args, query.Limit, query.Offset)
    
    rows, err := h.readDB.QueryContext(ctx, querySQL, args...)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var orders []OrderDetailDTO
    for rows.Next() {
        var dto OrderDetailDTO
        if err := rows.Scan(
            &dto.OrderID,
            &dto.UserID,
            &dto.TotalAmount,
            &dto.Status,
            &dto.PaymentMethod,
            &dto.TrackingNumber,
            &dto.CreatedAt,
            &dto.UpdatedAt,
        ); err != nil {
            return nil, err
        }
        orders = append(orders, dto)
    }
    
    return orders, nil
}

type OrderStatistics struct {
    TotalOrders    int     `json:"total_orders"`
    TotalAmount    float64 `json:"total_amount"`
    PendingOrders  int     `json:"pending_orders"`
    CompletedOrders int    `json:"completed_orders"`
}

func (h *OrderQueryHandler) handleGetOrderStatistics(ctx context.Context, query GetOrderStatisticsQuery) (*OrderStatistics, error) {
    var stats OrderStatistics
    
    err := h.readDB.QueryRowContext(ctx, `
        SELECT 
            COUNT(*) as total_orders,
            COALESCE(SUM(total_amount), 0) as total_amount,
            SUM(CASE WHEN status = 'PENDING' THEN 1 ELSE 0 END) as pending_orders,
            SUM(CASE WHEN status = 'DELIVERED' THEN 1 ELSE 0 END) as completed_orders
        FROM order_read_model
        WHERE user_id = $1 AND created_at BETWEEN $2 AND $3
    `, query.UserID, query.StartDate, query.EndDate).Scan(
        &stats.TotalOrders,
        &stats.TotalAmount,
        &stats.PendingOrders,
        &stats.CompletedOrders,
    )
    
    return &stats, err
}
```

---

## 4. Event Store设计

### 4.1 数据库Schema

```sql
-- events表 (事件流)
CREATE TABLE events (
    id SERIAL PRIMARY KEY,
    event_id UUID NOT NULL UNIQUE,
    event_type VARCHAR(255) NOT NULL,
    aggregate_id VARCHAR(255) NOT NULL,
    aggregate_type VARCHAR(255) NOT NULL,
    version BIGINT NOT NULL,
    timestamp TIMESTAMP NOT NULL,
    metadata JSONB,
    payload JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_aggregate_version UNIQUE(aggregate_id, version)
);

CREATE INDEX idx_events_aggregate ON events(aggregate_id, version);
CREATE INDEX idx_events_timestamp ON events(timestamp DESC);
CREATE INDEX idx_events_type ON events(event_type);

-- snapshots表 (快照,用于性能优化)
CREATE TABLE snapshots (
    aggregate_id VARCHAR(255) PRIMARY KEY,
    aggregate_type VARCHAR(255) NOT NULL,
    version BIGINT NOT NULL,
    state JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 读模型表
CREATE TABLE order_read_model (
    order_id VARCHAR(255) PRIMARY KEY,
    user_id VARCHAR(255) NOT NULL,
    total_amount DECIMAL(10, 2) NOT NULL,
    status VARCHAR(50) NOT NULL,
    payment_method VARCHAR(50),
    tracking_number VARCHAR(100),
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL
);

CREATE INDEX idx_order_read_user_id ON order_read_model(user_id);
CREATE INDEX idx_order_read_status ON order_read_model(status);
CREATE INDEX idx_order_read_created_at ON order_read_model(created_at DESC);

CREATE TABLE order_items_read_model (
    id SERIAL PRIMARY KEY,
    order_id VARCHAR(255) NOT NULL,
    product_id VARCHAR(255) NOT NULL,
    product_name VARCHAR(255) NOT NULL,
    quantity INT NOT NULL,
    price DECIMAL(10, 2) NOT NULL,
    FOREIGN KEY (order_id) REFERENCES order_read_model(order_id) ON DELETE CASCADE
);

CREATE INDEX idx_order_items_order_id ON order_items_read_model(order_id);
```

---

## 5. Projection与Read Model

### 5.1 Projection实现

```go
// projection/order_projection.go
package projection

import (
    "context"
    "database/sql"
    "encoding/json"
    "fmt"
    "yourapp/domain"
)

// Projection 投影接口
type Projection interface {
    ProjectEvent(ctx context.Context, event domain.Event) error
}

// OrderProjection 订单投影 (将事件投影到读模型)
type OrderProjection struct {
    db *sql.DB
}

func NewOrderProjection(db *sql.DB) *OrderProjection {
    return &OrderProjection{db: db}
}

// ProjectEvent 投影事件
func (p *OrderProjection) ProjectEvent(ctx context.Context, event domain.Event) error {
    switch event.EventType() {
    case "OrderCreated":
        return p.projectOrderCreated(ctx, event)
    case "OrderPaid":
        return p.projectOrderPaid(ctx, event)
    case "OrderShipped":
        return p.projectOrderShipped(ctx, event)
    case "OrderCancelled":
        return p.projectOrderCancelled(ctx, event)
    default:
        return nil  // 忽略未知事件
    }
}

func (p *OrderProjection) projectOrderCreated(ctx context.Context, event domain.Event) error {
    var e domain.OrderCreatedEvent
    if err := json.Unmarshal(event.(*domain.BaseEvent).Payload, &e); err != nil {
        return err
    }
    
    tx, err := p.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    // 插入订单记录
    _, err = tx.ExecContext(ctx, `
        INSERT INTO order_read_model (order_id, user_id, total_amount, status, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $5)
    `, e.OrderID, e.UserID, e.TotalAmount, "PENDING", e.CreatedAt)
    if err != nil {
        return err
    }
    
    // 插入订单明细
    stmt, err := tx.PrepareContext(ctx, `
        INSERT INTO order_items_read_model (order_id, product_id, product_name, quantity, price)
        VALUES ($1, $2, $3, $4, $5)
    `)
    if err != nil {
        return err
    }
    defer stmt.Close()
    
    for _, item := range e.Items {
        _, err = stmt.ExecContext(ctx, e.OrderID, item.ProductID, "Product", item.Quantity, item.Price)
        if err != nil {
            return err
        }
    }
    
    return tx.Commit()
}

func (p *OrderProjection) projectOrderPaid(ctx context.Context, event domain.Event) error {
    var e domain.OrderPaidEvent
    if err := json.Unmarshal(event.(*domain.BaseEvent).Payload, &e); err != nil {
        return err
    }
    
    _, err := p.db.ExecContext(ctx, `
        UPDATE order_read_model
        SET status = $1, payment_method = $2, updated_at = $3
        WHERE order_id = $4
    `, "PAID", e.PaymentMethod, e.PaidAt, e.OrderID)
    
    return err
}

func (p *OrderProjection) projectOrderShipped(ctx context.Context, event domain.Event) error {
    var e domain.OrderShippedEvent
    if err := json.Unmarshal(event.(*domain.BaseEvent).Payload, &e); err != nil {
        return err
    }
    
    _, err := p.db.ExecContext(ctx, `
        UPDATE order_read_model
        SET status = $1, tracking_number = $2, updated_at = $3
        WHERE order_id = $4
    `, "SHIPPED", e.TrackingNumber, e.ShippedAt, e.OrderID)
    
    return err
}

func (p *OrderProjection) projectOrderCancelled(ctx context.Context, event domain.Event) error {
    var e domain.OrderCancelledEvent
    if err := json.Unmarshal(event.(*domain.BaseEvent).Payload, &e); err != nil {
        return err
    }
    
    _, err := p.db.ExecContext(ctx, `
        UPDATE order_read_model
        SET status = $1, updated_at = $2
        WHERE order_id = $3
    `, "CANCELLED", e.CancelledAt, e.OrderID)
    
    return err
}
```

### 5.2 Projection Manager

```go
// projection/manager.go
package projection

import (
    "context"
    "fmt"
    "sync"
    "time"
    "yourapp/domain"
    "yourapp/eventstore"
)

// ProjectionManager 投影管理器
type ProjectionManager struct {
    eventStore  eventstore.EventStore
    projections []Projection
    checkpoints map[string]int64
    mu          sync.RWMutex
}

func NewProjectionManager(eventStore eventstore.EventStore) *ProjectionManager {
    return &ProjectionManager{
        eventStore:  eventStore,
        projections: make([]Projection, 0),
        checkpoints: make(map[string]int64),
    }
}

// RegisterProjection 注册投影
func (m *ProjectionManager) RegisterProjection(projection Projection) {
    m.projections = append(m.projections, projection)
}

// Start 启动投影管理器
func (m *ProjectionManager) Start(ctx context.Context) error {
    // 1. 追赶历史事件 (Catch-up)
    if err := m.catchUp(ctx); err != nil {
        return err
    }
    
    // 2. 订阅实时事件
    return m.eventStore.SubscribeToStream(ctx, "all_events", m.handleEvent)
}

func (m *ProjectionManager) catchUp(ctx context.Context) error {
    fmt.Println("[Projection] Catching up historical events...")
    
    // 从checkpoint开始追赶事件
    // (实际应从数据库读取checkpoint)
    startVersion := int64(0)
    
    // 这里简化处理,实际需要分页加载
    // events, err := m.eventStore.LoadAllEventsAfterVersion(ctx, startVersion)
    // for _, event := range events {
    //     if err := m.handleEvent(event); err != nil {
    //         return err
    //     }
    // }
    
    fmt.Println("[Projection] Catch-up completed")
    return nil
}

func (m *ProjectionManager) handleEvent(event domain.Event) error {
    // 并发投影到多个读模型
    var wg sync.WaitGroup
    errChan := make(chan error, len(m.projections))
    
    for _, projection := range m.projections {
        wg.Add(1)
        go func(p Projection) {
            defer wg.Done()
            ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
            defer cancel()
            
            if err := p.ProjectEvent(ctx, event); err != nil {
                errChan <- fmt.Errorf("projection error: %w", err)
            }
        }(projection)
    }
    
    wg.Wait()
    close(errChan)
    
    // 检查错误
    for err := range errChan {
        if err != nil {
            return err
        }
    }
    
    // 更新checkpoint
    m.updateCheckpoint(event.AggregateID(), event.Version())
    return nil
}

func (m *ProjectionManager) updateCheckpoint(aggregateID string, version int64) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.checkpoints[aggregateID] = version
    
    // 实际应持久化到数据库
}
```

---

## 6. Saga与Process Manager

### 6.1 Saga实现

```go
// saga/order_saga.go
package saga

import (
    "context"
    "fmt"
    "yourapp/cqrs"
    "yourapp/domain"
)

// OrderSaga 订单Saga (编排多个服务)
type OrderSaga struct {
    commandHandler cqrs.CommandHandler
}

func NewOrderSaga(commandHandler cqrs.CommandHandler) *OrderSaga {
    return &OrderSaga{commandHandler: commandHandler}
}

// HandleOrderPaid 处理订单支付成功事件
func (s *OrderSaga) HandleOrderPaid(ctx context.Context, event domain.Event) error {
    var e domain.OrderPaidEvent
    if err := json.Unmarshal(event.(*domain.BaseEvent).Payload, &e); err != nil {
        return err
    }
    
    // 编排步骤:
    // 1. 扣减库存
    if err := s.reserveInventory(ctx, e.OrderID); err != nil {
        // 补偿: 退款
        return s.compensatePayment(ctx, e.OrderID)
    }
    
    // 2. 创建物流单
    if err := s.createShipment(ctx, e.OrderID); err != nil {
        // 补偿: 释放库存 + 退款
        s.releaseInventory(ctx, e.OrderID)
        return s.compensatePayment(ctx, e.OrderID)
    }
    
    // 3. 发送通知
    if err := s.sendNotification(ctx, e.OrderID); err != nil {
        // 非关键步骤,记录日志即可
        fmt.Printf("[Saga] Failed to send notification: %v\n", err)
    }
    
    return nil
}

func (s *OrderSaga) reserveInventory(ctx context.Context, orderID string) error {
    // 调用库存服务
    fmt.Printf("[Saga] Reserving inventory for order %s\n", orderID)
    return nil
}

func (s *OrderSaga) releaseInventory(ctx context.Context, orderID string) error {
    fmt.Printf("[Saga] Releasing inventory for order %s\n", orderID)
    return nil
}

func (s *OrderSaga) createShipment(ctx context.Context, orderID string) error {
    fmt.Printf("[Saga] Creating shipment for order %s\n", orderID)
    return nil
}

func (s *OrderSaga) sendNotification(ctx context.Context, orderID string) error {
    fmt.Printf("[Saga] Sending notification for order %s\n", orderID)
    return nil
}

func (s *OrderSaga) compensatePayment(ctx context.Context, orderID string) error {
    fmt.Printf("[Saga] Compensating payment for order %s\n", orderID)
    // 发送退款命令
    return nil
}
```

---

## 7. 快照与性能优化

### 7.1 Snapshot实现

```go
// eventstore/snapshot.go
package eventstore

import (
    "context"
    "database/sql"
    "encoding/json"
    "yourapp/domain"
)

// SnapshotStore 快照存储
type SnapshotStore struct {
    db *sql.DB
}

func NewSnapshotStore(db *sql.DB) *SnapshotStore {
    return &SnapshotStore{db: db}
}

// SaveSnapshot 保存快照
func (s *SnapshotStore) SaveSnapshot(ctx context.Context, aggregate domain.Aggregate) error {
    state, err := json.Marshal(aggregate)
    if err != nil {
        return err
    }
    
    _, err = s.db.ExecContext(ctx, `
        INSERT INTO snapshots (aggregate_id, aggregate_type, version, state)
        VALUES ($1, $2, $3, $4)
        ON CONFLICT (aggregate_id) DO UPDATE SET
            version = EXCLUDED.version,
            state = EXCLUDED.state,
            created_at = CURRENT_TIMESTAMP
    `, aggregate.AggregateID(), aggregate.AggregateType(), aggregate.Version(), state)
    
    return err
}

// LoadSnapshot 加载快照
func (s *SnapshotStore) LoadSnapshot(ctx context.Context, aggregateID string) (json.RawMessage, int64, error) {
    var state json.RawMessage
    var version int64
    
    err := s.db.QueryRowContext(ctx, `
        SELECT state, version FROM snapshots WHERE aggregate_id = $1
    `, aggregateID).Scan(&state, &version)
    
    if err == sql.ErrNoRows {
        return nil, 0, nil
    }
    
    return state, version, err
}

// 优化后的聚合根加载 (使用快照)
func (h *OrderCommandHandler) loadOrderAggregateWithSnapshot(ctx context.Context, orderID string) (*domain.OrderAggregate, error) {
    // 1. 尝试加载快照
    snapshotStore := NewSnapshotStore(h.db)
    state, version, err := snapshotStore.LoadSnapshot(ctx, orderID)
    
    var order *domain.OrderAggregate
    
    if err == nil && state != nil {
        // 从快照恢复
        order = &domain.OrderAggregate{}
        if err := json.Unmarshal(state, order); err != nil {
            return nil, err
        }
        
        // 只需加载快照之后的事件
        events, err := h.eventStore.LoadEventsAfterVersion(ctx, orderID, version)
        if err != nil {
            return nil, err
        }
        
        for _, event := range events {
            if err := order.ApplyEvent(event); err != nil {
                return nil, err
            }
        }
    } else {
        // 没有快照,加载所有事件
        events, err := h.eventStore.LoadEvents(ctx, orderID)
        if err != nil {
            return nil, err
        }
        
        if len(events) == 0 {
            return nil, fmt.Errorf("order not found")
        }
        
        order = domain.NewOrderAggregate(orderID)
        for _, event := range events {
            if err := order.ApplyEvent(event); err != nil {
                return nil, err
            }
        }
        
        // 每100个事件创建一次快照
        if order.Version() % 100 == 0 {
            snapshotStore.SaveSnapshot(ctx, order)
        }
    }
    
    return order, nil
}
```

---

## 8. 最终一致性与幂等性

### 8.1 幂等性保证

```go
// idempotency/middleware.go
package idempotency

import (
    "context"
    "crypto/sha256"
    "database/sql"
    "encoding/hex"
    "fmt"
    "time"
)

// IdempotencyMiddleware 幂等性中间件
type IdempotencyMiddleware struct {
    db *sql.DB
}

func NewIdempotencyMiddleware(db *sql.DB) *IdempotencyMiddleware {
    // 创建幂等性表
    schema := `
    CREATE TABLE IF NOT EXISTS idempotency_keys (
        idempotency_key VARCHAR(255) PRIMARY KEY,
        request_hash VARCHAR(64) NOT NULL,
        response JSONB,
        status VARCHAR(50) NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        expires_at TIMESTAMP NOT NULL
    );
    CREATE INDEX IF NOT EXISTS idx_idempotency_expires ON idempotency_keys(expires_at);
    `
    db.Exec(schema)
    
    return &IdempotencyMiddleware{db: db}
}

// ExecuteIdempotent 幂等执行
func (m *IdempotencyMiddleware) ExecuteIdempotent(
    ctx context.Context,
    idempotencyKey string,
    fn func(ctx context.Context) (interface{}, error),
) (interface{}, error) {
    // 1. 检查幂等性Key是否存在
    var status string
    var response []byte
    
    err := m.db.QueryRowContext(ctx,
        "SELECT status, response FROM idempotency_keys WHERE idempotency_key = $1",
        idempotencyKey,
    ).Scan(&status, &response)
    
    if err == nil {
        // 已存在
        if status == "COMPLETED" {
            // 返回缓存结果
            return response, nil
        } else if status == "PROCESSING" {
            // 正在处理,返回冲突
            return nil, fmt.Errorf("request is being processed")
        }
    } else if err != sql.ErrNoRows {
        return nil, err
    }
    
    // 2. 插入幂等性Key (状态: PROCESSING)
    _, err = m.db.ExecContext(ctx, `
        INSERT INTO idempotency_keys (idempotency_key, request_hash, status, expires_at)
        VALUES ($1, $2, $3, $4)
        ON CONFLICT (idempotency_key) DO NOTHING
    `, idempotencyKey, "hash", "PROCESSING", time.Now().Add(24*time.Hour))
    
    if err != nil {
        return nil, err
    }
    
    // 3. 执行实际操作
    result, err := fn(ctx)
    
    // 4. 更新结果
    if err != nil {
        m.db.ExecContext(ctx,
            "UPDATE idempotency_keys SET status = $1 WHERE idempotency_key = $2",
            "FAILED", idempotencyKey,
        )
        return nil, err
    }
    
    resultJSON, _ := json.Marshal(result)
    m.db.ExecContext(ctx,
        "UPDATE idempotency_keys SET status = $1, response = $2 WHERE idempotency_key = $3",
        "COMPLETED", resultJSON, idempotencyKey,
    )
    
    return result, nil
}

// GenerateIdempotencyKey 生成幂等性Key
func GenerateIdempotencyKey(userID, operation string, params interface{}) string {
    data := fmt.Sprintf("%s:%s:%v", userID, operation, params)
    hash := sha256.Sum256([]byte(data))
    return hex.EncodeToString(hash[:])
}
```

### 8.2 最终一致性检测

```go
// consistency/checker.go
package consistency

import (
    "context"
    "database/sql"
    "fmt"
    "time"
)

// ConsistencyChecker 一致性检查器
type ConsistencyChecker struct {
    eventDB *sql.DB
    readDB  *sql.DB
}

func NewConsistencyChecker(eventDB, readDB *sql.DB) *ConsistencyChecker {
    return &ConsistencyChecker{
        eventDB: eventDB,
        readDB:  readDB,
    }
}

// CheckOrderConsistency 检查订单一致性
func (c *ConsistencyChecker) CheckOrderConsistency(ctx context.Context, orderID string) error {
    // 1. 从事件流重建状态
    expectedState, err := c.rebuildFromEvents(ctx, orderID)
    if err != nil {
        return err
    }
    
    // 2. 从读模型获取状态
    actualState, err := c.getReadModelState(ctx, orderID)
    if err != nil {
        return err
    }
    
    // 3. 对比
    if !c.statesEqual(expectedState, actualState) {
        return fmt.Errorf("consistency check failed for order %s", orderID)
    }
    
    return nil
}

func (c *ConsistencyChecker) rebuildFromEvents(ctx context.Context, orderID string) (interface{}, error) {
    // 从事件表重建
    return nil, nil
}

func (c *ConsistencyChecker) getReadModelState(ctx context.Context, orderID string) (interface{}, error) {
    // 从读模型查询
    return nil, nil
}

func (c *ConsistencyChecker) statesEqual(a, b interface{}) bool {
    // 对比状态
    return true
}

// StartPeriodicCheck 定期一致性检查
func (c *ConsistencyChecker) StartPeriodicCheck(ctx context.Context, interval time.Duration) {
    ticker := time.NewTicker(interval)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            c.runFullCheck(ctx)
        case <-ctx.Done():
            return
        }
    }
}

func (c *ConsistencyChecker) runFullCheck(ctx context.Context) {
    fmt.Println("[ConsistencyChecker] Running full consistency check...")
    // 检查所有聚合根
}
```

---

## 9. 完整示例

```go
// cmd/main.go
package main

import (
    "context"
    "fmt"
    "log"
    "database/sql"
    
    _ "github.com/lib/pq"
    "yourapp/cqrs"
    "yourapp/domain"
    "yourapp/eventstore"
    "yourapp/projection"
)

func main() {
    ctx := context.Background()
    
    // 1. 连接Event Store (PostgreSQL)
    eventDB, err := sql.Open("postgres", "postgres://user:pass@localhost/events?sslmode=disable")
    if err != nil {
        log.Fatal(err)
    }
    defer eventDB.Close()
    
    // 2. 连接Read Model (可以是不同的数据库)
    readDB, err := sql.Open("postgres", "postgres://user:pass@localhost/readmodel?sslmode=disable")
    if err != nil {
        log.Fatal(err)
    }
    defer readDB.Close()
    
    // 3. 创建Event Store
    eventStore, err := eventstore.NewPostgresEventStore(eventDB)
    if err != nil {
        log.Fatal(err)
    }
    
    // 4. 创建Command Handler
    commandHandler := cqrs.NewOrderCommandHandler(eventStore)
    
    // 5. 创建Query Handler
    queryHandler := cqrs.NewOrderQueryHandler(readDB)
    
    // 6. 启动Projection Manager
    projectionMgr := projection.NewProjectionManager(eventStore)
    projectionMgr.RegisterProjection(projection.NewOrderProjection(readDB))
    go projectionMgr.Start(ctx)
    
    // === 使用示例 ===
    
    // 创建订单
    createCmd := cqrs.CreateOrderCommand{
        OrderID: "order-001",
        UserID:  "user-123",
        Items: []domain.OrderItem{
            {ProductID: "prod-1", Quantity: 2, Price: 99.99},
            {ProductID: "prod-2", Quantity: 1, Price: 149.99},
        },
    }
    
    if err := commandHandler.Handle(ctx, createCmd); err != nil {
        log.Fatal(err)
    }
    
    fmt.Println("✅ Order created")
    
    // 支付订单
    payCmd := cqrs.PayOrderCommand{
        OrderID:       "order-001",
        PaymentMethod: "credit_card",
        Amount:        349.97,
    }
    
    if err := commandHandler.Handle(ctx, payCmd); err != nil {
        log.Fatal(err)
    }
    
    fmt.Println("✅ Order paid")
    
    // 查询订单详情
    query := cqrs.GetOrderDetailQuery{OrderID: "order-001"}
    result, err := queryHandler.Handle(ctx, query)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("📦 Order Detail: %+v\n", result)
    
    // 查询用户订单列表
    listQuery := cqrs.ListUserOrdersQuery{
        UserID: "user-123",
        Limit:  10,
        Offset: 0,
    }
    
    orders, err := queryHandler.Handle(ctx, listQuery)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("📋 User Orders: %+v\n", orders)
}
```

---

## 10. 总结

### 10.1 优势与劣势

```yaml
Event Sourcing优势:
  - 完整审计日志
  - 时间旅行 (回溯任意时刻状态)
  - 事件重放 (修复Bug)
  - 事件驱动架构天然支持

Event Sourcing劣势:
  - 学习曲线陡峭
  - 复杂度高
  - 查询复杂 (需要重建状态)
  - 事件Schema演化困难

CQRS优势:
  - 读写分离
  - 性能优化 (读写独立扩展)
  - 复杂查询优化
  - 适合事件驱动

CQRS劣势:
  - 最终一致性
  - 维护成本高 (两套模型)
  - 同步延迟

适用场景:
  - 金融系统 (审计要求)
  - 电商订单 (状态追溯)
  - 协作软件 (版本控制)
  - IoT数据 (时序数据)
```

### 10.2 最佳实践

```text
1. 事件设计
   - 使用过去时命名 (OrderCreated, UserUpdated)
   - 事件不可变
   - 包含所有必要信息 (避免依赖外部查询)
   - 小事件原则 (单一职责)

2. 聚合根设计
   - 一个事务只修改一个聚合根
   - 聚合根边界要清晰
   - 避免跨聚合根查询

3. 快照策略
   - 每N个事件创建快照 (N=100-1000)
   - 异步创建快照 (不阻塞主流程)
   - 定期清理旧快照

4. Projection优化
   - 异步投影
   - 支持重建 (Rebuild)
   - 幂等性
   - 监控延迟

5. 事件版本化
   - 使用Upcaster模式
   - 向后兼容
   - 事件迁移策略
```

**恭喜!** 🎉 您已掌握Go 1.25.3 Event Sourcing与CQRS的完整实战技能!

---

## 📚 参考资料

- [Event Sourcing Pattern](https://martinfowler.com/eaaDev/EventSourcing.html)
- [CQRS Pattern](https://martinfowler.com/bliki/CQRS.html)
- [EventStore DB](https://www.eventstore.com/)
- [Implementing Domain-Driven Design (Book)](https://www.oreilly.com/library/view/implementing-domain-driven-design/9780133039900/)
- [Versioning in an Event Sourced System](https://leanpub.com/esversioning)
