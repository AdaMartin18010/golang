# Go 1.25.3‰∫ã‰ª∂Ê∫ØÊ∫ê‰∏éCQRSÂÆåÊï¥ÂÆûÊàò

> **ÈöæÂ∫¶**: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
> **Ê†áÁ≠æ**: `Event Sourcing` `CQRS` `DDD` `EventStore` `Projection` `ÊúÄÁªà‰∏ÄËá¥ÊÄß` `‰∫ã‰ª∂È©±Âä®`

**ÁâàÊú¨**: v1.0
**Êõ¥Êñ∞Êó•Êúü**: 2025-10-29
**ÈÄÇÁî®‰∫é**: Go 1.25.3

---

## üìã ÁõÆÂΩï

- [Go 1.25.3‰∫ã‰ª∂Ê∫ØÊ∫ê‰∏éCQRSÂÆåÊï¥ÂÆûÊàò](#go-1253‰∫ã‰ª∂Ê∫ØÊ∫ê‰∏écqrsÂÆåÊï¥ÂÆûÊàò)
  - [üìã ÁõÆÂΩï](#-ÁõÆÂΩï)
  - [1. Event Sourcing‰∏éCQRSÊ¶ÇËø∞](#1-event-sourcing‰∏écqrsÊ¶ÇËø∞)
    - [1.1 ‰ªÄ‰πàÊòØEvent Sourcing](#11-‰ªÄ‰πàÊòØevent-sourcing)
    - [1.2 ‰ªÄ‰πàÊòØCQRS](#12-‰ªÄ‰πàÊòØcqrs)
  - [2. Event SourcingÂÆûÁé∞](#2-event-sourcingÂÆûÁé∞)
    - [2.1 EventÂÆö‰πâ](#21-eventÂÆö‰πâ)
    - [2.2 AggregateËÅöÂêàÊ†π](#22-aggregateËÅöÂêàÊ†π)
    - [2.3 Event StoreÂÆûÁé∞](#23-event-storeÂÆûÁé∞)
  - [3. CQRSÊ®°ÂºèÂÆûÁé∞](#3-cqrsÊ®°ÂºèÂÆûÁé∞)
    - [3.1 CommandÁ´Ø (ÂÜôÊ®°Âûã)](#31-commandÁ´Ø-ÂÜôÊ®°Âûã)
    - [3.2 QueryÁ´Ø (ËØªÊ®°Âûã)](#32-queryÁ´Ø-ËØªÊ®°Âûã)
  - [4. Event StoreËÆæËÆ°](#4-event-storeËÆæËÆ°)
    - [4.1 Êï∞ÊçÆÂ∫ìSchema](#41-Êï∞ÊçÆÂ∫ìschema)
  - [5. Projection‰∏éRead Model](#5-projection‰∏éread-model)
    - [5.1 ProjectionÂÆûÁé∞](#51-projectionÂÆûÁé∞)
    - [5.2 Projection Manager](#52-projection-manager)
  - [6. Saga‰∏éProcess Manager](#6-saga‰∏éprocess-manager)
    - [6.1 SagaÂÆûÁé∞](#61-sagaÂÆûÁé∞)
  - [7. Âø´ÁÖß‰∏éÊÄßËÉΩ‰ºòÂåñ](#7-Âø´ÁÖß‰∏éÊÄßËÉΩ‰ºòÂåñ)
    - [7.1 SnapshotÂÆûÁé∞](#71-snapshotÂÆûÁé∞)
  - [8. ÊúÄÁªà‰∏ÄËá¥ÊÄß‰∏éÂπÇÁ≠âÊÄß](#8-ÊúÄÁªà‰∏ÄËá¥ÊÄß‰∏éÂπÇÁ≠âÊÄß)
    - [8.1 ÂπÇÁ≠âÊÄß‰øùËØÅ](#81-ÂπÇÁ≠âÊÄß‰øùËØÅ)
    - [8.2 ÊúÄÁªà‰∏ÄËá¥ÊÄßÊ£ÄÊµã](#82-ÊúÄÁªà‰∏ÄËá¥ÊÄßÊ£ÄÊµã)
  - [9. ÂÆåÊï¥Á§∫‰æã](#9-ÂÆåÊï¥Á§∫‰æã)
  - [10. ÊÄªÁªì](#10-ÊÄªÁªì)
    - [10.1 ‰ºòÂäø‰∏éÂä£Âäø](#101-‰ºòÂäø‰∏éÂä£Âäø)
    - [10.2 ÊúÄ‰Ω≥ÂÆûË∑µ](#102-ÊúÄ‰Ω≥ÂÆûË∑µ)
  - [üìö ÂèÇËÄÉËµÑÊñô](#-ÂèÇËÄÉËµÑÊñô)

## 1. Event Sourcing‰∏éCQRSÊ¶ÇËø∞

### 1.1 ‰ªÄ‰πàÊòØEvent Sourcing

```go
// Event SourcingÊ†∏ÂøÉÊÄùÊÉ≥
/*
‰º†ÁªüCRUDÊ®°Âûã:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  User Table  ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ ‚îÇ id: 123  ‚îÇ ‚îÇ  ‚Üê Âè™Â≠òÂÇ®ÂΩìÂâçÁä∂ÊÄÅ
‚îÇ ‚îÇ name: Bob‚îÇ ‚îÇ
‚îÇ ‚îÇ age: 30  ‚îÇ ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
ÈóÆÈ¢ò: Êó†Ê≥ïÂõûÊ∫ØÂéÜÂè≤,Êó†Ê≥ïÂÆ°ËÆ°

Event SourcingÊ®°Âûã:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        Event Store (Event Stream)        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Event 1: UserCreated {id:123, name:Alice} ‚îÇ
‚îÇ Event 2: UserRenamed {id:123, name:Bob}   ‚îÇ
‚îÇ Event 3: UserAged {id:123, age:30}        ‚îÇ
‚îÇ Event 4: UserEmailUpdated {id:123, ...}   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚Üì (Replay Events)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Current State‚îÇ
‚îÇ id: 123      ‚îÇ
‚îÇ name: Bob    ‚îÇ
‚îÇ age: 30      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‰ºòÂäø:
1. ÂÆåÊï¥ÂÆ°ËÆ°Êó•Âøó
2. Êó∂Èó¥ÊóÖË°å (Time Travel)
3. ‰∫ã‰ª∂Ê∫ØÊ∫ê (Debug)
4. ‰∫ã‰ª∂ÈáçÊîæ (Replay)
*/
```

### 1.2 ‰ªÄ‰πàÊòØCQRS

```go
// CQRS (Command Query Responsibility Segregation)
/*
‰º†ÁªüÊ®°Âûã:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Client ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   Model  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ  (CRUD)  ‚îÇ
               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ËØªÂÜôÂÖ±Áî®Âêå‰∏ÄÊ®°Âûã

CQRSÊ®°Âûã:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Client ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ
     ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ                             ‚îÇ
     ‚ñº                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Command ‚îÇ                  ‚îÇ  Query  ‚îÇ
‚îÇ  Model  ‚îÇ                  ‚îÇ  Model  ‚îÇ
‚îÇ (Write) ‚îÇ                  ‚îÇ  (Read) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚ñ≤‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ                             ‚îÇ
     ‚îÇ Events                      ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‰ºòÂäø:
1. ËØªÂÜôÂàÜÁ¶ª
2. Áã¨Á´ãÊâ©Â±ï
3. ÊÄßËÉΩ‰ºòÂåñ
4. Â§çÊùÇÊü•ËØ¢‰ºòÂåñ
*/

// Example: ÁîµÂïÜËÆ¢ÂçïÁ≥ªÁªü
type TraditionalModel struct {
    // ËØªÂÜôÊ∑∑Âêà,Èöæ‰ª•‰ºòÂåñ
    CreateOrder(order Order) error
    UpdateOrder(orderId string, updates OrderUpdates) error
    GetOrder(orderId string) (Order, error)
    ListOrders(userId string, filters Filters) ([]Order, error)
    GetOrderStatistics(userId string) (Statistics, error)
}

type CQRSModel struct {
    // ÂëΩ‰ª§Á´Ø (Write Model)
    CommandHandler struct {
        CreateOrder CreateOrderCommand
        CancelOrder CancelOrderCommand
        ShipOrder   ShipOrderCommand
    }

    // Êü•ËØ¢Á´Ø (Read Model)
    QueryHandler struct {
        GetOrderDetail       GetOrderDetailQuery
        ListUserOrders       ListUserOrdersQuery
        GetOrderStatistics   GetOrderStatisticsQuery
        GetRecommendations   GetRecommendationsQuery
    }
}
```

---

## 2. Event SourcingÂÆûÁé∞

### 2.1 EventÂÆö‰πâ

```go
// domain/event.go
package domain

import (
    "encoding/json"
    "time"
    "github.com/google/uuid"
)

// Event ‰∫ã‰ª∂Êé•Âè£
type Event interface {
    EventID() string
    EventType() string
    AggregateID() string
    AggregateType() string
    Version() int64
    Timestamp() time.Time
    Data() interface{}
}

// BaseEvent ‰∫ã‰ª∂Âü∫Á±ª
type BaseEvent struct {
    ID            string      `json:"id"`
    Type          string      `json:"type"`
    AggregateIdVal   string      `json:"aggregate_id"`
    AggregateTypeVal string      `json:"aggregate_type"`
    Ver           int64       `json:"version"`
    Time          time.Time   `json:"timestamp"`
    Metadata      map[string]string `json:"metadata"`
    Payload       json.RawMessage `json:"payload"`
}

func (e BaseEvent) EventID() string         { return e.ID }
func (e BaseEvent) EventType() string       { return e.Type }
func (e BaseEvent) AggregateID() string     { return e.AggregateIdVal }
func (e BaseEvent) AggregateType() string   { return e.AggregateTypeVal }
func (e BaseEvent) Version() int64          { return e.Ver }
func (e BaseEvent) Timestamp() time.Time    { return e.Time }
func (e BaseEvent) Data() interface{}       { return e.Payload }

// NewBaseEvent ÂàõÂª∫Âü∫Á°Ä‰∫ã‰ª∂
func NewBaseEvent(eventType, aggregateID, aggregateType string, version int64, payload interface{}) (*BaseEvent, error) {
    data, err := json.Marshal(payload)
    if err != nil {
        return nil, err
    }

    return &BaseEvent{
        ID:            uuid.New().String(),
        Type:          eventType,
        AggregateIdVal:   aggregateID,
        AggregateTypeVal: aggregateType,
        Ver:           version,
        Time:          time.Now().UTC(),
        Metadata:      make(map[string]string),
        Payload:       data,
    }, nil
}

// ÂÖ∑‰Ωì‰∫ã‰ª∂Á±ªÂûã
// Áî®Êà∑‰∫ã‰ª∂
type UserCreatedEvent struct {
    UserID   string `json:"user_id"`
    Username string `json:"username"`
    Email    string `json:"email"`
}

type UserEmailUpdatedEvent struct {
    UserID   string `json:"user_id"`
    OldEmail string `json:"old_email"`
    NewEmail string `json:"new_email"`
}

type UserDeletedEvent struct {
    UserID string `json:"user_id"`
    Reason string `json:"reason"`
}

// ËÆ¢Âçï‰∫ã‰ª∂
type OrderCreatedEvent struct {
    OrderID      string    `json:"order_id"`
    UserID       string    `json:"user_id"`
    Items        []OrderItem `json:"items"`
    TotalAmount  float64   `json:"total_amount"`
    CreatedAt    time.Time `json:"created_at"`
}

type OrderItem struct {
    ProductID string  `json:"product_id"`
    Quantity  int     `json:"quantity"`
    Price     float64 `json:"price"`
}

type OrderPaidEvent struct {
    OrderID       string    `json:"order_id"`
    PaymentMethod string    `json:"payment_method"`
    Amount        float64   `json:"amount"`
    PaidAt        time.Time `json:"paid_at"`
}

type OrderShippedEvent struct {
    OrderID        string    `json:"order_id"`
    TrackingNumber string    `json:"tracking_number"`
    ShippedAt      time.Time `json:"shipped_at"`
}

type OrderCancelledEvent struct {
    OrderID   string `json:"order_id"`
    Reason    string `json:"reason"`
    CancelledAt time.Time `json:"cancelled_at"`
}
```

### 2.2 AggregateËÅöÂêàÊ†π

```go
// domain/aggregate.go
package domain

import (
    "fmt"
)

// Aggregate ËÅöÂêàÊ†πÊé•Âè£
type Aggregate interface {
    AggregateID() string
    AggregateType() string
    Version() int64
    UncommittedEvents() []Event
    ClearUncommittedEvents()
    ApplyEvent(event Event) error
}

// BaseAggregate ËÅöÂêàÊ†πÂü∫Á±ª
type BaseAggregate struct {
    ID                string
    Type              string
    Ver               int64
    uncommittedEvents []Event
}

func (a *BaseAggregate) AggregateID() string   { return a.ID }
func (a *BaseAggregate) AggregateType() string { return a.Type }
func (a *BaseAggregate) Version() int64        { return a.Ver }
func (a *BaseAggregate) UncommittedEvents() []Event { return a.uncommittedEvents }

func (a *BaseAggregate) ClearUncommittedEvents() {
    a.uncommittedEvents = nil
}

func (a *BaseAggregate) raiseEvent(event Event) {
    a.uncommittedEvents = append(a.uncommittedEvents, event)
    a.Ver++
}

// OrderAggregate ËÆ¢ÂçïËÅöÂêàÊ†π
type OrderAggregate struct {
    BaseAggregate

    // Áä∂ÊÄÅÂ≠óÊÆµ
    UserID       string
    Items        []OrderItem
    TotalAmount  float64
    Status       OrderStatus
    PaymentInfo  *PaymentInfo
    ShippingInfo *ShippingInfo
}

type OrderStatus string

const (
    OrderStatusPending   OrderStatus = "PENDING"
    OrderStatusPaid      OrderStatus = "PAID"
    OrderStatusShipped   OrderStatus = "SHIPPED"
    OrderStatusDelivered OrderStatus = "DELIVERED"
    OrderStatusCancelled OrderStatus = "CANCELLED"
)

type PaymentInfo struct {
    Method string
    Amount float64
    PaidAt time.Time
}

type ShippingInfo struct {
    TrackingNumber string
    ShippedAt      time.Time
}

// NewOrderAggregate ÂàõÂª∫ËÆ¢ÂçïËÅöÂêà
func NewOrderAggregate(orderID string) *OrderAggregate {
    return &OrderAggregate{
        BaseAggregate: BaseAggregate{
            ID:   orderID,
            Type: "Order",
            Ver:  0,
        },
        Status: OrderStatusPending,
    }
}

// CreateOrder ÂàõÂª∫ËÆ¢ÂçïÂëΩ‰ª§
func (o *OrderAggregate) CreateOrder(userID string, items []OrderItem) error {
    if o.Status != "" && o.Status != OrderStatusPending {
        return fmt.Errorf("order already created")
    }

    // ËÆ°ÁÆóÊÄªÈ¢ù
    var totalAmount float64
    for _, item := range items {
        totalAmount += item.Price * float64(item.Quantity)
    }

    // ÂàõÂª∫‰∫ã‰ª∂
    event, err := NewBaseEvent(
        "OrderCreated",
        o.ID,
        o.Type,
        o.Ver+1,
        OrderCreatedEvent{
            OrderID:     o.ID,
            UserID:      userID,
            Items:       items,
            TotalAmount: totalAmount,
            CreatedAt:   time.Now().UTC(),
        },
    )
    if err != nil {
        return err
    }

    // Â∫îÁî®‰∫ã‰ª∂
    if err := o.ApplyEvent(event); err != nil {
        return err
    }

    o.raiseEvent(event)
    return nil
}

// Pay ÊîØ‰ªòËÆ¢Âçï
func (o *OrderAggregate) Pay(paymentMethod string, amount float64) error {
    if o.Status != OrderStatusPending {
        return fmt.Errorf("order is not in pending status")
    }

    if amount != o.TotalAmount {
        return fmt.Errorf("payment amount mismatch")
    }

    event, err := NewBaseEvent(
        "OrderPaid",
        o.ID,
        o.Type,
        o.Ver+1,
        OrderPaidEvent{
            OrderID:       o.ID,
            PaymentMethod: paymentMethod,
            Amount:        amount,
            PaidAt:        time.Now().UTC(),
        },
    )
    if err != nil {
        return err
    }

    if err := o.ApplyEvent(event); err != nil {
        return err
    }

    o.raiseEvent(event)
    return nil
}

// Ship ÂèëË¥ß
func (o *OrderAggregate) Ship(trackingNumber string) error {
    if o.Status != OrderStatusPaid {
        return fmt.Errorf("order is not paid")
    }

    event, err := NewBaseEvent(
        "OrderShipped",
        o.ID,
        o.Type,
        o.Ver+1,
        OrderShippedEvent{
            OrderID:        o.ID,
            TrackingNumber: trackingNumber,
            ShippedAt:      time.Now().UTC(),
        },
    )
    if err != nil {
        return err
    }

    if err := o.ApplyEvent(event); err != nil {
        return err
    }

    o.raiseEvent(event)
    return nil
}

// Cancel ÂèñÊ∂àËÆ¢Âçï
func (o *OrderAggregate) Cancel(reason string) error {
    if o.Status == OrderStatusShipped || o.Status == OrderStatusDelivered {
        return fmt.Errorf("cannot cancel shipped/delivered order")
    }

    if o.Status == OrderStatusCancelled {
        return fmt.Errorf("order already cancelled")
    }

    event, err := NewBaseEvent(
        "OrderCancelled",
        o.ID,
        o.Type,
        o.Ver+1,
        OrderCancelledEvent{
            OrderID:     o.ID,
            Reason:      reason,
            CancelledAt: time.Now().UTC(),
        },
    )
    if err != nil {
        return err
    }

    if err := o.ApplyEvent(event); err != nil {
        return err
    }

    o.raiseEvent(event)
    return nil
}

// ApplyEvent Â∫îÁî®‰∫ã‰ª∂ (Êõ¥Êñ∞Áä∂ÊÄÅ)
func (o *OrderAggregate) ApplyEvent(event Event) error {
    var payload interface{}

    switch event.EventType() {
    case "OrderCreated":
        var e OrderCreatedEvent
        if err := json.Unmarshal(event.(*BaseEvent).Payload, &e); err != nil {
            return err
        }
        payload = e
        o.UserID = e.UserID
        o.Items = e.Items
        o.TotalAmount = e.TotalAmount
        o.Status = OrderStatusPending

    case "OrderPaid":
        var e OrderPaidEvent
        if err := json.Unmarshal(event.(*BaseEvent).Payload, &e); err != nil {
            return err
        }
        payload = e
        o.PaymentInfo = &PaymentInfo{
            Method: e.PaymentMethod,
            Amount: e.Amount,
            PaidAt: e.PaidAt,
        }
        o.Status = OrderStatusPaid

    case "OrderShipped":
        var e OrderShippedEvent
        if err := json.Unmarshal(event.(*BaseEvent).Payload, &e); err != nil {
            return err
        }
        payload = e
        o.ShippingInfo = &ShippingInfo{
            TrackingNumber: e.TrackingNumber,
            ShippedAt:      e.ShippedAt,
        }
        o.Status = OrderStatusShipped

    case "OrderCancelled":
        var e OrderCancelledEvent
        if err := json.Unmarshal(event.(*BaseEvent).Payload, &e); err != nil {
            return err
        }
        payload = e
        o.Status = OrderStatusCancelled

    default:
        return fmt.Errorf("unknown event type: %s", event.EventType())
    }

    o.Ver = event.Version()
    _ = payload
    return nil
}
```

### 2.3 Event StoreÂÆûÁé∞

```go
// eventstore/store.go
package eventstore

import (
    "context"
    "database/sql"
    "encoding/json"
    "fmt"
    "time"

    "github.com/lib/pq"
    "yourapp/domain"
)

// EventStore ‰∫ã‰ª∂Â≠òÂÇ®Êé•Âè£
type EventStore interface {
    SaveEvents(ctx context.Context, aggregateID string, events []domain.Event, expectedVersion int64) error
    LoadEvents(ctx context.Context, aggregateID string) ([]domain.Event, error)
    LoadEventsAfterVersion(ctx context.Context, aggregateID string, version int64) ([]domain.Event, error)
    SubscribeToStream(ctx context.Context, streamName string, handler EventHandler) error
}

// EventHandler ‰∫ã‰ª∂Â§ÑÁêÜÂô®
type EventHandler func(event domain.Event) error

// PostgresEventStore PostgreSQLÂÆûÁé∞
type PostgresEventStore struct {
    db *sql.DB
}

// NewPostgresEventStore ÂàõÂª∫EventStore
func NewPostgresEventStore(db *sql.DB) (*PostgresEventStore, error) {
    // ÂàõÂª∫Ë°®
    schema := `
    CREATE TABLE IF NOT EXISTS events (
        id SERIAL PRIMARY KEY,
        event_id UUID NOT NULL UNIQUE,
        event_type VARCHAR(255) NOT NULL,
        aggregate_id VARCHAR(255) NOT NULL,
        aggregate_type VARCHAR(255) NOT NULL,
        version BIGINT NOT NULL,
        timestamp TIMESTAMP NOT NULL,
        metadata JSONB,
        payload JSONB NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(aggregate_id, version)
    );

    CREATE INDEX IF NOT EXISTS idx_events_aggregate ON events(aggregate_id, version);
    CREATE INDEX IF NOT EXISTS idx_events_timestamp ON events(timestamp);
    CREATE INDEX IF NOT EXISTS idx_events_type ON events(event_type);
    `

    if _, err := db.Exec(schema); err != nil {
        return nil, err
    }

    return &PostgresEventStore{db: db}, nil
}

// SaveEvents ‰øùÂ≠ò‰∫ã‰ª∂ (ÂéüÂ≠êÊìç‰Ωú)
func (s *PostgresEventStore) SaveEvents(ctx context.Context, aggregateID string, events []domain.Event, expectedVersion int64) error {
    if len(events) == 0 {
        return nil
    }

    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // ‰πêËßÇÈîÅ: Ê£ÄÊü•ÁâàÊú¨
    var currentVersion int64
    err = tx.QueryRowContext(ctx,
        "SELECT COALESCE(MAX(version), 0) FROM events WHERE aggregate_id = $1",
        aggregateID,
    ).Scan(&currentVersion)
    if err != nil {
        return err
    }

    if currentVersion != expectedVersion {
        return fmt.Errorf("concurrency conflict: expected version %d, got %d", expectedVersion, currentVersion)
    }

    // ÊèíÂÖ•‰∫ã‰ª∂
    stmt, err := tx.PrepareContext(ctx, `
        INSERT INTO events (event_id, event_type, aggregate_id, aggregate_type, version, timestamp, metadata, payload)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    `)
    if err != nil {
        return err
    }
    defer stmt.Close()

    for _, event := range events {
        baseEvent := event.(*domain.BaseEvent)
        metadata, _ := json.Marshal(baseEvent.Metadata)

        _, err = stmt.ExecContext(ctx,
            baseEvent.ID,
            baseEvent.Type,
            baseEvent.AggregateIdVal,
            baseEvent.AggregateTypeVal,
            baseEvent.Ver,
            baseEvent.Time,
            metadata,
            baseEvent.Payload,
        )
        if err != nil {
            return err
        }
    }

    return tx.Commit()
}

// LoadEvents Âä†ËΩΩÊâÄÊúâ‰∫ã‰ª∂
func (s *PostgresEventStore) LoadEvents(ctx context.Context, aggregateID string) ([]domain.Event, error) {
    return s.LoadEventsAfterVersion(ctx, aggregateID, 0)
}

// LoadEventsAfterVersion Âä†ËΩΩÊåáÂÆöÁâàÊú¨‰πãÂêéÁöÑ‰∫ã‰ª∂
func (s *PostgresEventStore) LoadEventsAfterVersion(ctx context.Context, aggregateID string, version int64) ([]domain.Event, error) {
    rows, err := s.db.QueryContext(ctx, `
        SELECT event_id, event_type, aggregate_id, aggregate_type, version, timestamp, metadata, payload
        FROM events
        WHERE aggregate_id = $1 AND version > $2
        ORDER BY version ASC
    `, aggregateID, version)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var events []domain.Event
    for rows.Next() {
        var e domain.BaseEvent
        var metadata []byte

        err := rows.Scan(
            &e.ID,
            &e.Type,
            &e.AggregateIdVal,
            &e.AggregateTypeVal,
            &e.Ver,
            &e.Time,
            &metadata,
            &e.Payload,
        )
        if err != nil {
            return nil, err
        }

        json.Unmarshal(metadata, &e.Metadata)
        events = append(events, &e)
    }

    return events, rows.Err()
}

// SubscribeToStream ËÆ¢ÈòÖ‰∫ã‰ª∂ÊµÅ (‰ΩøÁî®PostgreSQL LISTEN/NOTIFY)
func (s *PostgresEventStore) SubscribeToStream(ctx context.Context, streamName string, handler EventHandler) error {
    listener := pq.NewListener(
        s.db.(*sql.DB).Driver().(*pq.Driver).ConnStr(),
        10*time.Second,
        time.Minute,
        func(ev pq.ListenerEventType, err error) {
            if err != nil {
                fmt.Printf("Listener error: %v\n", err)
            }
        },
    )
    defer listener.Close()

    if err := listener.Listen(streamName); err != nil {
        return err
    }

    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        case notification := <-listener.Notify:
            if notification == nil {
                continue
            }

            // Ëß£Êûê‰∫ã‰ª∂
            var event domain.BaseEvent
            if err := json.Unmarshal([]byte(notification.Extra), &event); err != nil {
                fmt.Printf("Failed to unmarshal event: %v\n", err)
                continue
            }

            // Â§ÑÁêÜ‰∫ã‰ª∂
            if err := handler(&event); err != nil {
                fmt.Printf("Handler error: %v\n", err)
            }
        }
    }
}
```

---

## 3. CQRSÊ®°ÂºèÂÆûÁé∞

### 3.1 CommandÁ´Ø (ÂÜôÊ®°Âûã)

```go
// cqrs/command.go
package cqrs

import (
    "context"
    "fmt"
    "yourapp/domain"
    "yourapp/eventstore"
)

// Command ÂëΩ‰ª§Êé•Âè£
type Command interface {
    CommandID() string
    AggregateID() string
}

// CommandHandler ÂëΩ‰ª§Â§ÑÁêÜÂô®
type CommandHandler interface {
    Handle(ctx context.Context, command Command) error
}

// CreateOrderCommand ÂàõÂª∫ËÆ¢ÂçïÂëΩ‰ª§
type CreateOrderCommand struct {
    OrderID string
    UserID  string
    Items   []domain.OrderItem
}

func (c CreateOrderCommand) CommandID() string   { return "CreateOrder" }
func (c CreateOrderCommand) AggregateID() string { return c.OrderID }

// PayOrderCommand ÊîØ‰ªòËÆ¢ÂçïÂëΩ‰ª§
type PayOrderCommand struct {
    OrderID       string
    PaymentMethod string
    Amount        float64
}

func (c PayOrderCommand) CommandID() string   { return "PayOrder" }
func (c PayOrderCommand) AggregateID() string { return c.OrderID }

// OrderCommandHandler ËÆ¢ÂçïÂëΩ‰ª§Â§ÑÁêÜÂô®
type OrderCommandHandler struct {
    eventStore eventstore.EventStore
}

func NewOrderCommandHandler(eventStore eventstore.EventStore) *OrderCommandHandler {
    return &OrderCommandHandler{eventStore: eventStore}
}

// Handle Â§ÑÁêÜÂëΩ‰ª§
func (h *OrderCommandHandler) Handle(ctx context.Context, command Command) error {
    switch cmd := command.(type) {
    case CreateOrderCommand:
        return h.handleCreateOrder(ctx, cmd)
    case PayOrderCommand:
        return h.handlePayOrder(ctx, cmd)
    default:
        return fmt.Errorf("unknown command type: %T", command)
    }
}

func (h *OrderCommandHandler) handleCreateOrder(ctx context.Context, cmd CreateOrderCommand) error {
    // 1. ÂàõÂª∫ËÅöÂêàÊ†π
    order := domain.NewOrderAggregate(cmd.OrderID)

    // 2. ÊâßË°å‰∏öÂä°ÈÄªËæë
    if err := order.CreateOrder(cmd.UserID, cmd.Items); err != nil {
        return err
    }

    // 3. ‰øùÂ≠ò‰∫ã‰ª∂
    events := order.UncommittedEvents()
    if err := h.eventStore.SaveEvents(ctx, order.AggregateID(), events, 0); err != nil {
        return err
    }

    order.ClearUncommittedEvents()
    return nil
}

func (h *OrderCommandHandler) handlePayOrder(ctx context.Context, cmd PayOrderCommand) error {
    // 1. Âä†ËΩΩËÅöÂêàÊ†π (‰∫ã‰ª∂Ê∫ØÊ∫ê)
    order, err := h.loadOrderAggregate(ctx, cmd.OrderID)
    if err != nil {
        return err
    }

    // 2. ÊâßË°å‰∏öÂä°ÈÄªËæë
    if err := order.Pay(cmd.PaymentMethod, cmd.Amount); err != nil {
        return err
    }

    // 3. ‰øùÂ≠òÊñ∞‰∫ã‰ª∂
    events := order.UncommittedEvents()
    if err := h.eventStore.SaveEvents(ctx, order.AggregateID(), events, order.Version()-int64(len(events))); err != nil {
        return err
    }

    order.ClearUncommittedEvents()
    return nil
}

// loadOrderAggregate ‰ªé‰∫ã‰ª∂ÊµÅÈáçÂª∫ËÅöÂêàÊ†π
func (h *OrderCommandHandler) loadOrderAggregate(ctx context.Context, orderID string) (*domain.OrderAggregate, error) {
    // Âä†ËΩΩ‰∫ã‰ª∂
    events, err := h.eventStore.LoadEvents(ctx, orderID)
    if err != nil {
        return nil, err
    }

    if len(events) == 0 {
        return nil, fmt.Errorf("order not found: %s", orderID)
    }

    // ÈáçÊîæ‰∫ã‰ª∂
    order := domain.NewOrderAggregate(orderID)
    for _, event := range events {
        if err := order.ApplyEvent(event); err != nil {
            return nil, err
        }
    }

    return order, nil
}
```

### 3.2 QueryÁ´Ø (ËØªÊ®°Âûã)

```go
// cqrs/query.go
package cqrs

import (
    "context"
    "database/sql"
    "time"
)

// Query Êü•ËØ¢Êé•Âè£
type Query interface {
    QueryID() string
}

// QueryHandler Êü•ËØ¢Â§ÑÁêÜÂô®
type QueryHandler interface {
    Handle(ctx context.Context, query Query) (interface{}, error)
}

// GetOrderDetailQuery Êü•ËØ¢ËÆ¢ÂçïËØ¶ÊÉÖ
type GetOrderDetailQuery struct {
    OrderID string
}

func (q GetOrderDetailQuery) QueryID() string { return "GetOrderDetail" }

// ListUserOrdersQuery Êü•ËØ¢Áî®Êà∑ËÆ¢ÂçïÂàóË°®
type ListUserOrdersQuery struct {
    UserID string
    Status string
    Limit  int
    Offset int
}

func (q ListUserOrdersQuery) QueryID() string { return "ListUserOrders" }

// GetOrderStatisticsQuery Êü•ËØ¢ËÆ¢ÂçïÁªüËÆ°
type GetOrderStatisticsQuery struct {
    UserID    string
    StartDate time.Time
    EndDate   time.Time
}

func (q GetOrderStatisticsQuery) QueryID() string { return "GetOrderStatistics" }

// OrderQueryHandler ËÆ¢ÂçïÊü•ËØ¢Â§ÑÁêÜÂô®
type OrderQueryHandler struct {
    readDB *sql.DB  // ËØªÂ∫ì (ÂèØ‰ª•ÊòØ‰∏çÂêåÁöÑÊï∞ÊçÆÂ∫ì)
}

func NewOrderQueryHandler(readDB *sql.DB) *OrderQueryHandler {
    return &OrderQueryHandler{readDB: readDB}
}

// OrderDetailDTO ËÆ¢ÂçïËØ¶ÊÉÖDTO
type OrderDetailDTO struct {
    OrderID        string      `json:"order_id"`
    UserID         string      `json:"user_id"`
    Items          []OrderItemDTO `json:"items"`
    TotalAmount    float64     `json:"total_amount"`
    Status         string      `json:"status"`
    PaymentMethod  string      `json:"payment_method,omitempty"`
    TrackingNumber string      `json:"tracking_number,omitempty"`
    CreatedAt      time.Time   `json:"created_at"`
    UpdatedAt      time.Time   `json:"updated_at"`
}

type OrderItemDTO struct {
    ProductID   string  `json:"product_id"`
    ProductName string  `json:"product_name"`
    Quantity    int     `json:"quantity"`
    Price       float64 `json:"price"`
}

// Handle Â§ÑÁêÜÊü•ËØ¢
func (h *OrderQueryHandler) Handle(ctx context.Context, query Query) (interface{}, error) {
    switch q := query.(type) {
    case GetOrderDetailQuery:
        return h.handleGetOrderDetail(ctx, q)
    case ListUserOrdersQuery:
        return h.handleListUserOrders(ctx, q)
    case GetOrderStatisticsQuery:
        return h.handleGetOrderStatistics(ctx, q)
    default:
        return nil, fmt.Errorf("unknown query type: %T", query)
    }
}

func (h *OrderQueryHandler) handleGetOrderDetail(ctx context.Context, query GetOrderDetailQuery) (*OrderDetailDTO, error) {
    var dto OrderDetailDTO

    // Êü•ËØ¢‰ºòÂåñÁöÑËØªÊ®°Âûã
    err := h.readDB.QueryRowContext(ctx, `
        SELECT
            order_id, user_id, total_amount, status,
            payment_method, tracking_number,
            created_at, updated_at
        FROM order_read_model
        WHERE order_id = $1
    `, query.OrderID).Scan(
        &dto.OrderID,
        &dto.UserID,
        &dto.TotalAmount,
        &dto.Status,
        &dto.PaymentMethod,
        &dto.TrackingNumber,
        &dto.CreatedAt,
        &dto.UpdatedAt,
    )
    if err != nil {
        return nil, err
    }

    // Êü•ËØ¢ËÆ¢ÂçïÊòéÁªÜ
    rows, err := h.readDB.QueryContext(ctx, `
        SELECT product_id, product_name, quantity, price
        FROM order_items_read_model
        WHERE order_id = $1
    `, query.OrderID)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    for rows.Next() {
        var item OrderItemDTO
        if err := rows.Scan(&item.ProductID, &item.ProductName, &item.Quantity, &item.Price); err != nil {
            return nil, err
        }
        dto.Items = append(dto.Items, item)
    }

    return &dto, nil
}

func (h *OrderQueryHandler) handleListUserOrders(ctx context.Context, query ListUserOrdersQuery) ([]OrderDetailDTO, error) {
    querySQL := `
        SELECT
            order_id, user_id, total_amount, status,
            payment_method, tracking_number,
            created_at, updated_at
        FROM order_read_model
        WHERE user_id = $1
    `

    args := []interface{}{query.UserID}

    if query.Status != "" {
        querySQL += " AND status = $2"
        args = append(args, query.Status)
    }

    querySQL += " ORDER BY created_at DESC LIMIT $3 OFFSET $4"
    args = append(args, query.Limit, query.Offset)

    rows, err := h.readDB.QueryContext(ctx, querySQL, args...)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var orders []OrderDetailDTO
    for rows.Next() {
        var dto OrderDetailDTO
        if err := rows.Scan(
            &dto.OrderID,
            &dto.UserID,
            &dto.TotalAmount,
            &dto.Status,
            &dto.PaymentMethod,
            &dto.TrackingNumber,
            &dto.CreatedAt,
            &dto.UpdatedAt,
        ); err != nil {
            return nil, err
        }
        orders = append(orders, dto)
    }

    return orders, nil
}

type OrderStatistics struct {
    TotalOrders    int     `json:"total_orders"`
    TotalAmount    float64 `json:"total_amount"`
    PendingOrders  int     `json:"pending_orders"`
    CompletedOrders int    `json:"completed_orders"`
}

func (h *OrderQueryHandler) handleGetOrderStatistics(ctx context.Context, query GetOrderStatisticsQuery) (*OrderStatistics, error) {
    var stats OrderStatistics

    err := h.readDB.QueryRowContext(ctx, `
        SELECT
            COUNT(*) as total_orders,
            COALESCE(SUM(total_amount), 0) as total_amount,
            SUM(CASE WHEN status = 'PENDING' THEN 1 ELSE 0 END) as pending_orders,
            SUM(CASE WHEN status = 'DELIVERED' THEN 1 ELSE 0 END) as completed_orders
        FROM order_read_model
        WHERE user_id = $1 AND created_at BETWEEN $2 AND $3
    `, query.UserID, query.StartDate, query.EndDate).Scan(
        &stats.TotalOrders,
        &stats.TotalAmount,
        &stats.PendingOrders,
        &stats.CompletedOrders,
    )

    return &stats, err
}
```

---

## 4. Event StoreËÆæËÆ°

### 4.1 Êï∞ÊçÆÂ∫ìSchema

```sql
-- eventsË°® (‰∫ã‰ª∂ÊµÅ)
CREATE TABLE events (
    id SERIAL PRIMARY KEY,
    event_id UUID NOT NULL UNIQUE,
    event_type VARCHAR(255) NOT NULL,
    aggregate_id VARCHAR(255) NOT NULL,
    aggregate_type VARCHAR(255) NOT NULL,
    version BIGINT NOT NULL,
    timestamp TIMESTAMP NOT NULL,
    metadata JSONB,
    payload JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_aggregate_version UNIQUE(aggregate_id, version)
);

CREATE INDEX idx_events_aggregate ON events(aggregate_id, version);
CREATE INDEX idx_events_timestamp ON events(timestamp DESC);
CREATE INDEX idx_events_type ON events(event_type);

-- snapshotsË°® (Âø´ÁÖß,Áî®‰∫éÊÄßËÉΩ‰ºòÂåñ)
CREATE TABLE snapshots (
    aggregate_id VARCHAR(255) PRIMARY KEY,
    aggregate_type VARCHAR(255) NOT NULL,
    version BIGINT NOT NULL,
    state JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ËØªÊ®°ÂûãË°®
CREATE TABLE order_read_model (
    order_id VARCHAR(255) PRIMARY KEY,
    user_id VARCHAR(255) NOT NULL,
    total_amount DECIMAL(10, 2) NOT NULL,
    status VARCHAR(50) NOT NULL,
    payment_method VARCHAR(50),
    tracking_number VARCHAR(100),
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL
);

CREATE INDEX idx_order_read_user_id ON order_read_model(user_id);
CREATE INDEX idx_order_read_status ON order_read_model(status);
CREATE INDEX idx_order_read_created_at ON order_read_model(created_at DESC);

CREATE TABLE order_items_read_model (
    id SERIAL PRIMARY KEY,
    order_id VARCHAR(255) NOT NULL,
    product_id VARCHAR(255) NOT NULL,
    product_name VARCHAR(255) NOT NULL,
    quantity INT NOT NULL,
    price DECIMAL(10, 2) NOT NULL,
    FOREIGN KEY (order_id) REFERENCES order_read_model(order_id) ON DELETE CASCADE
);

CREATE INDEX idx_order_items_order_id ON order_items_read_model(order_id);
```

---

## 5. Projection‰∏éRead Model

### 5.1 ProjectionÂÆûÁé∞

```go
// projection/order_projection.go
package projection

import (
    "context"
    "database/sql"
    "encoding/json"
    "fmt"
    "yourapp/domain"
)

// Projection ÊäïÂΩ±Êé•Âè£
type Projection interface {
    ProjectEvent(ctx context.Context, event domain.Event) error
}

// OrderProjection ËÆ¢ÂçïÊäïÂΩ± (Â∞Ü‰∫ã‰ª∂ÊäïÂΩ±Âà∞ËØªÊ®°Âûã)
type OrderProjection struct {
    db *sql.DB
}

func NewOrderProjection(db *sql.DB) *OrderProjection {
    return &OrderProjection{db: db}
}

// ProjectEvent ÊäïÂΩ±‰∫ã‰ª∂
func (p *OrderProjection) ProjectEvent(ctx context.Context, event domain.Event) error {
    switch event.EventType() {
    case "OrderCreated":
        return p.projectOrderCreated(ctx, event)
    case "OrderPaid":
        return p.projectOrderPaid(ctx, event)
    case "OrderShipped":
        return p.projectOrderShipped(ctx, event)
    case "OrderCancelled":
        return p.projectOrderCancelled(ctx, event)
    default:
        return nil  // ÂøΩÁï•Êú™Áü•‰∫ã‰ª∂
    }
}

func (p *OrderProjection) projectOrderCreated(ctx context.Context, event domain.Event) error {
    var e domain.OrderCreatedEvent
    if err := json.Unmarshal(event.(*domain.BaseEvent).Payload, &e); err != nil {
        return err
    }

    tx, err := p.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // ÊèíÂÖ•ËÆ¢ÂçïËÆ∞ÂΩï
    _, err = tx.ExecContext(ctx, `
        INSERT INTO order_read_model (order_id, user_id, total_amount, status, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $5)
    `, e.OrderID, e.UserID, e.TotalAmount, "PENDING", e.CreatedAt)
    if err != nil {
        return err
    }

    // ÊèíÂÖ•ËÆ¢ÂçïÊòéÁªÜ
    stmt, err := tx.PrepareContext(ctx, `
        INSERT INTO order_items_read_model (order_id, product_id, product_name, quantity, price)
        VALUES ($1, $2, $3, $4, $5)
    `)
    if err != nil {
        return err
    }
    defer stmt.Close()

    for _, item := range e.Items {
        _, err = stmt.ExecContext(ctx, e.OrderID, item.ProductID, "Product", item.Quantity, item.Price)
        if err != nil {
            return err
        }
    }

    return tx.Commit()
}

func (p *OrderProjection) projectOrderPaid(ctx context.Context, event domain.Event) error {
    var e domain.OrderPaidEvent
    if err := json.Unmarshal(event.(*domain.BaseEvent).Payload, &e); err != nil {
        return err
    }

    _, err := p.db.ExecContext(ctx, `
        UPDATE order_read_model
        SET status = $1, payment_method = $2, updated_at = $3
        WHERE order_id = $4
    `, "PAID", e.PaymentMethod, e.PaidAt, e.OrderID)

    return err
}

func (p *OrderProjection) projectOrderShipped(ctx context.Context, event domain.Event) error {
    var e domain.OrderShippedEvent
    if err := json.Unmarshal(event.(*domain.BaseEvent).Payload, &e); err != nil {
        return err
    }

    _, err := p.db.ExecContext(ctx, `
        UPDATE order_read_model
        SET status = $1, tracking_number = $2, updated_at = $3
        WHERE order_id = $4
    `, "SHIPPED", e.TrackingNumber, e.ShippedAt, e.OrderID)

    return err
}

func (p *OrderProjection) projectOrderCancelled(ctx context.Context, event domain.Event) error {
    var e domain.OrderCancelledEvent
    if err := json.Unmarshal(event.(*domain.BaseEvent).Payload, &e); err != nil {
        return err
    }

    _, err := p.db.ExecContext(ctx, `
        UPDATE order_read_model
        SET status = $1, updated_at = $2
        WHERE order_id = $3
    `, "CANCELLED", e.CancelledAt, e.OrderID)

    return err
}
```

### 5.2 Projection Manager

```go
// projection/manager.go
package projection

import (
    "context"
    "fmt"
    "sync"
    "time"
    "yourapp/domain"
    "yourapp/eventstore"
)

// ProjectionManager ÊäïÂΩ±ÁÆ°ÁêÜÂô®
type ProjectionManager struct {
    eventStore  eventstore.EventStore
    projections []Projection
    checkpoints map[string]int64
    mu          sync.RWMutex
}

func NewProjectionManager(eventStore eventstore.EventStore) *ProjectionManager {
    return &ProjectionManager{
        eventStore:  eventStore,
        projections: make([]Projection, 0),
        checkpoints: make(map[string]int64),
    }
}

// RegisterProjection Ê≥®ÂÜåÊäïÂΩ±
func (m *ProjectionManager) RegisterProjection(projection Projection) {
    m.projections = append(m.projections, projection)
}

// Start ÂêØÂä®ÊäïÂΩ±ÁÆ°ÁêÜÂô®
func (m *ProjectionManager) Start(ctx context.Context) error {
    // 1. ËøΩËµ∂ÂéÜÂè≤‰∫ã‰ª∂ (Catch-up)
    if err := m.catchUp(ctx); err != nil {
        return err
    }

    // 2. ËÆ¢ÈòÖÂÆûÊó∂‰∫ã‰ª∂
    return m.eventStore.SubscribeToStream(ctx, "all_events", m.handleEvent)
}

func (m *ProjectionManager) catchUp(ctx context.Context) error {
    fmt.Println("[Projection] Catching up historical events...")

    // ‰ªécheckpointÂºÄÂßãËøΩËµ∂‰∫ã‰ª∂
    // (ÂÆûÈôÖÂ∫î‰ªéÊï∞ÊçÆÂ∫ìËØªÂèñcheckpoint)
    startVersion := int64(0)

    // ËøôÈáåÁÆÄÂåñÂ§ÑÁêÜ,ÂÆûÈôÖÈúÄË¶ÅÂàÜÈ°µÂä†ËΩΩ
    // events, err := m.eventStore.LoadAllEventsAfterVersion(ctx, startVersion)
    // for _, event := range events {
    //     if err := m.handleEvent(event); err != nil {
    //         return err
    //     }
    // }

    fmt.Println("[Projection] Catch-up completed")
    return nil
}

func (m *ProjectionManager) handleEvent(event domain.Event) error {
    // Âπ∂ÂèëÊäïÂΩ±Âà∞Â§ö‰∏™ËØªÊ®°Âûã
    var wg sync.WaitGroup
    errChan := make(chan error, len(m.projections))

    for _, projection := range m.projections {
        wg.Add(1)
        go func(p Projection) {
            defer wg.Done()
            ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
            defer cancel()

            if err := p.ProjectEvent(ctx, event); err != nil {
                errChan <- fmt.Errorf("projection error: %w", err)
            }
        }(projection)
    }

    wg.Wait()
    close(errChan)

    // Ê£ÄÊü•ÈîôËØØ
    for err := range errChan {
        if err != nil {
            return err
        }
    }

    // Êõ¥Êñ∞checkpoint
    m.updateCheckpoint(event.AggregateID(), event.Version())
    return nil
}

func (m *ProjectionManager) updateCheckpoint(aggregateID string, version int64) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.checkpoints[aggregateID] = version

    // ÂÆûÈôÖÂ∫îÊåÅ‰πÖÂåñÂà∞Êï∞ÊçÆÂ∫ì
}
```

---

## 6. Saga‰∏éProcess Manager

### 6.1 SagaÂÆûÁé∞

```go
// saga/order_saga.go
package saga

import (
    "context"
    "fmt"
    "yourapp/cqrs"
    "yourapp/domain"
)

// OrderSaga ËÆ¢ÂçïSaga (ÁºñÊéíÂ§ö‰∏™ÊúçÂä°)
type OrderSaga struct {
    commandHandler cqrs.CommandHandler
}

func NewOrderSaga(commandHandler cqrs.CommandHandler) *OrderSaga {
    return &OrderSaga{commandHandler: commandHandler}
}

// HandleOrderPaid Â§ÑÁêÜËÆ¢ÂçïÊîØ‰ªòÊàêÂäü‰∫ã‰ª∂
func (s *OrderSaga) HandleOrderPaid(ctx context.Context, event domain.Event) error {
    var e domain.OrderPaidEvent
    if err := json.Unmarshal(event.(*domain.BaseEvent).Payload, &e); err != nil {
        return err
    }

    // ÁºñÊéíÊ≠•È™§:
    // 1. Êâ£ÂáèÂ∫ìÂ≠ò
    if err := s.reserveInventory(ctx, e.OrderID); err != nil {
        // Ë°•ÂÅø: ÈÄÄÊ¨æ
        return s.compensatePayment(ctx, e.OrderID)
    }

    // 2. ÂàõÂª∫Áâ©ÊµÅÂçï
    if err := s.createShipment(ctx, e.OrderID); err != nil {
        // Ë°•ÂÅø: ÈáäÊîæÂ∫ìÂ≠ò + ÈÄÄÊ¨æ
        s.releaseInventory(ctx, e.OrderID)
        return s.compensatePayment(ctx, e.OrderID)
    }

    // 3. ÂèëÈÄÅÈÄöÁü•
    if err := s.sendNotification(ctx, e.OrderID); err != nil {
        // ÈùûÂÖ≥ÈîÆÊ≠•È™§,ËÆ∞ÂΩïÊó•ÂøóÂç≥ÂèØ
        fmt.Printf("[Saga] Failed to send notification: %v\n", err)
    }

    return nil
}

func (s *OrderSaga) reserveInventory(ctx context.Context, orderID string) error {
    // Ë∞ÉÁî®Â∫ìÂ≠òÊúçÂä°
    fmt.Printf("[Saga] Reserving inventory for order %s\n", orderID)
    return nil
}

func (s *OrderSaga) releaseInventory(ctx context.Context, orderID string) error {
    fmt.Printf("[Saga] Releasing inventory for order %s\n", orderID)
    return nil
}

func (s *OrderSaga) createShipment(ctx context.Context, orderID string) error {
    fmt.Printf("[Saga] Creating shipment for order %s\n", orderID)
    return nil
}

func (s *OrderSaga) sendNotification(ctx context.Context, orderID string) error {
    fmt.Printf("[Saga] Sending notification for order %s\n", orderID)
    return nil
}

func (s *OrderSaga) compensatePayment(ctx context.Context, orderID string) error {
    fmt.Printf("[Saga] Compensating payment for order %s\n", orderID)
    // ÂèëÈÄÅÈÄÄÊ¨æÂëΩ‰ª§
    return nil
}
```

---

## 7. Âø´ÁÖß‰∏éÊÄßËÉΩ‰ºòÂåñ

### 7.1 SnapshotÂÆûÁé∞

```go
// eventstore/snapshot.go
package eventstore

import (
    "context"
    "database/sql"
    "encoding/json"
    "yourapp/domain"
)

// SnapshotStore Âø´ÁÖßÂ≠òÂÇ®
type SnapshotStore struct {
    db *sql.DB
}

func NewSnapshotStore(db *sql.DB) *SnapshotStore {
    return &SnapshotStore{db: db}
}

// SaveSnapshot ‰øùÂ≠òÂø´ÁÖß
func (s *SnapshotStore) SaveSnapshot(ctx context.Context, aggregate domain.Aggregate) error {
    state, err := json.Marshal(aggregate)
    if err != nil {
        return err
    }

    _, err = s.db.ExecContext(ctx, `
        INSERT INTO snapshots (aggregate_id, aggregate_type, version, state)
        VALUES ($1, $2, $3, $4)
        ON CONFLICT (aggregate_id) DO UPDATE SET
            version = EXCLUDED.version,
            state = EXCLUDED.state,
            created_at = CURRENT_TIMESTAMP
    `, aggregate.AggregateID(), aggregate.AggregateType(), aggregate.Version(), state)

    return err
}

// LoadSnapshot Âä†ËΩΩÂø´ÁÖß
func (s *SnapshotStore) LoadSnapshot(ctx context.Context, aggregateID string) (json.RawMessage, int64, error) {
    var state json.RawMessage
    var version int64

    err := s.db.QueryRowContext(ctx, `
        SELECT state, version FROM snapshots WHERE aggregate_id = $1
    `, aggregateID).Scan(&state, &version)

    if err == sql.ErrNoRows {
        return nil, 0, nil
    }

    return state, version, err
}

// ‰ºòÂåñÂêéÁöÑËÅöÂêàÊ†πÂä†ËΩΩ (‰ΩøÁî®Âø´ÁÖß)
func (h *OrderCommandHandler) loadOrderAggregateWithSnapshot(ctx context.Context, orderID string) (*domain.OrderAggregate, error) {
    // 1. Â∞ùËØïÂä†ËΩΩÂø´ÁÖß
    snapshotStore := NewSnapshotStore(h.db)
    state, version, err := snapshotStore.LoadSnapshot(ctx, orderID)

    var order *domain.OrderAggregate

    if err == nil && state != nil {
        // ‰ªéÂø´ÁÖßÊÅ¢Â§ç
        order = &domain.OrderAggregate{}
        if err := json.Unmarshal(state, order); err != nil {
            return nil, err
        }

        // Âè™ÈúÄÂä†ËΩΩÂø´ÁÖß‰πãÂêéÁöÑ‰∫ã‰ª∂
        events, err := h.eventStore.LoadEventsAfterVersion(ctx, orderID, version)
        if err != nil {
            return nil, err
        }

        for _, event := range events {
            if err := order.ApplyEvent(event); err != nil {
                return nil, err
            }
        }
    } else {
        // Ê≤°ÊúâÂø´ÁÖß,Âä†ËΩΩÊâÄÊúâ‰∫ã‰ª∂
        events, err := h.eventStore.LoadEvents(ctx, orderID)
        if err != nil {
            return nil, err
        }

        if len(events) == 0 {
            return nil, fmt.Errorf("order not found")
        }

        order = domain.NewOrderAggregate(orderID)
        for _, event := range events {
            if err := order.ApplyEvent(event); err != nil {
                return nil, err
            }
        }

        // ÊØè100‰∏™‰∫ã‰ª∂ÂàõÂª∫‰∏ÄÊ¨°Âø´ÁÖß
        if order.Version() % 100 == 0 {
            snapshotStore.SaveSnapshot(ctx, order)
        }
    }

    return order, nil
}
```

---

## 8. ÊúÄÁªà‰∏ÄËá¥ÊÄß‰∏éÂπÇÁ≠âÊÄß

### 8.1 ÂπÇÁ≠âÊÄß‰øùËØÅ

```go
// idempotency/middleware.go
package idempotency

import (
    "context"
    "crypto/sha256"
    "database/sql"
    "encoding/hex"
    "fmt"
    "time"
)

// IdempotencyMiddleware ÂπÇÁ≠âÊÄß‰∏≠Èó¥‰ª∂
type IdempotencyMiddleware struct {
    db *sql.DB
}

func NewIdempotencyMiddleware(db *sql.DB) *IdempotencyMiddleware {
    // ÂàõÂª∫ÂπÇÁ≠âÊÄßË°®
    schema := `
    CREATE TABLE IF NOT EXISTS idempotency_keys (
        idempotency_key VARCHAR(255) PRIMARY KEY,
        request_hash VARCHAR(64) NOT NULL,
        response JSONB,
        status VARCHAR(50) NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        expires_at TIMESTAMP NOT NULL
    );
    CREATE INDEX IF NOT EXISTS idx_idempotency_expires ON idempotency_keys(expires_at);
    `
    db.Exec(schema)

    return &IdempotencyMiddleware{db: db}
}

// ExecuteIdempotent ÂπÇÁ≠âÊâßË°å
func (m *IdempotencyMiddleware) ExecuteIdempotent(
    ctx context.Context,
    idempotencyKey string,
    fn func(ctx context.Context) (interface{}, error),
) (interface{}, error) {
    // 1. Ê£ÄÊü•ÂπÇÁ≠âÊÄßKeyÊòØÂê¶Â≠òÂú®
    var status string
    var response []byte

    err := m.db.QueryRowContext(ctx,
        "SELECT status, response FROM idempotency_keys WHERE idempotency_key = $1",
        idempotencyKey,
    ).Scan(&status, &response)

    if err == nil {
        // Â∑≤Â≠òÂú®
        if status == "COMPLETED" {
            // ËøîÂõûÁºìÂ≠òÁªìÊûú
            return response, nil
        } else if status == "PROCESSING" {
            // Ê≠£Âú®Â§ÑÁêÜ,ËøîÂõûÂÜ≤Á™Å
            return nil, fmt.Errorf("request is being processed")
        }
    } else if err != sql.ErrNoRows {
        return nil, err
    }

    // 2. ÊèíÂÖ•ÂπÇÁ≠âÊÄßKey (Áä∂ÊÄÅ: PROCESSING)
    _, err = m.db.ExecContext(ctx, `
        INSERT INTO idempotency_keys (idempotency_key, request_hash, status, expires_at)
        VALUES ($1, $2, $3, $4)
        ON CONFLICT (idempotency_key) DO NOTHING
    `, idempotencyKey, "hash", "PROCESSING", time.Now().Add(24*time.Hour))

    if err != nil {
        return nil, err
    }

    // 3. ÊâßË°åÂÆûÈôÖÊìç‰Ωú
    result, err := fn(ctx)

    // 4. Êõ¥Êñ∞ÁªìÊûú
    if err != nil {
        m.db.ExecContext(ctx,
            "UPDATE idempotency_keys SET status = $1 WHERE idempotency_key = $2",
            "FAILED", idempotencyKey,
        )
        return nil, err
    }

    resultJSON, _ := json.Marshal(result)
    m.db.ExecContext(ctx,
        "UPDATE idempotency_keys SET status = $1, response = $2 WHERE idempotency_key = $3",
        "COMPLETED", resultJSON, idempotencyKey,
    )

    return result, nil
}

// GenerateIdempotencyKey ÁîüÊàêÂπÇÁ≠âÊÄßKey
func GenerateIdempotencyKey(userID, operation string, params interface{}) string {
    data := fmt.Sprintf("%s:%s:%v", userID, operation, params)
    hash := sha256.Sum256([]byte(data))
    return hex.EncodeToString(hash[:])
}
```

### 8.2 ÊúÄÁªà‰∏ÄËá¥ÊÄßÊ£ÄÊµã

```go
// consistency/checker.go
package consistency

import (
    "context"
    "database/sql"
    "fmt"
    "time"
)

// ConsistencyChecker ‰∏ÄËá¥ÊÄßÊ£ÄÊü•Âô®
type ConsistencyChecker struct {
    eventDB *sql.DB
    readDB  *sql.DB
}

func NewConsistencyChecker(eventDB, readDB *sql.DB) *ConsistencyChecker {
    return &ConsistencyChecker{
        eventDB: eventDB,
        readDB:  readDB,
    }
}

// CheckOrderConsistency Ê£ÄÊü•ËÆ¢Âçï‰∏ÄËá¥ÊÄß
func (c *ConsistencyChecker) CheckOrderConsistency(ctx context.Context, orderID string) error {
    // 1. ‰ªé‰∫ã‰ª∂ÊµÅÈáçÂª∫Áä∂ÊÄÅ
    expectedState, err := c.rebuildFromEvents(ctx, orderID)
    if err != nil {
        return err
    }

    // 2. ‰ªéËØªÊ®°ÂûãËé∑ÂèñÁä∂ÊÄÅ
    actualState, err := c.getReadModelState(ctx, orderID)
    if err != nil {
        return err
    }

    // 3. ÂØπÊØî
    if !c.statesEqual(expectedState, actualState) {
        return fmt.Errorf("consistency check failed for order %s", orderID)
    }

    return nil
}

func (c *ConsistencyChecker) rebuildFromEvents(ctx context.Context, orderID string) (interface{}, error) {
    // ‰ªé‰∫ã‰ª∂Ë°®ÈáçÂª∫
    return nil, nil
}

func (c *ConsistencyChecker) getReadModelState(ctx context.Context, orderID string) (interface{}, error) {
    // ‰ªéËØªÊ®°ÂûãÊü•ËØ¢
    return nil, nil
}

func (c *ConsistencyChecker) statesEqual(a, b interface{}) bool {
    // ÂØπÊØîÁä∂ÊÄÅ
    return true
}

// StartPeriodicCheck ÂÆöÊúü‰∏ÄËá¥ÊÄßÊ£ÄÊü•
func (c *ConsistencyChecker) StartPeriodicCheck(ctx context.Context, interval time.Duration) {
    ticker := time.NewTicker(interval)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            c.runFullCheck(ctx)
        case <-ctx.Done():
            return
        }
    }
}

func (c *ConsistencyChecker) runFullCheck(ctx context.Context) {
    fmt.Println("[ConsistencyChecker] Running full consistency check...")
    // Ê£ÄÊü•ÊâÄÊúâËÅöÂêàÊ†π
}
```

---

## 9. ÂÆåÊï¥Á§∫‰æã

```go
// cmd/main.go
package main

import (
    "context"
    "fmt"
    "log"
    "database/sql"

    _ "github.com/lib/pq"
    "yourapp/cqrs"
    "yourapp/domain"
    "yourapp/eventstore"
    "yourapp/projection"
)

func main() {
    ctx := context.Background()

    // 1. ËøûÊé•Event Store (PostgreSQL)
    eventDB, err := sql.Open("postgres", "postgres://user:pass@localhost/events?sslmode=disable")
    if err != nil {
        log.Fatal(err)
    }
    defer eventDB.Close()

    // 2. ËøûÊé•Read Model (ÂèØ‰ª•ÊòØ‰∏çÂêåÁöÑÊï∞ÊçÆÂ∫ì)
    readDB, err := sql.Open("postgres", "postgres://user:pass@localhost/readmodel?sslmode=disable")
    if err != nil {
        log.Fatal(err)
    }
    defer readDB.Close()

    // 3. ÂàõÂª∫Event Store
    eventStore, err := eventstore.NewPostgresEventStore(eventDB)
    if err != nil {
        log.Fatal(err)
    }

    // 4. ÂàõÂª∫Command Handler
    commandHandler := cqrs.NewOrderCommandHandler(eventStore)

    // 5. ÂàõÂª∫Query Handler
    queryHandler := cqrs.NewOrderQueryHandler(readDB)

    // 6. ÂêØÂä®Projection Manager
    projectionMgr := projection.NewProjectionManager(eventStore)
    projectionMgr.RegisterProjection(projection.NewOrderProjection(readDB))
    go projectionMgr.Start(ctx)

    // === ‰ΩøÁî®Á§∫‰æã ===

    // ÂàõÂª∫ËÆ¢Âçï
    createCmd := cqrs.CreateOrderCommand{
        OrderID: "order-001",
        UserID:  "user-123",
        Items: []domain.OrderItem{
            {ProductID: "prod-1", Quantity: 2, Price: 99.99},
            {ProductID: "prod-2", Quantity: 1, Price: 149.99},
        },
    }

    if err := commandHandler.Handle(ctx, createCmd); err != nil {
        log.Fatal(err)
    }

    fmt.Println("‚úÖ Order created")

    // ÊîØ‰ªòËÆ¢Âçï
    payCmd := cqrs.PayOrderCommand{
        OrderID:       "order-001",
        PaymentMethod: "credit_card",
        Amount:        349.97,
    }

    if err := commandHandler.Handle(ctx, payCmd); err != nil {
        log.Fatal(err)
    }

    fmt.Println("‚úÖ Order paid")

    // Êü•ËØ¢ËÆ¢ÂçïËØ¶ÊÉÖ
    query := cqrs.GetOrderDetailQuery{OrderID: "order-001"}
    result, err := queryHandler.Handle(ctx, query)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("üì¶ Order Detail: %+v\n", result)

    // Êü•ËØ¢Áî®Êà∑ËÆ¢ÂçïÂàóË°®
    listQuery := cqrs.ListUserOrdersQuery{
        UserID: "user-123",
        Limit:  10,
        Offset: 0,
    }

    orders, err := queryHandler.Handle(ctx, listQuery)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("üìã User Orders: %+v\n", orders)
}
```

---

## 10. ÊÄªÁªì

### 10.1 ‰ºòÂäø‰∏éÂä£Âäø

```yaml
Event Sourcing‰ºòÂäø:
  - ÂÆåÊï¥ÂÆ°ËÆ°Êó•Âøó
  - Êó∂Èó¥ÊóÖË°å (ÂõûÊ∫Ø‰ªªÊÑèÊó∂ÂàªÁä∂ÊÄÅ)
  - ‰∫ã‰ª∂ÈáçÊîæ (‰øÆÂ§çBug)
  - ‰∫ã‰ª∂È©±Âä®Êû∂ÊûÑÂ§©ÁÑ∂ÊîØÊåÅ

Event SourcingÂä£Âäø:
  - Â≠¶‰π†Êõ≤Á∫øÈô°Â≥≠
  - Â§çÊùÇÂ∫¶È´ò
  - Êü•ËØ¢Â§çÊùÇ (ÈúÄË¶ÅÈáçÂª∫Áä∂ÊÄÅ)
  - ‰∫ã‰ª∂SchemaÊºîÂåñÂõ∞Èöæ

CQRS‰ºòÂäø:
  - ËØªÂÜôÂàÜÁ¶ª
  - ÊÄßËÉΩ‰ºòÂåñ (ËØªÂÜôÁã¨Á´ãÊâ©Â±ï)
  - Â§çÊùÇÊü•ËØ¢‰ºòÂåñ
  - ÈÄÇÂêà‰∫ã‰ª∂È©±Âä®

CQRSÂä£Âäø:
  - ÊúÄÁªà‰∏ÄËá¥ÊÄß
  - Áª¥Êä§ÊàêÊú¨È´ò (‰∏§Â•óÊ®°Âûã)
  - ÂêåÊ≠•Âª∂Ëøü

ÈÄÇÁî®Âú∫ÊôØ:
  - ÈáëËûçÁ≥ªÁªü (ÂÆ°ËÆ°Ë¶ÅÊ±Ç)
  - ÁîµÂïÜËÆ¢Âçï (Áä∂ÊÄÅËøΩÊ∫Ø)
  - Âçè‰ΩúËΩØ‰ª∂ (ÁâàÊú¨ÊéßÂà∂)
  - IoTÊï∞ÊçÆ (Êó∂Â∫èÊï∞ÊçÆ)
```

### 10.2 ÊúÄ‰Ω≥ÂÆûË∑µ

```text
1. ‰∫ã‰ª∂ËÆæËÆ°
   - ‰ΩøÁî®ËøáÂéªÊó∂ÂëΩÂêç (OrderCreated, UserUpdated)
   - ‰∫ã‰ª∂‰∏çÂèØÂèò
   - ÂåÖÂê´ÊâÄÊúâÂøÖË¶Å‰ø°ÊÅØ (ÈÅøÂÖç‰æùËµñÂ§ñÈÉ®Êü•ËØ¢)
   - Â∞è‰∫ã‰ª∂ÂéüÂàô (Âçï‰∏ÄËÅåË¥£)

2. ËÅöÂêàÊ†πËÆæËÆ°
   - ‰∏Ä‰∏™‰∫ãÂä°Âè™‰øÆÊîπ‰∏Ä‰∏™ËÅöÂêàÊ†π
   - ËÅöÂêàÊ†πËæπÁïåË¶ÅÊ∏ÖÊô∞
   - ÈÅøÂÖçË∑®ËÅöÂêàÊ†πÊü•ËØ¢

3. Âø´ÁÖßÁ≠ñÁï•
   - ÊØèN‰∏™‰∫ã‰ª∂ÂàõÂª∫Âø´ÁÖß (N=100-1000)
   - ÂºÇÊ≠•ÂàõÂª∫Âø´ÁÖß (‰∏çÈòªÂ°û‰∏ªÊµÅÁ®ã)
   - ÂÆöÊúüÊ∏ÖÁêÜÊóßÂø´ÁÖß

4. Projection‰ºòÂåñ
   - ÂºÇÊ≠•ÊäïÂΩ±
   - ÊîØÊåÅÈáçÂª∫ (Rebuild)
   - ÂπÇÁ≠âÊÄß
   - ÁõëÊéßÂª∂Ëøü

5. ‰∫ã‰ª∂ÁâàÊú¨Âåñ
   - ‰ΩøÁî®UpcasterÊ®°Âºè
   - ÂêëÂêéÂÖºÂÆπ
   - ‰∫ã‰ª∂ËøÅÁßªÁ≠ñÁï•
```

**ÊÅ≠Âñú!** üéâ ÊÇ®Â∑≤ÊéåÊè°Go 1.25.3 Event Sourcing‰∏éCQRSÁöÑÂÆåÊï¥ÂÆûÊàòÊäÄËÉΩ!

---

## üìö ÂèÇËÄÉËµÑÊñô

- [Event Sourcing Pattern](https://martinfowler.com/eaaDev/EventSourcing.html)
- [CQRS Pattern](https://martinfowler.com/bliki/CQRS.html)
- [EventStore DB](https://www.eventstore.com/)
- [Implementing Domain-Driven Design (Book)](https://www.oreilly.com/library/view/implementing-domain-driven-design/9780133039900/)
- [Versioning in an Event Sourced System](https://leanpub.com/esversioning)
