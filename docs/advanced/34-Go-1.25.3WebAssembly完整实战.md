# Go 1.25.3 WebAssemblyå®Œæ•´å®æˆ˜

## ğŸ“‹ ç›®å½•

- [Go 1.25.3 WebAssemblyå®Œæ•´å®æˆ˜](#go-1253-webassemblyå®Œæ•´å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. WebAssemblyæ¦‚è¿°](#1-webassemblyæ¦‚è¿°)
    - [1.1 ä»€ä¹ˆæ˜¯WebAssembly](#11-ä»€ä¹ˆæ˜¯webassembly)
    - [1.2 ç¯å¢ƒå‡†å¤‡](#12-ç¯å¢ƒå‡†å¤‡)
  - [2. TinyGoç¼–è¯‘å™¨](#2-tinygoç¼–è¯‘å™¨)
    - [2.1 ç¬¬ä¸€ä¸ªWASMç¨‹åº](#21-ç¬¬ä¸€ä¸ªwasmç¨‹åº)
    - [2.2 å¯¼å‡ºå‡½æ•°ç»™JavaScript](#22-å¯¼å‡ºå‡½æ•°ç»™javascript)
  - [3. æµè§ˆå™¨é›†æˆ](#3-æµè§ˆå™¨é›†æˆ)
    - [3.1 è°ƒç”¨JavaScriptå‡½æ•°](#31-è°ƒç”¨javascriptå‡½æ•°)
    - [3.2 Promiseå’Œå¼‚æ­¥æ“ä½œ](#32-promiseå’Œå¼‚æ­¥æ“ä½œ)
  - [4. JavaScriptäº’æ“ä½œ](#4-javascriptäº’æ“ä½œ)
    - [4.1 ç±»å‹è½¬æ¢](#41-ç±»å‹è½¬æ¢)
  - [5. DOMæ“ä½œ](#5-domæ“ä½œ)
    - [5.1 åŠ¨æ€åˆ›å»ºUI](#51-åŠ¨æ€åˆ›å»ºui)
    - [5.2 Canvaså›¾å½¢ç»˜åˆ¶](#52-canvaså›¾å½¢ç»˜åˆ¶)
  - [6. WebAssembly System Interface](#6-webassembly-system-interface)
    - [6.1 WASIæ–‡ä»¶æ“ä½œ](#61-wasiæ–‡ä»¶æ“ä½œ)
    - [6.2 å‘½ä»¤è¡Œå·¥å…·](#62-å‘½ä»¤è¡Œå·¥å…·)
  - [7. æ€§èƒ½ä¼˜åŒ–](#7-æ€§èƒ½ä¼˜åŒ–)
    - [7.1 äºŒè¿›åˆ¶å¤§å°ä¼˜åŒ–](#71-äºŒè¿›åˆ¶å¤§å°ä¼˜åŒ–)
    - [7.2 æ€§èƒ½åŸºå‡†æµ‹è¯•](#72-æ€§èƒ½åŸºå‡†æµ‹è¯•)
  - [8. å®é™…åº”ç”¨](#8-å®é™…åº”ç”¨)
    - [8.1 å›¾åƒå¤„ç†](#81-å›¾åƒå¤„ç†)
    - [8.2 åŠ å¯†/è§£å¯†å·¥å…·](#82-åŠ å¯†è§£å¯†å·¥å…·)
  - [9. è°ƒè¯•ä¸æµ‹è¯•](#9-è°ƒè¯•ä¸æµ‹è¯•)
    - [9.1 æµè§ˆå™¨è°ƒè¯•](#91-æµè§ˆå™¨è°ƒè¯•)
    - [9.2 å•å…ƒæµ‹è¯•](#92-å•å…ƒæµ‹è¯•)
  - [10. å®Œæ•´é¡¹ç›®ç¤ºä¾‹](#10-å®Œæ•´é¡¹ç›®ç¤ºä¾‹)
    - [10.1 Markdownç¼–è¾‘å™¨](#101-markdownç¼–è¾‘å™¨)
  - [æ€»ç»“](#æ€»ç»“)
    - [WebAssemblyæŠ€æœ¯æ ˆ](#webassemblyæŠ€æœ¯æ ˆ)
    - [é€‚ç”¨åœºæ™¯](#é€‚ç”¨åœºæ™¯)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

## 1. WebAssemblyæ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯WebAssembly

```go
// WebAssembly (WASM) æ ¸å¿ƒæ¦‚å¿µ
/*
WebAssemblyæ˜¯:
  âœ… é«˜æ€§èƒ½çš„äºŒè¿›åˆ¶æŒ‡ä»¤æ ¼å¼
  âœ… åœ¨Webæµè§ˆå™¨ä¸­è¿è¡Œçš„è™šæ‹Ÿæœº
  âœ… ä¸JavaScriptäº’æ“ä½œ
  âœ… è·¨å¹³å° (æµè§ˆå™¨, Node.js, WASI)

ä¸ºä»€ä¹ˆé€‰æ‹©Goç¼–è¯‘åˆ°WASM:
  1. æ€§èƒ½: æ¯”JavaScriptå¿«2-20å€
  2. ç±»å‹å®‰å…¨: ç¼–è¯‘æ—¶æ£€æŸ¥
  3. å¹¶å‘: Goroutineæ”¯æŒ
  4. ç”Ÿæ€: ä¸°å¯Œçš„Goæ ‡å‡†åº“
  5. è·¨å¹³å°: ä¸€æ¬¡ç¼–å†™,å¤šå¤„è¿è¡Œ

åº”ç”¨åœºæ™¯:
  â€¢ å›¾åƒ/è§†é¢‘å¤„ç†
  â€¢ æ¸¸æˆå¼•æ“
  â€¢ æ•°æ®å¯è§†åŒ–
  â€¢ åŠ å¯†ç®—æ³•
  â€¢ ç§‘å­¦è®¡ç®—
  â€¢ CAD/3Då»ºæ¨¡
*/

// Goç¼–è¯‘åˆ°WASMçš„ä¸¤ç§æ–¹å¼
type CompilerComparison struct {
 StandardGo struct {
  Command     string // "GOOS=js GOARCH=wasm go build"
  BinarySize  string // "~2-10MB"
  Performance string // "Good"
  Features    string // "å®Œæ•´æ ‡å‡†åº“"
  LimitGC     string // "å†…å­˜å ç”¨è¾ƒå¤§"
 }

 TinyGo struct {
  Command     string // "tinygo build -target=wasm"
  BinarySize  string // "~50-500KB" âœ…
  Performance string // "Excellent" âœ…
  Features    string // "æ ‡å‡†åº“å­é›†"
  Limitation  string // "éƒ¨åˆ†åŠŸèƒ½ä¸æ”¯æŒ"
 }
}

// æ€§èƒ½å¯¹æ¯” (å®é™…æµ‹è¯•)
/*
ä»»åŠ¡: è®¡ç®—1000000æ¬¡æ–æ³¢é‚£å¥‘æ•°åˆ—
  JavaScript: 850ms
  Go WASM (Standard): 120ms (7x faster)
  Go WASM (TinyGo): 95ms (9x faster)
  TinyGoæ–‡ä»¶å¤§å°: 45KB vs Go 2.8MB
*/
```

### 1.2 ç¯å¢ƒå‡†å¤‡

```bash
# å®‰è£…TinyGo (æ¨è)
# macOS
brew install tinygo

# Linux
wget https://github.com/tinygo-org/tinygo/releases/download/v0.30.0/tinygo_0.30.0_amd64.deb
sudo dpkg -i tinygo_0.30.0_amd64.deb

# éªŒè¯å®‰è£…
tinygo version

# æˆ–ä½¿ç”¨æ ‡å‡†Go (è‡ªå¸¦WASMæ”¯æŒ)
go version  # Go 1.25.3å·²å†…ç½®WASMæ”¯æŒ
```

---

## 2. TinyGoç¼–è¯‘å™¨

### 2.1 ç¬¬ä¸€ä¸ªWASMç¨‹åº

```go
// main.go
package main

import (
 "fmt"
)

func main() {
 fmt.Println("Hello, WebAssembly!")
}

//export add
func add(a, b int) int {
 return a + b
}
```

```bash
# ä½¿ç”¨TinyGoç¼–è¯‘
tinygo build -o main.wasm -target wasm main.go

# ä½¿ç”¨æ ‡å‡†Goç¼–è¯‘
GOOS=js GOARCH=wasm go build -o main.wasm main.go

# æŸ¥çœ‹æ–‡ä»¶å¤§å°
ls -lh main.wasm
# TinyGo: ~45KB
# Go:     ~2.8MB
```

```html
<!-- index.html -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Go WebAssembly</title>
</head>
<body>
    <h1>Go WebAssembly Example</h1>
    <script src="wasm_exec.js"></script>
    <script>
        const go = new Go();
        WebAssembly.instantiateStreaming(fetch("main.wasm"), go.importObject)
            .then((result) => {
                go.run(result.instance);

                // è°ƒç”¨å¯¼å‡ºçš„å‡½æ•°
                const add = result.instance.exports.add;
                console.log("3 + 4 =", add(3, 4));
            });
    </script>
</body>
</html>
```

```bash
# è·å–wasm_exec.js (TinyGo)
cp $(tinygo env TINYGOROOT)/targets/wasm_exec.js .

# æˆ–ä½¿ç”¨æ ‡å‡†Goçš„wasm_exec.js
cp "$(go env GOROOT)/misc/wasm/wasm_exec.js" .

# å¯åŠ¨HTTPæœåŠ¡å™¨
python3 -m http.server 8080
# è®¿é—® http://localhost:8080
```

### 2.2 å¯¼å‡ºå‡½æ•°ç»™JavaScript

```go
// calculator.go
package main

import (
 "syscall/js"
)

func main() {
 // æ³¨å†Œå…¨å±€å‡½æ•°
 js.Global().Set("goAdd", js.FuncOf(add))
 js.Global().Set("goMultiply", js.FuncOf(multiply))
 js.Global().Set("goFibonacci", js.FuncOf(fibonacci))

 // é˜²æ­¢ç¨‹åºé€€å‡º
 select {}
}

// addå¯¼å‡ºåŠ æ³•å‡½æ•°
func add(this js.Value, args []js.Value) interface{} {
 if len(args) != 2 {
  return js.ValueOf("Error: Expected 2 arguments")
 }

 a := args[0].Float()
 b := args[1].Float()
 return js.ValueOf(a + b)
}

// multiplyå¯¼å‡ºä¹˜æ³•å‡½æ•°
func multiply(this js.Value, args []js.Value) interface{} {
 a := args[0].Float()
 b := args[1].Float()
 return js.ValueOf(a * b)
}

// fibonacciè®¡ç®—æ–æ³¢é‚£å¥‘æ•°
func fibonacci(this js.Value, args []js.Value) interface{} {
 n := args[0].Int()
 return js.ValueOf(fib(n))
}

func fib(n int) int {
 if n <= 1 {
  return n
 }
 return fib(n-1) + fib(n-2)
}
```

```html
<!-- calculator.html -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Go Calculator</title>
</head>
<body>
    <h1>WebAssembly Calculator</h1>

    <div>
        <input type="number" id="num1" value="10">
        <input type="number" id="num2" value="5">
    </div>

    <button onclick="calculate('add')">Add</button>
    <button onclick="calculate('multiply')">Multiply</button>
    <button onclick="calculateFib()">Fibonacci</button>

    <div id="result"></div>

    <script src="wasm_exec.js"></script>
    <script>
        const go = new Go();
        WebAssembly.instantiateStreaming(fetch("calculator.wasm"), go.importObject)
            .then((result) => {
                go.run(result.instance);
            });

        function calculate(op) {
            const a = parseFloat(document.getElementById('num1').value);
            const b = parseFloat(document.getElementById('num2').value);

            let result;
            if (op === 'add') {
                result = goAdd(a, b);
            } else if (op === 'multiply') {
                result = goMultiply(a, b);
            }

            document.getElementById('result').textContent = `Result: ${result}`;
        }

        function calculateFib() {
            const n = parseInt(document.getElementById('num1').value);
            const start = performance.now();
            const result = goFibonacci(n);
            const end = performance.now();

            document.getElementById('result').textContent =
                `Fibonacci(${n}) = ${result} (${(end-start).toFixed(2)}ms)`;
        }
    </script>
</body>
</html>
```

---

## 3. æµè§ˆå™¨é›†æˆ

### 3.1 è°ƒç”¨JavaScriptå‡½æ•°

```go
package main

import (
 "syscall/js"
 "time"
)

func main() {
 // è·å–JavaScriptå…¨å±€å¯¹è±¡
 global := js.Global()

 // è°ƒç”¨alert
 global.Call("alert", "Hello from Go!")

 // è°ƒç”¨console.log
 console := global.Get("console")
 console.Call("log", "This is from Go WASM")

 // è·å–document
 document := global.Get("document")
 body := document.Get("body")

 // åˆ›å»ºå…ƒç´ 
 h1 := document.Call("createElement", "h1")
 h1.Set("textContent", "Go WebAssembly")
 h1.Get("style").Set("color", "blue")

 body.Call("appendChild", h1)

 // æ³¨å†Œäº‹ä»¶å¤„ç†å™¨
 js.Global().Set("handleClick", js.FuncOf(handleClick))

 select {}
}

func handleClick(this js.Value, args []js.Value) interface{} {
 event := args[0]
 target := event.Get("target")

 js.Global().Get("console").Call("log", "Button clicked:", target.Get("textContent"))

 return nil
}
```

### 3.2 Promiseå’Œå¼‚æ­¥æ“ä½œ

```go
package main

import (
 "syscall/js"
 "time"
)

// fetchDataæ¨¡æ‹Ÿå¼‚æ­¥æ•°æ®è·å–
func fetchData(this js.Value, args []js.Value) interface{} {
 // åˆ›å»ºPromise
 handler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {
  resolve := args[0]
  reject := args[1]

  // å¼‚æ­¥æ“ä½œ
  go func() {
   time.Sleep(2 * time.Second)

   // æ¨¡æ‹ŸæˆåŠŸ
   data := map[string]interface{}{
    "status": "success",
    "data":   []int{1, 2, 3, 4, 5},
   }

   resolve.Invoke(js.ValueOf(data))
  }()

  return nil
 })

 promiseConstructor := js.Global().Get("Promise")
 return promiseConstructor.New(handler)
}

// fetchAPIè°ƒç”¨çœŸå®çš„fetch API
func fetchAPI(this js.Value, args []js.Value) interface{} {
 url := args[0].String()

 // è°ƒç”¨JavaScriptçš„fetch
 promise := js.Global().Call("fetch", url)

 // é“¾å¼Promise
 then := js.FuncOf(func(this js.Value, args []js.Value) interface{} {
  response := args[0]
  return response.Call("json")
 })

 promise = promise.Call("then", then)

 return promise
}

func main() {
 js.Global().Set("goFetchData", js.FuncOf(fetchData))
 js.Global().Set("goFetchAPI", js.FuncOf(fetchAPI))

 select {}
}
```

```javascript
// JavaScriptè°ƒç”¨Goçš„Promise
async function loadData() {
    try {
        const data = await goFetchData();
        console.log("Data from Go:", data);
    } catch (error) {
        console.error("Error:", error);
    }
}

// ä½¿ç”¨Goè°ƒç”¨çœŸå®API
async function loadAPI() {
    const data = await goFetchAPI("https://api.github.com/users/golang");
    console.log("GitHub Data:", data);
}
```

---

## 4. JavaScriptäº’æ“ä½œ

### 4.1 ç±»å‹è½¬æ¢

```go
package main

import (
 "encoding/json"
 "syscall/js"
)

// å¤„ç†å„ç§JavaScriptç±»å‹
func handleTypes(this js.Value, args []js.Value) interface{} {
 arg := args[0]

 switch arg.Type() {
 case js.TypeBoolean:
  val := arg.Bool()
  return js.ValueOf(!val)

 case js.TypeNumber:
  val := arg.Float()
  return js.ValueOf(val * 2)

 case js.TypeString:
  val := arg.String()
  return js.ValueOf("Go says: " + val)

 case js.TypeObject:
  // JavaScriptå¯¹è±¡è½¬Go map
  obj := make(map[string]interface{})
  keys := js.Global().Get("Object").Call("keys", arg)

  for i := 0; i < keys.Length(); i++ {
   key := keys.Index(i).String()
   val := arg.Get(key)
   obj[key] = convertJSValue(val)
  }

  // å¤„ç†åè¿”å›
  obj["processed"] = true
  return js.ValueOf(obj)

 default:
  return js.ValueOf("Unknown type")
 }
}

// convertJSValueå°†js.Valueè½¬æ¢ä¸ºGoç±»å‹
func convertJSValue(v js.Value) interface{} {
 switch v.Type() {
 case js.TypeBoolean:
  return v.Bool()
 case js.TypeNumber:
  return v.Float()
 case js.TypeString:
  return v.String()
 case js.TypeNull, js.TypeUndefined:
  return nil
 default:
  return v
 }
}

// processJSONå¤„ç†JSONæ•°æ®
func processJSON(this js.Value, args []js.Value) interface{} {
 jsonStr := args[0].String()

 // è§£æJSON
 var data map[string]interface{}
 if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
  return js.ValueOf(map[string]interface{}{
   "error": err.Error(),
  })
 }

 // å¤„ç†æ•°æ®
 data["timestamp"] = time.Now().Unix()
 data["processed_by"] = "Go WASM"

 // è¿”å›JSONå­—ç¬¦ä¸²
 result, _ := json.Marshal(data)
 return js.ValueOf(string(result))
}

// createTypedArrayåˆ›å»ºTypedArray
func createTypedArray(this js.Value, args []js.Value) interface{} {
 size := args[0].Int()

 // åˆ›å»ºGo slice
 data := make([]byte, size)
 for i := range data {
  data[i] = byte(i % 256)
 }

 // è½¬æ¢ä¸ºUint8Array
 uint8Array := js.Global().Get("Uint8Array").New(size)
 js.CopyBytesToJS(uint8Array, data)

 return uint8Array
}

// processTypedArrayå¤„ç†TypedArray
func processTypedArray(this js.Value, args []js.Value) interface{} {
 array := args[0]
 length := array.Get("length").Int()

 // å¤åˆ¶åˆ°Go slice
 data := make([]byte, length)
 js.CopyBytesToGo(data, array)

 // å¤„ç†æ•°æ® (ç¤ºä¾‹: æ¯ä¸ªå­—èŠ‚+1)
 for i := range data {
  data[i] = (data[i] + 1) % 256
 }

 // è¿”å›å¤„ç†åçš„æ•°ç»„
 result := js.Global().Get("Uint8Array").New(length)
 js.CopyBytesToJS(result, data)

 return result
}
```

---

## 5. DOMæ“ä½œ

### 5.1 åŠ¨æ€åˆ›å»ºUI

```go
package main

import (
 "fmt"
 "syscall/js"
 "time"
)

type TodoApp struct {
 document js.Value
 listEl   js.Value
 inputEl  js.Value
 todos    []string
}

func NewTodoApp() *TodoApp {
 doc := js.Global().Get("document")

 app := &TodoApp{
  document: doc,
  todos:    make([]string, 0),
 }

 app.render()
 return app
}

func (app *TodoApp) render() {
 // åˆ›å»ºå®¹å™¨
 container := app.document.Call("createElement", "div")
 container.Set("id", "todo-app")

 // åˆ›å»ºæ ‡é¢˜
 title := app.document.Call("createElement", "h1")
 title.Set("textContent", "Go WASM Todo App")
 container.Call("appendChild", title)

 // åˆ›å»ºè¾“å…¥æ¡†
 app.inputEl = app.document.Call("createElement", "input")
 app.inputEl.Set("type", "text")
 app.inputEl.Set("placeholder", "Enter todo...")
 container.Call("appendChild", app.inputEl)

 // åˆ›å»ºæ·»åŠ æŒ‰é’®
 addBtn := app.document.Call("createElement", "button")
 addBtn.Set("textContent", "Add")
 addBtn.Call("addEventListener", "click", js.FuncOf(app.handleAdd))
 container.Call("appendChild", addBtn)

 // åˆ›å»ºåˆ—è¡¨
 app.listEl = app.document.Call("createElement", "ul")
 container.Call("appendChild", app.listEl)

 // æ·»åŠ åˆ°body
 app.document.Get("body").Call("appendChild", container)
}

func (app *TodoApp) handleAdd(this js.Value, args []js.Value) interface{} {
 text := app.inputEl.Get("value").String()
 if text == "" {
  return nil
 }

 // æ·»åŠ todo
 app.todos = append(app.todos, text)

 // æ¸…ç©ºè¾“å…¥æ¡†
 app.inputEl.Set("value", "")

 // æ›´æ–°åˆ—è¡¨
 app.updateList()

 return nil
}

func (app *TodoApp) updateList() {
 // æ¸…ç©ºåˆ—è¡¨
 app.listEl.Set("innerHTML", "")

 // é‡æ–°æ¸²æŸ“
 for i, todo := range app.todos {
  li := app.document.Call("createElement", "li")
  li.Set("textContent", todo)

  // æ·»åŠ åˆ é™¤æŒ‰é’®
  deleteBtn := app.document.Call("createElement", "button")
  deleteBtn.Set("textContent", "Delete")
  deleteBtn.Set("data-index", i)
  deleteBtn.Call("addEventListener", "click", js.FuncOf(app.handleDelete))

  li.Call("appendChild", deleteBtn)
  app.listEl.Call("appendChild", li)
 }
}

func (app *TodoApp) handleDelete(this js.Value, args []js.Value) interface{} {
 event := args[0]
 button := event.Get("target")
 index := button.Get("data-index").Int()

 // åˆ é™¤todo
 app.todos = append(app.todos[:index], app.todos[index+1:]...)

 // æ›´æ–°åˆ—è¡¨
 app.updateList()

 return nil
}

func main() {
 NewTodoApp()
 select {}
}
```

### 5.2 Canvaså›¾å½¢ç»˜åˆ¶

```go
package main

import (
 "math"
 "syscall/js"
 "time"
)

type Canvas struct {
 element js.Value
 ctx     js.Value
 width   int
 height  int
}

func NewCanvas(id string) *Canvas {
 doc := js.Global().Get("document")
 canvas := doc.Call("getElementById", id)

 width := canvas.Get("width").Int()
 height := canvas.Get("height").Int()

 return &Canvas{
  element: canvas,
  ctx:     canvas.Call("getContext", "2d"),
  width:   width,
  height:  height,
 }
}

// Clearæ¸…ç©ºç”»å¸ƒ
func (c *Canvas) Clear() {
 c.ctx.Call("clearRect", 0, 0, c.width, c.height)
}

// DrawCircleç»˜åˆ¶åœ†å½¢
func (c *Canvas) DrawCircle(x, y, r float64, color string) {
 c.ctx.Set("fillStyle", color)
 c.ctx.Call("beginPath")
 c.ctx.Call("arc", x, y, r, 0, 2*math.Pi)
 c.ctx.Call("fill")
}

// DrawRectç»˜åˆ¶çŸ©å½¢
func (c *Canvas) DrawRect(x, y, w, h float64, color string) {
 c.ctx.Set("fillStyle", color)
 c.ctx.Call("fillRect", x, y, w, h)
}

// DrawTextç»˜åˆ¶æ–‡æœ¬
func (c *Canvas) DrawText(text string, x, y float64, color string) {
 c.ctx.Set("fillStyle", color)
 c.ctx.Set("font", "24px Arial")
 c.ctx.Call("fillText", text, x, y)
}

// åŠ¨ç”»ç¤ºä¾‹: å¼¹è·³çš„çƒ
type Ball struct {
 x, y   float64
 vx, vy float64
 r      float64
 color  string
}

func (b *Ball) Update(canvas *Canvas) {
 b.x += b.vx
 b.y += b.vy

 // è¾¹ç•Œç¢°æ’
 if b.x-b.r < 0 || b.x+b.r > float64(canvas.width) {
  b.vx = -b.vx
 }
 if b.y-b.r < 0 || b.y+b.r > float64(canvas.height) {
  b.vy = -b.vy
 }
}

func main() {
 canvas := NewCanvas("canvas")

 // åˆ›å»ºå¤šä¸ªçƒ
 balls := []*Ball{
  {x: 100, y: 100, vx: 2, vy: 3, r: 20, color: "red"},
  {x: 200, y: 150, vx: -3, vy: 2, r: 15, color: "blue"},
  {x: 300, y: 200, vx: 1, vy: -2, r: 25, color: "green"},
 }

 // åŠ¨ç”»å¾ªç¯
 var renderFrame js.Func
 renderFrame = js.FuncOf(func(this js.Value, args []js.Value) interface{} {
  canvas.Clear()

  for _, ball := range balls {
   ball.Update(canvas)
   canvas.DrawCircle(ball.x, ball.y, ball.r, ball.color)
  }

  // æ˜¾ç¤ºFPS
  canvas.DrawText("Go WebAssembly Animation", 10, 30, "black")

  js.Global().Call("requestAnimationFrame", renderFrame)
  return nil
 })

 js.Global().Call("requestAnimationFrame", renderFrame)

 select {}
}
```

---

## 6. WebAssembly System Interface

### 6.1 WASIæ–‡ä»¶æ“ä½œ

```go
// wasi_file.go
//go:build wasi

package main

import (
 "fmt"
 "os"
)

func main() {
 // WASIç¯å¢ƒå¯ä»¥ä½¿ç”¨æ ‡å‡†çš„æ–‡ä»¶æ“ä½œ

 // å†™æ–‡ä»¶
 data := []byte("Hello from Go WASI!\n")
 if err := os.WriteFile("/tmp/output.txt", data, 0644); err != nil {
  fmt.Println("Write error:", err)
  return
 }

 // è¯»æ–‡ä»¶
 content, err := os.ReadFile("/tmp/output.txt")
 if err != nil {
  fmt.Println("Read error:", err)
  return
 }

 fmt.Println("File content:", string(content))

 // åˆ—å‡ºç›®å½•
 files, err := os.ReadDir(".")
 if err != nil {
  fmt.Println("ReadDir error:", err)
  return
 }

 fmt.Println("Files:")
 for _, file := range files {
  fmt.Printf("  %s\n", file.Name())
 }
}
```

```bash
# ç¼–è¯‘WASIç›®æ ‡
tinygo build -o main.wasm -target=wasi main.go

# ä½¿ç”¨wasmtimeè¿è¡Œ
wasmtime --dir=. main.wasm

# æˆ–ä½¿ç”¨wasmer
wasmer run --dir=. main.wasm
```

### 6.2 å‘½ä»¤è¡Œå·¥å…·

```go
// wasi_cli.go
//go:build wasi

package main

import (
 "flag"
 "fmt"
 "os"
)

func main() {
 // WASIæ”¯æŒå‘½ä»¤è¡Œå‚æ•°
 var name string
 var age int

 flag.StringVar(&name, "name", "World", "Your name")
 flag.IntVar(&age, "age", 0, "Your age")
 flag.Parse()

 fmt.Printf("Hello, %s!\n", name)
 if age > 0 {
  fmt.Printf("You are %d years old.\n", age)
 }

 // è®¿é—®ç¯å¢ƒå˜é‡
 if path := os.Getenv("PATH"); path != "" {
  fmt.Printf("PATH: %s\n", path)
 }

 // æ ‡å‡†è¾“å…¥è¾“å‡º
 fmt.Println("Enter your message:")
 var input string
 fmt.Scanln(&input)
 fmt.Printf("You entered: %s\n", input)
}
```

```bash
# ç¼–è¯‘
tinygo build -o cli.wasm -target=wasi wasi_cli.go

# è¿è¡Œ (å¸¦å‚æ•°)
wasmtime cli.wasm -- --name=Alice --age=25

# å¸¦ç¯å¢ƒå˜é‡
wasmtime --env PATH=/usr/bin cli.wasm
```

---

## 7. æ€§èƒ½ä¼˜åŒ–

### 7.1 äºŒè¿›åˆ¶å¤§å°ä¼˜åŒ–

```bash
# TinyGoä¼˜åŒ–é€‰é¡¹
tinygo build -o main.wasm \
  -target=wasm \
  -no-debug \          # ç§»é™¤è°ƒè¯•ä¿¡æ¯
  -opt=z \             # ä¼˜åŒ–å¤§å°
  -gc=leaking \        # ä½¿ç”¨leaking GC (é€‚åˆçŸ­æœŸè¿è¡Œ)
  main.go

# è¿›ä¸€æ­¥å‹ç¼©
wasm-opt -Oz -o optimized.wasm main.wasm  # ä½¿ç”¨Binaryenä¼˜åŒ–

# å¯ç”¨Brotliå‹ç¼©
brotli -9 optimized.wasm  # ç”Ÿæˆ optimized.wasm.br

# å¤§å°å¯¹æ¯”
/*
åŸå§‹ (æ ‡å‡†Go): 2.8MB
TinyGo:        450KB
TinyGo + opt:  120KB
+ wasm-opt:    85KB
+ Brotli:      28KB âœ…
*/
```

### 7.2 æ€§èƒ½åŸºå‡†æµ‹è¯•

```go
package main

import (
 "fmt"
 "syscall/js"
 "time"
)

// æ€§èƒ½æµ‹è¯•: è®¡ç®—å¯†é›†å‹
func benchmarkFibonacci(this js.Value, args []js.Value) interface{} {
 n := args[0].Int()

 start := time.Now()
 result := fib(n)
 duration := time.Since(start)

 return js.ValueOf(map[string]interface{}{
  "result":   result,
  "duration": duration.Milliseconds(),
 })
}

func fib(n int) int {
 if n <= 1 {
  return n
 }
 return fib(n-1) + fib(n-2)
}

// æ€§èƒ½æµ‹è¯•: å†…å­˜æ“ä½œ
func benchmarkMemory(this js.Value, args []js.Value) interface{} {
 size := args[0].Int()

 start := time.Now()

 // åˆ†é…å¤§æ•°ç»„
 data := make([]int, size)
 for i := range data {
  data[i] = i * 2
 }

 // æ±‚å’Œ
 sum := 0
 for _, v := range data {
  sum += v
 }

 duration := time.Since(start)

 return js.ValueOf(map[string]interface{}{
  "sum":      sum,
  "duration": duration.Milliseconds(),
 })
}

// æ€§èƒ½æµ‹è¯•: å­—ç¬¦ä¸²æ“ä½œ
func benchmarkString(this js.Value, args []js.Value) interface{} {
 count := args[0].Int()

 start := time.Now()

 result := ""
 for i := 0; i < count; i++ {
  result += fmt.Sprintf("Item%d ", i)
 }

 duration := time.Since(start)

 return js.ValueOf(map[string]interface{}{
  "length":   len(result),
  "duration": duration.Milliseconds(),
 })
}

func main() {
 js.Global().Set("benchFib", js.FuncOf(benchmarkFibonacci))
 js.Global().Set("benchMem", js.FuncOf(benchmarkMemory))
 js.Global().Set("benchStr", js.FuncOf(benchmarkString))

 select {}
}
```

```javascript
// æ€§èƒ½å¯¹æ¯”æµ‹è¯•
async function runBenchmarks() {
    console.log("=== Go WASM vs JavaScript Benchmarks ===");

    // Fibonacciæµ‹è¯•
    console.log("\n1. Fibonacci(35):");

    // JavaScript
    let start = performance.now();
    let jsResult = fibonacci(35);
    let jsDuration = performance.now() - start;
    console.log(`  JavaScript: ${jsDuration.toFixed(2)}ms`);

    // Go WASM
    let goResult = benchFib(35);
    console.log(`  Go WASM:    ${goResult.duration}ms`);
    console.log(`  Speedup:    ${(jsDuration / goResult.duration).toFixed(2)}x`);

    // å†…å­˜æ“ä½œæµ‹è¯•
    console.log("\n2. Memory Operations (1M elements):");
    // ... ç±»ä¼¼æµ‹è¯•
}

function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

---

## 8. å®é™…åº”ç”¨

### 8.1 å›¾åƒå¤„ç†

```go
package main

import (
 "image"
 "image/color"
 "syscall/js"
)

type ImageProcessor struct{}

// applyGrayscaleè½¬æ¢ä¸ºç°åº¦å›¾
func (ip *ImageProcessor) applyGrayscale(this js.Value, args []js.Value) interface{} {
 // ä»Canvasè·å–å›¾åƒæ•°æ®
 imageData := args[0]
 data := imageData.Get("data")
 width := imageData.Get("width").Int()
 height := imageData.Get("height").Int()

 // è½¬æ¢ä¸ºç°åº¦
 for i := 0; i < width*height*4; i += 4 {
  r := data.Index(i).Int()
  g := data.Index(i + 1).Int()
  b := data.Index(i + 2).Int()

  // ç°åº¦å…¬å¼
  gray := int(0.299*float64(r) + 0.587*float64(g) + 0.114*float64(b))

  data.SetIndex(i, gray)
  data.SetIndex(i+1, gray)
  data.SetIndex(i+2, gray)
 }

 return imageData
}

// applyBluråº”ç”¨æ¨¡ç³Šæ»¤é•œ
func (ip *ImageProcessor) applyBlur(this js.Value, args []js.Value) interface{} {
 imageData := args[0]
 radius := args[1].Int()

 data := imageData.Get("data")
 width := imageData.Get("width").Int()
 height := imageData.Get("height").Int()

 // å¤åˆ¶åŸå§‹æ•°æ®
 original := make([]uint8, width*height*4)
 for i := 0; i < len(original); i++ {
  original[i] = uint8(data.Index(i).Int())
 }

 // é«˜æ–¯æ¨¡ç³Š
 for y := radius; y < height-radius; y++ {
  for x := radius; x < width-radius; x++ {
   var r, g, b, count int

   for dy := -radius; dy <= radius; dy++ {
    for dx := -radius; dx <= radius; dx++ {
     idx := ((y+dy)*width + (x+dx)) * 4
     r += int(original[idx])
     g += int(original[idx+1])
     b += int(original[idx+2])
     count++
    }
   }

   idx := (y*width + x) * 4
   data.SetIndex(idx, r/count)
   data.SetIndex(idx+1, g/count)
   data.SetIndex(idx+2, b/count)
  }
 }

 return imageData
}

// detectEdgesè¾¹ç¼˜æ£€æµ‹
func (ip *ImageProcessor) detectEdges(this js.Value, args []js.Value) interface{} {
 imageData := args[0]
 data := imageData.Get("data")
 width := imageData.Get("width").Int()
 height := imageData.Get("height").Int()

 // Sobelç®—å­
 sobelX := [][]int{
  {-1, 0, 1},
  {-2, 0, 2},
  {-1, 0, 1},
 }
 sobelY := [][]int{
  {-1, -2, -1},
  {0, 0, 0},
  {1, 2, 1},
 }

 original := make([]uint8, width*height*4)
 for i := 0; i < len(original); i++ {
  original[i] = uint8(data.Index(i).Int())
 }

 for y := 1; y < height-1; y++ {
  for x := 1; x < width-1; x++ {
   var gx, gy int

   for dy := -1; dy <= 1; dy++ {
    for dx := -1; dx <= 1; dx++ {
     idx := ((y+dy)*width + (x+dx)) * 4
     pixel := int(original[idx])

     gx += pixel * sobelX[dy+1][dx+1]
     gy += pixel * sobelY[dy+1][dx+1]
    }
   }

   magnitude := int(math.Sqrt(float64(gx*gx + gy*gy)))
   if magnitude > 255 {
    magnitude = 255
   }

   idx := (y*width + x) * 4
   data.SetIndex(idx, magnitude)
   data.SetIndex(idx+1, magnitude)
   data.SetIndex(idx+2, magnitude)
  }
 }

 return imageData
}

func main() {
 ip := &ImageProcessor{}

 js.Global().Set("goGrayscale", js.FuncOf(ip.applyGrayscale))
 js.Global().Set("goBlur", js.FuncOf(ip.applyBlur))
 js.Global().Set("goEdges", js.FuncOf(ip.detectEdges))

 select {}
}
```

```html
<!-- image_processor.html -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Image Processor</title>
    <style>
        canvas { border: 1px solid #ccc; margin: 10px; }
        button { margin: 5px; padding: 10px 20px; }
    </style>
</head>
<body>
    <h1>WebAssembly Image Processor</h1>

    <input type="file" id="fileInput" accept="image/*">

    <div>
        <button onclick="applyFilter('grayscale')">Grayscale</button>
        <button onclick="applyFilter('blur')">Blur</button>
        <button onclick="applyFilter('edges')">Edge Detection</button>
        <button onclick="reset()">Reset</button>
    </div>

    <canvas id="canvas"></canvas>

    <script src="wasm_exec.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let originalImage;

        // åŠ è½½WASM
        const go = new Go();
        WebAssembly.instantiateStreaming(fetch("image_processor.wasm"), go.importObject)
            .then((result) => go.run(result.instance));

        // åŠ è½½å›¾åƒ
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            const reader = new FileReader();

            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    originalImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
                };
                img.src = event.target.result;
            };

            reader.readAsDataURL(file);
        });

        function applyFilter(type) {
            if (!originalImage) return;

            let imageData = ctx.createImageData(originalImage.width, originalImage.height);
            for (let i = 0; i < originalImage.data.length; i++) {
                imageData.data[i] = originalImage.data[i];
            }

            const start = performance.now();

            switch (type) {
                case 'grayscale':
                    imageData = goGrayscale(imageData);
                    break;
                case 'blur':
                    imageData = goBlur(imageData, 3);
                    break;
                case 'edges':
                    imageData = goEdges(imageData);
                    break;
            }

            const duration = performance.now() - start;
            console.log(`${type} filter: ${duration.toFixed(2)}ms`);

            ctx.putImageData(imageData, 0, 0);
        }

        function reset() {
            if (originalImage) {
                ctx.putImageData(originalImage, 0, 0);
            }
        }
    </script>
</body>
</html>
```

### 8.2 åŠ å¯†/è§£å¯†å·¥å…·

```go
package main

import (
 "crypto/aes"
 "crypto/cipher"
 "crypto/rand"
 "crypto/sha256"
 "encoding/base64"
 "io"
 "syscall/js"
)

type CryptoUtils struct{}

// encryptåŠ å¯†æ•°æ®
func (cu *CryptoUtils) encrypt(this js.Value, args []js.Value) interface{} {
 plaintext := args[0].String()
 password := args[1].String()

 // ç”Ÿæˆå¯†é’¥
 key := sha256.Sum256([]byte(password))

 // åˆ›å»ºAES cipher
 block, err := aes.NewCipher(key[:])
 if err != nil {
  return js.ValueOf(map[string]interface{}{
   "error": err.Error(),
  })
 }

 // æ·»åŠ å¡«å……
 plaintextBytes := []byte(plaintext)
 ciphertext := make([]byte, aes.BlockSize+len(plaintextBytes))
 iv := ciphertext[:aes.BlockSize]

 if _, err := io.ReadFull(rand.Reader, iv); err != nil {
  return js.ValueOf(map[string]interface{}{
   "error": err.Error(),
  })
 }

 // åŠ å¯†
 stream := cipher.NewCFBEncrypter(block, iv)
 stream.XORKeyStream(ciphertext[aes.BlockSize:], plaintextBytes)

 // Base64ç¼–ç 
 encoded := base64.StdEncoding.EncodeToString(ciphertext)

 return js.ValueOf(map[string]interface{}{
  "ciphertext": encoded,
 })
}

// decryptè§£å¯†æ•°æ®
func (cu *CryptoUtils) decrypt(this js.Value, args []js.Value) interface{} {
 ciphertextB64 := args[0].String()
 password := args[1].String()

 // Base64è§£ç 
 ciphertext, err := base64.StdEncoding.DecodeString(ciphertextB64)
 if err != nil {
  return js.ValueOf(map[string]interface{}{
   "error": "Invalid base64",
  })
 }

 // ç”Ÿæˆå¯†é’¥
 key := sha256.Sum256([]byte(password))

 // åˆ›å»ºAES cipher
 block, err := aes.NewCipher(key[:])
 if err != nil {
  return js.ValueOf(map[string]interface{}{
   "error": err.Error(),
  })
 }

 if len(ciphertext) < aes.BlockSize {
  return js.ValueOf(map[string]interface{}{
   "error": "Ciphertext too short",
  })
 }

 iv := ciphertext[:aes.BlockSize]
 ciphertext = ciphertext[aes.BlockSize:]

 // è§£å¯†
 stream := cipher.NewCFBDecrypter(block, iv)
 stream.XORKeyStream(ciphertext, ciphertext)

 return js.ValueOf(map[string]interface{}{
  "plaintext": string(ciphertext),
 })
}

// hashè®¡ç®—SHA-256å“ˆå¸Œ
func (cu *CryptoUtils) hash(this js.Value, args []js.Value) interface{} {
 data := args[0].String()

 hash := sha256.Sum256([]byte(data))
 hexHash := fmt.Sprintf("%x", hash)

 return js.ValueOf(hexHash)
}

func main() {
 cu := &CryptoUtils{}

 js.Global().Set("goEncrypt", js.FuncOf(cu.encrypt))
 js.Global().Set("goDecrypt", js.FuncOf(cu.decrypt))
 js.Global().Set("goHash", js.FuncOf(cu.hash))

 select {}
}
```

---

## 9. è°ƒè¯•ä¸æµ‹è¯•

### 9.1 æµè§ˆå™¨è°ƒè¯•

```go
// debug.go
package main

import (
 "fmt"
 "runtime/debug"
 "syscall/js"
)

// å¯ç”¨è°ƒè¯•æ—¥å¿—
var debugEnabled = true

func log(message string) {
 if debugEnabled {
  js.Global().Get("console").Call("log", "[Go WASM]", message)
 }
}

func logError(message string, err error) {
 js.Global().Get("console").Call("error", "[Go WASM]", message, err.Error())
}

// debugInfoè¿”å›è°ƒè¯•ä¿¡æ¯
func debugInfo(this js.Value, args []js.Value) interface{} {
 info := map[string]interface{}{
  "go_version":  runtime.Version(),
  "go_os":       runtime.GOOS,
  "go_arch":     runtime.GOARCH,
  "num_cpu":     runtime.NumCPU(),
  "num_goroutine": runtime.NumGoroutine(),
 }

 // å†…å­˜ç»Ÿè®¡
 var m runtime.MemStats
 runtime.ReadMemStats(&m)
 info["alloc_mb"] = m.Alloc / 1024 / 1024
 info["total_alloc_mb"] = m.TotalAlloc / 1024 / 1024

 return js.ValueOf(info)
}

// stackTraceè·å–è°ƒç”¨æ ˆ
func stackTrace(this js.Value, args []js.Value) interface{} {
 stack := string(debug.Stack())
 return js.ValueOf(stack)
}

func main() {
 log("Application started")

 js.Global().Set("goDebugInfo", js.FuncOf(debugInfo))
 js.Global().Set("goStackTrace", js.FuncOf(stackTrace))

 select {}
}
```

```javascript
// æµè§ˆå™¨ä¸­è°ƒè¯•
console.log("Debug Info:", goDebugInfo());
console.log("Stack Trace:", goStackTrace());

// Chrome DevTools
// 1. æ‰“å¼€ chrome://flags
// 2. å¯ç”¨ "WebAssembly Debugging"
// 3. åœ¨Sourcesé¢æ¿å¯ä»¥çœ‹åˆ°.wasmæ–‡ä»¶
// 4. è®¾ç½®æ–­ç‚¹è°ƒè¯•
```

### 9.2 å•å…ƒæµ‹è¯•

```go
// math_test.go
//go:build js && wasm

package main

import (
 "testing"
)

func TestAdd(t *testing.T) {
 tests := []struct {
  a, b, want int
 }{
  {1, 2, 3},
  {0, 0, 0},
  {-1, 1, 0},
 }

 for _, tt := range tests {
  got := add(tt.a, tt.b)
  if got != tt.want {
   t.Errorf("add(%d, %d) = %d, want %d", tt.a, tt.b, got, tt.want)
  }
 }
}

func add(a, b int) int {
 return a + b
}
```

```bash
# è¿è¡ŒWASMæµ‹è¯• (éœ€è¦Node.js)
GOOS=js GOARCH=wasm go test -exec="$(go env GOROOT)/misc/wasm/go_js_wasm_exec"

# æˆ–ä½¿ç”¨TinyGo
tinygo test -target=wasm
```

---

## 10. å®Œæ•´é¡¹ç›®ç¤ºä¾‹

### 10.1 Markdownç¼–è¾‘å™¨

```go
// markdown_editor.go
package main

import (
 "syscall/js"

 "github.com/russross/blackfriday/v2"
)

type MarkdownEditor struct {
 inputEl  js.Value
 outputEl js.Value
}

func NewMarkdownEditor() *MarkdownEditor {
 doc := js.Global().Get("document")

 editor := &MarkdownEditor{
  inputEl:  doc.Call("getElementById", "markdown-input"),
  outputEl: doc.Call("getElementById", "html-output"),
 }

 // ç›‘å¬è¾“å…¥äº‹ä»¶
 editor.inputEl.Call("addEventListener", "input", js.FuncOf(editor.handleInput))

 return editor
}

func (me *MarkdownEditor) handleInput(this js.Value, args []js.Value) interface{} {
 markdown := me.inputEl.Get("value").String()

 // ä½¿ç”¨blackfridayæ¸²æŸ“Markdown
 html := blackfriday.Run([]byte(markdown))

 // æ›´æ–°è¾“å‡º
 me.outputEl.Set("innerHTML", string(html))

 return nil
}

func main() {
 NewMarkdownEditor()
 select {}
}
```

```html
<!-- markdown_editor.html -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Markdown Editor</title>
    <style>
        body {
            display: flex;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
        }

        #markdown-input {
            width: 50%;
            padding: 20px;
            font-family: monospace;
            font-size: 14px;
            border: none;
            resize: none;
        }

        #html-output {
            width: 50%;
            padding: 20px;
            border-left: 1px solid #ccc;
            overflow-y: auto;
        }

        #html-output h1 { color: #333; }
        #html-output code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <textarea id="markdown-input" placeholder="Enter Markdown here..."># Hello World

This is **bold** and this is *italic*.

## Code Example

```go
func main() {
    fmt.Println("Hello, Go!")
}
```

- Item 1
- Item 2
- Item 3
</textarea>
    <div id="html-output"></div>

    <script src="wasm_exec.js"></script>
    <script>
        const go = new Go();
        WebAssembly.instantiateStreaming(fetch("markdown_editor.wasm"), go.importObject)
            .then((result) => go.run(result.instance));
    </script>

</body>
</html>
```

### 10.2 é¡¹ç›®ç»“æ„

```text
wasm-project/
â”œâ”€â”€ cmd/
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â””â”€â”€ main.go
â”‚   â””â”€â”€ cli/
â”‚       â””â”€â”€ main.go (WASI)
â”œâ”€â”€ pkg/
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â””â”€â”€ helper.go
â”‚   â””â”€â”€ components/
â”‚       â””â”€â”€ button.go
â”œâ”€â”€ web/
â”‚   â”œâ”€â”€ index.html
â”‚   â”œâ”€â”€ styles.css
â”‚   â””â”€â”€ wasm_exec.js
â”œâ”€â”€ Makefile
â”œâ”€â”€ go.mod
â””â”€â”€ README.md
```

```makefile
# Makefile
.PHONY: build-tiny build-std serve clean test

# ä½¿ç”¨TinyGoç¼–è¯‘ (æ¨è)
build-tiny:
 tinygo build -o web/app.wasm -target=wasm -no-debug -opt=z ./cmd/app

# ä½¿ç”¨æ ‡å‡†Goç¼–è¯‘
build-std:
 GOOS=js GOARCH=wasm go build -o web/app.wasm ./cmd/app

# ç¼–è¯‘WASI CLI
build-wasi:
 tinygo build -o cli.wasm -target=wasi ./cmd/cli

# å¯åŠ¨å¼€å‘æœåŠ¡å™¨
serve:
 @echo "Server running on http://localhost:8080"
 @cd web && python3 -m http.server 8080

# æµ‹è¯•
test:
 GOOS=js GOARCH=wasm go test ./...

# ä¼˜åŒ–WASM
optimize:
 wasm-opt -Oz -o web/app_optimized.wasm web/app.wasm
 brotli -9 web/app_optimized.wasm

# æ¸…ç†
clean:
 rm -f web/*.wasm web/*.wasm.br

# å®Œæ•´æ„å»ºæµç¨‹
all: build-tiny optimize
```

---

## æ€»ç»“

### WebAssemblyæŠ€æœ¯æ ˆ

```text
1. ç¼–è¯‘å™¨é€‰æ‹©:
   âœ… TinyGo (æ¨è): å°ä½“ç§¯, é«˜æ€§èƒ½
   âœ… æ ‡å‡†Go: å®Œæ•´æ ‡å‡†åº“

2. ç›®æ ‡å¹³å°:
   âœ… Webæµè§ˆå™¨ (target=wasm)
   âœ… WASI (target=wasi)

3. æ€§èƒ½ä¼˜åŠ¿:
   â€¢ æ¯”JavaScriptå¿« 2-20å€
   â€¢ äºŒè¿›åˆ¶å¤§å° 50-500KB (TinyGo)
   â€¢ å¯åŠ¨æ—¶é—´ <100ms
```

### é€‚ç”¨åœºæ™¯

```text
âœ… é«˜æ€§èƒ½Webåº”ç”¨:
   â€¢ å›¾åƒ/è§†é¢‘å¤„ç†
   â€¢ æ•°æ®å¯è§†åŒ–
   â€¢ æ¸¸æˆå¼•æ“
   â€¢ CAD/3Då»ºæ¨¡

âœ… è·¨å¹³å°å·¥å…·:
   â€¢ CLIå·¥å…· (WASI)
   â€¢ åŠ å¯†/è§£å¯†
   â€¢ æ•°æ®å¤„ç†

âœ… è¾¹ç¼˜è®¡ç®—:
   â€¢ Cloudflare Workers
   â€¢ Fastly Compute@Edge
```

### æœ€ä½³å®è·µ

1. **é€‰æ‹©åˆé€‚çš„ç¼–è¯‘å™¨**: TinyGoé€‚åˆè¿½æ±‚å°ä½“ç§¯
2. **ä¼˜åŒ–äºŒè¿›åˆ¶å¤§å°**: ä½¿ç”¨-opt=zå’Œwasm-opt
3. **å¯ç”¨Brotliå‹ç¼©**: å‡å°‘70-80%ä½“ç§¯
4. **é¿å…å¤§é‡DOMæ“ä½œ**: æ‰¹é‡æ›´æ–°
5. **ä½¿ç”¨Web Workers**: é¿å…é˜»å¡ä¸»çº¿ç¨‹

**ç›¸å…³æ–‡æ¡£:**

- [æ€§èƒ½ä¼˜åŒ–](../07-æ€§èƒ½ä¼˜åŒ–/10-Go-1.25.3æ€§èƒ½ä¼˜åŒ–å®Œæ•´å®æˆ˜.md)
- [Serverlessä¸FaaS](32-Go-1.25.3Serverlessä¸FaaSå®Œæ•´å®æˆ˜.md)
- [äº‘åŸç”Ÿéƒ¨ç½²](../06-äº‘åŸç”Ÿä¸å®¹å™¨/10-äº‘åŸç”Ÿå®Œæ•´é¡¹ç›®å®æˆ˜.md)
