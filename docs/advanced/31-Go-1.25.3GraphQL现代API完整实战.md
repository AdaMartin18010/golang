# Go 1.25.3GraphQLç°ä»£APIå®Œæ•´å®æˆ˜

> **ç‰ˆæœ¬**: Go 1.25.3  
> **éš¾åº¦**: â­â­â­â­â­  
> **æ ‡ç­¾**: `GraphQL` `gqlgen` `Schema` `Resolver` `DataLoader` `Subscription` `Federation` `Apollo`

## ğŸ“‹ ç›®å½•

- [Go 1.25.3GraphQLç°ä»£APIå®Œæ•´å®æˆ˜](#go-1253graphqlç°ä»£apiå®Œæ•´å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. GraphQLæ¦‚è¿°](#1-graphqlæ¦‚è¿°)
    - [1.1 GraphQL vs REST](#11-graphql-vs-rest)
    - [1.2 GraphQLå·¥ä½œæµç¨‹](#12-graphqlå·¥ä½œæµç¨‹)
  - [2. gqlgenå¿«é€Ÿå…¥é—¨](#2-gqlgenå¿«é€Ÿå…¥é—¨)
    - [2.1 é¡¹ç›®åˆå§‹åŒ–](#21-é¡¹ç›®åˆå§‹åŒ–)
    - [2.2 å®šä¹‰Schema](#22-å®šä¹‰schema)
    - [2.3 ç”Ÿæˆä»£ç ](#23-ç”Ÿæˆä»£ç )
  - [3. Schemaè®¾è®¡](#3-schemaè®¾è®¡)
    - [3.1 ç±»å‹è®¾è®¡æœ€ä½³å®è·µ](#31-ç±»å‹è®¾è®¡æœ€ä½³å®è·µ)
    - [3.2 Schemaæ‹†åˆ†](#32-schemaæ‹†åˆ†)
  - [4. Resolverå®ç°](#4-resolverå®ç°)
    - [4.1 Query Resolver](#41-query-resolver)
    - [4.2 Mutation Resolver](#42-mutation-resolver)
    - [4.3 Field Resolver](#43-field-resolver)
  - [5. DataLoaderä¼˜åŒ–](#5-dataloaderä¼˜åŒ–)
    - [5.1 DataLoaderå®ç°](#51-dataloaderå®ç°)
    - [5.2 DataLoaderä¸­é—´ä»¶](#52-dataloaderä¸­é—´ä»¶)
    - [5.3 ä½¿ç”¨DataLoader](#53-ä½¿ç”¨dataloader)
  - [6. Subscriptionå®æ—¶æ¨é€](#6-subscriptionå®æ—¶æ¨é€)
    - [6.1 WebSocketé…ç½®](#61-websocketé…ç½®)
    - [6.2 Subscription Resolver](#62-subscription-resolver)
    - [6.3 PubSubå®ç°](#63-pubsubå®ç°)
  - [7. Federationå¾®æœåŠ¡](#7-federationå¾®æœåŠ¡)
    - [7.1 Apollo Federationæ¦‚è¿°](#71-apollo-federationæ¦‚è¿°)
    - [7.2 Federation Schema](#72-federation-schema)
    - [7.3 Entity Resolver](#73-entity-resolver)
  - [8. å®‰å…¨ä¸æœ€ä½³å®è·µ](#8-å®‰å…¨ä¸æœ€ä½³å®è·µ)
    - [8.1 Queryå¤æ‚åº¦é™åˆ¶](#81-queryå¤æ‚åº¦é™åˆ¶)
    - [8.2 æ·±åº¦é™åˆ¶](#82-æ·±åº¦é™åˆ¶)
    - [8.3 æŸ¥è¯¢ç™½åå•](#83-æŸ¥è¯¢ç™½åå•)
    - [8.4 Rate Limiting](#84-rate-limiting)
    - [8.5 æœ€ä½³å®è·µæ€»ç»“](#85-æœ€ä½³å®è·µæ€»ç»“)
  - [ğŸ“š å‚è€ƒèµ„æ–™](#-å‚è€ƒèµ„æ–™)

---

## 1. GraphQLæ¦‚è¿°

### 1.1 GraphQL vs REST

```go
// GraphQL vs RESTå¯¹æ¯”
/*
REST API:
å®¢æˆ·ç«¯éœ€è¦å¤šæ¬¡è¯·æ±‚

GET /users/123              // è·å–ç”¨æˆ·åŸºæœ¬ä¿¡æ¯
GET /users/123/posts        // è·å–ç”¨æˆ·æ–‡ç« 
GET /users/123/followers    // è·å–ç²‰ä¸åˆ—è¡¨
GET /posts/456/comments     // è·å–æ–‡ç« è¯„è®º

é—®é¢˜:
1. Over-fetching: è¿”å›å¤šä½™å­—æ®µ
2. Under-fetching: éœ€è¦å¤šæ¬¡è¯·æ±‚
3. æ¥å£å›ºå®š,ä¸çµæ´»
4. ç‰ˆæœ¬ç®¡ç†å›°éš¾

GraphQL API:
ä¸€æ¬¡è¯·æ±‚è·å–æ‰€æœ‰æ•°æ®

query {
  user(id: "123") {
    id
    name
    email
    posts {
      id
      title
      comments {
        id
        content
        author {
          name
        }
      }
    }
    followers {
      id
      name
    }
  }
}

ä¼˜åŠ¿:
1. æŒ‰éœ€æŸ¥è¯¢,ä¸å¤šä¸å°‘
2. ä¸€æ¬¡è¯·æ±‚è·å–æ‰€æœ‰æ•°æ®
3. å¼ºç±»å‹ç³»ç»Ÿ
4. è‡ªæ–‡æ¡£åŒ–
5. æ— éœ€ç‰ˆæœ¬ç®¡ç†
*/

// GraphQLæ ¸å¿ƒæ¦‚å¿µ
type GraphQLConcepts struct {
    // 1. Schema: å®šä¹‰APIç»“æ„
    Schema string // type Query { user(id: ID!): User }
    
    // 2. Query: æŸ¥è¯¢æ•°æ® (ç±»ä¼¼GET)
    Query string // query { user(id: "123") { name } }
    
    // 3. Mutation: ä¿®æ”¹æ•°æ® (ç±»ä¼¼POST/PUT/DELETE)
    Mutation string // mutation { createUser(input: ...) { id } }
    
    // 4. Subscription: å®æ—¶æ¨é€ (WebSocket)
    Subscription string // subscription { messageAdded { content } }
    
    // 5. Resolver: æ•°æ®è·å–é€»è¾‘
    Resolver string // func (r *queryResolver) User(id string) (*User, error)
    
    // 6. DataLoader: æ‰¹é‡åŠ è½½,è§£å†³N+1é—®é¢˜
    DataLoader string // loader.LoadMany(ids)
}
```

### 1.2 GraphQLå·¥ä½œæµç¨‹

```go
/*
GraphQLè¯·æ±‚å¤„ç†æµç¨‹:

1. å®¢æˆ·ç«¯å‘é€Query
   â†“
2. GraphQLè§£æQuery
   â†“
3. éªŒè¯Schema
   â†“
4. æ‰§è¡ŒResolver
   â”œâ”€ å¹¶è¡Œæ‰§è¡Œç‹¬ç«‹å­—æ®µ
   â””â”€ åµŒå¥—å­—æ®µé€’å½’æ‰§è¡Œ
   â†“
5. ç»„è£…ç»“æœ
   â†“
6. è¿”å›JSON

ç¤ºä¾‹:
query {
  user(id: "123") {      // Resolver: UserResolver
    name                 // ç›´æ¥å­—æ®µ
    posts {              // Resolver: PostsResolver (å¯èƒ½N+1)
      title
      author {           // Resolver: AuthorResolver
        name
      }
    }
  }
}

Resolveræ‰§è¡Œé¡ºåº:
1. UserResolver(id: "123")
2. PostsResolver(user: User) -> [Post1, Post2, Post3]
3. å¹¶è¡Œæ‰§è¡Œ:
   - AuthorResolver(post: Post1)
   - AuthorResolver(post: Post2)
   - AuthorResolver(post: Post3)
*/
```

---

## 2. gqlgenå¿«é€Ÿå…¥é—¨

### 2.1 é¡¹ç›®åˆå§‹åŒ–

```bash
# åˆ›å»ºé¡¹ç›®
mkdir graphql-server && cd graphql-server
go mod init github.com/yourorg/graphql-server

# å®‰è£…gqlgen
go get github.com/99designs/gqlgen

# åˆå§‹åŒ–gqlgen
go run github.com/99designs/gqlgen init

# é¡¹ç›®ç»“æ„
# â”œâ”€â”€ graph/
# â”‚   â”œâ”€â”€ schema.graphqls      # GraphQL Schema
# â”‚   â”œâ”€â”€ generated/            # è‡ªåŠ¨ç”Ÿæˆçš„ä»£ç 
# â”‚   â”‚   â””â”€â”€ generated.go
# â”‚   â”œâ”€â”€ model/                # æ¨¡å‹å®šä¹‰
# â”‚   â”‚   â””â”€â”€ models_gen.go
# â”‚   â””â”€â”€ resolver.go           # Resolverå®ç°
# â”œâ”€â”€ server.go                 # æœåŠ¡å™¨å…¥å£
# â”œâ”€â”€ go.mod
# â””â”€â”€ gqlgen.yml                # é…ç½®æ–‡ä»¶
```

### 2.2 å®šä¹‰Schema

```graphql
# graph/schema.graphqls

# æŸ¥è¯¢
type Query {
  # è·å–ç”¨æˆ·
  user(id: ID!): User
  # è·å–æ‰€æœ‰ç”¨æˆ·
  users(limit: Int, offset: Int): [User!]!
  # æœç´¢ç”¨æˆ·
  searchUsers(keyword: String!): [User!]!
  
  # è·å–æ–‡ç« 
  post(id: ID!): Post
  # è·å–æ‰€æœ‰æ–‡ç« 
  posts(limit: Int, offset: Int): [Post!]!
}

# å˜æ›´
type Mutation {
  # åˆ›å»ºç”¨æˆ·
  createUser(input: CreateUserInput!): User!
  # æ›´æ–°ç”¨æˆ·
  updateUser(id: ID!, input: UpdateUserInput!): User!
  # åˆ é™¤ç”¨æˆ·
  deleteUser(id: ID!): Boolean!
  
  # åˆ›å»ºæ–‡ç« 
  createPost(input: CreatePostInput!): Post!
  # ç‚¹èµæ–‡ç« 
  likePost(postId: ID!): Post!
}

# è®¢é˜…
type Subscription {
  # æ–°æ–‡ç« é€šçŸ¥
  postAdded: Post!
  # è¯„è®ºé€šçŸ¥
  commentAdded(postId: ID!): Comment!
}

# ç”¨æˆ·ç±»å‹
type User {
  id: ID!
  username: String!
  email: String!
  avatar: String
  bio: String
  createdAt: Time!
  
  # å…³è”æ•°æ®
  posts: [Post!]!
  followers: [User!]!
  following: [User!]!
  followerCount: Int!
  followingCount: Int!
}

# æ–‡ç« ç±»å‹
type Post {
  id: ID!
  title: String!
  content: String!
  author: User!
  tags: [String!]!
  likes: Int!
  createdAt: Time!
  updatedAt: Time!
  
  # å…³è”æ•°æ®
  comments: [Comment!]!
  commentCount: Int!
}

# è¯„è®ºç±»å‹
type Comment {
  id: ID!
  content: String!
  author: User!
  post: Post!
  createdAt: Time!
}

# è¾“å…¥ç±»å‹
input CreateUserInput {
  username: String!
  email: String!
  password: String!
  avatar: String
  bio: String
}

input UpdateUserInput {
  username: String
  email: String
  avatar: String
  bio: String
}

input CreatePostInput {
  title: String!
  content: String!
  tags: [String!]
}

# è‡ªå®šä¹‰æ ‡é‡
scalar Time
```

### 2.3 ç”Ÿæˆä»£ç 

```bash
# ç”ŸæˆResolveréª¨æ¶å’Œæ¨¡å‹
go run github.com/99designs/gqlgen generate

# ç”Ÿæˆçš„æ–‡ä»¶:
# - graph/generated/generated.go  (GraphQLæ‰§è¡Œå¼•æ“)
# - graph/model/models_gen.go     (Goæ¨¡å‹)
# - graph/resolver.go             (Resolverå®ç°)
```

---

## 3. Schemaè®¾è®¡

### 3.1 ç±»å‹è®¾è®¡æœ€ä½³å®è·µ

```graphql
# schema/best_practices.graphqls

# ===== 1. ä½¿ç”¨æ¥å£ =====
interface Node {
  id: ID!
}

interface Timestamped {
  createdAt: Time!
  updatedAt: Time!
}

type User implements Node & Timestamped {
  id: ID!
  username: String!
  createdAt: Time!
  updatedAt: Time!
}

type Post implements Node & Timestamped {
  id: ID!
  title: String!
  createdAt: Time!
  updatedAt: Time!
}

# ===== 2. ä½¿ç”¨è”åˆç±»å‹ =====
union SearchResult = User | Post | Comment

type Query {
  search(keyword: String!): [SearchResult!]!
}

# ===== 3. ä½¿ç”¨æšä¸¾ =====
enum PostStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum UserRole {
  USER
  ADMIN
  MODERATOR
}

type Post {
  id: ID!
  title: String!
  status: PostStatus!
}

# ===== 4. åˆ†é¡µ =====
# Relayé£æ ¼ (Cursor-based)
type PostConnection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PostEdge {
  node: Post!
  cursor: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  posts(
    first: Int
    after: String
    last: Int
    before: String
  ): PostConnection!
}

# ===== 5. é”™è¯¯å¤„ç† =====
type Result {
  success: Boolean!
  message: String
  data: User
  errors: [Error!]
}

type Error {
  field: String
  message: String!
  code: String!
}

type Mutation {
  createUser(input: CreateUserInput!): Result!
}

# ===== 6. å­—æ®µå‚æ•° =====
type Query {
  users(
    # åˆ†é¡µ
    limit: Int = 10
    offset: Int = 0
    
    # æ’åº
    orderBy: OrderBy
    sortOrder: SortOrder = ASC
    
    # è¿‡æ»¤
    filter: UserFilter
  ): [User!]!
}

enum OrderBy {
  CREATED_AT
  UPDATED_AT
  USERNAME
}

enum SortOrder {
  ASC
  DESC
}

input UserFilter {
  username: String
  email: String
  role: UserRole
  createdAfter: Time
  createdBefore: Time
}
```

### 3.2 Schemaæ‹†åˆ†

```go
// schema/schema.go
package schema

import (
    "os"
    "path/filepath"
)

// LoadSchema åŠ è½½å¤šä¸ªSchemaæ–‡ä»¶
func LoadSchema() (string, error) {
    schemaFiles := []string{
        "schema/user.graphqls",
        "schema/post.graphqls",
        "schema/comment.graphqls",
        "schema/common.graphqls",
    }
    
    var schema string
    for _, file := range schemaFiles {
        data, err := os.ReadFile(file)
        if err != nil {
            return "", err
        }
        schema += string(data) + "\n"
    }
    
    return schema, nil
}
```

```graphql
# schema/user.graphqls
extend type Query {
  user(id: ID!): User
  users: [User!]!
}

extend type Mutation {
  createUser(input: CreateUserInput!): User!
}

type User implements Node {
  id: ID!
  username: String!
  email: String!
}

# schema/post.graphqls
extend type Query {
  post(id: ID!): Post
  posts: [Post!]!
}

extend type Mutation {
  createPost(input: CreatePostInput!): Post!
}

type Post implements Node {
  id: ID!
  title: String!
  author: User!
}

# schema/common.graphqls
interface Node {
  id: ID!
}

scalar Time
```

---

## 4. Resolverå®ç°

### 4.1 Query Resolver

```go
// graph/resolver.go
package graph

import (
    "context"
    "github.com/yourorg/graphql-server/graph/model"
)

// Resolver æ ¹Resolver
type Resolver struct {
    userService UserService
    postService PostService
}

// Query Resolver
func (r *Resolver) Query() QueryResolver {
    return &queryResolver{r}
}

type queryResolver struct{ *Resolver }

// User è·å–å•ä¸ªç”¨æˆ·
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
    return r.userService.GetUserByID(ctx, id)
}

// Users è·å–ç”¨æˆ·åˆ—è¡¨
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int) ([]*model.User, error) {
    l := 10
    if limit != nil {
        l = *limit
    }
    
    o := 0
    if offset != nil {
        o = *offset
    }
    
    return r.userService.ListUsers(ctx, l, o)
}

// SearchUsers æœç´¢ç”¨æˆ·
func (r *queryResolver) SearchUsers(ctx context.Context, keyword string) ([]*model.User, error) {
    return r.userService.SearchUsers(ctx, keyword)
}

// Post è·å–å•ä¸ªæ–‡ç« 
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
    return r.postService.GetPostByID(ctx, id)
}

// Posts è·å–æ–‡ç« åˆ—è¡¨
func (r *queryResolver) Posts(ctx context.Context, limit *int, offset *int) ([]*model.Post, error) {
    l := 10
    if limit != nil {
        l = *limit
    }
    
    o := 0
    if offset != nil {
        o = *offset
    }
    
    return r.postService.ListPosts(ctx, l, o)
}
```

### 4.2 Mutation Resolver

```go
// graph/mutation.go
package graph

import (
    "context"
    "github.com/yourorg/graphql-server/graph/model"
)

// Mutation Resolver
func (r *Resolver) Mutation() MutationResolver {
    return &mutationResolver{r}
}

type mutationResolver struct{ *Resolver }

// CreateUser åˆ›å»ºç”¨æˆ·
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.User, error) {
    // 1. éªŒè¯è¾“å…¥
    if err := validateCreateUserInput(input); err != nil {
        return nil, err
    }
    
    // 2. åˆ›å»ºç”¨æˆ·
    user, err := r.userService.CreateUser(ctx, input)
    if err != nil {
        return nil, err
    }
    
    // 3. å‘é€æ¬¢è¿é‚®ä»¶ (å¼‚æ­¥)
    go r.userService.SendWelcomeEmail(ctx, user.Email)
    
    return user, nil
}

// UpdateUser æ›´æ–°ç”¨æˆ·
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.UpdateUserInput) (*model.User, error) {
    // 1. æƒé™æ£€æŸ¥
    currentUser := getCurrentUser(ctx)
    if currentUser.ID != id && currentUser.Role != "ADMIN" {
        return nil, fmt.Errorf("permission denied")
    }
    
    // 2. æ›´æ–°ç”¨æˆ·
    return r.userService.UpdateUser(ctx, id, input)
}

// DeleteUser åˆ é™¤ç”¨æˆ·
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
    // 1. æƒé™æ£€æŸ¥
    currentUser := getCurrentUser(ctx)
    if currentUser.Role != "ADMIN" {
        return false, fmt.Errorf("permission denied")
    }
    
    // 2. åˆ é™¤ç”¨æˆ·
    if err := r.userService.DeleteUser(ctx, id); err != nil {
        return false, err
    }
    
    return true, nil
}

// CreatePost åˆ›å»ºæ–‡ç« 
func (r *mutationResolver) CreatePost(ctx context.Context, input model.CreatePostInput) (*model.Post, error) {
    currentUser := getCurrentUser(ctx)
    
    post, err := r.postService.CreatePost(ctx, currentUser.ID, input)
    if err != nil {
        return nil, err
    }
    
    // è§¦å‘äº‹ä»¶: æ–°æ–‡ç« å‘å¸ƒ
    r.pubsub.Publish("post_added", post)
    
    return post, nil
}

// LikePost ç‚¹èµæ–‡ç« 
func (r *mutationResolver) LikePost(ctx context.Context, postID string) (*model.Post, error) {
    currentUser := getCurrentUser(ctx)
    
    return r.postService.LikePost(ctx, postID, currentUser.ID)
}
```

### 4.3 Field Resolver

```go
// graph/user.go
package graph

import (
    "context"
    "github.com/yourorg/graphql-server/graph/model"
)

// User Field Resolver
func (r *Resolver) User() UserResolver {
    return &userResolver{r}
}

type userResolver struct{ *Resolver }

// Posts è·å–ç”¨æˆ·çš„æ–‡ç« 
func (r *userResolver) Posts(ctx context.Context, obj *model.User) ([]*model.Post, error) {
    // é€šè¿‡DataLoaderæ‰¹é‡åŠ è½½ (é¿å…N+1é—®é¢˜)
    return r.postService.GetPostsByUserID(ctx, obj.ID)
}

// Followers è·å–ç²‰ä¸åˆ—è¡¨
func (r *userResolver) Followers(ctx context.Context, obj *model.User) ([]*model.User, error) {
    return r.userService.GetFollowers(ctx, obj.ID)
}

// Following è·å–å…³æ³¨åˆ—è¡¨
func (r *userResolver) Following(ctx context.Context, obj *model.User) ([]*model.User, error) {
    return r.userService.GetFollowing(ctx, obj.ID)
}

// FollowerCount ç²‰ä¸æ•°é‡
func (r *userResolver) FollowerCount(ctx context.Context, obj *model.User) (int, error) {
    return r.userService.GetFollowerCount(ctx, obj.ID)
}

// FollowingCount å…³æ³¨æ•°é‡
func (r *userResolver) FollowingCount(ctx context.Context, obj *model.User) (int, error) {
    return r.userService.GetFollowingCount(ctx, obj.ID)
}

// Post Field Resolver
func (r *Resolver) Post() PostResolver {
    return &postResolver{r}
}

type postResolver struct{ *Resolver }

// Author è·å–æ–‡ç« ä½œè€…
func (r *postResolver) Author(ctx context.Context, obj *model.Post) (*model.User, error) {
    // ä½¿ç”¨DataLoader
    loader := getDataLoader(ctx)
    return loader.UserLoader.Load(obj.AuthorID)
}

// Comments è·å–æ–‡ç« è¯„è®º
func (r *postResolver) Comments(ctx context.Context, obj *model.Post) ([]*model.Comment, error) {
    return r.commentService.GetCommentsByPostID(ctx, obj.ID)
}

// CommentCount è¯„è®ºæ•°é‡
func (r *postResolver) CommentCount(ctx context.Context, obj *model.Post) (int, error) {
    return r.commentService.GetCommentCount(ctx, obj.ID)
}
```

---

## 5. DataLoaderä¼˜åŒ–

### 5.1 DataLoaderå®ç°

```go
// dataloader/user_loader.go
package dataloader

import (
    "context"
    "github.com/graph-gophers/dataloader"
    "github.com/yourorg/graphql-server/graph/model"
)

// UserLoader ç”¨æˆ·DataLoader
type UserLoader struct {
    loader *dataloader.Loader
}

// NewUserLoader åˆ›å»ºUserLoader
func NewUserLoader(userService UserService) *UserLoader {
    batchFn := func(ctx context.Context, keys dataloader.Keys) []*dataloader.Result {
        // æ‰¹é‡åŠ è½½ç”¨æˆ·
        userIDs := make([]string, len(keys))
        for i, key := range keys {
            userIDs[i] = key.String()
        }
        
        users, err := userService.GetUsersByIDs(ctx, userIDs)
        if err != nil {
            results := make([]*dataloader.Result, len(keys))
            for i := range results {
                results[i] = &dataloader.Result{Error: err}
            }
            return results
        }
        
        // æ„å»ºç»“æœæ˜ å°„
        userMap := make(map[string]*model.User)
        for _, user := range users {
            userMap[user.ID] = user
        }
        
        // æŒ‰keysé¡ºåºè¿”å›ç»“æœ
        results := make([]*dataloader.Result, len(keys))
        for i, key := range keys {
            user, exists := userMap[key.String()]
            if exists {
                results[i] = &dataloader.Result{Data: user}
            } else {
                results[i] = &dataloader.Result{Error: fmt.Errorf("user not found: %s", key.String())}
            }
        }
        
        return results
    }
    
    loader := dataloader.NewBatchedLoader(batchFn, dataloader.WithBatchCapacity(100))
    
    return &UserLoader{loader: loader}
}

// Load åŠ è½½å•ä¸ªç”¨æˆ·
func (l *UserLoader) Load(id string) (*model.User, error) {
    thunk := l.loader.Load(context.Background(), dataloader.StringKey(id))
    result, err := thunk()
    if err != nil {
        return nil, err
    }
    return result.(*model.User), nil
}

// LoadMany æ‰¹é‡åŠ è½½ç”¨æˆ·
func (l *UserLoader) LoadMany(ids []string) ([]*model.User, []error) {
    keys := make(dataloader.Keys, len(ids))
    for i, id := range ids {
        keys[i] = dataloader.StringKey(id)
    }
    
    thunk := l.loader.LoadMany(context.Background(), keys)
    results, errs := thunk()
    
    users := make([]*model.User, len(results))
    for i, result := range results {
        if result != nil {
            users[i] = result.(*model.User)
        }
    }
    
    return users, errs
}
```

### 5.2 DataLoaderä¸­é—´ä»¶

```go
// middleware/dataloader.go
package middleware

import (
    "context"
    "net/http"
    "github.com/yourorg/graphql-server/dataloader"
)

// DataLoader Context Key
type contextKey string

const dataLoaderKey contextKey = "dataloader"

// DataLoaderMiddleware DataLoaderä¸­é—´ä»¶
func DataLoaderMiddleware(userService UserService, postService PostService) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // ä¸ºæ¯ä¸ªè¯·æ±‚åˆ›å»ºæ–°çš„DataLoader
            loaders := &Loaders{
                UserLoader: dataloader.NewUserLoader(userService),
                PostLoader: dataloader.NewPostLoader(postService),
            }
            
            ctx := context.WithValue(r.Context(), dataLoaderKey, loaders)
            next.ServeHTTP(w, r.WithContext(ctx))
        })
    }
}

// Loaders æ‰€æœ‰DataLoader
type Loaders struct {
    UserLoader *dataloader.UserLoader
    PostLoader *dataloader.PostLoader
}

// GetLoaders ä»Contextè·å–DataLoader
func GetLoaders(ctx context.Context) *Loaders {
    return ctx.Value(dataLoaderKey).(*Loaders)
}
```

### 5.3 ä½¿ç”¨DataLoader

```go
// graph/post.go
package graph

import (
    "context"
    "github.com/yourorg/graphql-server/middleware"
)

// Author ä½¿ç”¨DataLoaderè·å–ä½œè€…
func (r *postResolver) Author(ctx context.Context, obj *model.Post) (*model.User, error) {
    loaders := middleware.GetLoaders(ctx)
    return loaders.UserLoader.Load(obj.AuthorID)
}

// æ€§èƒ½å¯¹æ¯”
/*
ä¸ä½¿ç”¨DataLoader (N+1é—®é¢˜):
Queryè·å–10ä¸ªPost,æ¯ä¸ªPostéœ€è¦è·å–Author

SELECT * FROM posts LIMIT 10;             // 1æ¬¡æŸ¥è¯¢
SELECT * FROM users WHERE id = 1;         // 10æ¬¡æŸ¥è¯¢
SELECT * FROM users WHERE id = 2;
SELECT * FROM users WHERE id = 3;
...
æ€»è®¡: 11æ¬¡æŸ¥è¯¢

ä½¿ç”¨DataLoader:
SELECT * FROM posts LIMIT 10;             // 1æ¬¡æŸ¥è¯¢
SELECT * FROM users WHERE id IN (1,2,3,...); // 1æ¬¡æ‰¹é‡æŸ¥è¯¢
æ€»è®¡: 2æ¬¡æŸ¥è¯¢

æ€§èƒ½æå‡: 5-10å€
*/
```

---

## 6. Subscriptionå®æ—¶æ¨é€

### 6.1 WebSocketé…ç½®

```go
// server.go
package main

import (
    "net/http"
    "github.com/99designs/gqlgen/graphql/handler"
    "github.com/99designs/gqlgen/graphql/handler/transport"
    "github.com/gorilla/websocket"
)

func main() {
    // åˆ›å»ºGraphQL Handler
    srv := handler.NewDefaultServer(generated.NewExecutableSchema(generated.Config{
        Resolvers: &graph.Resolver{},
    }))
    
    // æ·»åŠ WebSocketä¼ è¾“
    srv.AddTransport(&transport.Websocket{
        Upgrader: websocket.Upgrader{
            CheckOrigin: func(r *http.Request) bool {
                return true // ç”Ÿäº§ç¯å¢ƒéœ€è¦ä¸¥æ ¼æ£€æŸ¥
            },
        },
        KeepAlivePingInterval: 10 * time.Second,
    })
    
    http.Handle("/graphql", srv)
    http.ListenAndServe(":8080", nil)
}
```

### 6.2 Subscription Resolver

```graphql
# schema.graphqls
type Subscription {
  # æ–°æ–‡ç« é€šçŸ¥
  postAdded: Post!
  
  # è¯„è®ºé€šçŸ¥
  commentAdded(postId: ID!): Comment!
  
  # ç”¨æˆ·åœ¨çº¿çŠ¶æ€
  userOnlineStatus(userId: ID!): OnlineStatus!
}

type OnlineStatus {
  userId: ID!
  isOnline: Boolean!
  lastSeen: Time!
}
```

```go
// graph/subscription.go
package graph

import (
    "context"
    "time"
)

// Subscription Resolver
func (r *Resolver) Subscription() SubscriptionResolver {
    return &subscriptionResolver{r}
}

type subscriptionResolver struct{ *Resolver }

// PostAdded æ–°æ–‡ç« è®¢é˜…
func (r *subscriptionResolver) PostAdded(ctx context.Context) (<-chan *model.Post, error) {
    // åˆ›å»ºChannel
    posts := make(chan *model.Post, 1)
    
    // è®¢é˜…äº‹ä»¶
    subscription := r.pubsub.Subscribe("post_added")
    
    // å¯åŠ¨ç›‘å¬
    go func() {
        defer close(posts)
        defer subscription.Unsubscribe()
        
        for {
            select {
            case <-ctx.Done():
                return
            case msg := <-subscription.Channel():
                post := msg.(*model.Post)
                select {
                case posts <- post:
                case <-ctx.Done():
                    return
                }
            }
        }
    }()
    
    return posts, nil
}

// CommentAdded è¯„è®ºè®¢é˜…
func (r *subscriptionResolver) CommentAdded(ctx context.Context, postID string) (<-chan *model.Comment, error) {
    comments := make(chan *model.Comment, 1)
    
    subscription := r.pubsub.Subscribe(fmt.Sprintf("comment_added:%s", postID))
    
    go func() {
        defer close(comments)
        defer subscription.Unsubscribe()
        
        for {
            select {
            case <-ctx.Done():
                return
            case msg := <-subscription.Channel():
                comment := msg.(*model.Comment)
                select {
                case comments <- comment:
                case <-ctx.Done():
                    return
                }
            }
        }
    }()
    
    return comments, nil
}

// UserOnlineStatus ç”¨æˆ·åœ¨çº¿çŠ¶æ€
func (r *subscriptionResolver) UserOnlineStatus(ctx context.Context, userID string) (<-chan *model.OnlineStatus, error) {
    statusCh := make(chan *model.OnlineStatus, 1)
    
    // è®¢é˜…Redis Pub/Sub
    subscription := r.redis.Subscribe(ctx, fmt.Sprintf("user:status:%s", userID))
    
    go func() {
        defer close(statusCh)
        defer subscription.Close()
        
        for {
            select {
            case <-ctx.Done():
                return
            case msg := <-subscription.Channel():
                var status model.OnlineStatus
                if err := json.Unmarshal([]byte(msg.Payload), &status); err != nil {
                    continue
                }
                
                select {
                case statusCh <- &status:
                case <-ctx.Done():
                    return
                }
            }
        }
    }()
    
    return statusCh, nil
}
```

### 6.3 PubSubå®ç°

```go
// pubsub/pubsub.go
package pubsub

import (
    "sync"
)

// PubSub å‘å¸ƒè®¢é˜…
type PubSub struct {
    mu            sync.RWMutex
    subscriptions map[string]map[*Subscription]struct{}
}

// Subscription è®¢é˜…
type Subscription struct {
    topic string
    ch    chan interface{}
}

// NewPubSub åˆ›å»ºPubSub
func NewPubSub() *PubSub {
    return &PubSub{
        subscriptions: make(map[string]map[*Subscription]struct{}),
    }
}

// Publish å‘å¸ƒæ¶ˆæ¯
func (ps *PubSub) Publish(topic string, message interface{}) {
    ps.mu.RLock()
    defer ps.mu.RUnlock()
    
    if subs, exists := ps.subscriptions[topic]; exists {
        for sub := range subs {
            select {
            case sub.ch <- message:
            default:
                // Channelæ»¡,è·³è¿‡
            }
        }
    }
}

// Subscribe è®¢é˜…ä¸»é¢˜
func (ps *PubSub) Subscribe(topic string) *Subscription {
    ps.mu.Lock()
    defer ps.mu.Unlock()
    
    sub := &Subscription{
        topic: topic,
        ch:    make(chan interface{}, 10),
    }
    
    if _, exists := ps.subscriptions[topic]; !exists {
        ps.subscriptions[topic] = make(map[*Subscription]struct{})
    }
    ps.subscriptions[topic][sub] = struct{}{}
    
    return sub
}

// Unsubscribe å–æ¶ˆè®¢é˜…
func (sub *Subscription) Unsubscribe() {
    // å®ç°å–æ¶ˆè®¢é˜…é€»è¾‘
}

// Channel è·å–æ¶ˆæ¯Channel
func (sub *Subscription) Channel() <-chan interface{} {
    return sub.ch
}
```

---

## 7. Federationå¾®æœåŠ¡

### 7.1 Apollo Federationæ¦‚è¿°

```go
/*
Apollo Federationæ¶æ„:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Apollo Gateway                      â”‚
â”‚  (ç»Ÿä¸€å…¥å£,æŸ¥è¯¢è§„åˆ’,èšåˆç»“æœ)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚             â”‚             â”‚
    â–¼             â–¼             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User    â”‚  â”‚ Product â”‚  â”‚ Order   â”‚
â”‚ Service â”‚  â”‚ Service â”‚  â”‚ Service â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ¯ä¸ªæœåŠ¡ç®¡ç†è‡ªå·±çš„Schema

User Service:
type User @key(fields: "id") {
  id: ID!
  username: String!
  email: String!
}

Product Service:
extend type User @key(fields: "id") {
  id: ID! @external
  orders: [Order!]!  # æ‰©å±•Userç±»å‹
}

type Product @key(fields: "id") {
  id: ID!
  name: String!
  price: Float!
}

Order Service:
extend type User @key(fields: "id") {
  id: ID! @external
}

extend type Product @key(fields: "id") {
  id: ID! @external
}

type Order @key(fields: "id") {
  id: ID!
  user: User!
  product: Product!
  quantity: Int!
}

å®¢æˆ·ç«¯æŸ¥è¯¢:
query {
  user(id: "123") {     # User Service
    username
    email
    orders {            # Order Service
      id
      product {         # Product Service
        name
        price
      }
    }
  }
}

Gatewayè‡ªåŠ¨åè°ƒå¤šä¸ªæœåŠ¡å®ŒæˆæŸ¥è¯¢
*/
```

### 7.2 Federation Schema

```graphql
# user-service/schema.graphqls
extend type Query {
  user(id: ID!): User
  users: [User!]!
}

type User @key(fields: "id") {
  id: ID!
  username: String!
  email: String!
  avatar: String
}

# product-service/schema.graphqls
extend type Query {
  product(id: ID!): Product
  products: [Product!]!
}

type Product @key(fields: "id") {
  id: ID!
  name: String!
  description: String!
  price: Float!
  stock: Int!
}

# order-service/schema.graphqls
extend type Query {
  order(id: ID!): Order
  orders(userId: ID!): [Order!]!
}

# æ‰©å±•Userç±»å‹
extend type User @key(fields: "id") {
  id: ID! @external
  orders: [Order!]!
}

# æ‰©å±•Productç±»å‹
extend type Product @key(fields: "id") {
  id: ID! @external
}

type Order @key(fields: "id") {
  id: ID!
  user: User!
  items: [OrderItem!]!
  totalAmount: Float!
  status: OrderStatus!
  createdAt: Time!
}

type OrderItem {
  product: Product!
  quantity: Int!
  price: Float!
}

enum OrderStatus {
  PENDING
  PAID
  SHIPPED
  DELIVERED
  CANCELLED
}
```

### 7.3 Entity Resolver

```go
// order-service/graph/entity.go
package graph

import (
    "context"
    "github.com/99designs/gqlgen/graphql"
)

// Entity Resolver (Federation)
func (r *Resolver) Entity(ctx context.Context, rep map[string]interface{}) (interface{}, error) {
    typename := rep["__typename"].(string)
    
    switch typename {
    case "User":
        // è§£æUserå®ä½“
        id := rep["id"].(string)
        return &model.User{ID: id}, nil
        
    case "Product":
        // è§£æProductå®ä½“
        id := rep["id"].(string)
        return &model.Product{ID: id}, nil
        
    default:
        return nil, fmt.Errorf("unknown entity type: %s", typename)
    }
}

// User Field Resolver (æ‰©å±•Userç±»å‹)
func (r *userResolver) Orders(ctx context.Context, obj *model.User) ([]*model.Order, error) {
    // æ ¹æ®UserIDæŸ¥è¯¢è®¢å•
    return r.orderService.GetOrdersByUserID(ctx, obj.ID)
}

// OrderItem Field Resolver
func (r *orderItemResolver) Product(ctx context.Context, obj *model.OrderItem) (*model.Product, error) {
    // è¿”å›Productå¼•ç”¨,Gatewayä¼šè‡ªåŠ¨è§£æ
    return &model.Product{ID: obj.ProductID}, nil
}
```

---

## 8. å®‰å…¨ä¸æœ€ä½³å®è·µ

### 8.1 Queryå¤æ‚åº¦é™åˆ¶

```go
// middleware/complexity.go
package middleware

import (
    "context"
    "github.com/99designs/gqlgen/graphql"
)

// ComplexityLimit å¤æ‚åº¦é™åˆ¶
func ComplexityLimit(limit int) graphql.HandlerExtension {
    return graphql.FixedComplexityLimit(limit)
}

// é…ç½®å¤æ‚åº¦
srv := handler.NewDefaultServer(schema)
srv.Use(ComplexityLimit(1000))

// è‡ªå®šä¹‰å¤æ‚åº¦è®¡ç®—
/*
type Query {
  users: [User!]!     # å¤æ‚åº¦: 1 * N
  user(id: ID!): User # å¤æ‚åº¦: 1
}

type User {
  id: ID!             # å¤æ‚åº¦: 0
  posts: [Post!]!     # å¤æ‚åº¦: 1 * M
}

æŸ¥è¯¢:
query {
  users {            # 100 users
    id
    posts {          # æ¯ä¸ªuser 50 posts
      id
      title
    }
  }
}

æ€»å¤æ‚åº¦: 100 + (100 * 50) = 5100
å¦‚æœé™åˆ¶ä¸º1000,åˆ™æ‹’ç»æ­¤æŸ¥è¯¢
*/
```

### 8.2 æ·±åº¦é™åˆ¶

```go
// middleware/depth.go
package middleware

import (
    "github.com/99designs/gqlgen/graphql/handler/extension"
)

// é™åˆ¶æŸ¥è¯¢æ·±åº¦
srv.Use(extension.FixedComplexityLimit(10))

// é˜²æ­¢æ¶æ„æ·±åº¦æŸ¥è¯¢
/*
query {
  user {
    posts {
      author {
        posts {
          author {
            posts {
              author {
                posts {
                  # æ— é™åµŒå¥—...
                }
              }
            }
          }
        }
      }
    }
  }
}
*/
```

### 8.3 æŸ¥è¯¢ç™½åå•

```go
// middleware/whitelist.go
package middleware

import (
    "crypto/sha256"
    "encoding/hex"
    "fmt"
)

// QueryWhitelist æŸ¥è¯¢ç™½åå•
type QueryWhitelist struct {
    queries map[string]string // hash -> query
}

func NewQueryWhitelist() *QueryWhitelist {
    return &QueryWhitelist{
        queries: make(map[string]string),
    }
}

// RegisterQuery æ³¨å†Œå…è®¸çš„æŸ¥è¯¢
func (w *QueryWhitelist) RegisterQuery(query string) string {
    hash := w.hashQuery(query)
    w.queries[hash] = query
    return hash
}

// ValidateQuery éªŒè¯æŸ¥è¯¢
func (w *QueryWhitelist) ValidateQuery(query string) error {
    hash := w.hashQuery(query)
    if _, exists := w.queries[hash]; !exists {
        return fmt.Errorf("query not in whitelist")
    }
    return nil
}

func (w *QueryWhitelist) hashQuery(query string) string {
    hash := sha256.Sum256([]byte(query))
    return hex.EncodeToString(hash[:])
}

// Middleware
func WhitelistMiddleware(whitelist *QueryWhitelist) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // ä»è¯·æ±‚ä¸­æå–query
            // éªŒè¯æ˜¯å¦åœ¨ç™½åå•ä¸­
            // ...
            next.ServeHTTP(w, r)
        })
    }
}
```

### 8.4 Rate Limiting

```go
// middleware/ratelimit.go
package middleware

import (
    "golang.org/x/time/rate"
    "net/http"
)

// RateLimitMiddleware é™æµä¸­é—´ä»¶
func RateLimitMiddleware(rps int) func(http.Handler) http.Handler {
    limiter := rate.NewLimiter(rate.Limit(rps), rps)
    
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            if !limiter.Allow() {
                http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
                return
            }
            next.ServeHTTP(w, r)
        })
    }
}

// æŒ‰ç”¨æˆ·é™æµ
type UserRateLimiter struct {
    limiters map[string]*rate.Limiter
    mu       sync.RWMutex
}

func (l *UserRateLimiter) GetLimiter(userID string) *rate.Limiter {
    l.mu.Lock()
    defer l.mu.Unlock()
    
    limiter, exists := l.limiters[userID]
    if !exists {
        limiter = rate.NewLimiter(10, 10) // æ¯ç§’10æ¬¡
        l.limiters[userID] = limiter
    }
    
    return limiter
}
```

### 8.5 æœ€ä½³å®è·µæ€»ç»“

```yaml
Schemaè®¾è®¡:
  - ä½¿ç”¨æ¥å£å’Œè”åˆç±»å‹æé«˜å¤ç”¨æ€§
  - åˆç†ä½¿ç”¨æšä¸¾,é¿å…å­—ç¬¦ä¸²
  - åˆ†é¡µä½¿ç”¨Relay Cursoré£æ ¼
  - é”™è¯¯å¤„ç†ä½¿ç”¨Resultç±»å‹
  - Schemaæ‹†åˆ†,æ¨¡å—åŒ–ç®¡ç†

Resolverå®ç°:
  - ä½¿ç”¨DataLoaderé¿å…N+1é—®é¢˜
  - å­—æ®µè§£æä¿æŒè½»é‡çº§
  - å¼‚æ­¥å¤„ç†éå…³é”®ä»»åŠ¡
  - åˆç†ä½¿ç”¨ç¼“å­˜

æ€§èƒ½ä¼˜åŒ–:
  - å¯ç”¨DataLoaderæ‰¹é‡åŠ è½½
  - å®ç°æŸ¥è¯¢å¤æ‚åº¦é™åˆ¶
  - é™åˆ¶æŸ¥è¯¢æ·±åº¦
  - ä½¿ç”¨APQ (Automatic Persisted Queries)
  - ç¼“å­˜å¸¸ç”¨æŸ¥è¯¢

å®‰å…¨:
  - å®ç°è®¤è¯æˆæƒ
  - æŸ¥è¯¢ç™½åå•
  - Rate Limiting
  - è¾“å…¥éªŒè¯
  - é˜²æ­¢DOSæ”»å‡»

ç›‘æ§:
  - è®°å½•æŸ¥è¯¢æ€§èƒ½
  - ç›‘æ§Resolveræ‰§è¡Œæ—¶é—´
  - è¿½è¸ªN+1é—®é¢˜
  - é”™è¯¯æ—¥å¿—
```

**æ­å–œ!** ğŸ‰ æ‚¨å·²æŒæ¡Go 1.25.3 GraphQLç°ä»£APIçš„å®Œæ•´å®æˆ˜æŠ€èƒ½!

---

## ğŸ“š å‚è€ƒèµ„æ–™

- [GraphQLå®˜æ–¹æ–‡æ¡£](https://graphql.org/)
- [gqlgenæ–‡æ¡£](https://gqlgen.com/)
- [Apollo Federation](https://www.apollographql.com/docs/federation/)
- [DataLoader](https://github.com/graphql/dataloader)
- [GraphQL Best Practices](https://graphql.org/learn/best-practices/)
