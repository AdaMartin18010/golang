# Go 1.25.3GraphQL现代API完整实战

> **版本**: Go 1.25.3  
> **难度**: ⭐⭐⭐⭐⭐  
> **标签**: `GraphQL` `gqlgen` `Schema` `Resolver` `DataLoader` `Subscription` `Federation` `Apollo`

## 📋 目录

- [Go 1.25.3GraphQL现代API完整实战](#go-1253graphql现代api完整实战)
  - [📋 目录](#-目录)
  - [1. GraphQL概述](#1-graphql概述)
    - [1.1 GraphQL vs REST](#11-graphql-vs-rest)
    - [1.2 GraphQL工作流程](#12-graphql工作流程)
  - [2. gqlgen快速入门](#2-gqlgen快速入门)
    - [2.1 项目初始化](#21-项目初始化)
    - [2.2 定义Schema](#22-定义schema)
    - [2.3 生成代码](#23-生成代码)
  - [3. Schema设计](#3-schema设计)
    - [3.1 类型设计最佳实践](#31-类型设计最佳实践)
    - [3.2 Schema拆分](#32-schema拆分)
  - [4. Resolver实现](#4-resolver实现)
    - [4.1 Query Resolver](#41-query-resolver)
    - [4.2 Mutation Resolver](#42-mutation-resolver)
    - [4.3 Field Resolver](#43-field-resolver)
  - [5. DataLoader优化](#5-dataloader优化)
    - [5.1 DataLoader实现](#51-dataloader实现)
    - [5.2 DataLoader中间件](#52-dataloader中间件)
    - [5.3 使用DataLoader](#53-使用dataloader)
  - [6. Subscription实时推送](#6-subscription实时推送)
    - [6.1 WebSocket配置](#61-websocket配置)
    - [6.2 Subscription Resolver](#62-subscription-resolver)
    - [6.3 PubSub实现](#63-pubsub实现)
  - [7. Federation微服务](#7-federation微服务)
    - [7.1 Apollo Federation概述](#71-apollo-federation概述)
    - [7.2 Federation Schema](#72-federation-schema)
    - [7.3 Entity Resolver](#73-entity-resolver)
  - [8. 安全与最佳实践](#8-安全与最佳实践)
    - [8.1 Query复杂度限制](#81-query复杂度限制)
    - [8.2 深度限制](#82-深度限制)
    - [8.3 查询白名单](#83-查询白名单)
    - [8.4 Rate Limiting](#84-rate-limiting)
    - [8.5 最佳实践总结](#85-最佳实践总结)
  - [📚 参考资料](#-参考资料)

---

## 1. GraphQL概述

### 1.1 GraphQL vs REST

```go
// GraphQL vs REST对比
/*
REST API:
客户端需要多次请求

GET /users/123              // 获取用户基本信息
GET /users/123/posts        // 获取用户文章
GET /users/123/followers    // 获取粉丝列表
GET /posts/456/comments     // 获取文章评论

问题:
1. Over-fetching: 返回多余字段
2. Under-fetching: 需要多次请求
3. 接口固定,不灵活
4. 版本管理困难

GraphQL API:
一次请求获取所有数据

query {
  user(id: "123") {
    id
    name
    email
    posts {
      id
      title
      comments {
        id
        content
        author {
          name
        }
      }
    }
    followers {
      id
      name
    }
  }
}

优势:
1. 按需查询,不多不少
2. 一次请求获取所有数据
3. 强类型系统
4. 自文档化
5. 无需版本管理
*/

// GraphQL核心概念
type GraphQLConcepts struct {
    // 1. Schema: 定义API结构
    Schema string // type Query { user(id: ID!): User }
    
    // 2. Query: 查询数据 (类似GET)
    Query string // query { user(id: "123") { name } }
    
    // 3. Mutation: 修改数据 (类似POST/PUT/DELETE)
    Mutation string // mutation { createUser(input: ...) { id } }
    
    // 4. Subscription: 实时推送 (WebSocket)
    Subscription string // subscription { messageAdded { content } }
    
    // 5. Resolver: 数据获取逻辑
    Resolver string // func (r *queryResolver) User(id string) (*User, error)
    
    // 6. DataLoader: 批量加载,解决N+1问题
    DataLoader string // loader.LoadMany(ids)
}
```

### 1.2 GraphQL工作流程

```go
/*
GraphQL请求处理流程:

1. 客户端发送Query
   ↓
2. GraphQL解析Query
   ↓
3. 验证Schema
   ↓
4. 执行Resolver
   ├─ 并行执行独立字段
   └─ 嵌套字段递归执行
   ↓
5. 组装结果
   ↓
6. 返回JSON

示例:
query {
  user(id: "123") {      // Resolver: UserResolver
    name                 // 直接字段
    posts {              // Resolver: PostsResolver (可能N+1)
      title
      author {           // Resolver: AuthorResolver
        name
      }
    }
  }
}

Resolver执行顺序:
1. UserResolver(id: "123")
2. PostsResolver(user: User) -> [Post1, Post2, Post3]
3. 并行执行:
   - AuthorResolver(post: Post1)
   - AuthorResolver(post: Post2)
   - AuthorResolver(post: Post3)
*/
```

---

## 2. gqlgen快速入门

### 2.1 项目初始化

```bash
# 创建项目
mkdir graphql-server && cd graphql-server
go mod init github.com/yourorg/graphql-server

# 安装gqlgen
go get github.com/99designs/gqlgen

# 初始化gqlgen
go run github.com/99designs/gqlgen init

# 项目结构
# ├── graph/
# │   ├── schema.graphqls      # GraphQL Schema
# │   ├── generated/            # 自动生成的代码
# │   │   └── generated.go
# │   ├── model/                # 模型定义
# │   │   └── models_gen.go
# │   └── resolver.go           # Resolver实现
# ├── server.go                 # 服务器入口
# ├── go.mod
# └── gqlgen.yml                # 配置文件
```

### 2.2 定义Schema

```graphql
# graph/schema.graphqls

# 查询
type Query {
  # 获取用户
  user(id: ID!): User
  # 获取所有用户
  users(limit: Int, offset: Int): [User!]!
  # 搜索用户
  searchUsers(keyword: String!): [User!]!
  
  # 获取文章
  post(id: ID!): Post
  # 获取所有文章
  posts(limit: Int, offset: Int): [Post!]!
}

# 变更
type Mutation {
  # 创建用户
  createUser(input: CreateUserInput!): User!
  # 更新用户
  updateUser(id: ID!, input: UpdateUserInput!): User!
  # 删除用户
  deleteUser(id: ID!): Boolean!
  
  # 创建文章
  createPost(input: CreatePostInput!): Post!
  # 点赞文章
  likePost(postId: ID!): Post!
}

# 订阅
type Subscription {
  # 新文章通知
  postAdded: Post!
  # 评论通知
  commentAdded(postId: ID!): Comment!
}

# 用户类型
type User {
  id: ID!
  username: String!
  email: String!
  avatar: String
  bio: String
  createdAt: Time!
  
  # 关联数据
  posts: [Post!]!
  followers: [User!]!
  following: [User!]!
  followerCount: Int!
  followingCount: Int!
}

# 文章类型
type Post {
  id: ID!
  title: String!
  content: String!
  author: User!
  tags: [String!]!
  likes: Int!
  createdAt: Time!
  updatedAt: Time!
  
  # 关联数据
  comments: [Comment!]!
  commentCount: Int!
}

# 评论类型
type Comment {
  id: ID!
  content: String!
  author: User!
  post: Post!
  createdAt: Time!
}

# 输入类型
input CreateUserInput {
  username: String!
  email: String!
  password: String!
  avatar: String
  bio: String
}

input UpdateUserInput {
  username: String
  email: String
  avatar: String
  bio: String
}

input CreatePostInput {
  title: String!
  content: String!
  tags: [String!]
}

# 自定义标量
scalar Time
```

### 2.3 生成代码

```bash
# 生成Resolver骨架和模型
go run github.com/99designs/gqlgen generate

# 生成的文件:
# - graph/generated/generated.go  (GraphQL执行引擎)
# - graph/model/models_gen.go     (Go模型)
# - graph/resolver.go             (Resolver实现)
```

---

## 3. Schema设计

### 3.1 类型设计最佳实践

```graphql
# schema/best_practices.graphqls

# ===== 1. 使用接口 =====
interface Node {
  id: ID!
}

interface Timestamped {
  createdAt: Time!
  updatedAt: Time!
}

type User implements Node & Timestamped {
  id: ID!
  username: String!
  createdAt: Time!
  updatedAt: Time!
}

type Post implements Node & Timestamped {
  id: ID!
  title: String!
  createdAt: Time!
  updatedAt: Time!
}

# ===== 2. 使用联合类型 =====
union SearchResult = User | Post | Comment

type Query {
  search(keyword: String!): [SearchResult!]!
}

# ===== 3. 使用枚举 =====
enum PostStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum UserRole {
  USER
  ADMIN
  MODERATOR
}

type Post {
  id: ID!
  title: String!
  status: PostStatus!
}

# ===== 4. 分页 =====
# Relay风格 (Cursor-based)
type PostConnection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PostEdge {
  node: Post!
  cursor: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  posts(
    first: Int
    after: String
    last: Int
    before: String
  ): PostConnection!
}

# ===== 5. 错误处理 =====
type Result {
  success: Boolean!
  message: String
  data: User
  errors: [Error!]
}

type Error {
  field: String
  message: String!
  code: String!
}

type Mutation {
  createUser(input: CreateUserInput!): Result!
}

# ===== 6. 字段参数 =====
type Query {
  users(
    # 分页
    limit: Int = 10
    offset: Int = 0
    
    # 排序
    orderBy: OrderBy
    sortOrder: SortOrder = ASC
    
    # 过滤
    filter: UserFilter
  ): [User!]!
}

enum OrderBy {
  CREATED_AT
  UPDATED_AT
  USERNAME
}

enum SortOrder {
  ASC
  DESC
}

input UserFilter {
  username: String
  email: String
  role: UserRole
  createdAfter: Time
  createdBefore: Time
}
```

### 3.2 Schema拆分

```go
// schema/schema.go
package schema

import (
    "os"
    "path/filepath"
)

// LoadSchema 加载多个Schema文件
func LoadSchema() (string, error) {
    schemaFiles := []string{
        "schema/user.graphqls",
        "schema/post.graphqls",
        "schema/comment.graphqls",
        "schema/common.graphqls",
    }
    
    var schema string
    for _, file := range schemaFiles {
        data, err := os.ReadFile(file)
        if err != nil {
            return "", err
        }
        schema += string(data) + "\n"
    }
    
    return schema, nil
}
```

```graphql
# schema/user.graphqls
extend type Query {
  user(id: ID!): User
  users: [User!]!
}

extend type Mutation {
  createUser(input: CreateUserInput!): User!
}

type User implements Node {
  id: ID!
  username: String!
  email: String!
}

# schema/post.graphqls
extend type Query {
  post(id: ID!): Post
  posts: [Post!]!
}

extend type Mutation {
  createPost(input: CreatePostInput!): Post!
}

type Post implements Node {
  id: ID!
  title: String!
  author: User!
}

# schema/common.graphqls
interface Node {
  id: ID!
}

scalar Time
```

---

## 4. Resolver实现

### 4.1 Query Resolver

```go
// graph/resolver.go
package graph

import (
    "context"
    "github.com/yourorg/graphql-server/graph/model"
)

// Resolver 根Resolver
type Resolver struct {
    userService UserService
    postService PostService
}

// Query Resolver
func (r *Resolver) Query() QueryResolver {
    return &queryResolver{r}
}

type queryResolver struct{ *Resolver }

// User 获取单个用户
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
    return r.userService.GetUserByID(ctx, id)
}

// Users 获取用户列表
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int) ([]*model.User, error) {
    l := 10
    if limit != nil {
        l = *limit
    }
    
    o := 0
    if offset != nil {
        o = *offset
    }
    
    return r.userService.ListUsers(ctx, l, o)
}

// SearchUsers 搜索用户
func (r *queryResolver) SearchUsers(ctx context.Context, keyword string) ([]*model.User, error) {
    return r.userService.SearchUsers(ctx, keyword)
}

// Post 获取单个文章
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
    return r.postService.GetPostByID(ctx, id)
}

// Posts 获取文章列表
func (r *queryResolver) Posts(ctx context.Context, limit *int, offset *int) ([]*model.Post, error) {
    l := 10
    if limit != nil {
        l = *limit
    }
    
    o := 0
    if offset != nil {
        o = *offset
    }
    
    return r.postService.ListPosts(ctx, l, o)
}
```

### 4.2 Mutation Resolver

```go
// graph/mutation.go
package graph

import (
    "context"
    "github.com/yourorg/graphql-server/graph/model"
)

// Mutation Resolver
func (r *Resolver) Mutation() MutationResolver {
    return &mutationResolver{r}
}

type mutationResolver struct{ *Resolver }

// CreateUser 创建用户
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.User, error) {
    // 1. 验证输入
    if err := validateCreateUserInput(input); err != nil {
        return nil, err
    }
    
    // 2. 创建用户
    user, err := r.userService.CreateUser(ctx, input)
    if err != nil {
        return nil, err
    }
    
    // 3. 发送欢迎邮件 (异步)
    go r.userService.SendWelcomeEmail(ctx, user.Email)
    
    return user, nil
}

// UpdateUser 更新用户
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.UpdateUserInput) (*model.User, error) {
    // 1. 权限检查
    currentUser := getCurrentUser(ctx)
    if currentUser.ID != id && currentUser.Role != "ADMIN" {
        return nil, fmt.Errorf("permission denied")
    }
    
    // 2. 更新用户
    return r.userService.UpdateUser(ctx, id, input)
}

// DeleteUser 删除用户
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
    // 1. 权限检查
    currentUser := getCurrentUser(ctx)
    if currentUser.Role != "ADMIN" {
        return false, fmt.Errorf("permission denied")
    }
    
    // 2. 删除用户
    if err := r.userService.DeleteUser(ctx, id); err != nil {
        return false, err
    }
    
    return true, nil
}

// CreatePost 创建文章
func (r *mutationResolver) CreatePost(ctx context.Context, input model.CreatePostInput) (*model.Post, error) {
    currentUser := getCurrentUser(ctx)
    
    post, err := r.postService.CreatePost(ctx, currentUser.ID, input)
    if err != nil {
        return nil, err
    }
    
    // 触发事件: 新文章发布
    r.pubsub.Publish("post_added", post)
    
    return post, nil
}

// LikePost 点赞文章
func (r *mutationResolver) LikePost(ctx context.Context, postID string) (*model.Post, error) {
    currentUser := getCurrentUser(ctx)
    
    return r.postService.LikePost(ctx, postID, currentUser.ID)
}
```

### 4.3 Field Resolver

```go
// graph/user.go
package graph

import (
    "context"
    "github.com/yourorg/graphql-server/graph/model"
)

// User Field Resolver
func (r *Resolver) User() UserResolver {
    return &userResolver{r}
}

type userResolver struct{ *Resolver }

// Posts 获取用户的文章
func (r *userResolver) Posts(ctx context.Context, obj *model.User) ([]*model.Post, error) {
    // 通过DataLoader批量加载 (避免N+1问题)
    return r.postService.GetPostsByUserID(ctx, obj.ID)
}

// Followers 获取粉丝列表
func (r *userResolver) Followers(ctx context.Context, obj *model.User) ([]*model.User, error) {
    return r.userService.GetFollowers(ctx, obj.ID)
}

// Following 获取关注列表
func (r *userResolver) Following(ctx context.Context, obj *model.User) ([]*model.User, error) {
    return r.userService.GetFollowing(ctx, obj.ID)
}

// FollowerCount 粉丝数量
func (r *userResolver) FollowerCount(ctx context.Context, obj *model.User) (int, error) {
    return r.userService.GetFollowerCount(ctx, obj.ID)
}

// FollowingCount 关注数量
func (r *userResolver) FollowingCount(ctx context.Context, obj *model.User) (int, error) {
    return r.userService.GetFollowingCount(ctx, obj.ID)
}

// Post Field Resolver
func (r *Resolver) Post() PostResolver {
    return &postResolver{r}
}

type postResolver struct{ *Resolver }

// Author 获取文章作者
func (r *postResolver) Author(ctx context.Context, obj *model.Post) (*model.User, error) {
    // 使用DataLoader
    loader := getDataLoader(ctx)
    return loader.UserLoader.Load(obj.AuthorID)
}

// Comments 获取文章评论
func (r *postResolver) Comments(ctx context.Context, obj *model.Post) ([]*model.Comment, error) {
    return r.commentService.GetCommentsByPostID(ctx, obj.ID)
}

// CommentCount 评论数量
func (r *postResolver) CommentCount(ctx context.Context, obj *model.Post) (int, error) {
    return r.commentService.GetCommentCount(ctx, obj.ID)
}
```

---

## 5. DataLoader优化

### 5.1 DataLoader实现

```go
// dataloader/user_loader.go
package dataloader

import (
    "context"
    "github.com/graph-gophers/dataloader"
    "github.com/yourorg/graphql-server/graph/model"
)

// UserLoader 用户DataLoader
type UserLoader struct {
    loader *dataloader.Loader
}

// NewUserLoader 创建UserLoader
func NewUserLoader(userService UserService) *UserLoader {
    batchFn := func(ctx context.Context, keys dataloader.Keys) []*dataloader.Result {
        // 批量加载用户
        userIDs := make([]string, len(keys))
        for i, key := range keys {
            userIDs[i] = key.String()
        }
        
        users, err := userService.GetUsersByIDs(ctx, userIDs)
        if err != nil {
            results := make([]*dataloader.Result, len(keys))
            for i := range results {
                results[i] = &dataloader.Result{Error: err}
            }
            return results
        }
        
        // 构建结果映射
        userMap := make(map[string]*model.User)
        for _, user := range users {
            userMap[user.ID] = user
        }
        
        // 按keys顺序返回结果
        results := make([]*dataloader.Result, len(keys))
        for i, key := range keys {
            user, exists := userMap[key.String()]
            if exists {
                results[i] = &dataloader.Result{Data: user}
            } else {
                results[i] = &dataloader.Result{Error: fmt.Errorf("user not found: %s", key.String())}
            }
        }
        
        return results
    }
    
    loader := dataloader.NewBatchedLoader(batchFn, dataloader.WithBatchCapacity(100))
    
    return &UserLoader{loader: loader}
}

// Load 加载单个用户
func (l *UserLoader) Load(id string) (*model.User, error) {
    thunk := l.loader.Load(context.Background(), dataloader.StringKey(id))
    result, err := thunk()
    if err != nil {
        return nil, err
    }
    return result.(*model.User), nil
}

// LoadMany 批量加载用户
func (l *UserLoader) LoadMany(ids []string) ([]*model.User, []error) {
    keys := make(dataloader.Keys, len(ids))
    for i, id := range ids {
        keys[i] = dataloader.StringKey(id)
    }
    
    thunk := l.loader.LoadMany(context.Background(), keys)
    results, errs := thunk()
    
    users := make([]*model.User, len(results))
    for i, result := range results {
        if result != nil {
            users[i] = result.(*model.User)
        }
    }
    
    return users, errs
}
```

### 5.2 DataLoader中间件

```go
// middleware/dataloader.go
package middleware

import (
    "context"
    "net/http"
    "github.com/yourorg/graphql-server/dataloader"
)

// DataLoader Context Key
type contextKey string

const dataLoaderKey contextKey = "dataloader"

// DataLoaderMiddleware DataLoader中间件
func DataLoaderMiddleware(userService UserService, postService PostService) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // 为每个请求创建新的DataLoader
            loaders := &Loaders{
                UserLoader: dataloader.NewUserLoader(userService),
                PostLoader: dataloader.NewPostLoader(postService),
            }
            
            ctx := context.WithValue(r.Context(), dataLoaderKey, loaders)
            next.ServeHTTP(w, r.WithContext(ctx))
        })
    }
}

// Loaders 所有DataLoader
type Loaders struct {
    UserLoader *dataloader.UserLoader
    PostLoader *dataloader.PostLoader
}

// GetLoaders 从Context获取DataLoader
func GetLoaders(ctx context.Context) *Loaders {
    return ctx.Value(dataLoaderKey).(*Loaders)
}
```

### 5.3 使用DataLoader

```go
// graph/post.go
package graph

import (
    "context"
    "github.com/yourorg/graphql-server/middleware"
)

// Author 使用DataLoader获取作者
func (r *postResolver) Author(ctx context.Context, obj *model.Post) (*model.User, error) {
    loaders := middleware.GetLoaders(ctx)
    return loaders.UserLoader.Load(obj.AuthorID)
}

// 性能对比
/*
不使用DataLoader (N+1问题):
Query获取10个Post,每个Post需要获取Author

SELECT * FROM posts LIMIT 10;             // 1次查询
SELECT * FROM users WHERE id = 1;         // 10次查询
SELECT * FROM users WHERE id = 2;
SELECT * FROM users WHERE id = 3;
...
总计: 11次查询

使用DataLoader:
SELECT * FROM posts LIMIT 10;             // 1次查询
SELECT * FROM users WHERE id IN (1,2,3,...); // 1次批量查询
总计: 2次查询

性能提升: 5-10倍
*/
```

---

## 6. Subscription实时推送

### 6.1 WebSocket配置

```go
// server.go
package main

import (
    "net/http"
    "github.com/99designs/gqlgen/graphql/handler"
    "github.com/99designs/gqlgen/graphql/handler/transport"
    "github.com/gorilla/websocket"
)

func main() {
    // 创建GraphQL Handler
    srv := handler.NewDefaultServer(generated.NewExecutableSchema(generated.Config{
        Resolvers: &graph.Resolver{},
    }))
    
    // 添加WebSocket传输
    srv.AddTransport(&transport.Websocket{
        Upgrader: websocket.Upgrader{
            CheckOrigin: func(r *http.Request) bool {
                return true // 生产环境需要严格检查
            },
        },
        KeepAlivePingInterval: 10 * time.Second,
    })
    
    http.Handle("/graphql", srv)
    http.ListenAndServe(":8080", nil)
}
```

### 6.2 Subscription Resolver

```graphql
# schema.graphqls
type Subscription {
  # 新文章通知
  postAdded: Post!
  
  # 评论通知
  commentAdded(postId: ID!): Comment!
  
  # 用户在线状态
  userOnlineStatus(userId: ID!): OnlineStatus!
}

type OnlineStatus {
  userId: ID!
  isOnline: Boolean!
  lastSeen: Time!
}
```

```go
// graph/subscription.go
package graph

import (
    "context"
    "time"
)

// Subscription Resolver
func (r *Resolver) Subscription() SubscriptionResolver {
    return &subscriptionResolver{r}
}

type subscriptionResolver struct{ *Resolver }

// PostAdded 新文章订阅
func (r *subscriptionResolver) PostAdded(ctx context.Context) (<-chan *model.Post, error) {
    // 创建Channel
    posts := make(chan *model.Post, 1)
    
    // 订阅事件
    subscription := r.pubsub.Subscribe("post_added")
    
    // 启动监听
    go func() {
        defer close(posts)
        defer subscription.Unsubscribe()
        
        for {
            select {
            case <-ctx.Done():
                return
            case msg := <-subscription.Channel():
                post := msg.(*model.Post)
                select {
                case posts <- post:
                case <-ctx.Done():
                    return
                }
            }
        }
    }()
    
    return posts, nil
}

// CommentAdded 评论订阅
func (r *subscriptionResolver) CommentAdded(ctx context.Context, postID string) (<-chan *model.Comment, error) {
    comments := make(chan *model.Comment, 1)
    
    subscription := r.pubsub.Subscribe(fmt.Sprintf("comment_added:%s", postID))
    
    go func() {
        defer close(comments)
        defer subscription.Unsubscribe()
        
        for {
            select {
            case <-ctx.Done():
                return
            case msg := <-subscription.Channel():
                comment := msg.(*model.Comment)
                select {
                case comments <- comment:
                case <-ctx.Done():
                    return
                }
            }
        }
    }()
    
    return comments, nil
}

// UserOnlineStatus 用户在线状态
func (r *subscriptionResolver) UserOnlineStatus(ctx context.Context, userID string) (<-chan *model.OnlineStatus, error) {
    statusCh := make(chan *model.OnlineStatus, 1)
    
    // 订阅Redis Pub/Sub
    subscription := r.redis.Subscribe(ctx, fmt.Sprintf("user:status:%s", userID))
    
    go func() {
        defer close(statusCh)
        defer subscription.Close()
        
        for {
            select {
            case <-ctx.Done():
                return
            case msg := <-subscription.Channel():
                var status model.OnlineStatus
                if err := json.Unmarshal([]byte(msg.Payload), &status); err != nil {
                    continue
                }
                
                select {
                case statusCh <- &status:
                case <-ctx.Done():
                    return
                }
            }
        }
    }()
    
    return statusCh, nil
}
```

### 6.3 PubSub实现

```go
// pubsub/pubsub.go
package pubsub

import (
    "sync"
)

// PubSub 发布订阅
type PubSub struct {
    mu            sync.RWMutex
    subscriptions map[string]map[*Subscription]struct{}
}

// Subscription 订阅
type Subscription struct {
    topic string
    ch    chan interface{}
}

// NewPubSub 创建PubSub
func NewPubSub() *PubSub {
    return &PubSub{
        subscriptions: make(map[string]map[*Subscription]struct{}),
    }
}

// Publish 发布消息
func (ps *PubSub) Publish(topic string, message interface{}) {
    ps.mu.RLock()
    defer ps.mu.RUnlock()
    
    if subs, exists := ps.subscriptions[topic]; exists {
        for sub := range subs {
            select {
            case sub.ch <- message:
            default:
                // Channel满,跳过
            }
        }
    }
}

// Subscribe 订阅主题
func (ps *PubSub) Subscribe(topic string) *Subscription {
    ps.mu.Lock()
    defer ps.mu.Unlock()
    
    sub := &Subscription{
        topic: topic,
        ch:    make(chan interface{}, 10),
    }
    
    if _, exists := ps.subscriptions[topic]; !exists {
        ps.subscriptions[topic] = make(map[*Subscription]struct{})
    }
    ps.subscriptions[topic][sub] = struct{}{}
    
    return sub
}

// Unsubscribe 取消订阅
func (sub *Subscription) Unsubscribe() {
    // 实现取消订阅逻辑
}

// Channel 获取消息Channel
func (sub *Subscription) Channel() <-chan interface{} {
    return sub.ch
}
```

---

## 7. Federation微服务

### 7.1 Apollo Federation概述

```go
/*
Apollo Federation架构:

┌─────────────────────────────────────────────────┐
│              Apollo Gateway                      │
│  (统一入口,查询规划,聚合结果)                     │
└─────────────────┬───────────────────────────────┘
                  │
    ┌─────────────┼─────────────┐
    │             │             │
    ▼             ▼             ▼
┌─────────┐  ┌─────────┐  ┌─────────┐
│ User    │  │ Product │  │ Order   │
│ Service │  │ Service │  │ Service │
└─────────┘  └─────────┘  └─────────┘

每个服务管理自己的Schema

User Service:
type User @key(fields: "id") {
  id: ID!
  username: String!
  email: String!
}

Product Service:
extend type User @key(fields: "id") {
  id: ID! @external
  orders: [Order!]!  # 扩展User类型
}

type Product @key(fields: "id") {
  id: ID!
  name: String!
  price: Float!
}

Order Service:
extend type User @key(fields: "id") {
  id: ID! @external
}

extend type Product @key(fields: "id") {
  id: ID! @external
}

type Order @key(fields: "id") {
  id: ID!
  user: User!
  product: Product!
  quantity: Int!
}

客户端查询:
query {
  user(id: "123") {     # User Service
    username
    email
    orders {            # Order Service
      id
      product {         # Product Service
        name
        price
      }
    }
  }
}

Gateway自动协调多个服务完成查询
*/
```

### 7.2 Federation Schema

```graphql
# user-service/schema.graphqls
extend type Query {
  user(id: ID!): User
  users: [User!]!
}

type User @key(fields: "id") {
  id: ID!
  username: String!
  email: String!
  avatar: String
}

# product-service/schema.graphqls
extend type Query {
  product(id: ID!): Product
  products: [Product!]!
}

type Product @key(fields: "id") {
  id: ID!
  name: String!
  description: String!
  price: Float!
  stock: Int!
}

# order-service/schema.graphqls
extend type Query {
  order(id: ID!): Order
  orders(userId: ID!): [Order!]!
}

# 扩展User类型
extend type User @key(fields: "id") {
  id: ID! @external
  orders: [Order!]!
}

# 扩展Product类型
extend type Product @key(fields: "id") {
  id: ID! @external
}

type Order @key(fields: "id") {
  id: ID!
  user: User!
  items: [OrderItem!]!
  totalAmount: Float!
  status: OrderStatus!
  createdAt: Time!
}

type OrderItem {
  product: Product!
  quantity: Int!
  price: Float!
}

enum OrderStatus {
  PENDING
  PAID
  SHIPPED
  DELIVERED
  CANCELLED
}
```

### 7.3 Entity Resolver

```go
// order-service/graph/entity.go
package graph

import (
    "context"
    "github.com/99designs/gqlgen/graphql"
)

// Entity Resolver (Federation)
func (r *Resolver) Entity(ctx context.Context, rep map[string]interface{}) (interface{}, error) {
    typename := rep["__typename"].(string)
    
    switch typename {
    case "User":
        // 解析User实体
        id := rep["id"].(string)
        return &model.User{ID: id}, nil
        
    case "Product":
        // 解析Product实体
        id := rep["id"].(string)
        return &model.Product{ID: id}, nil
        
    default:
        return nil, fmt.Errorf("unknown entity type: %s", typename)
    }
}

// User Field Resolver (扩展User类型)
func (r *userResolver) Orders(ctx context.Context, obj *model.User) ([]*model.Order, error) {
    // 根据UserID查询订单
    return r.orderService.GetOrdersByUserID(ctx, obj.ID)
}

// OrderItem Field Resolver
func (r *orderItemResolver) Product(ctx context.Context, obj *model.OrderItem) (*model.Product, error) {
    // 返回Product引用,Gateway会自动解析
    return &model.Product{ID: obj.ProductID}, nil
}
```

---

## 8. 安全与最佳实践

### 8.1 Query复杂度限制

```go
// middleware/complexity.go
package middleware

import (
    "context"
    "github.com/99designs/gqlgen/graphql"
)

// ComplexityLimit 复杂度限制
func ComplexityLimit(limit int) graphql.HandlerExtension {
    return graphql.FixedComplexityLimit(limit)
}

// 配置复杂度
srv := handler.NewDefaultServer(schema)
srv.Use(ComplexityLimit(1000))

// 自定义复杂度计算
/*
type Query {
  users: [User!]!     # 复杂度: 1 * N
  user(id: ID!): User # 复杂度: 1
}

type User {
  id: ID!             # 复杂度: 0
  posts: [Post!]!     # 复杂度: 1 * M
}

查询:
query {
  users {            # 100 users
    id
    posts {          # 每个user 50 posts
      id
      title
    }
  }
}

总复杂度: 100 + (100 * 50) = 5100
如果限制为1000,则拒绝此查询
*/
```

### 8.2 深度限制

```go
// middleware/depth.go
package middleware

import (
    "github.com/99designs/gqlgen/graphql/handler/extension"
)

// 限制查询深度
srv.Use(extension.FixedComplexityLimit(10))

// 防止恶意深度查询
/*
query {
  user {
    posts {
      author {
        posts {
          author {
            posts {
              author {
                posts {
                  # 无限嵌套...
                }
              }
            }
          }
        }
      }
    }
  }
}
*/
```

### 8.3 查询白名单

```go
// middleware/whitelist.go
package middleware

import (
    "crypto/sha256"
    "encoding/hex"
    "fmt"
)

// QueryWhitelist 查询白名单
type QueryWhitelist struct {
    queries map[string]string // hash -> query
}

func NewQueryWhitelist() *QueryWhitelist {
    return &QueryWhitelist{
        queries: make(map[string]string),
    }
}

// RegisterQuery 注册允许的查询
func (w *QueryWhitelist) RegisterQuery(query string) string {
    hash := w.hashQuery(query)
    w.queries[hash] = query
    return hash
}

// ValidateQuery 验证查询
func (w *QueryWhitelist) ValidateQuery(query string) error {
    hash := w.hashQuery(query)
    if _, exists := w.queries[hash]; !exists {
        return fmt.Errorf("query not in whitelist")
    }
    return nil
}

func (w *QueryWhitelist) hashQuery(query string) string {
    hash := sha256.Sum256([]byte(query))
    return hex.EncodeToString(hash[:])
}

// Middleware
func WhitelistMiddleware(whitelist *QueryWhitelist) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // 从请求中提取query
            // 验证是否在白名单中
            // ...
            next.ServeHTTP(w, r)
        })
    }
}
```

### 8.4 Rate Limiting

```go
// middleware/ratelimit.go
package middleware

import (
    "golang.org/x/time/rate"
    "net/http"
)

// RateLimitMiddleware 限流中间件
func RateLimitMiddleware(rps int) func(http.Handler) http.Handler {
    limiter := rate.NewLimiter(rate.Limit(rps), rps)
    
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            if !limiter.Allow() {
                http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
                return
            }
            next.ServeHTTP(w, r)
        })
    }
}

// 按用户限流
type UserRateLimiter struct {
    limiters map[string]*rate.Limiter
    mu       sync.RWMutex
}

func (l *UserRateLimiter) GetLimiter(userID string) *rate.Limiter {
    l.mu.Lock()
    defer l.mu.Unlock()
    
    limiter, exists := l.limiters[userID]
    if !exists {
        limiter = rate.NewLimiter(10, 10) // 每秒10次
        l.limiters[userID] = limiter
    }
    
    return limiter
}
```

### 8.5 最佳实践总结

```yaml
Schema设计:
  - 使用接口和联合类型提高复用性
  - 合理使用枚举,避免字符串
  - 分页使用Relay Cursor风格
  - 错误处理使用Result类型
  - Schema拆分,模块化管理

Resolver实现:
  - 使用DataLoader避免N+1问题
  - 字段解析保持轻量级
  - 异步处理非关键任务
  - 合理使用缓存

性能优化:
  - 启用DataLoader批量加载
  - 实现查询复杂度限制
  - 限制查询深度
  - 使用APQ (Automatic Persisted Queries)
  - 缓存常用查询

安全:
  - 实现认证授权
  - 查询白名单
  - Rate Limiting
  - 输入验证
  - 防止DOS攻击

监控:
  - 记录查询性能
  - 监控Resolver执行时间
  - 追踪N+1问题
  - 错误日志
```

**恭喜!** 🎉 您已掌握Go 1.25.3 GraphQL现代API的完整实战技能!

---

## 📚 参考资料

- [GraphQL官方文档](https://graphql.org/)
- [gqlgen文档](https://gqlgen.com/)
- [Apollo Federation](https://www.apollographql.com/docs/federation/)
- [DataLoader](https://github.com/graphql/dataloader)
- [GraphQL Best Practices](https://graphql.org/learn/best-practices/)
