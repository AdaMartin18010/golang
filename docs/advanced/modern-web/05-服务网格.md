# æœåŠ¡ç½‘æ ¼

**éš¾åº¦**: é«˜çº§ | **é¢„è®¡é˜…è¯»**: 15åˆ†é’Ÿ

---

## ğŸ“‹ ç›®å½•


- [1. ğŸ“– Istioé›†æˆ](#1--istioé›†æˆ)
- [ğŸ”€ æµé‡ç®¡ç†](#-æµé‡ç®¡ç†)
- [ğŸ” mTLS](#-mtls)
- [ğŸ“Š å¯è§‚æµ‹æ€§](#-å¯è§‚æµ‹æ€§)
- [ğŸ“š ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

## 1. ğŸ“– Istioé›†æˆ

```yaml
# virtualservice.yaml
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: myservice
spec:
  hosts:
  - myservice
  http:
  - match:
    - headers:
        version:
          exact: v2
    route:
    - destination:
        host: myservice
        subset: v2
  - route:
    - destination:
        host: myservice
        subset: v1
```

```go
// GoæœåŠ¡é›†æˆIstio
func main() {
    // å¥åº·æ£€æŸ¥ç«¯ç‚¹
    http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
    })
    
    // å°±ç»ªæ£€æŸ¥
    http.HandleFunc("/ready", func(w http.ResponseWriter, r *http.Request) {
        if isReady() {
            w.WriteHeader(http.StatusOK)
        } else {
            w.WriteHeader(http.StatusServiceUnavailable)
        }
    })
    
    // ä¸šåŠ¡é€»è¾‘
    http.HandleFunc("/api/users", handleUsers)
    
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

---

## ğŸ”€ æµé‡ç®¡ç†

```go
// A/Bæµ‹è¯•é…ç½®
type TrafficSplit struct {
    VersionA float64
    VersionB float64
}

func routeTraffic(split TrafficSplit) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        random := rand.Float64()
        
        var version string
        if random < split.VersionA {
            version = "v1"
        } else {
            version = "v2"
        }
        
        r.Header.Set("X-Version", version)
        // ç»§ç»­å¤„ç†...
    })
}
```

---

## ğŸ” mTLS

```yaml
# peerauthentication.yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
spec:
  mtls:
    mode: STRICT
```

---

## ğŸ“Š å¯è§‚æµ‹æ€§

```go
import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    requestDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "http_request_duration_seconds",
            Help: "HTTP request duration",
        },
        []string{"method", "path", "status"},
    )
)

func metricsMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        recorder := &responseRecorder{ResponseWriter: w}
        next.ServeHTTP(recorder, r)
        
        duration := time.Since(start).Seconds()
        requestDuration.WithLabelValues(
            r.Method,
            r.URL.Path,
            strconv.Itoa(recorder.statusCode),
        ).Observe(duration)
    })
}
```

---

## ğŸ“š ç›¸å…³èµ„æº

- [Istio](https://istio.io/)
- [Linkerd](https://linkerd.io/)

**ä¸‹ä¸€æ­¥**: [06-äº‘åŸç”Ÿå®è·µ](./06-äº‘åŸç”Ÿå®è·µ.md)

---

**æœ€åæ›´æ–°**: 2025-10-28

