# 微服务网关

**版本**: v1.0
**更新日期**: 2025-10-29
**适用于**: Go 1.25.3

---

## 📋 目录

- [微服务网关](#微服务网关)
  - [📋 目录](#-目录)
  - [1. 📖 API Gateway](#1--api-gateway)
  - [🔐 认证中间件](#-认证中间件)
  - [⚡ 限流](#-限流)
  - [🔄 熔断器](#-熔断器)
  - [📊 监控与日志](#-监控与日志)
  - [📚 相关资源](#-相关资源)

## 1. 📖 API Gateway

```go
package gateway

import (
    "net/http"
    "net/http/httputil"
    "net/url"
)

type Gateway struct {
    routes map[string]*Route
}

type Route struct {
    Path    string
    Target  *url.URL
    Proxy   *httputil.ReverseProxy
    Methods []string
}

func NewGateway() *Gateway {
    return &Gateway{
        routes: make(map[string]*Route),
    }
}

func (g *Gateway) AddRoute(path string, target string, methods []string) error {
    targetURL, err := url.Parse(target)
    if err != nil {
        return err
    }

    proxy := httputil.NewSingleHostReverseProxy(targetURL)

    g.routes[path] = &Route{
        Path:    path,
        Target:  targetURL,
        Proxy:   proxy,
        Methods: methods,
    }

    return nil
}

func (g *Gateway) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    for _, route := range g.routes {
        if strings.HasPrefix(r.URL.Path, route.Path) {
            // 检查方法
            if !contains(route.Methods, r.Method) {
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
            }

            // 代理请求
            route.Proxy.ServeHTTP(w, r)
            return
        }
    }

    http.NotFound(w, r)
}

// 使用示例
func main() {
    gw := NewGateway()

    gw.AddRoute("/users", "http://user-service:8001", []string{"GET", "POST"})
    gw.AddRoute("/orders", "http://order-service:8002", []string{"GET", "POST"})
    gw.AddRoute("/products", "http://product-service:8003", []string{"GET"})

    http.ListenAndServe(":8080", gw)
}
```

---

## 🔐 认证中间件

```go
func AuthMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        token := r.Header.Get("Authorization")

        if token == "" {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }

        // 验证JWT
        claims, err := ValidateJWT(token)
        if err != nil {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }

        // 将用户信息添加到header
        r.Header.Set("X-User-ID", claims.UserID)
        r.Header.Set("X-User-Role", claims.Role)

        next.ServeHTTP(w, r)
    })
}
```

---

## ⚡ 限流

```go
import "golang.org/x/time/rate"

type RateLimitedGateway struct {
    gateway *Gateway
    limiter *rate.Limiter
}

func (rlg *RateLimitedGateway) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    if !rlg.limiter.Allow() {
        http.Error(w, "Too many requests", http.StatusTooManyRequests)
        return
    }

    rlg.gateway.ServeHTTP(w, r)
}
```

---

## 🔄 熔断器

```go
import "github.com/sony/gobreaker"

type CircuitBreakerGateway struct {
    gateway *Gateway
    cb      *gobreaker.CircuitBreaker
}

func NewCircuitBreakerGateway(gw *Gateway) *CircuitBreakerGateway {
    settings := gobreaker.Settings{
        Name:        "API Gateway",
        MaxRequests: 3,
        Interval:    time.Minute,
        Timeout:     30 * time.Second,
        ReadyToTrip: func(counts gobreaker.Counts) bool {
            failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)
            return counts.Requests >= 3 && failureRatio >= 0.6
        },
    }

    return &CircuitBreakerGateway{
        gateway: gw,
        cb:      gobreaker.NewCircuitBreaker(settings),
    }
}

func (cbg *CircuitBreakerGateway) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    _, err := cbg.cb.Execute(func() (interface{}, error) {
        cbg.gateway.ServeHTTP(w, r)
        return nil, nil
    })

    if err != nil {
        http.Error(w, "Service unavailable", http.StatusServiceUnavailable)
    }
}
```

---

## 📊 监控与日志

```go
func LoggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()

        recorder := &responseRecorder{
            ResponseWriter: w,
            statusCode:     http.StatusOK,
        }

        next.ServeHTTP(recorder, r)

        log.Printf(
            "%s %s %d %v",
            r.Method,
            r.URL.Path,
            recorder.statusCode,
            time.Since(start),
        )
    })
}
```

---

## 📚 相关资源

- [Kong Gateway](https://konghq.com/)
- [Traefik](https://traefik.io/)

**下一步**: [05-服务网格](./05-服务网格.md)

---

**最后更新**: 2025-10-29
