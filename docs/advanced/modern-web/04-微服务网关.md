# å¾®æœåŠ¡ç½‘å…³

**éš¾åº¦**: é«˜çº§ | **é¢„è®¡é˜…è¯»**: 15åˆ†é’Ÿ

---

## ğŸ“‹ ç›®å½•

- [1. ğŸ“– API Gateway](#1--api-gateway)
- [2. ğŸ“š ç›¸å…³èµ„æº](#2--ç›¸å…³èµ„æº)

---

## 1. ğŸ“– API Gateway

```go
package gateway

import (
    "net/http"
    "net/http/httputil"
    "net/url"
)

type Gateway struct {
    routes map[string]*Route
}

type Route struct {
    Path    string
    Target  *url.URL
    Proxy   *httputil.ReverseProxy
    Methods []string
}

func NewGateway() *Gateway {
    return &Gateway{
        routes: make(map[string]*Route),
    }
}

func (g *Gateway) AddRoute(path string, target string, methods []string) error {
    targetURL, err := url.Parse(target)
    if err != nil {
        return err
    }
    
    proxy := httputil.NewSingleHostReverseProxy(targetURL)
    
    g.routes[path] = &Route{
        Path:    path,
        Target:  targetURL,
        Proxy:   proxy,
        Methods: methods,
    }
    
    return nil
}

func (g *Gateway) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    for _, route := range g.routes {
        if strings.HasPrefix(r.URL.Path, route.Path) {
            // æ£€æŸ¥æ–¹æ³•
            if !contains(route.Methods, r.Method) {
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
            }
            
            // ä»£ç†è¯·æ±‚
            route.Proxy.ServeHTTP(w, r)
            return
        }
    }
    
    http.NotFound(w, r)
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    gw := NewGateway()
    
    gw.AddRoute("/users", "http://user-service:8001", []string{"GET", "POST"})
    gw.AddRoute("/orders", "http://order-service:8002", []string{"GET", "POST"})
    gw.AddRoute("/products", "http://product-service:8003", []string{"GET"})
    
    http.ListenAndServe(":8080", gw)
}
```

---

## ğŸ” è®¤è¯ä¸­é—´ä»¶

```go
func AuthMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        token := r.Header.Get("Authorization")
        
        if token == "" {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        
        // éªŒè¯JWT
        claims, err := ValidateJWT(token)
        if err != nil {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }
        
        // å°†ç”¨æˆ·ä¿¡æ¯æ·»åŠ åˆ°header
        r.Header.Set("X-User-ID", claims.UserID)
        r.Header.Set("X-User-Role", claims.Role)
        
        next.ServeHTTP(w, r)
    })
}
```

---

## âš¡ é™æµ

```go
import "golang.org/x/time/rate"

type RateLimitedGateway struct {
    gateway *Gateway
    limiter *rate.Limiter
}

func (rlg *RateLimitedGateway) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    if !rlg.limiter.Allow() {
        http.Error(w, "Too many requests", http.StatusTooManyRequests)
        return
    }
    
    rlg.gateway.ServeHTTP(w, r)
}
```

---

## ğŸ”„ ç†”æ–­å™¨

```go
import "github.com/sony/gobreaker"

type CircuitBreakerGateway struct {
    gateway *Gateway
    cb      *gobreaker.CircuitBreaker
}

func NewCircuitBreakerGateway(gw *Gateway) *CircuitBreakerGateway {
    settings := gobreaker.Settings{
        Name:        "API Gateway",
        MaxRequests: 3,
        Interval:    time.Minute,
        Timeout:     30 * time.Second,
        ReadyToTrip: func(counts gobreaker.Counts) bool {
            failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)
            return counts.Requests >= 3 && failureRatio >= 0.6
        },
    }
    
    return &CircuitBreakerGateway{
        gateway: gw,
        cb:      gobreaker.NewCircuitBreaker(settings),
    }
}

func (cbg *CircuitBreakerGateway) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    _, err := cbg.cb.Execute(func() (interface{}, error) {
        cbg.gateway.ServeHTTP(w, r)
        return nil, nil
    })
    
    if err != nil {
        http.Error(w, "Service unavailable", http.StatusServiceUnavailable)
    }
}
```

---

## ğŸ“Š ç›‘æ§ä¸æ—¥å¿—

```go
func LoggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        recorder := &responseRecorder{
            ResponseWriter: w,
            statusCode:     http.StatusOK,
        }
        
        next.ServeHTTP(recorder, r)
        
        log.Printf(
            "%s %s %d %v",
            r.Method,
            r.URL.Path,
            recorder.statusCode,
            time.Since(start),
        )
    })
}
```

---

## ğŸ“š ç›¸å…³èµ„æº

- [Kong Gateway](https://konghq.com/)
- [Traefik](https://traefik.io/)

**ä¸‹ä¸€æ­¥**: [05-æœåŠ¡ç½‘æ ¼](./05-æœåŠ¡ç½‘æ ¼.md)

---

**æœ€åæ›´æ–°**: 2025-10-28

