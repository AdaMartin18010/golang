# å®æ—¶é€šä¿¡

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.25.3

---

## ğŸ“‹ ç›®å½•

- [å®æ—¶é€šä¿¡](#å®æ—¶é€šä¿¡)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. ğŸ“– WebSocket](#1--websocket)
  - [ğŸ”„ Server-Sent Events (SSE)](#-server-sent-events-sse)
  - [ğŸ“¡ gRPC Streaming](#-grpc-streaming)
  - [ğŸ’¡ èŠå¤©å®¤ç¤ºä¾‹](#-èŠå¤©å®¤ç¤ºä¾‹)
  - [ğŸ“š ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

## 1. ğŸ“– WebSocket

```go
import (
    "github.com/gorilla/websocket"
    "net/http"
)

var upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool {
        return true // ç”Ÿäº§ç¯å¢ƒéœ€ä¸¥æ ¼æ£€æŸ¥
    },
}

type Client struct {
    conn *websocket.Conn
    send chan []byte
}

type Hub struct {
    clients    map[*Client]bool
    broadcast  chan []byte
    register   chan *Client
    unregister chan *Client
}

func NewHub() *Hub {
    return &Hub{
        clients:    make(map[*Client]bool),
        broadcast:  make(chan []byte),
        register:   make(chan *Client),
        unregister: make(chan *Client),
    }
}

func (h *Hub) Run() {
    for {
        select {
        case client := <-h.register:
            h.clients[client] = true

        case client := <-h.unregister:
            if _, ok := h.clients[client]; ok {
                delete(h.clients, client)
                close(client.send)
            }

        case message := <-h.broadcast:
            for client := range h.clients {
                select {
                case client.send <- message:
                default:
                    close(client.send)
                    delete(h.clients, client)
                }
            }
        }
    }
}

func (h *Hub) ServeWS(w http.ResponseWriter, r *http.Request) {
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        log.Println(err)
        return
    }

    client := &Client{
        conn: conn,
        send: make(chan []byte, 256),
    }

    h.register <- client

    go client.writePump()
    go client.readPump(h)
}

func (c *Client) readPump(hub *Hub) {
    defer func() {
        hub.unregister <- c
        c.conn.Close()
    }()

    for {
        _, message, err := c.conn.ReadMessage()
        if err != nil {
            break
        }
        hub.broadcast <- message
    }
}

func (c *Client) writePump() {
    defer c.conn.Close()

    for message := range c.send {
        c.conn.WriteMessage(websocket.TextMessage, message)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    hub := NewHub()
    go hub.Run()

    http.HandleFunc("/ws", hub.ServeWS)
    http.ListenAndServe(":8080", nil)
}
```

---

## ğŸ”„ Server-Sent Events (SSE)

```go
type SSEServer struct {
    clients map[chan string]bool
    mu      sync.Mutex
}

func NewSSEServer() *SSEServer {
    return &SSEServer{
        clients: make(map[chan string]bool),
    }
}

func (s *SSEServer) ServeSSE(w http.ResponseWriter, r *http.Request) {
    // è®¾ç½®SSEå¤´éƒ¨
    w.Header().Set("Content-Type", "text/event-stream")
    w.Header().Set("Cache-Control", "no-cache")
    w.Header().Set("Connection", "keep-alive")

    // åˆ›å»ºå®¢æˆ·ç«¯channel
    clientChan := make(chan string)

    s.mu.Lock()
    s.clients[clientChan] = true
    s.mu.Unlock()

    defer func() {
        s.mu.Lock()
        delete(s.clients, clientChan)
        s.mu.Unlock()
        close(clientChan)
    }()

    // å‘é€æ¶ˆæ¯ç»™å®¢æˆ·ç«¯
    for msg := range clientChan {
        fmt.Fprintf(w, "data: %s\n\n", msg)
        w.(http.Flusher).Flush()
    }
}

func (s *SSEServer) Broadcast(message string) {
    s.mu.Lock()
    defer s.mu.Unlock()

    for client := range s.clients {
        select {
        case client <- message:
        default:
        }
    }
}
```

---

## ğŸ“¡ gRPC Streaming

```go
// æœåŠ¡å™¨æµå¼
func (s *server) StreamData(req *pb.Request, stream pb.Service_StreamDataServer) error {
    for i := 0; i < 10; i++ {
        resp := &pb.Response{
            Data: fmt.Sprintf("Message %d", i),
        }

        if err := stream.Send(resp); err != nil {
            return err
        }

        time.Sleep(time.Second)
    }

    return nil
}

// å®¢æˆ·ç«¯æµå¼
func (s *server) ReceiveStream(stream pb.Service_ReceiveStreamServer) error {
    for {
        req, err := stream.Recv()
        if err == io.EOF {
            return stream.SendAndClose(&pb.Response{
                Data: "Received all messages",
            })
        }
        if err != nil {
            return err
        }

        log.Printf("Received: %s", req.Data)
    }
}

// åŒå‘æµå¼
func (s *server) BidirectionalStream(stream pb.Service_BidirectionalStreamServer) error {
    for {
        req, err := stream.Recv()
        if err == io.EOF {
            return nil
        }
        if err != nil {
            return err
        }

        resp := &pb.Response{
            Data: "Echo: " + req.Data,
        }

        if err := stream.Send(resp); err != nil {
            return err
        }
    }
}
```

---

## ğŸ’¡ èŠå¤©å®¤ç¤ºä¾‹

```go
type ChatRoom struct {
    name    string
    clients map[string]*Client
    mu      sync.RWMutex
}

func (cr *ChatRoom) Join(client *Client) {
    cr.mu.Lock()
    cr.clients[client.ID] = client
    cr.mu.Unlock()

    cr.Broadcast(fmt.Sprintf("%s joined the room", client.Name))
}

func (cr *ChatRoom) Leave(client *Client) {
    cr.mu.Lock()
    delete(cr.clients, client.ID)
    cr.mu.Unlock()

    cr.Broadcast(fmt.Sprintf("%s left the room", client.Name))
}

func (cr *ChatRoom) Broadcast(message string) {
    cr.mu.RLock()
    defer cr.mu.RUnlock()

    for _, client := range cr.clients {
        client.Send(message)
    }
}
```

---

## ğŸ“š ç›¸å…³èµ„æº

- [Gorilla WebSocket](https://github.com/gorilla/websocket)
- [gRPC Streaming](https://grpc.io/docs/what-is-grpc/core-concepts/#server-streaming-rpc)

**ä¸‹ä¸€æ­¥**: [03-GraphQL](./03-GraphQL.md)

---

**æœ€åæ›´æ–°**: 2025-10-29
