# 实时通信

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---

## 📋 目录


- [1. 📖 WebSocket](#1.-websocket)
- [🔄 Server-Sent Events (SSE)](#server-sent-events-sse)
- [📡 gRPC Streaming](#grpc-streaming)
- [💡 聊天室示例](#聊天室示例)
- [📚 相关资源](#相关资源)

## 1. 📖 WebSocket

```go
import (
    "github.com/gorilla/websocket"
    "net/http"
)

var upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool {
        return true // 生产环境需严格检查
    },
}

type Client struct {
    conn *websocket.Conn
    send chan []byte
}

type Hub struct {
    clients    map[*Client]bool
    broadcast  chan []byte
    register   chan *Client
    unregister chan *Client
}

func NewHub() *Hub {
    return &Hub{
        clients:    make(map[*Client]bool),
        broadcast:  make(chan []byte),
        register:   make(chan *Client),
        unregister: make(chan *Client),
    }
}

func (h *Hub) Run() {
    for {
        select {
        case client := <-h.register:
            h.clients[client] = true
            
        case client := <-h.unregister:
            if _, ok := h.clients[client]; ok {
                delete(h.clients, client)
                close(client.send)
            }
            
        case message := <-h.broadcast:
            for client := range h.clients {
                select {
                case client.send <- message:
                default:
                    close(client.send)
                    delete(h.clients, client)
                }
            }
        }
    }
}

func (h *Hub) ServeWS(w http.ResponseWriter, r *http.Request) {
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        log.Println(err)
        return
    }
    
    client := &Client{
        conn: conn,
        send: make(chan []byte, 256),
    }
    
    h.register <- client
    
    go client.writePump()
    go client.readPump(h)
}

func (c *Client) readPump(hub *Hub) {
    defer func() {
        hub.unregister <- c
        c.conn.Close()
    }()
    
    for {
        _, message, err := c.conn.ReadMessage()
        if err != nil {
            break
        }
        hub.broadcast <- message
    }
}

func (c *Client) writePump() {
    defer c.conn.Close()
    
    for message := range c.send {
        c.conn.WriteMessage(websocket.TextMessage, message)
    }
}

// 使用示例
func main() {
    hub := NewHub()
    go hub.Run()
    
    http.HandleFunc("/ws", hub.ServeWS)
    http.ListenAndServe(":8080", nil)
}
```

---

## 🔄 Server-Sent Events (SSE)

```go
type SSEServer struct {
    clients map[chan string]bool
    mu      sync.Mutex
}

func NewSSEServer() *SSEServer {
    return &SSEServer{
        clients: make(map[chan string]bool),
    }
}

func (s *SSEServer) ServeSSE(w http.ResponseWriter, r *http.Request) {
    // 设置SSE头部
    w.Header().Set("Content-Type", "text/event-stream")
    w.Header().Set("Cache-Control", "no-cache")
    w.Header().Set("Connection", "keep-alive")
    
    // 创建客户端channel
    clientChan := make(chan string)
    
    s.mu.Lock()
    s.clients[clientChan] = true
    s.mu.Unlock()
    
    defer func() {
        s.mu.Lock()
        delete(s.clients, clientChan)
        s.mu.Unlock()
        close(clientChan)
    }()
    
    // 发送消息给客户端
    for msg := range clientChan {
        fmt.Fprintf(w, "data: %s\n\n", msg)
        w.(http.Flusher).Flush()
    }
}

func (s *SSEServer) Broadcast(message string) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    for client := range s.clients {
        select {
        case client <- message:
        default:
        }
    }
}
```

---

## 📡 gRPC Streaming

```go
// 服务器流式
func (s *server) StreamData(req *pb.Request, stream pb.Service_StreamDataServer) error {
    for i := 0; i < 10; i++ {
        resp := &pb.Response{
            Data: fmt.Sprintf("Message %d", i),
        }
        
        if err := stream.Send(resp); err != nil {
            return err
        }
        
        time.Sleep(time.Second)
    }
    
    return nil
}

// 客户端流式
func (s *server) ReceiveStream(stream pb.Service_ReceiveStreamServer) error {
    for {
        req, err := stream.Recv()
        if err == io.EOF {
            return stream.SendAndClose(&pb.Response{
                Data: "Received all messages",
            })
        }
        if err != nil {
            return err
        }
        
        log.Printf("Received: %s", req.Data)
    }
}

// 双向流式
func (s *server) BidirectionalStream(stream pb.Service_BidirectionalStreamServer) error {
    for {
        req, err := stream.Recv()
        if err == io.EOF {
            return nil
        }
        if err != nil {
            return err
        }
        
        resp := &pb.Response{
            Data: "Echo: " + req.Data,
        }
        
        if err := stream.Send(resp); err != nil {
            return err
        }
    }
}
```

---

## 💡 聊天室示例

```go
type ChatRoom struct {
    name    string
    clients map[string]*Client
    mu      sync.RWMutex
}

func (cr *ChatRoom) Join(client *Client) {
    cr.mu.Lock()
    cr.clients[client.ID] = client
    cr.mu.Unlock()
    
    cr.Broadcast(fmt.Sprintf("%s joined the room", client.Name))
}

func (cr *ChatRoom) Leave(client *Client) {
    cr.mu.Lock()
    delete(cr.clients, client.ID)
    cr.mu.Unlock()
    
    cr.Broadcast(fmt.Sprintf("%s left the room", client.Name))
}

func (cr *ChatRoom) Broadcast(message string) {
    cr.mu.RLock()
    defer cr.mu.RUnlock()
    
    for _, client := range cr.clients {
        client.Send(message)
    }
}
```

---

## 📚 相关资源

- [Gorilla WebSocket](https://github.com/gorilla/websocket)
- [gRPC Streaming](https://grpc.io/docs/what-is-grpc/core-concepts/#server-streaming-rpc)

**下一步**: [03-GraphQL](./03-GraphQL.md)

---

**最后更新**: 2025-10-29

