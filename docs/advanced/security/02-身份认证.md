# 身份认证

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---

## 📋 目录


- [1. 📖 概念介绍](#1.-概念介绍)
- [2. 🎯 基本认证 (Basic Auth)](#2.-基本认证-basic-auth)
- [🔑 JWT认证](#jwt认证)
- [🔐 Session认证](#session认证)
- [🌐 OAuth 2.0](#oauth-2.0)
- [💡 最佳实践](#最佳实践)
  - [1. 密码策略](#1.-密码策略)
  - [2. 限速保护](#2.-限速保护)
  - [3. 多因素认证 (2FA)](#3.-多因素认证-2fa)
- [3. 📚 相关资源](#3.-相关资源)

## 1. 📖 概念介绍

身份认证验证用户身份，是系统安全的第一道防线。Go提供了多种实现认证的方式。

---

## 2. 🎯 基本认证 (Basic Auth)

```go
import (
    "crypto/subtle"
    "encoding/base64"
    "net/http"
    "strings"
)

func basicAuthMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        auth := r.Header.Get("Authorization")
        if auth == "" {
            requireAuth(w)
            return
        }
        
        // 解析Basic Auth
        const prefix = "Basic "
        if !strings.HasPrefix(auth, prefix) {
            requireAuth(w)
            return
        }
        
        decoded, err := base64.StdEncoding.DecodeString(auth[len(prefix):])
        if err != nil {
            requireAuth(w)
            return
        }
        
        creds := strings.SplitN(string(decoded), ":", 2)
        if len(creds) != 2 {
            requireAuth(w)
            return
        }
        
        username, password := creds[0], creds[1]
        
        // 验证凭证（使用constant-time比较防止时序攻击）
        if !checkCredentials(username, password) {
            requireAuth(w)
            return
        }
        
        next.ServeHTTP(w, r)
    })
}

func checkCredentials(username, password string) bool {
    expectedUser := "admin"
    expectedPass := "secret"
    
    usernameMatch := subtle.ConstantTimeCompare(
        []byte(username), []byte(expectedUser)) == 1
    passwordMatch := subtle.ConstantTimeCompare(
        []byte(password), []byte(expectedPass)) == 1
    
    return usernameMatch && passwordMatch
}

func requireAuth(w http.ResponseWriter) {
    w.Header().Set("WWW-Authenticate", `Basic realm="Restricted"`)
    w.WriteHeader(http.StatusUnauthorized)
    w.Write([]byte("Unauthorized"))
}
```

---

## 🔑 JWT认证

```go
package auth

import (
    "time"
    
    "github.com/golang-jwt/jwt/v5"
)

var jwtSecret = []byte("your-secret-key")

// Claims结构
type Claims struct {
    UserID   string `json:"user_id"`
    Username string `json:"username"`
    jwt.RegisteredClaims
}

// 生成JWT
func GenerateToken(userID, username string) (string, error) {
    claims := Claims{
        UserID:   userID,
        Username: username,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
            Issuer:    "my-app",
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(jwtSecret)
}

// 验证JWT
func ValidateToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(
        tokenString,
        &Claims{},
        func(token *jwt.Token) (interface{}, error) {
            return jwtSecret, nil
        },
    )
    
    if err != nil {
        return nil, err
    }
    
    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }
    
    return nil, errors.New("invalid token")
}

// JWT中间件
func JWTMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" {
            http.Error(w, "Missing authorization header", http.StatusUnauthorized)
            return
        }
        
        // 提取Bearer token
        const prefix = "Bearer "
        if !strings.HasPrefix(authHeader, prefix) {
            http.Error(w, "Invalid authorization format", http.StatusUnauthorized)
            return
        }
        
        tokenString := authHeader[len(prefix):]
        claims, err := ValidateToken(tokenString)
        if err != nil {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }
        
        // 将claims存入context
        ctx := context.WithValue(r.Context(), "claims", claims)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// 使用示例
func loginHandler(w http.ResponseWriter, r *http.Request) {
    // 验证用户名密码...
    
    // 生成token
    token, _ := GenerateToken("user123", "john")
    
    json.NewEncoder(w).Encode(map[string]string{
        "token": token,
    })
}

func protectedHandler(w http.ResponseWriter, r *http.Request) {
    claims := r.Context().Value("claims").(*Claims)
    fmt.Fprintf(w, "Hello, %s!", claims.Username)
}
```

---

## 🔐 Session认证

```go
package session

import (
    "github.com/gorilla/sessions"
)

var store = sessions.NewCookieStore([]byte("your-secret-key"))

// 登录
func LoginHandler(w http.ResponseWriter, r *http.Request) {
    username := r.FormValue("username")
    password := r.FormValue("password")
    
    // 验证凭证
    if !checkCredentials(username, password) {
        http.Error(w, "Invalid credentials", http.StatusUnauthorized)
        return
    }
    
    // 创建session
    session, _ := store.Get(r, "session-name")
    session.Values["authenticated"] = true
    session.Values["username"] = username
    session.Save(r, w)
    
    http.Redirect(w, r, "/dashboard", http.StatusFound)
}

// 登出
func LogoutHandler(w http.ResponseWriter, r *http.Request) {
    session, _ := store.Get(r, "session-name")
    session.Values["authenticated"] = false
    session.Save(r, w)
    
    http.Redirect(w, r, "/", http.StatusFound)
}

// Session中间件
func SessionMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        session, _ := store.Get(r, "session-name")
        
        if auth, ok := session.Values["authenticated"].(bool); !ok || !auth {
            http.Redirect(w, r, "/login", http.StatusFound)
            return
        }
        
        next.ServeHTTP(w, r)
    })
}
```

---

## 🌐 OAuth 2.0

```go
import (
    "golang.org/x/oauth2"
    "golang.org/x/oauth2/github"
)

var oauthConfig = &oauth2.Config{
    ClientID:     "your-client-id",
    ClientSecret: "your-client-secret",
    RedirectURL:  "http://localhost:8080/callback",
    Scopes:       []string{"user:email"},
    Endpoint:     github.Endpoint,
}

// 生成随机state
func generateStateOauthCookie(w http.ResponseWriter) string {
    b := make([]byte, 16)
    rand.Read(b)
    state := base64.URLEncoding.EncodeToString(b)
    
    cookie := http.Cookie{
        Name:     "oauthstate",
        Value:    state,
        Expires:  time.Now().Add(24 * time.Hour),
        HttpOnly: true,
    }
    http.SetCookie(w, &cookie)
    
    return state
}

// 登录处理
func OAuthLoginHandler(w http.ResponseWriter, r *http.Request) {
    state := generateStateOauthCookie(w)
    url := oauthConfig.AuthCodeURL(state)
    http.Redirect(w, r, url, http.StatusTemporaryRedirect)
}

// 回调处理
func OAuthCallbackHandler(w http.ResponseWriter, r *http.Request) {
    // 验证state
    stateCookie, _ := r.Cookie("oauthstate")
    if r.FormValue("state") != stateCookie.Value {
        http.Error(w, "Invalid state", http.StatusBadRequest)
        return
    }
    
    // 交换code获取token
    code := r.FormValue("code")
    token, err := oauthConfig.Exchange(r.Context(), code)
    if err != nil {
        http.Error(w, "Token exchange failed", http.StatusInternalServerError)
        return
    }
    
    // 使用token获取用户信息
    client := oauthConfig.Client(r.Context(), token)
    resp, _ := client.Get("https://api.github.com/user")
    defer resp.Body.Close()
    
    // 处理用户信息...
}
```

---

## 💡 最佳实践

### 1. 密码策略
```go
func validatePassword(password string) error {
    if len(password) < 8 {
        return errors.New("password must be at least 8 characters")
    }
    
    var (
        hasUpper   = regexp.MustCompile(`[A-Z]`).MatchString(password)
        hasLower   = regexp.MustCompile(`[a-z]`).MatchString(password)
        hasNumber  = regexp.MustCompile(`[0-9]`).MatchString(password)
        hasSpecial = regexp.MustCompile(`[!@#$%^&*]`).MatchString(password)
    )
    
    if !hasUpper || !hasLower || !hasNumber || !hasSpecial {
        return errors.New("password must contain uppercase, lowercase, number, and special character")
    }
    
    return nil
}
```

### 2. 限速保护
```go
type RateLimiter struct {
    attempts map[string]int
    mu       sync.Mutex
}

func (rl *RateLimiter) AllowLogin(ip string) bool {
    rl.mu.Lock()
    defer rl.mu.Unlock()
    
    if rl.attempts[ip] >= 5 {
        return false
    }
    
    rl.attempts[ip]++
    return true
}
```

### 3. 多因素认证 (2FA)
```go
import "github.com/pquerna/otp/totp"

// 生成TOTP密钥
func generateTOTP(username string) (*otp.Key, error) {
    return totp.Generate(totp.GenerateOpts{
        Issuer:      "MyApp",
        AccountName: username,
    })
}

// 验证TOTP
func validateTOTP(token, secret string) bool {
    return totp.Validate(token, secret)
}
```

---

## 3. 📚 相关资源

- [JWT.io](https://jwt.io/)
- [OAuth 2.0](https://oauth.net/2/)

**下一步**: [03-授权机制](./03-授权机制.md)

---

**最后更新**: 2025-10-29

