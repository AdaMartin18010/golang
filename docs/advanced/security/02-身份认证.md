# èº«ä»½è®¤è¯

**éš¾åº¦**: ä¸­çº§ | **é¢„è®¡é˜…è¯»**: 20åˆ†é’Ÿ | **å‰ç½®çŸ¥è¯†**: HTTPã€å¯†ç å­¦åŸºç¡€

---

## ğŸ“– æ¦‚å¿µä»‹ç»

èº«ä»½è®¤è¯éªŒè¯ç”¨æˆ·èº«ä»½ï¼Œæ˜¯ç³»ç»Ÿå®‰å…¨çš„ç¬¬ä¸€é“é˜²çº¿ã€‚Goæä¾›äº†å¤šç§å®ç°è®¤è¯çš„æ–¹å¼ã€‚

---

## ğŸ¯ åŸºæœ¬è®¤è¯ (Basic Auth)

```go
import (
    "crypto/subtle"
    "encoding/base64"
    "net/http"
    "strings"
)

func basicAuthMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        auth := r.Header.Get("Authorization")
        if auth == "" {
            requireAuth(w)
            return
        }
        
        // è§£æBasic Auth
        const prefix = "Basic "
        if !strings.HasPrefix(auth, prefix) {
            requireAuth(w)
            return
        }
        
        decoded, err := base64.StdEncoding.DecodeString(auth[len(prefix):])
        if err != nil {
            requireAuth(w)
            return
        }
        
        creds := strings.SplitN(string(decoded), ":", 2)
        if len(creds) != 2 {
            requireAuth(w)
            return
        }
        
        username, password := creds[0], creds[1]
        
        // éªŒè¯å‡­è¯ï¼ˆä½¿ç”¨constant-timeæ¯”è¾ƒé˜²æ­¢æ—¶åºæ”»å‡»ï¼‰
        if !checkCredentials(username, password) {
            requireAuth(w)
            return
        }
        
        next.ServeHTTP(w, r)
    })
}

func checkCredentials(username, password string) bool {
    expectedUser := "admin"
    expectedPass := "secret"
    
    usernameMatch := subtle.ConstantTimeCompare(
        []byte(username), []byte(expectedUser)) == 1
    passwordMatch := subtle.ConstantTimeCompare(
        []byte(password), []byte(expectedPass)) == 1
    
    return usernameMatch && passwordMatch
}

func requireAuth(w http.ResponseWriter) {
    w.Header().Set("WWW-Authenticate", `Basic realm="Restricted"`)
    w.WriteHeader(http.StatusUnauthorized)
    w.Write([]byte("Unauthorized"))
}
```

---

## ğŸ”‘ JWTè®¤è¯

```go
package auth

import (
    "time"
    
    "github.com/golang-jwt/jwt/v5"
)

var jwtSecret = []byte("your-secret-key")

// Claimsç»“æ„
type Claims struct {
    UserID   string `json:"user_id"`
    Username string `json:"username"`
    jwt.RegisteredClaims
}

// ç”ŸæˆJWT
func GenerateToken(userID, username string) (string, error) {
    claims := Claims{
        UserID:   userID,
        Username: username,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
            Issuer:    "my-app",
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(jwtSecret)
}

// éªŒè¯JWT
func ValidateToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(
        tokenString,
        &Claims{},
        func(token *jwt.Token) (interface{}, error) {
            return jwtSecret, nil
        },
    )
    
    if err != nil {
        return nil, err
    }
    
    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }
    
    return nil, errors.New("invalid token")
}

// JWTä¸­é—´ä»¶
func JWTMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" {
            http.Error(w, "Missing authorization header", http.StatusUnauthorized)
            return
        }
        
        // æå–Bearer token
        const prefix = "Bearer "
        if !strings.HasPrefix(authHeader, prefix) {
            http.Error(w, "Invalid authorization format", http.StatusUnauthorized)
            return
        }
        
        tokenString := authHeader[len(prefix):]
        claims, err := ValidateToken(tokenString)
        if err != nil {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }
        
        // å°†claimså­˜å…¥context
        ctx := context.WithValue(r.Context(), "claims", claims)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// ä½¿ç”¨ç¤ºä¾‹
func loginHandler(w http.ResponseWriter, r *http.Request) {
    // éªŒè¯ç”¨æˆ·åå¯†ç ...
    
    // ç”Ÿæˆtoken
    token, _ := GenerateToken("user123", "john")
    
    json.NewEncoder(w).Encode(map[string]string{
        "token": token,
    })
}

func protectedHandler(w http.ResponseWriter, r *http.Request) {
    claims := r.Context().Value("claims").(*Claims)
    fmt.Fprintf(w, "Hello, %s!", claims.Username)
}
```

---

## ğŸ” Sessionè®¤è¯

```go
package session

import (
    "github.com/gorilla/sessions"
)

var store = sessions.NewCookieStore([]byte("your-secret-key"))

// ç™»å½•
func LoginHandler(w http.ResponseWriter, r *http.Request) {
    username := r.FormValue("username")
    password := r.FormValue("password")
    
    // éªŒè¯å‡­è¯
    if !checkCredentials(username, password) {
        http.Error(w, "Invalid credentials", http.StatusUnauthorized)
        return
    }
    
    // åˆ›å»ºsession
    session, _ := store.Get(r, "session-name")
    session.Values["authenticated"] = true
    session.Values["username"] = username
    session.Save(r, w)
    
    http.Redirect(w, r, "/dashboard", http.StatusFound)
}

// ç™»å‡º
func LogoutHandler(w http.ResponseWriter, r *http.Request) {
    session, _ := store.Get(r, "session-name")
    session.Values["authenticated"] = false
    session.Save(r, w)
    
    http.Redirect(w, r, "/", http.StatusFound)
}

// Sessionä¸­é—´ä»¶
func SessionMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        session, _ := store.Get(r, "session-name")
        
        if auth, ok := session.Values["authenticated"].(bool); !ok || !auth {
            http.Redirect(w, r, "/login", http.StatusFound)
            return
        }
        
        next.ServeHTTP(w, r)
    })
}
```

---

## ğŸŒ OAuth 2.0

```go
import (
    "golang.org/x/oauth2"
    "golang.org/x/oauth2/github"
)

var oauthConfig = &oauth2.Config{
    ClientID:     "your-client-id",
    ClientSecret: "your-client-secret",
    RedirectURL:  "http://localhost:8080/callback",
    Scopes:       []string{"user:email"},
    Endpoint:     github.Endpoint,
}

// ç”Ÿæˆéšæœºstate
func generateStateOauthCookie(w http.ResponseWriter) string {
    b := make([]byte, 16)
    rand.Read(b)
    state := base64.URLEncoding.EncodeToString(b)
    
    cookie := http.Cookie{
        Name:     "oauthstate",
        Value:    state,
        Expires:  time.Now().Add(24 * time.Hour),
        HttpOnly: true,
    }
    http.SetCookie(w, &cookie)
    
    return state
}

// ç™»å½•å¤„ç†
func OAuthLoginHandler(w http.ResponseWriter, r *http.Request) {
    state := generateStateOauthCookie(w)
    url := oauthConfig.AuthCodeURL(state)
    http.Redirect(w, r, url, http.StatusTemporaryRedirect)
}

// å›è°ƒå¤„ç†
func OAuthCallbackHandler(w http.ResponseWriter, r *http.Request) {
    // éªŒè¯state
    stateCookie, _ := r.Cookie("oauthstate")
    if r.FormValue("state") != stateCookie.Value {
        http.Error(w, "Invalid state", http.StatusBadRequest)
        return
    }
    
    // äº¤æ¢codeè·å–token
    code := r.FormValue("code")
    token, err := oauthConfig.Exchange(r.Context(), code)
    if err != nil {
        http.Error(w, "Token exchange failed", http.StatusInternalServerError)
        return
    }
    
    // ä½¿ç”¨tokenè·å–ç”¨æˆ·ä¿¡æ¯
    client := oauthConfig.Client(r.Context(), token)
    resp, _ := client.Get("https://api.github.com/user")
    defer resp.Body.Close()
    
    // å¤„ç†ç”¨æˆ·ä¿¡æ¯...
}
```

---

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. å¯†ç ç­–ç•¥
```go
func validatePassword(password string) error {
    if len(password) < 8 {
        return errors.New("password must be at least 8 characters")
    }
    
    var (
        hasUpper   = regexp.MustCompile(`[A-Z]`).MatchString(password)
        hasLower   = regexp.MustCompile(`[a-z]`).MatchString(password)
        hasNumber  = regexp.MustCompile(`[0-9]`).MatchString(password)
        hasSpecial = regexp.MustCompile(`[!@#$%^&*]`).MatchString(password)
    )
    
    if !hasUpper || !hasLower || !hasNumber || !hasSpecial {
        return errors.New("password must contain uppercase, lowercase, number, and special character")
    }
    
    return nil
}
```

### 2. é™é€Ÿä¿æŠ¤
```go
type RateLimiter struct {
    attempts map[string]int
    mu       sync.Mutex
}

func (rl *RateLimiter) AllowLogin(ip string) bool {
    rl.mu.Lock()
    defer rl.mu.Unlock()
    
    if rl.attempts[ip] >= 5 {
        return false
    }
    
    rl.attempts[ip]++
    return true
}
```

### 3. å¤šå› ç´ è®¤è¯ (2FA)
```go
import "github.com/pquerna/otp/totp"

// ç”ŸæˆTOTPå¯†é’¥
func generateTOTP(username string) (*otp.Key, error) {
    return totp.Generate(totp.GenerateOpts{
        Issuer:      "MyApp",
        AccountName: username,
    })
}

// éªŒè¯TOTP
func validateTOTP(token, secret string) bool {
    return totp.Validate(token, secret)
}
```

---

## ğŸ“š ç›¸å…³èµ„æº

- [JWT.io](https://jwt.io/)
- [OAuth 2.0](https://oauth.net/2/)

**ä¸‹ä¸€æ­¥**: [03-æˆæƒæœºåˆ¶](./03-æˆæƒæœºåˆ¶.md)

---

**æœ€åæ›´æ–°**: 2025-10-28

