# 身份认证

**版本**: v1.0
**更新日期**: 2025-10-29
**适用于**: Go 1.25.3

---

## 📋 目录

- [身份认证](#身份认证)
  - [📋 目录](#-目录)
  - [1. 📖 概念介绍](#1--概念介绍)
  - [2. 🎯 基本认证 (Basic Auth)](#2--基本认证-basic-auth)
  - [🔑 JWT认证](#-jwt认证)
  - [🔐 Session认证](#-session认证)
  - [🌐 OAuth 2.0](#-oauth-20)
  - [💡 最佳实践](#-最佳实践)
    - [1. 密码策略](#1-密码策略)
    - [2. 限速保护](#2-限速保护)
    - [3. 多因素认证 (2FA)](#3-多因素认证-2fa)
  - [3. 📚 相关资源](#3--相关资源)

---

## 1. 📖 概念介绍

身份认证验证用户身份，是系统安全的第一道防线。Go提供了多种实现认证的方式。

---

## 2. 🎯 基本认证 (Basic Auth)

```go
import (
    "crypto/subtle"
    "encoding/base64"
    "net/http"
    "strings"
)

func basicAuthMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        auth := r.Header.Get("Authorization")
        if auth == "" {
            requireAuth(w)
            return
        }

        // 解析Basic Auth
        const prefix = "Basic "
        if !strings.HasPrefix(auth, prefix) {
            requireAuth(w)
            return
        }

        decoded, err := base64.StdEncoding.DecodeString(auth[len(prefix):])
        if err != nil {
            requireAuth(w)
            return
        }

        creds := strings.SplitN(string(decoded), ":", 2)
        if len(creds) != 2 {
            requireAuth(w)
            return
        }

        username, password := creds[0], creds[1]

        // 验证凭证（使用constant-time比较防止时序攻击）
        if !checkCredentials(username, password) {
            requireAuth(w)
            return
        }

        next.ServeHTTP(w, r)
    })
}

func checkCredentials(username, password string) bool {
    expectedUser := "admin"
    expectedPass := "secret"

    usernameMatch := subtle.ConstantTimeCompare(
        []byte(username), []byte(expectedUser)) == 1
    passwordMatch := subtle.ConstantTimeCompare(
        []byte(password), []byte(expectedPass)) == 1

    return usernameMatch && passwordMatch
}

func requireAuth(w http.ResponseWriter) {
    w.Header().Set("WWW-Authenticate", `Basic realm="Restricted"`)
    w.WriteHeader(http.StatusUnauthorized)
    w.Write([]byte("Unauthorized"))
}
```

---

## 🔑 JWT认证

```go
package auth

import (
    "time"

    "github.com/golang-jwt/jwt/v5"
)

var jwtSecret = []byte("your-secret-key")

// Claims结构
type Claims struct {
    UserID   string `json:"user_id"`
    Username string `json:"username"`
    jwt.RegisteredClaims
}

// 生成JWT
func GenerateToken(userID, username string) (string, error) {
    claims := Claims{
        UserID:   userID,
        Username: username,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
            Issuer:    "my-app",
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(jwtSecret)
}

// 验证JWT
func ValidateToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(
        tokenString,
        &Claims{},
        func(token *jwt.Token) (interface{}, error) {
            return jwtSecret, nil
        },
    )

    if err != nil {
        return nil, err
    }

    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }

    return nil, errors.New("invalid token")
}

// JWT中间件
func JWTMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" {
            http.Error(w, "Missing authorization header", http.StatusUnauthorized)
            return
        }

        // 提取Bearer token
        const prefix = "Bearer "
        if !strings.HasPrefix(authHeader, prefix) {
            http.Error(w, "Invalid authorization format", http.StatusUnauthorized)
            return
        }

        tokenString := authHeader[len(prefix):]
        claims, err := ValidateToken(tokenString)
        if err != nil {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }

        // 将claims存入context
        ctx := Context.WithValue(r.Context(), "claims", claims)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// 使用示例
func loginHandler(w http.ResponseWriter, r *http.Request) {
    // 验证用户名密码...

    // 生成token
    token, _ := GenerateToken("user123", "john")

    json.NewEncoder(w).Encode(map[string]string{
        "token": token,
    })
}

func protectedHandler(w http.ResponseWriter, r *http.Request) {
    claims := r.Context().Value("claims").(*Claims)
    fmt.Fprintf(w, "Hello, %s!", claims.Username)
}
```

---

## 🔐 Session认证

```go
package session

import (
    "github.com/gorilla/sessions"
)

var store = sessions.NewCookieStore([]byte("your-secret-key"))

// 登录
func LoginHandler(w http.ResponseWriter, r *http.Request) {
    username := r.FormValue("username")
    password := r.FormValue("password")

    // 验证凭证
    if !checkCredentials(username, password) {
        http.Error(w, "Invalid credentials", http.StatusUnauthorized)
        return
    }

    // 创建session
    session, _ := store.Get(r, "session-name")
    session.Values["authenticated"] = true
    session.Values["username"] = username
    session.Save(r, w)

    http.Redirect(w, r, "/dashboard", http.StatusFound)
}

// 登出
func LogoutHandler(w http.ResponseWriter, r *http.Request) {
    session, _ := store.Get(r, "session-name")
    session.Values["authenticated"] = false
    session.Save(r, w)

    http.Redirect(w, r, "/", http.StatusFound)
}

// Session中间件
func SessionMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        session, _ := store.Get(r, "session-name")

        if auth, ok := session.Values["authenticated"].(bool); !ok || !auth {
            http.Redirect(w, r, "/login", http.StatusFound)
            return
        }

        next.ServeHTTP(w, r)
    })
}
```

---

## 🌐 OAuth 2.0

```go
import (
    "golang.org/x/oauth2"
    "golang.org/x/oauth2/github"
)

var oauthConfig = &oauth2.Config{
    ClientID:     "your-client-id",
    ClientSecret: "your-client-secret",
    RedirectURL:  "http://localhost:8080/callback",
    Scopes:       []string{"user:email"},
    Endpoint:     github.Endpoint,
}

// 生成随机state
func generateStateOauthCookie(w http.ResponseWriter) string {
    b := make([]byte, 16)
    rand.Read(b)
    state := base64.URLEncoding.EncodeToString(b)

    cookie := http.Cookie{
        Name:     "oauthstate",
        Value:    state,
        Expires:  time.Now().Add(24 * time.Hour),
        HttpOnly: true,
    }
    http.SetCookie(w, &cookie)

    return state
}

// 登录处理
func OAuthLoginHandler(w http.ResponseWriter, r *http.Request) {
    state := generateStateOauthCookie(w)
    url := oauthConfig.AuthCodeURL(state)
    http.Redirect(w, r, url, http.StatusTemporaryRedirect)
}

// 回调处理
func OAuthCallbackHandler(w http.ResponseWriter, r *http.Request) {
    // 验证state
    stateCookie, _ := r.Cookie("oauthstate")
    if r.FormValue("state") != stateCookie.Value {
        http.Error(w, "Invalid state", http.StatusBadRequest)
        return
    }

    // 交换code获取token
    code := r.FormValue("code")
    token, err := oauthConfig.Exchange(r.Context(), code)
    if err != nil {
        http.Error(w, "Token exchange failed", http.StatusInternalServerError)
        return
    }

    // 使用token获取用户信息
    client := oauthConfig.Client(r.Context(), token)
    resp, _ := client.Get("https://api.github.com/user")
    defer resp.Body.Close()

    // 处理用户信息...
}
```

---

## 💡 最佳实践

### 1. 密码策略

```go
func validatePassword(password string) error {
    if len(password) < 8 {
        return errors.New("password must be at least 8 characters")
    }

    var (
        hasUpper   = regexp.MustCompile(`[A-Z]`).MatchString(password)
        hasLower   = regexp.MustCompile(`[a-z]`).MatchString(password)
        hasNumber  = regexp.MustCompile(`[0-9]`).MatchString(password)
        hasSpecial = regexp.MustCompile(`[!@#$%^&*]`).MatchString(password)
    )

    if !hasUpper || !hasLower || !hasNumber || !hasSpecial {
        return errors.New("password must contain uppercase, lowercase, number, and special character")
    }

    return nil
}
```

### 2. 限速保护

```go
type RateLimiter struct {
    attempts map[string]int
    mu       sync.Mutex
}

func (rl *RateLimiter) AllowLogin(ip string) bool {
    rl.mu.Lock()
    defer rl.mu.Unlock()

    if rl.attempts[ip] >= 5 {
        return false
    }

    rl.attempts[ip]++
    return true
}
```

### 3. 多因素认证 (2FA)

```go
import "github.com/pquerna/otp/totp"

// 生成TOTP密钥
func generateTOTP(username string) (*otp.Key, error) {
    return totp.Generate(totp.GenerateOpts{
        Issuer:      "MyApp",
        AccountName: username,
    })
}

// 验证TOTP
func validateTOTP(token, secret string) bool {
    return totp.Validate(token, secret)
}
```

---

## 3. 📚 相关资源
