# Go认证授权

> **简介**: Go认证授权完整指南，包括JWT、OAuth2、RBAC和最佳实践

> **版本**: Go 1.25.3  
> **难度**: ⭐⭐⭐⭐  
> **标签**: #安全 #认证 #授权 #JWT

---

## 📋 目录
- [1. 认证基础](#认证基础)
- [2. JWT实现](#jwt实现)
- [3. OAuth2](#oauth2)
- [4. RBAC权限控制](#rbac权限控制)
- [5. Session管理](#session管理)
- [6. 最佳实践](#最佳实践)

---

## 1. 认证基础

### 基本认证流程

```
1. 用户提交凭证（用户名/密码）
2. 服务器验证凭证
3. 生成Token
4. 返回Token给客户端
5. 客户端在后续请求中携带Token
6. 服务器验证Token
```

---

### 密码哈希

```go
import "golang.org/x/crypto/bcrypt"

// 生成密码哈希
func HashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return "", err
    }
    return string(bytes), nil
}

// 验证密码
func CheckPassword(password, hash string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}

// 使用示例
func registerUser(username, password string) error {
    hash, err := HashPassword(password)
    if err != nil {
        return err
    }
    
    user := &User{
        Username:     username,
        PasswordHash: hash,
    }
    
    return saveUser(user)
}

func login(username, password string) (*User, error) {
    user, err := findUserByUsername(username)
    if err != nil {
        return nil, err
    }
    
    if !CheckPassword(password, user.PasswordHash) {
        return nil, errors.New("invalid credentials")
    }
    
    return user, nil
}
```

---

## 2. JWT实现

### JWT结构

```
Header.Payload.Signature

Header: {"alg": "HS256", "typ": "JWT"}
Payload: {"sub": "123", "name": "Alice", "exp": 1735401600}
Signature: HMACSHA256(base64(header) + "." + base64(payload), secret)
```

---

### JWT生成和验证

```go
import "github.com/golang-jwt/jwt/v5"

var jwtSecret = []byte("your-secret-key")

type Claims struct {
    UserID   string `json:"user_id"`
    Username string `json:"username"`
    jwt.RegisteredClaims
}

// 生成JWT Token
func GenerateToken(userID, username string) (string, error) {
    claims := &Claims{
        UserID:   userID,
        Username: username,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
            Issuer:    "myapp",
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(jwtSecret)
}

// 验证JWT Token
func ValidateToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        // 验证签名算法
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
        }
        return jwtSecret, nil
    })
    
    if err != nil {
        return nil, err
    }
    
    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }
    
    return nil, errors.New("invalid token")
}

// 刷新Token
func RefreshToken(tokenString string) (string, error) {
    claims, err := ValidateToken(tokenString)
    if err != nil {
        return "", err
    }
    
    // 检查是否即将过期（例如，剩余时间小于1小时）
    if time.Until(claims.ExpiresAt.Time) > time.Hour {
        return tokenString, nil
    }
    
    // 生成新Token
    return GenerateToken(claims.UserID, claims.Username)
}
```

---

### JWT中间件

```go
func AuthMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 从Header获取Token
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" {
            http.Error(w, "Authorization header required", http.StatusUnauthorized)
            return
        }
        
        // 解析Bearer Token
        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
        if tokenString == authHeader {
            http.Error(w, "Bearer token required", http.StatusUnauthorized)
            return
        }
        
        // 验证Token
        claims, err := ValidateToken(tokenString)
        if err != nil {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }
        
        // 将用户信息存入Context
        ctx := context.WithValue(r.Context(), "user_id", claims.UserID)
        ctx = context.WithValue(ctx, "username", claims.Username)
        
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// 使用
func main() {
    mux := http.NewServeMux()
    
    // 公开路由
    mux.HandleFunc("/login", loginHandler)
    mux.HandleFunc("/register", registerHandler)
    
    // 受保护路由
    protected := http.NewServeMux()
    protected.HandleFunc("/profile", profileHandler)
    protected.HandleFunc("/orders", ordersHandler)
    
    mux.Handle("/api/", http.StripPrefix("/api", AuthMiddleware(protected)))
    
    http.ListenAndServe(":8080", mux)
}
```

---

## 3. OAuth2

### OAuth2流程

```
1. 用户点击"使用XX登录"
2. 重定向到OAuth提供商
3. 用户授权
4. 重定向回应用，带上授权码
5. 应用用授权码换取访问令牌
6. 使用访问令牌访问资源
```

---

### OAuth2客户端实现

```go
import "golang.org/x/oauth2"
import "golang.org/x/oauth2/google"

var oauth2Config = &oauth2.Config{
    ClientID:     "your-client-id",
    ClientSecret: "your-client-secret",
    RedirectURL:  "http://localhost:8080/callback",
    Scopes: []string{
        "https://www.googleapis.com/auth/userinfo.email",
        "https://www.googleapis.com/auth/userinfo.profile",
    },
    Endpoint: google.Endpoint,
}

// 生成授权URL
func handleLogin(w http.ResponseWriter, r *http.Request) {
    state := generateRandomState() // 防CSRF
    url := oauth2Config.AuthCodeURL(state, oauth2.AccessTypeOffline)
    http.Redirect(w, r, url, http.StatusTemporaryRedirect)
}

// 处理回调
func handleCallback(w http.ResponseWriter, r *http.Request) {
    // 验证state
    state := r.URL.Query().Get("state")
    if !validateState(state) {
        http.Error(w, "Invalid state", http.StatusBadRequest)
        return
    }
    
    // 获取授权码
    code := r.URL.Query().Get("code")
    
    // 交换Token
    token, err := oauth2Config.Exchange(context.Background(), code)
    if err != nil {
        http.Error(w, "Failed to exchange token", http.StatusInternalServerError)
        return
    }
    
    // 获取用户信息
    client := oauth2Config.Client(context.Background(), token)
    resp, err := client.Get("https://www.googleapis.com/oauth2/v2/userinfo")
    if err != nil {
        http.Error(w, "Failed to get user info", http.StatusInternalServerError)
        return
    }
    defer resp.Body.Close()
    
    var userInfo map[string]interface{}
    json.NewDecoder(resp.Body).Decode(&userInfo)
    
    // 创建或更新用户
    user := createOrUpdateUser(userInfo)
    
    // 生成JWT Token
    jwtToken, _ := GenerateToken(user.ID, user.Username)
    
    // 返回Token
    json.NewEncoder(w).Encode(map[string]string{
        "token": jwtToken,
    })
}
```

---

## 4. RBAC权限控制

### 权限模型

```go
type Role struct {
    ID          string
    Name        string
    Permissions []string
}

type User struct {
    ID       string
    Username string
    Roles    []string
}

type Permission struct {
    Resource string // 资源，如 "users", "orders"
    Action   string // 操作，如 "read", "write", "delete"
}
```

---

### RBAC实现

```go
type RBACService struct {
    roles map[string]*Role
}

func NewRBACService() *RBACService {
    return &RBACService{
        roles: map[string]*Role{
            "admin": {
                ID:   "admin",
                Name: "Administrator",
                Permissions: []string{
                    "users:read", "users:write", "users:delete",
                    "orders:read", "orders:write", "orders:delete",
                    "products:read", "products:write", "products:delete",
                },
            },
            "user": {
                ID:   "user",
                Name: "Regular User",
                Permissions: []string{
                    "orders:read", "orders:write",
                    "products:read",
                },
            },
            "guest": {
                ID:   "guest",
                Name: "Guest",
                Permissions: []string{
                    "products:read",
                },
            },
        },
    }
}

// 检查权限
func (s *RBACService) HasPermission(user *User, resource, action string) bool {
    permission := fmt.Sprintf("%s:%s", resource, action)
    
    for _, roleID := range user.Roles {
        role, exists := s.roles[roleID]
        if !exists {
            continue
        }
        
        for _, p := range role.Permissions {
            if p == permission || p == fmt.Sprintf("%s:*", resource) || p == "*:*" {
                return true
            }
        }
    }
    
    return false
}

// 添加角色
func (s *RBACService) AddRole(role *Role) {
    s.roles[role.ID] = role
}

// 添加权限到角色
func (s *RBACService) AddPermissionToRole(roleID, permission string) error {
    role, exists := s.roles[roleID]
    if !exists {
        return errors.New("role not found")
    }
    
    role.Permissions = append(role.Permissions, permission)
    return nil
}
```

---

### RBAC中间件

```go
func RequirePermission(resource, action string) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // 从Context获取用户
            userID := r.Context().Value("user_id").(string)
            user, err := getUserByID(userID)
            if err != nil {
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
            }
            
            // 检查权限
            if !rbacService.HasPermission(user, resource, action) {
                http.Error(w, "Forbidden", http.StatusForbidden)
                return
            }
            
            next.ServeHTTP(w, r)
        })
    }
}

// 使用
func main() {
    mux := http.NewServeMux()
    
    // 需要读取用户权限
    mux.Handle("/api/users", 
        AuthMiddleware(
            RequirePermission("users", "read")(
                http.HandlerFunc(listUsersHandler),
            ),
        ),
    )
    
    // 需要删除用户权限
    mux.Handle("/api/users/delete", 
        AuthMiddleware(
            RequirePermission("users", "delete")(
                http.HandlerFunc(deleteUserHandler),
            ),
        ),
    )
    
    http.ListenAndServe(":8080", mux)
}
```

---

## 5. Session管理

### Session存储

```go
import "github.com/gorilla/sessions"

var store = sessions.NewCookieStore([]byte("your-secret-key"))

// 创建Session
func createSession(w http.ResponseWriter, r *http.Request, userID string) error {
    session, _ := store.Get(r, "session-name")
    
    session.Values["user_id"] = userID
    session.Values["authenticated"] = true
    session.Options = &sessions.Options{
        Path:     "/",
        MaxAge:   3600 * 24, // 24小时
        HttpOnly: true,
        Secure:   true,
        SameSite: http.SameSiteStrictMode,
    }
    
    return session.Save(r, w)
}

// 获取Session
func getSession(r *http.Request) (string, bool) {
    session, _ := store.Get(r, "session-name")
    
    if auth, ok := session.Values["authenticated"].(bool); !ok || !auth {
        return "", false
    }
    
    userID, ok := session.Values["user_id"].(string)
    return userID, ok
}

// 销毁Session
func destroySession(w http.ResponseWriter, r *http.Request) error {
    session, _ := store.Get(r, "session-name")
    
    session.Values["authenticated"] = false
    session.Options.MaxAge = -1
    
    return session.Save(r, w)
}
```

---

### Redis Session

```go
import "github.com/go-redis/redis/v8"

type RedisSessionStore struct {
    client *redis.Client
}

func NewRedisSessionStore(addr string) *RedisSessionStore {
    client := redis.NewClient(&redis.Options{
        Addr: addr,
    })
    
    return &RedisSessionStore{client: client}
}

// 创建Session
func (s *RedisSessionStore) Create(ctx context.Context, sessionID, userID string) error {
    data := map[string]interface{}{
        "user_id":       userID,
        "authenticated": true,
        "created_at":    time.Now().Unix(),
    }
    
    return s.client.HSet(ctx, "session:"+sessionID, data).Err()
}

// 获取Session
func (s *RedisSessionStore) Get(ctx context.Context, sessionID string) (string, error) {
    userID, err := s.client.HGet(ctx, "session:"+sessionID, "user_id").Result()
    if err != nil {
        return "", err
    }
    
    // 延长过期时间
    s.client.Expire(ctx, "session:"+sessionID, 24*time.Hour)
    
    return userID, nil
}

// 删除Session
func (s *RedisSessionStore) Delete(ctx context.Context, sessionID string) error {
    return s.client.Del(ctx, "session:"+sessionID).Err()
}
```

---

## 6. 最佳实践

### 1. 安全的Token存储

```go
// ✅ 推荐：HttpOnly Cookie
func setTokenCookie(w http.ResponseWriter, token string) {
    cookie := &http.Cookie{
        Name:     "token",
        Value:    token,
        Path:     "/",
        MaxAge:   3600 * 24,
        HttpOnly: true,  // 防止XSS
        Secure:   true,  // 仅HTTPS
        SameSite: http.SameSiteStrictMode,  // 防止CSRF
    }
    http.SetCookie(w, cookie)
}

// ❌ 不推荐：LocalStorage（易受XSS攻击）
```

---

### 2. Token刷新机制

```go
type TokenPair struct {
    AccessToken  string `json:"access_token"`
    RefreshToken string `json:"refresh_token"`
}

func GenerateTokenPair(userID, username string) (*TokenPair, error) {
    // 短期访问Token（15分钟）
    accessClaims := &Claims{
        UserID:   userID,
        Username: username,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(15 * time.Minute)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
        },
    }
    
    accessToken := jwt.NewWithClaims(jwt.SigningMethodHS256, accessClaims)
    accessTokenString, _ := accessToken.SignedString(jwtSecret)
    
    // 长期刷新Token（7天）
    refreshClaims := &Claims{
        UserID:   userID,
        Username: username,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(7 * 24 * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
        },
    }
    
    refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshClaims)
    refreshTokenString, _ := refreshToken.SignedString(jwtSecret)
    
    return &TokenPair{
        AccessToken:  accessTokenString,
        RefreshToken: refreshTokenString,
    }, nil
}
```

---

### 3. 防止暴力破解

```go
import "golang.org/x/time/rate"

type LoginRateLimiter struct {
    limiters map[string]*rate.Limiter
    mu       sync.RWMutex
}

func NewLoginRateLimiter() *LoginRateLimiter {
    return &LoginRateLimiter{
        limiters: make(map[string]*rate.Limiter),
    }
}

func (l *LoginRateLimiter) GetLimiter(ip string) *rate.Limiter {
    l.mu.Lock()
    defer l.mu.Unlock()
    
    limiter, exists := l.limiters[ip]
    if !exists {
        // 每分钟最多5次登录尝试
        limiter = rate.NewLimiter(rate.Every(time.Minute/5), 5)
        l.limiters[ip] = limiter
    }
    
    return limiter
}

func (l *LoginRateLimiter) Allow(ip string) bool {
    return l.GetLimiter(ip).Allow()
}

// 使用
func loginHandler(w http.ResponseWriter, r *http.Request) {
    ip := getClientIP(r)
    
    if !rateLimiter.Allow(ip) {
        http.Error(w, "Too many login attempts", http.StatusTooManyRequests)
        return
    }
    
    // 处理登录
}
```

---

### 4. 多因素认证（2FA）

```go
import "github.com/pquerna/otp/totp"

// 生成2FA密钥
func Generate2FA(username string) (string, string, error) {
    key, err := totp.Generate(totp.GenerateOpts{
        Issuer:      "MyApp",
        AccountName: username,
    })
    if err != nil {
        return "", "", err
    }
    
    return key.Secret(), key.URL(), nil
}

// 验证2FA代码
func Verify2FA(secret, code string) bool {
    return totp.Validate(code, secret)
}

// 登录流程
func loginWith2FA(username, password, code string) (*User, error) {
    // 验证密码
    user, err := login(username, password)
    if err != nil {
        return nil, err
    }
    
    // 如果启用2FA，验证代码
    if user.TwoFactorEnabled {
        if !Verify2FA(user.TwoFactorSecret, code) {
            return nil, errors.New("invalid 2FA code")
        }
    }
    
    return user, nil
}
```

---

## 🔗 相关资源

- [数据加密](./02-数据加密.md)
- [安全最佳实践](./04-安全最佳实践.md)
- [审计日志](./05-审计日志.md)

---

**最后更新**: 2025-10-28  
**Go版本**: 1.25.3

