# Goè®¤è¯æˆæƒ

> **ç®€ä»‹**: Goè®¤è¯æˆæƒå®Œæ•´æŒ‡å—ï¼ŒåŒ…æ‹¬JWTã€OAuth2ã€RBACå’Œæœ€ä½³å®è·µ

> **ç‰ˆæœ¬**: Go 1.25.3  
> **éš¾åº¦**: â­â­â­â­  
> **æ ‡ç­¾**: #å®‰å…¨ #è®¤è¯ #æˆæƒ #JWT

---

## ğŸ“‹ ç›®å½•

- [1. è®¤è¯åŸºç¡€](#1-è®¤è¯åŸºç¡€)
  - [åŸºæœ¬è®¤è¯æµç¨‹](#åŸºæœ¬è®¤è¯æµç¨‹)
  - [å¯†ç å“ˆå¸Œ](#å¯†ç å“ˆå¸Œ)
- [2. JWTå®ç°](#2-jwtå®ç°)
  - [JWTç»“æ„](#jwtç»“æ„)
  - [JWTç”Ÿæˆå’ŒéªŒè¯](#jwtç”Ÿæˆå’ŒéªŒè¯)
  - [JWTä¸­é—´ä»¶](#jwtä¸­é—´ä»¶)
- [3. OAuth2](#3-oauth2)
  - [OAuth2æµç¨‹](#oauth2æµç¨‹)
  - [OAuth2å®¢æˆ·ç«¯å®ç°](#oauth2å®¢æˆ·ç«¯å®ç°)
- [4. RBACæƒé™æ§åˆ¶](#4-rbacæƒé™æ§åˆ¶)
  - [æƒé™æ¨¡å‹](#æƒé™æ¨¡å‹)
  - [RBACå®ç°](#rbacå®ç°)
  - [RBACä¸­é—´ä»¶](#rbacä¸­é—´ä»¶)
- [5. Sessionç®¡ç†](#5-sessionç®¡ç†)
  - [Sessionå­˜å‚¨](#sessionå­˜å‚¨)
  - [Redis Session](#redis-session)
- [6. æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)
  - [1. å®‰å…¨çš„Tokenå­˜å‚¨](#1-å®‰å…¨çš„tokenå­˜å‚¨)
  - [2. Tokenåˆ·æ–°æœºåˆ¶](#2-tokenåˆ·æ–°æœºåˆ¶)
  - [3. é˜²æ­¢æš´åŠ›ç ´è§£](#3-é˜²æ­¢æš´åŠ›ç ´è§£)
  - [4. å¤šå› ç´ è®¤è¯ï¼ˆ2FAï¼‰](#4-å¤šå› ç´ è®¤è¯2fa)
- [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

## 1. è®¤è¯åŸºç¡€

### åŸºæœ¬è®¤è¯æµç¨‹

```
1. ç”¨æˆ·æäº¤å‡­è¯ï¼ˆç”¨æˆ·å/å¯†ç ï¼‰
2. æœåŠ¡å™¨éªŒè¯å‡­è¯
3. ç”ŸæˆToken
4. è¿”å›Tokenç»™å®¢æˆ·ç«¯
5. å®¢æˆ·ç«¯åœ¨åç»­è¯·æ±‚ä¸­æºå¸¦Token
6. æœåŠ¡å™¨éªŒè¯Token
```

---

### å¯†ç å“ˆå¸Œ

```go
import "golang.org/x/crypto/bcrypt"

// ç”Ÿæˆå¯†ç å“ˆå¸Œ
func HashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return "", err
    }
    return string(bytes), nil
}

// éªŒè¯å¯†ç 
func CheckPassword(password, hash string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}

// ä½¿ç”¨ç¤ºä¾‹
func registerUser(username, password string) error {
    hash, err := HashPassword(password)
    if err != nil {
        return err
    }
    
    user := &User{
        Username:     username,
        PasswordHash: hash,
    }
    
    return saveUser(user)
}

func login(username, password string) (*User, error) {
    user, err := findUserByUsername(username)
    if err != nil {
        return nil, err
    }
    
    if !CheckPassword(password, user.PasswordHash) {
        return nil, errors.New("invalid credentials")
    }
    
    return user, nil
}
```

---

## 2. JWTå®ç°

### JWTç»“æ„

```
Header.Payload.Signature

Header: {"alg": "HS256", "typ": "JWT"}
Payload: {"sub": "123", "name": "Alice", "exp": 1735401600}
Signature: HMACSHA256(base64(header) + "." + base64(payload), secret)
```

---

### JWTç”Ÿæˆå’ŒéªŒè¯

```go
import "github.com/golang-jwt/jwt/v5"

var jwtSecret = []byte("your-secret-key")

type Claims struct {
    UserID   string `json:"user_id"`
    Username string `json:"username"`
    jwt.RegisteredClaims
}

// ç”ŸæˆJWT Token
func GenerateToken(userID, username string) (string, error) {
    claims := &Claims{
        UserID:   userID,
        Username: username,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
            Issuer:    "myapp",
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(jwtSecret)
}

// éªŒè¯JWT Token
func ValidateToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        // éªŒè¯ç­¾åç®—æ³•
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
        }
        return jwtSecret, nil
    })
    
    if err != nil {
        return nil, err
    }
    
    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }
    
    return nil, errors.New("invalid token")
}

// åˆ·æ–°Token
func RefreshToken(tokenString string) (string, error) {
    claims, err := ValidateToken(tokenString)
    if err != nil {
        return "", err
    }
    
    // æ£€æŸ¥æ˜¯å¦å³å°†è¿‡æœŸï¼ˆä¾‹å¦‚ï¼Œå‰©ä½™æ—¶é—´å°äº1å°æ—¶ï¼‰
    if time.Until(claims.ExpiresAt.Time) > time.Hour {
        return tokenString, nil
    }
    
    // ç”Ÿæˆæ–°Token
    return GenerateToken(claims.UserID, claims.Username)
}
```

---

### JWTä¸­é—´ä»¶

```go
func AuthMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // ä»Headerè·å–Token
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" {
            http.Error(w, "Authorization header required", http.StatusUnauthorized)
            return
        }
        
        // è§£æBearer Token
        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
        if tokenString == authHeader {
            http.Error(w, "Bearer token required", http.StatusUnauthorized)
            return
        }
        
        // éªŒè¯Token
        claims, err := ValidateToken(tokenString)
        if err != nil {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }
        
        // å°†ç”¨æˆ·ä¿¡æ¯å­˜å…¥Context
        ctx := context.WithValue(r.Context(), "user_id", claims.UserID)
        ctx = context.WithValue(ctx, "username", claims.Username)
        
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// ä½¿ç”¨
func main() {
    mux := http.NewServeMux()
    
    // å…¬å¼€è·¯ç”±
    mux.HandleFunc("/login", loginHandler)
    mux.HandleFunc("/register", registerHandler)
    
    // å—ä¿æŠ¤è·¯ç”±
    protected := http.NewServeMux()
    protected.HandleFunc("/profile", profileHandler)
    protected.HandleFunc("/orders", ordersHandler)
    
    mux.Handle("/api/", http.StripPrefix("/api", AuthMiddleware(protected)))
    
    http.ListenAndServe(":8080", mux)
}
```

---

## 3. OAuth2

### OAuth2æµç¨‹

```
1. ç”¨æˆ·ç‚¹å‡»"ä½¿ç”¨XXç™»å½•"
2. é‡å®šå‘åˆ°OAuthæä¾›å•†
3. ç”¨æˆ·æˆæƒ
4. é‡å®šå‘å›åº”ç”¨ï¼Œå¸¦ä¸Šæˆæƒç 
5. åº”ç”¨ç”¨æˆæƒç æ¢å–è®¿é—®ä»¤ç‰Œ
6. ä½¿ç”¨è®¿é—®ä»¤ç‰Œè®¿é—®èµ„æº
```

---

### OAuth2å®¢æˆ·ç«¯å®ç°

```go
import "golang.org/x/oauth2"
import "golang.org/x/oauth2/google"

var oauth2Config = &oauth2.Config{
    ClientID:     "your-client-id",
    ClientSecret: "your-client-secret",
    RedirectURL:  "http://localhost:8080/callback",
    Scopes: []string{
        "https://www.googleapis.com/auth/userinfo.email",
        "https://www.googleapis.com/auth/userinfo.profile",
    },
    Endpoint: google.Endpoint,
}

// ç”ŸæˆæˆæƒURL
func handleLogin(w http.ResponseWriter, r *http.Request) {
    state := generateRandomState() // é˜²CSRF
    url := oauth2Config.AuthCodeURL(state, oauth2.AccessTypeOffline)
    http.Redirect(w, r, url, http.StatusTemporaryRedirect)
}

// å¤„ç†å›è°ƒ
func handleCallback(w http.ResponseWriter, r *http.Request) {
    // éªŒè¯state
    state := r.URL.Query().Get("state")
    if !validateState(state) {
        http.Error(w, "Invalid state", http.StatusBadRequest)
        return
    }
    
    // è·å–æˆæƒç 
    code := r.URL.Query().Get("code")
    
    // äº¤æ¢Token
    token, err := oauth2Config.Exchange(context.Background(), code)
    if err != nil {
        http.Error(w, "Failed to exchange token", http.StatusInternalServerError)
        return
    }
    
    // è·å–ç”¨æˆ·ä¿¡æ¯
    client := oauth2Config.Client(context.Background(), token)
    resp, err := client.Get("https://www.googleapis.com/oauth2/v2/userinfo")
    if err != nil {
        http.Error(w, "Failed to get user info", http.StatusInternalServerError)
        return
    }
    defer resp.Body.Close()
    
    var userInfo map[string]interface{}
    json.NewDecoder(resp.Body).Decode(&userInfo)
    
    // åˆ›å»ºæˆ–æ›´æ–°ç”¨æˆ·
    user := createOrUpdateUser(userInfo)
    
    // ç”ŸæˆJWT Token
    jwtToken, _ := GenerateToken(user.ID, user.Username)
    
    // è¿”å›Token
    json.NewEncoder(w).Encode(map[string]string{
        "token": jwtToken,
    })
}
```

---

## 4. RBACæƒé™æ§åˆ¶

### æƒé™æ¨¡å‹

```go
type Role struct {
    ID          string
    Name        string
    Permissions []string
}

type User struct {
    ID       string
    Username string
    Roles    []string
}

type Permission struct {
    Resource string // èµ„æºï¼Œå¦‚ "users", "orders"
    Action   string // æ“ä½œï¼Œå¦‚ "read", "write", "delete"
}
```

---

### RBACå®ç°

```go
type RBACService struct {
    roles map[string]*Role
}

func NewRBACService() *RBACService {
    return &RBACService{
        roles: map[string]*Role{
            "admin": {
                ID:   "admin",
                Name: "Administrator",
                Permissions: []string{
                    "users:read", "users:write", "users:delete",
                    "orders:read", "orders:write", "orders:delete",
                    "products:read", "products:write", "products:delete",
                },
            },
            "user": {
                ID:   "user",
                Name: "Regular User",
                Permissions: []string{
                    "orders:read", "orders:write",
                    "products:read",
                },
            },
            "guest": {
                ID:   "guest",
                Name: "Guest",
                Permissions: []string{
                    "products:read",
                },
            },
        },
    }
}

// æ£€æŸ¥æƒé™
func (s *RBACService) HasPermission(user *User, resource, action string) bool {
    permission := fmt.Sprintf("%s:%s", resource, action)
    
    for _, roleID := range user.Roles {
        role, exists := s.roles[roleID]
        if !exists {
            continue
        }
        
        for _, p := range role.Permissions {
            if p == permission || p == fmt.Sprintf("%s:*", resource) || p == "*:*" {
                return true
            }
        }
    }
    
    return false
}

// æ·»åŠ è§’è‰²
func (s *RBACService) AddRole(role *Role) {
    s.roles[role.ID] = role
}

// æ·»åŠ æƒé™åˆ°è§’è‰²
func (s *RBACService) AddPermissionToRole(roleID, permission string) error {
    role, exists := s.roles[roleID]
    if !exists {
        return errors.New("role not found")
    }
    
    role.Permissions = append(role.Permissions, permission)
    return nil
}
```

---

### RBACä¸­é—´ä»¶

```go
func RequirePermission(resource, action string) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // ä»Contextè·å–ç”¨æˆ·
            userID := r.Context().Value("user_id").(string)
            user, err := getUserByID(userID)
            if err != nil {
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
            }
            
            // æ£€æŸ¥æƒé™
            if !rbacService.HasPermission(user, resource, action) {
                http.Error(w, "Forbidden", http.StatusForbidden)
                return
            }
            
            next.ServeHTTP(w, r)
        })
    }
}

// ä½¿ç”¨
func main() {
    mux := http.NewServeMux()
    
    // éœ€è¦è¯»å–ç”¨æˆ·æƒé™
    mux.Handle("/api/users", 
        AuthMiddleware(
            RequirePermission("users", "read")(
                http.HandlerFunc(listUsersHandler),
            ),
        ),
    )
    
    // éœ€è¦åˆ é™¤ç”¨æˆ·æƒé™
    mux.Handle("/api/users/delete", 
        AuthMiddleware(
            RequirePermission("users", "delete")(
                http.HandlerFunc(deleteUserHandler),
            ),
        ),
    )
    
    http.ListenAndServe(":8080", mux)
}
```

---

## 5. Sessionç®¡ç†

### Sessionå­˜å‚¨

```go
import "github.com/gorilla/sessions"

var store = sessions.NewCookieStore([]byte("your-secret-key"))

// åˆ›å»ºSession
func createSession(w http.ResponseWriter, r *http.Request, userID string) error {
    session, _ := store.Get(r, "session-name")
    
    session.Values["user_id"] = userID
    session.Values["authenticated"] = true
    session.Options = &sessions.Options{
        Path:     "/",
        MaxAge:   3600 * 24, // 24å°æ—¶
        HttpOnly: true,
        Secure:   true,
        SameSite: http.SameSiteStrictMode,
    }
    
    return session.Save(r, w)
}

// è·å–Session
func getSession(r *http.Request) (string, bool) {
    session, _ := store.Get(r, "session-name")
    
    if auth, ok := session.Values["authenticated"].(bool); !ok || !auth {
        return "", false
    }
    
    userID, ok := session.Values["user_id"].(string)
    return userID, ok
}

// é”€æ¯Session
func destroySession(w http.ResponseWriter, r *http.Request) error {
    session, _ := store.Get(r, "session-name")
    
    session.Values["authenticated"] = false
    session.Options.MaxAge = -1
    
    return session.Save(r, w)
}
```

---

### Redis Session

```go
import "github.com/go-redis/redis/v8"

type RedisSessionStore struct {
    client *redis.Client
}

func NewRedisSessionStore(addr string) *RedisSessionStore {
    client := redis.NewClient(&redis.Options{
        Addr: addr,
    })
    
    return &RedisSessionStore{client: client}
}

// åˆ›å»ºSession
func (s *RedisSessionStore) Create(ctx context.Context, sessionID, userID string) error {
    data := map[string]interface{}{
        "user_id":       userID,
        "authenticated": true,
        "created_at":    time.Now().Unix(),
    }
    
    return s.client.HSet(ctx, "session:"+sessionID, data).Err()
}

// è·å–Session
func (s *RedisSessionStore) Get(ctx context.Context, sessionID string) (string, error) {
    userID, err := s.client.HGet(ctx, "session:"+sessionID, "user_id").Result()
    if err != nil {
        return "", err
    }
    
    // å»¶é•¿è¿‡æœŸæ—¶é—´
    s.client.Expire(ctx, "session:"+sessionID, 24*time.Hour)
    
    return userID, nil
}

// åˆ é™¤Session
func (s *RedisSessionStore) Delete(ctx context.Context, sessionID string) error {
    return s.client.Del(ctx, "session:"+sessionID).Err()
}
```

---

## 6. æœ€ä½³å®è·µ

### 1. å®‰å…¨çš„Tokenå­˜å‚¨

```go
// âœ… æ¨èï¼šHttpOnly Cookie
func setTokenCookie(w http.ResponseWriter, token string) {
    cookie := &http.Cookie{
        Name:     "token",
        Value:    token,
        Path:     "/",
        MaxAge:   3600 * 24,
        HttpOnly: true,  // é˜²æ­¢XSS
        Secure:   true,  // ä»…HTTPS
        SameSite: http.SameSiteStrictMode,  // é˜²æ­¢CSRF
    }
    http.SetCookie(w, cookie)
}

// âŒ ä¸æ¨èï¼šLocalStorageï¼ˆæ˜“å—XSSæ”»å‡»ï¼‰
```

---

### 2. Tokenåˆ·æ–°æœºåˆ¶

```go
type TokenPair struct {
    AccessToken  string `json:"access_token"`
    RefreshToken string `json:"refresh_token"`
}

func GenerateTokenPair(userID, username string) (*TokenPair, error) {
    // çŸ­æœŸè®¿é—®Tokenï¼ˆ15åˆ†é’Ÿï¼‰
    accessClaims := &Claims{
        UserID:   userID,
        Username: username,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(15 * time.Minute)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
        },
    }
    
    accessToken := jwt.NewWithClaims(jwt.SigningMethodHS256, accessClaims)
    accessTokenString, _ := accessToken.SignedString(jwtSecret)
    
    // é•¿æœŸåˆ·æ–°Tokenï¼ˆ7å¤©ï¼‰
    refreshClaims := &Claims{
        UserID:   userID,
        Username: username,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(7 * 24 * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
        },
    }
    
    refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshClaims)
    refreshTokenString, _ := refreshToken.SignedString(jwtSecret)
    
    return &TokenPair{
        AccessToken:  accessTokenString,
        RefreshToken: refreshTokenString,
    }, nil
}
```

---

### 3. é˜²æ­¢æš´åŠ›ç ´è§£

```go
import "golang.org/x/time/rate"

type LoginRateLimiter struct {
    limiters map[string]*rate.Limiter
    mu       sync.RWMutex
}

func NewLoginRateLimiter() *LoginRateLimiter {
    return &LoginRateLimiter{
        limiters: make(map[string]*rate.Limiter),
    }
}

func (l *LoginRateLimiter) GetLimiter(ip string) *rate.Limiter {
    l.mu.Lock()
    defer l.mu.Unlock()
    
    limiter, exists := l.limiters[ip]
    if !exists {
        // æ¯åˆ†é’Ÿæœ€å¤š5æ¬¡ç™»å½•å°è¯•
        limiter = rate.NewLimiter(rate.Every(time.Minute/5), 5)
        l.limiters[ip] = limiter
    }
    
    return limiter
}

func (l *LoginRateLimiter) Allow(ip string) bool {
    return l.GetLimiter(ip).Allow()
}

// ä½¿ç”¨
func loginHandler(w http.ResponseWriter, r *http.Request) {
    ip := getClientIP(r)
    
    if !rateLimiter.Allow(ip) {
        http.Error(w, "Too many login attempts", http.StatusTooManyRequests)
        return
    }
    
    // å¤„ç†ç™»å½•
}
```

---

### 4. å¤šå› ç´ è®¤è¯ï¼ˆ2FAï¼‰

```go
import "github.com/pquerna/otp/totp"

// ç”Ÿæˆ2FAå¯†é’¥
func Generate2FA(username string) (string, string, error) {
    key, err := totp.Generate(totp.GenerateOpts{
        Issuer:      "MyApp",
        AccountName: username,
    })
    if err != nil {
        return "", "", err
    }
    
    return key.Secret(), key.URL(), nil
}

// éªŒè¯2FAä»£ç 
func Verify2FA(secret, code string) bool {
    return totp.Validate(code, secret)
}

// ç™»å½•æµç¨‹
func loginWith2FA(username, password, code string) (*User, error) {
    // éªŒè¯å¯†ç 
    user, err := login(username, password)
    if err != nil {
        return nil, err
    }
    
    // å¦‚æœå¯ç”¨2FAï¼ŒéªŒè¯ä»£ç 
    if user.TwoFactorEnabled {
        if !Verify2FA(user.TwoFactorSecret, code) {
            return nil, errors.New("invalid 2FA code")
        }
    }
    
    return user, nil
}
```

---

## ğŸ”— ç›¸å…³èµ„æº

- [æ•°æ®åŠ å¯†](./02-æ•°æ®åŠ å¯†.md)
- [å®‰å…¨æœ€ä½³å®è·µ](./04-å®‰å…¨æœ€ä½³å®è·µ.md)
- [å®¡è®¡æ—¥å¿—](./05-å®¡è®¡æ—¥å¿—.md)

---

**æœ€åæ›´æ–°**: 2025-10-28  
**Goç‰ˆæœ¬**: 1.25.3

