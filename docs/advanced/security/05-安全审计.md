# 安全审计

**版本**: v1.0
**更新日期**: 2025-10-29
**适用于**: Go 1.25.3

---
## 📋 目录

- [安全审计](#安全审计)
  - [1. 📖 概念介绍](#1-概念介绍)
  - [2. 📝 审计日志](#2-审计日志)
  - [🔍 审计中间件](#审计中间件)
  - [📊 异常行为检测](#异常行为检测)
  - [🛡️ 合规性检查](#️-合规性检查)
  - [📈 审计报告](#审计报告)
  - [🔐 敏感操作追踪](#敏感操作追踪)
  - [💡 日志聚合与分析](#日志聚合与分析)
  - [3. 📚 相关资源](#3-相关资源)

---

## 1. 📖 概念介绍

安全审计记录和分析系统中的安全相关事件，帮助检测和响应安全威胁。

---

## 2. 📝 审计日志

```go
package audit

import (
    "encoding/json"
    "log"
    "time"
)

// 审计事件
type AuditEvent struct {
    Timestamp time.Time `json:"timestamp"`
    UserID    string    `json:"user_id"`
    Action    string    `json:"action"`
    Resource  string    `json:"resource"`
    IP        string    `json:"ip"`
    Status    string    `json:"status"`
    Details   string    `json:"details"`
}

// 审计日志记录器
type AuditLogger struct {
    logger *log.Logger
}

func NewAuditLogger() *AuditLogger {
    return &AuditLogger{
        logger: log.New(os.Stdout, "[AUDIT] ", log.LstdFlags),
    }
}

func (al *AuditLogger) Log(event AuditEvent) {
    event.Timestamp = time.Now()

    jsonData, _ := json.Marshal(event)
    al.logger.Println(string(jsonData))
}

// 使用示例
func loginHandler(w http.ResponseWriter, r *http.Request, auditor *AuditLogger) {
    username := r.FormValue("username")
    password := r.FormValue("password")

    if checkCredentials(username, password) {
        auditor.Log(AuditEvent{
            UserID:   username,
            Action:   "login",
            Resource: "auth",
            IP:       r.RemoteAddr,
            Status:   "success",
        })

        // 登录成功逻辑...
    } else {
        auditor.Log(AuditEvent{
            UserID:   username,
            Action:   "login",
            Resource: "auth",
            IP:       r.RemoteAddr,
            Status:   "failed",
            Details:  "invalid credentials",
        })

        http.Error(w, "Unauthorized", http.StatusUnauthorized)
    }
}
```

---

## 🔍 审计中间件

```go
func AuditMiddleware(auditor *AuditLogger) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()

            // 记录请求
            userID := r.Context().Value("userID")
            if userID == nil {
                userID = "anonymous"
            }

            // 创建响应记录器
            recorder := &responseRecorder{
                ResponseWriter: w,
                statusCode:     http.StatusOK,
            }

            // 处理请求
            next.ServeHTTP(recorder, r)

            // 记录审计日志
            auditor.Log(AuditEvent{
                UserID:   userID.(string),
                Action:   r.Method,
                Resource: r.URL.Path,
                IP:       r.RemoteAddr,
                Status:   http.StatusText(recorder.statusCode),
                Details:  fmt.Sprintf("duration=%v", time.Since(start)),
            })
        })
    }
}

type responseRecorder struct {
    http.ResponseWriter
    statusCode int
}

func (rr *responseRecorder) WriteHeader(code int) {
    rr.statusCode = code
    rr.ResponseWriter.WriteHeader(code)
}
```

---

## 📊 异常行为检测

```go
type SecurityMonitor struct {
    failedLogins map[string]int
    mu           sync.RWMutex
}

func NewSecurityMonitor() *SecurityMonitor {
    return &SecurityMonitor{
        failedLogins: make(map[string]int),
    }
}

// 记录失败的登录
func (sm *SecurityMonitor) RecordFailedLogin(ip string) {
    sm.mu.Lock()
    defer sm.mu.Unlock()

    sm.failedLogins[ip]++

    // 检测暴力破解
    if sm.failedLogins[ip] >= 5 {
        sm.alertBruteForce(ip)
    }
}

func (sm *SecurityMonitor) alertBruteForce(ip string) {
    log.Printf("SECURITY ALERT: Possible brute force attack from %s", ip)
    // 发送告警通知...
}

// 检测异常访问模式
func (sm *SecurityMonitor) DetectAnomalies(events []AuditEvent) []string {
    var anomalies []string

    // 检测非工作时间的大量操作
    for _, event := range events {
        hour := event.Timestamp.Hour()
        if hour < 6 || hour > 22 {
            anomalies = append(anomalies,
                fmt.Sprintf("Off-hours activity: %s at %v",
                    event.Action, event.Timestamp))
        }
    }

    return anomalies
}
```

---

## 🛡️ 合规性检查

```go
// GDPR合规性检查
type GDPRCompliance struct {
    dataRetention time.Duration
}

func (gc *GDPRCompliance) CheckCompliance(userID string, db *sql.DB) error {
    // 检查数据保留期限
    var lastActivity time.Time
    err := db.QueryRow(
        "SELECT last_activity FROM users WHERE id = ?",
        userID,
    ).Scan(&lastActivity)

    if err != nil {
        return err
    }

    if time.Since(lastActivity) > gc.dataRetention {
        // 数据应该被删除
        return fmt.Errorf("data retention policy violated for user %s", userID)
    }

    return nil
}

// 审计用户数据访问
func (gc *GDPRCompliance) AuditDataAccess(userID, accessor string) {
    log.Printf("DATA ACCESS: User %s data accessed by %s", userID, accessor)
}
```

---

## 📈 审计报告

```go
type AuditReport struct {
    Period      string
    TotalEvents int
    ByAction    map[string]int
    ByStatus    map[string]int
    TopUsers    []UserActivity
}

type UserActivity struct {
    UserID      string
    ActionCount int
}

func GenerateAuditReport(events []AuditEvent) *AuditReport {
    report := &AuditReport{
        ByAction: make(map[string]int),
        ByStatus: make(map[string]int),
    }

    userActions := make(map[string]int)

    for _, event := range events {
        report.TotalEvents++
        report.ByAction[event.Action]++
        report.ByStatus[event.Status]++
        userActions[event.UserID]++
    }

    // 提取Top用户
    for userID, count := range userActions {
        report.TopUsers = append(report.TopUsers, UserActivity{
            UserID:      userID,
            ActionCount: count,
        })
    }

    // 排序
    sort.Slice(report.TopUsers, func(i, j int) bool {
        return report.TopUsers[i].ActionCount > report.TopUsers[j].ActionCount
    })

    if len(report.TopUsers) > 10 {
        report.TopUsers = report.TopUsers[:10]
    }

    return report
}
```

---

## 🔐 敏感操作追踪

```go
// 关键操作审计
func AuditCriticalOperation(operation string, details map[string]interface{}) {
    event := map[string]interface{}{
        "timestamp": time.Now(),
        "operation": operation,
        "details":   details,
    }

    // 写入专用的审计日志
    writeToAuditDB(event)

    // 发送实时告警
    if isCritical(operation) {
        sendAlert(event)
    }
}

// 使用示例
func deleteUserHandler(w http.ResponseWriter, r *http.Request) {
    userID := mux.Vars(r)["id"]
    adminID := r.Context().Value("userID").(string)

    // 执行删除
    if err := deleteUser(userID); err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    // 审计关键操作
    AuditCriticalOperation("user_deletion", map[string]interface{}{
        "deleted_user_id": userID,
        "admin_id":        adminID,
        "ip":              r.RemoteAddr,
    })

    w.WriteHeader(http.StatusNoContent)
}
```

---

## 💡 日志聚合与分析

```go
// 集成ELK Stack
import (
    "github.com/olivere/elastic/v7"
)

type ElasticLogger struct {
    client *elastic.Client
    index  string
}

func NewElasticLogger(url, index string) (*ElasticLogger, error) {
    client, err := elastic.NewClient(elastic.SetURL(url))
    if err != nil {
        return nil, err
    }

    return &ElasticLogger{
        client: client,
        index:  index,
    }, nil
}

func (el *ElasticLogger) LogEvent(event AuditEvent) error {
    ctx := Context.Background()
    _, err := el.client.Index().
        Index(el.index).
        BodyJson(event).
        Do(ctx)

    return err
}

// 查询审计日志
func (el *ElasticLogger) QueryEvents(userID string, from, to time.Time) ([]AuditEvent, error) {
    ctx := Context.Background()

    query := elastic.NewBoolQuery().
        Must(elastic.NewTermQuery("user_id", userID)).
        Filter(elastic.NewRangeQuery("timestamp").
            Gte(from).
            Lte(to))

    results, err := el.client.Search().
        Index(el.index).
        Query(query).
        Do(ctx)

    if err != nil {
        return nil, err
    }

    var events []AuditEvent
    for _, hit := range results.Hits.Hits {
        var event AuditEvent
        json.Unmarshal(hit.Source, &event)
        events = append(events, event)
    }

    return events, nil
}
```

---

## 3. 📚 相关资源
