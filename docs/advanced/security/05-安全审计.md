# 安全审计

**难度**: 中级 | **预计阅读**: 15分钟 | **前置知识**: 日志、监控

---

## 📋 目录

- [1. 📖 概念介绍](#1--概念介绍)
- [2. 📝 审计日志](#2--审计日志)
- [3. 📚 相关资源](#3--相关资源)

---

## 1. 📖 概念介绍

安全审计记录和分析系统中的安全相关事件，帮助检测和响应安全威胁。

---

## 2. 📝 审计日志

```go
package audit

import (
    "encoding/json"
    "log"
    "time"
)

// 审计事件
type AuditEvent struct {
    Timestamp time.Time `json:"timestamp"`
    UserID    string    `json:"user_id"`
    Action    string    `json:"action"`
    Resource  string    `json:"resource"`
    IP        string    `json:"ip"`
    Status    string    `json:"status"`
    Details   string    `json:"details"`
}

// 审计日志记录器
type AuditLogger struct {
    logger *log.Logger
}

func NewAuditLogger() *AuditLogger {
    return &AuditLogger{
        logger: log.New(os.Stdout, "[AUDIT] ", log.LstdFlags),
    }
}

func (al *AuditLogger) Log(event AuditEvent) {
    event.Timestamp = time.Now()
    
    jsonData, _ := json.Marshal(event)
    al.logger.Println(string(jsonData))
}

// 使用示例
func loginHandler(w http.ResponseWriter, r *http.Request, auditor *AuditLogger) {
    username := r.FormValue("username")
    password := r.FormValue("password")
    
    if checkCredentials(username, password) {
        auditor.Log(AuditEvent{
            UserID:   username,
            Action:   "login",
            Resource: "auth",
            IP:       r.RemoteAddr,
            Status:   "success",
        })
        
        // 登录成功逻辑...
    } else {
        auditor.Log(AuditEvent{
            UserID:   username,
            Action:   "login",
            Resource: "auth",
            IP:       r.RemoteAddr,
            Status:   "failed",
            Details:  "invalid credentials",
        })
        
        http.Error(w, "Unauthorized", http.StatusUnauthorized)
    }
}
```

---

## 🔍 审计中间件

```go
func AuditMiddleware(auditor *AuditLogger) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()
            
            // 记录请求
            userID := r.Context().Value("userID")
            if userID == nil {
                userID = "anonymous"
            }
            
            // 创建响应记录器
            recorder := &responseRecorder{
                ResponseWriter: w,
                statusCode:     http.StatusOK,
            }
            
            // 处理请求
            next.ServeHTTP(recorder, r)
            
            // 记录审计日志
            auditor.Log(AuditEvent{
                UserID:   userID.(string),
                Action:   r.Method,
                Resource: r.URL.Path,
                IP:       r.RemoteAddr,
                Status:   http.StatusText(recorder.statusCode),
                Details:  fmt.Sprintf("duration=%v", time.Since(start)),
            })
        })
    }
}

type responseRecorder struct {
    http.ResponseWriter
    statusCode int
}

func (rr *responseRecorder) WriteHeader(code int) {
    rr.statusCode = code
    rr.ResponseWriter.WriteHeader(code)
}
```

---

## 📊 异常行为检测

```go
type SecurityMonitor struct {
    failedLogins map[string]int
    mu           sync.RWMutex
}

func NewSecurityMonitor() *SecurityMonitor {
    return &SecurityMonitor{
        failedLogins: make(map[string]int),
    }
}

// 记录失败的登录
func (sm *SecurityMonitor) RecordFailedLogin(ip string) {
    sm.mu.Lock()
    defer sm.mu.Unlock()
    
    sm.failedLogins[ip]++
    
    // 检测暴力破解
    if sm.failedLogins[ip] >= 5 {
        sm.alertBruteForce(ip)
    }
}

func (sm *SecurityMonitor) alertBruteForce(ip string) {
    log.Printf("SECURITY ALERT: Possible brute force attack from %s", ip)
    // 发送告警通知...
}

// 检测异常访问模式
func (sm *SecurityMonitor) DetectAnomalies(events []AuditEvent) []string {
    var anomalies []string
    
    // 检测非工作时间的大量操作
    for _, event := range events {
        hour := event.Timestamp.Hour()
        if hour < 6 || hour > 22 {
            anomalies = append(anomalies, 
                fmt.Sprintf("Off-hours activity: %s at %v", 
                    event.Action, event.Timestamp))
        }
    }
    
    return anomalies
}
```

---

## 🛡️ 合规性检查

```go
// GDPR合规性检查
type GDPRCompliance struct {
    dataRetention time.Duration
}

func (gc *GDPRCompliance) CheckCompliance(userID string, db *sql.DB) error {
    // 检查数据保留期限
    var lastActivity time.Time
    err := db.QueryRow(
        "SELECT last_activity FROM users WHERE id = ?", 
        userID,
    ).Scan(&lastActivity)
    
    if err != nil {
        return err
    }
    
    if time.Since(lastActivity) > gc.dataRetention {
        // 数据应该被删除
        return fmt.Errorf("data retention policy violated for user %s", userID)
    }
    
    return nil
}

// 审计用户数据访问
func (gc *GDPRCompliance) AuditDataAccess(userID, accessor string) {
    log.Printf("DATA ACCESS: User %s data accessed by %s", userID, accessor)
}
```

---

## 📈 审计报告

```go
type AuditReport struct {
    Period      string
    TotalEvents int
    ByAction    map[string]int
    ByStatus    map[string]int
    TopUsers    []UserActivity
}

type UserActivity struct {
    UserID      string
    ActionCount int
}

func GenerateAuditReport(events []AuditEvent) *AuditReport {
    report := &AuditReport{
        ByAction: make(map[string]int),
        ByStatus: make(map[string]int),
    }
    
    userActions := make(map[string]int)
    
    for _, event := range events {
        report.TotalEvents++
        report.ByAction[event.Action]++
        report.ByStatus[event.Status]++
        userActions[event.UserID]++
    }
    
    // 提取Top用户
    for userID, count := range userActions {
        report.TopUsers = append(report.TopUsers, UserActivity{
            UserID:      userID,
            ActionCount: count,
        })
    }
    
    // 排序
    sort.Slice(report.TopUsers, func(i, j int) bool {
        return report.TopUsers[i].ActionCount > report.TopUsers[j].ActionCount
    })
    
    if len(report.TopUsers) > 10 {
        report.TopUsers = report.TopUsers[:10]
    }
    
    return report
}
```

---

## 🔐 敏感操作追踪

```go
// 关键操作审计
func AuditCriticalOperation(operation string, details map[string]interface{}) {
    event := map[string]interface{}{
        "timestamp": time.Now(),
        "operation": operation,
        "details":   details,
    }
    
    // 写入专用的审计日志
    writeToAuditDB(event)
    
    // 发送实时告警
    if isCritical(operation) {
        sendAlert(event)
    }
}

// 使用示例
func deleteUserHandler(w http.ResponseWriter, r *http.Request) {
    userID := mux.Vars(r)["id"]
    adminID := r.Context().Value("userID").(string)
    
    // 执行删除
    if err := deleteUser(userID); err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    // 审计关键操作
    AuditCriticalOperation("user_deletion", map[string]interface{}{
        "deleted_user_id": userID,
        "admin_id":        adminID,
        "ip":              r.RemoteAddr,
    })
    
    w.WriteHeader(http.StatusNoContent)
}
```

---

## 💡 日志聚合与分析

```go
// 集成ELK Stack
import (
    "github.com/olivere/elastic/v7"
)

type ElasticLogger struct {
    client *elastic.Client
    index  string
}

func NewElasticLogger(url, index string) (*ElasticLogger, error) {
    client, err := elastic.NewClient(elastic.SetURL(url))
    if err != nil {
        return nil, err
    }
    
    return &ElasticLogger{
        client: client,
        index:  index,
    }, nil
}

func (el *ElasticLogger) LogEvent(event AuditEvent) error {
    ctx := context.Background()
    _, err := el.client.Index().
        Index(el.index).
        BodyJson(event).
        Do(ctx)
    
    return err
}

// 查询审计日志
func (el *ElasticLogger) QueryEvents(userID string, from, to time.Time) ([]AuditEvent, error) {
    ctx := context.Background()
    
    query := elastic.NewBoolQuery().
        Must(elastic.NewTermQuery("user_id", userID)).
        Filter(elastic.NewRangeQuery("timestamp").
            Gte(from).
            Lte(to))
    
    results, err := el.client.Search().
        Index(el.index).
        Query(query).
        Do(ctx)
    
    if err != nil {
        return nil, err
    }
    
    var events []AuditEvent
    for _, hit := range results.Hits.Hits {
        var event AuditEvent
        json.Unmarshal(hit.Source, &event)
        events = append(events, event)
    }
    
    return events, nil
}
```

---

## 3. 📚 相关资源

- [OWASP Logging Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)
- [GDPR Compliance](https://gdpr-info.eu/)

**下一步**: [06-最佳实践](./06-最佳实践.md)

---

**最后更新**: 2025-10-28

