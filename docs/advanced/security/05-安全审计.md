# å®‰å…¨å®¡è®¡

**éš¾åº¦**: ä¸­çº§ | **é¢„è®¡é˜…è¯»**: 15åˆ†é’Ÿ | **å‰ç½®çŸ¥è¯†**: æ—¥å¿—ã€ç›‘æ§

---

## ğŸ“‹ ç›®å½•

- [1. ğŸ“– æ¦‚å¿µä»‹ç»](#1--æ¦‚å¿µä»‹ç»)
- [2. ğŸ“ å®¡è®¡æ—¥å¿—](#2--å®¡è®¡æ—¥å¿—)
- [3. ğŸ“š ç›¸å…³èµ„æº](#3--ç›¸å…³èµ„æº)

---

## 1. ğŸ“– æ¦‚å¿µä»‹ç»

å®‰å…¨å®¡è®¡è®°å½•å’Œåˆ†æç³»ç»Ÿä¸­çš„å®‰å…¨ç›¸å…³äº‹ä»¶ï¼Œå¸®åŠ©æ£€æµ‹å’Œå“åº”å®‰å…¨å¨èƒã€‚

---

## 2. ğŸ“ å®¡è®¡æ—¥å¿—

```go
package audit

import (
    "encoding/json"
    "log"
    "time"
)

// å®¡è®¡äº‹ä»¶
type AuditEvent struct {
    Timestamp time.Time `json:"timestamp"`
    UserID    string    `json:"user_id"`
    Action    string    `json:"action"`
    Resource  string    `json:"resource"`
    IP        string    `json:"ip"`
    Status    string    `json:"status"`
    Details   string    `json:"details"`
}

// å®¡è®¡æ—¥å¿—è®°å½•å™¨
type AuditLogger struct {
    logger *log.Logger
}

func NewAuditLogger() *AuditLogger {
    return &AuditLogger{
        logger: log.New(os.Stdout, "[AUDIT] ", log.LstdFlags),
    }
}

func (al *AuditLogger) Log(event AuditEvent) {
    event.Timestamp = time.Now()
    
    jsonData, _ := json.Marshal(event)
    al.logger.Println(string(jsonData))
}

// ä½¿ç”¨ç¤ºä¾‹
func loginHandler(w http.ResponseWriter, r *http.Request, auditor *AuditLogger) {
    username := r.FormValue("username")
    password := r.FormValue("password")
    
    if checkCredentials(username, password) {
        auditor.Log(AuditEvent{
            UserID:   username,
            Action:   "login",
            Resource: "auth",
            IP:       r.RemoteAddr,
            Status:   "success",
        })
        
        // ç™»å½•æˆåŠŸé€»è¾‘...
    } else {
        auditor.Log(AuditEvent{
            UserID:   username,
            Action:   "login",
            Resource: "auth",
            IP:       r.RemoteAddr,
            Status:   "failed",
            Details:  "invalid credentials",
        })
        
        http.Error(w, "Unauthorized", http.StatusUnauthorized)
    }
}
```

---

## ğŸ” å®¡è®¡ä¸­é—´ä»¶

```go
func AuditMiddleware(auditor *AuditLogger) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()
            
            // è®°å½•è¯·æ±‚
            userID := r.Context().Value("userID")
            if userID == nil {
                userID = "anonymous"
            }
            
            // åˆ›å»ºå“åº”è®°å½•å™¨
            recorder := &responseRecorder{
                ResponseWriter: w,
                statusCode:     http.StatusOK,
            }
            
            // å¤„ç†è¯·æ±‚
            next.ServeHTTP(recorder, r)
            
            // è®°å½•å®¡è®¡æ—¥å¿—
            auditor.Log(AuditEvent{
                UserID:   userID.(string),
                Action:   r.Method,
                Resource: r.URL.Path,
                IP:       r.RemoteAddr,
                Status:   http.StatusText(recorder.statusCode),
                Details:  fmt.Sprintf("duration=%v", time.Since(start)),
            })
        })
    }
}

type responseRecorder struct {
    http.ResponseWriter
    statusCode int
}

func (rr *responseRecorder) WriteHeader(code int) {
    rr.statusCode = code
    rr.ResponseWriter.WriteHeader(code)
}
```

---

## ğŸ“Š å¼‚å¸¸è¡Œä¸ºæ£€æµ‹

```go
type SecurityMonitor struct {
    failedLogins map[string]int
    mu           sync.RWMutex
}

func NewSecurityMonitor() *SecurityMonitor {
    return &SecurityMonitor{
        failedLogins: make(map[string]int),
    }
}

// è®°å½•å¤±è´¥çš„ç™»å½•
func (sm *SecurityMonitor) RecordFailedLogin(ip string) {
    sm.mu.Lock()
    defer sm.mu.Unlock()
    
    sm.failedLogins[ip]++
    
    // æ£€æµ‹æš´åŠ›ç ´è§£
    if sm.failedLogins[ip] >= 5 {
        sm.alertBruteForce(ip)
    }
}

func (sm *SecurityMonitor) alertBruteForce(ip string) {
    log.Printf("SECURITY ALERT: Possible brute force attack from %s", ip)
    // å‘é€å‘Šè­¦é€šçŸ¥...
}

// æ£€æµ‹å¼‚å¸¸è®¿é—®æ¨¡å¼
func (sm *SecurityMonitor) DetectAnomalies(events []AuditEvent) []string {
    var anomalies []string
    
    // æ£€æµ‹éå·¥ä½œæ—¶é—´çš„å¤§é‡æ“ä½œ
    for _, event := range events {
        hour := event.Timestamp.Hour()
        if hour < 6 || hour > 22 {
            anomalies = append(anomalies, 
                fmt.Sprintf("Off-hours activity: %s at %v", 
                    event.Action, event.Timestamp))
        }
    }
    
    return anomalies
}
```

---

## ğŸ›¡ï¸ åˆè§„æ€§æ£€æŸ¥

```go
// GDPRåˆè§„æ€§æ£€æŸ¥
type GDPRCompliance struct {
    dataRetention time.Duration
}

func (gc *GDPRCompliance) CheckCompliance(userID string, db *sql.DB) error {
    // æ£€æŸ¥æ•°æ®ä¿ç•™æœŸé™
    var lastActivity time.Time
    err := db.QueryRow(
        "SELECT last_activity FROM users WHERE id = ?", 
        userID,
    ).Scan(&lastActivity)
    
    if err != nil {
        return err
    }
    
    if time.Since(lastActivity) > gc.dataRetention {
        // æ•°æ®åº”è¯¥è¢«åˆ é™¤
        return fmt.Errorf("data retention policy violated for user %s", userID)
    }
    
    return nil
}

// å®¡è®¡ç”¨æˆ·æ•°æ®è®¿é—®
func (gc *GDPRCompliance) AuditDataAccess(userID, accessor string) {
    log.Printf("DATA ACCESS: User %s data accessed by %s", userID, accessor)
}
```

---

## ğŸ“ˆ å®¡è®¡æŠ¥å‘Š

```go
type AuditReport struct {
    Period      string
    TotalEvents int
    ByAction    map[string]int
    ByStatus    map[string]int
    TopUsers    []UserActivity
}

type UserActivity struct {
    UserID      string
    ActionCount int
}

func GenerateAuditReport(events []AuditEvent) *AuditReport {
    report := &AuditReport{
        ByAction: make(map[string]int),
        ByStatus: make(map[string]int),
    }
    
    userActions := make(map[string]int)
    
    for _, event := range events {
        report.TotalEvents++
        report.ByAction[event.Action]++
        report.ByStatus[event.Status]++
        userActions[event.UserID]++
    }
    
    // æå–Topç”¨æˆ·
    for userID, count := range userActions {
        report.TopUsers = append(report.TopUsers, UserActivity{
            UserID:      userID,
            ActionCount: count,
        })
    }
    
    // æ’åº
    sort.Slice(report.TopUsers, func(i, j int) bool {
        return report.TopUsers[i].ActionCount > report.TopUsers[j].ActionCount
    })
    
    if len(report.TopUsers) > 10 {
        report.TopUsers = report.TopUsers[:10]
    }
    
    return report
}
```

---

## ğŸ” æ•æ„Ÿæ“ä½œè¿½è¸ª

```go
// å…³é”®æ“ä½œå®¡è®¡
func AuditCriticalOperation(operation string, details map[string]interface{}) {
    event := map[string]interface{}{
        "timestamp": time.Now(),
        "operation": operation,
        "details":   details,
    }
    
    // å†™å…¥ä¸“ç”¨çš„å®¡è®¡æ—¥å¿—
    writeToAuditDB(event)
    
    // å‘é€å®æ—¶å‘Šè­¦
    if isCritical(operation) {
        sendAlert(event)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func deleteUserHandler(w http.ResponseWriter, r *http.Request) {
    userID := mux.Vars(r)["id"]
    adminID := r.Context().Value("userID").(string)
    
    // æ‰§è¡Œåˆ é™¤
    if err := deleteUser(userID); err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    // å®¡è®¡å…³é”®æ“ä½œ
    AuditCriticalOperation("user_deletion", map[string]interface{}{
        "deleted_user_id": userID,
        "admin_id":        adminID,
        "ip":              r.RemoteAddr,
    })
    
    w.WriteHeader(http.StatusNoContent)
}
```

---

## ğŸ’¡ æ—¥å¿—èšåˆä¸åˆ†æ

```go
// é›†æˆELK Stack
import (
    "github.com/olivere/elastic/v7"
)

type ElasticLogger struct {
    client *elastic.Client
    index  string
}

func NewElasticLogger(url, index string) (*ElasticLogger, error) {
    client, err := elastic.NewClient(elastic.SetURL(url))
    if err != nil {
        return nil, err
    }
    
    return &ElasticLogger{
        client: client,
        index:  index,
    }, nil
}

func (el *ElasticLogger) LogEvent(event AuditEvent) error {
    ctx := context.Background()
    _, err := el.client.Index().
        Index(el.index).
        BodyJson(event).
        Do(ctx)
    
    return err
}

// æŸ¥è¯¢å®¡è®¡æ—¥å¿—
func (el *ElasticLogger) QueryEvents(userID string, from, to time.Time) ([]AuditEvent, error) {
    ctx := context.Background()
    
    query := elastic.NewBoolQuery().
        Must(elastic.NewTermQuery("user_id", userID)).
        Filter(elastic.NewRangeQuery("timestamp").
            Gte(from).
            Lte(to))
    
    results, err := el.client.Search().
        Index(el.index).
        Query(query).
        Do(ctx)
    
    if err != nil {
        return nil, err
    }
    
    var events []AuditEvent
    for _, hit := range results.Hits.Hits {
        var event AuditEvent
        json.Unmarshal(hit.Source, &event)
        events = append(events, event)
    }
    
    return events, nil
}
```

---

## 3. ğŸ“š ç›¸å…³èµ„æº

- [OWASP Logging Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)
- [GDPR Compliance](https://gdpr-info.eu/)

**ä¸‹ä¸€æ­¥**: [06-æœ€ä½³å®è·µ](./06-æœ€ä½³å®è·µ.md)

---

**æœ€åæ›´æ–°**: 2025-10-28

