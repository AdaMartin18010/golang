# æ•°æ®ä¿æŠ¤

**éš¾åº¦**: ä¸­çº§ | **é¢„è®¡é˜…è¯»**: 20åˆ†é’Ÿ | **å‰ç½®çŸ¥è¯†**: å¯†ç å­¦åŸºç¡€

---

## ğŸ“‹ ç›®å½•

- [1. ğŸ“– æ¦‚å¿µä»‹ç»](#1--æ¦‚å¿µä»‹ç»)
- [2. ğŸ” å¯¹ç§°åŠ å¯†](#2--å¯¹ç§°åŠ å¯†)
- [3. ğŸ“š ç›¸å…³èµ„æº](#3--ç›¸å…³èµ„æº)

---

## 1. ğŸ“– æ¦‚å¿µä»‹ç»

æ•°æ®ä¿æŠ¤æ¶‰åŠåŠ å¯†ã€å“ˆå¸Œã€å®‰å…¨å­˜å‚¨ç­‰æŠ€æœ¯ï¼Œç¡®ä¿æ•æ„Ÿæ•°æ®åœ¨å­˜å‚¨å’Œä¼ è¾“è¿‡ç¨‹ä¸­çš„å®‰å…¨ã€‚

---

## 2. ğŸ” å¯¹ç§°åŠ å¯† (AES)

```go
package encryption

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "encoding/base64"
    "io"
)

// AES-GCMåŠ å¯†
func Encrypt(plaintext string, key []byte) (string, error) {
    // åˆ›å»ºcipher
    block, err := aes.NewCipher(key)
    if err != nil {
        return "", err
    }
    
    // åˆ›å»ºGCMæ¨¡å¼
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }
    
    // ç”Ÿæˆnonce
    nonce := make([]byte, gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return "", err
    }
    
    // åŠ å¯†
    ciphertext := gcm.Seal(nonce, nonce, []byte(plaintext), nil)
    
    // ç¼–ç ä¸ºbase64
    return base64.StdEncoding.EncodeToString(ciphertext), nil
}

// AES-GCMè§£å¯†
func Decrypt(ciphertext string, key []byte) (string, error) {
    // è§£ç base64
    data, err := base64.StdEncoding.DecodeString(ciphertext)
    if err != nil {
        return "", err
    }
    
    // åˆ›å»ºcipher
    block, err := aes.NewCipher(key)
    if err != nil {
        return "", err
    }
    
    // åˆ›å»ºGCMæ¨¡å¼
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }
    
    // æå–nonce
    nonceSize := gcm.NonceSize()
    if len(data) < nonceSize {
        return "", errors.New("ciphertext too short")
    }
    
    nonce, ciphertext := data[:nonceSize], data[nonceSize:]
    
    // è§£å¯†
    plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return "", err
    }
    
    return string(plaintext), nil
}

// ä½¿ç”¨ç¤ºä¾‹
func example() {
    // 32å­—èŠ‚å¯†é’¥ (AES-256)
    key := make([]byte, 32)
    rand.Read(key)
    
    plaintext := "sensitive data"
    
    // åŠ å¯†
    encrypted, _ := Encrypt(plaintext, key)
    fmt.Printf("Encrypted: %s\n", encrypted)
    
    // è§£å¯†
    decrypted, _ := Decrypt(encrypted, key)
    fmt.Printf("Decrypted: %s\n", decrypted)
}
```

---

## ğŸ”‘ éå¯¹ç§°åŠ å¯† (RSA)

```go
package rsa

import (
    "crypto/rand"
    "crypto/rsa"
    "crypto/sha256"
    "crypto/x509"
    "encoding/pem"
)

// ç”ŸæˆRSAå¯†é’¥å¯¹
func GenerateKeyPair(bits int) (*rsa.PrivateKey, *rsa.PublicKey, error) {
    privateKey, err := rsa.GenerateKey(rand.Reader, bits)
    if err != nil {
        return nil, nil, err
    }
    
    return privateKey, &privateKey.PublicKey, nil
}

// åŠ å¯†
func EncryptRSA(plaintext []byte, publicKey *rsa.PublicKey) ([]byte, error) {
    return rsa.EncryptOAEP(
        sha256.New(),
        rand.Reader,
        publicKey,
        plaintext,
        nil,
    )
}

// è§£å¯†
func DecryptRSA(ciphertext []byte, privateKey *rsa.PrivateKey) ([]byte, error) {
    return rsa.DecryptOAEP(
        sha256.New(),
        rand.Reader,
        privateKey,
        ciphertext,
        nil,
    )
}

// å¯¼å‡ºç§é’¥ä¸ºPEM
func ExportPrivateKeyToPEM(key *rsa.PrivateKey) string {
    privBytes := x509.MarshalPKCS1PrivateKey(key)
    privPEM := pem.EncodeToMemory(&pem.Block{
        Type:  "RSA PRIVATE KEY",
        Bytes: privBytes,
    })
    return string(privPEM)
}

// å¯¼å‡ºå…¬é’¥ä¸ºPEM
func ExportPublicKeyToPEM(key *rsa.PublicKey) (string, error) {
    pubBytes, err := x509.MarshalPKIXPublicKey(key)
    if err != nil {
        return "", err
    }
    
    pubPEM := pem.EncodeToMemory(&pem.Block{
        Type:  "RSA PUBLIC KEY",
        Bytes: pubBytes,
    })
    
    return string(pubPEM), nil
}
```

---

## ğŸ”’ å¯†ç å“ˆå¸Œ

```go
import (
    "golang.org/x/crypto/argon2"
    "golang.org/x/crypto/bcrypt"
)

// Bcryptå“ˆå¸Œ
func HashPasswordBcrypt(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
    return string(bytes), err
}

func CheckPasswordBcrypt(password, hash string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}

// Argon2å“ˆå¸Œï¼ˆæ›´å®‰å…¨ï¼‰
type Argon2Params struct {
    Memory      uint32
    Iterations  uint32
    Parallelism uint8
    SaltLength  uint32
    KeyLength   uint32
}

func DefaultArgon2Params() *Argon2Params {
    return &Argon2Params{
        Memory:      64 * 1024,
        Iterations:  3,
        Parallelism: 2,
        SaltLength:  16,
        KeyLength:   32,
    }
}

func HashPasswordArgon2(password string, params *Argon2Params) (string, error) {
    // ç”Ÿæˆsalt
    salt := make([]byte, params.SaltLength)
    if _, err := rand.Read(salt); err != nil {
        return "", err
    }
    
    // ç”Ÿæˆå“ˆå¸Œ
    hash := argon2.IDKey(
        []byte(password),
        salt,
        params.Iterations,
        params.Memory,
        params.Parallelism,
        params.KeyLength,
    )
    
    // ç»„åˆå‚æ•°ã€saltå’Œå“ˆå¸Œ
    b64Salt := base64.RawStdEncoding.EncodeToString(salt)
    b64Hash := base64.RawStdEncoding.EncodeToString(hash)
    
    encoded := fmt.Sprintf("$argon2id$v=%d$m=%d,t=%d,p=%d$%s$%s",
        argon2.Version, params.Memory, params.Iterations,
        params.Parallelism, b64Salt, b64Hash)
    
    return encoded, nil
}
```

---

## ğŸ›¡ï¸ æ•°æ®è„±æ•

```go
// æ‰‹æœºå·è„±æ•
func MaskPhone(phone string) string {
    if len(phone) != 11 {
        return phone
    }
    return phone[:3] + "****" + phone[7:]
}

// é‚®ç®±è„±æ•
func MaskEmail(email string) string {
    parts := strings.Split(email, "@")
    if len(parts) != 2 {
        return email
    }
    
    username := parts[0]
    if len(username) <= 2 {
        return email
    }
    
    masked := username[:2] + "***@" + parts[1]
    return masked
}

// èº«ä»½è¯è„±æ•
func MaskIDCard(idCard string) string {
    if len(idCard) != 18 {
        return idCard
    }
    return idCard[:6] + "********" + idCard[14:]
}

// é“¶è¡Œå¡å·è„±æ•
func MaskBankCard(card string) string {
    if len(card) < 8 {
        return card
    }
    return card[:4] + strings.Repeat("*", len(card)-8) + card[len(card)-4:]
}
```

---

## ğŸ” å®‰å…¨å­˜å‚¨

```go
// ç¯å¢ƒå˜é‡é…ç½®
type SecureConfig struct {
    DBPassword string
    APIKey     string
    JWTSecret  string
}

func LoadSecureConfig() (*SecureConfig, error) {
    return &SecureConfig{
        DBPassword: os.Getenv("DB_PASSWORD"),
        APIKey:     os.Getenv("API_KEY"),
        JWTSecret:  os.Getenv("JWT_SECRET"),
    }, nil
}

// åŠ å¯†é…ç½®æ–‡ä»¶
type EncryptedConfig struct {
    key []byte
}

func NewEncryptedConfig(keyPath string) (*EncryptedConfig, error) {
    key, err := ioutil.ReadFile(keyPath)
    if err != nil {
        return nil, err
    }
    
    return &EncryptedConfig{key: key}, nil
}

func (ec *EncryptedConfig) SaveConfig(data interface{}, path string) error {
    // åºåˆ—åŒ–
    jsonData, err := json.Marshal(data)
    if err != nil {
        return err
    }
    
    // åŠ å¯†
    encrypted, err := Encrypt(string(jsonData), ec.key)
    if err != nil {
        return err
    }
    
    // ä¿å­˜
    return ioutil.WriteFile(path, []byte(encrypted), 0600)
}

func (ec *EncryptedConfig) LoadConfig(path string, data interface{}) error {
    // è¯»å–
    encrypted, err := ioutil.ReadFile(path)
    if err != nil {
        return err
    }
    
    // è§£å¯†
    decrypted, err := Decrypt(string(encrypted), ec.key)
    if err != nil {
        return err
    }
    
    // ååºåˆ—åŒ–
    return json.Unmarshal([]byte(decrypted), data)
}
```

---

## ğŸ’¡ TLS/SSL

```go
// HTTPSæœåŠ¡å™¨
func startHTTPSServer() {
    mux := http.NewServeMux()
    mux.HandleFunc("/", handler)
    
    // é…ç½®TLS
    tlsConfig := &tls.Config{
        MinVersion:               tls.VersionTLS12,
        CurvePreferences:         []tls.CurveID{tls.CurveP521, tls.CurveP384, tls.CurveP256},
        PreferServerCipherSuites: true,
        CipherSuites: []uint16{
            tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
            tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
            tls.TLS_RSA_WITH_AES_256_GCM_SHA384,
            tls.TLS_RSA_WITH_AES_256_CBC_SHA,
        },
    }
    
    server := &http.Server{
        Addr:         ":443",
        Handler:      mux,
        TLSConfig:    tlsConfig,
        TLSNextProto: make(map[string]func(*http.Server, *tls.Conn, http.Handler)),
    }
    
    log.Fatal(server.ListenAndServeTLS("cert.pem", "key.pem"))
}

// å¼ºåˆ¶HTTPSé‡å®šå‘
func redirectToHTTPS(w http.ResponseWriter, r *http.Request) {
    target := "https://" + r.Host + r.URL.Path
    if len(r.URL.RawQuery) > 0 {
        target += "?" + r.URL.RawQuery
    }
    http.Redirect(w, r, target, http.StatusMovedPermanently)
}
```

---

## 3. ğŸ“š ç›¸å…³èµ„æº

- [Go Cryptography](https://pkg.go.dev/crypto)
- [OWASP Cryptographic Storage](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)

**ä¸‹ä¸€æ­¥**: [05-å®‰å…¨å®¡è®¡](./05-å®‰å…¨å®¡è®¡.md)

---

**æœ€åæ›´æ–°**: 2025-10-28

