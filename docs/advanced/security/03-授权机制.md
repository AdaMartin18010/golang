# 授权机制

**难度**: 中级 | **预计阅读**: 20分钟 | **前置知识**: 身份认证

---

## 📖 概念介绍

授权决定已认证用户可以访问哪些资源。实现细粒度的访问控制是系统安全的关键。

---

## 🎯 RBAC (基于角色的访问控制)

```go
package rbac

import (
    "errors"
    "sync"
)

// 角色和权限定义
type Permission string
type Role string

const (
    PermissionRead   Permission = "read"
    PermissionWrite  Permission = "write"
    PermissionDelete Permission = "delete"
    
    RoleAdmin  Role = "admin"
    RoleEditor Role = "editor"
    RoleViewer Role = "viewer"
)

// RBAC管理器
type RBAC struct {
    rolePermissions map[Role][]Permission
    userRoles       map[string][]Role
    mu              sync.RWMutex
}

func NewRBAC() *RBAC {
    rbac := &RBAC{
        rolePermissions: make(map[Role][]Permission),
        userRoles:       make(map[string][]Role),
    }
    
    // 初始化角色权限
    rbac.rolePermissions[RoleAdmin] = []Permission{
        PermissionRead, PermissionWrite, PermissionDelete,
    }
    rbac.rolePermissions[RoleEditor] = []Permission{
        PermissionRead, PermissionWrite,
    }
    rbac.rolePermissions[RoleViewer] = []Permission{
        PermissionRead,
    }
    
    return rbac
}

// 分配角色
func (r *RBAC) AssignRole(userID string, role Role) {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    r.userRoles[userID] = append(r.userRoles[userID], role)
}

// 检查权限
func (r *RBAC) HasPermission(userID string, perm Permission) bool {
    r.mu.RLock()
    defer r.mu.RUnlock()
    
    roles := r.userRoles[userID]
    for _, role := range roles {
        permissions := r.rolePermissions[role]
        for _, p := range permissions {
            if p == perm {
                return true
            }
        }
    }
    
    return false
}

// 授权中间件
func (r *RBAC) AuthorizeMiddleware(perm Permission) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
            userID := req.Context().Value("userID").(string)
            
            if !r.HasPermission(userID, perm) {
                http.Error(w, "Forbidden", http.StatusForbidden)
                return
            }
            
            next.ServeHTTP(w, req)
        })
    }
}

// 使用示例
func main() {
    rbac := NewRBAC()
    
    // 分配角色
    rbac.AssignRole("user1", RoleAdmin)
    rbac.AssignRole("user2", RoleViewer)
    
    // 路由保护
    mux := http.NewServeMux()
    
    // 只有有写权限的用户可访问
    mux.Handle("/api/posts", 
        rbac.AuthorizeMiddleware(PermissionWrite)(
            http.HandlerFunc(createPostHandler)))
    
    http.ListenAndServe(":8080", mux)
}
```

---

## 🔐 ABAC (基于属性的访问控制)

```go
package abac

type Attribute struct {
    Name  string
    Value interface{}
}

type Policy struct {
    Resource   string
    Action     string
    Conditions []Condition
}

type Condition struct {
    Attribute string
    Operator  string
    Value     interface{}
}

type ABAC struct {
    policies []Policy
}

func (a *ABAC) AddPolicy(p Policy) {
    a.policies = append(a.policies, p)
}

// 评估访问请求
func (a *ABAC) Evaluate(resource, action string, attributes map[string]interface{}) bool {
    for _, policy := range a.policies {
        if policy.Resource == resource && policy.Action == action {
            if a.evaluateConditions(policy.Conditions, attributes) {
                return true
            }
        }
    }
    return false
}

func (a *ABAC) evaluateConditions(conditions []Condition, attributes map[string]interface{}) bool {
    for _, cond := range conditions {
        attrValue, exists := attributes[cond.Attribute]
        if !exists {
            return false
        }
        
        if !a.evaluateCondition(cond, attrValue) {
            return false
        }
    }
    return true
}

func (a *ABAC) evaluateCondition(cond Condition, value interface{}) bool {
    switch cond.Operator {
    case "equals":
        return value == cond.Value
    case "greater_than":
        return value.(int) > cond.Value.(int)
    case "in":
        list := cond.Value.([]string)
        for _, item := range list {
            if item == value.(string) {
                return true
            }
        }
        return false
    }
    return false
}

// 使用示例
func example() {
    abac := &ABAC{}
    
    // 定义策略：只有VIP用户可以删除
    abac.AddPolicy(Policy{
        Resource: "posts",
        Action:   "delete",
        Conditions: []Condition{
            {Attribute: "user_type", Operator: "equals", Value: "vip"},
        },
    })
    
    // 评估访问
    attributes := map[string]interface{}{
        "user_type": "vip",
        "user_id":   "123",
    }
    
    allowed := abac.Evaluate("posts", "delete", attributes)
    fmt.Printf("Access allowed: %v\n", allowed)
}
```

---

## 🔑 ACL (访问控制列表)

```go
package acl

type ACL struct {
    rules map[string]map[string]bool
    mu    sync.RWMutex
}

func NewACL() *ACL {
    return &ACL{
        rules: make(map[string]map[string]bool),
    }
}

// 授予权限
func (a *ACL) Grant(userID, resource string) {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    if a.rules[userID] == nil {
        a.rules[userID] = make(map[string]bool)
    }
    a.rules[userID][resource] = true
}

// 撤销权限
func (a *ACL) Revoke(userID, resource string) {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    if a.rules[userID] != nil {
        delete(a.rules[userID], resource)
    }
}

// 检查权限
func (a *ACL) HasAccess(userID, resource string) bool {
    a.mu.RLock()
    defer a.mu.RUnlock()
    
    return a.rules[userID][resource]
}

// 使用示例
func aclExample() {
    acl := NewACL()
    
    // 授予权限
    acl.Grant("user1", "document:123")
    acl.Grant("user1", "document:456")
    
    // 检查权限
    if acl.HasAccess("user1", "document:123") {
        fmt.Println("Access granted")
    }
}
```

---

## 💡 资源级权限控制

```go
package resource

type Resource struct {
    ID      string
    OwnerID string
    Type    string
}

type ResourceController struct {
    rbac *RBAC
    acl  *ACL
}

func (rc *ResourceController) CanAccess(userID string, resource Resource, action string) bool {
    // 1. 检查所有权
    if resource.OwnerID == userID {
        return true
    }
    
    // 2. 检查ACL
    if rc.acl.HasAccess(userID, fmt.Sprintf("%s:%s", resource.Type, resource.ID)) {
        return true
    }
    
    // 3. 检查RBAC
    var perm Permission
    switch action {
    case "read":
        perm = PermissionRead
    case "write":
        perm = PermissionWrite
    case "delete":
        perm = PermissionDelete
    default:
        return false
    }
    
    return rc.rbac.HasPermission(userID, perm)
}

// 中间件
func (rc *ResourceController) AuthorizeResource(action string) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            userID := r.Context().Value("userID").(string)
            resourceID := mux.Vars(r)["id"]
            
            // 加载资源
            resource := loadResource(resourceID)
            
            if !rc.CanAccess(userID, resource, action) {
                http.Error(w, "Forbidden", http.StatusForbidden)
                return
            }
            
            // 将资源放入context
            ctx := context.WithValue(r.Context(), "resource", resource)
            next.ServeHTTP(w, r.WithContext(ctx))
        })
    }
}
```

---

## 🚀 Casbin集成

```go
import "github.com/casbin/casbin/v2"

func setupCasbin() (*casbin.Enforcer, error) {
    // 加载模型和策略
    e, err := casbin.NewEnforcer("model.conf", "policy.csv")
    if err != nil {
        return nil, err
    }
    
    return e, nil
}

// model.conf 示例
/*
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act
*/

// policy.csv 示例
/*
p, admin, *, *
p, editor, posts, write
p, editor, posts, read
p, viewer, posts, read

g, alice, admin
g, bob, editor
g, charlie, viewer
*/

// 中间件
func CasbinMiddleware(e *casbin.Enforcer) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            user := r.Context().Value("username").(string)
            path := r.URL.Path
            method := r.Method
            
            ok, err := e.Enforce(user, path, method)
            if err != nil {
                http.Error(w, "Error checking permission", http.StatusInternalServerError)
                return
            }
            
            if !ok {
                http.Error(w, "Forbidden", http.StatusForbidden)
                return
            }
            
            next.ServeHTTP(w, r)
        })
    }
}
```

---

## 📚 相关资源

- [Casbin Documentation](https://casbin.org/)
- [NIST RBAC Model](https://csrc.nist.gov/projects/role-based-access-control)

**下一步**: [04-数据保护](./04-数据保护.md)

---

**最后更新**: 2025-10-28

