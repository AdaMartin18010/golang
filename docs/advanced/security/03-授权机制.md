# æˆæƒæœºåˆ¶

**éš¾åº¦**: ä¸­çº§ | **é¢„è®¡é˜…è¯»**: 20åˆ†é’Ÿ | **å‰ç½®çŸ¥è¯†**: èº«ä»½è®¤è¯

---

## ğŸ“– æ¦‚å¿µä»‹ç»

æˆæƒå†³å®šå·²è®¤è¯ç”¨æˆ·å¯ä»¥è®¿é—®å“ªäº›èµ„æºã€‚å®ç°ç»†ç²’åº¦çš„è®¿é—®æ§åˆ¶æ˜¯ç³»ç»Ÿå®‰å…¨çš„å…³é”®ã€‚

---

## ğŸ¯ RBAC (åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶)

```go
package rbac

import (
    "errors"
    "sync"
)

// è§’è‰²å’Œæƒé™å®šä¹‰
type Permission string
type Role string

const (
    PermissionRead   Permission = "read"
    PermissionWrite  Permission = "write"
    PermissionDelete Permission = "delete"
    
    RoleAdmin  Role = "admin"
    RoleEditor Role = "editor"
    RoleViewer Role = "viewer"
)

// RBACç®¡ç†å™¨
type RBAC struct {
    rolePermissions map[Role][]Permission
    userRoles       map[string][]Role
    mu              sync.RWMutex
}

func NewRBAC() *RBAC {
    rbac := &RBAC{
        rolePermissions: make(map[Role][]Permission),
        userRoles:       make(map[string][]Role),
    }
    
    // åˆå§‹åŒ–è§’è‰²æƒé™
    rbac.rolePermissions[RoleAdmin] = []Permission{
        PermissionRead, PermissionWrite, PermissionDelete,
    }
    rbac.rolePermissions[RoleEditor] = []Permission{
        PermissionRead, PermissionWrite,
    }
    rbac.rolePermissions[RoleViewer] = []Permission{
        PermissionRead,
    }
    
    return rbac
}

// åˆ†é…è§’è‰²
func (r *RBAC) AssignRole(userID string, role Role) {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    r.userRoles[userID] = append(r.userRoles[userID], role)
}

// æ£€æŸ¥æƒé™
func (r *RBAC) HasPermission(userID string, perm Permission) bool {
    r.mu.RLock()
    defer r.mu.RUnlock()
    
    roles := r.userRoles[userID]
    for _, role := range roles {
        permissions := r.rolePermissions[role]
        for _, p := range permissions {
            if p == perm {
                return true
            }
        }
    }
    
    return false
}

// æˆæƒä¸­é—´ä»¶
func (r *RBAC) AuthorizeMiddleware(perm Permission) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
            userID := req.Context().Value("userID").(string)
            
            if !r.HasPermission(userID, perm) {
                http.Error(w, "Forbidden", http.StatusForbidden)
                return
            }
            
            next.ServeHTTP(w, req)
        })
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    rbac := NewRBAC()
    
    // åˆ†é…è§’è‰²
    rbac.AssignRole("user1", RoleAdmin)
    rbac.AssignRole("user2", RoleViewer)
    
    // è·¯ç”±ä¿æŠ¤
    mux := http.NewServeMux()
    
    // åªæœ‰æœ‰å†™æƒé™çš„ç”¨æˆ·å¯è®¿é—®
    mux.Handle("/api/posts", 
        rbac.AuthorizeMiddleware(PermissionWrite)(
            http.HandlerFunc(createPostHandler)))
    
    http.ListenAndServe(":8080", mux)
}
```

---

## ğŸ” ABAC (åŸºäºå±æ€§çš„è®¿é—®æ§åˆ¶)

```go
package abac

type Attribute struct {
    Name  string
    Value interface{}
}

type Policy struct {
    Resource   string
    Action     string
    Conditions []Condition
}

type Condition struct {
    Attribute string
    Operator  string
    Value     interface{}
}

type ABAC struct {
    policies []Policy
}

func (a *ABAC) AddPolicy(p Policy) {
    a.policies = append(a.policies, p)
}

// è¯„ä¼°è®¿é—®è¯·æ±‚
func (a *ABAC) Evaluate(resource, action string, attributes map[string]interface{}) bool {
    for _, policy := range a.policies {
        if policy.Resource == resource && policy.Action == action {
            if a.evaluateConditions(policy.Conditions, attributes) {
                return true
            }
        }
    }
    return false
}

func (a *ABAC) evaluateConditions(conditions []Condition, attributes map[string]interface{}) bool {
    for _, cond := range conditions {
        attrValue, exists := attributes[cond.Attribute]
        if !exists {
            return false
        }
        
        if !a.evaluateCondition(cond, attrValue) {
            return false
        }
    }
    return true
}

func (a *ABAC) evaluateCondition(cond Condition, value interface{}) bool {
    switch cond.Operator {
    case "equals":
        return value == cond.Value
    case "greater_than":
        return value.(int) > cond.Value.(int)
    case "in":
        list := cond.Value.([]string)
        for _, item := range list {
            if item == value.(string) {
                return true
            }
        }
        return false
    }
    return false
}

// ä½¿ç”¨ç¤ºä¾‹
func example() {
    abac := &ABAC{}
    
    // å®šä¹‰ç­–ç•¥ï¼šåªæœ‰VIPç”¨æˆ·å¯ä»¥åˆ é™¤
    abac.AddPolicy(Policy{
        Resource: "posts",
        Action:   "delete",
        Conditions: []Condition{
            {Attribute: "user_type", Operator: "equals", Value: "vip"},
        },
    })
    
    // è¯„ä¼°è®¿é—®
    attributes := map[string]interface{}{
        "user_type": "vip",
        "user_id":   "123",
    }
    
    allowed := abac.Evaluate("posts", "delete", attributes)
    fmt.Printf("Access allowed: %v\n", allowed)
}
```

---

## ğŸ”‘ ACL (è®¿é—®æ§åˆ¶åˆ—è¡¨)

```go
package acl

type ACL struct {
    rules map[string]map[string]bool
    mu    sync.RWMutex
}

func NewACL() *ACL {
    return &ACL{
        rules: make(map[string]map[string]bool),
    }
}

// æˆäºˆæƒé™
func (a *ACL) Grant(userID, resource string) {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    if a.rules[userID] == nil {
        a.rules[userID] = make(map[string]bool)
    }
    a.rules[userID][resource] = true
}

// æ’¤é”€æƒé™
func (a *ACL) Revoke(userID, resource string) {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    if a.rules[userID] != nil {
        delete(a.rules[userID], resource)
    }
}

// æ£€æŸ¥æƒé™
func (a *ACL) HasAccess(userID, resource string) bool {
    a.mu.RLock()
    defer a.mu.RUnlock()
    
    return a.rules[userID][resource]
}

// ä½¿ç”¨ç¤ºä¾‹
func aclExample() {
    acl := NewACL()
    
    // æˆäºˆæƒé™
    acl.Grant("user1", "document:123")
    acl.Grant("user1", "document:456")
    
    // æ£€æŸ¥æƒé™
    if acl.HasAccess("user1", "document:123") {
        fmt.Println("Access granted")
    }
}
```

---

## ğŸ’¡ èµ„æºçº§æƒé™æ§åˆ¶

```go
package resource

type Resource struct {
    ID      string
    OwnerID string
    Type    string
}

type ResourceController struct {
    rbac *RBAC
    acl  *ACL
}

func (rc *ResourceController) CanAccess(userID string, resource Resource, action string) bool {
    // 1. æ£€æŸ¥æ‰€æœ‰æƒ
    if resource.OwnerID == userID {
        return true
    }
    
    // 2. æ£€æŸ¥ACL
    if rc.acl.HasAccess(userID, fmt.Sprintf("%s:%s", resource.Type, resource.ID)) {
        return true
    }
    
    // 3. æ£€æŸ¥RBAC
    var perm Permission
    switch action {
    case "read":
        perm = PermissionRead
    case "write":
        perm = PermissionWrite
    case "delete":
        perm = PermissionDelete
    default:
        return false
    }
    
    return rc.rbac.HasPermission(userID, perm)
}

// ä¸­é—´ä»¶
func (rc *ResourceController) AuthorizeResource(action string) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            userID := r.Context().Value("userID").(string)
            resourceID := mux.Vars(r)["id"]
            
            // åŠ è½½èµ„æº
            resource := loadResource(resourceID)
            
            if !rc.CanAccess(userID, resource, action) {
                http.Error(w, "Forbidden", http.StatusForbidden)
                return
            }
            
            // å°†èµ„æºæ”¾å…¥context
            ctx := context.WithValue(r.Context(), "resource", resource)
            next.ServeHTTP(w, r.WithContext(ctx))
        })
    }
}
```

---

## ğŸš€ Casbiné›†æˆ

```go
import "github.com/casbin/casbin/v2"

func setupCasbin() (*casbin.Enforcer, error) {
    // åŠ è½½æ¨¡å‹å’Œç­–ç•¥
    e, err := casbin.NewEnforcer("model.conf", "policy.csv")
    if err != nil {
        return nil, err
    }
    
    return e, nil
}

// model.conf ç¤ºä¾‹
/*
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act
*/

// policy.csv ç¤ºä¾‹
/*
p, admin, *, *
p, editor, posts, write
p, editor, posts, read
p, viewer, posts, read

g, alice, admin
g, bob, editor
g, charlie, viewer
*/

// ä¸­é—´ä»¶
func CasbinMiddleware(e *casbin.Enforcer) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            user := r.Context().Value("username").(string)
            path := r.URL.Path
            method := r.Method
            
            ok, err := e.Enforce(user, path, method)
            if err != nil {
                http.Error(w, "Error checking permission", http.StatusInternalServerError)
                return
            }
            
            if !ok {
                http.Error(w, "Forbidden", http.StatusForbidden)
                return
            }
            
            next.ServeHTTP(w, r)
        })
    }
}
```

---

## ğŸ“š ç›¸å…³èµ„æº

- [Casbin Documentation](https://casbin.org/)
- [NIST RBAC Model](https://csrc.nist.gov/projects/role-based-access-control)

**ä¸‹ä¸€æ­¥**: [04-æ•°æ®ä¿æŠ¤](./04-æ•°æ®ä¿æŠ¤.md)

---

**æœ€åæ›´æ–°**: 2025-10-28

