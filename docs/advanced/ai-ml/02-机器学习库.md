# æœºå™¨å­¦ä¹ åº“

**éš¾åº¦**: ä¸­çº§ | **é¢„è®¡é˜…è¯»**: 15åˆ†é’Ÿ | **å‰ç½®çŸ¥è¯†**: GoåŸºç¡€ã€MLæ¦‚å¿µ

---

## ğŸ“‹ ç›®å½•


- [1. ğŸ“– æ¦‚å¿µä»‹ç»](#1--æ¦‚å¿µä»‹ç»)
- [ğŸ¯ GoLearn](#-golearn)
  - [åŸºç¡€ä½¿ç”¨](#åŸºç¡€ä½¿ç”¨)
  - [å†³ç­–æ ‘](#å†³ç­–æ ‘)
- [ğŸ”¢ Gorgonia (æ·±åº¦å­¦ä¹ )](#-gorgonia-æ·±åº¦å­¦ä¹ )
- [ğŸ“Š GoNum (æ•°å€¼è®¡ç®—)](#-gonum-æ•°å€¼è®¡ç®—)
- [ğŸ§  Neat (ç¥ç»è¿›åŒ–)](#-neat-ç¥ç»è¿›åŒ–)
- [ğŸ’¡ å®ç”¨å·¥å…·](#-å®ç”¨å·¥å…·)
  - [æ•°æ®é¢„å¤„ç†](#æ•°æ®é¢„å¤„ç†)
- [ğŸ“š ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

## 1. ğŸ“– æ¦‚å¿µä»‹ç»

è™½ç„¶Goçš„MLç”Ÿæ€ä¸å¦‚Pythonä¸°å¯Œï¼Œä½†ä»æœ‰ä¼˜ç§€çš„çº¯Goæœºå™¨å­¦ä¹ åº“ï¼Œé€‚åˆç”Ÿäº§ç¯å¢ƒéƒ¨ç½²ã€‚

---

## ğŸ¯ GoLearn

### åŸºç¡€ä½¿ç”¨

```go
import (
    "github.com/sjwhitworth/golearn/base"
    "github.com/sjwhitworth/golearn/evaluation"
    "github.com/sjwhitworth/golearn/knn"
)

func trainKNN() {
    // åŠ è½½æ•°æ®
    rawData, _ := base.ParseCSVToInstances("datasets/iris.csv", true)
    
    // åˆ†å‰²è®­ç»ƒå’Œæµ‹è¯•é›†
    trainData, testData := base.InstancesTrainTestSplit(rawData, 0.8)
    
    // åˆ›å»ºKNNåˆ†ç±»å™¨
    classifier := knn.NewKnnClassifier("euclidean", "linear", 2)
    
    // è®­ç»ƒ
    classifier.Fit(trainData)
    
    // é¢„æµ‹
    predictions, _ := classifier.Predict(testData)
    
    // è¯„ä¼°
    confusionMat, _ := evaluation.GetConfusionMatrix(testData, predictions)
    fmt.Println(evaluation.GetSummary(confusionMat))
}
```

---

### å†³ç­–æ ‘

```go
import "github.com/sjwhitworth/golearn/trees"

func trainDecisionTree() {
    data, _ := base.ParseCSVToInstances("data.csv", true)
    
    // åˆ›å»ºå†³ç­–æ ‘
    tree := trees.NewID3DecisionTree(0.6)
    
    // è®­ç»ƒ
    tree.Fit(data)
    
    // é¢„æµ‹
    predictions, _ := tree.Predict(data)
    
    // å‡†ç¡®ç‡
    accuracy := evaluation.GetAccuracy(data, predictions)
    fmt.Printf("Accuracy: %.2f%%\n", accuracy*100)
}
```

---

## ğŸ”¢ Gorgonia (æ·±åº¦å­¦ä¹ )

```go
import (
    "gorgonia.org/gorgonia"
    "gorgonia.org/tensor"
)

// ç®€å•ç¥ç»ç½‘ç»œ
type NN struct {
    g      *gorgonia.ExprGraph
    w0, w1 *gorgonia.Node
    
    pred   *gorgonia.Node
    loss   *gorgonia.Node
}

func NewNN(input, hidden, output int) *NN {
    g := gorgonia.NewGraph()
    
    // æƒé‡
    w0 := gorgonia.NewMatrix(g, tensor.Float64, 
        gorgonia.WithShape(input, hidden), 
        gorgonia.WithName("w0"),
        gorgonia.WithInit(gorgonia.GlorotU(1.0)))
    
    w1 := gorgonia.NewMatrix(g, tensor.Float64,
        gorgonia.WithShape(hidden, output),
        gorgonia.WithName("w1"),
        gorgonia.WithInit(gorgonia.GlorotU(1.0)))
    
    return &NN{
        g:  g,
        w0: w0,
        w1: w1,
    }
}

func (nn *NN) Forward(x *gorgonia.Node) (*gorgonia.Node, error) {
    // ç¬¬ä¸€å±‚
    h := gorgonia.Must(gorgonia.Mul(x, nn.w0))
    h = gorgonia.Must(gorgonia.Tanh(h))
    
    // è¾“å‡ºå±‚
    out := gorgonia.Must(gorgonia.Mul(h, nn.w1))
    nn.pred = out
    
    return out, nil
}
```

---

## ğŸ“Š GoNum (æ•°å€¼è®¡ç®—)

```go
import (
    "gonum.org/v1/gonum/mat"
    "gonum.org/v1/gonum/stat"
)

// çº¿æ€§å›å½’
func linearRegression(X, y []float64) (slope, intercept float64) {
    alpha, beta := stat.LinearRegression(X, y, nil, false)
    return beta, alpha
}

// çŸ©é˜µè¿ç®—
func matrixOperations() {
    // åˆ›å»ºçŸ©é˜µ
    data := []float64{1, 2, 3, 4, 5, 6}
    m := mat.NewDense(2, 3, data)
    
    // è½¬ç½®
    var mt mat.Dense
    mt.CloneFrom(m.T())
    
    // çŸ©é˜µä¹˜æ³•
    n := mat.NewDense(3, 2, []float64{1, 2, 3, 4, 5, 6})
    var result mat.Dense
    result.Mul(m, n)
    
    fmt.Printf("Result:\n%.2f\n", mat.Formatted(&result))
}

// ç»Ÿè®¡åˆ†æ
func statisticalAnalysis(data []float64) {
    mean := stat.Mean(data, nil)
    variance := stat.Variance(data, nil)
    stdDev := stat.StdDev(data, nil)
    
    fmt.Printf("Mean: %.2f\n", mean)
    fmt.Printf("Variance: %.2f\n", variance)
    fmt.Printf("Std Dev: %.2f\n", stdDev)
}
```

---

## ğŸ§  Neat (ç¥ç»è¿›åŒ–)

```go
import "github.com/jinyeom/neat"

func evolveNN() {
    // åˆ›å»ºé…ç½®
    config := neat.DefaultConfig()
    config.PopSize = 150
    
    // åˆ›å»ºç§ç¾¤
    pop := neat.NewPopulation(config, 2, 1)
    
    // è¿›åŒ–
    for gen := 0; gen < 100; gen++ {
        for _, org := range pop.Organisms {
            // è¯„ä¼°é€‚åº”åº¦
            fitness := evaluateFitness(org.Phenotype)
            org.Fitness = fitness
        }
        
        pop.Epoch()
        
        best := pop.BestOrganism()
        fmt.Printf("Gen %d: Best fitness = %.2f\n", gen, best.Fitness)
    }
}

func evaluateFitness(network *neat.Network) float64 {
    // XORé—®é¢˜
    inputs := [][]float64{{0, 0}, {0, 1}, {1, 0}, {1, 1}}
    expected := []float64{0, 1, 1, 0}
    
    fitness := 4.0
    for i, input := range inputs {
        output := network.Activate(input)
        error := math.Abs(expected[i] - output[0])
        fitness -= error
    }
    
    return fitness * fitness
}
```

---

## ğŸ’¡ å®ç”¨å·¥å…·

### æ•°æ®é¢„å¤„ç†

```go
// å½’ä¸€åŒ–
func normalize(data []float64) []float64 {
    min, max := minMax(data)
    result := make([]float64, len(data))
    
    for i, v := range data {
        result[i] = (v - min) / (max - min)
    }
    
    return result
}

// æ ‡å‡†åŒ–
func standardize(data []float64) []float64 {
    mean := stat.Mean(data, nil)
    stdDev := stat.StdDev(data, nil)
    
    result := make([]float64, len(data))
    for i, v := range data {
        result[i] = (v - mean) / stdDev
    }
    
    return result
}
```

---

## ğŸ“š ç›¸å…³èµ„æº

- [GoLearn](https://github.com/sjwhitworth/golearn)
- [Gorgonia](https://gorgonia.org/)
- [GoNum](https://www.gonum.org/)

**ä¸‹ä¸€æ­¥**: [03-æ·±åº¦å­¦ä¹ æ¡†æ¶](./03-æ·±åº¦å­¦ä¹ æ¡†æ¶.md)

---

**æœ€åæ›´æ–°**: 2025-10-28

