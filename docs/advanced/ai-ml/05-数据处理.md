# 数据处理

**版本**: v1.0
**更新日期**: 2025-10-29
**适用于**: Go 1.25.3

---

## 📋 目录

- [1. 📖 数据加载](#1.-数据加载)[2. 🔄 数据增强](#2.-数据增强)[3. 📊 特征工程](#3.-特征工程)[4. 🔀 数据分割](#4.-数据分割)[5. 🎲 数据采样](#5.-数据采样)[6. 📚 相关资源](#6.-相关资源)📚 相关资源](#相关资源)

---

## 📖 数据加载

```go
package dataloader

import (
    "encoding/csv"
    "os"
)

type Dataset struct {
    Features [][]float64
    Labels   []float64
}

// CSV加载器
func LoadCSV(filename string, hasHeader bool) (*Dataset, error) {
    file, err := os.Open(filename)
    if err != nil {
        return nil, err
    }
    defer file.Close()

    reader := csv.NewReader(file)
    records, err := reader.ReadAll()
    if err != nil {
        return nil, err
    }

    start := 0
    if hasHeader {
        start = 1
    }

    dataset := &Dataset{
        Features: make([][]float64, 0, len(records)-start),
        Labels:   make([]float64, 0, len(records)-start),
    }

    for i := start; i < len(records); i++ {
        row := make([]float64, len(records[i])-1)
        for j := 0; j < len(row); j++ {
            val, _ := strconv.ParseFloat(records[i][j], 64)
            row[j] = val
        }

        label, _ := strconv.ParseFloat(records[i][len(records[i])-1], 64)

        dataset.Features = append(dataset.Features, row)
        dataset.Labels = append(dataset.Labels, label)
    }

    return dataset, nil
}
```

---

## 🔄 数据增强

```go
// 图像数据增强
type ImageAugmenter struct {
    flipHorizontal bool
    rotation       float64
    brightness     float64
}

func (ia *ImageAugmenter) Augment(img [][]float64) [][]float64 {
    result := copyImage(img)

    // 水平翻转
    if ia.flipHorizontal && rand.Float64() < 0.5 {
        result = flipHorizontal(result)
    }

    // 旋转
    if ia.rotation > 0 {
        angle := (rand.Float64()*2 - 1) * ia.rotation
        result = rotate(result, angle)
    }

    // 亮度调整
    if ia.brightness > 0 {
        factor := 1 + (rand.Float64()*2-1)*ia.brightness
        result = adjustBrightness(result, factor)
    }

    return result
}
```

---

## 📊 特征工程

```go
// 特征缩放
func MinMaxScale(data []float64) []float64 {
    min, max := data[0], data[0]
    for _, v := range data {
        if v < min {
            min = v
        }
        if v > max {
            max = v
        }
    }

    result := make([]float64, len(data))
    for i, v := range data {
        result[i] = (v - min) / (max - min)
    }

    return result
}

// One-Hot编码
func OneHotEncode(labels []int, numClasses int) [][]float64 {
    result := make([][]float64, len(labels))

    for i, label := range labels {
        encoded := make([]float64, numClasses)
        encoded[label] = 1.0
        result[i] = encoded
    }

    return result
}
```

---

## 🔀 数据分割

```go
// 训练/测试分割
func TrainTestSplit(X [][]float64, y []float64, testSize float64) (
    XTrain, XTest [][]float64, yTrain, yTest []float64) {

    n := len(X)
    testN := int(float64(n) * testSize)

    // 打乱索引
    indices := rand.Perm(n)

    XTrain = make([][]float64, n-testN)
    yTrain = make([]float64, n-testN)
    XTest = make([][]float64, testN)
    yTest = make([]float64, testN)

    for i := 0; i < testN; i++ {
        idx := indices[i]
        XTest[i] = X[idx]
        yTest[i] = y[idx]
    }

    for i := testN; i < n; i++ {
        idx := indices[i]
        XTrain[i-testN] = X[idx]
        yTrain[i-testN] = y[idx]
    }

    return
}
```

---

## 🎲 数据采样

```go
// Mini-batch采样器
type BatchSampler struct {
    data      [][]float64
    labels    []float64
    batchSize int
    shuffle   bool
    indices   []int
    current   int
}

func NewBatchSampler(data [][]float64, labels []float64, batchSize int, shuffle bool) *BatchSampler {
    indices := make([]int, len(data))
    for i := range indices {
        indices[i] = i
    }

    if shuffle {
        rand.Shuffle(len(indices), func(i, j int) {
            indices[i], indices[j] = indices[j], indices[i]
        })
    }

    return &BatchSampler{
        data:      data,
        labels:    labels,
        batchSize: batchSize,
        shuffle:   shuffle,
        indices:   indices,
        current:   0,
    }
}

func (bs *BatchSampler) NextBatch() ([][]float64, []float64, bool) {
    if bs.current >= len(bs.indices) {
        return nil, nil, false
    }

    end := bs.current + bs.batchSize
    if end > len(bs.indices) {
        end = len(bs.indices)
    }

    batchIndices := bs.indices[bs.current:end]
    bs.current = end

    batchData := make([][]float64, len(batchIndices))
    batchLabels := make([]float64, len(batchIndices))

    for i, idx := range batchIndices {
        batchData[i] = bs.data[idx]
        batchLabels[i] = bs.labels[idx]
    }

    return batchData, batchLabels, true
}

func (bs *BatchSampler) Reset() {
    bs.current = 0
    if bs.shuffle {
        rand.Shuffle(len(bs.indices), func(i, j int) {
            bs.indices[i], bs.indices[j] = bs.indices[j], bs.indices[i]
        })
    }
}
```

---

## 📚 相关资源

- [GoNum](https://www.gonum.org/)
- [Data Processing in Go](https://github.com/go-gota/gota)

**下一步**: [06-实战案例](./06-实战案例.md)

---

**最后更新**: 2025-10-29
