# æ•°æ®å¤„ç†

**éš¾åº¦**: ä¸­çº§ | **é¢„è®¡é˜…è¯»**: 15åˆ†é’Ÿ

---

## ğŸ“– æ•°æ®åŠ è½½

```go
package dataloader

import (
    "encoding/csv"
    "os"
)

type Dataset struct {
    Features [][]float64
    Labels   []float64
}

// CSVåŠ è½½å™¨
func LoadCSV(filename string, hasHeader bool) (*Dataset, error) {
    file, err := os.Open(filename)
    if err != nil {
        return nil, err
    }
    defer file.Close()
    
    reader := csv.NewReader(file)
    records, err := reader.ReadAll()
    if err != nil {
        return nil, err
    }
    
    start := 0
    if hasHeader {
        start = 1
    }
    
    dataset := &Dataset{
        Features: make([][]float64, 0, len(records)-start),
        Labels:   make([]float64, 0, len(records)-start),
    }
    
    for i := start; i < len(records); i++ {
        row := make([]float64, len(records[i])-1)
        for j := 0; j < len(row); j++ {
            val, _ := strconv.ParseFloat(records[i][j], 64)
            row[j] = val
        }
        
        label, _ := strconv.ParseFloat(records[i][len(records[i])-1], 64)
        
        dataset.Features = append(dataset.Features, row)
        dataset.Labels = append(dataset.Labels, label)
    }
    
    return dataset, nil
}
```

---

## ğŸ”„ æ•°æ®å¢å¼º

```go
// å›¾åƒæ•°æ®å¢å¼º
type ImageAugmenter struct {
    flipHorizontal bool
    rotation       float64
    brightness     float64
}

func (ia *ImageAugmenter) Augment(img [][]float64) [][]float64 {
    result := copyImage(img)
    
    // æ°´å¹³ç¿»è½¬
    if ia.flipHorizontal && rand.Float64() < 0.5 {
        result = flipHorizontal(result)
    }
    
    // æ—‹è½¬
    if ia.rotation > 0 {
        angle := (rand.Float64()*2 - 1) * ia.rotation
        result = rotate(result, angle)
    }
    
    // äº®åº¦è°ƒæ•´
    if ia.brightness > 0 {
        factor := 1 + (rand.Float64()*2-1)*ia.brightness
        result = adjustBrightness(result, factor)
    }
    
    return result
}
```

---

## ğŸ“Š ç‰¹å¾å·¥ç¨‹

```go
// ç‰¹å¾ç¼©æ”¾
func MinMaxScale(data []float64) []float64 {
    min, max := data[0], data[0]
    for _, v := range data {
        if v < min {
            min = v
        }
        if v > max {
            max = v
        }
    }
    
    result := make([]float64, len(data))
    for i, v := range data {
        result[i] = (v - min) / (max - min)
    }
    
    return result
}

// One-Hotç¼–ç 
func OneHotEncode(labels []int, numClasses int) [][]float64 {
    result := make([][]float64, len(labels))
    
    for i, label := range labels {
        encoded := make([]float64, numClasses)
        encoded[label] = 1.0
        result[i] = encoded
    }
    
    return result
}
```

---

## ğŸ”€ æ•°æ®åˆ†å‰²

```go
// è®­ç»ƒ/æµ‹è¯•åˆ†å‰²
func TrainTestSplit(X [][]float64, y []float64, testSize float64) (
    XTrain, XTest [][]float64, yTrain, yTest []float64) {
    
    n := len(X)
    testN := int(float64(n) * testSize)
    
    // æ‰“ä¹±ç´¢å¼•
    indices := rand.Perm(n)
    
    XTrain = make([][]float64, n-testN)
    yTrain = make([]float64, n-testN)
    XTest = make([][]float64, testN)
    yTest = make([]float64, testN)
    
    for i := 0; i < testN; i++ {
        idx := indices[i]
        XTest[i] = X[idx]
        yTest[i] = y[idx]
    }
    
    for i := testN; i < n; i++ {
        idx := indices[i]
        XTrain[i-testN] = X[idx]
        yTrain[i-testN] = y[idx]
    }
    
    return
}
```

---

## ğŸ² æ•°æ®é‡‡æ ·

```go
// Mini-batché‡‡æ ·å™¨
type BatchSampler struct {
    data      [][]float64
    labels    []float64
    batchSize int
    shuffle   bool
    indices   []int
    current   int
}

func NewBatchSampler(data [][]float64, labels []float64, batchSize int, shuffle bool) *BatchSampler {
    indices := make([]int, len(data))
    for i := range indices {
        indices[i] = i
    }
    
    if shuffle {
        rand.Shuffle(len(indices), func(i, j int) {
            indices[i], indices[j] = indices[j], indices[i]
        })
    }
    
    return &BatchSampler{
        data:      data,
        labels:    labels,
        batchSize: batchSize,
        shuffle:   shuffle,
        indices:   indices,
        current:   0,
    }
}

func (bs *BatchSampler) NextBatch() ([][]float64, []float64, bool) {
    if bs.current >= len(bs.indices) {
        return nil, nil, false
    }
    
    end := bs.current + bs.batchSize
    if end > len(bs.indices) {
        end = len(bs.indices)
    }
    
    batchIndices := bs.indices[bs.current:end]
    bs.current = end
    
    batchData := make([][]float64, len(batchIndices))
    batchLabels := make([]float64, len(batchIndices))
    
    for i, idx := range batchIndices {
        batchData[i] = bs.data[idx]
        batchLabels[i] = bs.labels[idx]
    }
    
    return batchData, batchLabels, true
}

func (bs *BatchSampler) Reset() {
    bs.current = 0
    if bs.shuffle {
        rand.Shuffle(len(bs.indices), func(i, j int) {
            bs.indices[i], bs.indices[j] = bs.indices[j], bs.indices[i]
        })
    }
}
```

---

## ğŸ“š ç›¸å…³èµ„æº

- [GoNum](https://www.gonum.org/)
- [Data Processing in Go](https://github.com/go-gota/gota)

**ä¸‹ä¸€æ­¥**: [06-å®æˆ˜æ¡ˆä¾‹](./06-å®æˆ˜æ¡ˆä¾‹.md)

---

**æœ€åæ›´æ–°**: 2025-10-28

