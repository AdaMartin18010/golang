# 实战案例

**难度**: 高级 | **预计阅读**: 20分钟

---

## 📖 完整推理服务

```go
package main

import (
    "encoding/json"
    "log"
    "net/http"
    "time"
    
    "github.com/gorilla/mux"
)

type MLService struct {
    server  *InferenceServer
    metrics *InferenceMetrics
}

func NewMLService(modelPath string) (*MLService, error) {
    // 加载模型
    model, err := LoadONNXModel(modelPath)
    if err != nil {
        return nil, err
    }
    
    // 模型预热
    warmer := &ModelWarmer{model: model, warmupNum: 10}
    warmer.Warmup()
    
    // 创建推理服务
    server := NewInferenceServer(model, 32, 100*time.Millisecond)
    server.Start(context.Background())
    
    return &MLService{
        server:  server,
        metrics: &InferenceMetrics{},
    }, nil
}

func (ms *MLService) PredictHandler(w http.ResponseWriter, r *http.Request) {
    start := time.Now()
    
    var req struct {
        Features []float32 `json:"features"`
    }
    
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        ms.metrics.RecordRequest(time.Since(start), err)
        return
    }
    
    // 推理
    result, err := ms.server.Predict(req.Features)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        ms.metrics.RecordRequest(time.Since(start), err)
        return
    }
    
    ms.metrics.RecordRequest(time.Since(start), nil)
    
    json.NewEncoder(w).Encode(map[string]interface{}{
        "prediction": result,
        "latency_ms": time.Since(start).Milliseconds(),
    })
}

func (ms *MLService) MetricsHandler(w http.ResponseWriter, r *http.Request) {
    json.NewEncoder(w).Encode(ms.metrics.Stats())
}

func (ms *MLService) HealthHandler(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(map[string]string{
        "status": "healthy",
    })
}

func main() {
    service, err := NewMLService("model.onnx")
    if err != nil {
        log.Fatal(err)
    }
    
    r := mux.NewRouter()
    r.HandleFunc("/predict", service.PredictHandler).Methods("POST")
    r.HandleFunc("/metrics", service.MetricsHandler).Methods("GET")
    r.HandleFunc("/health", service.HealthHandler).Methods("GET")
    
    log.Println("Starting ML service on :8080")
    log.Fatal(http.ListenAndServe(":8080", r))
}
```

---

## 🔄 模型版本管理

```go
type ModelRegistry struct {
    models map[string]*ModelVersion
    mu     sync.RWMutex
}

type ModelVersion struct {
    Version string
    Model   Model
    Metrics *ModelMetrics
}

func (mr *ModelRegistry) RegisterModel(version string, model Model) {
    mr.mu.Lock()
    defer mr.mu.Unlock()
    
    mr.models[version] = &ModelVersion{
        Version: version,
        Model:   model,
        Metrics: &ModelMetrics{},
    }
}

func (mr *ModelRegistry) GetModel(version string) (Model, error) {
    mr.mu.RLock()
    defer mr.mu.RUnlock()
    
    mv, exists := mr.models[version]
    if !exists {
        return nil, fmt.Errorf("model version %s not found", version)
    }
    
    return mv.Model, nil
}
```

---

## 📊 在线学习

```go
type OnlineLearner struct {
    model      Model
    buffer     []TrainingSample
    bufferSize int
    retrainAt  int
}

type TrainingSample struct {
    Features []float32
    Label    float32
}

func (ol *OnlineLearner) Predict(features []float32) (float32, error) {
    return ol.model.Predict(features)
}

func (ol *OnlineLearner) AddSample(features []float32, label float32) {
    ol.buffer = append(ol.buffer, TrainingSample{
        Features: features,
        Label:    label,
    })
    
    // 达到阈值时重新训练
    if len(ol.buffer) >= ol.retrainAt {
        go ol.retrain()
    }
}

func (ol *OnlineLearner) retrain() {
    log.Println("Retraining model with new samples...")
    
    // 使用缓冲区数据重新训练
    newModel := ol.model.Clone()
    newModel.Train(ol.buffer)
    
    // 原子替换模型
    ol.model = newModel
    
    // 清空缓冲区
    ol.buffer = ol.buffer[:0]
    
    log.Println("Model retrained successfully")
}
```

---

## 🎯 实时特征提取

```go
type FeatureExtractor struct {
    cache *cache.Cache
}

func (fe *FeatureExtractor) Extract(ctx context.Context, userID string) ([]float32, error) {
    // 检查缓存
    if cached, found := fe.cache.Get(userID); found {
        return cached.([]float32), nil
    }
    
    // 提取特征
    features := make([]float32, 0)
    
    // 用户基本特征
    userFeatures, _ := fe.getUserFeatures(ctx, userID)
    features = append(features, userFeatures...)
    
    // 行为特征
    behaviorFeatures, _ := fe.getBehaviorFeatures(ctx, userID)
    features = append(features, behaviorFeatures...)
    
    // 缓存
    fe.cache.Set(userID, features, 5*time.Minute)
    
    return features, nil
}
```

---

## 📚 相关资源

- [Production ML Systems](https://developers.google.com/machine-learning/crash-course/production-ml-systems)
- [MLOps](https://ml-ops.org/)

---

**最后更新**: 2025-10-28

