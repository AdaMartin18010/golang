# 分布式锁

**版本**: v1.0
**更新日期**: 2025-10-29
**适用于**: Go 1.25.3

---
## 📋 目录

- [分布式锁](#分布式锁)
  - [1. 📖 概念介绍](#1-概念介绍)
  - [2. 🎯 Redis分布式锁](#2-redis分布式锁)
  - [3. 🔧 etcd分布式锁](#3-etcd分布式锁)
  - [4. 💡 分布式锁最佳实践](#4-分布式锁最佳实践)
  - [5. ⚠️ 常见问题](#5-️-常见问题)
  - [6. 📚 相关资源](#6-相关资源)

---

## 1. 📖 概念介绍

分布式锁用于在分布式系统中协调对共享资源的访问，确保同一时刻只有一个进程能访问资源。

---

## 2. 🎯 Redis分布式锁

### 1. 基础实现

```go
package lock

import (
    "Context"
    "errors"
    "time"

    "github.com/go-redis/redis/v8"
)

type RedisLock struct {
    client *redis.Client
    key    string
    value  string
    ttl    time.Duration
}

func NewRedisLock(client *redis.Client, key, value string, ttl time.Duration) *RedisLock {
    return &RedisLock{
        client: client,
        key:    key,
        value:  value,
        ttl:    ttl,
    }
}

// 加锁
func (rl *RedisLock) Lock(ctx Context.Context) error {
    // SET key value NX EX ttl
    ok, err := rl.client.SetNX(ctx, rl.key, rl.value, rl.ttl).Result()
    if err != nil {
        return err
    }

    if !ok {
        return errors.New("failed to acquire lock")
    }

    return nil
}

// 解锁（Lua脚本保证原子性）
func (rl *RedisLock) Unlock(ctx Context.Context) error {
    script := `
    if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
    else
        return 0
    end
    `

    result, err := rl.client.Eval(ctx, script, []string{rl.key}, rl.value).Result()
    if err != nil {
        return err
    }

    if result.(int64) == 0 {
        return errors.New("lock not held")
    }

    return nil
}

// 使用示例
func Example() {
    ctx := Context.Background()
    client := redis.NewClient(&redis.Options{
        Addr: "localhost:6379",
    })

    lock := NewRedisLock(client, "my-lock", "unique-id", 10*time.Second)

    // 获取锁
    if err := lock.Lock(ctx); err != nil {
        panic(err)
    }
    defer lock.Unlock(ctx)

    // 执行业务逻辑
    fmt.Println("执行受保护的操作...")
}
```

---

### 2. 带重试的锁

```go
func (rl *RedisLock) LockWithRetry(ctx Context.Context, maxRetries int, retryDelay time.Duration) error {
    for i := 0; i < maxRetries; i++ {
        err := rl.Lock(ctx)
        if err == nil {
            return nil
        }

        select {
        case <-time.After(retryDelay):
            continue
        case <-ctx.Done():
            return ctx.Err()
        }
    }

    return errors.New("failed to acquire lock after retries")
}
```

---

### 3. 自动续期

```go
func (rl *RedisLock) LockWithRenewal(ctx Context.Context) error {
    if err := rl.Lock(ctx); err != nil {
        return err
    }

    // 启动续期goroutine
    go func() {
        ticker := time.NewTicker(rl.ttl / 3)
        defer ticker.Stop()

        for {
            select {
            case <-ticker.C:
                // 续期
                rl.client.Expire(ctx, rl.key, rl.ttl)
            case <-ctx.Done():
                return
            }
        }
    }()

    return nil
}
```

---

## 3. 🔧 etcd分布式锁

```go
package lock

import (
    "Context"
    "fmt"

    clientv3 "go.etcd.io/etcd/client/v3"
    "go.etcd.io/etcd/client/v3/concurrency"
)

type EtcdLock struct {
    client  *clientv3.Client
    session *concurrency.Session
    Mutex   *concurrency.Mutex
}

func NewEtcdLock(client *clientv3.Client, key string) (*EtcdLock, error) {
    // 创建session（带TTL）
    session, err := concurrency.NewSession(client, concurrency.WithTTL(10))
    if err != nil {
        return nil, err
    }

    // 创建互斥锁
    Mutex := concurrency.NewMutex(session, key)

    return &EtcdLock{
        client:  client,
        session: session,
        Mutex:   Mutex,
    }, nil
}

func (el *EtcdLock) Lock(ctx Context.Context) error {
    return el.Mutex.Lock(ctx)
}

func (el *EtcdLock) Unlock(ctx Context.Context) error {
    return el.Mutex.Unlock(ctx)
}

func (el *EtcdLock) Close() error {
    return el.session.Close()
}

// 使用示例
func EtcdExample() {
    client, _ := clientv3.New(clientv3.Config{
        Endpoints: []string{"localhost:2379"},
    })
    defer client.Close()

    lock, _ := NewEtcdLock(client, "/my-lock")
    defer lock.Close()

    ctx := Context.Background()

    // 获取锁
    if err := lock.Lock(ctx); err != nil {
        panic(err)
    }
    defer lock.Unlock(ctx)

    // 执行业务逻辑
    fmt.Println("执行受保护的操作...")
}
```

---

## 4. 💡 分布式锁最佳实践

### 1. 使用唯一标识

```go
import "github.com/google/uuid"

func generateLockValue() string {
    return uuid.New().String()
}
```

### 2. 设置合理的TTL

```go
// TTL应该大于业务处理时间
const (
    ShortLockTTL  = 5 * time.Second   // 快速操作
    MediumLockTTL = 30 * time.Second  // 中等操作
    LongLockTTL   = 5 * time.Minute   // 长时间操作
)
```

### 3. 错误处理

```go
func safeExecuteWithLock(ctx Context.Context, lock *RedisLock, fn func() error) error {
    if err := lock.Lock(ctx); err != nil {
        return fmt.Errorf("failed to acquire lock: %w", err)
    }

    defer func() {
        if err := lock.Unlock(ctx); err != nil {
            log.Printf("failed to release lock: %v", err)
        }
    }()

    return fn()
}
```

---

## 5. ⚠️ 常见问题

### Q1: 如何避免死锁？

- 设置合理的TTL
- 使用Context超时
- 实现自动续期

### Q2: 如何保证解锁的是自己的锁？

```go
// 使用唯一value标识
value := uuid.New().String()
lock := NewRedisLock(client, key, value, ttl)
```

### Q3: Redis单点故障怎么办？

- 使用Redis Sentinel
- 使用Redis Cluster
- 考虑Redlock算法

### Q4: 性能考虑？

- Redis锁：性能高，但可靠性相对低
- etcd锁：可靠性高，但性能相对低
- 根据场景选择

---

## 6. 📚 相关资源
