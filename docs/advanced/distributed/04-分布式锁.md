# 分布式锁

**难度**: 高级 | **预计阅读**: 20分钟 | **前置知识**: Redis、etcd基础

---

## 📋 目录


- [1. 📖 概念介绍](#1--概念介绍)
- [2. 🎯 Redis分布式锁](#2--redis分布式锁)
  - [1. 基础实现](#1-基础实现)
  - [2. 带重试的锁](#2-带重试的锁)
  - [3. 自动续期](#3-自动续期)
- [3. 🔧 etcd分布式锁](#3--etcd分布式锁)
- [4. 💡 分布式锁最佳实践](#4--分布式锁最佳实践)
  - [1. 使用唯一标识](#1-使用唯一标识)
  - [2. 设置合理的TTL](#2-设置合理的ttl)
  - [3. 错误处理](#3-错误处理)
- [5. ⚠️ 常见问题](#5--常见问题)
  - [Q1: 如何避免死锁？](#q1-如何避免死锁)
  - [Q2: 如何保证解锁的是自己的锁？](#q2-如何保证解锁的是自己的锁)
  - [Q3: Redis单点故障怎么办？](#q3-redis单点故障怎么办)
  - [Q4: 性能考虑？](#q4-性能考虑)
- [6. 📚 相关资源](#6--相关资源)

## 1. 📖 概念介绍

分布式锁用于在分布式系统中协调对共享资源的访问，确保同一时刻只有一个进程能访问资源。

---

## 2. 🎯 Redis分布式锁

### 1. 基础实现

```go
package lock

import (
    "context"
    "errors"
    "time"
    
    "github.com/go-redis/redis/v8"
)

type RedisLock struct {
    client *redis.Client
    key    string
    value  string
    ttl    time.Duration
}

func NewRedisLock(client *redis.Client, key, value string, ttl time.Duration) *RedisLock {
    return &RedisLock{
        client: client,
        key:    key,
        value:  value,
        ttl:    ttl,
    }
}

// 加锁
func (rl *RedisLock) Lock(ctx context.Context) error {
    // SET key value NX EX ttl
    ok, err := rl.client.SetNX(ctx, rl.key, rl.value, rl.ttl).Result()
    if err != nil {
        return err
    }
    
    if !ok {
        return errors.New("failed to acquire lock")
    }
    
    return nil
}

// 解锁（Lua脚本保证原子性）
func (rl *RedisLock) Unlock(ctx context.Context) error {
    script := `
    if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
    else
        return 0
    end
    `
    
    result, err := rl.client.Eval(ctx, script, []string{rl.key}, rl.value).Result()
    if err != nil {
        return err
    }
    
    if result.(int64) == 0 {
        return errors.New("lock not held")
    }
    
    return nil
}

// 使用示例
func Example() {
    ctx := context.Background()
    client := redis.NewClient(&redis.Options{
        Addr: "localhost:6379",
    })
    
    lock := NewRedisLock(client, "my-lock", "unique-id", 10*time.Second)
    
    // 获取锁
    if err := lock.Lock(ctx); err != nil {
        panic(err)
    }
    defer lock.Unlock(ctx)
    
    // 执行业务逻辑
    fmt.Println("执行受保护的操作...")
}
```

---

### 2. 带重试的锁

```go
func (rl *RedisLock) LockWithRetry(ctx context.Context, maxRetries int, retryDelay time.Duration) error {
    for i := 0; i < maxRetries; i++ {
        err := rl.Lock(ctx)
        if err == nil {
            return nil
        }
        
        select {
        case <-time.After(retryDelay):
            continue
        case <-ctx.Done():
            return ctx.Err()
        }
    }
    
    return errors.New("failed to acquire lock after retries")
}
```

---

### 3. 自动续期

```go
func (rl *RedisLock) LockWithRenewal(ctx context.Context) error {
    if err := rl.Lock(ctx); err != nil {
        return err
    }
    
    // 启动续期goroutine
    go func() {
        ticker := time.NewTicker(rl.ttl / 3)
        defer ticker.Stop()
        
        for {
            select {
            case <-ticker.C:
                // 续期
                rl.client.Expire(ctx, rl.key, rl.ttl)
            case <-ctx.Done():
                return
            }
        }
    }()
    
    return nil
}
```

---

## 3. 🔧 etcd分布式锁

```go
package lock

import (
    "context"
    "fmt"
    
    clientv3 "go.etcd.io/etcd/client/v3"
    "go.etcd.io/etcd/client/v3/concurrency"
)

type EtcdLock struct {
    client  *clientv3.Client
    session *concurrency.Session
    mutex   *concurrency.Mutex
}

func NewEtcdLock(client *clientv3.Client, key string) (*EtcdLock, error) {
    // 创建session（带TTL）
    session, err := concurrency.NewSession(client, concurrency.WithTTL(10))
    if err != nil {
        return nil, err
    }
    
    // 创建互斥锁
    mutex := concurrency.NewMutex(session, key)
    
    return &EtcdLock{
        client:  client,
        session: session,
        mutex:   mutex,
    }, nil
}

func (el *EtcdLock) Lock(ctx context.Context) error {
    return el.mutex.Lock(ctx)
}

func (el *EtcdLock) Unlock(ctx context.Context) error {
    return el.mutex.Unlock(ctx)
}

func (el *EtcdLock) Close() error {
    return el.session.Close()
}

// 使用示例
func EtcdExample() {
    client, _ := clientv3.New(clientv3.Config{
        Endpoints: []string{"localhost:2379"},
    })
    defer client.Close()
    
    lock, _ := NewEtcdLock(client, "/my-lock")
    defer lock.Close()
    
    ctx := context.Background()
    
    // 获取锁
    if err := lock.Lock(ctx); err != nil {
        panic(err)
    }
    defer lock.Unlock(ctx)
    
    // 执行业务逻辑
    fmt.Println("执行受保护的操作...")
}
```

---

## 4. 💡 分布式锁最佳实践

### 1. 使用唯一标识

```go
import "github.com/google/uuid"

func generateLockValue() string {
    return uuid.New().String()
}
```

### 2. 设置合理的TTL

```go
// TTL应该大于业务处理时间
const (
    ShortLockTTL  = 5 * time.Second   // 快速操作
    MediumLockTTL = 30 * time.Second  // 中等操作
    LongLockTTL   = 5 * time.Minute   // 长时间操作
)
```

### 3. 错误处理

```go
func safeExecuteWithLock(ctx context.Context, lock *RedisLock, fn func() error) error {
    if err := lock.Lock(ctx); err != nil {
        return fmt.Errorf("failed to acquire lock: %w", err)
    }
    
    defer func() {
        if err := lock.Unlock(ctx); err != nil {
            log.Printf("failed to release lock: %v", err)
        }
    }()
    
    return fn()
}
```

---

## 5. ⚠️ 常见问题

### Q1: 如何避免死锁？
- 设置合理的TTL
- 使用Context超时
- 实现自动续期

### Q2: 如何保证解锁的是自己的锁？
```go
// 使用唯一value标识
value := uuid.New().String()
lock := NewRedisLock(client, key, value, ttl)
```

### Q3: Redis单点故障怎么办？
- 使用Redis Sentinel
- 使用Redis Cluster
- 考虑Redlock算法

### Q4: 性能考虑？
- Redis锁：性能高，但可靠性相对低
- etcd锁：可靠性高，但性能相对低
- 根据场景选择

---

## 6. 📚 相关资源

- [Redlock Algorithm](https://redis.io/topics/distlock)
- [etcd Concurrency](https://etcd.io/docs/latest/learning/api/#concurrency)

**下一步**: [05-分布式事务](./05-分布式事务.md)

---

**最后更新**: 2025-10-28

