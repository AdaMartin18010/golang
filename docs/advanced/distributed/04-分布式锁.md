# åˆ†å¸ƒå¼é”

**éš¾åº¦**: é«˜çº§ | **é¢„è®¡é˜…è¯»**: 20åˆ†é’Ÿ | **å‰ç½®çŸ¥è¯†**: Redisã€etcdåŸºç¡€

---

## ğŸ“– æ¦‚å¿µä»‹ç»

åˆ†å¸ƒå¼é”ç”¨äºåœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­åè°ƒå¯¹å…±äº«èµ„æºçš„è®¿é—®ï¼Œç¡®ä¿åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªè¿›ç¨‹èƒ½è®¿é—®èµ„æºã€‚

---

## ğŸ¯ Redisåˆ†å¸ƒå¼é”

### 1. åŸºç¡€å®ç°

```go
package lock

import (
    "context"
    "errors"
    "time"
    
    "github.com/go-redis/redis/v8"
)

type RedisLock struct {
    client *redis.Client
    key    string
    value  string
    ttl    time.Duration
}

func NewRedisLock(client *redis.Client, key, value string, ttl time.Duration) *RedisLock {
    return &RedisLock{
        client: client,
        key:    key,
        value:  value,
        ttl:    ttl,
    }
}

// åŠ é”
func (rl *RedisLock) Lock(ctx context.Context) error {
    // SET key value NX EX ttl
    ok, err := rl.client.SetNX(ctx, rl.key, rl.value, rl.ttl).Result()
    if err != nil {
        return err
    }
    
    if !ok {
        return errors.New("failed to acquire lock")
    }
    
    return nil
}

// è§£é”ï¼ˆLuaè„šæœ¬ä¿è¯åŸå­æ€§ï¼‰
func (rl *RedisLock) Unlock(ctx context.Context) error {
    script := `
    if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
    else
        return 0
    end
    `
    
    result, err := rl.client.Eval(ctx, script, []string{rl.key}, rl.value).Result()
    if err != nil {
        return err
    }
    
    if result.(int64) == 0 {
        return errors.New("lock not held")
    }
    
    return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    ctx := context.Background()
    client := redis.NewClient(&redis.Options{
        Addr: "localhost:6379",
    })
    
    lock := NewRedisLock(client, "my-lock", "unique-id", 10*time.Second)
    
    // è·å–é”
    if err := lock.Lock(ctx); err != nil {
        panic(err)
    }
    defer lock.Unlock(ctx)
    
    // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
    fmt.Println("æ‰§è¡Œå—ä¿æŠ¤çš„æ“ä½œ...")
}
```

---

### 2. å¸¦é‡è¯•çš„é”

```go
func (rl *RedisLock) LockWithRetry(ctx context.Context, maxRetries int, retryDelay time.Duration) error {
    for i := 0; i < maxRetries; i++ {
        err := rl.Lock(ctx)
        if err == nil {
            return nil
        }
        
        select {
        case <-time.After(retryDelay):
            continue
        case <-ctx.Done():
            return ctx.Err()
        }
    }
    
    return errors.New("failed to acquire lock after retries")
}
```

---

### 3. è‡ªåŠ¨ç»­æœŸ

```go
func (rl *RedisLock) LockWithRenewal(ctx context.Context) error {
    if err := rl.Lock(ctx); err != nil {
        return err
    }
    
    // å¯åŠ¨ç»­æœŸgoroutine
    go func() {
        ticker := time.NewTicker(rl.ttl / 3)
        defer ticker.Stop()
        
        for {
            select {
            case <-ticker.C:
                // ç»­æœŸ
                rl.client.Expire(ctx, rl.key, rl.ttl)
            case <-ctx.Done():
                return
            }
        }
    }()
    
    return nil
}
```

---

## ğŸ”§ etcdåˆ†å¸ƒå¼é”

```go
package lock

import (
    "context"
    "fmt"
    
    clientv3 "go.etcd.io/etcd/client/v3"
    "go.etcd.io/etcd/client/v3/concurrency"
)

type EtcdLock struct {
    client  *clientv3.Client
    session *concurrency.Session
    mutex   *concurrency.Mutex
}

func NewEtcdLock(client *clientv3.Client, key string) (*EtcdLock, error) {
    // åˆ›å»ºsessionï¼ˆå¸¦TTLï¼‰
    session, err := concurrency.NewSession(client, concurrency.WithTTL(10))
    if err != nil {
        return nil, err
    }
    
    // åˆ›å»ºäº’æ–¥é”
    mutex := concurrency.NewMutex(session, key)
    
    return &EtcdLock{
        client:  client,
        session: session,
        mutex:   mutex,
    }, nil
}

func (el *EtcdLock) Lock(ctx context.Context) error {
    return el.mutex.Lock(ctx)
}

func (el *EtcdLock) Unlock(ctx context.Context) error {
    return el.mutex.Unlock(ctx)
}

func (el *EtcdLock) Close() error {
    return el.session.Close()
}

// ä½¿ç”¨ç¤ºä¾‹
func EtcdExample() {
    client, _ := clientv3.New(clientv3.Config{
        Endpoints: []string{"localhost:2379"},
    })
    defer client.Close()
    
    lock, _ := NewEtcdLock(client, "/my-lock")
    defer lock.Close()
    
    ctx := context.Background()
    
    // è·å–é”
    if err := lock.Lock(ctx); err != nil {
        panic(err)
    }
    defer lock.Unlock(ctx)
    
    // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
    fmt.Println("æ‰§è¡Œå—ä¿æŠ¤çš„æ“ä½œ...")
}
```

---

## ğŸ’¡ åˆ†å¸ƒå¼é”æœ€ä½³å®è·µ

### 1. ä½¿ç”¨å”¯ä¸€æ ‡è¯†

```go
import "github.com/google/uuid"

func generateLockValue() string {
    return uuid.New().String()
}
```

### 2. è®¾ç½®åˆç†çš„TTL

```go
// TTLåº”è¯¥å¤§äºä¸šåŠ¡å¤„ç†æ—¶é—´
const (
    ShortLockTTL  = 5 * time.Second   // å¿«é€Ÿæ“ä½œ
    MediumLockTTL = 30 * time.Second  // ä¸­ç­‰æ“ä½œ
    LongLockTTL   = 5 * time.Minute   // é•¿æ—¶é—´æ“ä½œ
)
```

### 3. é”™è¯¯å¤„ç†

```go
func safeExecuteWithLock(ctx context.Context, lock *RedisLock, fn func() error) error {
    if err := lock.Lock(ctx); err != nil {
        return fmt.Errorf("failed to acquire lock: %w", err)
    }
    
    defer func() {
        if err := lock.Unlock(ctx); err != nil {
            log.Printf("failed to release lock: %v", err)
        }
    }()
    
    return fn()
}
```

---

## âš ï¸ å¸¸è§é—®é¢˜

### Q1: å¦‚ä½•é¿å…æ­»é”ï¼Ÿ
- è®¾ç½®åˆç†çš„TTL
- ä½¿ç”¨Contextè¶…æ—¶
- å®ç°è‡ªåŠ¨ç»­æœŸ

### Q2: å¦‚ä½•ä¿è¯è§£é”çš„æ˜¯è‡ªå·±çš„é”ï¼Ÿ
```go
// ä½¿ç”¨å”¯ä¸€valueæ ‡è¯†
value := uuid.New().String()
lock := NewRedisLock(client, key, value, ttl)
```

### Q3: Rediså•ç‚¹æ•…éšœæ€ä¹ˆåŠï¼Ÿ
- ä½¿ç”¨Redis Sentinel
- ä½¿ç”¨Redis Cluster
- è€ƒè™‘Redlockç®—æ³•

### Q4: æ€§èƒ½è€ƒè™‘ï¼Ÿ
- Redisé”ï¼šæ€§èƒ½é«˜ï¼Œä½†å¯é æ€§ç›¸å¯¹ä½
- etcdé”ï¼šå¯é æ€§é«˜ï¼Œä½†æ€§èƒ½ç›¸å¯¹ä½
- æ ¹æ®åœºæ™¯é€‰æ‹©

---

## ğŸ“š ç›¸å…³èµ„æº

- [Redlock Algorithm](https://redis.io/topics/distlock)
- [etcd Concurrency](https://etcd.io/docs/latest/learning/api/#concurrency)

**ä¸‹ä¸€æ­¥**: [05-åˆ†å¸ƒå¼äº‹åŠ¡](./05-åˆ†å¸ƒå¼äº‹åŠ¡.md)

---

**æœ€åæ›´æ–°**: 2025-10-28

