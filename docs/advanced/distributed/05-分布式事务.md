# 分布式事务

**难度**: 高级 | **预计阅读**: 20分钟 | **前置知识**: 数据库事务、分布式系统

---

## 📋 目录

- [1. 📖 概念介绍](#1--概念介绍)
- [2. 🎯 核心模式](#2--核心模式)
- [3. 💡 最佳实践](#3--最佳实践)
- [4. 📚 相关资源](#4--相关资源)

---

## 1. 📖 概念介绍

分布式事务确保跨多个服务或数据库的操作要么全部成功，要么全部失败，保证数据一致性。

---

## 2. 🎯 核心模式

### 1. Saga模式

```go
package saga

import (
    "context"
    "errors"
)

// Saga步骤
type Step struct {
    Name        string
    Action      func(ctx context.Context) error
    Compensate  func(ctx context.Context) error
}

// Saga协调器
type Saga struct {
    steps []Step
}

func NewSaga() *Saga {
    return &Saga{
        steps: make([]Step, 0),
    }
}

func (s *Saga) AddStep(name string, action, compensate func(context.Context) error) *Saga {
    s.steps = append(s.steps, Step{
        Name:       name,
        Action:     action,
        Compensate: compensate,
    })
    return s
}

// 执行Saga
func (s *Saga) Execute(ctx context.Context) error {
    executed := make([]Step, 0)
    
    // 顺序执行所有步骤
    for _, step := range s.steps {
        if err := step.Action(ctx); err != nil {
            // 失败：执行补偿
            s.compensate(ctx, executed)
            return errors.New(fmt.Sprintf("step %s failed: %v", step.Name, err))
        }
        executed = append(executed, step)
    }
    
    return nil
}

// 补偿已执行的步骤
func (s *Saga) compensate(ctx context.Context, executed []Step) {
    // 逆序执行补偿
    for i := len(executed) - 1; i >= 0; i-- {
        step := executed[i]
        if err := step.Compensate(ctx); err != nil {
            log.Printf("compensation failed for step %s: %v", step.Name, err)
        }
    }
}

// 使用示例：订单流程
func CreateOrderSaga(orderID string, amount float64) *Saga {
    saga := NewSaga()
    
    // 步骤1：扣减库存
    saga.AddStep("reserve_inventory",
        func(ctx context.Context) error {
            return inventoryService.Reserve(orderID, amount)
        },
        func(ctx context.Context) error {
            return inventoryService.Release(orderID, amount)
        })
    
    // 步骤2：扣减余额
    saga.AddStep("deduct_balance",
        func(ctx context.Context) error {
            return paymentService.Deduct(orderID, amount)
        },
        func(ctx context.Context) error {
            return paymentService.Refund(orderID, amount)
        })
    
    // 步骤3：创建订单
    saga.AddStep("create_order",
        func(ctx context.Context) error {
            return orderService.Create(orderID)
        },
        func(ctx context.Context) error {
            return orderService.Cancel(orderID)
        })
    
    return saga
}
```

---

### 2. TCC模式

```go
package tcc

import "context"

// TCC接口
type TCC interface {
    Try(ctx context.Context, params interface{}) error
    Confirm(ctx context.Context, params interface{}) error
    Cancel(ctx context.Context, params interface{}) error
}

// TCC协调器
type TCCCoordinator struct {
    participants []TCC
}

func (tc *TCCCoordinator) Execute(ctx context.Context, params interface{}) error {
    // Phase 1: Try - 预留资源
    for _, p := range tc.participants {
        if err := p.Try(ctx, params); err != nil {
            // Try失败，取消所有
            tc.cancelAll(ctx, params)
            return err
        }
    }
    
    // Phase 2: Confirm - 提交事务
    for _, p := range tc.participants {
        if err := p.Confirm(ctx, params); err != nil {
            // Confirm失败，继续重试或人工介入
            log.Printf("confirm failed: %v", err)
        }
    }
    
    return nil
}

func (tc *TCCCoordinator) cancelAll(ctx context.Context, params interface{}) {
    for _, p := range tc.participants {
        p.Cancel(ctx, params)
    }
}

// 示例：账户服务实现TCC
type AccountService struct {
    db *sql.DB
}

func (as *AccountService) Try(ctx context.Context, params interface{}) error {
    req := params.(*TransferRequest)
    
    // 冻结金额
    _, err := as.db.ExecContext(ctx,
        "UPDATE accounts SET frozen = frozen + ? WHERE id = ?",
        req.Amount, req.FromAccount)
    
    return err
}

func (as *AccountService) Confirm(ctx context.Context, params interface{}) error {
    req := params.(*TransferRequest)
    
    tx, _ := as.db.BeginTx(ctx, nil)
    defer tx.Rollback()
    
    // 扣减冻结金额
    _, err := tx.ExecContext(ctx,
        "UPDATE accounts SET balance = balance - ?, frozen = frozen - ? WHERE id = ?",
        req.Amount, req.Amount, req.FromAccount)
    if err != nil {
        return err
    }
    
    // 增加目标账户余额
    _, err = tx.ExecContext(ctx,
        "UPDATE accounts SET balance = balance + ? WHERE id = ?",
        req.Amount, req.ToAccount)
    if err != nil {
        return err
    }
    
    return tx.Commit()
}

func (as *AccountService) Cancel(ctx context.Context, params interface{}) error {
    req := params.(*TransferRequest)
    
    // 解冻金额
    _, err := as.db.ExecContext(ctx,
        "UPDATE accounts SET frozen = frozen - ? WHERE id = ?",
        req.Amount, req.FromAccount)
    
    return err
}
```

---

### 3. 2PC (两阶段提交)

```go
package twopc

import (
    "context"
    "sync"
)

// 参与者接口
type Participant interface {
    Prepare(ctx context.Context, txID string) error
    Commit(ctx context.Context, txID string) error
    Rollback(ctx context.Context, txID string) error
}

// 协调器
type Coordinator struct {
    participants []Participant
}

func (c *Coordinator) Execute(ctx context.Context, txID string) error {
    // Phase 1: Prepare
    if err := c.prepare(ctx, txID); err != nil {
        c.rollbackAll(ctx, txID)
        return err
    }
    
    // Phase 2: Commit
    return c.commitAll(ctx, txID)
}

func (c *Coordinator) prepare(ctx context.Context, txID string) error {
    var wg sync.WaitGroup
    errCh := make(chan error, len(c.participants))
    
    for _, p := range c.participants {
        wg.Add(1)
        go func(p Participant) {
            defer wg.Done()
            if err := p.Prepare(ctx, txID); err != nil {
                errCh <- err
            }
        }(p)
    }
    
    wg.Wait()
    close(errCh)
    
    // 任何一个失败都返回错误
    for err := range errCh {
        if err != nil {
            return err
        }
    }
    
    return nil
}

func (c *Coordinator) commitAll(ctx context.Context, txID string) error {
    for _, p := range c.participants {
        if err := p.Commit(ctx, txID); err != nil {
            log.Printf("commit failed: %v", err)
            // 继续重试或记录日志
        }
    }
    return nil
}

func (c *Coordinator) rollbackAll(ctx context.Context, txID string) {
    for _, p := range c.participants {
        p.Rollback(ctx, txID)
    }
}
```

---

## 3. 💡 最佳实践

### 1. 幂等性设计

```go
type OrderService struct {
    processed map[string]bool
    mu        sync.RWMutex
}

func (os *OrderService) CreateOrder(orderID string) error {
    os.mu.Lock()
    defer os.mu.Unlock()
    
    // 检查是否已处理
    if os.processed[orderID] {
        return nil // 幂等：已处理，直接返回成功
    }
    
    // 创建订单
    if err := os.create(orderID); err != nil {
        return err
    }
    
    // 标记为已处理
    os.processed[orderID] = true
    return nil
}
```

### 2. 重试机制

```go
func retryWithBackoff(fn func() error, maxRetries int) error {
    backoff := time.Second
    
    for i := 0; i < maxRetries; i++ {
        if err := fn(); err == nil {
            return nil
        }
        
        time.Sleep(backoff)
        backoff *= 2 // 指数退避
    }
    
    return errors.New("max retries exceeded")
}
```

### 3. 事务日志

```go
type TransactionLog struct {
    TxID      string
    Status    string // PENDING, COMMITTED, ROLLBACK
    Steps     []string
    CreatedAt time.Time
    UpdatedAt time.Time
}

func (tl *TransactionLog) Save(db *sql.DB) error {
    _, err := db.Exec(
        "INSERT INTO tx_log (tx_id, status, steps, created_at) VALUES (?, ?, ?, ?)",
        tl.TxID, tl.Status, strings.Join(tl.Steps, ","), tl.CreatedAt)
    return err
}
```

---

## ⚠️ 常见问题

**Q1: Saga vs TCC选择？**
- **Saga**: 适合长事务，补偿逻辑简单
- **TCC**: 适合短事务，要求强一致性

**Q2: 如何处理补偿失败？**
- 重试机制
- 死信队列
- 人工介入

**Q3: 性能考虑？**
- 2PC: 性能最差，阻塞
- TCC: 性能较好，非阻塞
- Saga: 性能最好，异步

---

## 4. 📚 相关资源

- [Saga Pattern](https://microservices.io/patterns/data/saga.html)
- [TCC Pattern](https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf)

**下一步**: [06-负载均衡](./06-负载均衡.md)

---

**最后更新**: 2025-10-28

