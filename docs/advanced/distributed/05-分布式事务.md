# åˆ†å¸ƒå¼äº‹åŠ¡

**éš¾åº¦**: é«˜çº§ | **é¢„è®¡é˜…è¯»**: 20åˆ†é’Ÿ | **å‰ç½®çŸ¥è¯†**: æ•°æ®åº“äº‹åŠ¡ã€åˆ†å¸ƒå¼ç³»ç»Ÿ

---

## ğŸ“‹ ç›®å½•

- [1. ğŸ“– æ¦‚å¿µä»‹ç»](#1--æ¦‚å¿µä»‹ç»)
- [2. ğŸ¯ æ ¸å¿ƒæ¨¡å¼](#2--æ ¸å¿ƒæ¨¡å¼)
- [3. ğŸ’¡ æœ€ä½³å®è·µ](#3--æœ€ä½³å®è·µ)
- [4. ğŸ“š ç›¸å…³èµ„æº](#4--ç›¸å…³èµ„æº)

---

## 1. ğŸ“– æ¦‚å¿µä»‹ç»

åˆ†å¸ƒå¼äº‹åŠ¡ç¡®ä¿è·¨å¤šä¸ªæœåŠ¡æˆ–æ•°æ®åº“çš„æ“ä½œè¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å¤±è´¥ï¼Œä¿è¯æ•°æ®ä¸€è‡´æ€§ã€‚

---

## 2. ğŸ¯ æ ¸å¿ƒæ¨¡å¼

### 1. Sagaæ¨¡å¼

```go
package saga

import (
    "context"
    "errors"
)

// Sagaæ­¥éª¤
type Step struct {
    Name        string
    Action      func(ctx context.Context) error
    Compensate  func(ctx context.Context) error
}

// Sagaåè°ƒå™¨
type Saga struct {
    steps []Step
}

func NewSaga() *Saga {
    return &Saga{
        steps: make([]Step, 0),
    }
}

func (s *Saga) AddStep(name string, action, compensate func(context.Context) error) *Saga {
    s.steps = append(s.steps, Step{
        Name:       name,
        Action:     action,
        Compensate: compensate,
    })
    return s
}

// æ‰§è¡ŒSaga
func (s *Saga) Execute(ctx context.Context) error {
    executed := make([]Step, 0)
    
    // é¡ºåºæ‰§è¡Œæ‰€æœ‰æ­¥éª¤
    for _, step := range s.steps {
        if err := step.Action(ctx); err != nil {
            // å¤±è´¥ï¼šæ‰§è¡Œè¡¥å¿
            s.compensate(ctx, executed)
            return errors.New(fmt.Sprintf("step %s failed: %v", step.Name, err))
        }
        executed = append(executed, step)
    }
    
    return nil
}

// è¡¥å¿å·²æ‰§è¡Œçš„æ­¥éª¤
func (s *Saga) compensate(ctx context.Context, executed []Step) {
    // é€†åºæ‰§è¡Œè¡¥å¿
    for i := len(executed) - 1; i >= 0; i-- {
        step := executed[i]
        if err := step.Compensate(ctx); err != nil {
            log.Printf("compensation failed for step %s: %v", step.Name, err)
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šè®¢å•æµç¨‹
func CreateOrderSaga(orderID string, amount float64) *Saga {
    saga := NewSaga()
    
    // æ­¥éª¤1ï¼šæ‰£å‡åº“å­˜
    saga.AddStep("reserve_inventory",
        func(ctx context.Context) error {
            return inventoryService.Reserve(orderID, amount)
        },
        func(ctx context.Context) error {
            return inventoryService.Release(orderID, amount)
        })
    
    // æ­¥éª¤2ï¼šæ‰£å‡ä½™é¢
    saga.AddStep("deduct_balance",
        func(ctx context.Context) error {
            return paymentService.Deduct(orderID, amount)
        },
        func(ctx context.Context) error {
            return paymentService.Refund(orderID, amount)
        })
    
    // æ­¥éª¤3ï¼šåˆ›å»ºè®¢å•
    saga.AddStep("create_order",
        func(ctx context.Context) error {
            return orderService.Create(orderID)
        },
        func(ctx context.Context) error {
            return orderService.Cancel(orderID)
        })
    
    return saga
}
```

---

### 2. TCCæ¨¡å¼

```go
package tcc

import "context"

// TCCæ¥å£
type TCC interface {
    Try(ctx context.Context, params interface{}) error
    Confirm(ctx context.Context, params interface{}) error
    Cancel(ctx context.Context, params interface{}) error
}

// TCCåè°ƒå™¨
type TCCCoordinator struct {
    participants []TCC
}

func (tc *TCCCoordinator) Execute(ctx context.Context, params interface{}) error {
    // Phase 1: Try - é¢„ç•™èµ„æº
    for _, p := range tc.participants {
        if err := p.Try(ctx, params); err != nil {
            // Tryå¤±è´¥ï¼Œå–æ¶ˆæ‰€æœ‰
            tc.cancelAll(ctx, params)
            return err
        }
    }
    
    // Phase 2: Confirm - æäº¤äº‹åŠ¡
    for _, p := range tc.participants {
        if err := p.Confirm(ctx, params); err != nil {
            // Confirmå¤±è´¥ï¼Œç»§ç»­é‡è¯•æˆ–äººå·¥ä»‹å…¥
            log.Printf("confirm failed: %v", err)
        }
    }
    
    return nil
}

func (tc *TCCCoordinator) cancelAll(ctx context.Context, params interface{}) {
    for _, p := range tc.participants {
        p.Cancel(ctx, params)
    }
}

// ç¤ºä¾‹ï¼šè´¦æˆ·æœåŠ¡å®ç°TCC
type AccountService struct {
    db *sql.DB
}

func (as *AccountService) Try(ctx context.Context, params interface{}) error {
    req := params.(*TransferRequest)
    
    // å†»ç»“é‡‘é¢
    _, err := as.db.ExecContext(ctx,
        "UPDATE accounts SET frozen = frozen + ? WHERE id = ?",
        req.Amount, req.FromAccount)
    
    return err
}

func (as *AccountService) Confirm(ctx context.Context, params interface{}) error {
    req := params.(*TransferRequest)
    
    tx, _ := as.db.BeginTx(ctx, nil)
    defer tx.Rollback()
    
    // æ‰£å‡å†»ç»“é‡‘é¢
    _, err := tx.ExecContext(ctx,
        "UPDATE accounts SET balance = balance - ?, frozen = frozen - ? WHERE id = ?",
        req.Amount, req.Amount, req.FromAccount)
    if err != nil {
        return err
    }
    
    // å¢åŠ ç›®æ ‡è´¦æˆ·ä½™é¢
    _, err = tx.ExecContext(ctx,
        "UPDATE accounts SET balance = balance + ? WHERE id = ?",
        req.Amount, req.ToAccount)
    if err != nil {
        return err
    }
    
    return tx.Commit()
}

func (as *AccountService) Cancel(ctx context.Context, params interface{}) error {
    req := params.(*TransferRequest)
    
    // è§£å†»é‡‘é¢
    _, err := as.db.ExecContext(ctx,
        "UPDATE accounts SET frozen = frozen - ? WHERE id = ?",
        req.Amount, req.FromAccount)
    
    return err
}
```

---

### 3. 2PC (ä¸¤é˜¶æ®µæäº¤)

```go
package twopc

import (
    "context"
    "sync"
)

// å‚ä¸è€…æ¥å£
type Participant interface {
    Prepare(ctx context.Context, txID string) error
    Commit(ctx context.Context, txID string) error
    Rollback(ctx context.Context, txID string) error
}

// åè°ƒå™¨
type Coordinator struct {
    participants []Participant
}

func (c *Coordinator) Execute(ctx context.Context, txID string) error {
    // Phase 1: Prepare
    if err := c.prepare(ctx, txID); err != nil {
        c.rollbackAll(ctx, txID)
        return err
    }
    
    // Phase 2: Commit
    return c.commitAll(ctx, txID)
}

func (c *Coordinator) prepare(ctx context.Context, txID string) error {
    var wg sync.WaitGroup
    errCh := make(chan error, len(c.participants))
    
    for _, p := range c.participants {
        wg.Add(1)
        go func(p Participant) {
            defer wg.Done()
            if err := p.Prepare(ctx, txID); err != nil {
                errCh <- err
            }
        }(p)
    }
    
    wg.Wait()
    close(errCh)
    
    // ä»»ä½•ä¸€ä¸ªå¤±è´¥éƒ½è¿”å›é”™è¯¯
    for err := range errCh {
        if err != nil {
            return err
        }
    }
    
    return nil
}

func (c *Coordinator) commitAll(ctx context.Context, txID string) error {
    for _, p := range c.participants {
        if err := p.Commit(ctx, txID); err != nil {
            log.Printf("commit failed: %v", err)
            // ç»§ç»­é‡è¯•æˆ–è®°å½•æ—¥å¿—
        }
    }
    return nil
}

func (c *Coordinator) rollbackAll(ctx context.Context, txID string) {
    for _, p := range c.participants {
        p.Rollback(ctx, txID)
    }
}
```

---

## 3. ğŸ’¡ æœ€ä½³å®è·µ

### 1. å¹‚ç­‰æ€§è®¾è®¡

```go
type OrderService struct {
    processed map[string]bool
    mu        sync.RWMutex
}

func (os *OrderService) CreateOrder(orderID string) error {
    os.mu.Lock()
    defer os.mu.Unlock()
    
    // æ£€æŸ¥æ˜¯å¦å·²å¤„ç†
    if os.processed[orderID] {
        return nil // å¹‚ç­‰ï¼šå·²å¤„ç†ï¼Œç›´æ¥è¿”å›æˆåŠŸ
    }
    
    // åˆ›å»ºè®¢å•
    if err := os.create(orderID); err != nil {
        return err
    }
    
    // æ ‡è®°ä¸ºå·²å¤„ç†
    os.processed[orderID] = true
    return nil
}
```

### 2. é‡è¯•æœºåˆ¶

```go
func retryWithBackoff(fn func() error, maxRetries int) error {
    backoff := time.Second
    
    for i := 0; i < maxRetries; i++ {
        if err := fn(); err == nil {
            return nil
        }
        
        time.Sleep(backoff)
        backoff *= 2 // æŒ‡æ•°é€€é¿
    }
    
    return errors.New("max retries exceeded")
}
```

### 3. äº‹åŠ¡æ—¥å¿—

```go
type TransactionLog struct {
    TxID      string
    Status    string // PENDING, COMMITTED, ROLLBACK
    Steps     []string
    CreatedAt time.Time
    UpdatedAt time.Time
}

func (tl *TransactionLog) Save(db *sql.DB) error {
    _, err := db.Exec(
        "INSERT INTO tx_log (tx_id, status, steps, created_at) VALUES (?, ?, ?, ?)",
        tl.TxID, tl.Status, strings.Join(tl.Steps, ","), tl.CreatedAt)
    return err
}
```

---

## âš ï¸ å¸¸è§é—®é¢˜

**Q1: Saga vs TCCé€‰æ‹©ï¼Ÿ**
- **Saga**: é€‚åˆé•¿äº‹åŠ¡ï¼Œè¡¥å¿é€»è¾‘ç®€å•
- **TCC**: é€‚åˆçŸ­äº‹åŠ¡ï¼Œè¦æ±‚å¼ºä¸€è‡´æ€§

**Q2: å¦‚ä½•å¤„ç†è¡¥å¿å¤±è´¥ï¼Ÿ**
- é‡è¯•æœºåˆ¶
- æ­»ä¿¡é˜Ÿåˆ—
- äººå·¥ä»‹å…¥

**Q3: æ€§èƒ½è€ƒè™‘ï¼Ÿ**
- 2PC: æ€§èƒ½æœ€å·®ï¼Œé˜»å¡
- TCC: æ€§èƒ½è¾ƒå¥½ï¼Œéé˜»å¡
- Saga: æ€§èƒ½æœ€å¥½ï¼Œå¼‚æ­¥

---

## 4. ğŸ“š ç›¸å…³èµ„æº

- [Saga Pattern](https://microservices.io/patterns/data/saga.html)
- [TCC Pattern](https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf)

**ä¸‹ä¸€æ­¥**: [06-è´Ÿè½½å‡è¡¡](./06-è´Ÿè½½å‡è¡¡.md)

---

**æœ€åæ›´æ–°**: 2025-10-28

