# åˆ†å¸ƒå¼ç³»ç»Ÿ - æ¦‚å¿µå®šä¹‰ä½“ç³»

**æ›´æ–°æ—¥æœŸ**: 2025-10-28

---

## æ ¸å¿ƒæ¦‚å¿µ

### 1. CAPå®šç†

**å®šä¹‰**: åˆ†å¸ƒå¼ç³»ç»Ÿä¸å¯èƒ½åŒæ—¶æ»¡è¶³ä¸€è‡´æ€§(C)ã€å¯ç”¨æ€§(A)å’Œåˆ†åŒºå®¹é”™æ€§(P)

**ä¸‰è¦ç´ **:
- **C (Consistency)**: æ‰€æœ‰èŠ‚ç‚¹åŒæ—¶çœ‹åˆ°ç›¸åŒæ•°æ®
- **A (Availability)**: æ¯ä¸ªè¯·æ±‚éƒ½èƒ½å¾—åˆ°å“åº”
- **P (Partition Tolerance)**: ç³»ç»Ÿåœ¨ç½‘ç»œåˆ†åŒºæ—¶ä»èƒ½å·¥ä½œ

**æƒè¡¡**:
```
CPç³»ç»Ÿ: etcd, ZooKeeper, HBase
APç³»ç»Ÿ: Cassandra, DynamoDB, Couchbase
CAç³»ç»Ÿ: å•æœºæ•°æ®åº“
```

---

### 2. BASEç†è®º

**å®šä¹‰**: Basically Available, Soft state, Eventually consistent

**æ ¸å¿ƒæ€æƒ³**:
- **BA**: åŸºæœ¬å¯ç”¨ï¼ˆå…è®¸éƒ¨åˆ†å¯ç”¨æ€§æŸå¤±ï¼‰
- **S**: è½¯çŠ¶æ€ï¼ˆå…è®¸ä¸­é—´çŠ¶æ€ï¼‰
- **E**: æœ€ç»ˆä¸€è‡´æ€§ï¼ˆä¸è¦æ±‚å®æ—¶ä¸€è‡´ï¼‰

---

### 3. Raftä¸€è‡´æ€§åè®®

**å®šä¹‰**: æ˜“äºç†è§£çš„åˆ†å¸ƒå¼ä¸€è‡´æ€§ç®—æ³•

**æ ¸å¿ƒæœºåˆ¶**:
```go
// Leaderé€‰ä¸¾
type NodeState int
const (
    Follower NodeState = iota
    Candidate
    Leader
)

// æ—¥å¿—å¤åˆ¶
type LogEntry struct {
    Term    int
    Command interface{}
}

// ä»»æœŸæŠ•ç¥¨
func (n *Node) RequestVote(term int, candidateID string) bool {
    if term > n.currentTerm {
        n.currentTerm = term
        n.votedFor = candidateID
        return true
    }
    return false
}
```

---

### 4. åˆ†å¸ƒå¼é”

**å®šä¹‰**: åœ¨åˆ†å¸ƒå¼ç¯å¢ƒä¸­åè°ƒå¤šä¸ªè¿›ç¨‹å¯¹å…±äº«èµ„æºçš„è®¿é—®

**Rediså®ç°**:
```go
// SET key value NX PX milliseconds
func AcquireLock(key, value string, ttl time.Duration) bool {
    result := redis.SetNX(key, value, ttl)
    return result == "OK"
}

// Luaè„šæœ¬ä¿è¯åŸå­æ€§
func ReleaseLock(key, value string) bool {
    script := `
        if redis.call("get", KEYS[1]) == ARGV[1] then
            return redis.call("del", KEYS[1])
        else
            return 0
        end
    `
    return redis.Eval(script, key, value) == 1
}
```

---

### 5. åˆ†å¸ƒå¼äº‹åŠ¡ - Sagaæ¨¡å¼

**å®šä¹‰**: é€šè¿‡è¡¥å¿æœºåˆ¶å®ç°çš„é•¿äº‹åŠ¡æ¨¡å¼

**å·¥ä½œæµç¨‹**:
```
æ­£å‘æ“ä½œé“¾: T1 â†’ T2 â†’ T3 â†’ ... â†’ Tn
è¡¥å¿æ“ä½œé“¾: C1 â† C2 â† C3 â† ... â† Cn

æ‰§è¡Œ:
æˆåŠŸ: T1 â†’ T2 â†’ T3
å¤±è´¥: T1 â†’ T2 â†’ T3âœ— â†’ C2 â†’ C1
```

**Goå®ç°**:
```go
type SagaStep struct {
    Action     func() error
    Compensate func() error
}

func ExecuteSaga(steps []SagaStep) error {
    executed := []SagaStep{}
    for _, step := range steps {
        if err := step.Action(); err != nil {
            // è¡¥å¿å·²æ‰§è¡Œæ­¥éª¤
            for i := len(executed) - 1; i >= 0; i-- {
                executed[i].Compensate()
            }
            return err
        }
        executed = append(executed, step)
    }
    return nil
}
```

---

### 6. ä¸€è‡´æ€§å“ˆå¸Œ

**å®šä¹‰**: è§£å†³åˆ†å¸ƒå¼ç¼“å­˜èŠ‚ç‚¹åŠ¨æ€å˜åŒ–çš„å“ˆå¸Œç®—æ³•

**ç‰¹ç‚¹**:
- å•è°ƒæ€§: èŠ‚ç‚¹å¢åŠ ä¸å½±å“å…¶ä»–èŠ‚ç‚¹æ˜ å°„
- å¹³è¡¡æ€§: æ•°æ®å‡åŒ€åˆ†å¸ƒ
- åˆ†æ•£æ€§: åŒä¸€æ•°æ®åœ¨ä¸åŒç»ˆç«¯ä¸€è‡´

**å®ç°**:
```go
type ConsistentHash struct {
    ring       map[uint32]string  // å“ˆå¸Œç¯
    sortedKeys []uint32           // æ’åºçš„keys
    replicas   int                // è™šæ‹ŸèŠ‚ç‚¹æ•°
}

func (c *ConsistentHash) Get(key string) string {
    hash := c.hashKey(key)
    idx := sort.Search(len(c.sortedKeys), func(i int) bool {
        return c.sortedKeys[i] >= hash
    })
    if idx == len(c.sortedKeys) {
        idx = 0
    }
    return c.ring[c.sortedKeys[idx]]
}
```

---

## ğŸ”— ç›¸å…³æ–‡æ¡£

- [çŸ¥è¯†å›¾è°±](./00-çŸ¥è¯†å›¾è°±.md)
- [å¯¹æ¯”çŸ©é˜µ](./00-å¯¹æ¯”çŸ©é˜µ.md)

---

**æœ€åæ›´æ–°**: 2025-10-28
