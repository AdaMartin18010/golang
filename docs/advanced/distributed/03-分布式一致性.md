# åˆ†å¸ƒå¼ä¸€è‡´æ€§

**éš¾åº¦**: é«˜çº§ | **é¢„è®¡é˜…è¯»**: 25åˆ†é’Ÿ | **å‰ç½®çŸ¥è¯†**: åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€

---

## ğŸ“‹ ç›®å½•

- [1. ğŸ“– æ¦‚å¿µä»‹ç»](#1--æ¦‚å¿µä»‹ç»)
- [2. ğŸ¯ Raftç®—æ³•](#2--raftç®—æ³•)
  - [2.1 Raftæ ¸å¿ƒæ¦‚å¿µ](#21-raftæ ¸å¿ƒæ¦‚å¿µ)
  - [2.2 Leaderé€‰ä¸¾](#22-leaderé€‰ä¸¾)
  - [2.3 æ—¥å¿—å¤åˆ¶](#23-æ—¥å¿—å¤åˆ¶)
- [3. ğŸ”§ ä¸€è‡´æ€§å“ˆå¸Œ](#3--ä¸€è‡´æ€§å“ˆå¸Œ)
- [4. ğŸ’¡ Paxosç®€ä»‹](#4--paxosç®€ä»‹)
- [5. ğŸ“š ç›¸å…³èµ„æº](#5--ç›¸å…³èµ„æº)

---

## 1. ğŸ“– æ¦‚å¿µä»‹ç»

åˆ†å¸ƒå¼ä¸€è‡´æ€§ç®—æ³•ç¡®ä¿å¤šä¸ªèŠ‚ç‚¹å¯¹æ•°æ®çŠ¶æ€è¾¾æˆå…±è¯†ã€‚Raftå’ŒPaxosæ˜¯æœ€è‘—åçš„å…±è¯†ç®—æ³•ã€‚

---

## 2. ğŸ¯ Raftç®—æ³•

### 2.1 Raftæ ¸å¿ƒæ¦‚å¿µ

```
è§’è‰²:
- Leader:   å¤„ç†æ‰€æœ‰å®¢æˆ·ç«¯è¯·æ±‚
- Follower: è¢«åŠ¨æ¥æ”¶Leaderçš„æ—¥å¿—
- Candidate: é€‰ä¸¾æ—¶çš„å€™é€‰è€…

æœ¯è¯­ï¼ˆTermï¼‰: é€»è¾‘æ—¶é—´ï¼Œç”¨äºæ£€æµ‹è¿‡æœŸçš„Leader
```

### 2.2 Leaderé€‰ä¸¾

```go
package raft

import (
    "context"
    "math/rand"
    "sync"
    "time"
)

type NodeState int

const (
    Follower NodeState = iota
    Candidate
    Leader
)

type RaftNode struct {
    id          string
    state       NodeState
    currentTerm int64
    votedFor    string
    peers       []string
    
    electionTimeout  time.Duration
    heartbeatTimeout time.Duration
    
    mu sync.RWMutex
}

func (rn *RaftNode) StartElection(ctx context.Context) {
    rn.mu.Lock()
    rn.state = Candidate
    rn.currentTerm++
    rn.votedFor = rn.id
    term := rn.currentTerm
    rn.mu.Unlock()
    
    votes := 1 // æŠ•ç»™è‡ªå·±
    needed := len(rn.peers)/2 + 1
    
    // å‘æ‰€æœ‰peerè¯·æ±‚æŠ•ç¥¨
    voteCh := make(chan bool, len(rn.peers))
    for _, peer := range rn.peers {
        go func(peer string) {
            vote := rn.requestVote(peer, term)
            voteCh <- vote
        }(peer)
    }
    
    // æ”¶é›†æŠ•ç¥¨
    for i := 0; i < len(rn.peers); i++ {
        select {
        case vote := <-voteCh:
            if vote {
                votes++
            }
            if votes >= needed {
                rn.becomeLeader()
                return
            }
        case <-ctx.Done():
            return
        }
    }
}

func (rn *RaftNode) becomeLeader() {
    rn.mu.Lock()
    defer rn.mu.Unlock()
    
    rn.state = Leader
    go rn.sendHeartbeats()
}

func (rn *RaftNode) sendHeartbeats() {
    ticker := time.NewTicker(rn.heartbeatTimeout)
    defer ticker.Stop()
    
    for range ticker.C {
        rn.mu.RLock()
        if rn.state != Leader {
            rn.mu.RUnlock()
            return
        }
        term := rn.currentTerm
        rn.mu.RUnlock()
        
        for _, peer := range rn.peers {
            go rn.sendHeartbeat(peer, term)
        }
    }
}
```

---

### 2.3 æ—¥å¿—å¤åˆ¶

```go
type LogEntry struct {
    Term    int64
    Index   int64
    Command interface{}
}

type RaftLog struct {
    entries       []LogEntry
    commitIndex   int64
    lastApplied   int64
    mu            sync.RWMutex
}

func (rl *RaftLog) Append(term int64, command interface{}) int64 {
    rl.mu.Lock()
    defer rl.mu.Unlock()
    
    entry := LogEntry{
        Term:    term,
        Index:   int64(len(rl.entries)),
        Command: command,
    }
    
    rl.entries = append(rl.entries, entry)
    return entry.Index
}

func (rl *RaftLog) Commit(index int64) {
    rl.mu.Lock()
    defer rl.mu.Unlock()
    
    if index > rl.commitIndex {
        rl.commitIndex = index
    }
}

// Leaderå¤åˆ¶æ—¥å¿—åˆ°Follower
func (rn *RaftNode) ReplicateLog(entry LogEntry) error {
    successCount := 1 // è‡ªå·±
    needed := len(rn.peers)/2 + 1
    
    // å‘é€ç»™æ‰€æœ‰Follower
    for _, peer := range rn.peers {
        if rn.appendEntries(peer, []LogEntry{entry}) {
            successCount++
        }
    }
    
    // å¤šæ•°ç¡®è®¤åæäº¤
    if successCount >= needed {
        rn.log.Commit(entry.Index)
        return nil
    }
    
    return errors.New("failed to replicate to majority")
}
```

---

## 3. ğŸ”§ ä¸€è‡´æ€§å“ˆå¸Œ

```go
package consistent

import (
    "hash/crc32"
    "sort"
    "sync"
)

type HashRing struct {
    nodes       map[uint32]string // å“ˆå¸Œå€¼ -> èŠ‚ç‚¹
    sortedKeys  []uint32          // æ’åºçš„å“ˆå¸Œå€¼
    virtualNodes int              // è™šæ‹ŸèŠ‚ç‚¹æ•°
    mu          sync.RWMutex
}

func NewHashRing(virtualNodes int) *HashRing {
    return &HashRing{
        nodes:        make(map[uint32]string),
        virtualNodes: virtualNodes,
    }
}

func (hr *HashRing) AddNode(node string) {
    hr.mu.Lock()
    defer hr.mu.Unlock()
    
    // ä¸ºæ¯ä¸ªç‰©ç†èŠ‚ç‚¹åˆ›å»ºå¤šä¸ªè™šæ‹ŸèŠ‚ç‚¹
    for i := 0; i < hr.virtualNodes; i++ {
        virtualKey := fmt.Sprintf("%s#%d", node, i)
        hash := hr.hash(virtualKey)
        hr.nodes[hash] = node
        hr.sortedKeys = append(hr.sortedKeys, hash)
    }
    
    sort.Slice(hr.sortedKeys, func(i, j int) bool {
        return hr.sortedKeys[i] < hr.sortedKeys[j]
    })
}

func (hr *HashRing) RemoveNode(node string) {
    hr.mu.Lock()
    defer hr.mu.Unlock()
    
    for i := 0; i < hr.virtualNodes; i++ {
        virtualKey := fmt.Sprintf("%s#%d", node, i)
        hash := hr.hash(virtualKey)
        delete(hr.nodes, hash)
    }
    
    // é‡æ–°æ„å»ºsortedKeys
    hr.sortedKeys = hr.sortedKeys[:0]
    for hash := range hr.nodes {
        hr.sortedKeys = append(hr.sortedKeys, hash)
    }
    sort.Slice(hr.sortedKeys, func(i, j int) bool {
        return hr.sortedKeys[i] < hr.sortedKeys[j]
    })
}

func (hr *HashRing) GetNode(key string) string {
    hr.mu.RLock()
    defer hr.mu.RUnlock()
    
    if len(hr.sortedKeys) == 0 {
        return ""
    }
    
    hash := hr.hash(key)
    
    // æ‰¾åˆ°ç¬¬ä¸€ä¸ª >= hash çš„èŠ‚ç‚¹
    idx := sort.Search(len(hr.sortedKeys), func(i int) bool {
        return hr.sortedKeys[i] >= hash
    })
    
    // å¦‚æœè¶…å‡ºèŒƒå›´ï¼Œå›åˆ°ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆç¯å½¢ï¼‰
    if idx == len(hr.sortedKeys) {
        idx = 0
    }
    
    return hr.nodes[hr.sortedKeys[idx]]
}

func (hr *HashRing) hash(key string) uint32 {
    return crc32.ChecksumIEEE([]byte(key))
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    ring := NewHashRing(150) // 150ä¸ªè™šæ‹ŸèŠ‚ç‚¹
    
    // æ·»åŠ èŠ‚ç‚¹
    ring.AddNode("node1")
    ring.AddNode("node2")
    ring.AddNode("node3")
    
    // è·å–keyå¯¹åº”çš„èŠ‚ç‚¹
    node := ring.GetNode("user:1001")
    fmt.Printf("Key maps to: %s\n", node)
    
    // ç§»é™¤èŠ‚ç‚¹
    ring.RemoveNode("node2")
}
```

---

## 4. ğŸ’¡ Paxosç®€ä»‹

```go
// Paxosä¸‰ä¸ªé˜¶æ®µ
type Paxos struct {
    // Prepareé˜¶æ®µ
    proposalNumber int64
    acceptedNumber int64
    acceptedValue  interface{}
    
    // Accepté˜¶æ®µ
    promises map[string]int64
    
    mu sync.Mutex
}

// Proposer: Prepareè¯·æ±‚
func (p *Paxos) Prepare(n int64) (int64, interface{}, error) {
    p.mu.Lock()
    defer p.mu.Unlock()
    
    if n <= p.proposalNumber {
        return 0, nil, errors.New("proposal number too low")
    }
    
    p.proposalNumber = n
    return p.acceptedNumber, p.acceptedValue, nil
}

// Acceptor: Acceptè¯·æ±‚
func (p *Paxos) Accept(n int64, value interface{}) error {
    p.mu.Lock()
    defer p.mu.Unlock()
    
    if n < p.proposalNumber {
        return errors.New("proposal number too low")
    }
    
    p.acceptedNumber = n
    p.acceptedValue = value
    return nil
}
```

---

## 5. ğŸ“š ç›¸å…³èµ„æº

- [Raft Paper](https://raft.github.io/)
- [Paxos Made Simple](https://lamport.azurewebsites.net/pubs/paxos-simple.pdf)
- [etcd Raft](https://github.com/etcd-io/raft)

**ä¸‹ä¸€æ­¥**: [04-åˆ†å¸ƒå¼é”](./04-åˆ†å¸ƒå¼é”.md)

---

**æœ€åæ›´æ–°**: 2025-10-28

