# 分布式一致性

**难度**: 高级 | **预计阅读**: 25分钟 | **前置知识**: 分布式系统基础

---

## 📋 目录

- [1. 📖 概念介绍](#1--概念介绍)
- [2. 🎯 Raft算法](#2--raft算法)
  - [2.1 Raft核心概念](#21-raft核心概念)
  - [2.2 Leader选举](#22-leader选举)
  - [2.3 日志复制](#23-日志复制)
- [3. 🔧 一致性哈希](#3--一致性哈希)
- [4. 💡 Paxos简介](#4--paxos简介)
- [5. 📚 相关资源](#5--相关资源)

---

## 1. 📖 概念介绍

分布式一致性算法确保多个节点对数据状态达成共识。Raft和Paxos是最著名的共识算法。

---

## 2. 🎯 Raft算法

### 2.1 Raft核心概念

```
角色:
- Leader:   处理所有客户端请求
- Follower: 被动接收Leader的日志
- Candidate: 选举时的候选者

术语（Term）: 逻辑时间，用于检测过期的Leader
```

### 2.2 Leader选举

```go
package raft

import (
    "context"
    "math/rand"
    "sync"
    "time"
)

type NodeState int

const (
    Follower NodeState = iota
    Candidate
    Leader
)

type RaftNode struct {
    id          string
    state       NodeState
    currentTerm int64
    votedFor    string
    peers       []string
    
    electionTimeout  time.Duration
    heartbeatTimeout time.Duration
    
    mu sync.RWMutex
}

func (rn *RaftNode) StartElection(ctx context.Context) {
    rn.mu.Lock()
    rn.state = Candidate
    rn.currentTerm++
    rn.votedFor = rn.id
    term := rn.currentTerm
    rn.mu.Unlock()
    
    votes := 1 // 投给自己
    needed := len(rn.peers)/2 + 1
    
    // 向所有peer请求投票
    voteCh := make(chan bool, len(rn.peers))
    for _, peer := range rn.peers {
        go func(peer string) {
            vote := rn.requestVote(peer, term)
            voteCh <- vote
        }(peer)
    }
    
    // 收集投票
    for i := 0; i < len(rn.peers); i++ {
        select {
        case vote := <-voteCh:
            if vote {
                votes++
            }
            if votes >= needed {
                rn.becomeLeader()
                return
            }
        case <-ctx.Done():
            return
        }
    }
}

func (rn *RaftNode) becomeLeader() {
    rn.mu.Lock()
    defer rn.mu.Unlock()
    
    rn.state = Leader
    go rn.sendHeartbeats()
}

func (rn *RaftNode) sendHeartbeats() {
    ticker := time.NewTicker(rn.heartbeatTimeout)
    defer ticker.Stop()
    
    for range ticker.C {
        rn.mu.RLock()
        if rn.state != Leader {
            rn.mu.RUnlock()
            return
        }
        term := rn.currentTerm
        rn.mu.RUnlock()
        
        for _, peer := range rn.peers {
            go rn.sendHeartbeat(peer, term)
        }
    }
}
```

---

### 2.3 日志复制

```go
type LogEntry struct {
    Term    int64
    Index   int64
    Command interface{}
}

type RaftLog struct {
    entries       []LogEntry
    commitIndex   int64
    lastApplied   int64
    mu            sync.RWMutex
}

func (rl *RaftLog) Append(term int64, command interface{}) int64 {
    rl.mu.Lock()
    defer rl.mu.Unlock()
    
    entry := LogEntry{
        Term:    term,
        Index:   int64(len(rl.entries)),
        Command: command,
    }
    
    rl.entries = append(rl.entries, entry)
    return entry.Index
}

func (rl *RaftLog) Commit(index int64) {
    rl.mu.Lock()
    defer rl.mu.Unlock()
    
    if index > rl.commitIndex {
        rl.commitIndex = index
    }
}

// Leader复制日志到Follower
func (rn *RaftNode) ReplicateLog(entry LogEntry) error {
    successCount := 1 // 自己
    needed := len(rn.peers)/2 + 1
    
    // 发送给所有Follower
    for _, peer := range rn.peers {
        if rn.appendEntries(peer, []LogEntry{entry}) {
            successCount++
        }
    }
    
    // 多数确认后提交
    if successCount >= needed {
        rn.log.Commit(entry.Index)
        return nil
    }
    
    return errors.New("failed to replicate to majority")
}
```

---

## 3. 🔧 一致性哈希

```go
package consistent

import (
    "hash/crc32"
    "sort"
    "sync"
)

type HashRing struct {
    nodes       map[uint32]string // 哈希值 -> 节点
    sortedKeys  []uint32          // 排序的哈希值
    virtualNodes int              // 虚拟节点数
    mu          sync.RWMutex
}

func NewHashRing(virtualNodes int) *HashRing {
    return &HashRing{
        nodes:        make(map[uint32]string),
        virtualNodes: virtualNodes,
    }
}

func (hr *HashRing) AddNode(node string) {
    hr.mu.Lock()
    defer hr.mu.Unlock()
    
    // 为每个物理节点创建多个虚拟节点
    for i := 0; i < hr.virtualNodes; i++ {
        virtualKey := fmt.Sprintf("%s#%d", node, i)
        hash := hr.hash(virtualKey)
        hr.nodes[hash] = node
        hr.sortedKeys = append(hr.sortedKeys, hash)
    }
    
    sort.Slice(hr.sortedKeys, func(i, j int) bool {
        return hr.sortedKeys[i] < hr.sortedKeys[j]
    })
}

func (hr *HashRing) RemoveNode(node string) {
    hr.mu.Lock()
    defer hr.mu.Unlock()
    
    for i := 0; i < hr.virtualNodes; i++ {
        virtualKey := fmt.Sprintf("%s#%d", node, i)
        hash := hr.hash(virtualKey)
        delete(hr.nodes, hash)
    }
    
    // 重新构建sortedKeys
    hr.sortedKeys = hr.sortedKeys[:0]
    for hash := range hr.nodes {
        hr.sortedKeys = append(hr.sortedKeys, hash)
    }
    sort.Slice(hr.sortedKeys, func(i, j int) bool {
        return hr.sortedKeys[i] < hr.sortedKeys[j]
    })
}

func (hr *HashRing) GetNode(key string) string {
    hr.mu.RLock()
    defer hr.mu.RUnlock()
    
    if len(hr.sortedKeys) == 0 {
        return ""
    }
    
    hash := hr.hash(key)
    
    // 找到第一个 >= hash 的节点
    idx := sort.Search(len(hr.sortedKeys), func(i int) bool {
        return hr.sortedKeys[i] >= hash
    })
    
    // 如果超出范围，回到第一个节点（环形）
    if idx == len(hr.sortedKeys) {
        idx = 0
    }
    
    return hr.nodes[hr.sortedKeys[idx]]
}

func (hr *HashRing) hash(key string) uint32 {
    return crc32.ChecksumIEEE([]byte(key))
}

// 使用示例
func main() {
    ring := NewHashRing(150) // 150个虚拟节点
    
    // 添加节点
    ring.AddNode("node1")
    ring.AddNode("node2")
    ring.AddNode("node3")
    
    // 获取key对应的节点
    node := ring.GetNode("user:1001")
    fmt.Printf("Key maps to: %s\n", node)
    
    // 移除节点
    ring.RemoveNode("node2")
}
```

---

## 4. 💡 Paxos简介

```go
// Paxos三个阶段
type Paxos struct {
    // Prepare阶段
    proposalNumber int64
    acceptedNumber int64
    acceptedValue  interface{}
    
    // Accept阶段
    promises map[string]int64
    
    mu sync.Mutex
}

// Proposer: Prepare请求
func (p *Paxos) Prepare(n int64) (int64, interface{}, error) {
    p.mu.Lock()
    defer p.mu.Unlock()
    
    if n <= p.proposalNumber {
        return 0, nil, errors.New("proposal number too low")
    }
    
    p.proposalNumber = n
    return p.acceptedNumber, p.acceptedValue, nil
}

// Acceptor: Accept请求
func (p *Paxos) Accept(n int64, value interface{}) error {
    p.mu.Lock()
    defer p.mu.Unlock()
    
    if n < p.proposalNumber {
        return errors.New("proposal number too low")
    }
    
    p.acceptedNumber = n
    p.acceptedValue = value
    return nil
}
```

---

## 5. 📚 相关资源

- [Raft Paper](https://raft.github.io/)
- [Paxos Made Simple](https://lamport.azurewebsites.net/pubs/paxos-simple.pdf)
- [etcd Raft](https://github.com/etcd-io/raft)

**下一步**: [04-分布式锁](./04-分布式锁.md)

---

**最后更新**: 2025-10-28

