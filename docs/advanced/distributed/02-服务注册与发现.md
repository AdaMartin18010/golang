# 服务注册与发现

**版本**: v1.0
**更新日期**: 2025-10-29
**适用于**: Go 1.25.3

---

## 📋 目录

- [服务注册与发现](#服务注册与发现)
  - [📋 目录](#-目录)
  - [1. 📖 概念介绍](#1--概念介绍)
  - [2. 🎯 核心组件](#2--核心组件)
    - [1. Consul集成](#1-consul集成)
    - [2. etcd集成](#2-etcd集成)
    - [3. 健康检查](#3-健康检查)
    - [4. 客户端负载均衡](#4-客户端负载均衡)
  - [3. 🏗️ 完整示例](#3-️-完整示例)
  - [4. 💡 最佳实践](#4--最佳实践)
  - [5. 📚 相关资源](#5--相关资源)

---

## 1. 📖 概念介绍

服务注册与发现是微服务架构的核心组件，允许服务动态发现和通信，无需硬编码地址。

---

## 2. 🎯 核心组件

### 1. Consul集成

```go
package main

import (
    "fmt"
    "github.com/hashicorp/consul/api"
)

type ServiceRegistry struct {
    client *api.Client
}

func NewServiceRegistry(addr string) (*ServiceRegistry, error) {
    config := api.DefaultConfig()
    config.Address = addr

    client, err := api.NewClient(config)
    if err != nil {
        return nil, err
    }

    return &ServiceRegistry{client: client}, nil
}

// 注册服务
func (sr *ServiceRegistry) Register(name, id, address string, port int) error {
    registration := &api.AgentServiceRegistration{
        ID:      id,
        Name:    name,
        Address: address,
        Port:    port,
        Check: &api.AgentServiceCheck{
            HTTP:     fmt.Sprintf("http://%s:%d/health", address, port),
            Interval: "10s",
            Timeout:  "3s",
        },
    }

    return sr.client.Agent().ServiceRegister(registration)
}

// 注销服务
func (sr *ServiceRegistry) Deregister(id string) error {
    return sr.client.Agent().ServiceDeregister(id)
}

// 发现服务
func (sr *ServiceRegistry) Discover(name string) ([]*api.ServiceEntry, error) {
    services, _, err := sr.client.Health().Service(name, "", true, nil)
    return services, err
}

// 使用示例
func main() {
    registry, _ := NewServiceRegistry("localhost:8500")

    // 注册服务
    registry.Register("my-service", "my-service-1", "localhost", 8080)

    // 发现服务
    services, _ := registry.Discover("my-service")
    for _, service := range services {
        fmt.Printf("Service: %s at %s:%d\n",
            service.Service.Service,
            service.Service.Address,
            service.Service.Port)
    }
}
```

---

### 2. etcd集成

```go
package main

import (
    "context"
    "fmt"
    "time"

    clientv3 "go.etcd.io/etcd/client/v3"
)

type EtcdRegistry struct {
    client *clientv3.Client
    lease  clientv3.Lease
}

func NewEtcdRegistry(endpoints []string) (*EtcdRegistry, error) {
    client, err := clientv3.New(clientv3.Config{
        Endpoints:   endpoints,
        DialTimeout: 5 * time.Second,
    })
    if err != nil {
        return nil, err
    }

    return &EtcdRegistry{
        client: client,
        lease:  clientv3.NewLease(client),
    }, nil
}

// 注册服务（带TTL）
func (er *EtcdRegistry) Register(ctx context.Context, key, value string, ttl int64) error {
    // 创建租约
    grant, err := er.lease.Grant(ctx, ttl)
    if err != nil {
        return err
    }

    // 注册服务
    _, err = er.client.Put(ctx, key, value, clientv3.WithLease(grant.ID))
    if err != nil {
        return err
    }

    // 保持租约
    keepAlive, err := er.lease.KeepAlive(ctx, grant.ID)
    if err != nil {
        return err
    }

    go func() {
        for range keepAlive {
            // 处理keepalive响应
        }
    }()

    return nil
}

// 发现服务
func (er *EtcdRegistry) Discover(ctx context.Context, prefix string) ([]string, error) {
    resp, err := er.client.Get(ctx, prefix, clientv3.WithPrefix())
    if err != nil {
        return nil, err
    }

    var services []string
    for _, kv := range resp.Kvs {
        services = append(services, string(kv.Value))
    }

    return services, nil
}

// 监听服务变化
func (er *EtcdRegistry) Watch(ctx context.Context, prefix string) clientv3.WatchChan {
    return er.client.Watch(ctx, prefix, clientv3.WithPrefix())
}
```

---

### 3. 健康检查

```go
type HealthChecker struct {
    services map[string]*ServiceInfo
    interval time.Duration
    mu       sync.RWMutex
}

type ServiceInfo struct {
    Address string
    Healthy bool
    LastCheck time.Time
}

func (hc *HealthChecker) StartHealthCheck(ctx context.Context) {
    ticker := time.NewTicker(hc.interval)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            hc.checkAll()
        case <-ctx.Done():
            return
        }
    }
}

func (hc *HealthChecker) checkAll() {
    hc.mu.Lock()
    defer hc.mu.Unlock()

    for name, info := range hc.services {
        healthy := hc.checkHealth(info.Address)
        info.Healthy = healthy
        info.LastCheck = time.Now()
        hc.services[name] = info
    }
}

func (hc *HealthChecker) checkHealth(address string) bool {
    client := &http.Client{Timeout: 3 * time.Second}
    resp, err := client.Get(fmt.Sprintf("http://%s/health", address))
    if err != nil {
        return false
    }
    defer resp.Body.Close()

    return resp.StatusCode == http.StatusOK
}

func (hc *HealthChecker) GetHealthyServices() []string {
    hc.mu.RLock()
    defer hc.mu.RUnlock()

    var healthy []string
    for name, info := range hc.services {
        if info.Healthy {
            healthy = append(healthy, name)
        }
    }
    return healthy
}
```

---

### 4. 客户端负载均衡

```go
type LoadBalancer struct {
    services []string
    current  uint32
}

// 轮询
func (lb *LoadBalancer) RoundRobin() string {
    n := atomic.AddUint32(&lb.current, 1)
    return lb.services[int(n-1)%len(lb.services)]
}

// 随机
func (lb *LoadBalancer) Random() string {
    return lb.services[rand.Intn(len(lb.services))]
}

// 带权重
type WeightedService struct {
    Address string
    Weight  int
}

func (lb *LoadBalancer) WeightedRandom(services []WeightedService) string {
    totalWeight := 0
    for _, s := range services {
        totalWeight += s.Weight
    }

    r := rand.Intn(totalWeight)
    for _, s := range services {
        r -= s.Weight
        if r < 0 {
            return s.Address
        }
    }

    return services[0].Address
}
```

---

## 3. 🏗️ 完整示例

```go
// 服务端
func main() {
    registry, _ := NewServiceRegistry("localhost:8500")

    // 注册服务
    serviceID := "my-service-1"
    registry.Register("my-service", serviceID, "localhost", 8080)

    // 优雅关闭时注销
    defer registry.Deregister(serviceID)

    // 启动HTTP服务
    http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
    })

    http.ListenAndServe(":8080", nil)
}

// 客户端
func main() {
    registry, _ := NewServiceRegistry("localhost:8500")

    // 发现服务
    services, _ := registry.Discover("my-service")

    // 负载均衡
    lb := &LoadBalancer{
        services: extractAddresses(services),
    }

    // 调用服务
    address := lb.RoundRobin()
    resp, _ := http.Get(fmt.Sprintf("http://%s/api", address))
    defer resp.Body.Close()
}
```

---

## 4. 💡 最佳实践

1. **健康检查**: 定期检查服务健康状态
2. **优雅退出**: 服务关闭前注销
3. **重试机制**: 调用失败时重试其他实例
4. **缓存**: 缓存服务列表，减少注册中心压力
5. **监控**: 监控注册/注销事件

---

## 5. 📚 相关资源

- [Consul Documentation](https://www.consul.io/docs)
- [etcd Documentation](https://etcd.io/docs/)

**下一步**: [03-分布式一致性](./03-分布式一致性.md)

---

**最后更新**: 2025-10-29
