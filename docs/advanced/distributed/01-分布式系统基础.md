# 分布式系统基础

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---

## 📋 目录


- [1. 📖 概念介绍](#1.-概念介绍)
- [2. 🎯 核心理论](#2.-核心理论)
  - [2.1 CAP定理](#2.1-cap定理)
  - [2.2 BASE理论](#2.2-base理论)
  - [2.3 一致性模型](#2.3-一致性模型)
    - [强一致性](#强一致性)
    - [最终一致性](#最终一致性)
    - [因果一致性](#因果一致性)
- [3. 🔧 分布式系统挑战](#3.-分布式系统挑战)
  - [3.1 网络分区](#3.1-网络分区)
  - [3.2 时钟同步](#3.2-时钟同步)
  - [3.3 故障检测](#3.3-故障检测)
- [4. 💡 Go在分布式系统中的优势](#4.-go在分布式系统中的优势)
  - [4.1 轻量级并发](#4.1-轻量级并发)
  - [4.2 内置网络库](#4.2-内置网络库)
  - [4.3 高效序列化](#4.3-高效序列化)
  - [4.4 强大的标准库](#4.4-强大的标准库)
- [5. 📚 相关资源](#5.-相关资源)

## 1. 📖 概念介绍

分布式系统是由多个独立计算机组成的系统，对用户来说像单一系统。理解分布式系统的核心理论是构建可靠系统的基础。

---

## 2. 🎯 核心理论

### 2.1 CAP定理

```
Consistency (一致性)
Availability (可用性)  
Partition Tolerance (分区容错)

定理：最多同时满足两个
```

**三种选择**:
- **CP**: 一致性+分区容错（如ZooKeeper）
- **AP**: 可用性+分区容错（如Cassandra）
- **CA**: 一致性+可用性（单机系统）

```go
// CP系统示例：强一致性
type CPSystem struct {
    leader  string
    replicas []string
}

func (s *CPSystem) Write(key, value string) error {
    // 必须同步到多数副本才返回成功
    successCount := 0
    for _, replica := range s.replicas {
        if err := syncWrite(replica, key, value); err == nil {
            successCount++
        }
    }
    
    if successCount < len(s.replicas)/2+1 {
        return errors.New("write failed: not enough replicas")
    }
    return nil
}

// AP系统示例：最终一致性
type APSystem struct {
    nodes []string
}

func (s *APSystem) Write(key, value string) error {
    // 异步写入所有节点
    for _, node := range s.nodes {
        go asyncWrite(node, key, value)
    }
    return nil // 立即返回
}
```

---

### 2.2 BASE理论

```
Basically Available    (基本可用)
Soft state            (软状态)
Eventually consistent (最终一致性)
```

**实现示例**:
```go
type EventuallyConsistentStore struct {
    local  map[string]string
    remote []string
    sync   chan SyncEvent
}

func (s *EventuallyConsistentStore) Set(key, value string) {
    // 立即写入本地
    s.local[key] = value
    
    // 异步同步到远程节点
    go func() {
        for _, node := range s.remote {
            s.sync <- SyncEvent{
                Node:  node,
                Key:   key,
                Value: value,
            }
        }
    }()
}
```

---

### 2.3 一致性模型

#### 强一致性
```go
// 读取最新写入的值
func (s *StrongConsistent) Read(key string) (string, error) {
    // 从leader读取
    return s.leader.Get(key)
}
```

#### 最终一致性
```go
// 读取可能是旧值，但最终会一致
func (s *EventualConsistent) Read(key string) (string, error) {
    // 从任意副本读取
    return s.anyReplica().Get(key)
}
```

#### 因果一致性
```go
// 保证因果关系的读取
type CausalConsistent struct {
    versions map[string]VectorClock
}

func (s *CausalConsistent) Read(key string, clock VectorClock) (string, error) {
    // 只返回满足因果关系的版本
    if s.versions[key].HappenedBefore(clock) {
        return s.get(key), nil
    }
    return "", errors.New("causality violation")
}
```

---

## 3. 🔧 分布式系统挑战

### 3.1 网络分区

```go
// 检测网络分区
type PartitionDetector struct {
    peers     []string
    threshold time.Duration
}

func (d *PartitionDetector) IsPartitioned() bool {
    reachable := 0
    for _, peer := range d.peers {
        if d.canReach(peer, d.threshold) {
            reachable++
        }
    }
    return reachable < len(d.peers)/2+1
}
```

---

### 3.2 时钟同步

```go
// Lamport时钟
type LamportClock struct {
    counter int64
}

func (c *LamportClock) Tick() int64 {
    return atomic.AddInt64(&c.counter, 1)
}

func (c *LamportClock) Update(received int64) {
    for {
        current := atomic.LoadInt64(&c.counter)
        new := max(current, received) + 1
        if atomic.CompareAndSwapInt64(&c.counter, current, new) {
            break
        }
    }
}

// 向量时钟
type VectorClock map[string]int64

func (vc VectorClock) Increment(node string) {
    vc[node]++
}

func (vc VectorClock) HappenedBefore(other VectorClock) bool {
    // 实现向量时钟比较逻辑
    for node, timestamp := range vc {
        if timestamp > other[node] {
            return false
        }
    }
    return true
}
```

---

### 3.3 故障检测

```go
// 心跳检测
type FailureDetector struct {
    heartbeats map[string]time.Time
    timeout    time.Duration
    mu         sync.RWMutex
}

func (fd *FailureDetector) Heartbeat(node string) {
    fd.mu.Lock()
    fd.heartbeats[node] = time.Now()
    fd.mu.Unlock()
}

func (fd *FailureDetector) IsFailed(node string) bool {
    fd.mu.RLock()
    lastSeen := fd.heartbeats[node]
    fd.mu.RUnlock()
    
    return time.Since(lastSeen) > fd.timeout
}

func (fd *FailureDetector) GetHealthyNodes() []string {
    fd.mu.RLock()
    defer fd.mu.RUnlock()
    
    var healthy []string
    for node, lastSeen := range fd.heartbeats {
        if time.Since(lastSeen) <= fd.timeout {
            healthy = append(healthy, node)
        }
    }
    return healthy
}
```

---

## 4. 💡 Go在分布式系统中的优势

### 4.1 轻量级并发
```go
// 处理数千个连接
for {
    conn, _ := listener.Accept()
    go handleConnection(conn) // 轻量级goroutine
}
```

### 4.2 内置网络库
```go
// 简洁的网络编程
listener, _ := net.Listen("tcp", ":8080")
conn, _ := net.Dial("tcp", "node2:8080")
```

### 4.3 高效序列化
```go
// gob/protobuf/json
data, _ := json.Marshal(message)
```

### 4.4 强大的标准库
- net/rpc: RPC框架
- net/http: HTTP服务
- sync: 并发原语
- context: 超时控制

---

## 5. 📚 相关资源

- [CAP Theorem](https://en.wikipedia.org/wiki/CAP_theorem)
- [Designing Data-Intensive Applications](https://dataintensive.net/)

**下一步**: [02-服务注册与发现](./02-服务注册与发现.md)

---

**最后更新**: 2025-10-29

