# åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.25.3

---

## ğŸ“‹ ç›®å½•

- [åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€](#åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. ğŸ“– æ¦‚å¿µä»‹ç»](#1--æ¦‚å¿µä»‹ç»)
  - [2. ğŸ¯ æ ¸å¿ƒç†è®º](#2--æ ¸å¿ƒç†è®º)
    - [2.1 CAPå®šç†](#21-capå®šç†)
    - [2.2 BASEç†è®º](#22-baseç†è®º)
    - [2.3 ä¸€è‡´æ€§æ¨¡å‹](#23-ä¸€è‡´æ€§æ¨¡å‹)
      - [å¼ºä¸€è‡´æ€§](#å¼ºä¸€è‡´æ€§)
      - [æœ€ç»ˆä¸€è‡´æ€§](#æœ€ç»ˆä¸€è‡´æ€§)
      - [å› æœä¸€è‡´æ€§](#å› æœä¸€è‡´æ€§)
  - [3. ğŸ”§ åˆ†å¸ƒå¼ç³»ç»ŸæŒ‘æˆ˜](#3--åˆ†å¸ƒå¼ç³»ç»ŸæŒ‘æˆ˜)
    - [3.1 ç½‘ç»œåˆ†åŒº](#31-ç½‘ç»œåˆ†åŒº)
    - [3.2 æ—¶é’ŸåŒæ­¥](#32-æ—¶é’ŸåŒæ­¥)
    - [3.3 æ•…éšœæ£€æµ‹](#33-æ•…éšœæ£€æµ‹)
  - [4. ğŸ’¡ Goåœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„ä¼˜åŠ¿](#4--goåœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„ä¼˜åŠ¿)
    - [4.1 è½»é‡çº§å¹¶å‘](#41-è½»é‡çº§å¹¶å‘)
    - [4.2 å†…ç½®ç½‘ç»œåº“](#42-å†…ç½®ç½‘ç»œåº“)
    - [4.3 é«˜æ•ˆåºåˆ—åŒ–](#43-é«˜æ•ˆåºåˆ—åŒ–)
    - [4.4 å¼ºå¤§çš„æ ‡å‡†åº“](#44-å¼ºå¤§çš„æ ‡å‡†åº“)
  - [5. ğŸ“š ç›¸å…³èµ„æº](#5--ç›¸å…³èµ„æº)

## 1. ğŸ“– æ¦‚å¿µä»‹ç»

åˆ†å¸ƒå¼ç³»ç»Ÿæ˜¯ç”±å¤šä¸ªç‹¬ç«‹è®¡ç®—æœºç»„æˆçš„ç³»ç»Ÿï¼Œå¯¹ç”¨æˆ·æ¥è¯´åƒå•ä¸€ç³»ç»Ÿã€‚ç†è§£åˆ†å¸ƒå¼ç³»ç»Ÿçš„æ ¸å¿ƒç†è®ºæ˜¯æ„å»ºå¯é ç³»ç»Ÿçš„åŸºç¡€ã€‚

---

## 2. ğŸ¯ æ ¸å¿ƒç†è®º

### 2.1 CAPå®šç†

```
Consistency (ä¸€è‡´æ€§)
Availability (å¯ç”¨æ€§)
Partition Tolerance (åˆ†åŒºå®¹é”™)

å®šç†ï¼šæœ€å¤šåŒæ—¶æ»¡è¶³ä¸¤ä¸ª
```

**ä¸‰ç§é€‰æ‹©**:

- **CP**: ä¸€è‡´æ€§+åˆ†åŒºå®¹é”™ï¼ˆå¦‚ZooKeeperï¼‰
- **AP**: å¯ç”¨æ€§+åˆ†åŒºå®¹é”™ï¼ˆå¦‚Cassandraï¼‰
- **CA**: ä¸€è‡´æ€§+å¯ç”¨æ€§ï¼ˆå•æœºç³»ç»Ÿï¼‰

```go
// CPç³»ç»Ÿç¤ºä¾‹ï¼šå¼ºä¸€è‡´æ€§
type CPSystem struct {
    leader  string
    replicas []string
}

func (s *CPSystem) Write(key, value string) error {
    // å¿…é¡»åŒæ­¥åˆ°å¤šæ•°å‰¯æœ¬æ‰è¿”å›æˆåŠŸ
    successCount := 0
    for _, replica := range s.replicas {
        if err := syncWrite(replica, key, value); err == nil {
            successCount++
        }
    }

    if successCount < len(s.replicas)/2+1 {
        return errors.New("write failed: not enough replicas")
    }
    return nil
}

// APç³»ç»Ÿç¤ºä¾‹ï¼šæœ€ç»ˆä¸€è‡´æ€§
type APSystem struct {
    nodes []string
}

func (s *APSystem) Write(key, value string) error {
    // å¼‚æ­¥å†™å…¥æ‰€æœ‰èŠ‚ç‚¹
    for _, node := range s.nodes {
        go asyncWrite(node, key, value)
    }
    return nil // ç«‹å³è¿”å›
}
```

---

### 2.2 BASEç†è®º

```
Basically Available    (åŸºæœ¬å¯ç”¨)
Soft state            (è½¯çŠ¶æ€)
Eventually consistent (æœ€ç»ˆä¸€è‡´æ€§)
```

**å®ç°ç¤ºä¾‹**:

```go
type EventuallyConsistentStore struct {
    local  map[string]string
    remote []string
    sync   chan SyncEvent
}

func (s *EventuallyConsistentStore) Set(key, value string) {
    // ç«‹å³å†™å…¥æœ¬åœ°
    s.local[key] = value

    // å¼‚æ­¥åŒæ­¥åˆ°è¿œç¨‹èŠ‚ç‚¹
    go func() {
        for _, node := range s.remote {
            s.sync <- SyncEvent{
                Node:  node,
                Key:   key,
                Value: value,
            }
        }
    }()
}
```

---

### 2.3 ä¸€è‡´æ€§æ¨¡å‹

#### å¼ºä¸€è‡´æ€§

```go
// è¯»å–æœ€æ–°å†™å…¥çš„å€¼
func (s *StrongConsistent) Read(key string) (string, error) {
    // ä»leaderè¯»å–
    return s.leader.Get(key)
}
```

#### æœ€ç»ˆä¸€è‡´æ€§

```go
// è¯»å–å¯èƒ½æ˜¯æ—§å€¼ï¼Œä½†æœ€ç»ˆä¼šä¸€è‡´
func (s *EventualConsistent) Read(key string) (string, error) {
    // ä»ä»»æ„å‰¯æœ¬è¯»å–
    return s.anyReplica().Get(key)
}
```

#### å› æœä¸€è‡´æ€§

```go
// ä¿è¯å› æœå…³ç³»çš„è¯»å–
type CausalConsistent struct {
    versions map[string]VectorClock
}

func (s *CausalConsistent) Read(key string, clock VectorClock) (string, error) {
    // åªè¿”å›æ»¡è¶³å› æœå…³ç³»çš„ç‰ˆæœ¬
    if s.versions[key].HappenedBefore(clock) {
        return s.get(key), nil
    }
    return "", errors.New("causality violation")
}
```

---

## 3. ğŸ”§ åˆ†å¸ƒå¼ç³»ç»ŸæŒ‘æˆ˜

### 3.1 ç½‘ç»œåˆ†åŒº

```go
// æ£€æµ‹ç½‘ç»œåˆ†åŒº
type PartitionDetector struct {
    peers     []string
    threshold time.Duration
}

func (d *PartitionDetector) IsPartitioned() bool {
    reachable := 0
    for _, peer := range d.peers {
        if d.canReach(peer, d.threshold) {
            reachable++
        }
    }
    return reachable < len(d.peers)/2+1
}
```

---

### 3.2 æ—¶é’ŸåŒæ­¥

```go
// Lamportæ—¶é’Ÿ
type LamportClock struct {
    counter int64
}

func (c *LamportClock) Tick() int64 {
    return atomic.AddInt64(&c.counter, 1)
}

func (c *LamportClock) Update(received int64) {
    for {
        current := atomic.LoadInt64(&c.counter)
        new := max(current, received) + 1
        if atomic.CompareAndSwapInt64(&c.counter, current, new) {
            break
        }
    }
}

// å‘é‡æ—¶é’Ÿ
type VectorClock map[string]int64

func (vc VectorClock) Increment(node string) {
    vc[node]++
}

func (vc VectorClock) HappenedBefore(other VectorClock) bool {
    // å®ç°å‘é‡æ—¶é’Ÿæ¯”è¾ƒé€»è¾‘
    for node, timestamp := range vc {
        if timestamp > other[node] {
            return false
        }
    }
    return true
}
```

---

### 3.3 æ•…éšœæ£€æµ‹

```go
// å¿ƒè·³æ£€æµ‹
type FailureDetector struct {
    heartbeats map[string]time.Time
    timeout    time.Duration
    mu         sync.RWMutex
}

func (fd *FailureDetector) Heartbeat(node string) {
    fd.mu.Lock()
    fd.heartbeats[node] = time.Now()
    fd.mu.Unlock()
}

func (fd *FailureDetector) IsFailed(node string) bool {
    fd.mu.RLock()
    lastSeen := fd.heartbeats[node]
    fd.mu.RUnlock()

    return time.Since(lastSeen) > fd.timeout
}

func (fd *FailureDetector) GetHealthyNodes() []string {
    fd.mu.RLock()
    defer fd.mu.RUnlock()

    var healthy []string
    for node, lastSeen := range fd.heartbeats {
        if time.Since(lastSeen) <= fd.timeout {
            healthy = append(healthy, node)
        }
    }
    return healthy
}
```

---

## 4. ğŸ’¡ Goåœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„ä¼˜åŠ¿

### 4.1 è½»é‡çº§å¹¶å‘

```go
// å¤„ç†æ•°åƒä¸ªè¿æ¥
for {
    conn, _ := listener.Accept()
    go handleConnection(conn) // è½»é‡çº§goroutine
}
```

### 4.2 å†…ç½®ç½‘ç»œåº“

```go
// ç®€æ´çš„ç½‘ç»œç¼–ç¨‹
listener, _ := net.Listen("tcp", ":8080")
conn, _ := net.Dial("tcp", "node2:8080")
```

### 4.3 é«˜æ•ˆåºåˆ—åŒ–

```go
// gob/protobuf/json
data, _ := json.Marshal(message)
```

### 4.4 å¼ºå¤§çš„æ ‡å‡†åº“

- net/rpc: RPCæ¡†æ¶
- net/http: HTTPæœåŠ¡
- sync: å¹¶å‘åŸè¯­
- context: è¶…æ—¶æ§åˆ¶

---

## 5. ğŸ“š ç›¸å…³èµ„æº

- [CAP Theorem](https://en.wikipedia.org/wiki/CAP_theorem)
- [Designing Data-Intensive Applications](https://dataintensive.net/)

**ä¸‹ä¸€æ­¥**: [02-æœåŠ¡æ³¨å†Œä¸å‘ç°](./02-æœåŠ¡æ³¨å†Œä¸å‘ç°.md)

---

**æœ€åæ›´æ–°**: 2025-10-29
