# 分布式系统基础

**版本**: v1.0
**更新日期**: 2025-10-29
**适用于**: Go 1.25.3

---

## 📋 目录

- [分布式系统基础](#分布式系统基础)
  - [📋 目录](#-目录)
  - [1. 📖 概念介绍](#1--概念介绍)
  - [2. 🎯 核心理论](#2--核心理论)
    - [2.1 CAP定理](#21-cap定理)
    - [2.2 BASE理论](#22-base理论)
    - [2.3 一致性模型](#23-一致性模型)
      - [强一致性](#强一致性)
      - [最终一致性](#最终一致性)
      - [因果一致性](#因果一致性)
  - [3. 🔧 分布式系统挑战](#3--分布式系统挑战)
    - [3.1 网络分区](#31-网络分区)
    - [3.2 时钟同步](#32-时钟同步)
    - [3.3 故障检测](#33-故障检测)
  - [4. 💡 Go在分布式系统中的优势](#4--go在分布式系统中的优势)
    - [4.1 轻量级并发](#41-轻量级并发)
    - [4.2 内置网络库](#42-内置网络库)
    - [4.3 高效序列化](#43-高效序列化)
    - [4.4 强大的标准库](#44-强大的标准库)
  - [5. 📚 相关资源](#5--相关资源)

## 1. 📖 概念介绍

分布式系统是由多个独立计算机组成的系统，对用户来说像单一系统。理解分布式系统的核心理论是构建可靠系统的基础。

---

## 2. 🎯 核心理论

### 2.1 CAP定理

```
Consistency (一致性)
Availability (可用性)
Partition Tolerance (分区容错)

定理：最多同时满足两个
```

**三种选择**:

- **CP**: 一致性+分区容错（如ZooKeeper）
- **AP**: 可用性+分区容错（如Cassandra）
- **CA**: 一致性+可用性（单机系统）

```go
// CP系统示例：强一致性
type CPSystem struct {
    leader  string
    replicas []string
}

func (s *CPSystem) Write(key, value string) error {
    // 必须同步到多数副本才返回成功
    successCount := 0
    for _, replica := range s.replicas {
        if err := syncWrite(replica, key, value); err == nil {
            successCount++
        }
    }

    if successCount < len(s.replicas)/2+1 {
        return errors.New("write failed: not enough replicas")
    }
    return nil
}

// AP系统示例：最终一致性
type APSystem struct {
    nodes []string
}

func (s *APSystem) Write(key, value string) error {
    // 异步写入所有节点
    for _, node := range s.nodes {
        go asyncWrite(node, key, value)
    }
    return nil // 立即返回
}
```

---

### 2.2 BASE理论

```
Basically Available    (基本可用)
Soft state            (软状态)
Eventually consistent (最终一致性)
```

**实现示例**:

```go
type EventuallyConsistentStore struct {
    local  map[string]string
    remote []string
    sync   chan SyncEvent
}

func (s *EventuallyConsistentStore) Set(key, value string) {
    // 立即写入本地
    s.local[key] = value

    // 异步同步到远程节点
    go func() {
        for _, node := range s.remote {
            s.sync <- SyncEvent{
                Node:  node,
                Key:   key,
                Value: value,
            }
        }
    }()
}
```

---

### 2.3 一致性模型

#### 强一致性

```go
// 读取最新写入的值
func (s *StrongConsistent) Read(key string) (string, error) {
    // 从leader读取
    return s.leader.Get(key)
}
```

#### 最终一致性

```go
// 读取可能是旧值，但最终会一致
func (s *EventualConsistent) Read(key string) (string, error) {
    // 从任意副本读取
    return s.anyReplica().Get(key)
}
```

#### 因果一致性

```go
// 保证因果关系的读取
type CausalConsistent struct {
    versions map[string]VectorClock
}

func (s *CausalConsistent) Read(key string, clock VectorClock) (string, error) {
    // 只返回满足因果关系的版本
    if s.versions[key].HappenedBefore(clock) {
        return s.get(key), nil
    }
    return "", errors.New("causality violation")
}
```

---

## 3. 🔧 分布式系统挑战

### 3.1 网络分区

```go
// 检测网络分区
type PartitionDetector struct {
    peers     []string
    threshold time.Duration
}

func (d *PartitionDetector) IsPartitioned() bool {
    reachable := 0
    for _, peer := range d.peers {
        if d.canReach(peer, d.threshold) {
            reachable++
        }
    }
    return reachable < len(d.peers)/2+1
}
```

---

### 3.2 时钟同步

```go
// Lamport时钟
type LamportClock struct {
    counter int64
}

func (c *LamportClock) Tick() int64 {
    return atomic.AddInt64(&c.counter, 1)
}

func (c *LamportClock) Update(received int64) {
    for {
        current := atomic.LoadInt64(&c.counter)
        new := max(current, received) + 1
        if atomic.CompareAndSwapInt64(&c.counter, current, new) {
            break
        }
    }
}

// 向量时钟
type VectorClock map[string]int64

func (vc VectorClock) Increment(node string) {
    vc[node]++
}

func (vc VectorClock) HappenedBefore(other VectorClock) bool {
    // 实现向量时钟比较逻辑
    for node, timestamp := range vc {
        if timestamp > other[node] {
            return false
        }
    }
    return true
}
```

---

### 3.3 故障检测

```go
// 心跳检测
type FailureDetector struct {
    heartbeats map[string]time.Time
    timeout    time.Duration
    mu         sync.RWMutex
}

func (fd *FailureDetector) Heartbeat(node string) {
    fd.mu.Lock()
    fd.heartbeats[node] = time.Now()
    fd.mu.Unlock()
}

func (fd *FailureDetector) IsFailed(node string) bool {
    fd.mu.RLock()
    lastSeen := fd.heartbeats[node]
    fd.mu.RUnlock()

    return time.Since(lastSeen) > fd.timeout
}

func (fd *FailureDetector) GetHealthyNodes() []string {
    fd.mu.RLock()
    defer fd.mu.RUnlock()

    var healthy []string
    for node, lastSeen := range fd.heartbeats {
        if time.Since(lastSeen) <= fd.timeout {
            healthy = append(healthy, node)
        }
    }
    return healthy
}
```

---

## 4. 💡 Go在分布式系统中的优势

### 4.1 轻量级并发

```go
// 处理数千个连接
for {
    conn, _ := listener.Accept()
    go handleConnection(conn) // 轻量级goroutine
}
```

### 4.2 内置网络库

```go
// 简洁的网络编程
listener, _ := net.Listen("tcp", ":8080")
conn, _ := net.Dial("tcp", "node2:8080")
```

### 4.3 高效序列化

```go
// gob/protobuf/json
data, _ := json.Marshal(message)
```

### 4.4 强大的标准库

- net/rpc: RPC框架
- net/http: HTTP服务
- sync: 并发原语
- context: 超时控制

---

## 5. 📚 相关资源

- [CAP Theorem](https://en.wikipedia.org/wiki/CAP_theorem)
- [Designing Data-Intensive Applications](https://dataintensive.net/)

**下一步**: [02-服务注册与发现](./02-服务注册与发现.md)

---

**最后更新**: 2025-10-29
