# è´Ÿè½½å‡è¡¡

**éš¾åº¦**: ä¸­çº§ | **é¢„è®¡é˜…è¯»**: 15åˆ†é’Ÿ | **å‰ç½®çŸ¥è¯†**: åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€

---

## ðŸ“‹ ç›®å½•


- [1. ðŸ“– æ¦‚å¿µä»‹ç»](#1--æ¦‚å¿µä»‹ç»)
- [2. ðŸŽ¯ è´Ÿè½½å‡è¡¡ç®—æ³•](#2--è´Ÿè½½å‡è¡¡ç®—æ³•)
  - [1. è½®è¯¢ï¼ˆRound Robinï¼‰](#1-è½®è¯¢round-robin)
  - [2. åŠ æƒè½®è¯¢](#2-åŠ æƒè½®è¯¢)
  - [3. æœ€å°‘è¿žæŽ¥ï¼ˆLeast Connectionsï¼‰](#3-æœ€å°‘è¿žæŽ¥least-connections)
  - [4. IPå“ˆå¸Œ](#4-ipå“ˆå¸Œ)
  - [5. éšæœº](#5-éšæœº)
- [ðŸ”§ å®žæˆ˜ç¤ºä¾‹](#-å®žæˆ˜ç¤ºä¾‹)
  - [HTTPåå‘ä»£ç†è´Ÿè½½å‡è¡¡](#httpåå‘ä»£ç†è´Ÿè½½å‡è¡¡)
  - [å¸¦å¥åº·æ£€æŸ¥çš„è´Ÿè½½å‡è¡¡](#å¸¦å¥åº·æ£€æŸ¥çš„è´Ÿè½½å‡è¡¡)
- [3. ðŸ’¡ æœ€ä½³å®žè·µ](#3--æœ€ä½³å®žè·µ)
- [4. ðŸ“š ç›¸å…³èµ„æº](#4--ç›¸å…³èµ„æº)

## 1. ðŸ“– æ¦‚å¿µä»‹ç»

è´Ÿè½½å‡è¡¡å°†è¯·æ±‚åˆ†å‘åˆ°å¤šä¸ªæœåŠ¡å®žä¾‹ï¼Œæé«˜ç³»ç»Ÿçš„å¯ç”¨æ€§å’Œæ€§èƒ½ã€‚

---

## 2. ðŸŽ¯ è´Ÿè½½å‡è¡¡ç®—æ³•

### 1. è½®è¯¢ï¼ˆRound Robinï¼‰

```go
type RoundRobinBalancer struct {
    servers []string
    current uint32
}

func (rb *RoundRobinBalancer) Next() string {
    n := atomic.AddUint32(&rb.current, 1)
    return rb.servers[(n-1)%uint32(len(rb.servers))]
}
```

---

### 2. åŠ æƒè½®è¯¢

```go
type WeightedServer struct {
    Address        string
    Weight         int
    CurrentWeight  int
    EffectiveWeight int
}

type WeightedRoundRobinBalancer struct {
    servers []*WeightedServer
    mu      sync.Mutex
}

func (wrb *WeightedRoundRobinBalancer) Next() string {
    wrb.mu.Lock()
    defer wrb.mu.Unlock()
    
    var best *WeightedServer
    total := 0
    
    for _, s := range wrb.servers {
        s.CurrentWeight += s.EffectiveWeight
        total += s.EffectiveWeight
        
        if best == nil || s.CurrentWeight > best.CurrentWeight {
            best = s
        }
    }
    
    if best == nil {
        return ""
    }
    
    best.CurrentWeight -= total
    return best.Address
}
```

---

### 3. æœ€å°‘è¿žæŽ¥ï¼ˆLeast Connectionsï¼‰

```go
type LeastConnectionsBalancer struct {
    servers     []string
    connections map[string]int
    mu          sync.RWMutex
}

func (lcb *LeastConnectionsBalancer) Next() string {
    lcb.mu.RLock()
    defer lcb.mu.RUnlock()
    
    var best string
    minConn := int(^uint(0) >> 1) // max int
    
    for _, server := range lcb.servers {
        if conn := lcb.connections[server]; conn < minConn {
            minConn = conn
            best = server
        }
    }
    
    return best
}

func (lcb *LeastConnectionsBalancer) IncrementConnection(server string) {
    lcb.mu.Lock()
    lcb.connections[server]++
    lcb.mu.Unlock()
}

func (lcb *LeastConnectionsBalancer) DecrementConnection(server string) {
    lcb.mu.Lock()
    lcb.connections[server]--
    lcb.mu.Unlock()
}
```

---

### 4. IPå“ˆå¸Œ

```go
type IPHashBalancer struct {
    servers []string
}

func (ihb *IPHashBalancer) Next(clientIP string) string {
    hash := fnv.New32a()
    hash.Write([]byte(clientIP))
    index := hash.Sum32() % uint32(len(ihb.servers))
    return ihb.servers[index]
}
```

---

### 5. éšæœº

```go
type RandomBalancer struct {
    servers []string
}

func (rb *RandomBalancer) Next() string {
    return rb.servers[rand.Intn(len(rb.servers))]
}
```

---

## ðŸ”§ å®žæˆ˜ç¤ºä¾‹

### HTTPåå‘ä»£ç†è´Ÿè½½å‡è¡¡

```go
package main

import (
    "net/http"
    "net/http/httputil"
    "net/url"
)

type LoadBalancer struct {
    backends  []*url.URL
    balancer  *RoundRobinBalancer
}

func NewLoadBalancer(backends []string) *LoadBalancer {
    urls := make([]*url.URL, len(backends))
    for i, backend := range backends {
        urls[i], _ = url.Parse(backend)
    }
    
    return &LoadBalancer{
        backends: urls,
        balancer: &RoundRobinBalancer{servers: backends},
    }
}

func (lb *LoadBalancer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // é€‰æ‹©åŽç«¯æœåŠ¡å™¨
    backend := lb.balancer.Next()
    targetURL, _ := url.Parse(backend)
    
    // åˆ›å»ºåå‘ä»£ç†
    proxy := httputil.NewSingleHostReverseProxy(targetURL)
    
    // è½¬å‘è¯·æ±‚
    proxy.ServeHTTP(w, r)
}

func main() {
    lb := NewLoadBalancer([]string{
        "http://backend1:8080",
        "http://backend2:8080",
        "http://backend3:8080",
    })
    
    http.ListenAndServe(":80", lb)
}
```

---

### å¸¦å¥åº·æ£€æŸ¥çš„è´Ÿè½½å‡è¡¡

```go
type HealthyBalancer struct {
    servers       []string
    healthStatus  map[string]bool
    balancer      *RoundRobinBalancer
    mu            sync.RWMutex
}

func (hb *HealthyBalancer) StartHealthCheck(ctx context.Context, interval time.Duration) {
    ticker := time.NewTicker(interval)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            hb.checkHealth()
        case <-ctx.Done():
            return
        }
    }
}

func (hb *HealthyBalancer) checkHealth() {
    for _, server := range hb.servers {
        go func(server string) {
            healthy := hb.isHealthy(server)
            hb.mu.Lock()
            hb.healthStatus[server] = healthy
            hb.mu.Unlock()
        }(server)
    }
}

func (hb *HealthyBalancer) isHealthy(server string) bool {
    client := &http.Client{Timeout: 3 * time.Second}
    resp, err := client.Get(fmt.Sprintf("http://%s/health", server))
    if err != nil {
        return false
    }
    defer resp.Body.Close()
    return resp.StatusCode == http.StatusOK
}

func (hb *HealthyBalancer) Next() string {
    hb.mu.RLock()
    defer hb.mu.RUnlock()
    
    // åªè¿”å›žå¥åº·çš„æœåŠ¡å™¨
    healthy := make([]string, 0)
    for _, server := range hb.servers {
        if hb.healthStatus[server] {
            healthy = append(healthy, server)
        }
    }
    
    if len(healthy) == 0 {
        return "" // æ— å¥åº·æœåŠ¡å™¨
    }
    
    return healthy[rand.Intn(len(healthy))]
}
```

---

## 3. ðŸ’¡ æœ€ä½³å®žè·µ

1. **é€‰æ‹©åˆé€‚çš„ç®—æ³•**
   - æ— çŠ¶æ€æœåŠ¡ï¼šè½®è¯¢ã€éšæœº
   - æœ‰çŠ¶æ€æœåŠ¡ï¼šIPå“ˆå¸Œã€ä¸€è‡´æ€§å“ˆå¸Œ
   - æ€§èƒ½å·®å¼‚å¤§ï¼šåŠ æƒè½®è¯¢ã€æœ€å°‘è¿žæŽ¥

2. **å¥åº·æ£€æŸ¥**
   - å®šæœŸæ£€æŸ¥åŽç«¯å¥åº·çŠ¶æ€
   - å¿«é€Ÿå‰”é™¤æ•…éšœèŠ‚ç‚¹
   - è‡ªåŠ¨æ¢å¤å¥åº·èŠ‚ç‚¹

3. **è¿žæŽ¥æ± **
   - å¤ç”¨è¿žæŽ¥å‡å°‘å¼€é”€
   - é™åˆ¶æœ€å¤§è¿žæŽ¥æ•°

4. **è¶…æ—¶æŽ§åˆ¶**
   - è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
   - é¿å…é›ªå´©æ•ˆåº”

---

## 4. ðŸ“š ç›¸å…³èµ„æº

- [NGINX Load Balancing](https://docs.nginx.com/nginx/admin-guide/load-balancer/)
- [HAProxy Documentation](http://www.haproxy.org/)

---

**æœ€åŽæ›´æ–°**: 2025-10-28

