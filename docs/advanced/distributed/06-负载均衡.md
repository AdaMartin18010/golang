# 负载均衡

**版本**: v1.0
**更新日期**: 2025-10-29
**适用于**: Go 1.25.3

---

## 📋 目录

- [负载均衡](#负载均衡)
  - [📋 目录](#-目录)
  - [1. 📖 概念介绍](#1--概念介绍)
  - [2. 🎯 负载均衡算法](#2--负载均衡算法)
    - [1. 轮询（Round Robin）](#1-轮询round-robin)
    - [2. 加权轮询](#2-加权轮询)
    - [3. 最少连接（Least Connections）](#3-最少连接least-connections)
    - [4. IP哈希](#4-ip哈希)
    - [5. 随机](#5-随机)
  - [🔧 实战示例](#-实战示例)
    - [HTTP反向代理负载均衡](#http反向代理负载均衡)
    - [带健康检查的负载均衡](#带健康检查的负载均衡)
  - [3. 💡 最佳实践](#3--最佳实践)
  - [4. 📚 相关资源](#4--相关资源)

## 1. 📖 概念介绍

负载均衡将请求分发到多个服务实例，提高系统的可用性和性能。

---

## 2. 🎯 负载均衡算法

### 1. 轮询（Round Robin）

```go
type RoundRobinBalancer struct {
    servers []string
    current uint32
}

func (rb *RoundRobinBalancer) Next() string {
    n := atomic.AddUint32(&rb.current, 1)
    return rb.servers[(n-1)%uint32(len(rb.servers))]
}
```

---

### 2. 加权轮询

```go
type WeightedServer struct {
    Address        string
    Weight         int
    CurrentWeight  int
    EffectiveWeight int
}

type WeightedRoundRobinBalancer struct {
    servers []*WeightedServer
    mu      sync.Mutex
}

func (wrb *WeightedRoundRobinBalancer) Next() string {
    wrb.mu.Lock()
    defer wrb.mu.Unlock()

    var best *WeightedServer
    total := 0

    for _, s := range wrb.servers {
        s.CurrentWeight += s.EffectiveWeight
        total += s.EffectiveWeight

        if best == nil || s.CurrentWeight > best.CurrentWeight {
            best = s
        }
    }

    if best == nil {
        return ""
    }

    best.CurrentWeight -= total
    return best.Address
}
```

---

### 3. 最少连接（Least Connections）

```go
type LeastConnectionsBalancer struct {
    servers     []string
    connections map[string]int
    mu          sync.RWMutex
}

func (lcb *LeastConnectionsBalancer) Next() string {
    lcb.mu.RLock()
    defer lcb.mu.RUnlock()

    var best string
    minConn := int(^uint(0) >> 1) // max int

    for _, server := range lcb.servers {
        if conn := lcb.connections[server]; conn < minConn {
            minConn = conn
            best = server
        }
    }

    return best
}

func (lcb *LeastConnectionsBalancer) IncrementConnection(server string) {
    lcb.mu.Lock()
    lcb.connections[server]++
    lcb.mu.Unlock()
}

func (lcb *LeastConnectionsBalancer) DecrementConnection(server string) {
    lcb.mu.Lock()
    lcb.connections[server]--
    lcb.mu.Unlock()
}
```

---

### 4. IP哈希

```go
type IPHashBalancer struct {
    servers []string
}

func (ihb *IPHashBalancer) Next(clientIP string) string {
    hash := fnv.New32a()
    hash.Write([]byte(clientIP))
    index := hash.Sum32() % uint32(len(ihb.servers))
    return ihb.servers[index]
}
```

---

### 5. 随机

```go
type RandomBalancer struct {
    servers []string
}

func (rb *RandomBalancer) Next() string {
    return rb.servers[rand.Intn(len(rb.servers))]
}
```

---

## 🔧 实战示例

### HTTP反向代理负载均衡

```go
package main

import (
    "net/http"
    "net/http/httputil"
    "net/url"
)

type LoadBalancer struct {
    backends  []*url.URL
    balancer  *RoundRobinBalancer
}

func NewLoadBalancer(backends []string) *LoadBalancer {
    urls := make([]*url.URL, len(backends))
    for i, backend := range backends {
        urls[i], _ = url.Parse(backend)
    }

    return &LoadBalancer{
        backends: urls,
        balancer: &RoundRobinBalancer{servers: backends},
    }
}

func (lb *LoadBalancer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // 选择后端服务器
    backend := lb.balancer.Next()
    targetURL, _ := url.Parse(backend)

    // 创建反向代理
    proxy := httputil.NewSingleHostReverseProxy(targetURL)

    // 转发请求
    proxy.ServeHTTP(w, r)
}

func main() {
    lb := NewLoadBalancer([]string{
        "http://backend1:8080",
        "http://backend2:8080",
        "http://backend3:8080",
    })

    http.ListenAndServe(":80", lb)
}
```

---

### 带健康检查的负载均衡

```go
type HealthyBalancer struct {
    servers       []string
    healthStatus  map[string]bool
    balancer      *RoundRobinBalancer
    mu            sync.RWMutex
}

func (hb *HealthyBalancer) StartHealthCheck(ctx Context.Context, interval time.Duration) {
    ticker := time.NewTicker(interval)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            hb.checkHealth()
        case <-ctx.Done():
            return
        }
    }
}

func (hb *HealthyBalancer) checkHealth() {
    for _, server := range hb.servers {
        go func(server string) {
            healthy := hb.isHealthy(server)
            hb.mu.Lock()
            hb.healthStatus[server] = healthy
            hb.mu.Unlock()
        }(server)
    }
}

func (hb *HealthyBalancer) isHealthy(server string) bool {
    client := &http.Client{Timeout: 3 * time.Second}
    resp, err := client.Get(fmt.Sprintf("http://%s/health", server))
    if err != nil {
        return false
    }
    defer resp.Body.Close()
    return resp.StatusCode == http.StatusOK
}

func (hb *HealthyBalancer) Next() string {
    hb.mu.RLock()
    defer hb.mu.RUnlock()

    // 只返回健康的服务器
    healthy := make([]string, 0)
    for _, server := range hb.servers {
        if hb.healthStatus[server] {
            healthy = append(healthy, server)
        }
    }

    if len(healthy) == 0 {
        return "" // 无健康服务器
    }

    return healthy[rand.Intn(len(healthy))]
}
```

---

## 3. 💡 最佳实践

1. **选择合适的算法**
   - 无状态服务：轮询、随机
   - 有状态服务：IP哈希、一致性哈希
   - 性能差异大：加权轮询、最少连接

2. **健康检查**
   - 定期检查后端健康状态
   - 快速剔除故障节点
   - 自动恢复健康节点

3. **连接池**
   - 复用连接减少开销
   - 限制最大连接数

4. **超时控制**
   - 设置合理的超时时间
   - 避免雪崩效应

---

## 4. 📚 相关资源

- [NGINX Load Balancing](https://docs.nginx.com/nginx/admin-guide/load-balancer/)
- [HAProxy Documentation](http://www.haproxy.org/)

---

**最后更新**: 2025-10-29
