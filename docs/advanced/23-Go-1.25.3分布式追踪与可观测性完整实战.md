# Go 1.25.3 分布式追踪与可观测性完整实战

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---


## 📋 目录


- [📖 文档说明](#文档说明)
- [目录](#目录)
- [1. OpenTelemetry基础](#1.-opentelemetry基础)
  - [1.1 初始化OpenTelemetry](#11-初始化opentelemetry)
- [2. 分布式追踪](#2.-分布式追踪)
  - [2.1 HTTP追踪中间件](#21-http追踪中间件)
  - [2.2 数据库追踪](#22-数据库追踪)
  - [2.3 gRPC追踪](#23-grpc追踪)
- [3. 指标监控](#3.-指标监控)
  - [3.1 业务指标](#31-业务指标)
  - [3.2 系统指标](#32-系统指标)
- [4. 结构化日志](#4.-结构化日志)
  - [4.1 结构化日志记录器](#41-结构化日志记录器)
- [5. 追踪后端集成](#5.-追踪后端集成)
  - [5.1 Jaeger集成](#51-jaeger集成)
  - [5.2 Zipkin集成](#52-zipkin集成)
- [6. 性能分析](#6.-性能分析)
  - [6.1 性能剖析](#61-性能剖析)
- [7. 告警系统](#7.-告警系统)
  - [7.1 告警规则](#71-告警规则)
  - [7.2 告警通知](#72-告警通知)
- [8. 完整案例](#8.-完整案例)
  - [8.1 可观测性完整集成](#81-可观测性完整集成)
- [📚 可观测性最佳实践](#可观测性最佳实践)
  - [追踪](#追踪)
  - [指标](#指标)
  - [日志](#日志)
  - [告警](#告警)
- [🎯 总结](#总结)

## 📖 文档说明

本文档展示Go 1.25.3的**分布式追踪与可观测性完整方案**，构建企业级监控系统：

- ✅ OpenTelemetry完整集成
- ✅ 分布式追踪(Trace)
- ✅ 指标监控(Metrics)
- ✅ 结构化日志(Logs)
- ✅ Jaeger/Zipkin追踪
- ✅ Prometheus指标导出
- ✅ 性能分析与告警

---

## 目录

1. [OpenTelemetry基础](#opentelemetry基础)
2. [分布[分布式追踪](#分布式追踪). [指标监控][指标监控](#指标监控)结构化日志](#[结构化日志](#结构化日志)端集成](#5.[追踪后端集成](#追踪后端集成)#6.-性能分析[性能分析](#性能分析)-告警系统)
[告警系统](#告警系统)案例)

-[完整案例](#完整案例)Telemetry基础

### 1.1 初始化OpenTelemetry

```go
package observability

import (
 "context"
 "log"
 "time"
 
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/exporters/jaeger"
 "go.opentelemetry.io/otel/exporters/prometheus"
 "go.opentelemetry.io/otel/metric"
 "go.opentelemetry.io/otel/propagation"
 "go.opentelemetry.io/otel/sdk/metric"
 "go.opentelemetry.io/otel/sdk/resource"
 "go.opentelemetry.io/otel/sdk/trace"
 semconv "go.opentelemetry.io/otel/semconv/v1.21.0"
)

// Config OpenTelemetry配置
type Config struct {
 ServiceName    string
 ServiceVersion string
 Environment    string
 JaegerEndpoint string
}

// InitOpenTelemetry 初始化OpenTelemetry
func InitOpenTelemetry(cfg *Config) (func(context.Context) error, error) {
 // 1. 创建资源
 res, err := resource.New(
  context.Background(),
  resource.WithAttributes(
   semconv.ServiceName(cfg.ServiceName),
   semconv.ServiceVersion(cfg.ServiceVersion),
   semconv.DeploymentEnvironment(cfg.Environment),
  ),
 )
 if err != nil {
  return nil, err
 }
 
 // 2. 初始化追踪
 tracerShutdown, err := initTracer(res, cfg.JaegerEndpoint)
 if err != nil {
  return nil, err
 }
 
 // 3. 初始化指标
 meterShutdown, err := initMeter(res)
 if err != nil {
  tracerShutdown(context.Background())
  return nil, err
 }
 
 // 4. 设置全局传播器
 otel.SetTextMapPropagator(
  propagation.NewCompositeTextMapPropagator(
   propagation.TraceContext{},
   propagation.Baggage{},
  ),
 )
 
 // 返回清理函数
 return func(ctx context.Context) error {
  if err := tracerShutdown(ctx); err != nil {
   return err
  }
  return meterShutdown(ctx)
 }, nil
}

// initTracer 初始化追踪器
func initTracer(res *resource.Resource, endpoint string) (func(context.Context) error, error) {
 // 创建Jaeger导出器
 exp, err := jaeger.New(jaeger.WithCollectorEndpoint(jaeger.WithEndpoint(endpoint)))
 if err != nil {
  return nil, err
 }
 
 // 创建追踪提供者
 tp := trace.NewTracerProvider(
  trace.WithBatcher(exp,
   trace.WithBatchTimeout(5*time.Second),
   trace.WithMaxExportBatchSize(512),
  ),
  trace.WithResource(res),
  trace.WithSampler(trace.TraceIDRatioBased(1.0)), // 采样率100%
 )
 
 otel.SetTracerProvider(tp)
 
 return tp.Shutdown, nil
}

// initMeter 初始化度量器
func initMeter(res *resource.Resource) (func(context.Context) error, error) {
 // 创建Prometheus导出器
 exporter, err := prometheus.New()
 if err != nil {
  return nil, err
 }
 
 // 创建度量提供者
 mp := metric.NewMeterProvider(
  metric.WithReader(exporter),
  metric.WithResource(res),
 )
 
 otel.SetMeterProvider(mp)
 
 return mp.Shutdown, nil
}
```

---

## 2. 分布式追踪

### 2.1 HTTP追踪中间件

```go
package tracing

import (
 "fmt"
 "net/http"
 
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/codes"
 "go.opentelemetry.io/otel/propagation"
 "go.opentelemetry.io/otel/trace"
)

// HTTPTracing HTTP追踪中间件
func HTTPTracing(serviceName string) func(http.Handler) http.Handler {
 tracer := otel.Tracer(serviceName)
 propagator := otel.GetTextMapPropagator()
 
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   // 从请求头中提取上下文
   ctx := propagator.Extract(r.Context(), propagation.HeaderCarrier(r.Header))
   
   // 开始span
   ctx, span := tracer.Start(ctx, fmt.Sprintf("%s %s", r.Method, r.URL.Path),
    trace.WithSpanKind(trace.SpanKindServer),
    trace.WithAttributes(
     attribute.String("http.method", r.Method),
     attribute.String("http.url", r.URL.String()),
     attribute.String("http.scheme", r.URL.Scheme),
     attribute.String("http.host", r.Host),
     attribute.String("http.user_agent", r.UserAgent()),
     attribute.String("http.client_ip", r.RemoteAddr),
    ),
   )
   defer span.End()
   
   // 创建响应记录器
   recorder := &statusRecorder{
    ResponseWriter: w,
    statusCode:     http.StatusOK,
   }
   
   // 处理请求
   next.ServeHTTP(recorder, r.WithContext(ctx))
   
   // 记录响应信息
   span.SetAttributes(
    attribute.Int("http.status_code", recorder.statusCode),
   )
   
   // 如果是错误状态码，记录为错误
   if recorder.statusCode >= 400 {
    span.SetStatus(codes.Error, http.StatusText(recorder.statusCode))
   }
  })
 }
}

type statusRecorder struct {
 http.ResponseWriter
 statusCode int
}

func (sr *statusRecorder) WriteHeader(code int) {
 sr.statusCode = code
 sr.ResponseWriter.WriteHeader(code)
}
```

---

### 2.2 数据库追踪

```go
package tracing

import (
 "context"
 "database/sql"
 "time"
 
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/codes"
 "go.opentelemetry.io/otel/trace"
)

// TracedDB 带追踪的数据库
type TracedDB struct {
 *sql.DB
 tracer trace.Tracer
}

// NewTracedDB 创建带追踪的数据库
func NewTracedDB(db *sql.DB, serviceName string) *TracedDB {
 return &TracedDB{
  DB:     db,
  tracer: otel.Tracer(serviceName),
 }
}

// QueryContext 带追踪的查询
func (tdb *TracedDB) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
 ctx, span := tdb.tracer.Start(ctx, "db.query",
  trace.WithSpanKind(trace.SpanKindClient),
  trace.WithAttributes(
   attribute.String("db.system", "mysql"),
   attribute.String("db.statement", query),
  ),
 )
 defer span.End()
 
 start := time.Now()
 rows, err := tdb.DB.QueryContext(ctx, query, args...)
 duration := time.Since(start)
 
 span.SetAttributes(
  attribute.Int64("db.duration_ms", duration.Milliseconds()),
 )
 
 if err != nil {
  span.RecordError(err)
  span.SetStatus(codes.Error, err.Error())
 }
 
 return rows, err
}

// ExecContext 带追踪的执行
func (tdb *TracedDB) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
 ctx, span := tdb.tracer.Start(ctx, "db.exec",
  trace.WithSpanKind(trace.SpanKindClient),
  trace.WithAttributes(
   attribute.String("db.system", "mysql"),
   attribute.String("db.statement", query),
  ),
 )
 defer span.End()
 
 start := time.Now()
 result, err := tdb.DB.ExecContext(ctx, query, args...)
 duration := time.Since(start)
 
 span.SetAttributes(
  attribute.Int64("db.duration_ms", duration.Milliseconds()),
 )
 
 if err != nil {
  span.RecordError(err)
  span.SetStatus(codes.Error, err.Error())
 }
 
 return result, err
}
```

---

### 2.3 gRPC追踪

```go
package tracing

import (
 "context"
 
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/codes"
 "go.opentelemetry.io/otel/trace"
 "google.golang.org/grpc"
 "google.golang.org/grpc/metadata"
 "google.golang.org/grpc/status"
)

// UnaryServerInterceptor gRPC服务端追踪拦截器
func UnaryServerInterceptor(serviceName string) grpc.UnaryServerInterceptor {
 tracer := otel.Tracer(serviceName)
 propagator := otel.GetTextMapPropagator()
 
 return func(
  ctx context.Context,
  req interface{},
  info *grpc.UnaryServerInfo,
  handler grpc.UnaryHandler,
 ) (interface{}, error) {
  // 从metadata中提取上下文
  md, _ := metadata.FromIncomingContext(ctx)
  ctx = propagator.Extract(ctx, &metadataCarrier{md})
  
  // 开始span
  ctx, span := tracer.Start(ctx, info.FullMethod,
   trace.WithSpanKind(trace.SpanKindServer),
   trace.WithAttributes(
    attribute.String("rpc.system", "grpc"),
    attribute.String("rpc.service", info.FullMethod),
   ),
  )
  defer span.End()
  
  // 调用handler
  resp, err := handler(ctx, req)
  
  // 记录错误
  if err != nil {
   span.RecordError(err)
   span.SetStatus(codes.Error, err.Error())
   
   // 记录gRPC状态码
   st, _ := status.FromError(err)
   span.SetAttributes(
    attribute.Int("rpc.grpc.status_code", int(st.Code())),
   )
  }
  
  return resp, err
 }
}

// UnaryClientInterceptor gRPC客户端追踪拦截器
func UnaryClientInterceptor(serviceName string) grpc.UnaryClientInterceptor {
 tracer := otel.Tracer(serviceName)
 propagator := otel.GetTextMapPropagator()
 
 return func(
  ctx context.Context,
  method string,
  req, reply interface{},
  cc *grpc.ClientConn,
  invoker grpc.UnaryInvoker,
  opts ...grpc.CallOption,
 ) error {
  // 开始span
  ctx, span := tracer.Start(ctx, method,
   trace.WithSpanKind(trace.SpanKindClient),
   trace.WithAttributes(
    attribute.String("rpc.system", "grpc"),
    attribute.String("rpc.service", method),
   ),
  )
  defer span.End()
  
  // 注入上下文到metadata
  md, ok := metadata.FromOutgoingContext(ctx)
  if !ok {
   md = metadata.New(nil)
  }
  propagator.Inject(ctx, &metadataCarrier{md})
  ctx = metadata.NewOutgoingContext(ctx, md)
  
  // 调用RPC
  err := invoker(ctx, method, req, reply, cc, opts...)
  
  if err != nil {
   span.RecordError(err)
   span.SetStatus(codes.Error, err.Error())
  }
  
  return err
 }
}

// metadataCarrier gRPC metadata载体
type metadataCarrier struct {
 md metadata.MD
}

func (mc *metadataCarrier) Get(key string) string {
 values := mc.md.Get(key)
 if len(values) == 0 {
  return ""
 }
 return values[0]
}

func (mc *metadataCarrier) Set(key, value string) {
 mc.md.Set(key, value)
}

func (mc *metadataCarrier) Keys() []string {
 keys := make([]string, 0, len(mc.md))
 for k := range mc.md {
  keys = append(keys, k)
 }
 return keys
}
```

---

## 3. 指标监控

### 3.1 业务指标

```go
package metrics

import (
 "context"
 "time"
 
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/metric"
)

// Metrics 指标收集器
type Metrics struct {
 requestCounter  metric.Int64Counter
 requestDuration metric.Float64Histogram
 activeRequests  metric.Int64UpDownCounter
 errorCounter    metric.Int64Counter
}

// NewMetrics 创建指标收集器
func NewMetrics(serviceName string) (*Metrics, error) {
 meter := otel.Meter(serviceName)
 
 // 请求计数器
 requestCounter, err := meter.Int64Counter(
  "http.server.request.count",
  metric.WithDescription("Total number of HTTP requests"),
  metric.WithUnit("1"),
 )
 if err != nil {
  return nil, err
 }
 
 // 请求时长直方图
 requestDuration, err := meter.Float64Histogram(
  "http.server.request.duration",
  metric.WithDescription("HTTP request duration"),
  metric.WithUnit("ms"),
 )
 if err != nil {
  return nil, err
 }
 
 // 活跃请求计数
 activeRequests, err := meter.Int64UpDownCounter(
  "http.server.active_requests",
  metric.WithDescription("Number of active HTTP requests"),
  metric.WithUnit("1"),
 )
 if err != nil {
  return nil, err
 }
 
 // 错误计数器
 errorCounter, err := meter.Int64Counter(
  "http.server.error.count",
  metric.WithDescription("Total number of HTTP errors"),
  metric.WithUnit("1"),
 )
 if err != nil {
  return nil, err
 }
 
 return &Metrics{
  requestCounter:  requestCounter,
  requestDuration: requestDuration,
  activeRequests:  activeRequests,
  errorCounter:    errorCounter,
 }, nil
}

// RecordRequest 记录请求
func (m *Metrics) RecordRequest(ctx context.Context, method, path string, statusCode int, duration time.Duration) {
 attrs := []attribute.KeyValue{
  attribute.String("http.method", method),
  attribute.String("http.path", path),
  attribute.Int("http.status_code", statusCode),
 }
 
 // 增加请求计数
 m.requestCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
 
 // 记录请求时长
 m.requestDuration.Record(ctx, float64(duration.Milliseconds()), metric.WithAttributes(attrs...))
 
 // 记录错误
 if statusCode >= 400 {
  m.errorCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
 }
}

// IncActiveRequests 增加活跃请求
func (m *Metrics) IncActiveRequests(ctx context.Context) {
 m.activeRequests.Add(ctx, 1)
}

// DecActiveRequests 减少活跃请求
func (m *Metrics) DecActiveRequests(ctx context.Context) {
 m.activeRequests.Add(ctx, -1)
}

// MetricsMiddleware 指标中间件
func MetricsMiddleware(metrics *Metrics) func(http.Handler) http.Handler {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   ctx := r.Context()
   
   // 增加活跃请求
   metrics.IncActiveRequests(ctx)
   defer metrics.DecActiveRequests(ctx)
   
   // 记录开始时间
   start := time.Now()
   
   // 创建响应记录器
   recorder := &statusRecorder{
    ResponseWriter: w,
    statusCode:     http.StatusOK,
   }
   
   // 处理请求
   next.ServeHTTP(recorder, r)
   
   // 记录指标
   metrics.RecordRequest(ctx, r.Method, r.URL.Path, recorder.statusCode, time.Since(start))
  })
 }
}
```

---

### 3.2 系统指标

```go
package metrics

import (
 "context"
 "runtime"
 "time"
 
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/metric"
)

// SystemMetrics 系统指标
type SystemMetrics struct {
 goroutineCount metric.Int64ObservableGauge
 memoryUsage    metric.Int64ObservableGauge
 gcCount        metric.Int64ObservableCounter
}

// NewSystemMetrics 创建系统指标
func NewSystemMetrics(serviceName string) (*SystemMetrics, error) {
 meter := otel.Meter(serviceName)
 
 sm := &SystemMetrics{}
 
 // Goroutine数量
 goroutineCount, err := meter.Int64ObservableGauge(
  "runtime.go.goroutines",
  metric.WithDescription("Number of goroutines"),
 )
 if err != nil {
  return nil, err
 }
 sm.goroutineCount = goroutineCount
 
 // 内存使用
 memoryUsage, err := meter.Int64ObservableGauge(
  "runtime.go.mem.heap_alloc",
  metric.WithDescription("Heap memory allocated"),
  metric.WithUnit("By"),
 )
 if err != nil {
  return nil, err
 }
 sm.memoryUsage = memoryUsage
 
 // GC次数
 gcCount, err := meter.Int64ObservableCounter(
  "runtime.go.gc.count",
  metric.WithDescription("Number of completed GC cycles"),
 )
 if err != nil {
  return nil, err
 }
 sm.gcCount = gcCount
 
 // 注册回调
 _, err = meter.RegisterCallback(
  func(ctx context.Context, o metric.Observer) error {
   // Goroutine数量
   o.ObserveInt64(goroutineCount, int64(runtime.NumGoroutine()))
   
   // 内存使用
   var m runtime.MemStats
   runtime.ReadMemStats(&m)
   o.ObserveInt64(memoryUsage, int64(m.HeapAlloc))
   o.ObserveInt64(gcCount, int64(m.NumGC))
   
   return nil
  },
  goroutineCount,
  memoryUsage,
  gcCount,
 )
 
 return sm, err
}
```

---

## 4. 结构化日志

### 4.1 结构化日志记录器

```go
package logging

import (
 "context"
 "log/slog"
 "os"
 
 "go.opentelemetry.io/otel/trace"
)

// Logger 结构化日志记录器
type Logger struct {
 *slog.Logger
}

// NewLogger 创建日志记录器
func NewLogger(serviceName, environment string) *Logger {
 handler := slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
  Level: slog.LevelInfo,
 })
 
 logger := slog.New(handler).With(
  slog.String("service", serviceName),
  slog.String("environment", environment),
 )
 
 return &Logger{Logger: logger}
}

// WithTrace 添加追踪信息
func (l *Logger) WithTrace(ctx context.Context) *slog.Logger {
 span := trace.SpanFromContext(ctx)
 if !span.IsRecording() {
  return l.Logger
 }
 
 spanCtx := span.SpanContext()
 return l.Logger.With(
  slog.String("trace_id", spanCtx.TraceID().String()),
  slog.String("span_id", spanCtx.SpanID().String()),
 )
}

// InfoCtx 带上下文的Info日志
func (l *Logger) InfoCtx(ctx context.Context, msg string, args ...any) {
 l.WithTrace(ctx).Info(msg, args...)
}

// ErrorCtx 带上下文的Error日志
func (l *Logger) ErrorCtx(ctx context.Context, msg string, args ...any) {
 l.WithTrace(ctx).Error(msg, args...)
}

// WarnCtx 带上下文的Warn日志
func (l *Logger) WarnCtx(ctx context.Context, msg string, args ...any) {
 l.WithTrace(ctx).Warn(msg, args...)
}

// DebugCtx 带上下文的Debug日志
func (l *Logger) DebugCtx(ctx context.Context, msg string, args ...any) {
 l.WithTrace(ctx).Debug(msg, args...)
}
```

---

## 5. 追踪后端集成

### 5.1 Jaeger集成

```go
package observability

import (
 "go.opentelemetry.io/otel/exporters/jaeger"
 "go.opentelemetry.io/otel/sdk/trace"
)

// NewJaegerExporter 创建Jaeger导出器
func NewJaegerExporter(endpoint string) (trace.SpanExporter, error) {
 return jaeger.New(
  jaeger.WithCollectorEndpoint(
   jaeger.WithEndpoint(endpoint),
  ),
 )
}
```

---

### 5.2 Zipkin集成

```go
package observability

import (
 "go.opentelemetry.io/otel/exporters/zipkin"
 "go.opentelemetry.io/otel/sdk/trace"
)

// NewZipkinExporter 创建Zipkin导出器
func NewZipkinExporter(endpoint string) (trace.SpanExporter, error) {
 return zipkin.New(endpoint)
}
```

---

## 6. 性能分析

### 6.1 性能剖析

```go
package profiling

import (
 "context"
 "net/http"
 "net/http/pprof"
 "runtime"
 "time"
 
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/trace"
)

// EnableProfiling 启用性能剖析
func EnableProfiling(mux *http.ServeMux) {
 mux.HandleFunc("/debug/pprof/", pprof.Index)
 mux.HandleFunc("/debug/pprof/cmdline", pprof.Cmdline)
 mux.HandleFunc("/debug/pprof/profile", pprof.Profile)
 mux.HandleFunc("/debug/pprof/symbol", pprof.Symbol)
 mux.HandleFunc("/debug/pprof/trace", pprof.Trace)
}

// ProfiledFunction 带性能分析的函数包装
func ProfiledFunction(ctx context.Context, name string, fn func() error) error {
 tracer := otel.Tracer("profiling")
 
 // 开始span
 ctx, span := tracer.Start(ctx, name,
  trace.WithAttributes(
   attribute.String("function", name),
  ),
 )
 defer span.End()
 
 // 记录开始时的内存状态
 var m1 runtime.MemStats
 runtime.ReadMemStats(&m1)
 
 start := time.Now()
 
 // 执行函数
 err := fn()
 
 duration := time.Since(start)
 
 // 记录结束时的内存状态
 var m2 runtime.MemStats
 runtime.ReadMemStats(&m2)
 
 // 记录性能指标
 span.SetAttributes(
  attribute.Int64("duration_ms", duration.Milliseconds()),
  attribute.Int64("alloc_bytes", int64(m2.Alloc-m1.Alloc)),
  attribute.Int64("total_alloc_bytes", int64(m2.TotalAlloc-m1.TotalAlloc)),
 )
 
 if err != nil {
  span.RecordError(err)
 }
 
 return err
}
```

---

## 7. 告警系统

### 7.1 告警规则

```go
package alerting

import (
 "context"
 "fmt"
 "sync"
 "time"
)

// AlertManager 告警管理器
type AlertManager struct {
 rules    []AlertRule
 notifier Notifier
 mu       sync.RWMutex
}

// AlertRule 告警规则
type AlertRule struct {
 Name        string
 Description string
 Condition   func(ctx context.Context) (bool, string)
 Severity    Severity
 Cooldown    time.Duration
 lastFired   time.Time
}

// Severity 严重程度
type Severity int

const (
 SeverityInfo Severity = iota
 SeverityWarning
 SeverityError
 SeverityCritical
)

// Notifier 通知器接口
type Notifier interface {
 Notify(ctx context.Context, alert *Alert) error
}

// Alert 告警
type Alert struct {
 RuleName    string
 Description string
 Message     string
 Severity    Severity
 Timestamp   time.Time
}

// NewAlertManager 创建告警管理器
func NewAlertManager(notifier Notifier) *AlertManager {
 return &AlertManager{
  rules:    make([]AlertRule, 0),
  notifier: notifier,
 }
}

// AddRule 添加告警规则
func (am *AlertManager) AddRule(rule AlertRule) {
 am.mu.Lock()
 defer am.mu.Unlock()
 
 am.rules = append(am.rules, rule)
}

// Start 启动告警检查
func (am *AlertManager) Start(ctx context.Context, checkInterval time.Duration) {
 ticker := time.NewTicker(checkInterval)
 defer ticker.Stop()
 
 for {
  select {
  case <-ticker.C:
   am.check(ctx)
  case <-ctx.Done():
   return
  }
 }
}

// check 检查告警规则
func (am *AlertManager) check(ctx context.Context) {
 am.mu.RLock()
 rules := make([]AlertRule, len(am.rules))
 copy(rules, am.rules)
 am.mu.RUnlock()
 
 for i := range rules {
  rule := &rules[i]
  
  // 检查冷却期
  if time.Since(rule.lastFired) < rule.Cooldown {
   continue
  }
  
  // 检查条件
  triggered, message := rule.Condition(ctx)
  if !triggered {
   continue
  }
  
  // 发送告警
  alert := &Alert{
   RuleName:    rule.Name,
   Description: rule.Description,
   Message:     message,
   Severity:    rule.Severity,
   Timestamp:   time.Now(),
  }
  
  if err := am.notifier.Notify(ctx, alert); err != nil {
   fmt.Printf("Failed to send alert: %v\n", err)
  }
  
  // 更新最后触发时间
  am.mu.Lock()
  for j := range am.rules {
   if am.rules[j].Name == rule.Name {
    am.rules[j].lastFired = time.Now()
    break
   }
  }
  am.mu.Unlock()
 }
}
```

---

### 7.2 告警通知

```go
// EmailNotifier 邮件通知器
type EmailNotifier struct {
 smtpHost string
 smtpPort int
 from     string
 to       []string
}

// Notify 发送通知
func (en *EmailNotifier) Notify(ctx context.Context, alert *Alert) error {
 subject := fmt.Sprintf("[%s] %s", alert.Severity, alert.RuleName)
 body := fmt.Sprintf(
  "Alert: %s\nDescription: %s\nMessage: %s\nTime: %s",
  alert.RuleName,
  alert.Description,
  alert.Message,
  alert.Timestamp.Format(time.RFC3339),
 )
 
 // 发送邮件的实现...
 fmt.Printf("Sending email alert: %s\n", subject)
 
 return nil
}

// WebhookNotifier Webhook通知器
type WebhookNotifier struct {
 url string
}

// Notify 发送通知
func (wn *WebhookNotifier) Notify(ctx context.Context, alert *Alert) error {
 // 发送HTTP请求到Webhook
 // ...
 fmt.Printf("Sending webhook notification to %s\n", wn.url)
 
 return nil
}
```

---

## 8. 完整案例

### 8.1 可观测性完整集成

```go
package main

import (
 "context"
 "log"
 "net/http"
 "time"
)

func main() {
 ctx := context.Background()
 
 // 1. 初始化OpenTelemetry
 shutdown, err := observability.InitOpenTelemetry(&observability.Config{
  ServiceName:    "my-service",
  ServiceVersion: "1.0.0",
  Environment:    "production",
  JaegerEndpoint: "http://localhost:14268/api/traces",
 })
 if err != nil {
  log.Fatal(err)
 }
 defer shutdown(ctx)
 
 // 2. 创建日志记录器
 logger := logging.NewLogger("my-service", "production")
 
 // 3. 创建指标收集器
 metrics, err := metrics.NewMetrics("my-service")
 if err != nil {
  log.Fatal(err)
 }
 
 // 4. 创建系统指标
 systemMetrics, err := metrics.NewSystemMetrics("my-service")
 if err != nil {
  log.Fatal(err)
 }
 _ = systemMetrics
 
 // 5. 创建告警管理器
 alertManager := alerting.NewAlertManager(&alerting.EmailNotifier{
  smtpHost: "smtp.example.com",
  smtpPort: 587,
  from:     "alerts@example.com",
  to:       []string{"admin@example.com"},
 })
 
 // 添加告警规则
 alertManager.AddRule(alerting.AlertRule{
  Name:        "high_error_rate",
  Description: "Error rate is too high",
  Condition: func(ctx context.Context) (bool, string) {
   // 检查错误率
   // ...
   return false, ""
  },
  Severity: alerting.SeverityWarning,
  Cooldown: 5 * time.Minute,
 })
 
 // 启动告警检查
 go alertManager.Start(ctx, 1*time.Minute)
 
 // 6. 创建HTTP服务器
 mux := http.NewServeMux()
 
 // 业务路由
 mux.HandleFunc("/api/users", func(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  
  logger.InfoCtx(ctx, "Handling request",
   "method", r.Method,
   "path", r.URL.Path,
  )
  
  // 业务逻辑...
  w.WriteHeader(http.StatusOK)
  w.Write([]byte(`{"status":"ok"}`))
 })
 
 // Prometheus指标端点
 mux.Handle("/metrics", promhttp.Handler())
 
 // pprof端点
 profiling.EnableProfiling(mux)
 
 // 应用中间件
 handler := applyMiddleware(mux,
  tracing.HTTPTracing("my-service"),
  metrics.MetricsMiddleware(metrics),
  logging.LoggingMiddleware(logger),
 )
 
 // 启动服务器
 server := &http.Server{
  Addr:    ":8080",
  Handler: handler,
 }
 
 log.Println("Server starting on :8080")
 log.Fatal(server.ListenAndServe())
}

func applyMiddleware(h http.Handler, middlewares ...func(http.Handler) http.Handler) http.Handler {
 for i := len(middlewares) - 1; i >= 0; i-- {
  h = middlewares[i](h)
 }
 return h
}
```

---

## 📚 可观测性最佳实践

### 追踪

- ✅ 使用OpenTelemetry标准
- ✅ 合理设置采样率
- ✅ 记录关键业务操作
- ✅ 传播追踪上下文

### 指标

- ✅ 使用标准指标命名
- ✅ 合理设置直方图桶
- ✅ 记录业务和系统指标
- ✅ 定期导出指标

### 日志

- ✅ 使用结构化日志
- ✅ 关联追踪ID
- ✅ 合理设置日志级别
- ✅ 避免敏感信息

### 告警

- ✅ 设置合理阈值
- ✅ 避免告警疲劳
- ✅ 多渠道通知
- ✅ 告警自愈机制

---

## 🎯 总结

Go 1.25.3可观测性关键点：

1. **OpenTelemetry**: 统一标准、Trace/Metrics/Logs
2. **分布式追踪**: HTTP/gRPC/DB追踪、上下文传播
3. **指标监控**: 业务指标、系统指标、Prometheus集成
4. **结构化日志**: slog、追踪关联、JSON格式
5. **后端集成**: Jaeger、Zipkin、Prometheus、Grafana
6. **性能分析**: pprof、内存分析、性能包装
7. **告警系统**: 规则引擎、多渠道通知、冷却期

**可观测性是系统稳定运行的基石！**

---

<div align="center">

**构建全面可观测的Go应用**:

[📚 返回目录](../README.md) | [📖 下一章](24-下一主题.md)

Made with ❤️ for Go Developers

</div>

---

**文档版本**: v1.0  
**最后更新**: 2025-10-29  
**Go版本**: Go 1.25.3  
**生产就绪**: ✅
