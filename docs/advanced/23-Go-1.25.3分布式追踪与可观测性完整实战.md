# Go 1.25.3 åˆ†å¸ƒå¼è¿½è¸ªä¸å¯è§‚æµ‹æ€§å®Œæ•´å®æˆ˜

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.25.3

---

## ğŸ“‹ ç›®å½•

- [Go 1.25.3 åˆ†å¸ƒå¼è¿½è¸ªä¸å¯è§‚æµ‹æ€§å®Œæ•´å®æˆ˜](#go-1253-åˆ†å¸ƒå¼è¿½è¸ªä¸å¯è§‚æµ‹æ€§å®Œæ•´å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“– æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
    - [1.1 åˆå§‹åŒ–OpenTelemetry](#11-åˆå§‹åŒ–opentelemetry)
  - [2. åˆ†å¸ƒå¼è¿½è¸ª](#2-åˆ†å¸ƒå¼è¿½è¸ª)
    - [2.1 HTTPè¿½è¸ªä¸­é—´ä»¶](#21-httpè¿½è¸ªä¸­é—´ä»¶)
    - [2.2 æ•°æ®åº“è¿½è¸ª](#22-æ•°æ®åº“è¿½è¸ª)
    - [2.3 gRPCè¿½è¸ª](#23-grpcè¿½è¸ª)
  - [3. æŒ‡æ ‡ç›‘æ§](#3-æŒ‡æ ‡ç›‘æ§)
    - [3.1 ä¸šåŠ¡æŒ‡æ ‡](#31-ä¸šåŠ¡æŒ‡æ ‡)
    - [3.2 ç³»ç»ŸæŒ‡æ ‡](#32-ç³»ç»ŸæŒ‡æ ‡)
  - [4. ç»“æ„åŒ–æ—¥å¿—](#4-ç»“æ„åŒ–æ—¥å¿—)
    - [4.1 ç»“æ„åŒ–æ—¥å¿—è®°å½•å™¨](#41-ç»“æ„åŒ–æ—¥å¿—è®°å½•å™¨)
  - [5. è¿½è¸ªåç«¯é›†æˆ](#5-è¿½è¸ªåç«¯é›†æˆ)
    - [5.1 Jaegeré›†æˆ](#51-jaegeré›†æˆ)
    - [5.2 Zipkiné›†æˆ](#52-zipkiné›†æˆ)
  - [6. æ€§èƒ½åˆ†æ](#6-æ€§èƒ½åˆ†æ)
    - [6.1 æ€§èƒ½å‰–æ](#61-æ€§èƒ½å‰–æ)
  - [7. å‘Šè­¦ç³»ç»Ÿ](#7-å‘Šè­¦ç³»ç»Ÿ)
    - [7.1 å‘Šè­¦è§„åˆ™](#71-å‘Šè­¦è§„åˆ™)
    - [7.2 å‘Šè­¦é€šçŸ¥](#72-å‘Šè­¦é€šçŸ¥)
  - [8. å®Œæ•´æ¡ˆä¾‹](#8-å®Œæ•´æ¡ˆä¾‹)
    - [8.1 å¯è§‚æµ‹æ€§å®Œæ•´é›†æˆ](#81-å¯è§‚æµ‹æ€§å®Œæ•´é›†æˆ)
  - [ğŸ“š å¯è§‚æµ‹æ€§æœ€ä½³å®è·µ](#-å¯è§‚æµ‹æ€§æœ€ä½³å®è·µ)
    - [è¿½è¸ª](#è¿½è¸ª)
    - [æŒ‡æ ‡](#æŒ‡æ ‡)
    - [æ—¥å¿—](#æ—¥å¿—)
    - [å‘Šè­¦](#å‘Šè­¦)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

## ğŸ“– æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£å±•ç¤ºGo 1.25.3çš„**åˆ†å¸ƒå¼è¿½è¸ªä¸å¯è§‚æµ‹æ€§å®Œæ•´æ–¹æ¡ˆ**ï¼Œæ„å»ºä¼ä¸šçº§ç›‘æ§ç³»ç»Ÿï¼š

- âœ… OpenTelemetryå®Œæ•´é›†æˆ
- âœ… åˆ†å¸ƒå¼è¿½è¸ª(Trace)
- âœ… æŒ‡æ ‡ç›‘æ§(Metrics)
- âœ… ç»“æ„åŒ–æ—¥å¿—(Logs)
- âœ… Jaeger/Zipkinè¿½è¸ª
- âœ… PrometheusæŒ‡æ ‡å¯¼å‡º
- âœ… æ€§èƒ½åˆ†æä¸å‘Šè­¦

---

## ç›®å½•

1. [OpenTelemetryåŸºç¡€](#opentelemetryåŸºç¡€)
2. [åˆ†å¸ƒ[åˆ†å¸ƒå¼è¿½è¸ª](#åˆ†å¸ƒå¼è¿½è¸ª). [æŒ‡æ ‡ç›‘æ§][æŒ‡æ ‡ç›‘æ§](#æŒ‡æ ‡ç›‘æ§)ç»“æ„åŒ–æ—¥å¿—](#[ç»“æ„åŒ–æ—¥å¿—](#ç»“æ„åŒ–æ—¥å¿—)ç«¯é›†æˆ](#5.[è¿½è¸ªåç«¯é›†æˆ](#è¿½è¸ªåç«¯é›†æˆ)#6.-æ€§èƒ½åˆ†æ[æ€§èƒ½åˆ†æ](#æ€§èƒ½åˆ†æ)-å‘Šè­¦ç³»ç»Ÿ)
[å‘Šè­¦ç³»ç»Ÿ](#å‘Šè­¦ç³»ç»Ÿ)æ¡ˆä¾‹)

-[å®Œæ•´æ¡ˆä¾‹](#å®Œæ•´æ¡ˆä¾‹)TelemetryåŸºç¡€

### 1.1 åˆå§‹åŒ–OpenTelemetry

```go
package observability

import (
 "context"
 "log"
 "time"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/exporters/jaeger"
 "go.opentelemetry.io/otel/exporters/prometheus"
 "go.opentelemetry.io/otel/metric"
 "go.opentelemetry.io/otel/propagation"
 "go.opentelemetry.io/otel/sdk/metric"
 "go.opentelemetry.io/otel/sdk/resource"
 "go.opentelemetry.io/otel/sdk/trace"
 semconv "go.opentelemetry.io/otel/semconv/v1.21.0"
)

// Config OpenTelemetryé…ç½®
type Config struct {
 ServiceName    string
 ServiceVersion string
 Environment    string
 JaegerEndpoint string
}

// InitOpenTelemetry åˆå§‹åŒ–OpenTelemetry
func InitOpenTelemetry(cfg *Config) (func(context.Context) error, error) {
 // 1. åˆ›å»ºèµ„æº
 res, err := resource.New(
  context.Background(),
  resource.WithAttributes(
   semconv.ServiceName(cfg.ServiceName),
   semconv.ServiceVersion(cfg.ServiceVersion),
   semconv.DeploymentEnvironment(cfg.Environment),
  ),
 )
 if err != nil {
  return nil, err
 }

 // 2. åˆå§‹åŒ–è¿½è¸ª
 tracerShutdown, err := initTracer(res, cfg.JaegerEndpoint)
 if err != nil {
  return nil, err
 }

 // 3. åˆå§‹åŒ–æŒ‡æ ‡
 meterShutdown, err := initMeter(res)
 if err != nil {
  tracerShutdown(context.Background())
  return nil, err
 }

 // 4. è®¾ç½®å…¨å±€ä¼ æ’­å™¨
 otel.SetTextMapPropagator(
  propagation.NewCompositeTextMapPropagator(
   propagation.TraceContext{},
   propagation.Baggage{},
  ),
 )

 // è¿”å›æ¸…ç†å‡½æ•°
 return func(ctx context.Context) error {
  if err := tracerShutdown(ctx); err != nil {
   return err
  }
  return meterShutdown(ctx)
 }, nil
}

// initTracer åˆå§‹åŒ–è¿½è¸ªå™¨
func initTracer(res *resource.Resource, endpoint string) (func(context.Context) error, error) {
 // åˆ›å»ºJaegerå¯¼å‡ºå™¨
 exp, err := jaeger.New(jaeger.WithCollectorEndpoint(jaeger.WithEndpoint(endpoint)))
 if err != nil {
  return nil, err
 }

 // åˆ›å»ºè¿½è¸ªæä¾›è€…
 tp := trace.NewTracerProvider(
  trace.WithBatcher(exp,
   trace.WithBatchTimeout(5*time.Second),
   trace.WithMaxExportBatchSize(512),
  ),
  trace.WithResource(res),
  trace.WithSampler(trace.TraceIDRatioBased(1.0)), // é‡‡æ ·ç‡100%
 )

 otel.SetTracerProvider(tp)

 return tp.Shutdown, nil
}

// initMeter åˆå§‹åŒ–åº¦é‡å™¨
func initMeter(res *resource.Resource) (func(context.Context) error, error) {
 // åˆ›å»ºPrometheuså¯¼å‡ºå™¨
 exporter, err := prometheus.New()
 if err != nil {
  return nil, err
 }

 // åˆ›å»ºåº¦é‡æä¾›è€…
 mp := metric.NewMeterProvider(
  metric.WithReader(exporter),
  metric.WithResource(res),
 )

 otel.SetMeterProvider(mp)

 return mp.Shutdown, nil
}
```

---

## 2. åˆ†å¸ƒå¼è¿½è¸ª

### 2.1 HTTPè¿½è¸ªä¸­é—´ä»¶

```go
package tracing

import (
 "fmt"
 "net/http"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/codes"
 "go.opentelemetry.io/otel/propagation"
 "go.opentelemetry.io/otel/trace"
)

// HTTPTracing HTTPè¿½è¸ªä¸­é—´ä»¶
func HTTPTracing(serviceName string) func(http.Handler) http.Handler {
 tracer := otel.Tracer(serviceName)
 propagator := otel.GetTextMapPropagator()

 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   // ä»è¯·æ±‚å¤´ä¸­æå–ä¸Šä¸‹æ–‡
   ctx := propagator.Extract(r.Context(), propagation.HeaderCarrier(r.Header))

   // å¼€å§‹span
   ctx, span := tracer.Start(ctx, fmt.Sprintf("%s %s", r.Method, r.URL.Path),
    trace.WithSpanKind(trace.SpanKindServer),
    trace.WithAttributes(
     attribute.String("http.method", r.Method),
     attribute.String("http.url", r.URL.String()),
     attribute.String("http.scheme", r.URL.Scheme),
     attribute.String("http.host", r.Host),
     attribute.String("http.user_agent", r.UserAgent()),
     attribute.String("http.client_ip", r.RemoteAddr),
    ),
   )
   defer span.End()

   // åˆ›å»ºå“åº”è®°å½•å™¨
   recorder := &statusRecorder{
    ResponseWriter: w,
    statusCode:     http.StatusOK,
   }

   // å¤„ç†è¯·æ±‚
   next.ServeHTTP(recorder, r.WithContext(ctx))

   // è®°å½•å“åº”ä¿¡æ¯
   span.SetAttributes(
    attribute.Int("http.status_code", recorder.statusCode),
   )

   // å¦‚æœæ˜¯é”™è¯¯çŠ¶æ€ç ï¼Œè®°å½•ä¸ºé”™è¯¯
   if recorder.statusCode >= 400 {
    span.SetStatus(codes.Error, http.StatusText(recorder.statusCode))
   }
  })
 }
}

type statusRecorder struct {
 http.ResponseWriter
 statusCode int
}

func (sr *statusRecorder) WriteHeader(code int) {
 sr.statusCode = code
 sr.ResponseWriter.WriteHeader(code)
}
```

---

### 2.2 æ•°æ®åº“è¿½è¸ª

```go
package tracing

import (
 "context"
 "database/sql"
 "time"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/codes"
 "go.opentelemetry.io/otel/trace"
)

// TracedDB å¸¦è¿½è¸ªçš„æ•°æ®åº“
type TracedDB struct {
 *sql.DB
 tracer trace.Tracer
}

// NewTracedDB åˆ›å»ºå¸¦è¿½è¸ªçš„æ•°æ®åº“
func NewTracedDB(db *sql.DB, serviceName string) *TracedDB {
 return &TracedDB{
  DB:     db,
  tracer: otel.Tracer(serviceName),
 }
}

// QueryContext å¸¦è¿½è¸ªçš„æŸ¥è¯¢
func (tdb *TracedDB) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
 ctx, span := tdb.tracer.Start(ctx, "db.query",
  trace.WithSpanKind(trace.SpanKindClient),
  trace.WithAttributes(
   attribute.String("db.system", "mysql"),
   attribute.String("db.statement", query),
  ),
 )
 defer span.End()

 start := time.Now()
 rows, err := tdb.DB.QueryContext(ctx, query, args...)
 duration := time.Since(start)

 span.SetAttributes(
  attribute.Int64("db.duration_ms", duration.Milliseconds()),
 )

 if err != nil {
  span.RecordError(err)
  span.SetStatus(codes.Error, err.Error())
 }

 return rows, err
}

// ExecContext å¸¦è¿½è¸ªçš„æ‰§è¡Œ
func (tdb *TracedDB) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
 ctx, span := tdb.tracer.Start(ctx, "db.exec",
  trace.WithSpanKind(trace.SpanKindClient),
  trace.WithAttributes(
   attribute.String("db.system", "mysql"),
   attribute.String("db.statement", query),
  ),
 )
 defer span.End()

 start := time.Now()
 result, err := tdb.DB.ExecContext(ctx, query, args...)
 duration := time.Since(start)

 span.SetAttributes(
  attribute.Int64("db.duration_ms", duration.Milliseconds()),
 )

 if err != nil {
  span.RecordError(err)
  span.SetStatus(codes.Error, err.Error())
 }

 return result, err
}
```

---

### 2.3 gRPCè¿½è¸ª

```go
package tracing

import (
 "context"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/codes"
 "go.opentelemetry.io/otel/trace"
 "google.golang.org/grpc"
 "google.golang.org/grpc/metadata"
 "google.golang.org/grpc/status"
)

// UnaryServerInterceptor gRPCæœåŠ¡ç«¯è¿½è¸ªæ‹¦æˆªå™¨
func UnaryServerInterceptor(serviceName string) grpc.UnaryServerInterceptor {
 tracer := otel.Tracer(serviceName)
 propagator := otel.GetTextMapPropagator()

 return func(
  ctx context.Context,
  req interface{},
  info *grpc.UnaryServerInfo,
  handler grpc.UnaryHandler,
 ) (interface{}, error) {
  // ä»metadataä¸­æå–ä¸Šä¸‹æ–‡
  md, _ := metadata.FromIncomingContext(ctx)
  ctx = propagator.Extract(ctx, &metadataCarrier{md})

  // å¼€å§‹span
  ctx, span := tracer.Start(ctx, info.FullMethod,
   trace.WithSpanKind(trace.SpanKindServer),
   trace.WithAttributes(
    attribute.String("rpc.system", "grpc"),
    attribute.String("rpc.service", info.FullMethod),
   ),
  )
  defer span.End()

  // è°ƒç”¨handler
  resp, err := handler(ctx, req)

  // è®°å½•é”™è¯¯
  if err != nil {
   span.RecordError(err)
   span.SetStatus(codes.Error, err.Error())

   // è®°å½•gRPCçŠ¶æ€ç 
   st, _ := status.FromError(err)
   span.SetAttributes(
    attribute.Int("rpc.grpc.status_code", int(st.Code())),
   )
  }

  return resp, err
 }
}

// UnaryClientInterceptor gRPCå®¢æˆ·ç«¯è¿½è¸ªæ‹¦æˆªå™¨
func UnaryClientInterceptor(serviceName string) grpc.UnaryClientInterceptor {
 tracer := otel.Tracer(serviceName)
 propagator := otel.GetTextMapPropagator()

 return func(
  ctx context.Context,
  method string,
  req, reply interface{},
  cc *grpc.ClientConn,
  invoker grpc.UnaryInvoker,
  opts ...grpc.CallOption,
 ) error {
  // å¼€å§‹span
  ctx, span := tracer.Start(ctx, method,
   trace.WithSpanKind(trace.SpanKindClient),
   trace.WithAttributes(
    attribute.String("rpc.system", "grpc"),
    attribute.String("rpc.service", method),
   ),
  )
  defer span.End()

  // æ³¨å…¥ä¸Šä¸‹æ–‡åˆ°metadata
  md, ok := metadata.FromOutgoingContext(ctx)
  if !ok {
   md = metadata.New(nil)
  }
  propagator.Inject(ctx, &metadataCarrier{md})
  ctx = metadata.NewOutgoingContext(ctx, md)

  // è°ƒç”¨RPC
  err := invoker(ctx, method, req, reply, cc, opts...)

  if err != nil {
   span.RecordError(err)
   span.SetStatus(codes.Error, err.Error())
  }

  return err
 }
}

// metadataCarrier gRPC metadataè½½ä½“
type metadataCarrier struct {
 md metadata.MD
}

func (mc *metadataCarrier) Get(key string) string {
 values := mc.md.Get(key)
 if len(values) == 0 {
  return ""
 }
 return values[0]
}

func (mc *metadataCarrier) Set(key, value string) {
 mc.md.Set(key, value)
}

func (mc *metadataCarrier) Keys() []string {
 keys := make([]string, 0, len(mc.md))
 for k := range mc.md {
  keys = append(keys, k)
 }
 return keys
}
```

---

## 3. æŒ‡æ ‡ç›‘æ§

### 3.1 ä¸šåŠ¡æŒ‡æ ‡

```go
package metrics

import (
 "context"
 "time"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/metric"
)

// Metrics æŒ‡æ ‡æ”¶é›†å™¨
type Metrics struct {
 requestCounter  metric.Int64Counter
 requestDuration metric.Float64Histogram
 activeRequests  metric.Int64UpDownCounter
 errorCounter    metric.Int64Counter
}

// NewMetrics åˆ›å»ºæŒ‡æ ‡æ”¶é›†å™¨
func NewMetrics(serviceName string) (*Metrics, error) {
 meter := otel.Meter(serviceName)

 // è¯·æ±‚è®¡æ•°å™¨
 requestCounter, err := meter.Int64Counter(
  "http.server.request.count",
  metric.WithDescription("Total number of HTTP requests"),
  metric.WithUnit("1"),
 )
 if err != nil {
  return nil, err
 }

 // è¯·æ±‚æ—¶é•¿ç›´æ–¹å›¾
 requestDuration, err := meter.Float64Histogram(
  "http.server.request.duration",
  metric.WithDescription("HTTP request duration"),
  metric.WithUnit("ms"),
 )
 if err != nil {
  return nil, err
 }

 // æ´»è·ƒè¯·æ±‚è®¡æ•°
 activeRequests, err := meter.Int64UpDownCounter(
  "http.server.active_requests",
  metric.WithDescription("Number of active HTTP requests"),
  metric.WithUnit("1"),
 )
 if err != nil {
  return nil, err
 }

 // é”™è¯¯è®¡æ•°å™¨
 errorCounter, err := meter.Int64Counter(
  "http.server.error.count",
  metric.WithDescription("Total number of HTTP errors"),
  metric.WithUnit("1"),
 )
 if err != nil {
  return nil, err
 }

 return &Metrics{
  requestCounter:  requestCounter,
  requestDuration: requestDuration,
  activeRequests:  activeRequests,
  errorCounter:    errorCounter,
 }, nil
}

// RecordRequest è®°å½•è¯·æ±‚
func (m *Metrics) RecordRequest(ctx context.Context, method, path string, statusCode int, duration time.Duration) {
 attrs := []attribute.KeyValue{
  attribute.String("http.method", method),
  attribute.String("http.path", path),
  attribute.Int("http.status_code", statusCode),
 }

 // å¢åŠ è¯·æ±‚è®¡æ•°
 m.requestCounter.Add(ctx, 1, metric.WithAttributes(attrs...))

 // è®°å½•è¯·æ±‚æ—¶é•¿
 m.requestDuration.Record(ctx, float64(duration.Milliseconds()), metric.WithAttributes(attrs...))

 // è®°å½•é”™è¯¯
 if statusCode >= 400 {
  m.errorCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
 }
}

// IncActiveRequests å¢åŠ æ´»è·ƒè¯·æ±‚
func (m *Metrics) IncActiveRequests(ctx context.Context) {
 m.activeRequests.Add(ctx, 1)
}

// DecActiveRequests å‡å°‘æ´»è·ƒè¯·æ±‚
func (m *Metrics) DecActiveRequests(ctx context.Context) {
 m.activeRequests.Add(ctx, -1)
}

// MetricsMiddleware æŒ‡æ ‡ä¸­é—´ä»¶
func MetricsMiddleware(metrics *Metrics) func(http.Handler) http.Handler {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   ctx := r.Context()

   // å¢åŠ æ´»è·ƒè¯·æ±‚
   metrics.IncActiveRequests(ctx)
   defer metrics.DecActiveRequests(ctx)

   // è®°å½•å¼€å§‹æ—¶é—´
   start := time.Now()

   // åˆ›å»ºå“åº”è®°å½•å™¨
   recorder := &statusRecorder{
    ResponseWriter: w,
    statusCode:     http.StatusOK,
   }

   // å¤„ç†è¯·æ±‚
   next.ServeHTTP(recorder, r)

   // è®°å½•æŒ‡æ ‡
   metrics.RecordRequest(ctx, r.Method, r.URL.Path, recorder.statusCode, time.Since(start))
  })
 }
}
```

---

### 3.2 ç³»ç»ŸæŒ‡æ ‡

```go
package metrics

import (
 "context"
 "runtime"
 "time"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/metric"
)

// SystemMetrics ç³»ç»ŸæŒ‡æ ‡
type SystemMetrics struct {
 goroutineCount metric.Int64ObservableGauge
 memoryUsage    metric.Int64ObservableGauge
 gcCount        metric.Int64ObservableCounter
}

// NewSystemMetrics åˆ›å»ºç³»ç»ŸæŒ‡æ ‡
func NewSystemMetrics(serviceName string) (*SystemMetrics, error) {
 meter := otel.Meter(serviceName)

 sm := &SystemMetrics{}

 // Goroutineæ•°é‡
 goroutineCount, err := meter.Int64ObservableGauge(
  "runtime.go.goroutines",
  metric.WithDescription("Number of goroutines"),
 )
 if err != nil {
  return nil, err
 }
 sm.goroutineCount = goroutineCount

 // å†…å­˜ä½¿ç”¨
 memoryUsage, err := meter.Int64ObservableGauge(
  "runtime.go.mem.heap_alloc",
  metric.WithDescription("Heap memory allocated"),
  metric.WithUnit("By"),
 )
 if err != nil {
  return nil, err
 }
 sm.memoryUsage = memoryUsage

 // GCæ¬¡æ•°
 gcCount, err := meter.Int64ObservableCounter(
  "runtime.go.gc.count",
  metric.WithDescription("Number of completed GC cycles"),
 )
 if err != nil {
  return nil, err
 }
 sm.gcCount = gcCount

 // æ³¨å†Œå›è°ƒ
 _, err = meter.RegisterCallback(
  func(ctx context.Context, o metric.Observer) error {
   // Goroutineæ•°é‡
   o.ObserveInt64(goroutineCount, int64(runtime.NumGoroutine()))

   // å†…å­˜ä½¿ç”¨
   var m runtime.MemStats
   runtime.ReadMemStats(&m)
   o.ObserveInt64(memoryUsage, int64(m.HeapAlloc))
   o.ObserveInt64(gcCount, int64(m.NumGC))

   return nil
  },
  goroutineCount,
  memoryUsage,
  gcCount,
 )

 return sm, err
}
```

---

## 4. ç»“æ„åŒ–æ—¥å¿—

### 4.1 ç»“æ„åŒ–æ—¥å¿—è®°å½•å™¨

```go
package logging

import (
 "context"
 "log/slog"
 "os"

 "go.opentelemetry.io/otel/trace"
)

// Logger ç»“æ„åŒ–æ—¥å¿—è®°å½•å™¨
type Logger struct {
 *slog.Logger
}

// NewLogger åˆ›å»ºæ—¥å¿—è®°å½•å™¨
func NewLogger(serviceName, environment string) *Logger {
 handler := slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
  Level: slog.LevelInfo,
 })

 logger := slog.New(handler).With(
  slog.String("service", serviceName),
  slog.String("environment", environment),
 )

 return &Logger{Logger: logger}
}

// WithTrace æ·»åŠ è¿½è¸ªä¿¡æ¯
func (l *Logger) WithTrace(ctx context.Context) *slog.Logger {
 span := trace.SpanFromContext(ctx)
 if !span.IsRecording() {
  return l.Logger
 }

 spanCtx := span.SpanContext()
 return l.Logger.With(
  slog.String("trace_id", spanCtx.TraceID().String()),
  slog.String("span_id", spanCtx.SpanID().String()),
 )
}

// InfoCtx å¸¦ä¸Šä¸‹æ–‡çš„Infoæ—¥å¿—
func (l *Logger) InfoCtx(ctx context.Context, msg string, args ...any) {
 l.WithTrace(ctx).Info(msg, args...)
}

// ErrorCtx å¸¦ä¸Šä¸‹æ–‡çš„Erroræ—¥å¿—
func (l *Logger) ErrorCtx(ctx context.Context, msg string, args ...any) {
 l.WithTrace(ctx).Error(msg, args...)
}

// WarnCtx å¸¦ä¸Šä¸‹æ–‡çš„Warnæ—¥å¿—
func (l *Logger) WarnCtx(ctx context.Context, msg string, args ...any) {
 l.WithTrace(ctx).Warn(msg, args...)
}

// DebugCtx å¸¦ä¸Šä¸‹æ–‡çš„Debugæ—¥å¿—
func (l *Logger) DebugCtx(ctx context.Context, msg string, args ...any) {
 l.WithTrace(ctx).Debug(msg, args...)
}
```

---

## 5. è¿½è¸ªåç«¯é›†æˆ

### 5.1 Jaegeré›†æˆ

```go
package observability

import (
 "go.opentelemetry.io/otel/exporters/jaeger"
 "go.opentelemetry.io/otel/sdk/trace"
)

// NewJaegerExporter åˆ›å»ºJaegerå¯¼å‡ºå™¨
func NewJaegerExporter(endpoint string) (trace.SpanExporter, error) {
 return jaeger.New(
  jaeger.WithCollectorEndpoint(
   jaeger.WithEndpoint(endpoint),
  ),
 )
}
```

---

### 5.2 Zipkiné›†æˆ

```go
package observability

import (
 "go.opentelemetry.io/otel/exporters/zipkin"
 "go.opentelemetry.io/otel/sdk/trace"
)

// NewZipkinExporter åˆ›å»ºZipkinå¯¼å‡ºå™¨
func NewZipkinExporter(endpoint string) (trace.SpanExporter, error) {
 return zipkin.New(endpoint)
}
```

---

## 6. æ€§èƒ½åˆ†æ

### 6.1 æ€§èƒ½å‰–æ

```go
package profiling

import (
 "context"
 "net/http"
 "net/http/pprof"
 "runtime"
 "time"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/trace"
)

// EnableProfiling å¯ç”¨æ€§èƒ½å‰–æ
func EnableProfiling(mux *http.ServeMux) {
 mux.HandleFunc("/debug/pprof/", pprof.Index)
 mux.HandleFunc("/debug/pprof/cmdline", pprof.Cmdline)
 mux.HandleFunc("/debug/pprof/profile", pprof.Profile)
 mux.HandleFunc("/debug/pprof/symbol", pprof.Symbol)
 mux.HandleFunc("/debug/pprof/trace", pprof.Trace)
}

// ProfiledFunction å¸¦æ€§èƒ½åˆ†æçš„å‡½æ•°åŒ…è£…
func ProfiledFunction(ctx context.Context, name string, fn func() error) error {
 tracer := otel.Tracer("profiling")

 // å¼€å§‹span
 ctx, span := tracer.Start(ctx, name,
  trace.WithAttributes(
   attribute.String("function", name),
  ),
 )
 defer span.End()

 // è®°å½•å¼€å§‹æ—¶çš„å†…å­˜çŠ¶æ€
 var m1 runtime.MemStats
 runtime.ReadMemStats(&m1)

 start := time.Now()

 // æ‰§è¡Œå‡½æ•°
 err := fn()

 duration := time.Since(start)

 // è®°å½•ç»“æŸæ—¶çš„å†…å­˜çŠ¶æ€
 var m2 runtime.MemStats
 runtime.ReadMemStats(&m2)

 // è®°å½•æ€§èƒ½æŒ‡æ ‡
 span.SetAttributes(
  attribute.Int64("duration_ms", duration.Milliseconds()),
  attribute.Int64("alloc_bytes", int64(m2.Alloc-m1.Alloc)),
  attribute.Int64("total_alloc_bytes", int64(m2.TotalAlloc-m1.TotalAlloc)),
 )

 if err != nil {
  span.RecordError(err)
 }

 return err
}
```

---

## 7. å‘Šè­¦ç³»ç»Ÿ

### 7.1 å‘Šè­¦è§„åˆ™

```go
package alerting

import (
 "context"
 "fmt"
 "sync"
 "time"
)

// AlertManager å‘Šè­¦ç®¡ç†å™¨
type AlertManager struct {
 rules    []AlertRule
 notifier Notifier
 mu       sync.RWMutex
}

// AlertRule å‘Šè­¦è§„åˆ™
type AlertRule struct {
 Name        string
 Description string
 Condition   func(ctx context.Context) (bool, string)
 Severity    Severity
 Cooldown    time.Duration
 lastFired   time.Time
}

// Severity ä¸¥é‡ç¨‹åº¦
type Severity int

const (
 SeverityInfo Severity = iota
 SeverityWarning
 SeverityError
 SeverityCritical
)

// Notifier é€šçŸ¥å™¨æ¥å£
type Notifier interface {
 Notify(ctx context.Context, alert *Alert) error
}

// Alert å‘Šè­¦
type Alert struct {
 RuleName    string
 Description string
 Message     string
 Severity    Severity
 Timestamp   time.Time
}

// NewAlertManager åˆ›å»ºå‘Šè­¦ç®¡ç†å™¨
func NewAlertManager(notifier Notifier) *AlertManager {
 return &AlertManager{
  rules:    make([]AlertRule, 0),
  notifier: notifier,
 }
}

// AddRule æ·»åŠ å‘Šè­¦è§„åˆ™
func (am *AlertManager) AddRule(rule AlertRule) {
 am.mu.Lock()
 defer am.mu.Unlock()

 am.rules = append(am.rules, rule)
}

// Start å¯åŠ¨å‘Šè­¦æ£€æŸ¥
func (am *AlertManager) Start(ctx context.Context, checkInterval time.Duration) {
 ticker := time.NewTicker(checkInterval)
 defer ticker.Stop()

 for {
  select {
  case <-ticker.C:
   am.check(ctx)
  case <-ctx.Done():
   return
  }
 }
}

// check æ£€æŸ¥å‘Šè­¦è§„åˆ™
func (am *AlertManager) check(ctx context.Context) {
 am.mu.RLock()
 rules := make([]AlertRule, len(am.rules))
 copy(rules, am.rules)
 am.mu.RUnlock()

 for i := range rules {
  rule := &rules[i]

  // æ£€æŸ¥å†·å´æœŸ
  if time.Since(rule.lastFired) < rule.Cooldown {
   continue
  }

  // æ£€æŸ¥æ¡ä»¶
  triggered, message := rule.Condition(ctx)
  if !triggered {
   continue
  }

  // å‘é€å‘Šè­¦
  alert := &Alert{
   RuleName:    rule.Name,
   Description: rule.Description,
   Message:     message,
   Severity:    rule.Severity,
   Timestamp:   time.Now(),
  }

  if err := am.notifier.Notify(ctx, alert); err != nil {
   fmt.Printf("Failed to send alert: %v\n", err)
  }

  // æ›´æ–°æœ€åè§¦å‘æ—¶é—´
  am.mu.Lock()
  for j := range am.rules {
   if am.rules[j].Name == rule.Name {
    am.rules[j].lastFired = time.Now()
    break
   }
  }
  am.mu.Unlock()
 }
}
```

---

### 7.2 å‘Šè­¦é€šçŸ¥

```go
// EmailNotifier é‚®ä»¶é€šçŸ¥å™¨
type EmailNotifier struct {
 smtpHost string
 smtpPort int
 from     string
 to       []string
}

// Notify å‘é€é€šçŸ¥
func (en *EmailNotifier) Notify(ctx context.Context, alert *Alert) error {
 subject := fmt.Sprintf("[%s] %s", alert.Severity, alert.RuleName)
 body := fmt.Sprintf(
  "Alert: %s\nDescription: %s\nMessage: %s\nTime: %s",
  alert.RuleName,
  alert.Description,
  alert.Message,
  alert.Timestamp.Format(time.RFC3339),
 )

 // å‘é€é‚®ä»¶çš„å®ç°...
 fmt.Printf("Sending email alert: %s\n", subject)

 return nil
}

// WebhookNotifier Webhooké€šçŸ¥å™¨
type WebhookNotifier struct {
 url string
}

// Notify å‘é€é€šçŸ¥
func (wn *WebhookNotifier) Notify(ctx context.Context, alert *Alert) error {
 // å‘é€HTTPè¯·æ±‚åˆ°Webhook
 // ...
 fmt.Printf("Sending webhook notification to %s\n", wn.url)

 return nil
}
```

---

## 8. å®Œæ•´æ¡ˆä¾‹

### 8.1 å¯è§‚æµ‹æ€§å®Œæ•´é›†æˆ

```go
package main

import (
 "context"
 "log"
 "net/http"
 "time"
)

func main() {
 ctx := context.Background()

 // 1. åˆå§‹åŒ–OpenTelemetry
 shutdown, err := observability.InitOpenTelemetry(&observability.Config{
  ServiceName:    "my-service",
  ServiceVersion: "1.0.0",
  Environment:    "production",
  JaegerEndpoint: "http://localhost:14268/api/traces",
 })
 if err != nil {
  log.Fatal(err)
 }
 defer shutdown(ctx)

 // 2. åˆ›å»ºæ—¥å¿—è®°å½•å™¨
 logger := logging.NewLogger("my-service", "production")

 // 3. åˆ›å»ºæŒ‡æ ‡æ”¶é›†å™¨
 metrics, err := metrics.NewMetrics("my-service")
 if err != nil {
  log.Fatal(err)
 }

 // 4. åˆ›å»ºç³»ç»ŸæŒ‡æ ‡
 systemMetrics, err := metrics.NewSystemMetrics("my-service")
 if err != nil {
  log.Fatal(err)
 }
 _ = systemMetrics

 // 5. åˆ›å»ºå‘Šè­¦ç®¡ç†å™¨
 alertManager := alerting.NewAlertManager(&alerting.EmailNotifier{
  smtpHost: "smtp.example.com",
  smtpPort: 587,
  from:     "alerts@example.com",
  to:       []string{"admin@example.com"},
 })

 // æ·»åŠ å‘Šè­¦è§„åˆ™
 alertManager.AddRule(alerting.AlertRule{
  Name:        "high_error_rate",
  Description: "Error rate is too high",
  Condition: func(ctx context.Context) (bool, string) {
   // æ£€æŸ¥é”™è¯¯ç‡
   // ...
   return false, ""
  },
  Severity: alerting.SeverityWarning,
  Cooldown: 5 * time.Minute,
 })

 // å¯åŠ¨å‘Šè­¦æ£€æŸ¥
 go alertManager.Start(ctx, 1*time.Minute)

 // 6. åˆ›å»ºHTTPæœåŠ¡å™¨
 mux := http.NewServeMux()

 // ä¸šåŠ¡è·¯ç”±
 mux.HandleFunc("/api/users", func(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()

  logger.InfoCtx(ctx, "Handling request",
   "method", r.Method,
   "path", r.URL.Path,
  )

  // ä¸šåŠ¡é€»è¾‘...
  w.WriteHeader(http.StatusOK)
  w.Write([]byte(`{"status":"ok"}`))
 })

 // PrometheusæŒ‡æ ‡ç«¯ç‚¹
 mux.Handle("/metrics", promhttp.Handler())

 // pprofç«¯ç‚¹
 profiling.EnableProfiling(mux)

 // åº”ç”¨ä¸­é—´ä»¶
 handler := applyMiddleware(mux,
  tracing.HTTPTracing("my-service"),
  metrics.MetricsMiddleware(metrics),
  logging.LoggingMiddleware(logger),
 )

 // å¯åŠ¨æœåŠ¡å™¨
 server := &http.Server{
  Addr:    ":8080",
  Handler: handler,
 }

 log.Println("Server starting on :8080")
 log.Fatal(server.ListenAndServe())
}

func applyMiddleware(h http.Handler, middlewares ...func(http.Handler) http.Handler) http.Handler {
 for i := len(middlewares) - 1; i >= 0; i-- {
  h = middlewares[i](h)
 }
 return h
}
```

---

## ğŸ“š å¯è§‚æµ‹æ€§æœ€ä½³å®è·µ

### è¿½è¸ª

- âœ… ä½¿ç”¨OpenTelemetryæ ‡å‡†
- âœ… åˆç†è®¾ç½®é‡‡æ ·ç‡
- âœ… è®°å½•å…³é”®ä¸šåŠ¡æ“ä½œ
- âœ… ä¼ æ’­è¿½è¸ªä¸Šä¸‹æ–‡

### æŒ‡æ ‡

- âœ… ä½¿ç”¨æ ‡å‡†æŒ‡æ ‡å‘½å
- âœ… åˆç†è®¾ç½®ç›´æ–¹å›¾æ¡¶
- âœ… è®°å½•ä¸šåŠ¡å’Œç³»ç»ŸæŒ‡æ ‡
- âœ… å®šæœŸå¯¼å‡ºæŒ‡æ ‡

### æ—¥å¿—

- âœ… ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—
- âœ… å…³è”è¿½è¸ªID
- âœ… åˆç†è®¾ç½®æ—¥å¿—çº§åˆ«
- âœ… é¿å…æ•æ„Ÿä¿¡æ¯

### å‘Šè­¦

- âœ… è®¾ç½®åˆç†é˜ˆå€¼
- âœ… é¿å…å‘Šè­¦ç–²åŠ³
- âœ… å¤šæ¸ é“é€šçŸ¥
- âœ… å‘Šè­¦è‡ªæ„ˆæœºåˆ¶

---

## ğŸ¯ æ€»ç»“

Go 1.25.3å¯è§‚æµ‹æ€§å…³é”®ç‚¹ï¼š

1. **OpenTelemetry**: ç»Ÿä¸€æ ‡å‡†ã€Trace/Metrics/Logs
2. **åˆ†å¸ƒå¼è¿½è¸ª**: HTTP/gRPC/DBè¿½è¸ªã€ä¸Šä¸‹æ–‡ä¼ æ’­
3. **æŒ‡æ ‡ç›‘æ§**: ä¸šåŠ¡æŒ‡æ ‡ã€ç³»ç»ŸæŒ‡æ ‡ã€Prometheusé›†æˆ
4. **ç»“æ„åŒ–æ—¥å¿—**: slogã€è¿½è¸ªå…³è”ã€JSONæ ¼å¼
5. **åç«¯é›†æˆ**: Jaegerã€Zipkinã€Prometheusã€Grafana
6. **æ€§èƒ½åˆ†æ**: pprofã€å†…å­˜åˆ†æã€æ€§èƒ½åŒ…è£…
7. **å‘Šè­¦ç³»ç»Ÿ**: è§„åˆ™å¼•æ“ã€å¤šæ¸ é“é€šçŸ¥ã€å†·å´æœŸ

**å¯è§‚æµ‹æ€§æ˜¯ç³»ç»Ÿç¨³å®šè¿è¡Œçš„åŸºçŸ³ï¼**

---

<div align="center">

**æ„å»ºå…¨é¢å¯è§‚æµ‹çš„Goåº”ç”¨**:

[ğŸ“š è¿”å›ç›®å½•](../README.md) | [ğŸ“– ä¸‹ä¸€ç« ](24-ä¸‹ä¸€ä¸»é¢˜.md)

Made with â¤ï¸ for Go Developers

</div>

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2025-10-29
**Goç‰ˆæœ¬**: Go 1.25.3
**ç”Ÿäº§å°±ç»ª**: âœ…
