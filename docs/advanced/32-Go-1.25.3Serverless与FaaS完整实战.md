# Go 1.25.3 Serverless与FaaS完整实战

## 📋 目录


- [1. Serverless架构概述](#1.-serverless架构概述)
  - [1.1 核心概念](#1.1-核心概念)
  - [1.2 Go在Serverless中的优势](#1.2-go在serverless中的优势)
- [2. AWS Lambda实战](#2.-aws-lambda实战)
  - [2.1 Lambda函数结构](#2.1-lambda函数结构)
  - [2.2 S3事件处理](#2.2-s3事件处理)
  - [2.3 DynamoDB Stream处理](#2.3-dynamodb-stream处理)
  - [2.4 定时任务 (CloudWatch Events/EventBridge)](#2.4-定时任务-cloudwatch-eventseventbridge)
  - [2.5 部署配置](#2.5-部署配置)
- [3. Knative Serverless平台](#3.-knative-serverless平台)
  - [3.1 Knative Service部署](#3.1-knative-service部署)
  - [3.2 Knative Eventing (事件驱动)](#3.2-knative-eventing-事件驱动)
- [4. Google Cloud Functions](#4.-google-cloud-functions)
  - [4.1 HTTP Cloud Function](#4.1-http-cloud-function)
  - [4.2 Cloud Storage触发](#4.2-cloud-storage触发)
  - [4.3 Pub/Sub触发](#4.3-pubsub触发)
- [5. 事件驱动架构](#5.-事件驱动架构)
  - [5.1 事件总线模式](#5.1-事件总线模式)
  - [5.2 消息队列集成](#5.2-消息队列集成)
- [6. 冷启动优化](#6.-冷启动优化)
  - [6.1 冷启动分析](#6.1-冷启动分析)
  - [6.2 优化技巧](#6.2-优化技巧)
  - [6.3 Provisioned Concurrency](#6.3-provisioned-concurrency)
- [7. 成本优化](#7.-成本优化)
  - [7.1 成本计算](#7.1-成本计算)
  - [7.2 成本监控](#7.2-成本监控)
- [8. 监控与调试](#8.-监控与调试)
  - [8.1 结构化日志](#8.1-结构化日志)
  - [8.2 分布式追踪](#8.2-分布式追踪)
  - [8.3 错误处理与重试](#8.3-错误处理与重试)
- [9. 最佳实践](#9.-最佳实践)
  - [9.1 安全最佳实践](#9.1-安全最佳实践)
  - [9.2 性能最佳实践](#9.2-性能最佳实践)
- [10. 完整项目示例](#10.-完整项目示例)
  - [10.1 项目结构](#10.1-项目结构)
  - [10.2 上传API](#10.2-上传api)
  - [10.3 图片处理函数](#10.3-图片处理函数)
  - [10.4 完整Serverless配置](#10.4-完整serverless配置)
  - [10.5 性能监控Dashboard](#10.5-性能监控dashboard)
- [总结](#总结)
  - [Serverless架构演进路径](#serverless架构演进路径)
  - [关键要点](#关键要点)
  - [适用场景](#适用场景)

## 1. Serverless架构概述

### 1.1 核心概念

```go
// Serverless架构定义
/*
Serverless = FaaS + BaaS

FaaS (Function as a Service):
  • 事件驱动的函数执行
  • 自动伸缩 (Scale to Zero)
  • 按需计费 (Pay per Use)
  • 无服务器管理

BaaS (Backend as a Service):
  • 托管数据库 (DynamoDB, Firestore)
  • 托管存储 (S3, Cloud Storage)
  • 托管认证 (Cognito, Auth0)
  • 托管API (API Gateway)

核心优势:
  ✅ 无需管理服务器
  ✅ 自动弹性伸缩
  ✅ 高可用性保证
  ✅ 按使用量计费
  ✅ 快速迭代部署

适用场景:
  • Web API后端
  • 数据处理管道
  • 定时任务 (Cron Jobs)
  • 事件响应 (S3上传, DB变更)
  • 微服务架构
*/

// Serverless架构对比
type ServerlessComparison struct {
 Traditional struct {
  Server      string // "需要管理EC2/VM"
  Scaling     string // "手动配置Auto Scaling"
  Billing     string // "按小时计费"
  Maintenance string // "需要OS补丁/安全更新"
  MinCost     string // "至少1台服务器运行"
 }
 
 Serverless struct {
  Server      string // "无需管理"
  Scaling     string // "自动伸缩到0"
  Billing     string // "按毫秒+请求数计费"
  Maintenance string // "云厂商负责"
  MinCost     string // "无流量时0成本"
 }
}
```

### 1.2 Go在Serverless中的优势

```go
// Go语言在Serverless场景的优势
/*
1. 启动速度快 ⚡
   • 编译型语言,启动时间 < 10ms
   • 对比: Node.js ~100ms, Python ~200ms, Java ~1000ms
   • 减少冷启动延迟

2. 内存占用小 💾
   • Go函数典型内存: 10-50MB
   • 对比: Java 128MB+, .NET 256MB+
   • 降低运行成本

3. 并发性能强 🚀
   • Goroutine轻量级并发
   • 内置channel通信
   • 适合高并发场景

4. 单一二进制 📦
   • 无依赖部署
   • 无需打包node_modules
   • 部署包更小

5. 强类型安全 🛡️
   • 编译时错误检查
   • 减少运行时错误
   • 提高稳定性

性能对比 (AWS Lambda):
  Go:      冷启动 50ms,  内存 20MB
  Node.js: 冷启动 150ms, 内存 40MB
  Python:  冷启动 250ms, 内存 50MB
  Java:    冷启动 2000ms, 内存 128MB
*/
```

---

## 2. AWS Lambda实战

### 2.1 Lambda函数结构

```go
package main

import (
 "context"
 "encoding/json"
 "fmt"
 "github.com/aws/aws-lambda-go/events"
 "github.com/aws/aws-lambda-go/lambda"
)

// Lambda函数基本结构
/*
Go Lambda函数签名:
  • func()
  • func() error
  • func(TIn) error
  • func() (TOut, error)
  • func(TIn) (TOut, error)
  • func(context.Context) error
  • func(context.Context, TIn) error
  • func(context.Context) (TOut, error)
  • func(context.Context, TIn) (TOut, error)

常用: func(context.Context, TIn) (TOut, error)
*/

// 1. 简单HTTP API处理
func HandleAPIRequest(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
 // 解析请求
 var input struct {
  Name string `json:"name"`
 }
 
 if err := json.Unmarshal([]byte(request.Body), &input); err != nil {
  return events.APIGatewayProxyResponse{
   StatusCode: 400,
   Body:       `{"error": "Invalid JSON"}`,
   Headers: map[string]string{
    "Content-Type": "application/json",
   },
  }, nil
 }
 
 // 业务逻辑
 message := fmt.Sprintf("Hello, %s!", input.Name)
 
 // 返回响应
 responseBody, _ := json.Marshal(map[string]string{
  "message": message,
 })
 
 return events.APIGatewayProxyResponse{
  StatusCode: 200,
  Body:       string(responseBody),
  Headers: map[string]string{
   "Content-Type": "application/json",
   "Access-Control-Allow-Origin": "*",
  },
 }, nil
}

func main() {
 lambda.Start(HandleAPIRequest)
}
```

### 2.2 S3事件处理

```go
package main

import (
 "context"
 "fmt"
 "github.com/aws/aws-lambda-go/events"
 "github.com/aws/aws-lambda-go/lambda"
 "github.com/aws/aws-sdk-go-v2/config"
 "github.com/aws/aws-sdk-go-v2/service/s3"
)

// S3事件触发的Lambda函数
func HandleS3Event(ctx context.Context, s3Event events.S3Event) error {
 // 加载AWS配置
 cfg, err := config.LoadDefaultConfig(ctx)
 if err != nil {
  return fmt.Errorf("load config: %w", err)
 }
 
 s3Client := s3.NewFromConfig(cfg)
 
 // 处理每个S3记录
 for _, record := range s3Event.Records {
  bucket := record.S3.Bucket.Name
  key := record.S3.Object.Key
  eventName := record.EventName
  
  fmt.Printf("Event: %s, Bucket: %s, Key: %s\n", eventName, bucket, key)
  
  // 根据事件类型处理
  switch {
  case record.EventName[:12] == "ObjectCreated":
   // 对象创建事件
   if err := processNewObject(ctx, s3Client, bucket, key); err != nil {
    return err
   }
   
  case record.EventName[:12] == "ObjectRemoved":
   // 对象删除事件
   fmt.Printf("Object removed: %s/%s\n", bucket, key)
  }
 }
 
 return nil
}

// 处理新上传的对象
func processNewObject(ctx context.Context, client *s3.Client, bucket, key string) error {
 // 获取对象
 result, err := client.GetObject(ctx, &s3.GetObjectInput{
  Bucket: &bucket,
  Key:    &key,
 })
 if err != nil {
  return fmt.Errorf("get object: %w", err)
 }
 defer result.Body.Close()
 
 // 处理对象内容
 // 示例: 生成缩略图、转换格式、提取元数据等
 fmt.Printf("Processing object: %s/%s (Size: %d bytes)\n", bucket, key, result.ContentLength)
 
 return nil
}

func main() {
 lambda.Start(HandleS3Event)
}
```

### 2.3 DynamoDB Stream处理

```go
package main

import (
 "context"
 "fmt"
 "github.com/aws/aws-lambda-go/events"
 "github.com/aws/aws-lambda-go/lambda"
)

// DynamoDB Stream事件处理
func HandleDynamoDBStream(ctx context.Context, event events.DynamoDBEvent) error {
 for _, record := range event.Records {
  fmt.Printf("Event: %s, EventID: %s\n", record.EventName, record.EventID)
  
  switch record.EventName {
  case "INSERT":
   // 新记录插入
   newImage := record.Change.NewImage
   fmt.Printf("New item: %v\n", newImage)
   
   // 示例: 发送欢迎邮件
   if email, ok := newImage["email"]; ok {
    sendWelcomeEmail(email.String())
   }
   
  case "MODIFY":
   // 记录修改
   oldImage := record.Change.OldImage
   newImage := record.Change.NewImage
   fmt.Printf("Updated: %v -> %v\n", oldImage, newImage)
   
  case "REMOVE":
   // 记录删除
   oldImage := record.Change.OldImage
   fmt.Printf("Deleted item: %v\n", oldImage)
  }
 }
 
 return nil
}

func sendWelcomeEmail(email string) {
 fmt.Printf("Sending welcome email to: %s\n", email)
 // 实际实现: 调用SES发送邮件
}

func main() {
 lambda.Start(HandleDynamoDBStream)
}
```

### 2.4 定时任务 (CloudWatch Events/EventBridge)

```go
package main

import (
 "context"
 "fmt"
 "github.com/aws/aws-lambda-go/events"
 "github.com/aws/aws-lambda-go/lambda"
 "time"
)

// 定时触发的Lambda函数
// 示例: 每天凌晨1点清理过期数据
func HandleScheduledEvent(ctx context.Context, event events.CloudWatchEvent) error {
 fmt.Printf("Scheduled event triggered at: %s\n", event.Time)
 
 // 执行定时任务
 if err := cleanupExpiredData(ctx); err != nil {
  return fmt.Errorf("cleanup failed: %w", err)
 }
 
 fmt.Println("Cleanup completed successfully")
 return nil
}

func cleanupExpiredData(ctx context.Context) error {
 // 示例: 删除30天前的旧数据
 cutoffDate := time.Now().AddDate(0, 0, -30)
 fmt.Printf("Cleaning up data older than: %s\n", cutoffDate.Format("2006-01-02"))
 
 // 实际实现: 查询并删除DynamoDB/RDS中的过期记录
 // ...
 
 return nil
}

func main() {
 lambda.Start(HandleScheduledEvent)
}
```

### 2.5 部署配置

```yaml
# serverless.yml (Serverless Framework)
service: go-lambda-service

provider:
  name: aws
  runtime: go1.x
  region: us-east-1
  stage: ${opt:stage, 'dev'}
  memorySize: 256
  timeout: 30
  
  environment:
    STAGE: ${self:provider.stage}
    TABLE_NAME: ${self:custom.tableName}
  
  iam:
    role:
      statements:
        - Effect: Allow
          Action:
            - s3:GetObject
            - s3:PutObject
          Resource: "arn:aws:s3:::${self:custom.bucket}/*"
        - Effect: Allow
          Action:
            - dynamodb:Query
            - dynamodb:GetItem
            - dynamodb:PutItem
          Resource: "arn:aws:dynamodb:*:*:table/${self:custom.tableName}"

custom:
  bucket: my-lambda-bucket-${self:provider.stage}
  tableName: MyTable-${self:provider.stage}

functions:
  # HTTP API
  api:
    handler: bin/api
    events:
      - http:
          path: /hello
          method: post
          cors: true
  
  # S3事件触发
  s3processor:
    handler: bin/s3processor
    events:
      - s3:
          bucket: ${self:custom.bucket}
          event: s3:ObjectCreated:*
          rules:
            - prefix: uploads/
            - suffix: .jpg
  
  # DynamoDB Stream
  dbstream:
    handler: bin/dbstream
    events:
      - stream:
          type: dynamodb
          arn:
            Fn::GetAtt:
              - MyTable
              - StreamArn
          batchSize: 10
          startingPosition: LATEST
  
  # 定时任务
  cleanup:
    handler: bin/cleanup
    events:
      - schedule:
          rate: cron(0 1 * * ? *)  # 每天凌晨1点
          enabled: true

resources:
  Resources:
    MyTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:custom.tableName}
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        BillingMode: PAY_PER_REQUEST
        StreamSpecification:
          StreamViewType: NEW_AND_OLD_IMAGES

package:
  individually: true
  patterns:
    - '!./**'
    - ./bin/**
```

```makefile
# Makefile
.PHONY: build deploy clean test

build:
 @echo "Building Lambda functions..."
 GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="-s -w" -o bin/api ./cmd/api
 GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="-s -w" -o bin/s3processor ./cmd/s3processor
 GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="-s -w" -o bin/dbstream ./cmd/dbstream
 GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="-s -w" -o bin/cleanup ./cmd/cleanup

deploy: build
 serverless deploy --stage $(STAGE)

deploy-function:
 serverless deploy function --function $(FUNCTION) --stage $(STAGE)

clean:
 rm -rf bin/
 serverless remove --stage $(STAGE)

test:
 go test -v ./...

invoke-local:
 serverless invoke local --function api --data '{"body":"{\"name\":\"World\"}"}'
```

---

## 3. Knative Serverless平台

### 3.1 Knative Service部署

```go
// cmd/knative-service/main.go
package main

import (
 "fmt"
 "log"
 "net/http"
 "os"
)

// Knative Service (运行在Kubernetes上)
func main() {
 // 从环境变量获取端口
 port := os.Getenv("PORT")
 if port == "" {
  port = "8080"
 }
 
 http.HandleFunc("/", handleRequest)
 http.HandleFunc("/health", healthCheck)
 
 log.Printf("Starting server on port %s", port)
 if err := http.ListenAndServe(":"+port, nil); err != nil {
  log.Fatal(err)
 }
}

func handleRequest(w http.ResponseWriter, r *http.Request) {
 // 业务逻辑
 name := r.URL.Query().Get("name")
 if name == "" {
  name = "World"
 }
 
 response := fmt.Sprintf("Hello, %s! (Powered by Knative)", name)
 w.Header().Set("Content-Type", "text/plain")
 fmt.Fprint(w, response)
}

func healthCheck(w http.ResponseWriter, r *http.Request) {
 w.WriteHeader(http.StatusOK)
 fmt.Fprint(w, "OK")
}
```

```yaml
# service.yaml (Knative Service定义)
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: go-serverless-service
  namespace: default
spec:
  template:
    metadata:
      annotations:
        # 自动伸缩配置
        autoscaling.knative.dev/minScale: "0"      # 可缩容到0
        autoscaling.knative.dev/maxScale: "10"     # 最多10个Pod
        autoscaling.knative.dev/target: "100"      # 目标并发数
        autoscaling.knative.dev/scaleDownDelay: "5m"  # 缩容延迟
    spec:
      containers:
        - image: gcr.io/my-project/go-serverless:latest
          ports:
            - containerPort: 8080
          env:
            - name: LOG_LEVEL
              value: "info"
          resources:
            requests:
              memory: "64Mi"
              cpu: "100m"
            limits:
              memory: "128Mi"
              cpu: "200m"
          # 健康检查
          livenessProbe:
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 3
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 3
            periodSeconds: 10
```

### 3.2 Knative Eventing (事件驱动)

```go
// cmd/event-consumer/main.go
package main

import (
 "context"
 "fmt"
 "log"
 
 cloudevents "github.com/cloudevents/sdk-go/v2"
)

// CloudEvents标准事件处理
func main() {
 c, err := cloudevents.NewDefaultClient()
 if err != nil {
  log.Fatal(err)
 }
 
 log.Println("Listening for CloudEvents...")
 if err := c.StartReceiver(context.Background(), receive); err != nil {
  log.Fatal(err)
 }
}

func receive(ctx context.Context, event cloudevents.Event) error {
 fmt.Printf("Received event: %s\n", event.Type())
 fmt.Printf("Source: %s\n", event.Source())
 fmt.Printf("Data: %s\n", string(event.Data()))
 
 // 根据事件类型处理
 switch event.Type() {
 case "com.example.order.created":
  return handleOrderCreated(event)
 case "com.example.payment.completed":
  return handlePaymentCompleted(event)
 default:
  fmt.Printf("Unknown event type: %s\n", event.Type())
 }
 
 return nil
}

type OrderCreatedData struct {
 OrderID string  `json:"order_id"`
 Amount  float64 `json:"amount"`
}

func handleOrderCreated(event cloudevents.Event) error {
 var data OrderCreatedData
 if err := event.DataAs(&data); err != nil {
  return err
 }
 
 fmt.Printf("Processing order: %s, Amount: %.2f\n", data.OrderID, data.Amount)
 // 业务逻辑: 发送确认邮件、更新库存等
 return nil
}

func handlePaymentCompleted(event cloudevents.Event) error {
 // 处理支付完成事件
 return nil
}
```

```yaml
# eventing.yaml (Knative Eventing配置)
apiVersion: eventing.knative.dev/v1
kind: Broker
metadata:
  name: default
  namespace: default

---
apiVersion: eventing.knative.dev/v1
kind: Trigger
metadata:
  name: order-trigger
  namespace: default
spec:
  broker: default
  filter:
    attributes:
      type: com.example.order.created
  subscriber:
    ref:
      apiVersion: serving.knative.dev/v1
      kind: Service
      name: order-consumer

---
apiVersion: eventing.knative.dev/v1
kind: Trigger
metadata:
  name: payment-trigger
  namespace: default
spec:
  broker: default
  filter:
    attributes:
      type: com.example.payment.completed
  subscriber:
    ref:
      apiVersion: serving.knative.dev/v1
      kind: Service
      name: payment-consumer
```

---

## 4. Google Cloud Functions

### 4.1 HTTP Cloud Function

```go
// function.go
package helloworld

import (
 "encoding/json"
 "fmt"
 "net/http"
)

// HTTP触发的Cloud Function
func HelloHTTP(w http.ResponseWriter, r *http.Request) {
 var d struct {
  Name string `json:"name"`
 }
 
 // 解析JSON请求
 if err := json.NewDecoder(r.Body).Decode(&d); err != nil {
  http.Error(w, "Invalid JSON", http.StatusBadRequest)
  return
 }
 
 if d.Name == "" {
  d.Name = "World"
 }
 
 // 返回JSON响应
 w.Header().Set("Content-Type", "application/json")
 json.NewEncoder(w).Encode(map[string]string{
  "message": fmt.Sprintf("Hello, %s!", d.Name),
 })
}
```

### 4.2 Cloud Storage触发

```go
// storage.go
package storage

import (
 "context"
 "fmt"
 "log"
)

// GCS (Google Cloud Storage) 事件
type GCSEvent struct {
 Bucket string `json:"bucket"`
 Name   string `json:"name"`
 Metageneration string `json:"metageneration"`
 TimeCreated string `json:"timeCreated"`
 Updated string `json:"updated"`
}

// Cloud Storage触发的函数
func ProcessFile(ctx context.Context, e GCSEvent) error {
 log.Printf("Processing file: gs://%s/%s", e.Bucket, e.Name)
 
 // 示例: 图片处理
 if isImageFile(e.Name) {
  return processImage(ctx, e.Bucket, e.Name)
 }
 
 return nil
}

func isImageFile(filename string) bool {
 // 检查文件扩展名
 return true
}

func processImage(ctx context.Context, bucket, name string) error {
 fmt.Printf("Processing image: gs://%s/%s\n", bucket, name)
 // 实现图片处理逻辑
 return nil
}
```

### 4.3 Pub/Sub触发

```go
// pubsub.go
package pubsub

import (
 "context"
 "encoding/json"
 "fmt"
 "log"
)

// PubSubMessage代表Pub/Sub消息
type PubSubMessage struct {
 Data []byte `json:"data"`
 Attributes map[string]string `json:"attributes"`
}

// Pub/Sub触发的函数
func ProcessPubSub(ctx context.Context, m PubSubMessage) error {
 // 解析消息数据
 var payload struct {
  UserID string `json:"user_id"`
  Action string `json:"action"`
 }
 
 if err := json.Unmarshal(m.Data, &payload); err != nil {
  return fmt.Errorf("unmarshal: %w", err)
 }
 
 log.Printf("Processing message: UserID=%s, Action=%s", payload.UserID, payload.Action)
 
 // 处理业务逻辑
 switch payload.Action {
 case "signup":
  return handleUserSignup(ctx, payload.UserID)
 case "purchase":
  return handlePurchase(ctx, payload.UserID)
 default:
  log.Printf("Unknown action: %s", payload.Action)
 }
 
 return nil
}

func handleUserSignup(ctx context.Context, userID string) error {
 fmt.Printf("User signed up: %s\n", userID)
 // 发送欢迎邮件
 return nil
}

func handlePurchase(ctx context.Context, userID string) error {
 fmt.Printf("User made a purchase: %s\n", userID)
 // 更新用户积分
 return nil
}
```

---

## 5. 事件驱动架构

### 5.1 事件总线模式

```go
package eventbus

import (
 "context"
 "encoding/json"
 "fmt"
 "sync"
 "time"
)

// Event表示系统事件
type Event struct {
 ID        string                 `json:"id"`
 Type      string                 `json:"type"`
 Source    string                 `json:"source"`
 Data      interface{}            `json:"data"`
 Metadata  map[string]string      `json:"metadata"`
 Timestamp time.Time              `json:"timestamp"`
}

// EventHandler是事件处理函数
type EventHandler func(context.Context, Event) error

// EventBus是内存事件总线
type EventBus struct {
 mu       sync.RWMutex
 handlers map[string][]EventHandler
}

func NewEventBus() *EventBus {
 return &EventBus{
  handlers: make(map[string][]EventHandler),
 }
}

// Subscribe订阅事件类型
func (eb *EventBus) Subscribe(eventType string, handler EventHandler) {
 eb.mu.Lock()
 defer eb.mu.Unlock()
 
 eb.handlers[eventType] = append(eb.handlers[eventType], handler)
}

// Publish发布事件
func (eb *EventBus) Publish(ctx context.Context, event Event) error {
 eb.mu.RLock()
 handlers := eb.handlers[event.Type]
 eb.mu.RUnlock()
 
 if len(handlers) == 0 {
  return fmt.Errorf("no handlers for event type: %s", event.Type)
 }
 
 // 并行执行所有处理器
 var wg sync.WaitGroup
 errChan := make(chan error, len(handlers))
 
 for _, handler := range handlers {
  wg.Add(1)
  go func(h EventHandler) {
   defer wg.Done()
   if err := h(ctx, event); err != nil {
    errChan <- err
   }
  }(handler)
 }
 
 wg.Wait()
 close(errChan)
 
 // 收集错误
 var errs []error
 for err := range errChan {
  errs = append(errs, err)
 }
 
 if len(errs) > 0 {
  return fmt.Errorf("event processing errors: %v", errs)
 }
 
 return nil
}

// 使用示例
func ExampleEventBus() {
 bus := NewEventBus()
 
 // 订阅订单创建事件
 bus.Subscribe("order.created", func(ctx context.Context, e Event) error {
  fmt.Printf("[订单服务] 处理订单: %v\n", e.Data)
  // 创建订单记录
  return nil
 })
 
 bus.Subscribe("order.created", func(ctx context.Context, e Event) error {
  fmt.Printf("[库存服务] 扣减库存: %v\n", e.Data)
  // 扣减库存
  return nil
 })
 
 bus.Subscribe("order.created", func(ctx context.Context, e Event) error {
  fmt.Printf("[通知服务] 发送确认邮件: %v\n", e.Data)
  // 发送邮件
  return nil
 })
 
 // 发布事件
 ctx := context.Background()
 event := Event{
  ID:        "evt-123",
  Type:      "order.created",
  Source:    "api-service",
  Data:      map[string]interface{}{"order_id": "ORD-001", "amount": 99.99},
  Timestamp: time.Now(),
 }
 
 if err := bus.Publish(ctx, event); err != nil {
  fmt.Printf("Error: %v\n", err)
 }
}
```

### 5.2 消息队列集成

```go
package messaging

import (
 "context"
 "encoding/json"
 "fmt"
 "log"
 
 "github.com/aws/aws-sdk-go-v2/config"
 "github.com/aws/aws-sdk-go-v2/service/sqs"
)

// SQSEventProcessor处理SQS消息
type SQSEventProcessor struct {
 client   *sqs.Client
 queueURL string
}

func NewSQSEventProcessor(queueURL string) (*SQSEventProcessor, error) {
 cfg, err := config.LoadDefaultConfig(context.Background())
 if err != nil {
  return nil, err
 }
 
 return &SQSEventProcessor{
  client:   sqs.NewFromConfig(cfg),
  queueURL: queueURL,
 }, nil
}

// PublishEvent发送事件到SQS
func (p *SQSEventProcessor) PublishEvent(ctx context.Context, event Event) error {
 body, err := json.Marshal(event)
 if err != nil {
  return fmt.Errorf("marshal event: %w", err)
 }
 
 _, err = p.client.SendMessage(ctx, &sqs.SendMessageInput{
  QueueUrl:    &p.queueURL,
  MessageBody: strPtr(string(body)),
  MessageAttributes: map[string]types.MessageAttributeValue{
   "EventType": {
    DataType:    strPtr("String"),
    StringValue: &event.Type,
   },
  },
 })
 
 return err
}

// ConsumeEvents消费SQS消息
func (p *SQSEventProcessor) ConsumeEvents(ctx context.Context, handler EventHandler) error {
 for {
  select {
  case <-ctx.Done():
   return ctx.Err()
  default:
   result, err := p.client.ReceiveMessage(ctx, &sqs.ReceiveMessageInput{
    QueueUrl:            &p.queueURL,
    MaxNumberOfMessages: 10,
    WaitTimeSeconds:     20, // 长轮询
   })
   
   if err != nil {
    log.Printf("Error receiving messages: %v", err)
    continue
   }
   
   for _, msg := range result.Messages {
    if err := p.processMessage(ctx, msg, handler); err != nil {
     log.Printf("Error processing message: %v", err)
     continue
    }
    
    // 删除已处理的消息
    p.client.DeleteMessage(ctx, &sqs.DeleteMessageInput{
     QueueUrl:      &p.queueURL,
     ReceiptHandle: msg.ReceiptHandle,
    })
   }
  }
 }
}

func (p *SQSEventProcessor) processMessage(ctx context.Context, msg types.Message, handler EventHandler) error {
 var event Event
 if err := json.Unmarshal([]byte(*msg.Body), &event); err != nil {
  return fmt.Errorf("unmarshal event: %w", err)
 }
 
 return handler(ctx, event)
}

func strPtr(s string) *string {
 return &s
}
```

---

## 6. 冷启动优化

### 6.1 冷启动分析

```go
// 冷启动时间组成
/*
Lambda冷启动 = 初始化环境 + 加载代码 + 初始化运行时 + 执行init代码

Go Lambda冷启动优化:
1. 减小二进制大小
   • 使用 -ldflags="-s -w" 去除调试信息
   • UPX压缩 (可选)
   • 典型大小: 5-20MB

2. 减少init代码
   • 延迟初始化
   • 避免在init()中进行网络请求
   • 使用连接池复用

3. 使用Provisioned Concurrency
   • 预热实例
   • 消除冷启动
   • 适合延迟敏感场景

4. 选择合适的内存
   • 内存越大,CPU越强
   • 冷启动越快
   • 权衡成本

冷启动时间对比:
  128MB内存: ~200ms
  512MB内存: ~100ms
  1024MB内存: ~50ms
  
  Provisioned Concurrency: <10ms
*/
```

### 6.2 优化技巧

```go
package main

import (
 "context"
 "database/sql"
 "fmt"
 "sync"
 
 "github.com/aws/aws-lambda-go/lambda"
 _ "github.com/lib/pq"
)

// 1. 全局变量复用连接
var (
 db     *sql.DB
 dbOnce sync.Once
)

// getDB延迟初始化数据库连接
func getDB() (*sql.DB, error) {
 var err error
 dbOnce.Do(func() {
  dsn := "postgres://user:pass@host:5432/db"
  db, err = sql.Open("postgres", dsn)
  if err == nil {
   db.SetMaxOpenConns(1) // Lambda单并发
   db.SetMaxIdleConns(1) // 保持连接
  }
 })
 return db, err
}

// 2. 避免在init()中初始化
// ❌ 不推荐:
// func init() {
//     db, _ = sql.Open("postgres", dsn) // 每次冷启动都执行
// }

// 3. 使用Lambda Extension缓存
type CachedData struct {
 mu    sync.RWMutex
 cache map[string]interface{}
}

var globalCache = &CachedData{
 cache: make(map[string]interface{}),
}

func (c *CachedData) Get(key string) (interface{}, bool) {
 c.mu.RLock()
 defer c.mu.RUnlock()
 val, ok := c.cache[key]
 return val, ok
}

func (c *CachedData) Set(key string, value interface{}) {
 c.mu.Lock()
 defer c.mu.Unlock()
 c.cache[key] = value
}

// Handler是优化后的Lambda函数
func Handler(ctx context.Context, event interface{}) (string, error) {
 // 使用延迟初始化的数据库连接
 db, err := getDB()
 if err != nil {
  return "", fmt.Errorf("get db: %w", err)
 }
 
 // 使用全局缓存
 if cached, ok := globalCache.Get("config"); ok {
  fmt.Printf("Using cached config: %v\n", cached)
 } else {
  // 首次请求时加载配置
  config := loadConfig(db)
  globalCache.Set("config", config)
 }
 
 return "OK", nil
}

func loadConfig(db *sql.DB) interface{} {
 // 从数据库加载配置
 return map[string]string{"key": "value"}
}

// 4. 使用SnapStart (仅Java目前支持,Go即将支持)
// 5. 选择合适的VPC配置
/*
Lambda VPC冷启动:
  • 无VPC: 50-100ms
  • 有VPC (旧): 10-30秒
  • 有VPC (Hyperplane ENI): 100-200ms ✅

建议: 使用Hyperplane ENI或Lambda SnapStart
*/

func main() {
 lambda.Start(Handler)
}
```

### 6.3 Provisioned Concurrency

```yaml
# serverless.yml
functions:
  api:
    handler: bin/api
    provisionedConcurrency: 5  # 预热5个实例
    events:
      - http:
          path: /api
          method: any
    
    # 自动伸缩配置
    reservedConcurrency: 100  # 最大并发数
    
    # 根据时间调整预热实例数
    provisionedConcurrencySchedules:
      - schedule: cron(0 8 * * ? *)   # 工作日早上8点
        provisionedConcurrency: 20
      - schedule: cron(0 18 * * ? *)  # 工作日下午6点
        provisionedConcurrency: 5
```

---

## 7. 成本优化

### 7.1 成本计算

```go
// AWS Lambda成本计算
/*
成本 = 请求费用 + 计算费用

1. 请求费用:
   • $0.20 per 1M requests
   • 每月前100万次请求免费

2. 计算费用 (GB-秒):
   • $0.0000166667 per GB-second
   • 每月前40万GB-秒免费

示例计算:
  假设:
    • 函数内存: 512MB (0.5GB)
    • 平均执行时间: 200ms (0.2s)
    • 月请求数: 10M

  计算费用 = (10M * 0.5GB * 0.2s * $0.0000166667) - 免费额度
           = $16.67 - $6.67 = $10

  请求费用 = ((10M - 1M) / 1M) * $0.20
           = $1.80

  总成本 = $10 + $1.80 = $11.80/月

对比传统EC2:
  t3.medium (2 vCPU, 4GB): ~$30/月
  
节省成本: 60%+ (低流量场景)
*/

// 成本优化策略
type CostOptimization struct {
 Strategy string
 Impact   string
}

var strategies = []CostOptimization{
 {
  Strategy: "选择合适的内存大小",
  Impact:   "内存与CPU成正比,过大浪费,过小执行慢",
 },
 {
  Strategy: "优化执行时间",
  Impact:   "减少20%执行时间 = 减少20%成本",
 },
 {
  Strategy: "使用ARM架构 (Graviton2)",
  Impact:   "成本降低20%,性能提升19%",
 },
 {
  Strategy: "批量处理",
  Impact:   "聚合多个小请求,减少调用次数",
 },
 {
  Strategy: "异步处理",
  Impact:   "使用SQS/SNS解耦,避免同步等待",
 },
}
```

### 7.2 成本监控

```go
package monitoring

import (
 "context"
 "fmt"
 "time"
 
 "github.com/aws/aws-sdk-go-v2/service/cloudwatch"
 "github.com/aws/aws-sdk-go-v2/service/cloudwatch/types"
)

// CostMonitor监控Lambda成本
type CostMonitor struct {
 cwClient *cloudwatch.Client
}

func NewCostMonitor(client *cloudwatch.Client) *CostMonitor {
 return &CostMonitor{cwClient: client}
}

// GetFunctionMetrics获取函数指标
func (m *CostMonitor) GetFunctionMetrics(ctx context.Context, functionName string, period time.Duration) (*FunctionMetrics, error) {
 endTime := time.Now()
 startTime := endTime.Add(-period)
 
 // 获取调用次数
 invocations, err := m.getMetric(ctx, functionName, "Invocations", startTime, endTime)
 if err != nil {
  return nil, err
 }
 
 // 获取执行时间
 duration, err := m.getMetric(ctx, functionName, "Duration", startTime, endTime)
 if err != nil {
  return nil, err
 }
 
 // 获取错误数
 errors, err := m.getMetric(ctx, functionName, "Errors", startTime, endTime)
 if err != nil {
  return nil, err
 }
 
 return &FunctionMetrics{
  Invocations: invocations,
  Duration:    duration,
  Errors:      errors,
 }, nil
}

type FunctionMetrics struct {
 Invocations float64
 Duration    float64
 Errors      float64
}

func (m *CostMonitor) getMetric(ctx context.Context, functionName, metricName string, start, end time.Time) (float64, error) {
 result, err := m.cwClient.GetMetricStatistics(ctx, &cloudwatch.GetMetricStatisticsInput{
  Namespace:  strPtr("AWS/Lambda"),
  MetricName: &metricName,
  Dimensions: []types.Dimension{
   {
    Name:  strPtr("FunctionName"),
    Value: &functionName,
   },
  },
  StartTime:  &start,
  EndTime:    &end,
  Period:     int32Ptr(300),
  Statistics: []types.Statistic{types.StatisticSum},
 })
 
 if err != nil {
  return 0, err
 }
 
 var sum float64
 for _, dp := range result.Datapoints {
  sum += *dp.Sum
 }
 
 return sum, nil
}

// EstimateCost估算成本
func (m *CostMonitor) EstimateCost(metrics *FunctionMetrics, memoryMB int) float64 {
 // 请求成本
 requestCost := 0.0
 if metrics.Invocations > 1000000 {
  requestCost = (metrics.Invocations - 1000000) / 1000000 * 0.20
 }
 
 // 计算成本
 memoryGB := float64(memoryMB) / 1024
 durationSeconds := metrics.Duration / 1000
 gbSeconds := metrics.Invocations * memoryGB * durationSeconds
 
 computeCost := 0.0
 if gbSeconds > 400000 {
  computeCost = (gbSeconds - 400000) * 0.0000166667
 }
 
 return requestCost + computeCost
}

func strPtr(s string) *string {
 return &s
}

func int32Ptr(i int32) *int32 {
 return &i
}

// 使用示例
func ExampleCostMonitoring() {
 // monitor := NewCostMonitor(cwClient)
 // metrics, _ := monitor.GetFunctionMetrics(ctx, "my-function", 24*time.Hour)
 // cost := monitor.EstimateCost(metrics, 512)
 // fmt.Printf("Estimated daily cost: $%.2f\n", cost)
}
```

---

## 8. 监控与调试

### 8.1 结构化日志

```go
package logging

import (
 "context"
 "encoding/json"
 "log/slog"
 "os"
 
 "github.com/aws/aws-lambda-go/lambdacontext"
)

// 初始化结构化日志
var logger *slog.Logger

func init() {
 logger = slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
  Level: slog.LevelInfo,
 }))
}

// LogWithContext记录带上下文的日志
func LogWithContext(ctx context.Context, level slog.Level, msg string, args ...any) {
 // 从Lambda上下文提取信息
 if lc, ok := lambdacontext.FromContext(ctx); ok {
  args = append(args,
   slog.String("request_id", lc.AwsRequestID),
   slog.String("function_name", lambdacontext.FunctionName),
   slog.String("function_version", lambdacontext.FunctionVersion),
  )
 }
 
 logger.Log(ctx, level, msg, args...)
}

// 使用示例
func ExampleStructuredLogging(ctx context.Context) {
 LogWithContext(ctx, slog.LevelInfo, "Processing request",
  slog.String("user_id", "user-123"),
  slog.Int("item_count", 5),
 )
 
 // 输出:
 // {"time":"2024-01-15T10:30:00Z","level":"INFO","msg":"Processing request","user_id":"user-123","item_count":5,"request_id":"abc-123","function_name":"my-function","function_version":"$LATEST"}
}
```

### 8.2 分布式追踪

```go
package tracing

import (
 "context"
 
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
 "go.opentelemetry.io/otel/sdk/resource"
 sdktrace "go.opentelemetry.io/otel/sdk/trace"
 semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
)

// InitTracer初始化OpenTelemetry
func InitTracer(ctx context.Context) (func(), error) {
 // 创建OTLP exporter
 exporter, err := otlptracegrpc.New(ctx)
 if err != nil {
  return nil, err
 }
 
 // 创建resource
 res, err := resource.New(ctx,
  resource.WithAttributes(
   semconv.ServiceNameKey.String("lambda-service"),
   semconv.ServiceVersionKey.String("1.0.0"),
  ),
 )
 if err != nil {
  return nil, err
 }
 
 // 创建tracer provider
 tp := sdktrace.NewTracerProvider(
  sdktrace.WithBatcher(exporter),
  sdktrace.WithResource(res),
 )
 
 otel.SetTracerProvider(tp)
 
 return func() {
  tp.Shutdown(ctx)
 }, nil
}

// TraceHandler包装Lambda handler添加追踪
func TraceHandler(handler lambda.Handler) lambda.Handler {
 return lambda.NewHandler(func(ctx context.Context, event interface{}) (interface{}, error) {
  tracer := otel.Tracer("lambda")
  ctx, span := tracer.Start(ctx, "lambda-invocation")
  defer span.End()
  
  // 调用原始handler
  return handler.Invoke(ctx, event)
 })
}
```

### 8.3 错误处理与重试

```go
package errorhandling

import (
 "context"
 "errors"
 "fmt"
 "time"
)

// RetryableError表示可重试的错误
type RetryableError struct {
 Err error
}

func (e *RetryableError) Error() string {
 return fmt.Sprintf("retryable: %v", e.Err)
}

func (e *RetryableError) Unwrap() error {
 return e.Err
}

// RetryHandler实现指数退避重试
func RetryHandler(ctx context.Context, fn func() error, maxRetries int) error {
 var err error
 backoff := time.Second
 
 for i := 0; i < maxRetries; i++ {
  err = fn()
  if err == nil {
   return nil
  }
  
  // 检查是否可重试
  var retryable *RetryableError
  if !errors.As(err, &retryable) {
   return err // 不可重试,直接返回
  }
  
  // 最后一次重试不再等待
  if i == maxRetries-1 {
   break
  }
  
  // 指数退避
  select {
  case <-ctx.Done():
   return ctx.Err()
  case <-time.After(backoff):
   backoff *= 2
   if backoff > 30*time.Second {
    backoff = 30 * time.Second
   }
  }
 }
 
 return fmt.Errorf("max retries exceeded: %w", err)
}

// 使用示例
func ExampleRetry() {
 ctx := context.Background()
 
 err := RetryHandler(ctx, func() error {
  // 可能失败的操作
  if err := callExternalAPI(); err != nil {
   return &RetryableError{Err: err}
  }
  return nil
 }, 3)
 
 if err != nil {
  fmt.Printf("Operation failed: %v\n", err)
 }
}

func callExternalAPI() error {
 // 模拟API调用
 return nil
}
```

---

## 9. 最佳实践

### 9.1 安全最佳实践

```go
// Serverless安全清单
/*
1. ✅ IAM权限最小化
   • 只授予必需的权限
   • 使用IAM角色而非AccessKey
   • 定期审计权限

2. ✅ 环境变量加密
   • 使用KMS加密敏感配置
   • 不在代码中硬编码密钥
   • 使用Secrets Manager

3. ✅ VPC网络隔离
   • 数据库放在private subnet
   • 使用Security Group限制访问
   • NAT Gateway访问外网

4. ✅ API Gateway认证
   • 使用API Key
   • JWT Token验证
   • AWS IAM授权

5. ✅ 输入验证
   • 验证所有输入参数
   • 防止SQL注入
   • 限制请求大小

6. ✅ 审计日志
   • 启用CloudTrail
   • 记录所有API调用
   • 设置告警规则
*/

// 示例: KMS加密的环境变量
package security

import (
 "context"
 "encoding/base64"
 "os"
 
 "github.com/aws/aws-sdk-go-v2/service/kms"
)

type SecretManager struct {
 kmsClient *kms.Client
}

func (sm *SecretManager) GetSecret(ctx context.Context, envKey string) (string, error) {
 // 从环境变量获取加密的值
 encrypted := os.Getenv(envKey)
 if encrypted == "" {
  return "", nil
 }
 
 // Base64解码
 ciphertext, err := base64.StdEncoding.DecodeString(encrypted)
 if err != nil {
  return "", err
 }
 
 // KMS解密
 result, err := sm.kmsClient.Decrypt(ctx, &kms.DecryptInput{
  CiphertextBlob: ciphertext,
 })
 if err != nil {
  return "", err
 }
 
 return string(result.Plaintext), nil
}
```

### 9.2 性能最佳实践

```go
// Serverless性能优化清单
/*
1. ✅ 连接复用
   • 使用全局变量保持数据库连接
   • 复用HTTP客户端
   • 使用连接池

2. ✅ 并行处理
   • 使用goroutine并行调用
   • 批量处理记录
   • 异步非阻塞

3. ✅ 缓存策略
   • Lambda Extension缓存
   • ElastiCache集中缓存
   • API Gateway缓存

4. ✅ 选择合适的内存
   • 内存 ∝ CPU性能
   • Benchmark测试最优值
   • 成本与性能平衡

5. ✅ 减少冷启动
   • 最小化依赖
   • 延迟初始化
   • Provisioned Concurrency

6. ✅ 异步解耦
   • 长时间任务异步化
   • 使用SQS/SNS
   • Step Functions编排
*/

package performance

import (
 "context"
 "sync"
)

// ParallelProcessor并行处理器
type ParallelProcessor struct {
 maxWorkers int
}

func NewParallelProcessor(maxWorkers int) *ParallelProcessor {
 return &ParallelProcessor{maxWorkers: maxWorkers}
}

// Process并行处理items
func (p *ParallelProcessor) Process(ctx context.Context, items []string, process func(string) error) error {
 sem := make(chan struct{}, p.maxWorkers)
 var wg sync.WaitGroup
 errChan := make(chan error, len(items))
 
 for _, item := range items {
  wg.Add(1)
  go func(item string) {
   defer wg.Done()
   
   sem <- struct{}{}        // 获取令牌
   defer func() { <-sem }() // 释放令牌
   
   if err := process(item); err != nil {
    errChan <- err
   }
  }(item)
 }
 
 wg.Wait()
 close(errChan)
 
 // 返回第一个错误
 select {
 case err := <-errChan:
  return err
 default:
  return nil
 }
}
```

---

## 10. 完整项目示例

### 10.1 项目结构

```text
serverless-image-processor/
├── cmd/
│   ├── upload/        # 上传API
│   ├── process/       # 图片处理
│   └── notify/        # 通知服务
├── internal/
│   ├── storage/       # S3操作
│   ├── processor/     # 图片处理逻辑
│   └── notification/  # 通知逻辑
├── pkg/
│   ├── models/        # 数据模型
│   └── utils/         # 工具函数
├── serverless.yml     # Serverless配置
├── Makefile          # 构建脚本
└── go.mod
```

### 10.2 上传API

```go
// cmd/upload/main.go
package main

import (
 "context"
 "encoding/json"
 "fmt"
 "time"
 
 "github.com/aws/aws-lambda-go/events"
 "github.com/aws/aws-lambda-go/lambda"
 "github.com/aws/aws-sdk-go-v2/config"
 "github.com/aws/aws-sdk-go-v2/service/s3"
 "github.com/google/uuid"
)

var s3Client *s3.Client

func init() {
 cfg, _ := config.LoadDefaultConfig(context.Background())
 s3Client = s3.NewFromConfig(cfg)
}

type UploadRequest struct {
 FileName string `json:"file_name"`
 FileType string `json:"file_type"`
}

type UploadResponse struct {
 UploadURL string `json:"upload_url"`
 FileID    string `json:"file_id"`
}

// Handler生成预签名上传URL
func Handler(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
 var req UploadRequest
 if err := json.Unmarshal([]byte(request.Body), &req); err != nil {
  return errorResponse(400, "Invalid request")
 }
 
 // 生成唯一文件ID
 fileID := uuid.New().String()
 key := fmt.Sprintf("uploads/%s/%s", fileID, req.FileName)
 
 // 生成预签名URL (15分钟有效)
 presigner := s3.NewPresignClient(s3Client)
 presignedReq, err := presigner.PresignPutObject(ctx, &s3.PutObjectInput{
  Bucket:      strPtr("my-image-bucket"),
  Key:         &key,
  ContentType: &req.FileType,
 }, s3.WithPresignExpires(15*time.Minute))
 
 if err != nil {
  return errorResponse(500, "Failed to generate upload URL")
 }
 
 // 返回响应
 response := UploadResponse{
  UploadURL: presignedReq.URL,
  FileID:    fileID,
 }
 
 return jsonResponse(200, response)
}

func jsonResponse(status int, data interface{}) (events.APIGatewayProxyResponse, error) {
 body, _ := json.Marshal(data)
 return events.APIGatewayProxyResponse{
  StatusCode: status,
  Body:       string(body),
  Headers: map[string]string{
   "Content-Type":                "application/json",
   "Access-Control-Allow-Origin": "*",
  },
 }, nil
}

func errorResponse(status int, message string) (events.APIGatewayProxyResponse, error) {
 return jsonResponse(status, map[string]string{"error": message})
}

func strPtr(s string) *string {
 return &s
}

func main() {
 lambda.Start(Handler)
}
```

### 10.3 图片处理函数

```go
// cmd/process/main.go
package main

import (
 "bytes"
 "context"
 "fmt"
 "image"
 "image/jpeg"
 "image/png"
 
 "github.com/aws/aws-lambda-go/events"
 "github.com/aws/aws-lambda-go/lambda"
 "github.com/aws/aws-sdk-go-v2/config"
 "github.com/aws/aws-sdk-go-v2/service/s3"
 "github.com/nfnt/resize"
)

var s3Client *s3.Client

func init() {
 cfg, _ := config.LoadDefaultConfig(context.Background())
 s3Client = s3.NewFromConfig(cfg)
}

// Handler处理S3上传事件
func Handler(ctx context.Context, s3Event events.S3Event) error {
 for _, record := range s3Event.Records {
  bucket := record.S3.Bucket.Name
  key := record.S3.Object.Key
  
  fmt.Printf("Processing: s3://%s/%s\n", bucket, key)
  
  // 处理图片
  if err := processImage(ctx, bucket, key); err != nil {
   fmt.Printf("Error processing image: %v\n", err)
   return err
  }
 }
 
 return nil
}

func processImage(ctx context.Context, bucket, key string) error {
 // 1. 从S3下载原始图片
 result, err := s3Client.GetObject(ctx, &s3.GetObjectInput{
  Bucket: &bucket,
  Key:    &key,
 })
 if err != nil {
  return fmt.Errorf("get object: %w", err)
 }
 defer result.Body.Close()
 
 // 2. 解码图片
 img, format, err := image.Decode(result.Body)
 if err != nil {
  return fmt.Errorf("decode image: %w", err)
 }
 
 fmt.Printf("Original image: %dx%d, format: %s\n", img.Bounds().Dx(), img.Bounds().Dy(), format)
 
 // 3. 生成多个尺寸的缩略图
 thumbnails := []struct {
  name   string
  width  uint
  height uint
 }{
  {"small", 150, 150},
  {"medium", 300, 300},
  {"large", 600, 600},
 }
 
 for _, thumb := range thumbnails {
  resized := resize.Thumbnail(thumb.width, thumb.height, img, resize.Lanczos3)
  
  // 上传缩略图
  thumbKey := fmt.Sprintf("thumbnails/%s/%s", thumb.name, key)
  if err := uploadImage(ctx, bucket, thumbKey, resized, format); err != nil {
   return fmt.Errorf("upload thumbnail: %w", err)
  }
  
  fmt.Printf("Generated thumbnail: %s (%dx%d)\n", thumb.name, resized.Bounds().Dx(), resized.Bounds().Dy())
 }
 
 return nil
}

func uploadImage(ctx context.Context, bucket, key string, img image.Image, format string) error {
 // 编码图片
 var buf bytes.Buffer
 switch format {
 case "jpeg", "jpg":
  jpeg.Encode(&buf, img, &jpeg.Options{Quality: 90})
 case "png":
  png.Encode(&buf, img)
 default:
  return fmt.Errorf("unsupported format: %s", format)
 }
 
 // 上传到S3
 _, err := s3Client.PutObject(ctx, &s3.PutObjectInput{
  Bucket:      &bucket,
  Key:         &key,
  Body:        bytes.NewReader(buf.Bytes()),
  ContentType: strPtr(fmt.Sprintf("image/%s", format)),
 })
 
 return err
}

func strPtr(s string) *string {
 return &s
}

func main() {
 lambda.Start(Handler)
}
```

### 10.4 完整Serverless配置

```yaml
# serverless.yml
service: serverless-image-processor

provider:
  name: aws
  runtime: go1.x
  region: us-east-1
  stage: ${opt:stage, 'dev'}
  memorySize: 512
  timeout: 60
  
  environment:
    BUCKET_NAME: ${self:custom.bucketName}
    STAGE: ${self:provider.stage}
  
  iam:
    role:
      statements:
        - Effect: Allow
          Action:
            - s3:GetObject
            - s3:PutObject
          Resource: "arn:aws:s3:::${self:custom.bucketName}/*"
        - Effect: Allow
          Action:
            - sns:Publish
          Resource: !Ref NotificationTopic

custom:
  bucketName: image-processor-${self:provider.stage}

functions:
  # 上传API
  upload:
    handler: bin/upload
    events:
      - http:
          path: /upload
          method: post
          cors: true
    environment:
      BUCKET: ${self:custom.bucketName}
  
  # 图片处理
  process:
    handler: bin/process
    events:
      - s3:
          bucket: ${self:custom.bucketName}
          event: s3:ObjectCreated:*
          rules:
            - prefix: uploads/
            - suffix: .jpg
      - s3:
          bucket: ${self:custom.bucketName}
          event: s3:ObjectCreated:*
          rules:
            - prefix: uploads/
            - suffix: .png
    memorySize: 1024  # 图片处理需要更多内存
  
  # 通知服务
  notify:
    handler: bin/notify
    events:
      - sns:
          arn: !Ref NotificationTopic
          topicName: ImageProcessingComplete

resources:
  Resources:
    # SNS Topic
    NotificationTopic:
      Type: AWS::SNS::Topic
      Properties:
        TopicName: ImageProcessingComplete-${self:provider.stage}
    
    # DLQ for failed processing
    ProcessDLQ:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: image-process-dlq-${self:provider.stage}
        MessageRetentionPeriod: 1209600  # 14 days

package:
  individually: true
  patterns:
    - '!./**'
    - ./bin/**
```

### 10.5 性能监控Dashboard

```go
// internal/monitoring/dashboard.go
package monitoring

import (
 "context"
 "fmt"
 "time"
 
 "github.com/aws/aws-sdk-go-v2/service/cloudwatch"
 "github.com/aws/aws-sdk-go-v2/service/cloudwatch/types"
)

// Dashboard创建CloudWatch Dashboard
func CreateDashboard(ctx context.Context, cwClient *cloudwatch.Client, functionName string) error {
 dashboardBody := fmt.Sprintf(`{
  "widgets": [
   {
    "type": "metric",
    "properties": {
     "title": "Invocations",
     "metrics": [
      ["AWS/Lambda", "Invocations", {"stat": "Sum"}]
     ],
     "period": 300,
     "region": "us-east-1"
    }
   },
   {
    "type": "metric",
    "properties": {
     "title": "Duration",
     "metrics": [
      ["AWS/Lambda", "Duration", {"stat": "Average"}],
      [".", ".", {"stat": "Maximum"}]
     ],
     "period": 300
    }
   },
   {
    "type": "metric",
    "properties": {
     "title": "Errors",
     "metrics": [
      ["AWS/Lambda", "Errors", {"stat": "Sum"}],
      [".", "Throttles", {"stat": "Sum"}]
     ],
     "period": 300
    }
   },
   {
    "type": "metric",
    "properties": {
     "title": "Concurrent Executions",
     "metrics": [
      ["AWS/Lambda", "ConcurrentExecutions", {"stat": "Maximum"}]
     ],
     "period": 60
    }
   }
  ]
 }`, functionName)
 
 _, err := cwClient.PutDashboard(ctx, &cloudwatch.PutDashboardInput{
  DashboardName: strPtr(fmt.Sprintf("%s-dashboard", functionName)),
  DashboardBody: &dashboardBody,
 })
 
 return err
}

// CreateAlarms创建告警规则
func CreateAlarms(ctx context.Context, cwClient *cloudwatch.Client, functionName, snsTopicARN string) error {
 alarms := []struct {
  name      string
  metric    string
  threshold float64
  operator  types.ComparisonOperator
 }{
  {
   name:      "HighErrorRate",
   metric:    "Errors",
   threshold: 10,
   operator:  types.ComparisonOperatorGreaterThanThreshold,
  },
  {
   name:      "HighDuration",
   metric:    "Duration",
   threshold: 5000,
   operator:  types.ComparisonOperatorGreaterThanThreshold,
  },
  {
   name:      "Throttles",
   metric:    "Throttles",
   threshold: 1,
   operator:  types.ComparisonOperatorGreaterThanOrEqualToThreshold,
  },
 }
 
 for _, alarm := range alarms {
  _, err := cwClient.PutMetricAlarm(ctx, &cloudwatch.PutMetricAlarmInput{
   AlarmName:          strPtr(fmt.Sprintf("%s-%s", functionName, alarm.name)),
   ComparisonOperator: alarm.operator,
   EvaluationPeriods:  int32Ptr(2),
   MetricName:         &alarm.metric,
   Namespace:          strPtr("AWS/Lambda"),
   Period:             int32Ptr(300),
   Statistic:          types.StatisticSum,
   Threshold:          &alarm.threshold,
   ActionsEnabled:     boolPtr(true),
   AlarmActions:       []string{snsTopicARN},
   Dimensions: []types.Dimension{
    {
     Name:  strPtr("FunctionName"),
     Value: &functionName,
    },
   },
  })
  
  if err != nil {
   return err
  }
 }
 
 return nil
}

func strPtr(s string) *string { return &s }
func int32Ptr(i int32) *int32 { return &i }
func boolPtr(b bool) *bool    { return &b }
```

---

## 总结

### Serverless架构演进路径

```text
1. 起步阶段:
   • 简单的HTTP API
   • 定时任务
   • 事件响应

2. 成长阶段:
   • 微服务拆分
   • 事件驱动架构
   • 异步处理

3. 成熟阶段:
   • 混合架构 (Serverless + Container)
   • 完整可观测性
   • 成本优化

4. 最佳实践:
   ✅ 安全第一
   ✅ 监控完善
   ✅ 成本可控
   ✅ 性能优化
```

### 关键要点

1. **Go语言优势**: 启动快、内存小、性能强
2. **成本优化**: 按用量计费,合理配置内存
3. **冷启动优化**: 延迟初始化,连接复用,Provisioned Concurrency
4. **安全实践**: IAM最小权限,KMS加密,VPC隔离
5. **监控体系**: 结构化日志,分布式追踪,CloudWatch告警

### 适用场景

- ✅ Web/Mobile后端API
- ✅ 数据ETL管道
- ✅ 实时文件处理
- ✅ 定时任务
- ✅ IoT数据处理
- ✅ Webhook处理
- ✅ 事件驱动架构

**相关文档:**

- [云原生部署](10-Go-1.25.3云原生完整实战.md)
- [微服务架构](09-Go-1.25.3微服务架构完整实战.md)
- [分布式追踪](23-Go-1.25.3分布式追踪与可观测性完整实战.md)
