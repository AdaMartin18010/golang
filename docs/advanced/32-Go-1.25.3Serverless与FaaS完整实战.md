# Go 1.25.3 Serverlessä¸FaaSå®Œæ•´å®æˆ˜

## ğŸ“‹ ç›®å½•


- [1. Serverlessæ¶æ„æ¦‚è¿°](#1-serverlessæ¶æ„æ¦‚è¿°)
  - [1.1 æ ¸å¿ƒæ¦‚å¿µ](#11-æ ¸å¿ƒæ¦‚å¿µ)
  - [1.2 Goåœ¨Serverlessä¸­çš„ä¼˜åŠ¿](#12-goåœ¨serverlessä¸­çš„ä¼˜åŠ¿)
- [2. AWS Lambdaå®æˆ˜](#2-aws-lambdaå®æˆ˜)
  - [2.1 Lambdaå‡½æ•°ç»“æ„](#21-lambdaå‡½æ•°ç»“æ„)
  - [2.2 S3äº‹ä»¶å¤„ç†](#22-s3äº‹ä»¶å¤„ç†)
  - [2.3 DynamoDB Streamå¤„ç†](#23-dynamodb-streamå¤„ç†)
  - [2.4 å®šæ—¶ä»»åŠ¡ (CloudWatch Events/EventBridge)](#24-å®šæ—¶ä»»åŠ¡-cloudwatch-eventseventbridge)
  - [2.5 éƒ¨ç½²é…ç½®](#25-éƒ¨ç½²é…ç½®)
- [3. Knative Serverlesså¹³å°](#3-knative-serverlesså¹³å°)
  - [3.1 Knative Serviceéƒ¨ç½²](#31-knative-serviceéƒ¨ç½²)
  - [3.2 Knative Eventing (äº‹ä»¶é©±åŠ¨)](#32-knative-eventing-äº‹ä»¶é©±åŠ¨)
- [4. Google Cloud Functions](#4-google-cloud-functions)
  - [4.1 HTTP Cloud Function](#41-http-cloud-function)
  - [4.2 Cloud Storageè§¦å‘](#42-cloud-storageè§¦å‘)
  - [4.3 Pub/Subè§¦å‘](#43-pubsubè§¦å‘)
- [5. äº‹ä»¶é©±åŠ¨æ¶æ„](#5-äº‹ä»¶é©±åŠ¨æ¶æ„)
  - [5.1 äº‹ä»¶æ€»çº¿æ¨¡å¼](#51-äº‹ä»¶æ€»çº¿æ¨¡å¼)
  - [5.2 æ¶ˆæ¯é˜Ÿåˆ—é›†æˆ](#52-æ¶ˆæ¯é˜Ÿåˆ—é›†æˆ)
- [6. å†·å¯åŠ¨ä¼˜åŒ–](#6-å†·å¯åŠ¨ä¼˜åŒ–)
  - [6.1 å†·å¯åŠ¨åˆ†æ](#61-å†·å¯åŠ¨åˆ†æ)
  - [6.2 ä¼˜åŒ–æŠ€å·§](#62-ä¼˜åŒ–æŠ€å·§)
  - [6.3 Provisioned Concurrency](#63-provisioned-concurrency)
- [7. æˆæœ¬ä¼˜åŒ–](#7-æˆæœ¬ä¼˜åŒ–)
  - [7.1 æˆæœ¬è®¡ç®—](#71-æˆæœ¬è®¡ç®—)
  - [7.2 æˆæœ¬ç›‘æ§](#72-æˆæœ¬ç›‘æ§)
- [8. ç›‘æ§ä¸è°ƒè¯•](#8-ç›‘æ§ä¸è°ƒè¯•)
  - [8.1 ç»“æ„åŒ–æ—¥å¿—](#81-ç»“æ„åŒ–æ—¥å¿—)
  - [8.2 åˆ†å¸ƒå¼è¿½è¸ª](#82-åˆ†å¸ƒå¼è¿½è¸ª)
  - [8.3 é”™è¯¯å¤„ç†ä¸é‡è¯•](#83-é”™è¯¯å¤„ç†ä¸é‡è¯•)
- [9. æœ€ä½³å®è·µ](#9-æœ€ä½³å®è·µ)
  - [9.1 å®‰å…¨æœ€ä½³å®è·µ](#91-å®‰å…¨æœ€ä½³å®è·µ)
  - [9.2 æ€§èƒ½æœ€ä½³å®è·µ](#92-æ€§èƒ½æœ€ä½³å®è·µ)
- [10. å®Œæ•´é¡¹ç›®ç¤ºä¾‹](#10-å®Œæ•´é¡¹ç›®ç¤ºä¾‹)
  - [10.1 é¡¹ç›®ç»“æ„](#101-é¡¹ç›®ç»“æ„)
  - [10.2 ä¸Šä¼ API](#102-ä¸Šä¼ api)
  - [10.3 å›¾ç‰‡å¤„ç†å‡½æ•°](#103-å›¾ç‰‡å¤„ç†å‡½æ•°)
  - [10.4 å®Œæ•´Serverlessé…ç½®](#104-å®Œæ•´serverlessé…ç½®)
  - [10.5 æ€§èƒ½ç›‘æ§Dashboard](#105-æ€§èƒ½ç›‘æ§dashboard)
- [æ€»ç»“](#æ€»ç»“)
  - [Serverlessæ¶æ„æ¼”è¿›è·¯å¾„](#serverlessæ¶æ„æ¼”è¿›è·¯å¾„)
  - [å…³é”®è¦ç‚¹](#å…³é”®è¦ç‚¹)
  - [é€‚ç”¨åœºæ™¯](#é€‚ç”¨åœºæ™¯)

## 1. Serverlessæ¶æ„æ¦‚è¿°

### 1.1 æ ¸å¿ƒæ¦‚å¿µ

```go
// Serverlessæ¶æ„å®šä¹‰
/*
Serverless = FaaS + BaaS

FaaS (Function as a Service):
  â€¢ äº‹ä»¶é©±åŠ¨çš„å‡½æ•°æ‰§è¡Œ
  â€¢ è‡ªåŠ¨ä¼¸ç¼© (Scale to Zero)
  â€¢ æŒ‰éœ€è®¡è´¹ (Pay per Use)
  â€¢ æ— æœåŠ¡å™¨ç®¡ç†

BaaS (Backend as a Service):
  â€¢ æ‰˜ç®¡æ•°æ®åº“ (DynamoDB, Firestore)
  â€¢ æ‰˜ç®¡å­˜å‚¨ (S3, Cloud Storage)
  â€¢ æ‰˜ç®¡è®¤è¯ (Cognito, Auth0)
  â€¢ æ‰˜ç®¡API (API Gateway)

æ ¸å¿ƒä¼˜åŠ¿:
  âœ… æ— éœ€ç®¡ç†æœåŠ¡å™¨
  âœ… è‡ªåŠ¨å¼¹æ€§ä¼¸ç¼©
  âœ… é«˜å¯ç”¨æ€§ä¿è¯
  âœ… æŒ‰ä½¿ç”¨é‡è®¡è´¹
  âœ… å¿«é€Ÿè¿­ä»£éƒ¨ç½²

é€‚ç”¨åœºæ™¯:
  â€¢ Web APIåç«¯
  â€¢ æ•°æ®å¤„ç†ç®¡é“
  â€¢ å®šæ—¶ä»»åŠ¡ (Cron Jobs)
  â€¢ äº‹ä»¶å“åº” (S3ä¸Šä¼ , DBå˜æ›´)
  â€¢ å¾®æœåŠ¡æ¶æ„
*/

// Serverlessæ¶æ„å¯¹æ¯”
type ServerlessComparison struct {
 Traditional struct {
  Server      string // "éœ€è¦ç®¡ç†EC2/VM"
  Scaling     string // "æ‰‹åŠ¨é…ç½®Auto Scaling"
  Billing     string // "æŒ‰å°æ—¶è®¡è´¹"
  Maintenance string // "éœ€è¦OSè¡¥ä¸/å®‰å…¨æ›´æ–°"
  MinCost     string // "è‡³å°‘1å°æœåŠ¡å™¨è¿è¡Œ"
 }
 
 Serverless struct {
  Server      string // "æ— éœ€ç®¡ç†"
  Scaling     string // "è‡ªåŠ¨ä¼¸ç¼©åˆ°0"
  Billing     string // "æŒ‰æ¯«ç§’+è¯·æ±‚æ•°è®¡è´¹"
  Maintenance string // "äº‘å‚å•†è´Ÿè´£"
  MinCost     string // "æ— æµé‡æ—¶0æˆæœ¬"
 }
}
```

### 1.2 Goåœ¨Serverlessä¸­çš„ä¼˜åŠ¿

```go
// Goè¯­è¨€åœ¨Serverlessåœºæ™¯çš„ä¼˜åŠ¿
/*
1. å¯åŠ¨é€Ÿåº¦å¿« âš¡
   â€¢ ç¼–è¯‘å‹è¯­è¨€,å¯åŠ¨æ—¶é—´ < 10ms
   â€¢ å¯¹æ¯”: Node.js ~100ms, Python ~200ms, Java ~1000ms
   â€¢ å‡å°‘å†·å¯åŠ¨å»¶è¿Ÿ

2. å†…å­˜å ç”¨å° ğŸ’¾
   â€¢ Goå‡½æ•°å…¸å‹å†…å­˜: 10-50MB
   â€¢ å¯¹æ¯”: Java 128MB+, .NET 256MB+
   â€¢ é™ä½è¿è¡Œæˆæœ¬

3. å¹¶å‘æ€§èƒ½å¼º ğŸš€
   â€¢ Goroutineè½»é‡çº§å¹¶å‘
   â€¢ å†…ç½®channelé€šä¿¡
   â€¢ é€‚åˆé«˜å¹¶å‘åœºæ™¯

4. å•ä¸€äºŒè¿›åˆ¶ ğŸ“¦
   â€¢ æ— ä¾èµ–éƒ¨ç½²
   â€¢ æ— éœ€æ‰“åŒ…node_modules
   â€¢ éƒ¨ç½²åŒ…æ›´å°

5. å¼ºç±»å‹å®‰å…¨ ğŸ›¡ï¸
   â€¢ ç¼–è¯‘æ—¶é”™è¯¯æ£€æŸ¥
   â€¢ å‡å°‘è¿è¡Œæ—¶é”™è¯¯
   â€¢ æé«˜ç¨³å®šæ€§

æ€§èƒ½å¯¹æ¯” (AWS Lambda):
  Go:      å†·å¯åŠ¨ 50ms,  å†…å­˜ 20MB
  Node.js: å†·å¯åŠ¨ 150ms, å†…å­˜ 40MB
  Python:  å†·å¯åŠ¨ 250ms, å†…å­˜ 50MB
  Java:    å†·å¯åŠ¨ 2000ms, å†…å­˜ 128MB
*/
```

---

## 2. AWS Lambdaå®æˆ˜

### 2.1 Lambdaå‡½æ•°ç»“æ„

```go
package main

import (
 "context"
 "encoding/json"
 "fmt"
 "github.com/aws/aws-lambda-go/events"
 "github.com/aws/aws-lambda-go/lambda"
)

// Lambdaå‡½æ•°åŸºæœ¬ç»“æ„
/*
Go Lambdaå‡½æ•°ç­¾å:
  â€¢ func()
  â€¢ func() error
  â€¢ func(TIn) error
  â€¢ func() (TOut, error)
  â€¢ func(TIn) (TOut, error)
  â€¢ func(context.Context) error
  â€¢ func(context.Context, TIn) error
  â€¢ func(context.Context) (TOut, error)
  â€¢ func(context.Context, TIn) (TOut, error)

å¸¸ç”¨: func(context.Context, TIn) (TOut, error)
*/

// 1. ç®€å•HTTP APIå¤„ç†
func HandleAPIRequest(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
 // è§£æè¯·æ±‚
 var input struct {
  Name string `json:"name"`
 }
 
 if err := json.Unmarshal([]byte(request.Body), &input); err != nil {
  return events.APIGatewayProxyResponse{
   StatusCode: 400,
   Body:       `{"error": "Invalid JSON"}`,
   Headers: map[string]string{
    "Content-Type": "application/json",
   },
  }, nil
 }
 
 // ä¸šåŠ¡é€»è¾‘
 message := fmt.Sprintf("Hello, %s!", input.Name)
 
 // è¿”å›å“åº”
 responseBody, _ := json.Marshal(map[string]string{
  "message": message,
 })
 
 return events.APIGatewayProxyResponse{
  StatusCode: 200,
  Body:       string(responseBody),
  Headers: map[string]string{
   "Content-Type": "application/json",
   "Access-Control-Allow-Origin": "*",
  },
 }, nil
}

func main() {
 lambda.Start(HandleAPIRequest)
}
```

### 2.2 S3äº‹ä»¶å¤„ç†

```go
package main

import (
 "context"
 "fmt"
 "github.com/aws/aws-lambda-go/events"
 "github.com/aws/aws-lambda-go/lambda"
 "github.com/aws/aws-sdk-go-v2/config"
 "github.com/aws/aws-sdk-go-v2/service/s3"
)

// S3äº‹ä»¶è§¦å‘çš„Lambdaå‡½æ•°
func HandleS3Event(ctx context.Context, s3Event events.S3Event) error {
 // åŠ è½½AWSé…ç½®
 cfg, err := config.LoadDefaultConfig(ctx)
 if err != nil {
  return fmt.Errorf("load config: %w", err)
 }
 
 s3Client := s3.NewFromConfig(cfg)
 
 // å¤„ç†æ¯ä¸ªS3è®°å½•
 for _, record := range s3Event.Records {
  bucket := record.S3.Bucket.Name
  key := record.S3.Object.Key
  eventName := record.EventName
  
  fmt.Printf("Event: %s, Bucket: %s, Key: %s\n", eventName, bucket, key)
  
  // æ ¹æ®äº‹ä»¶ç±»å‹å¤„ç†
  switch {
  case record.EventName[:12] == "ObjectCreated":
   // å¯¹è±¡åˆ›å»ºäº‹ä»¶
   if err := processNewObject(ctx, s3Client, bucket, key); err != nil {
    return err
   }
   
  case record.EventName[:12] == "ObjectRemoved":
   // å¯¹è±¡åˆ é™¤äº‹ä»¶
   fmt.Printf("Object removed: %s/%s\n", bucket, key)
  }
 }
 
 return nil
}

// å¤„ç†æ–°ä¸Šä¼ çš„å¯¹è±¡
func processNewObject(ctx context.Context, client *s3.Client, bucket, key string) error {
 // è·å–å¯¹è±¡
 result, err := client.GetObject(ctx, &s3.GetObjectInput{
  Bucket: &bucket,
  Key:    &key,
 })
 if err != nil {
  return fmt.Errorf("get object: %w", err)
 }
 defer result.Body.Close()
 
 // å¤„ç†å¯¹è±¡å†…å®¹
 // ç¤ºä¾‹: ç”Ÿæˆç¼©ç•¥å›¾ã€è½¬æ¢æ ¼å¼ã€æå–å…ƒæ•°æ®ç­‰
 fmt.Printf("Processing object: %s/%s (Size: %d bytes)\n", bucket, key, result.ContentLength)
 
 return nil
}

func main() {
 lambda.Start(HandleS3Event)
}
```

### 2.3 DynamoDB Streamå¤„ç†

```go
package main

import (
 "context"
 "fmt"
 "github.com/aws/aws-lambda-go/events"
 "github.com/aws/aws-lambda-go/lambda"
)

// DynamoDB Streamäº‹ä»¶å¤„ç†
func HandleDynamoDBStream(ctx context.Context, event events.DynamoDBEvent) error {
 for _, record := range event.Records {
  fmt.Printf("Event: %s, EventID: %s\n", record.EventName, record.EventID)
  
  switch record.EventName {
  case "INSERT":
   // æ–°è®°å½•æ’å…¥
   newImage := record.Change.NewImage
   fmt.Printf("New item: %v\n", newImage)
   
   // ç¤ºä¾‹: å‘é€æ¬¢è¿é‚®ä»¶
   if email, ok := newImage["email"]; ok {
    sendWelcomeEmail(email.String())
   }
   
  case "MODIFY":
   // è®°å½•ä¿®æ”¹
   oldImage := record.Change.OldImage
   newImage := record.Change.NewImage
   fmt.Printf("Updated: %v -> %v\n", oldImage, newImage)
   
  case "REMOVE":
   // è®°å½•åˆ é™¤
   oldImage := record.Change.OldImage
   fmt.Printf("Deleted item: %v\n", oldImage)
  }
 }
 
 return nil
}

func sendWelcomeEmail(email string) {
 fmt.Printf("Sending welcome email to: %s\n", email)
 // å®é™…å®ç°: è°ƒç”¨SESå‘é€é‚®ä»¶
}

func main() {
 lambda.Start(HandleDynamoDBStream)
}
```

### 2.4 å®šæ—¶ä»»åŠ¡ (CloudWatch Events/EventBridge)

```go
package main

import (
 "context"
 "fmt"
 "github.com/aws/aws-lambda-go/events"
 "github.com/aws/aws-lambda-go/lambda"
 "time"
)

// å®šæ—¶è§¦å‘çš„Lambdaå‡½æ•°
// ç¤ºä¾‹: æ¯å¤©å‡Œæ™¨1ç‚¹æ¸…ç†è¿‡æœŸæ•°æ®
func HandleScheduledEvent(ctx context.Context, event events.CloudWatchEvent) error {
 fmt.Printf("Scheduled event triggered at: %s\n", event.Time)
 
 // æ‰§è¡Œå®šæ—¶ä»»åŠ¡
 if err := cleanupExpiredData(ctx); err != nil {
  return fmt.Errorf("cleanup failed: %w", err)
 }
 
 fmt.Println("Cleanup completed successfully")
 return nil
}

func cleanupExpiredData(ctx context.Context) error {
 // ç¤ºä¾‹: åˆ é™¤30å¤©å‰çš„æ—§æ•°æ®
 cutoffDate := time.Now().AddDate(0, 0, -30)
 fmt.Printf("Cleaning up data older than: %s\n", cutoffDate.Format("2006-01-02"))
 
 // å®é™…å®ç°: æŸ¥è¯¢å¹¶åˆ é™¤DynamoDB/RDSä¸­çš„è¿‡æœŸè®°å½•
 // ...
 
 return nil
}

func main() {
 lambda.Start(HandleScheduledEvent)
}
```

### 2.5 éƒ¨ç½²é…ç½®

```yaml
# serverless.yml (Serverless Framework)
service: go-lambda-service

provider:
  name: aws
  runtime: go1.x
  region: us-east-1
  stage: ${opt:stage, 'dev'}
  memorySize: 256
  timeout: 30
  
  environment:
    STAGE: ${self:provider.stage}
    TABLE_NAME: ${self:custom.tableName}
  
  iam:
    role:
      statements:
        - Effect: Allow
          Action:
            - s3:GetObject
            - s3:PutObject
          Resource: "arn:aws:s3:::${self:custom.bucket}/*"
        - Effect: Allow
          Action:
            - dynamodb:Query
            - dynamodb:GetItem
            - dynamodb:PutItem
          Resource: "arn:aws:dynamodb:*:*:table/${self:custom.tableName}"

custom:
  bucket: my-lambda-bucket-${self:provider.stage}
  tableName: MyTable-${self:provider.stage}

functions:
  # HTTP API
  api:
    handler: bin/api
    events:
      - http:
          path: /hello
          method: post
          cors: true
  
  # S3äº‹ä»¶è§¦å‘
  s3processor:
    handler: bin/s3processor
    events:
      - s3:
          bucket: ${self:custom.bucket}
          event: s3:ObjectCreated:*
          rules:
            - prefix: uploads/
            - suffix: .jpg
  
  # DynamoDB Stream
  dbstream:
    handler: bin/dbstream
    events:
      - stream:
          type: dynamodb
          arn:
            Fn::GetAtt:
              - MyTable
              - StreamArn
          batchSize: 10
          startingPosition: LATEST
  
  # å®šæ—¶ä»»åŠ¡
  cleanup:
    handler: bin/cleanup
    events:
      - schedule:
          rate: cron(0 1 * * ? *)  # æ¯å¤©å‡Œæ™¨1ç‚¹
          enabled: true

resources:
  Resources:
    MyTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:custom.tableName}
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        BillingMode: PAY_PER_REQUEST
        StreamSpecification:
          StreamViewType: NEW_AND_OLD_IMAGES

package:
  individually: true
  patterns:
    - '!./**'
    - ./bin/**
```

```makefile
# Makefile
.PHONY: build deploy clean test

build:
 @echo "Building Lambda functions..."
 GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="-s -w" -o bin/api ./cmd/api
 GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="-s -w" -o bin/s3processor ./cmd/s3processor
 GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="-s -w" -o bin/dbstream ./cmd/dbstream
 GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="-s -w" -o bin/cleanup ./cmd/cleanup

deploy: build
 serverless deploy --stage $(STAGE)

deploy-function:
 serverless deploy function --function $(FUNCTION) --stage $(STAGE)

clean:
 rm -rf bin/
 serverless remove --stage $(STAGE)

test:
 go test -v ./...

invoke-local:
 serverless invoke local --function api --data '{"body":"{\"name\":\"World\"}"}'
```

---

## 3. Knative Serverlesså¹³å°

### 3.1 Knative Serviceéƒ¨ç½²

```go
// cmd/knative-service/main.go
package main

import (
 "fmt"
 "log"
 "net/http"
 "os"
)

// Knative Service (è¿è¡Œåœ¨Kubernetesä¸Š)
func main() {
 // ä»ç¯å¢ƒå˜é‡è·å–ç«¯å£
 port := os.Getenv("PORT")
 if port == "" {
  port = "8080"
 }
 
 http.HandleFunc("/", handleRequest)
 http.HandleFunc("/health", healthCheck)
 
 log.Printf("Starting server on port %s", port)
 if err := http.ListenAndServe(":"+port, nil); err != nil {
  log.Fatal(err)
 }
}

func handleRequest(w http.ResponseWriter, r *http.Request) {
 // ä¸šåŠ¡é€»è¾‘
 name := r.URL.Query().Get("name")
 if name == "" {
  name = "World"
 }
 
 response := fmt.Sprintf("Hello, %s! (Powered by Knative)", name)
 w.Header().Set("Content-Type", "text/plain")
 fmt.Fprint(w, response)
}

func healthCheck(w http.ResponseWriter, r *http.Request) {
 w.WriteHeader(http.StatusOK)
 fmt.Fprint(w, "OK")
}
```

```yaml
# service.yaml (Knative Serviceå®šä¹‰)
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: go-serverless-service
  namespace: default
spec:
  template:
    metadata:
      annotations:
        # è‡ªåŠ¨ä¼¸ç¼©é…ç½®
        autoscaling.knative.dev/minScale: "0"      # å¯ç¼©å®¹åˆ°0
        autoscaling.knative.dev/maxScale: "10"     # æœ€å¤š10ä¸ªPod
        autoscaling.knative.dev/target: "100"      # ç›®æ ‡å¹¶å‘æ•°
        autoscaling.knative.dev/scaleDownDelay: "5m"  # ç¼©å®¹å»¶è¿Ÿ
    spec:
      containers:
        - image: gcr.io/my-project/go-serverless:latest
          ports:
            - containerPort: 8080
          env:
            - name: LOG_LEVEL
              value: "info"
          resources:
            requests:
              memory: "64Mi"
              cpu: "100m"
            limits:
              memory: "128Mi"
              cpu: "200m"
          # å¥åº·æ£€æŸ¥
          livenessProbe:
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 3
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 3
            periodSeconds: 10
```

### 3.2 Knative Eventing (äº‹ä»¶é©±åŠ¨)

```go
// cmd/event-consumer/main.go
package main

import (
 "context"
 "fmt"
 "log"
 
 cloudevents "github.com/cloudevents/sdk-go/v2"
)

// CloudEventsæ ‡å‡†äº‹ä»¶å¤„ç†
func main() {
 c, err := cloudevents.NewDefaultClient()
 if err != nil {
  log.Fatal(err)
 }
 
 log.Println("Listening for CloudEvents...")
 if err := c.StartReceiver(context.Background(), receive); err != nil {
  log.Fatal(err)
 }
}

func receive(ctx context.Context, event cloudevents.Event) error {
 fmt.Printf("Received event: %s\n", event.Type())
 fmt.Printf("Source: %s\n", event.Source())
 fmt.Printf("Data: %s\n", string(event.Data()))
 
 // æ ¹æ®äº‹ä»¶ç±»å‹å¤„ç†
 switch event.Type() {
 case "com.example.order.created":
  return handleOrderCreated(event)
 case "com.example.payment.completed":
  return handlePaymentCompleted(event)
 default:
  fmt.Printf("Unknown event type: %s\n", event.Type())
 }
 
 return nil
}

type OrderCreatedData struct {
 OrderID string  `json:"order_id"`
 Amount  float64 `json:"amount"`
}

func handleOrderCreated(event cloudevents.Event) error {
 var data OrderCreatedData
 if err := event.DataAs(&data); err != nil {
  return err
 }
 
 fmt.Printf("Processing order: %s, Amount: %.2f\n", data.OrderID, data.Amount)
 // ä¸šåŠ¡é€»è¾‘: å‘é€ç¡®è®¤é‚®ä»¶ã€æ›´æ–°åº“å­˜ç­‰
 return nil
}

func handlePaymentCompleted(event cloudevents.Event) error {
 // å¤„ç†æ”¯ä»˜å®Œæˆäº‹ä»¶
 return nil
}
```

```yaml
# eventing.yaml (Knative Eventingé…ç½®)
apiVersion: eventing.knative.dev/v1
kind: Broker
metadata:
  name: default
  namespace: default

---
apiVersion: eventing.knative.dev/v1
kind: Trigger
metadata:
  name: order-trigger
  namespace: default
spec:
  broker: default
  filter:
    attributes:
      type: com.example.order.created
  subscriber:
    ref:
      apiVersion: serving.knative.dev/v1
      kind: Service
      name: order-consumer

---
apiVersion: eventing.knative.dev/v1
kind: Trigger
metadata:
  name: payment-trigger
  namespace: default
spec:
  broker: default
  filter:
    attributes:
      type: com.example.payment.completed
  subscriber:
    ref:
      apiVersion: serving.knative.dev/v1
      kind: Service
      name: payment-consumer
```

---

## 4. Google Cloud Functions

### 4.1 HTTP Cloud Function

```go
// function.go
package helloworld

import (
 "encoding/json"
 "fmt"
 "net/http"
)

// HTTPè§¦å‘çš„Cloud Function
func HelloHTTP(w http.ResponseWriter, r *http.Request) {
 var d struct {
  Name string `json:"name"`
 }
 
 // è§£æJSONè¯·æ±‚
 if err := json.NewDecoder(r.Body).Decode(&d); err != nil {
  http.Error(w, "Invalid JSON", http.StatusBadRequest)
  return
 }
 
 if d.Name == "" {
  d.Name = "World"
 }
 
 // è¿”å›JSONå“åº”
 w.Header().Set("Content-Type", "application/json")
 json.NewEncoder(w).Encode(map[string]string{
  "message": fmt.Sprintf("Hello, %s!", d.Name),
 })
}
```

### 4.2 Cloud Storageè§¦å‘

```go
// storage.go
package storage

import (
 "context"
 "fmt"
 "log"
)

// GCS (Google Cloud Storage) äº‹ä»¶
type GCSEvent struct {
 Bucket string `json:"bucket"`
 Name   string `json:"name"`
 Metageneration string `json:"metageneration"`
 TimeCreated string `json:"timeCreated"`
 Updated string `json:"updated"`
}

// Cloud Storageè§¦å‘çš„å‡½æ•°
func ProcessFile(ctx context.Context, e GCSEvent) error {
 log.Printf("Processing file: gs://%s/%s", e.Bucket, e.Name)
 
 // ç¤ºä¾‹: å›¾ç‰‡å¤„ç†
 if isImageFile(e.Name) {
  return processImage(ctx, e.Bucket, e.Name)
 }
 
 return nil
}

func isImageFile(filename string) bool {
 // æ£€æŸ¥æ–‡ä»¶æ‰©å±•å
 return true
}

func processImage(ctx context.Context, bucket, name string) error {
 fmt.Printf("Processing image: gs://%s/%s\n", bucket, name)
 // å®ç°å›¾ç‰‡å¤„ç†é€»è¾‘
 return nil
}
```

### 4.3 Pub/Subè§¦å‘

```go
// pubsub.go
package pubsub

import (
 "context"
 "encoding/json"
 "fmt"
 "log"
)

// PubSubMessageä»£è¡¨Pub/Subæ¶ˆæ¯
type PubSubMessage struct {
 Data []byte `json:"data"`
 Attributes map[string]string `json:"attributes"`
}

// Pub/Subè§¦å‘çš„å‡½æ•°
func ProcessPubSub(ctx context.Context, m PubSubMessage) error {
 // è§£ææ¶ˆæ¯æ•°æ®
 var payload struct {
  UserID string `json:"user_id"`
  Action string `json:"action"`
 }
 
 if err := json.Unmarshal(m.Data, &payload); err != nil {
  return fmt.Errorf("unmarshal: %w", err)
 }
 
 log.Printf("Processing message: UserID=%s, Action=%s", payload.UserID, payload.Action)
 
 // å¤„ç†ä¸šåŠ¡é€»è¾‘
 switch payload.Action {
 case "signup":
  return handleUserSignup(ctx, payload.UserID)
 case "purchase":
  return handlePurchase(ctx, payload.UserID)
 default:
  log.Printf("Unknown action: %s", payload.Action)
 }
 
 return nil
}

func handleUserSignup(ctx context.Context, userID string) error {
 fmt.Printf("User signed up: %s\n", userID)
 // å‘é€æ¬¢è¿é‚®ä»¶
 return nil
}

func handlePurchase(ctx context.Context, userID string) error {
 fmt.Printf("User made a purchase: %s\n", userID)
 // æ›´æ–°ç”¨æˆ·ç§¯åˆ†
 return nil
}
```

---

## 5. äº‹ä»¶é©±åŠ¨æ¶æ„

### 5.1 äº‹ä»¶æ€»çº¿æ¨¡å¼

```go
package eventbus

import (
 "context"
 "encoding/json"
 "fmt"
 "sync"
 "time"
)

// Eventè¡¨ç¤ºç³»ç»Ÿäº‹ä»¶
type Event struct {
 ID        string                 `json:"id"`
 Type      string                 `json:"type"`
 Source    string                 `json:"source"`
 Data      interface{}            `json:"data"`
 Metadata  map[string]string      `json:"metadata"`
 Timestamp time.Time              `json:"timestamp"`
}

// EventHandleræ˜¯äº‹ä»¶å¤„ç†å‡½æ•°
type EventHandler func(context.Context, Event) error

// EventBusæ˜¯å†…å­˜äº‹ä»¶æ€»çº¿
type EventBus struct {
 mu       sync.RWMutex
 handlers map[string][]EventHandler
}

func NewEventBus() *EventBus {
 return &EventBus{
  handlers: make(map[string][]EventHandler),
 }
}

// Subscribeè®¢é˜…äº‹ä»¶ç±»å‹
func (eb *EventBus) Subscribe(eventType string, handler EventHandler) {
 eb.mu.Lock()
 defer eb.mu.Unlock()
 
 eb.handlers[eventType] = append(eb.handlers[eventType], handler)
}

// Publishå‘å¸ƒäº‹ä»¶
func (eb *EventBus) Publish(ctx context.Context, event Event) error {
 eb.mu.RLock()
 handlers := eb.handlers[event.Type]
 eb.mu.RUnlock()
 
 if len(handlers) == 0 {
  return fmt.Errorf("no handlers for event type: %s", event.Type)
 }
 
 // å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰å¤„ç†å™¨
 var wg sync.WaitGroup
 errChan := make(chan error, len(handlers))
 
 for _, handler := range handlers {
  wg.Add(1)
  go func(h EventHandler) {
   defer wg.Done()
   if err := h(ctx, event); err != nil {
    errChan <- err
   }
  }(handler)
 }
 
 wg.Wait()
 close(errChan)
 
 // æ”¶é›†é”™è¯¯
 var errs []error
 for err := range errChan {
  errs = append(errs, err)
 }
 
 if len(errs) > 0 {
  return fmt.Errorf("event processing errors: %v", errs)
 }
 
 return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleEventBus() {
 bus := NewEventBus()
 
 // è®¢é˜…è®¢å•åˆ›å»ºäº‹ä»¶
 bus.Subscribe("order.created", func(ctx context.Context, e Event) error {
  fmt.Printf("[è®¢å•æœåŠ¡] å¤„ç†è®¢å•: %v\n", e.Data)
  // åˆ›å»ºè®¢å•è®°å½•
  return nil
 })
 
 bus.Subscribe("order.created", func(ctx context.Context, e Event) error {
  fmt.Printf("[åº“å­˜æœåŠ¡] æ‰£å‡åº“å­˜: %v\n", e.Data)
  // æ‰£å‡åº“å­˜
  return nil
 })
 
 bus.Subscribe("order.created", func(ctx context.Context, e Event) error {
  fmt.Printf("[é€šçŸ¥æœåŠ¡] å‘é€ç¡®è®¤é‚®ä»¶: %v\n", e.Data)
  // å‘é€é‚®ä»¶
  return nil
 })
 
 // å‘å¸ƒäº‹ä»¶
 ctx := context.Background()
 event := Event{
  ID:        "evt-123",
  Type:      "order.created",
  Source:    "api-service",
  Data:      map[string]interface{}{"order_id": "ORD-001", "amount": 99.99},
  Timestamp: time.Now(),
 }
 
 if err := bus.Publish(ctx, event); err != nil {
  fmt.Printf("Error: %v\n", err)
 }
}
```

### 5.2 æ¶ˆæ¯é˜Ÿåˆ—é›†æˆ

```go
package messaging

import (
 "context"
 "encoding/json"
 "fmt"
 "log"
 
 "github.com/aws/aws-sdk-go-v2/config"
 "github.com/aws/aws-sdk-go-v2/service/sqs"
)

// SQSEventProcessorå¤„ç†SQSæ¶ˆæ¯
type SQSEventProcessor struct {
 client   *sqs.Client
 queueURL string
}

func NewSQSEventProcessor(queueURL string) (*SQSEventProcessor, error) {
 cfg, err := config.LoadDefaultConfig(context.Background())
 if err != nil {
  return nil, err
 }
 
 return &SQSEventProcessor{
  client:   sqs.NewFromConfig(cfg),
  queueURL: queueURL,
 }, nil
}

// PublishEventå‘é€äº‹ä»¶åˆ°SQS
func (p *SQSEventProcessor) PublishEvent(ctx context.Context, event Event) error {
 body, err := json.Marshal(event)
 if err != nil {
  return fmt.Errorf("marshal event: %w", err)
 }
 
 _, err = p.client.SendMessage(ctx, &sqs.SendMessageInput{
  QueueUrl:    &p.queueURL,
  MessageBody: strPtr(string(body)),
  MessageAttributes: map[string]types.MessageAttributeValue{
   "EventType": {
    DataType:    strPtr("String"),
    StringValue: &event.Type,
   },
  },
 })
 
 return err
}

// ConsumeEventsæ¶ˆè´¹SQSæ¶ˆæ¯
func (p *SQSEventProcessor) ConsumeEvents(ctx context.Context, handler EventHandler) error {
 for {
  select {
  case <-ctx.Done():
   return ctx.Err()
  default:
   result, err := p.client.ReceiveMessage(ctx, &sqs.ReceiveMessageInput{
    QueueUrl:            &p.queueURL,
    MaxNumberOfMessages: 10,
    WaitTimeSeconds:     20, // é•¿è½®è¯¢
   })
   
   if err != nil {
    log.Printf("Error receiving messages: %v", err)
    continue
   }
   
   for _, msg := range result.Messages {
    if err := p.processMessage(ctx, msg, handler); err != nil {
     log.Printf("Error processing message: %v", err)
     continue
    }
    
    // åˆ é™¤å·²å¤„ç†çš„æ¶ˆæ¯
    p.client.DeleteMessage(ctx, &sqs.DeleteMessageInput{
     QueueUrl:      &p.queueURL,
     ReceiptHandle: msg.ReceiptHandle,
    })
   }
  }
 }
}

func (p *SQSEventProcessor) processMessage(ctx context.Context, msg types.Message, handler EventHandler) error {
 var event Event
 if err := json.Unmarshal([]byte(*msg.Body), &event); err != nil {
  return fmt.Errorf("unmarshal event: %w", err)
 }
 
 return handler(ctx, event)
}

func strPtr(s string) *string {
 return &s
}
```

---

## 6. å†·å¯åŠ¨ä¼˜åŒ–

### 6.1 å†·å¯åŠ¨åˆ†æ

```go
// å†·å¯åŠ¨æ—¶é—´ç»„æˆ
/*
Lambdaå†·å¯åŠ¨ = åˆå§‹åŒ–ç¯å¢ƒ + åŠ è½½ä»£ç  + åˆå§‹åŒ–è¿è¡Œæ—¶ + æ‰§è¡Œinitä»£ç 

Go Lambdaå†·å¯åŠ¨ä¼˜åŒ–:
1. å‡å°äºŒè¿›åˆ¶å¤§å°
   â€¢ ä½¿ç”¨ -ldflags="-s -w" å»é™¤è°ƒè¯•ä¿¡æ¯
   â€¢ UPXå‹ç¼© (å¯é€‰)
   â€¢ å…¸å‹å¤§å°: 5-20MB

2. å‡å°‘initä»£ç 
   â€¢ å»¶è¿Ÿåˆå§‹åŒ–
   â€¢ é¿å…åœ¨init()ä¸­è¿›è¡Œç½‘ç»œè¯·æ±‚
   â€¢ ä½¿ç”¨è¿æ¥æ± å¤ç”¨

3. ä½¿ç”¨Provisioned Concurrency
   â€¢ é¢„çƒ­å®ä¾‹
   â€¢ æ¶ˆé™¤å†·å¯åŠ¨
   â€¢ é€‚åˆå»¶è¿Ÿæ•æ„Ÿåœºæ™¯

4. é€‰æ‹©åˆé€‚çš„å†…å­˜
   â€¢ å†…å­˜è¶Šå¤§,CPUè¶Šå¼º
   â€¢ å†·å¯åŠ¨è¶Šå¿«
   â€¢ æƒè¡¡æˆæœ¬

å†·å¯åŠ¨æ—¶é—´å¯¹æ¯”:
  128MBå†…å­˜: ~200ms
  512MBå†…å­˜: ~100ms
  1024MBå†…å­˜: ~50ms
  
  Provisioned Concurrency: <10ms
*/
```

### 6.2 ä¼˜åŒ–æŠ€å·§

```go
package main

import (
 "context"
 "database/sql"
 "fmt"
 "sync"
 
 "github.com/aws/aws-lambda-go/lambda"
 _ "github.com/lib/pq"
)

// 1. å…¨å±€å˜é‡å¤ç”¨è¿æ¥
var (
 db     *sql.DB
 dbOnce sync.Once
)

// getDBå»¶è¿Ÿåˆå§‹åŒ–æ•°æ®åº“è¿æ¥
func getDB() (*sql.DB, error) {
 var err error
 dbOnce.Do(func() {
  dsn := "postgres://user:pass@host:5432/db"
  db, err = sql.Open("postgres", dsn)
  if err == nil {
   db.SetMaxOpenConns(1) // Lambdaå•å¹¶å‘
   db.SetMaxIdleConns(1) // ä¿æŒè¿æ¥
  }
 })
 return db, err
}

// 2. é¿å…åœ¨init()ä¸­åˆå§‹åŒ–
// âŒ ä¸æ¨è:
// func init() {
//     db, _ = sql.Open("postgres", dsn) // æ¯æ¬¡å†·å¯åŠ¨éƒ½æ‰§è¡Œ
// }

// 3. ä½¿ç”¨Lambda Extensionç¼“å­˜
type CachedData struct {
 mu    sync.RWMutex
 cache map[string]interface{}
}

var globalCache = &CachedData{
 cache: make(map[string]interface{}),
}

func (c *CachedData) Get(key string) (interface{}, bool) {
 c.mu.RLock()
 defer c.mu.RUnlock()
 val, ok := c.cache[key]
 return val, ok
}

func (c *CachedData) Set(key string, value interface{}) {
 c.mu.Lock()
 defer c.mu.Unlock()
 c.cache[key] = value
}

// Handleræ˜¯ä¼˜åŒ–åçš„Lambdaå‡½æ•°
func Handler(ctx context.Context, event interface{}) (string, error) {
 // ä½¿ç”¨å»¶è¿Ÿåˆå§‹åŒ–çš„æ•°æ®åº“è¿æ¥
 db, err := getDB()
 if err != nil {
  return "", fmt.Errorf("get db: %w", err)
 }
 
 // ä½¿ç”¨å…¨å±€ç¼“å­˜
 if cached, ok := globalCache.Get("config"); ok {
  fmt.Printf("Using cached config: %v\n", cached)
 } else {
  // é¦–æ¬¡è¯·æ±‚æ—¶åŠ è½½é…ç½®
  config := loadConfig(db)
  globalCache.Set("config", config)
 }
 
 return "OK", nil
}

func loadConfig(db *sql.DB) interface{} {
 // ä»æ•°æ®åº“åŠ è½½é…ç½®
 return map[string]string{"key": "value"}
}

// 4. ä½¿ç”¨SnapStart (ä»…Javaç›®å‰æ”¯æŒ,Goå³å°†æ”¯æŒ)
// 5. é€‰æ‹©åˆé€‚çš„VPCé…ç½®
/*
Lambda VPCå†·å¯åŠ¨:
  â€¢ æ— VPC: 50-100ms
  â€¢ æœ‰VPC (æ—§): 10-30ç§’
  â€¢ æœ‰VPC (Hyperplane ENI): 100-200ms âœ…

å»ºè®®: ä½¿ç”¨Hyperplane ENIæˆ–Lambda SnapStart
*/

func main() {
 lambda.Start(Handler)
}
```

### 6.3 Provisioned Concurrency

```yaml
# serverless.yml
functions:
  api:
    handler: bin/api
    provisionedConcurrency: 5  # é¢„çƒ­5ä¸ªå®ä¾‹
    events:
      - http:
          path: /api
          method: any
    
    # è‡ªåŠ¨ä¼¸ç¼©é…ç½®
    reservedConcurrency: 100  # æœ€å¤§å¹¶å‘æ•°
    
    # æ ¹æ®æ—¶é—´è°ƒæ•´é¢„çƒ­å®ä¾‹æ•°
    provisionedConcurrencySchedules:
      - schedule: cron(0 8 * * ? *)   # å·¥ä½œæ—¥æ—©ä¸Š8ç‚¹
        provisionedConcurrency: 20
      - schedule: cron(0 18 * * ? *)  # å·¥ä½œæ—¥ä¸‹åˆ6ç‚¹
        provisionedConcurrency: 5
```

---

## 7. æˆæœ¬ä¼˜åŒ–

### 7.1 æˆæœ¬è®¡ç®—

```go
// AWS Lambdaæˆæœ¬è®¡ç®—
/*
æˆæœ¬ = è¯·æ±‚è´¹ç”¨ + è®¡ç®—è´¹ç”¨

1. è¯·æ±‚è´¹ç”¨:
   â€¢ $0.20 per 1M requests
   â€¢ æ¯æœˆå‰100ä¸‡æ¬¡è¯·æ±‚å…è´¹

2. è®¡ç®—è´¹ç”¨ (GB-ç§’):
   â€¢ $0.0000166667 per GB-second
   â€¢ æ¯æœˆå‰40ä¸‡GB-ç§’å…è´¹

ç¤ºä¾‹è®¡ç®—:
  å‡è®¾:
    â€¢ å‡½æ•°å†…å­˜: 512MB (0.5GB)
    â€¢ å¹³å‡æ‰§è¡Œæ—¶é—´: 200ms (0.2s)
    â€¢ æœˆè¯·æ±‚æ•°: 10M

  è®¡ç®—è´¹ç”¨ = (10M * 0.5GB * 0.2s * $0.0000166667) - å…è´¹é¢åº¦
           = $16.67 - $6.67 = $10

  è¯·æ±‚è´¹ç”¨ = ((10M - 1M) / 1M) * $0.20
           = $1.80

  æ€»æˆæœ¬ = $10 + $1.80 = $11.80/æœˆ

å¯¹æ¯”ä¼ ç»ŸEC2:
  t3.medium (2 vCPU, 4GB): ~$30/æœˆ
  
èŠ‚çœæˆæœ¬: 60%+ (ä½æµé‡åœºæ™¯)
*/

// æˆæœ¬ä¼˜åŒ–ç­–ç•¥
type CostOptimization struct {
 Strategy string
 Impact   string
}

var strategies = []CostOptimization{
 {
  Strategy: "é€‰æ‹©åˆé€‚çš„å†…å­˜å¤§å°",
  Impact:   "å†…å­˜ä¸CPUæˆæ­£æ¯”,è¿‡å¤§æµªè´¹,è¿‡å°æ‰§è¡Œæ…¢",
 },
 {
  Strategy: "ä¼˜åŒ–æ‰§è¡Œæ—¶é—´",
  Impact:   "å‡å°‘20%æ‰§è¡Œæ—¶é—´ = å‡å°‘20%æˆæœ¬",
 },
 {
  Strategy: "ä½¿ç”¨ARMæ¶æ„ (Graviton2)",
  Impact:   "æˆæœ¬é™ä½20%,æ€§èƒ½æå‡19%",
 },
 {
  Strategy: "æ‰¹é‡å¤„ç†",
  Impact:   "èšåˆå¤šä¸ªå°è¯·æ±‚,å‡å°‘è°ƒç”¨æ¬¡æ•°",
 },
 {
  Strategy: "å¼‚æ­¥å¤„ç†",
  Impact:   "ä½¿ç”¨SQS/SNSè§£è€¦,é¿å…åŒæ­¥ç­‰å¾…",
 },
}
```

### 7.2 æˆæœ¬ç›‘æ§

```go
package monitoring

import (
 "context"
 "fmt"
 "time"
 
 "github.com/aws/aws-sdk-go-v2/service/cloudwatch"
 "github.com/aws/aws-sdk-go-v2/service/cloudwatch/types"
)

// CostMonitorç›‘æ§Lambdaæˆæœ¬
type CostMonitor struct {
 cwClient *cloudwatch.Client
}

func NewCostMonitor(client *cloudwatch.Client) *CostMonitor {
 return &CostMonitor{cwClient: client}
}

// GetFunctionMetricsè·å–å‡½æ•°æŒ‡æ ‡
func (m *CostMonitor) GetFunctionMetrics(ctx context.Context, functionName string, period time.Duration) (*FunctionMetrics, error) {
 endTime := time.Now()
 startTime := endTime.Add(-period)
 
 // è·å–è°ƒç”¨æ¬¡æ•°
 invocations, err := m.getMetric(ctx, functionName, "Invocations", startTime, endTime)
 if err != nil {
  return nil, err
 }
 
 // è·å–æ‰§è¡Œæ—¶é—´
 duration, err := m.getMetric(ctx, functionName, "Duration", startTime, endTime)
 if err != nil {
  return nil, err
 }
 
 // è·å–é”™è¯¯æ•°
 errors, err := m.getMetric(ctx, functionName, "Errors", startTime, endTime)
 if err != nil {
  return nil, err
 }
 
 return &FunctionMetrics{
  Invocations: invocations,
  Duration:    duration,
  Errors:      errors,
 }, nil
}

type FunctionMetrics struct {
 Invocations float64
 Duration    float64
 Errors      float64
}

func (m *CostMonitor) getMetric(ctx context.Context, functionName, metricName string, start, end time.Time) (float64, error) {
 result, err := m.cwClient.GetMetricStatistics(ctx, &cloudwatch.GetMetricStatisticsInput{
  Namespace:  strPtr("AWS/Lambda"),
  MetricName: &metricName,
  Dimensions: []types.Dimension{
   {
    Name:  strPtr("FunctionName"),
    Value: &functionName,
   },
  },
  StartTime:  &start,
  EndTime:    &end,
  Period:     int32Ptr(300),
  Statistics: []types.Statistic{types.StatisticSum},
 })
 
 if err != nil {
  return 0, err
 }
 
 var sum float64
 for _, dp := range result.Datapoints {
  sum += *dp.Sum
 }
 
 return sum, nil
}

// EstimateCostä¼°ç®—æˆæœ¬
func (m *CostMonitor) EstimateCost(metrics *FunctionMetrics, memoryMB int) float64 {
 // è¯·æ±‚æˆæœ¬
 requestCost := 0.0
 if metrics.Invocations > 1000000 {
  requestCost = (metrics.Invocations - 1000000) / 1000000 * 0.20
 }
 
 // è®¡ç®—æˆæœ¬
 memoryGB := float64(memoryMB) / 1024
 durationSeconds := metrics.Duration / 1000
 gbSeconds := metrics.Invocations * memoryGB * durationSeconds
 
 computeCost := 0.0
 if gbSeconds > 400000 {
  computeCost = (gbSeconds - 400000) * 0.0000166667
 }
 
 return requestCost + computeCost
}

func strPtr(s string) *string {
 return &s
}

func int32Ptr(i int32) *int32 {
 return &i
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleCostMonitoring() {
 // monitor := NewCostMonitor(cwClient)
 // metrics, _ := monitor.GetFunctionMetrics(ctx, "my-function", 24*time.Hour)
 // cost := monitor.EstimateCost(metrics, 512)
 // fmt.Printf("Estimated daily cost: $%.2f\n", cost)
}
```

---

## 8. ç›‘æ§ä¸è°ƒè¯•

### 8.1 ç»“æ„åŒ–æ—¥å¿—

```go
package logging

import (
 "context"
 "encoding/json"
 "log/slog"
 "os"
 
 "github.com/aws/aws-lambda-go/lambdacontext"
)

// åˆå§‹åŒ–ç»“æ„åŒ–æ—¥å¿—
var logger *slog.Logger

func init() {
 logger = slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
  Level: slog.LevelInfo,
 }))
}

// LogWithContextè®°å½•å¸¦ä¸Šä¸‹æ–‡çš„æ—¥å¿—
func LogWithContext(ctx context.Context, level slog.Level, msg string, args ...any) {
 // ä»Lambdaä¸Šä¸‹æ–‡æå–ä¿¡æ¯
 if lc, ok := lambdacontext.FromContext(ctx); ok {
  args = append(args,
   slog.String("request_id", lc.AwsRequestID),
   slog.String("function_name", lambdacontext.FunctionName),
   slog.String("function_version", lambdacontext.FunctionVersion),
  )
 }
 
 logger.Log(ctx, level, msg, args...)
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleStructuredLogging(ctx context.Context) {
 LogWithContext(ctx, slog.LevelInfo, "Processing request",
  slog.String("user_id", "user-123"),
  slog.Int("item_count", 5),
 )
 
 // è¾“å‡º:
 // {"time":"2024-01-15T10:30:00Z","level":"INFO","msg":"Processing request","user_id":"user-123","item_count":5,"request_id":"abc-123","function_name":"my-function","function_version":"$LATEST"}
}
```

### 8.2 åˆ†å¸ƒå¼è¿½è¸ª

```go
package tracing

import (
 "context"
 
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
 "go.opentelemetry.io/otel/sdk/resource"
 sdktrace "go.opentelemetry.io/otel/sdk/trace"
 semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
)

// InitTraceråˆå§‹åŒ–OpenTelemetry
func InitTracer(ctx context.Context) (func(), error) {
 // åˆ›å»ºOTLP exporter
 exporter, err := otlptracegrpc.New(ctx)
 if err != nil {
  return nil, err
 }
 
 // åˆ›å»ºresource
 res, err := resource.New(ctx,
  resource.WithAttributes(
   semconv.ServiceNameKey.String("lambda-service"),
   semconv.ServiceVersionKey.String("1.0.0"),
  ),
 )
 if err != nil {
  return nil, err
 }
 
 // åˆ›å»ºtracer provider
 tp := sdktrace.NewTracerProvider(
  sdktrace.WithBatcher(exporter),
  sdktrace.WithResource(res),
 )
 
 otel.SetTracerProvider(tp)
 
 return func() {
  tp.Shutdown(ctx)
 }, nil
}

// TraceHandleråŒ…è£…Lambda handleræ·»åŠ è¿½è¸ª
func TraceHandler(handler lambda.Handler) lambda.Handler {
 return lambda.NewHandler(func(ctx context.Context, event interface{}) (interface{}, error) {
  tracer := otel.Tracer("lambda")
  ctx, span := tracer.Start(ctx, "lambda-invocation")
  defer span.End()
  
  // è°ƒç”¨åŸå§‹handler
  return handler.Invoke(ctx, event)
 })
}
```

### 8.3 é”™è¯¯å¤„ç†ä¸é‡è¯•

```go
package errorhandling

import (
 "context"
 "errors"
 "fmt"
 "time"
)

// RetryableErrorè¡¨ç¤ºå¯é‡è¯•çš„é”™è¯¯
type RetryableError struct {
 Err error
}

func (e *RetryableError) Error() string {
 return fmt.Sprintf("retryable: %v", e.Err)
}

func (e *RetryableError) Unwrap() error {
 return e.Err
}

// RetryHandlerå®ç°æŒ‡æ•°é€€é¿é‡è¯•
func RetryHandler(ctx context.Context, fn func() error, maxRetries int) error {
 var err error
 backoff := time.Second
 
 for i := 0; i < maxRetries; i++ {
  err = fn()
  if err == nil {
   return nil
  }
  
  // æ£€æŸ¥æ˜¯å¦å¯é‡è¯•
  var retryable *RetryableError
  if !errors.As(err, &retryable) {
   return err // ä¸å¯é‡è¯•,ç›´æ¥è¿”å›
  }
  
  // æœ€åä¸€æ¬¡é‡è¯•ä¸å†ç­‰å¾…
  if i == maxRetries-1 {
   break
  }
  
  // æŒ‡æ•°é€€é¿
  select {
  case <-ctx.Done():
   return ctx.Err()
  case <-time.After(backoff):
   backoff *= 2
   if backoff > 30*time.Second {
    backoff = 30 * time.Second
   }
  }
 }
 
 return fmt.Errorf("max retries exceeded: %w", err)
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleRetry() {
 ctx := context.Background()
 
 err := RetryHandler(ctx, func() error {
  // å¯èƒ½å¤±è´¥çš„æ“ä½œ
  if err := callExternalAPI(); err != nil {
   return &RetryableError{Err: err}
  }
  return nil
 }, 3)
 
 if err != nil {
  fmt.Printf("Operation failed: %v\n", err)
 }
}

func callExternalAPI() error {
 // æ¨¡æ‹ŸAPIè°ƒç”¨
 return nil
}
```

---

## 9. æœ€ä½³å®è·µ

### 9.1 å®‰å…¨æœ€ä½³å®è·µ

```go
// Serverlesså®‰å…¨æ¸…å•
/*
1. âœ… IAMæƒé™æœ€å°åŒ–
   â€¢ åªæˆäºˆå¿…éœ€çš„æƒé™
   â€¢ ä½¿ç”¨IAMè§’è‰²è€ŒéAccessKey
   â€¢ å®šæœŸå®¡è®¡æƒé™

2. âœ… ç¯å¢ƒå˜é‡åŠ å¯†
   â€¢ ä½¿ç”¨KMSåŠ å¯†æ•æ„Ÿé…ç½®
   â€¢ ä¸åœ¨ä»£ç ä¸­ç¡¬ç¼–ç å¯†é’¥
   â€¢ ä½¿ç”¨Secrets Manager

3. âœ… VPCç½‘ç»œéš”ç¦»
   â€¢ æ•°æ®åº“æ”¾åœ¨private subnet
   â€¢ ä½¿ç”¨Security Groupé™åˆ¶è®¿é—®
   â€¢ NAT Gatewayè®¿é—®å¤–ç½‘

4. âœ… API Gatewayè®¤è¯
   â€¢ ä½¿ç”¨API Key
   â€¢ JWT TokenéªŒè¯
   â€¢ AWS IAMæˆæƒ

5. âœ… è¾“å…¥éªŒè¯
   â€¢ éªŒè¯æ‰€æœ‰è¾“å…¥å‚æ•°
   â€¢ é˜²æ­¢SQLæ³¨å…¥
   â€¢ é™åˆ¶è¯·æ±‚å¤§å°

6. âœ… å®¡è®¡æ—¥å¿—
   â€¢ å¯ç”¨CloudTrail
   â€¢ è®°å½•æ‰€æœ‰APIè°ƒç”¨
   â€¢ è®¾ç½®å‘Šè­¦è§„åˆ™
*/

// ç¤ºä¾‹: KMSåŠ å¯†çš„ç¯å¢ƒå˜é‡
package security

import (
 "context"
 "encoding/base64"
 "os"
 
 "github.com/aws/aws-sdk-go-v2/service/kms"
)

type SecretManager struct {
 kmsClient *kms.Client
}

func (sm *SecretManager) GetSecret(ctx context.Context, envKey string) (string, error) {
 // ä»ç¯å¢ƒå˜é‡è·å–åŠ å¯†çš„å€¼
 encrypted := os.Getenv(envKey)
 if encrypted == "" {
  return "", nil
 }
 
 // Base64è§£ç 
 ciphertext, err := base64.StdEncoding.DecodeString(encrypted)
 if err != nil {
  return "", err
 }
 
 // KMSè§£å¯†
 result, err := sm.kmsClient.Decrypt(ctx, &kms.DecryptInput{
  CiphertextBlob: ciphertext,
 })
 if err != nil {
  return "", err
 }
 
 return string(result.Plaintext), nil
}
```

### 9.2 æ€§èƒ½æœ€ä½³å®è·µ

```go
// Serverlessæ€§èƒ½ä¼˜åŒ–æ¸…å•
/*
1. âœ… è¿æ¥å¤ç”¨
   â€¢ ä½¿ç”¨å…¨å±€å˜é‡ä¿æŒæ•°æ®åº“è¿æ¥
   â€¢ å¤ç”¨HTTPå®¢æˆ·ç«¯
   â€¢ ä½¿ç”¨è¿æ¥æ± 

2. âœ… å¹¶è¡Œå¤„ç†
   â€¢ ä½¿ç”¨goroutineå¹¶è¡Œè°ƒç”¨
   â€¢ æ‰¹é‡å¤„ç†è®°å½•
   â€¢ å¼‚æ­¥éé˜»å¡

3. âœ… ç¼“å­˜ç­–ç•¥
   â€¢ Lambda Extensionç¼“å­˜
   â€¢ ElastiCacheé›†ä¸­ç¼“å­˜
   â€¢ API Gatewayç¼“å­˜

4. âœ… é€‰æ‹©åˆé€‚çš„å†…å­˜
   â€¢ å†…å­˜ âˆ CPUæ€§èƒ½
   â€¢ Benchmarkæµ‹è¯•æœ€ä¼˜å€¼
   â€¢ æˆæœ¬ä¸æ€§èƒ½å¹³è¡¡

5. âœ… å‡å°‘å†·å¯åŠ¨
   â€¢ æœ€å°åŒ–ä¾èµ–
   â€¢ å»¶è¿Ÿåˆå§‹åŒ–
   â€¢ Provisioned Concurrency

6. âœ… å¼‚æ­¥è§£è€¦
   â€¢ é•¿æ—¶é—´ä»»åŠ¡å¼‚æ­¥åŒ–
   â€¢ ä½¿ç”¨SQS/SNS
   â€¢ Step Functionsç¼–æ’
*/

package performance

import (
 "context"
 "sync"
)

// ParallelProcessorå¹¶è¡Œå¤„ç†å™¨
type ParallelProcessor struct {
 maxWorkers int
}

func NewParallelProcessor(maxWorkers int) *ParallelProcessor {
 return &ParallelProcessor{maxWorkers: maxWorkers}
}

// Processå¹¶è¡Œå¤„ç†items
func (p *ParallelProcessor) Process(ctx context.Context, items []string, process func(string) error) error {
 sem := make(chan struct{}, p.maxWorkers)
 var wg sync.WaitGroup
 errChan := make(chan error, len(items))
 
 for _, item := range items {
  wg.Add(1)
  go func(item string) {
   defer wg.Done()
   
   sem <- struct{}{}        // è·å–ä»¤ç‰Œ
   defer func() { <-sem }() // é‡Šæ”¾ä»¤ç‰Œ
   
   if err := process(item); err != nil {
    errChan <- err
   }
  }(item)
 }
 
 wg.Wait()
 close(errChan)
 
 // è¿”å›ç¬¬ä¸€ä¸ªé”™è¯¯
 select {
 case err := <-errChan:
  return err
 default:
  return nil
 }
}
```

---

## 10. å®Œæ•´é¡¹ç›®ç¤ºä¾‹

### 10.1 é¡¹ç›®ç»“æ„

```text
serverless-image-processor/
â”œâ”€â”€ cmd/
â”‚   â”œâ”€â”€ upload/        # ä¸Šä¼ API
â”‚   â”œâ”€â”€ process/       # å›¾ç‰‡å¤„ç†
â”‚   â””â”€â”€ notify/        # é€šçŸ¥æœåŠ¡
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ storage/       # S3æ“ä½œ
â”‚   â”œâ”€â”€ processor/     # å›¾ç‰‡å¤„ç†é€»è¾‘
â”‚   â””â”€â”€ notification/  # é€šçŸ¥é€»è¾‘
â”œâ”€â”€ pkg/
â”‚   â”œâ”€â”€ models/        # æ•°æ®æ¨¡å‹
â”‚   â””â”€â”€ utils/         # å·¥å…·å‡½æ•°
â”œâ”€â”€ serverless.yml     # Serverlessé…ç½®
â”œâ”€â”€ Makefile          # æ„å»ºè„šæœ¬
â””â”€â”€ go.mod
```

### 10.2 ä¸Šä¼ API

```go
// cmd/upload/main.go
package main

import (
 "context"
 "encoding/json"
 "fmt"
 "time"
 
 "github.com/aws/aws-lambda-go/events"
 "github.com/aws/aws-lambda-go/lambda"
 "github.com/aws/aws-sdk-go-v2/config"
 "github.com/aws/aws-sdk-go-v2/service/s3"
 "github.com/google/uuid"
)

var s3Client *s3.Client

func init() {
 cfg, _ := config.LoadDefaultConfig(context.Background())
 s3Client = s3.NewFromConfig(cfg)
}

type UploadRequest struct {
 FileName string `json:"file_name"`
 FileType string `json:"file_type"`
}

type UploadResponse struct {
 UploadURL string `json:"upload_url"`
 FileID    string `json:"file_id"`
}

// Handlerç”Ÿæˆé¢„ç­¾åä¸Šä¼ URL
func Handler(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
 var req UploadRequest
 if err := json.Unmarshal([]byte(request.Body), &req); err != nil {
  return errorResponse(400, "Invalid request")
 }
 
 // ç”Ÿæˆå”¯ä¸€æ–‡ä»¶ID
 fileID := uuid.New().String()
 key := fmt.Sprintf("uploads/%s/%s", fileID, req.FileName)
 
 // ç”Ÿæˆé¢„ç­¾åURL (15åˆ†é’Ÿæœ‰æ•ˆ)
 presigner := s3.NewPresignClient(s3Client)
 presignedReq, err := presigner.PresignPutObject(ctx, &s3.PutObjectInput{
  Bucket:      strPtr("my-image-bucket"),
  Key:         &key,
  ContentType: &req.FileType,
 }, s3.WithPresignExpires(15*time.Minute))
 
 if err != nil {
  return errorResponse(500, "Failed to generate upload URL")
 }
 
 // è¿”å›å“åº”
 response := UploadResponse{
  UploadURL: presignedReq.URL,
  FileID:    fileID,
 }
 
 return jsonResponse(200, response)
}

func jsonResponse(status int, data interface{}) (events.APIGatewayProxyResponse, error) {
 body, _ := json.Marshal(data)
 return events.APIGatewayProxyResponse{
  StatusCode: status,
  Body:       string(body),
  Headers: map[string]string{
   "Content-Type":                "application/json",
   "Access-Control-Allow-Origin": "*",
  },
 }, nil
}

func errorResponse(status int, message string) (events.APIGatewayProxyResponse, error) {
 return jsonResponse(status, map[string]string{"error": message})
}

func strPtr(s string) *string {
 return &s
}

func main() {
 lambda.Start(Handler)
}
```

### 10.3 å›¾ç‰‡å¤„ç†å‡½æ•°

```go
// cmd/process/main.go
package main

import (
 "bytes"
 "context"
 "fmt"
 "image"
 "image/jpeg"
 "image/png"
 
 "github.com/aws/aws-lambda-go/events"
 "github.com/aws/aws-lambda-go/lambda"
 "github.com/aws/aws-sdk-go-v2/config"
 "github.com/aws/aws-sdk-go-v2/service/s3"
 "github.com/nfnt/resize"
)

var s3Client *s3.Client

func init() {
 cfg, _ := config.LoadDefaultConfig(context.Background())
 s3Client = s3.NewFromConfig(cfg)
}

// Handlerå¤„ç†S3ä¸Šä¼ äº‹ä»¶
func Handler(ctx context.Context, s3Event events.S3Event) error {
 for _, record := range s3Event.Records {
  bucket := record.S3.Bucket.Name
  key := record.S3.Object.Key
  
  fmt.Printf("Processing: s3://%s/%s\n", bucket, key)
  
  // å¤„ç†å›¾ç‰‡
  if err := processImage(ctx, bucket, key); err != nil {
   fmt.Printf("Error processing image: %v\n", err)
   return err
  }
 }
 
 return nil
}

func processImage(ctx context.Context, bucket, key string) error {
 // 1. ä»S3ä¸‹è½½åŸå§‹å›¾ç‰‡
 result, err := s3Client.GetObject(ctx, &s3.GetObjectInput{
  Bucket: &bucket,
  Key:    &key,
 })
 if err != nil {
  return fmt.Errorf("get object: %w", err)
 }
 defer result.Body.Close()
 
 // 2. è§£ç å›¾ç‰‡
 img, format, err := image.Decode(result.Body)
 if err != nil {
  return fmt.Errorf("decode image: %w", err)
 }
 
 fmt.Printf("Original image: %dx%d, format: %s\n", img.Bounds().Dx(), img.Bounds().Dy(), format)
 
 // 3. ç”Ÿæˆå¤šä¸ªå°ºå¯¸çš„ç¼©ç•¥å›¾
 thumbnails := []struct {
  name   string
  width  uint
  height uint
 }{
  {"small", 150, 150},
  {"medium", 300, 300},
  {"large", 600, 600},
 }
 
 for _, thumb := range thumbnails {
  resized := resize.Thumbnail(thumb.width, thumb.height, img, resize.Lanczos3)
  
  // ä¸Šä¼ ç¼©ç•¥å›¾
  thumbKey := fmt.Sprintf("thumbnails/%s/%s", thumb.name, key)
  if err := uploadImage(ctx, bucket, thumbKey, resized, format); err != nil {
   return fmt.Errorf("upload thumbnail: %w", err)
  }
  
  fmt.Printf("Generated thumbnail: %s (%dx%d)\n", thumb.name, resized.Bounds().Dx(), resized.Bounds().Dy())
 }
 
 return nil
}

func uploadImage(ctx context.Context, bucket, key string, img image.Image, format string) error {
 // ç¼–ç å›¾ç‰‡
 var buf bytes.Buffer
 switch format {
 case "jpeg", "jpg":
  jpeg.Encode(&buf, img, &jpeg.Options{Quality: 90})
 case "png":
  png.Encode(&buf, img)
 default:
  return fmt.Errorf("unsupported format: %s", format)
 }
 
 // ä¸Šä¼ åˆ°S3
 _, err := s3Client.PutObject(ctx, &s3.PutObjectInput{
  Bucket:      &bucket,
  Key:         &key,
  Body:        bytes.NewReader(buf.Bytes()),
  ContentType: strPtr(fmt.Sprintf("image/%s", format)),
 })
 
 return err
}

func strPtr(s string) *string {
 return &s
}

func main() {
 lambda.Start(Handler)
}
```

### 10.4 å®Œæ•´Serverlessé…ç½®

```yaml
# serverless.yml
service: serverless-image-processor

provider:
  name: aws
  runtime: go1.x
  region: us-east-1
  stage: ${opt:stage, 'dev'}
  memorySize: 512
  timeout: 60
  
  environment:
    BUCKET_NAME: ${self:custom.bucketName}
    STAGE: ${self:provider.stage}
  
  iam:
    role:
      statements:
        - Effect: Allow
          Action:
            - s3:GetObject
            - s3:PutObject
          Resource: "arn:aws:s3:::${self:custom.bucketName}/*"
        - Effect: Allow
          Action:
            - sns:Publish
          Resource: !Ref NotificationTopic

custom:
  bucketName: image-processor-${self:provider.stage}

functions:
  # ä¸Šä¼ API
  upload:
    handler: bin/upload
    events:
      - http:
          path: /upload
          method: post
          cors: true
    environment:
      BUCKET: ${self:custom.bucketName}
  
  # å›¾ç‰‡å¤„ç†
  process:
    handler: bin/process
    events:
      - s3:
          bucket: ${self:custom.bucketName}
          event: s3:ObjectCreated:*
          rules:
            - prefix: uploads/
            - suffix: .jpg
      - s3:
          bucket: ${self:custom.bucketName}
          event: s3:ObjectCreated:*
          rules:
            - prefix: uploads/
            - suffix: .png
    memorySize: 1024  # å›¾ç‰‡å¤„ç†éœ€è¦æ›´å¤šå†…å­˜
  
  # é€šçŸ¥æœåŠ¡
  notify:
    handler: bin/notify
    events:
      - sns:
          arn: !Ref NotificationTopic
          topicName: ImageProcessingComplete

resources:
  Resources:
    # SNS Topic
    NotificationTopic:
      Type: AWS::SNS::Topic
      Properties:
        TopicName: ImageProcessingComplete-${self:provider.stage}
    
    # DLQ for failed processing
    ProcessDLQ:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: image-process-dlq-${self:provider.stage}
        MessageRetentionPeriod: 1209600  # 14 days

package:
  individually: true
  patterns:
    - '!./**'
    - ./bin/**
```

### 10.5 æ€§èƒ½ç›‘æ§Dashboard

```go
// internal/monitoring/dashboard.go
package monitoring

import (
 "context"
 "fmt"
 "time"
 
 "github.com/aws/aws-sdk-go-v2/service/cloudwatch"
 "github.com/aws/aws-sdk-go-v2/service/cloudwatch/types"
)

// Dashboardåˆ›å»ºCloudWatch Dashboard
func CreateDashboard(ctx context.Context, cwClient *cloudwatch.Client, functionName string) error {
 dashboardBody := fmt.Sprintf(`{
  "widgets": [
   {
    "type": "metric",
    "properties": {
     "title": "Invocations",
     "metrics": [
      ["AWS/Lambda", "Invocations", {"stat": "Sum"}]
     ],
     "period": 300,
     "region": "us-east-1"
    }
   },
   {
    "type": "metric",
    "properties": {
     "title": "Duration",
     "metrics": [
      ["AWS/Lambda", "Duration", {"stat": "Average"}],
      [".", ".", {"stat": "Maximum"}]
     ],
     "period": 300
    }
   },
   {
    "type": "metric",
    "properties": {
     "title": "Errors",
     "metrics": [
      ["AWS/Lambda", "Errors", {"stat": "Sum"}],
      [".", "Throttles", {"stat": "Sum"}]
     ],
     "period": 300
    }
   },
   {
    "type": "metric",
    "properties": {
     "title": "Concurrent Executions",
     "metrics": [
      ["AWS/Lambda", "ConcurrentExecutions", {"stat": "Maximum"}]
     ],
     "period": 60
    }
   }
  ]
 }`, functionName)
 
 _, err := cwClient.PutDashboard(ctx, &cloudwatch.PutDashboardInput{
  DashboardName: strPtr(fmt.Sprintf("%s-dashboard", functionName)),
  DashboardBody: &dashboardBody,
 })
 
 return err
}

// CreateAlarmsåˆ›å»ºå‘Šè­¦è§„åˆ™
func CreateAlarms(ctx context.Context, cwClient *cloudwatch.Client, functionName, snsTopicARN string) error {
 alarms := []struct {
  name      string
  metric    string
  threshold float64
  operator  types.ComparisonOperator
 }{
  {
   name:      "HighErrorRate",
   metric:    "Errors",
   threshold: 10,
   operator:  types.ComparisonOperatorGreaterThanThreshold,
  },
  {
   name:      "HighDuration",
   metric:    "Duration",
   threshold: 5000,
   operator:  types.ComparisonOperatorGreaterThanThreshold,
  },
  {
   name:      "Throttles",
   metric:    "Throttles",
   threshold: 1,
   operator:  types.ComparisonOperatorGreaterThanOrEqualToThreshold,
  },
 }
 
 for _, alarm := range alarms {
  _, err := cwClient.PutMetricAlarm(ctx, &cloudwatch.PutMetricAlarmInput{
   AlarmName:          strPtr(fmt.Sprintf("%s-%s", functionName, alarm.name)),
   ComparisonOperator: alarm.operator,
   EvaluationPeriods:  int32Ptr(2),
   MetricName:         &alarm.metric,
   Namespace:          strPtr("AWS/Lambda"),
   Period:             int32Ptr(300),
   Statistic:          types.StatisticSum,
   Threshold:          &alarm.threshold,
   ActionsEnabled:     boolPtr(true),
   AlarmActions:       []string{snsTopicARN},
   Dimensions: []types.Dimension{
    {
     Name:  strPtr("FunctionName"),
     Value: &functionName,
    },
   },
  })
  
  if err != nil {
   return err
  }
 }
 
 return nil
}

func strPtr(s string) *string { return &s }
func int32Ptr(i int32) *int32 { return &i }
func boolPtr(b bool) *bool    { return &b }
```

---

## æ€»ç»“

### Serverlessæ¶æ„æ¼”è¿›è·¯å¾„

```text
1. èµ·æ­¥é˜¶æ®µ:
   â€¢ ç®€å•çš„HTTP API
   â€¢ å®šæ—¶ä»»åŠ¡
   â€¢ äº‹ä»¶å“åº”

2. æˆé•¿é˜¶æ®µ:
   â€¢ å¾®æœåŠ¡æ‹†åˆ†
   â€¢ äº‹ä»¶é©±åŠ¨æ¶æ„
   â€¢ å¼‚æ­¥å¤„ç†

3. æˆç†Ÿé˜¶æ®µ:
   â€¢ æ··åˆæ¶æ„ (Serverless + Container)
   â€¢ å®Œæ•´å¯è§‚æµ‹æ€§
   â€¢ æˆæœ¬ä¼˜åŒ–

4. æœ€ä½³å®è·µ:
   âœ… å®‰å…¨ç¬¬ä¸€
   âœ… ç›‘æ§å®Œå–„
   âœ… æˆæœ¬å¯æ§
   âœ… æ€§èƒ½ä¼˜åŒ–
```

### å…³é”®è¦ç‚¹

1. **Goè¯­è¨€ä¼˜åŠ¿**: å¯åŠ¨å¿«ã€å†…å­˜å°ã€æ€§èƒ½å¼º
2. **æˆæœ¬ä¼˜åŒ–**: æŒ‰ç”¨é‡è®¡è´¹,åˆç†é…ç½®å†…å­˜
3. **å†·å¯åŠ¨ä¼˜åŒ–**: å»¶è¿Ÿåˆå§‹åŒ–,è¿æ¥å¤ç”¨,Provisioned Concurrency
4. **å®‰å…¨å®è·µ**: IAMæœ€å°æƒé™,KMSåŠ å¯†,VPCéš”ç¦»
5. **ç›‘æ§ä½“ç³»**: ç»“æ„åŒ–æ—¥å¿—,åˆ†å¸ƒå¼è¿½è¸ª,CloudWatchå‘Šè­¦

### é€‚ç”¨åœºæ™¯

- âœ… Web/Mobileåç«¯API
- âœ… æ•°æ®ETLç®¡é“
- âœ… å®æ—¶æ–‡ä»¶å¤„ç†
- âœ… å®šæ—¶ä»»åŠ¡
- âœ… IoTæ•°æ®å¤„ç†
- âœ… Webhookå¤„ç†
- âœ… äº‹ä»¶é©±åŠ¨æ¶æ„

**ç›¸å…³æ–‡æ¡£:**

- [äº‘åŸç”Ÿéƒ¨ç½²](10-Go-1.25.3äº‘åŸç”Ÿå®Œæ•´å®æˆ˜.md)
- [å¾®æœåŠ¡æ¶æ„](09-Go-1.25.3å¾®æœåŠ¡æ¶æ„å®Œæ•´å®æˆ˜.md)
- [åˆ†å¸ƒå¼è¿½è¸ª](23-Go-1.25.3åˆ†å¸ƒå¼è¿½è¸ªä¸å¯è§‚æµ‹æ€§å®Œæ•´å®æˆ˜.md)
