# 垃圾回收器详解

## 📋 目录


- [1. GC概述](#1.-gc概述)
  - [Go GC特点](#go-gc特点)
  - [与其他GC对比](#与其他gc对比)
- [2. 三色标记算法](#2.-三色标记算法)
  - [三色抽象](#三色抽象)
  - [标记流程](#标记流程)
  - [并发标记问题](#并发标记问题)
- [3. 写屏障](#写屏障类型)
  - [写屏障类型](#写屏障类型)
    - [1. Dijkstra插入写屏障](#1.-dijkstra插入写屏障)
    - [2. Yuasa删除写屏障](#2.-yuasa删除写屏障)
    - [3. 混合写屏障 (Go 1.8+)](#3.-混合写屏障-go-1.8)
  - [写屏障实现](#写屏障实现)
- [4. GC触发机制](#4.-gc触发机制)
  - [触发条件](#触发条件)
    - [1. 内存增长触发](#1.-内存增长触发)
    - [2. 定时触发](#2.-定时触发)
    - [3. 手动触发](#3.-手动触发)
  - [GC Pacer](#gc-pacer)
- [5. GC执行流程](#5.-gc执行流程)
  - [完整GC周期](#完整gc周期)
  - [详细阶段分析](#详细阶段分析)
    - [Phase 1: Sweep Termination (STW ~10μs)](#phase-1-sweep-termination-stw-10s)
    - [Phase 2: Mark Setup](#phase-2-mark-setup)
    - [Phase 3: Concurrent Mark (并发，与应用并行)](#phase-3-concurrent-mark-并发与应用并行)
    - [Phase 4: Mark Termination (STW ~50μs)](#phase-4-mark-termination-stw-50s)
    - [Phase 5: Concurrent Sweep (并发，与应用并行)](#phase-5-concurrent-sweep-并发与应用并行)
  - [GC时间分布](#gc时间分布)
- [6. GC调优](#6.-gc调优)
  - [GOGC参数](#gogc参数)
  - [内存限制 (Go 1.19+)](#内存限制-go-1.19)
  - [减少GC压力](#减少gc压力)
    - [1. 预分配](#1.-预分配)
    - [2. 对象池](#2.-对象池)
    - [3. 减少指针](#3.-减少指针)
  - [GC监控](#gc监控)
- [7. GC演进历史](#7.-gc演进历史)
  - [Go 1.0 - 1.4: 标记-清扫](#go-1.0-1.4-标记-清扫)
  - [Go 1.5: 并发标记](#go-1.5-并发标记)
  - [Go 1.6-1.7: 优化](#go-1.6-1.7-优化)
  - [Go 1.8: 混合写屏障](#go-1.8-混合写屏障)
  - [Go 1.9-1.11: 持续优化](#go-1.9-1.11-持续优化)
  - [Go 1.12-1.18: 精细调优](#go-1.12-1.18-精细调优)
  - [Go 1.19+: 软内存限制](#go-1.19-软内存限制)
  - [Go 1.25: 最新优化](#go-1.25-最新优化)
- [8. 最佳实践](#8.-最佳实践)
  - [实践1: 合理设置GOGC](#实践1-合理设置gogc)
  - [实践2: 使用内存限制](#实践2-使用内存限制)
  - [实践3: 减少分配](#实践3-减少分配)
  - [实践4: 监控GC](#实践4-监控gc)
  - [实践5: 压测验证](#实践5-压测验证)
  - [GC优化清单](#gc优化清单)
- [🔗 相关资源](#相关资源)

## 1. GC概述

### Go GC特点

**核心特性**:
- ✅ **并发标记**: 与应用并行运行
- ✅ **低延迟**: STW时间 < 100μs
- ✅ **三色标记**: 精确GC
- ✅ **写屏障**: 保证并发正确性
- ✅ **增量回收**: 分步执行

**Go 1.25 GC性能**:

| 指标 | 值 | 说明 |
|------|-----|------|
| STW时间 | < 100μs | 极短暂停 |
| GC CPU占用 | < 25% | 可配置 |
| 最大堆 | 数百GB | 大内存支持 |
| GC吞吐 | > 95% | 应用运行占比 |

---

### 与其他GC对比

| GC类型 | 代表 | 延迟 | 吞吐 | 实现复杂度 |
|--------|------|------|------|------------|
| **并发标记清除** | Go | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **分代GC** | JVM | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **引用计数** | Python | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ |
| **手动管理** | C/C++ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐ |

---

## 2. 三色标记算法

### 三色抽象

**颜色定义**:

- **白色 (White)**: 未扫描对象
  - 可能是垃圾
  - GC结束后仍为白色 → 回收

- **灰色 (Grey)**: 已扫描对象，但引用未扫描
  - 确定存活
  - 等待扫描引用

- **黑色 (Black)**: 已扫描对象，引用也已扫描
  - 确定存活
  - 不会再扫描

---

### 标记流程

```
初始状态:
所有对象: 白色

第1步: 标记根对象
栈/全局变量 → 灰色

第2步: 扫描灰色对象
for 灰色对象 in 灰色队列:
    for 引用 in 灰色对象.引用:
        if 引用 == 白色:
            引用 → 灰色
    灰色对象 → 黑色

第3步: 清除白色对象
for 对象 in 堆:
    if 对象 == 白色:
        回收(对象)
```

**示例**:

```
初始:
A(白) → B(白) → C(白)
         ↓
        D(白)

根对象A标记为灰:
A(灰) → B(白) → C(白)
         ↓
        D(白)

扫描A:
A(黑) → B(灰) → C(白)
         ↓
        D(灰)

扫描B:
A(黑) → B(黑) → C(灰)
         ↓
        D(黑)

扫描C:
A(黑) → B(黑) → C(黑)
         ↓
        D(黑)

所有可达对象: 黑色
白色对象: 垃圾
```

---

### 并发标记问题

**问题**: 应用与GC并发时，可能出现"漏标"

```
初始:
A(黑) → B(灰) → C(白)

应用线程执行:
1. A.next = C  (黑色A指向白色C)
2. B.next = nil (灰色B断开C)

结果:
A(黑) → C(白)
B(灰) → nil

问题: C变成了"浮动垃圾"，但实际可达
```

**解决方案**: 写屏障

---

## 3. 写屏障

### 写屏障类型

#### 1. Dijkstra插入写屏障

**原理**: 在插入指针时，将新对象标记为灰色

```go
// 伪代码
func writePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) {
    shade(ptr)  // 标记为灰色
    *slot = ptr
}
```

**特点**:
- ✅ 保证不漏标
- ❌ 可能产生浮动垃圾（本轮不回收）
- ❌ 需要栈重扫描

---

#### 2. Yuasa删除写屏障

**原理**: 在删除指针前，将旧对象标记为灰色

```go
func writePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) {
    shade(*slot)  // 标记旧值为灰色
    *slot = ptr
}
```

**特点**:
- ✅ 保证不漏标
- ❌ 浮动垃圾更多
- ✅ 不需要栈重扫描

---

#### 3. 混合写屏障 (Go 1.8+)

**原理**: 结合插入和删除写屏障

```go
// runtime/mbarrier.go (简化)
func writePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) {
    // 1. 标记旧值 (删除屏障)
    shade(*slot)
    
    // 2. 标记新值 (插入屏障)
    shade(ptr)
    
    // 3. 更新指针
    *slot = ptr
}
```

**优势**:
- ✅ 不需要栈重扫描
- ✅ STW时间更短
- ✅ 减少浮动垃圾

---

### 写屏障实现

```go
// runtime/mbarrier.go
func gcWriteBarrier(dst *uintptr, src uintptr) {
    if writeBarrier.enabled {
        // 快速路径: 如果src已标记，直接返回
        if src != 0 && (src>>_PageShift) != 0 {
            systemstack(func() {
                gcWriteBarrierSlow(dst, src)
            })
        }
    }
    *dst = src
}

func gcWriteBarrierSlow(dst *uintptr, src uintptr) {
    // 将对象加入扫描队列
    wbBufFlush(nil, 0)
    gcmarknewobject(uintptr(unsafe.Pointer(src)))
}
```

---

## 4. GC触发机制

### 触发条件

#### 1. 内存增长触发

```go
// runtime/mgc.go
func shouldtriggergc() bool {
    return memstats.heap_live >= memstats.gc_trigger
}

// gc_trigger计算
// goal = live + live * GOGC / 100
// 例: GOGC=100, live=100MB
// trigger = 100MB + 100MB * 100 / 100 = 200MB
```

**GOGC参数**:
- 默认: 100 (堆翻倍时触发)
- GOGC=50: 更频繁GC，内存占用低
- GOGC=200: 更少GC，内存占用高
- GOGC=off: 禁用自动GC

---

#### 2. 定时触发

```go
// runtime/proc.go
func forcegchelper() {
    for {
        // 2分钟未GC，强制触发
        if atomic.Load(&forcegc.idle) == 0 {
            gcStart(gcTriggerTime, gcBackgroundMode)
        }
        goparkunlock(&forcegc.lock, waitReasonForceGCIdle, traceEvGoBlock, 1)
    }
}
```

---

#### 3. 手动触发

```go
// 程序中调用
runtime.GC()

// 会阻塞到GC完成
```

---

### GC Pacer

**自适应调整触发阈值**:

```go
// runtime/mgc.go
type gcControllerState struct {
    // 目标堆大小
    heapGoal uint64
    
    // 当前扫描进度
    scanWork int64
    
    // 辅助标记比例
    assistRatio float64
    
    // CPU目标 (默认25%)
    bgMarkCPULimiter *time.Ticker
}

func (c *gcControllerState) trigger() uint64 {
    // 计算触发点
    goal := c.heapGoal
    trigger := goal - goal/(1+c.triggerRatio)
    return trigger
}
```

---

## 5. GC执行流程

### 完整GC周期

```go
// runtime/mgc.go (简化)
func gcStart(trigger gcTrigger, mode gcMode) {
    // ============ Phase 1: Sweep Termination ============
    systemstack(stopTheWorldWithSema)  // STW ~10μs
    
    // 完成上次GC的清扫
    finishsweep_m()
    
    // ============ Phase 2: Mark Setup ============
    gcBgMarkPrepare()  // 准备后台标记
    
    systemstack(startTheWorldWithSema)  // Start The World
    
    // ============ Phase 3: Concurrent Mark ============
    gcBgMarkWorker()  // 并发标记（与应用并行）
    
    // ============ Phase 4: Mark Termination ============
    systemstack(stopTheWorldWithSema)  // STW ~50μs
    
    gcMarkTermination()  // 完成标记
    
    systemstack(startTheWorldWithSema)  // Start The World
    
    // ============ Phase 5: Concurrent Sweep ============
    sweep()  // 并发清扫（与应用并行）
}
```

---

### 详细阶段分析

#### Phase 1: Sweep Termination (STW ~10μs)

```go
func finishsweep_m() {
    // 完成上次GC的清扫工作
    for sweepone() != ^uintptr(0) {
        sweep.nbgsweep++
    }
}
```

**作用**: 确保上轮GC的清扫完成

---

#### Phase 2: Mark Setup

```go
func gcBgMarkPrepare() {
    // 初始化标记worker
    work.nproc = gomaxprocs
    work.nwait = 0
    work.ndone = 0
    
    // 启动标记worker
    gcBgMarkStartWorkers()
}
```

**作用**: 准备标记环境，启动worker

---

#### Phase 3: Concurrent Mark (并发，与应用并行)

```go
func gcBgMarkWorker() {
    for {
        // 扫描根对象
        gcMarkRootCheck()
        
        // 扫描灰色对象
        for {
            // 从队列获取灰色对象
            b := gcw.tryGetFast()
            if b == 0 {
                b = gcw.tryGet()
                if b == 0 {
                    break
                }
            }
            
            // 扫描对象
            scanobject(b, gcw)
        }
        
        // 检查是否完成
        if work.nwait == work.nproc {
            break
        }
    }
}
```

**作用**: 标记所有可达对象

**辅助标记**:
```go
// 如果应用分配过快，协助标记
func gcAssistAlloc() {
    // 根据分配量决定辅助时间
    assistWorkPerByte := gcController.assistWorkPerByte.Load()
    debtBytes := gcController.assistBytesPerWork * float64(assistWorkPerByte)
    
    // 执行辅助标记
    gcAssistAlloc1(debtBytes)
}
```

---

#### Phase 4: Mark Termination (STW ~50μs)

```go
func gcMarkTermination() {
    // 1. 禁用写屏障
    setGCPhase(_GCoff)
    
    // 2. 唤醒等待的finalizer
    wakefing()
    
    // 3. 更新统计
    memstats.numgc++
    
    // 4. 准备清扫
    prepareFreeWorkbufs()
    
    // 5. 启动清扫
    systemstack(func() {
        gcMarkDone()
    })
}
```

**作用**: 完成标记，准备清扫

---

#### Phase 5: Concurrent Sweep (并发，与应用并行)

```go
func sweep() {
    // 后台清扫
    for {
        npages := sweepone()
        if npages == ^uintptr(0) {
            break  // 清扫完成
        }
        
        // 归还内存给OS
        if npages > 0 {
            mheap_.scavenge(int64(npages << _PageShift))
        }
    }
}
```

**作用**: 回收白色对象，释放内存

---

### GC时间分布

```
总GC时间: ~10ms (100MB堆)

STW1 (Sweep Term):     ~10μs  (0.1%)
Mark Setup:            ~100μs (1%)
Concurrent Mark:       ~8ms   (80%) ← 并发
STW2 (Mark Term):      ~50μs  (0.5%)
Concurrent Sweep:      ~1.8ms (18%) ← 并发

应用暂停时间: 10μs + 50μs = 60μs
```

---

## 6. GC调优

### GOGC参数

```bash
# 默认: GOGC=100 (堆翻倍时触发)
export GOGC=100

# 更频繁GC: 降低内存占用
export GOGC=50

# 更少GC: 提高吞吐量
export GOGC=200

# 禁用自动GC
export GOGC=off
```

**选择建议**:

| 场景 | GOGC | 理由 |
|------|------|------|
| 内存受限 | 50 | 降低峰值内存 |
| 延迟敏感 | 100 | 平衡性能 |
| 吞吐优先 | 200 | 减少GC频率 |
| 批处理 | 300+ | 最大化吞吐 |

---

### 内存限制 (Go 1.19+)

```go
import "runtime/debug"

// 设置1GB内存限制
debug.SetMemoryLimit(1 << 30)

// 获取当前限制
limit := debug.SetMemoryLimit(-1)
```

**优势**:
- 防止OOM
- 自动调整GC频率
- 优于GOGC

---

### 减少GC压力

#### 1. 预分配

```go
// ❌ 频繁扩容
s := []int{}
for i := 0; i < 10000; i++ {
    s = append(s, i)  // 多次扩容+复制
}

// ✅ 预分配
s := make([]int, 0, 10000)
for i := 0; i < 10000; i++ {
    s = append(s, i)  // 无扩容
}
```

---

#### 2. 对象池

```go
var pool = sync.Pool{
    New: func() interface{} {
        return &Buffer{}
    },
}

func process() {
    buf := pool.Get().(*Buffer)
    defer pool.Put(buf)
    // 使用buf...
}
```

---

#### 3. 减少指针

```go
// ❌ 大量指针，GC扫描慢
type Node struct {
    Data *Data
    Next *Node
}

// ✅ 减少指针，GC扫描快
type Node struct {
    Data Data   // 值类型
    Next *Node
}
```

---

### GC监控

```go
// 1. MemStats
var m runtime.MemStats
runtime.ReadMemStats(&m)
fmt.Printf("NumGC: %d\n", m.NumGC)
fmt.Printf("PauseTotal: %v\n", time.Duration(m.PauseTotalNs))
fmt.Printf("PauseAvg: %v\n", time.Duration(m.PauseTotalNs)/time.Duration(m.NumGC))

// 2. GCStats
var stats debug.GCStats
debug.ReadGCStats(&stats)
fmt.Printf("NumGC: %d\n", stats.NumGC)
fmt.Printf("PauseTotal: %v\n", stats.PauseTotal)

// 3. Trace
// go tool trace trace.out
```

---

## 7. GC演进历史

### Go 1.0 - 1.4: 标记-清扫

- Stop-The-World
- STW时间: 数百ms到数秒
- 不适合生产环境

---

### Go 1.5: 并发标记

- **重大突破**: 并发三色标记
- STW降至 ~10ms
- 引入写屏障
- 目标: 控制延迟 < 10ms

---

### Go 1.6-1.7: 优化

- 减少STW时间到 ~1ms
- 优化栈扫描
- 改进Pacer

---

### Go 1.8: 混合写屏障

- **关键优化**: 无需栈重扫描
- STW降至 ~500μs
- 消除最后一个大的STW

---

### Go 1.9-1.11: 持续优化

- STW降至 ~100μs
- 优化大对象扫描
- 改进GC Pacer

---

### Go 1.12-1.18: 精细调优

- Go 1.12: 优化清扫
- Go 1.14: 异步抢占
- Go 1.18: 泛型，无GC影响

---

### Go 1.19+: 软内存限制

- **新特性**: SetMemoryLimit
- 自动GC调整
- 更好的容器支持

---

### Go 1.25: 最新优化

- STW稳定 < 100μs
- 改进大堆支持
- 优化容器感知

---

## 8. 最佳实践

### 实践1: 合理设置GOGC

```go
// 根据场景选择

// 低延迟服务
os.Setenv("GOGC", "50")

// 高吞吐批处理
os.Setenv("GOGC", "200")

// 或运行时调整
debug.SetGCPercent(50)
```

---

### 实践2: 使用内存限制

```go
// 设置合理的内存限制
debug.SetMemoryLimit(container_memory * 0.9)

// 示例: 2GB容器，设置1.8GB限制
debug.SetMemoryLimit(1800 * 1024 * 1024)
```

---

### 实践3: 减少分配

```go
// 1. 预分配
s := make([]T, 0, expectedSize)

// 2. 复用对象
pool := sync.Pool{...}

// 3. 避免逃逸
// 返回值类型，不返回指针
```

---

### 实践4: 监控GC

```go
// Prometheus监控
gcDuration := prometheus.NewSummary(prometheus.SummaryOpts{
    Name: "gc_duration_seconds",
    Help: "GC pause duration",
})

// 定期采样
go func() {
    var m runtime.MemStats
    for {
        runtime.ReadMemStats(&m)
        gcDuration.Observe(float64(m.PauseNs[(m.NumGC+255)%256]) / 1e9)
        time.Sleep(time.Second)
    }
}()
```

---

### 实践5: 压测验证

```bash
# 1. 压测
wrk -t12 -c400 -d30s http://localhost:8080

# 2. 同时监控GC
watch -n1 'curl -s http://localhost:6060/debug/vars | jq .memstats'

# 3. 分析trace
curl http://localhost:6060/debug/pprof/trace?seconds=5 > trace.out
go tool trace trace.out
```

---

### GC优化清单

```
✅ 设置合理的GOGC
✅ 启用内存限制
✅ 预分配已知大小的slice/map
✅ 使用sync.Pool复用对象
✅ 减少指针使用
✅ 避免频繁创建小对象
✅ 监控GC指标
✅ 定期压测验证
✅ 分析pprof和trace
✅ 优化热点路径
```

---

## 🔗 相关资源

- [Go Runtime架构总览](./01-Go-Runtime架构总览.md)
- [GMP调度器详解](./02-GMP调度器详解.md)
- [内存分配器原理](./03-内存分配器原理.md)
- [内存优化](../performance/02-内存优化.md)
- [性能调优](../performance/06-性能调优实战.md)

---

**最后更新**: 2025-10-29  
**Go版本**: 1.25.3  
**文档类型**: 垃圾回收器深度解析 ✨

