# Go 1.25.3 高级DevOps完整实战

## 📋 目录


- [1. GitOps概述](#1-gitops概述)
  - [1.1 GitOps核心概念](#11-gitops核心概念)
  - [1.2 仓库结构](#12-仓库结构)
- [2. ArgoCD实战](#2-argocd实战)
  - [2.1 安装ArgoCD](#21-安装argocd)
  - [2.2 创建ArgoCD Application](#22-创建argocd-application)
  - [2.3 ApplicationSet (多环境部署)](#23-applicationset-多环境部署)
- [3. Tekton CI/CD](#3-tekton-cicd)
  - [3.1 安装Tekton](#31-安装tekton)
  - [3.2 构建Go应用的Pipeline](#32-构建go应用的pipeline)
  - [3.3 Tekton Triggers (Webhook自动触发)](#33-tekton-triggers-webhook自动触发)
- [4. Flux CD](#4-flux-cd)
  - [4.1 安装Flux](#41-安装flux)
  - [4.2 配置GitRepository和Kustomization](#42-配置gitrepository和kustomization)
  - [4.3 Helm Release管理](#43-helm-release管理)
- [5. 多环境管理](#5-多环境管理)
  - [5.1 Kustomize多环境](#51-kustomize多环境)
  - [5.2 Helm多环境](#52-helm多环境)
- [6. 金丝雀发布](#6-金丝雀发布)
  - [6.1 Flagger + Istio](#61-flagger--istio)
  - [6.2 Argo Rollouts](#62-argo-rollouts)
- [7. 配置管理](#7-配置管理)
  - [7.1 Sealed Secrets (加密敏感数据)](#71-sealed-secrets-加密敏感数据)
  - [7.2 External Secrets Operator](#72-external-secrets-operator)
- [8. 监控与告警](#8-监控与告警)
  - [8.1 Prometheus + Grafana集成](#81-prometheus--grafana集成)
  - [8.2 自定义Grafana Dashboard](#82-自定义grafana-dashboard)
- [9. 安全与合规](#9-安全与合规)
  - [9.1 Policy as Code (OPA Gatekeeper)](#91-policy-as-code-opa-gatekeeper)
  - [9.2 镜像扫描与策略](#92-镜像扫描与策略)
- [10. 完整项目示例](#10-完整项目示例)
  - [10.1 完整GitOps工作流](#101-完整gitops工作流)
  - [10.2 监控Dashboard](#102-监控dashboard)
- [总结](#总结)
  - [GitOps最佳实践](#gitops最佳实践)
  - [工具选择建议](#工具选择建议)

## 1. GitOps概述

### 1.1 GitOps核心概念

```go
// GitOps原则
/*
GitOps = Git + Ops

核心原则:
  1. 声明式 (Declarative)
     • 使用YAML/JSON描述期望状态
     • 而非命令式脚本

  2. 版本控制 (Versioned)
     • 所有配置存储在Git
     • 完整的变更历史
     • 易于回滚

  3. 自动拉取 (Pulled)
     • GitOps Operator监听Git
     • 自动同步到集群
     • 而非推送部署

  4. 持续协调 (Reconciled)
     • 持续监控实际状态
     • 与Git中期望状态对比
     • 自动修正偏差

GitOps工具对比:
  ArgoCD:
    • ✅ UI友好
    • ✅ 多集群支持
    • ✅ SSO集成
    • ✅ 应用最广泛

  Flux CD:
    • ✅ CNCF项目
    • ✅ GitOps Toolkit
    • ✅ 更轻量
    • ✅ Helm原生支持

  Tekton:
    • ✅ Cloud Native CI/CD
    • ✅ Kubernetes原生
    • ✅ 灵活的Pipeline
    • ✅ 可复用Task
*/

// GitOps工作流
type GitOpsWorkflow struct {
 Steps []string
}

var workflow = GitOpsWorkflow{
 Steps: []string{
  "1. 开发者提交代码到Git仓库",
  "2. CI Pipeline构建Docker镜像",
  "3. 更新Kubernetes YAML中的镜像版本",
  "4. 提交YAML变更到Git配置仓库",
  "5. GitOps Operator检测到Git变更",
  "6. 自动同步到Kubernetes集群",
  "7. Kubernetes拉取新镜像并部署",
  "8. 监控验证部署结果",
 },
}
```

### 1.2 仓库结构

```text
gitops-project/
├── apps/                         # 应用代码仓库
│   ├── go-api/
│   │   ├── main.go
│   │   ├── Dockerfile
│   │   └── .github/workflows/
│   │       └── ci.yml           # CI Pipeline
│   └── go-worker/
│       └── ...
│
├── infrastructure/              # 基础设施仓库
│   ├── argocd/
│   │   ├── install.yaml
│   │   └── apps/
│   │       └── applications.yaml
│   ├── base/                    # Kustomize base
│   │   ├── deployment.yaml
│   │   ├── service.yaml
│   │   └── kustomization.yaml
│   └── overlays/                # 环境特定配置
│       ├── dev/
│       │   ├── kustomization.yaml
│       │   └── replicas.yaml
│       ├── staging/
│       │   └── kustomization.yaml
│       └── production/
│           ├── kustomization.yaml
│           ├── replicas.yaml
│           └── resources.yaml
└── helm-charts/                 # Helm Charts
    └── go-api/
        ├── Chart.yaml
        ├── values.yaml
        ├── values-dev.yaml
        ├── values-prod.yaml
        └── templates/
            ├── deployment.yaml
            └── service.yaml
```

---

## 2. ArgoCD实战

### 2.1 安装ArgoCD

```bash
# 创建namespace
kubectl create namespace argocd

# 安装ArgoCD
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

# 等待Pod就绪
kubectl wait --for=condition=Ready pods --all -n argocd --timeout=300s

# 获取初始密码
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d

# Port Forward访问UI
kubectl port-forward svc/argocd-server -n argocd 8080:443

# 访问 https://localhost:8080
# 用户名: admin
# 密码: (上面获取的密码)

# 安装ArgoCD CLI
# macOS
brew install argocd

# Linux
curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
chmod +x /usr/local/bin/argocd

# 登录
argocd login localhost:8080 --insecure
argocd account update-password
```

### 2.2 创建ArgoCD Application

```yaml
# apps/go-api-application.yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: go-api
  namespace: argocd
spec:
  project: default
  
  # Git源
  source:
    repoURL: https://github.com/your-org/gitops-infra
    targetRevision: main
    path: overlays/production
    
    # Kustomize配置
    kustomize:
      images:
        - your-registry/go-api:v1.2.3
  
  # 目标集群
  destination:
    server: https://kubernetes.default.svc
    namespace: production
  
  # 同步策略
  syncPolicy:
    automated:
      prune: true          # 删除Git中不存在的资源
      selfHeal: true       # 自动修复配置偏差
      allowEmpty: false
    syncOptions:
      - CreateNamespace=true
      - PruneLast=true
    
    retry:
      limit: 5
      backoff:
        duration: 5s
        factor: 2
        maxDuration: 3m
  
  # 健康检查
  health:
    check:
      - name: Deployment
        type: SuccessfulDeployment
```

```bash
# 应用Application
kubectl apply -f apps/go-api-application.yaml

# 查看应用状态
argocd app list
argocd app get go-api

# 手动同步
argocd app sync go-api

# 查看同步历史
argocd app history go-api

# 回滚到上一版本
argocd app rollback go-api <revision>
```

### 2.3 ApplicationSet (多环境部署)

```yaml
# apps/go-api-appset.yaml
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: go-api-multienv
  namespace: argocd
spec:
  generators:
    # 列表生成器 (多环境)
    - list:
        elements:
          - env: dev
            cluster: https://kubernetes.default.svc
            replicas: 1
          - env: staging
            cluster: https://staging-cluster.example.com
            replicas: 2
          - env: production
            cluster: https://prod-cluster.example.com
            replicas: 3
  
  template:
    metadata:
      name: 'go-api-{{env}}'
    spec:
      project: default
      source:
        repoURL: https://github.com/your-org/gitops-infra
        targetRevision: main
        path: 'overlays/{{env}}'
        kustomize:
          commonLabels:
            environment: '{{env}}'
      destination:
        server: '{{cluster}}'
        namespace: '{{env}}'
      syncPolicy:
        automated:
          prune: true
          selfHeal: true
```

---

## 3. Tekton CI/CD

### 3.1 安装Tekton

```bash
# 安装Tekton Pipelines
kubectl apply -f https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml

# 安装Tekton Triggers (可选)
kubectl apply -f https://storage.googleapis.com/tekton-releases/triggers/latest/release.yaml

# 安装Tekton Dashboard (可选)
kubectl apply -f https://storage.googleapis.com/tekton-releases/dashboard/latest/release.yaml

# Port Forward Dashboard
kubectl port-forward -n tekton-pipelines svc/tekton-dashboard 9097:9097
```

### 3.2 构建Go应用的Pipeline

```yaml
# tekton/task-build-go.yaml
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: build-go-app
spec:
  params:
    - name: repo-url
      type: string
    - name: revision
      type: string
      default: main
    - name: image
      type: string
  
  workspaces:
    - name: source
    - name: dockerconfig
      mountPath: /kaniko/.docker
  
  steps:
    # Step 1: Clone代码
    - name: git-clone
      image: alpine/git:latest
      script: |
        #!/bin/sh
        git clone --depth 1 --branch $(params.revision) $(params.repo-url) /workspace/source
    
    # Step 2: Go测试
    - name: go-test
      image: golang:1.25.3-alpine
      workingDir: /workspace/source
      script: |
        #!/bin/sh
        go test -v ./...
    
    # Step 3: Go构建
    - name: go-build
      image: golang:1.25.3-alpine
      workingDir: /workspace/source
      script: |
        #!/bin/sh
        CGO_ENABLED=0 GOOS=linux go build -ldflags="-s -w" -o /workspace/app
    
    # Step 4: 构建Docker镜像
    - name: build-image
      image: gcr.io/kaniko-project/executor:latest
      args:
        - --dockerfile=/workspace/source/Dockerfile
        - --context=/workspace/source
        - --destination=$(params.image)
        - --cache=true
    
    # Step 5: 镜像扫描 (Trivy)
    - name: scan-image
      image: aquasec/trivy:latest
      script: |
        #!/bin/sh
        trivy image --severity HIGH,CRITICAL --exit-code 1 $(params.image)
```

```yaml
# tekton/pipeline-go-app.yaml
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: go-app-pipeline
spec:
  params:
    - name: repo-url
      type: string
    - name: image-name
      type: string
    - name: git-revision
      type: string
      default: main
    - name: deploy-env
      type: string
      default: dev
  
  workspaces:
    - name: shared-workspace
    - name: docker-credentials
  
  tasks:
    # Task 1: 构建和推送镜像
    - name: build
      taskRef:
        name: build-go-app
      params:
        - name: repo-url
          value: $(params.repo-url)
        - name: revision
          value: $(params.git-revision)
        - name: image
          value: $(params.image-name):$(params.git-revision)
      workspaces:
        - name: source
          workspace: shared-workspace
        - name: dockerconfig
          workspace: docker-credentials
    
    # Task 2: 更新Kubernetes配置
    - name: update-gitops-repo
      runAfter: [build]
      taskRef:
        name: git-cli
      params:
        - name: GIT_USER_NAME
          value: "Tekton Pipeline"
        - name: GIT_USER_EMAIL
          value: "tekton@example.com"
        - name: GIT_SCRIPT
          value: |
            git clone https://github.com/your-org/gitops-infra.git
            cd gitops-infra/overlays/$(params.deploy-env)
            
            # 更新镜像版本
            kustomize edit set image your-registry/go-api=$(params.image-name):$(params.git-revision)
            
            git add .
            git commit -m "Update image to $(params.git-revision)"
            git push origin main
```

```yaml
# tekton/pipelinerun.yaml
apiVersion: tekton.dev/v1beta1
kind: PipelineRun
metadata:
  generateName: go-app-pipeline-run-
spec:
  pipelineRef:
    name: go-app-pipeline
  params:
    - name: repo-url
      value: https://github.com/your-org/go-api.git
    - name: image-name
      value: your-registry/go-api
    - name: git-revision
      value: v1.2.3
    - name: deploy-env
      value: production
  workspaces:
    - name: shared-workspace
      volumeClaimTemplate:
        spec:
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 1Gi
    - name: docker-credentials
      secret:
        secretName: docker-registry-secret
```

```bash
# 执行Pipeline
kubectl create -f tekton/pipelinerun.yaml

# 查看Pipeline运行
tkn pipeline list
tkn pipelinerun list
tkn pipelinerun logs <pipelinerun-name> -f

# 通过CLI触发
tkn pipeline start go-app-pipeline \
  --param repo-url=https://github.com/your-org/go-api.git \
  --param image-name=your-registry/go-api \
  --param git-revision=v1.2.3 \
  --workspace name=shared-workspace,volumeClaimTemplateFile=pvc.yaml \
  --showlog
```

### 3.3 Tekton Triggers (Webhook自动触发)

```yaml
# tekton/trigger-binding.yaml
apiVersion: triggers.tekton.dev/v1beta1
kind: TriggerBinding
metadata:
  name: github-push-binding
spec:
  params:
    - name: git-revision
      value: $(body.head_commit.id)
    - name: repo-url
      value: $(body.repository.clone_url)

---
# tekton/trigger-template.yaml
apiVersion: triggers.tekton.dev/v1beta1
kind: TriggerTemplate
metadata:
  name: go-app-template
spec:
  params:
    - name: git-revision
    - name: repo-url
  resourcetemplates:
    - apiVersion: tekton.dev/v1beta1
      kind: PipelineRun
      metadata:
        generateName: go-app-pipeline-run-
      spec:
        pipelineRef:
          name: go-app-pipeline
        params:
          - name: repo-url
            value: $(tt.params.repo-url)
          - name: git-revision
            value: $(tt.params.git-revision)
        workspaces:
          - name: shared-workspace
            volumeClaimTemplate:
              spec:
                accessModes: [ReadWriteOnce]
                resources:
                  requests:
                    storage: 1Gi

---
# tekton/event-listener.yaml
apiVersion: triggers.tekton.dev/v1beta1
kind: EventListener
metadata:
  name: github-listener
spec:
  serviceAccountName: tekton-triggers-sa
  triggers:
    - name: github-push-trigger
      bindings:
        - ref: github-push-binding
      template:
        ref: go-app-template
```

```bash
# 暴露EventListener
kubectl port-forward svc/el-github-listener 8080:8080

# 配置GitHub Webhook
# Payload URL: http://your-domain:8080
# Content type: application/json
# Events: Push events
```

---

## 4. Flux CD

### 4.1 安装Flux

```bash
# 安装Flux CLI
curl -s https://fluxcd.io/install.sh | sudo bash

# 验证安装
flux --version

# 预检查集群
flux check --pre

# Bootstrap Flux (连接GitHub)
export GITHUB_TOKEN=<your-token>
flux bootstrap github \
  --owner=your-org \
  --repository=gitops-infra \
  --branch=main \
  --path=clusters/production \
  --personal

# 验证安装
flux check
```

### 4.2 配置GitRepository和Kustomization

```yaml
# flux/gitrepository.yaml
apiVersion: source.toolkit.fluxcd.io/v1
kind: GitRepository
metadata:
  name: go-api-repo
  namespace: flux-system
spec:
  interval: 1m
  url: https://github.com/your-org/go-api
  ref:
    branch: main
  secretRef:
    name: git-credentials

---
# flux/kustomization.yaml
apiVersion: kustomize.toolkit.fluxcd.io/v1
kind: Kustomization
metadata:
  name: go-api
  namespace: flux-system
spec:
  interval: 5m
  path: ./deploy/overlays/production
  prune: true
  sourceRef:
    kind: GitRepository
    name: go-api-repo
  healthChecks:
    - apiVersion: apps/v1
      kind: Deployment
      name: go-api
      namespace: production
  timeout: 2m
```

### 4.3 Helm Release管理

```yaml
# flux/helmrepository.yaml
apiVersion: source.toolkit.fluxcd.io/v1beta2
kind: HelmRepository
metadata:
  name: my-charts
  namespace: flux-system
spec:
  interval: 10m
  url: https://charts.example.com

---
# flux/helmrelease.yaml
apiVersion: helm.toolkit.fluxcd.io/v2beta1
kind: HelmRelease
metadata:
  name: go-api
  namespace: production
spec:
  interval: 5m
  chart:
    spec:
      chart: go-api
      version: '>= 1.0.0 < 2.0.0'
      sourceRef:
        kind: HelmRepository
        name: my-charts
        namespace: flux-system
  
  # 自定义Values
  values:
    replicaCount: 3
    image:
      repository: your-registry/go-api
      tag: v1.2.3
    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 250m
        memory: 256Mi
  
  # 升级配置
  upgrade:
    remediation:
      retries: 3
  
  # 测试
  test:
    enable: true
  
  # 回滚
  rollback:
    recreate: true
```

---

## 5. 多环境管理

### 5.1 Kustomize多环境

```yaml
# base/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
  - deployment.yaml
  - service.yaml
  - configmap.yaml

commonLabels:
  app: go-api

---
# overlays/dev/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

bases:
  - ../../base

namespace: dev

replicas:
  - name: go-api
    count: 1

images:
  - name: your-registry/go-api
    newTag: dev-latest

patches:
  - path: resources.yaml

---
# overlays/dev/resources.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: go-api
spec:
  template:
    spec:
      containers:
        - name: go-api
          resources:
            limits:
              cpu: 200m
              memory: 256Mi
            requests:
              cpu: 100m
              memory: 128Mi

---
# overlays/production/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

bases:
  - ../../base

namespace: production

replicas:
  - name: go-api
    count: 3

images:
  - name: your-registry/go-api
    newTag: v1.2.3

patches:
  - path: resources.yaml
  - path: hpa.yaml

---
# overlays/production/hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: go-api
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: go-api
  minReplicas: 3
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
```

```bash
# 预览各环境配置
kustomize build overlays/dev
kustomize build overlays/staging
kustomize build overlays/production

# 应用
kubectl apply -k overlays/production
```

### 5.2 Helm多环境

```yaml
# helm-charts/go-api/values.yaml (默认值)
replicaCount: 1

image:
  repository: your-registry/go-api
  pullPolicy: IfNotPresent
  tag: ""

resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 250m
    memory: 256Mi

autoscaling:
  enabled: false

---
# helm-charts/go-api/values-dev.yaml
replicaCount: 1

image:
  tag: dev-latest

resources:
  limits:
    cpu: 200m
    memory: 256Mi
  requests:
    cpu: 100m
    memory: 128Mi

---
# helm-charts/go-api/values-prod.yaml
replicaCount: 3

image:
  tag: v1.2.3

resources:
  limits:
    cpu: 1000m
    memory: 1Gi
  requests:
    cpu: 500m
    memory: 512Mi

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
```

```bash
# 部署到不同环境
helm upgrade --install go-api ./helm-charts/go-api \
  -n dev \
  -f helm-charts/go-api/values-dev.yaml

helm upgrade --install go-api ./helm-charts/go-api \
  -n production \
  -f helm-charts/go-api/values-prod.yaml
```

---

## 6. 金丝雀发布

### 6.1 Flagger + Istio

```bash
# 安装Flagger
kubectl apply -f https://raw.githubusercontent.com/fluxcd/flagger/main/artifacts/flagger/crd.yaml

helm upgrade -i flagger flagger/flagger \
  --namespace=istio-system \
  --set meshProvider=istio \
  --set metricsServer=http://prometheus:9090
```

```yaml
# flagger/canary.yaml
apiVersion: flagger.app/v1beta1
kind: Canary
metadata:
  name: go-api
  namespace: production
spec:
  # 目标Deployment
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: go-api
  
  # 服务配置
  service:
    port: 8080
    targetPort: 8080
    gateways:
      - istio-gateway
    hosts:
      - api.example.com
  
  # 金丝雀分析
  analysis:
    interval: 1m
    threshold: 5
    maxWeight: 50
    stepWeight: 10
    
    # 指标检查
    metrics:
      - name: request-success-rate
        thresholdRange:
          min: 99
        interval: 1m
      
      - name: request-duration
        thresholdRange:
          max: 500
        interval: 1m
    
    # Webhook测试
    webhooks:
      - name: acceptance-test
        type: pre-rollout
        url: http://test-runner.default/
        timeout: 30s
        metadata:
          type: bash
          cmd: "curl -sd 'test' http://go-api-canary:8080/test | grep OK"
      
      - name: load-test
        url: http://flagger-loadtester.default/
        timeout: 5s
        metadata:
          cmd: "hey -z 1m -q 10 -c 2 http://go-api-canary.production:8080/"
```

```bash
# 触发金丝雀发布 (更新镜像)
kubectl set image deployment/go-api \
  go-api=your-registry/go-api:v1.2.4 \
  -n production

# 监控金丝雀进度
watch kubectl get canary -n production

# 查看详细事件
kubectl describe canary go-api -n production
```

### 6.2 Argo Rollouts

```bash
# 安装Argo Rollouts
kubectl create namespace argo-rollouts
kubectl apply -n argo-rollouts -f https://github.com/argoproj/argo-rollouts/releases/latest/download/install.yaml

# 安装kubectl插件
curl -LO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64
chmod +x kubectl-argo-rollouts-linux-amd64
sudo mv kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts
```

```yaml
# rollouts/rollout.yaml
apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: go-api
  namespace: production
spec:
  replicas: 5
  strategy:
    canary:
      steps:
        - setWeight: 20
        - pause: {duration: 2m}
        - setWeight: 40
        - pause: {duration: 2m}
        - setWeight: 60
        - pause: {duration: 2m}
        - setWeight: 80
        - pause: {duration: 2m}
      
      # 自动提升
      analysis:
        templates:
          - templateName: success-rate
        startingStep: 2
        args:
          - name: service-name
            value: go-api
      
      # 流量路由 (Istio)
      trafficRouting:
        istio:
          virtualService:
            name: go-api
            routes:
              - primary
  
  revisionHistoryLimit: 2
  
  selector:
    matchLabels:
      app: go-api
  
  template:
    metadata:
      labels:
        app: go-api
    spec:
      containers:
        - name: go-api
          image: your-registry/go-api:v1.2.3
          ports:
            - containerPort: 8080
          resources:
            limits:
              cpu: 500m
              memory: 512Mi

---
# rollouts/analysis-template.yaml
apiVersion: argoproj.io/v1alpha1
kind: AnalysisTemplate
metadata:
  name: success-rate
spec:
  args:
    - name: service-name
  metrics:
    - name: success-rate
      interval: 1m
      successCondition: result[0] >= 0.95
      failureLimit: 3
      provider:
        prometheus:
          address: http://prometheus.monitoring:9090
          query: |
            sum(rate(http_requests_total{
              service="{{args.service-name}}",
              status!~"5.."
            }[2m]))
            /
            sum(rate(http_requests_total{
              service="{{args.service-name}}"
            }[2m]))
```

```bash
# 触发Rollout
kubectl argo rollouts set image go-api \
  go-api=your-registry/go-api:v1.2.4 \
  -n production

# 查看Rollout状态
kubectl argo rollouts get rollout go-api -n production --watch

# 手动提升
kubectl argo rollouts promote go-api -n production

# 手动回滚
kubectl argo rollouts abort go-api -n production
kubectl argo rollouts undo go-api -n production
```

---

## 7. 配置管理

### 7.1 Sealed Secrets (加密敏感数据)

```bash
# 安装Sealed Secrets Controller
kubectl apply -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.24.0/controller.yaml

# 安装kubeseal CLI
# macOS
brew install kubeseal

# Linux
wget https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.24.0/kubeseal-linux-amd64 -O kubeseal
chmod +x kubeseal
sudo mv kubeseal /usr/local/bin/
```

```bash
# 创建普通Secret
kubectl create secret generic db-credentials \
  --from-literal=username=admin \
  --from-literal=password=supersecret \
  --dry-run=client -o yaml > secret.yaml

# 加密Secret
kubeseal -f secret.yaml -w sealed-secret.yaml

# 提交到Git
git add sealed-secret.yaml
git commit -m "Add encrypted DB credentials"
git push
```

```yaml
# sealed-secret.yaml (加密后可安全存储在Git)
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: db-credentials
  namespace: production
spec:
  encryptedData:
    username: AgB1x5+...encrypted...
    password: AgCQ9f...encrypted...
  template:
    metadata:
      name: db-credentials
```

### 7.2 External Secrets Operator

```bash
# 安装External Secrets Operator
helm repo add external-secrets https://charts.external-secrets.io
helm install external-secrets \
  external-secrets/external-secrets \
  -n external-secrets-system \
  --create-namespace
```

```yaml
# external-secrets/secret-store.yaml
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: aws-secrets-manager
  namespace: production
spec:
  provider:
    aws:
      service: SecretsManager
      region: us-east-1
      auth:
        jwt:
          serviceAccountRef:
            name: external-secrets-sa

---
# external-secrets/external-secret.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: db-credentials
  namespace: production
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: aws-secrets-manager
    kind: SecretStore
  target:
    name: db-credentials
    creationPolicy: Owner
  data:
    - secretKey: username
      remoteRef:
        key: production/db
        property: username
    - secretKey: password
      remoteRef:
        key: production/db
        property: password
```

---

## 8. 监控与告警

### 8.1 Prometheus + Grafana集成

```yaml
# monitoring/servicemonitor.yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: go-api
  namespace: production
spec:
  selector:
    matchLabels:
      app: go-api
  endpoints:
    - port: metrics
      interval: 30s
      path: /metrics

---
# monitoring/prometheusrule.yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: go-api-alerts
  namespace: production
spec:
  groups:
    - name: go-api
      interval: 30s
      rules:
        - alert: HighErrorRate
          expr: |
            rate(http_requests_total{job="go-api",status=~"5.."}[5m]) > 0.05
          for: 5m
          labels:
            severity: critical
          annotations:
            summary: "High error rate on {{ $labels.instance }}"
            description: "Error rate is {{ $value | humanizePercentage }}"
        
        - alert: HighLatency
          expr: |
            histogram_quantile(0.95, 
              rate(http_request_duration_seconds_bucket{job="go-api"}[5m])
            ) > 1
          for: 5m
          labels:
            severity: warning
          annotations:
            summary: "High latency on {{ $labels.instance }}"
```

### 8.2 自定义Grafana Dashboard

```json
// grafana/dashboard-go-api.json
{
  "dashboard": {
    "title": "Go API Metrics",
    "panels": [
      {
        "title": "Request Rate",
        "targets": [
          {
            "expr": "rate(http_requests_total{job=\"go-api\"}[5m])"
          }
        ],
        "type": "graph"
      },
      {
        "title": "Error Rate",
        "targets": [
          {
            "expr": "rate(http_requests_total{job=\"go-api\",status=~\"5..\"}[5m])"
          }
        ],
        "type": "graph"
      },
      {
        "title": "Latency (p95)",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket{job=\"go-api\"}[5m]))"
          }
        ],
        "type": "graph"
      }
    ]
  }
}
```

---

## 9. 安全与合规

### 9.1 Policy as Code (OPA Gatekeeper)

```bash
# 安装Gatekeeper
kubectl apply -f https://raw.githubusercontent.com/open-policy-agent/gatekeeper/master/deploy/gatekeeper.yaml
```

```yaml
# policies/constraint-template.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8srequiredlabels
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredLabels
      validation:
        openAPIV3Schema:
          properties:
            labels:
              type: array
              items:
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredlabels
        
        violation[{"msg": msg, "details": {"missing_labels": missing}}] {
          provided := {label | input.review.object.metadata.labels[label]}
          required := {label | label := input.parameters.labels[_]}
          missing := required - provided
          count(missing) > 0
          msg := sprintf("Missing required labels: %v", [missing])
        }

---
# policies/constraint.yaml
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequiredLabels
metadata:
  name: must-have-owner
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment"]
    namespaces:
      - production
  parameters:
    labels:
      - owner
      - environment
      - cost-center
```

### 9.2 镜像扫描与策略

```yaml
# security/image-policy.yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: check-image-signature
spec:
  validationFailureAction: enforce
  background: false
  webhookTimeoutSeconds: 30
  rules:
    - name: verify-signature
      match:
        any:
          - resources:
              kinds:
                - Pod
      verifyImages:
        - imageReferences:
            - "your-registry/*"
          attestors:
            - count: 1
              entries:
                - keys:
                    publicKeys: |-
                      -----BEGIN PUBLIC KEY-----
                      ...
                      -----END PUBLIC KEY-----

---
# security/vulnerability-scan-policy.yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: check-vulnerabilities
spec:
  validationFailureAction: enforce
  background: true
  rules:
    - name: check-severity
      match:
        any:
          - resources:
              kinds:
                - Pod
      validate:
        message: "Image has HIGH or CRITICAL vulnerabilities"
        deny:
          conditions:
            any:
              - key: "{{ images.*.jmesPath.vulnerabilities[?severity=='HIGH'] | length(@) }}"
                operator: GreaterThan
                value: 0
```

---

## 10. 完整项目示例

### 10.1 完整GitOps工作流

```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
    tags: ['v*']

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.25.3'
      
      - name: Run tests
        run: go test -v -race -coverprofile=coverage.out ./...
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
  
  build:
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Log in to Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
      
      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
  
  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v3
        with:
          repository: your-org/gitops-infra
          token: ${{ secrets.PAT_TOKEN }}
      
      - name: Update image tag
        run: |
          cd overlays/production
          kustomize edit set image \
            ghcr.io/${{ github.repository }}=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
      
      - name: Commit and push
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          git add .
          git commit -m "Update image to ${{ github.sha }}"
          git push
```

### 10.2 监控Dashboard

```go
// cmd/api/main.go
package main

import (
 "net/http"
 
 "github.com/gin-gonic/gin"
 "github.com/prometheus/client_golang/prometheus"
 "github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
 httpRequestsTotal = prometheus.NewCounterVec(
  prometheus.CounterOpts{
   Name: "http_requests_total",
   Help: "Total number of HTTP requests",
  },
  []string{"method", "endpoint", "status"},
 )
 
 httpRequestDuration = prometheus.NewHistogramVec(
  prometheus.HistogramOpts{
   Name:    "http_request_duration_seconds",
   Help:    "HTTP request latencies in seconds",
   Buckets: []float64{.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5},
  },
  []string{"method", "endpoint"},
 )
)

func init() {
 prometheus.MustRegister(httpRequestsTotal)
 prometheus.MustRegister(httpRequestDuration)
}

func main() {
 r := gin.Default()
 
 // Prometheus metrics
 r.GET("/metrics", gin.WrapH(promhttp.Handler()))
 
 // Middleware for metrics
 r.Use(func(c *gin.Context) {
  timer := prometheus.NewTimer(httpRequestDuration.WithLabelValues(c.Request.Method, c.FullPath()))
  defer timer.ObserveDuration()
  
  c.Next()
  
  httpRequestsTotal.WithLabelValues(
   c.Request.Method,
   c.FullPath(),
   fmt.Sprintf("%d", c.Writer.Status()),
  ).Inc()
 })
 
 // Health checks
 r.GET("/health", func(c *gin.Context) {
  c.JSON(http.StatusOK, gin.H{"status": "healthy"})
 })
 
 r.GET("/ready", func(c *gin.Context) {
  // Check dependencies
  c.JSON(http.StatusOK, gin.H{"status": "ready"})
 })
 
 r.Run(":8080")
}
```

---

## 总结

### GitOps最佳实践

```text
1. 仓库结构:
   ✅ 应用代码与基础设施分离
   ✅ 使用Kustomize或Helm管理多环境
   ✅ Sealed Secrets加密敏感数据

2. CI/CD流程:
   ✅ CI负责构建和测试
   ✅ CD通过GitOps自动部署
   ✅ 所有变更通过Git审计

3. 发布策略:
   ✅ 金丝雀发布 (Flagger/Argo Rollouts)
   ✅ 蓝绿部署
   ✅ 自动回滚

4. 监控与告警:
   ✅ Prometheus指标
   ✅ Grafana可视化
   ✅ 告警规则

5. 安全与合规:
   ✅ Policy as Code (OPA)
   ✅ 镜像签名验证
   ✅ 漏洞扫描
```

### 工具选择建议

```text
ArgoCD vs Flux:
  ArgoCD: UI友好, 多集群支持, 易上手
  Flux: 轻量, CNCF, GitOps Toolkit

Kustomize vs Helm:
  Kustomize: 简单, 原生支持, 无模板
  Helm: 成熟, 社区charts丰富, 功能强大

Tekton vs GitHub Actions:
  Tekton: Kubernetes原生, 灵活Pipeline
  GitHub Actions: 易用, 与GitHub深度集成
```

**相关文档:**

- [云原生部署](../06-云原生与容器/10-云原生完整项目实战.md)
- [微服务架构](09-Go-1.25.3微服务架构完整实战.md)
- [Serverless与FaaS](32-Go-1.25.3Serverless与FaaS完整实战.md)
