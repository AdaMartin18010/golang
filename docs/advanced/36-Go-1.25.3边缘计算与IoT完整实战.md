# Go 1.25.3边缘计算与IoT完整实战

> **边缘计算·MQTT/CoAP·设备管理·OTA升级·实时数据处理**  
> 📍 **难度**：⭐⭐⭐⭐⭐ (高级)  
> 🎯 **目标**：构建生产级IoT边缘计算平台  
> ⏱ **预计时间**：6-8小时  
> 🔧 **技术栈**：MQTT·CoAP·NATS·InfluxDB·Protocol Buffers·边缘AI

---


## 📋 目录

- [1. 目录](#目录)
- [2. 1. 边缘计算架构](#1-边缘计算架构)
- [3. 2. MQTT协议实战](#2-mqtt协议实战)
- [4. 3. CoAP协议实战](#3-coap协议实战)
- [5. 4. 设备管理系统](#4-设备管理系统)
- [6. 5. OTA固件升级](#5-ota固件升级)
- [7. 6. 边缘数据处理](#6-边缘数据处理)
- [8. 7. 边缘-云协同](#7-边缘-云协同)
- [9. 8. 完整IoT平台](#8-完整iot平台)
- [10. 9. 监控与告警](#9-监控与告警)
- [11. 10. 生产部署](#10-生产部署)
- [12. 总结](#总结)
- [13. 下一步学习](#下一步学习)

---

## 目录

- [Go 1.25.3边缘计算与IoT完整实战](#go-1253边缘计算与iot完整实战)
  - [目录](#目录)
  - [1. 边缘计算架构](#1-边缘计算架构)
    - [1.1 为什么需要边缘计算？](#11-为什么需要边缘计算)
    - [1.2 边缘计算三层架构](#12-边缘计算三层架构)
  - [2. MQTT协议实战](#2-mqtt协议实战)
    - [2.1 MQTT基础架构](#21-mqtt基础架构)
    - [2.2 设备数据采集与上报](#22-设备数据采集与上报)
    - [2.3 命令下发与执行](#23-命令下发与执行)
  - [3. CoAP协议实战](#3-coap协议实战)
    - [3.1 CoAP协议基础](#31-coap协议基础)
    - [3.2 资源读取与观察模式](#32-资源读取与观察模式)
  - [4. 设备管理系统](#4-设备管理系统)
    - [4.1 设备生命周期管理](#41-设备生命周期管理)
    - [4.2 设备影子 (Device Shadow)](#42-设备影子-device-shadow)
  - [5. OTA固件升级](#5-ota固件升级)
    - [5.1 OTA升级架构](#51-ota升级架构)
  - [6. 边缘数据处理](#6-边缘数据处理)
    - [6.1 时序数据库集成](#61-时序数据库集成)
    - [6.2 边缘数据聚合与预处理](#62-边缘数据聚合与预处理)
  - [7. 边缘-云协同](#7-边缘-云协同)
    - [7.1 数据同步策略](#71-数据同步策略)
  - [8. 完整IoT平台](#8-完整iot平台)
    - [8.1 IoT平台架构](#81-iot平台架构)
    - [8.2 规则引擎](#82-规则引擎)
  - [9. 监控与告警](#9-监控与告警)
    - [9.1 平台监控](#91-平台监控)
  - [10. 生产部署](#10-生产部署)
    - [10.1 Docker部署](#101-docker部署)
    - [10.2 Kubernetes部署](#102-kubernetes部署)
  - [总结](#总结)
    - [✅ 核心成果](#-核心成果)
    - [🌟 Go 1.25.3应用](#-go-1253应用)
    - [📊 架构亮点](#-架构亮点)
    - [🎯 适用场景](#-适用场景)
  - [下一步学习](#下一步学习)

---

## 1. 边缘计算架构

### 1.1 为什么需要边缘计算？

```go
// 边缘计算 vs 云计算对比
type ComputingParadigm struct {
 CloudComputing struct {
  Latency    string // "100-500ms" 
  Bandwidth  string // "高带宽消耗"
  Offline    string // "离线不可用" ❌
  Cost       string // "按流量计费"
  Privacy    string // "数据上云"
 }

 EdgeComputing struct {
  Latency    string // "<10ms" ✅
  Bandwidth  string // "低带宽消耗" ✅
  Offline    string // "离线可用" ✅
  Cost       string // "降低云成本" ✅
  Privacy    string // "本地处理" ✅
 }
}

// 边缘计算典型场景
/*
1. 工业物联网 (IIoT)
   • 设备预测性维护
   • 实时质量检测
   • 生产线监控

2. 智能交通
   • 车联网 (V2X)
   • 自动驾驶
   • 交通流量优化

3. 智能家居
   • 语音控制
   • 安防监控
   • 能源管理

4. 智慧城市
   • 环境监测
   • 智能路灯
   • 垃圾管理
*/
```

### 1.2 边缘计算三层架构

```go
package edge

import (
 "context"
 "sync"
)

// 边缘计算三层架构
/*
┌─────────────────────────────────────┐
│      Cloud Layer (云层)              │
│  • 数据存储与分析                     │
│  • AI模型训练                        │
│  • 设备管理平台                      │
└─────────────────────────────────────┘
                 ↕ (数据同步)
┌─────────────────────────────────────┐
│      Edge Layer (边缘层)             │
│  • 本地数据处理                      │
│  • AI推理                           │
│  • 协议转换                         │
└─────────────────────────────────────┘
                 ↕ (MQTT/CoAP)
┌─────────────────────────────────────┐
│     Device Layer (设备层)            │
│  • 传感器 (Sensors)                 │
│  • 执行器 (Actuators)               │
│  • 工业设备                          │
└─────────────────────────────────────┘
*/

// EdgeArchitecture 边缘计算架构定义
type EdgeArchitecture struct {
 // 设备层
 DeviceLayer struct {
  Sensors   []Sensor
  Actuators []Actuator
 }

 // 边缘层
 EdgeLayer struct {
  EdgeNodes []EdgeNode
  Gateway   EdgeGateway
 }

 // 云层
 CloudLayer struct {
  Platform string // "IoT平台"
  Storage  string // "时序数据库"
 }
}

// EdgeNode 边缘节点
type EdgeNode struct {
 NodeID   string
 Location string
 CPU      string // "ARM Cortex-A72"
 Memory   string // "4GB"
 OS       string // "Linux"
}

// Sensor 传感器
type Sensor interface {
 Read(ctx context.Context) (SensorData, error)
 GetType() SensorType
}

// SensorType 传感器类型
type SensorType string

const (
 SensorTemperature SensorType = "temperature"
 SensorHumidity    SensorType = "humidity"
 SensorPressure    SensorType = "pressure"
 SensorVibration   SensorType = "vibration"
 SensorCamera      SensorType = "camera"
)

// SensorData 传感器数据
type SensorData struct {
 SensorID  string
 Type      SensorType
 Value     interface{}
 Unit      string
 Timestamp int64
 Quality   float64 // 数据质量 0-1
}
```

---

## 2. MQTT协议实战

### 2.1 MQTT基础架构

```go
package mqtt

import (
 "context"
 "fmt"
 "log"
 "time"

 paho "github.com/eclipse/paho.mqtt.golang"
)

// MQTT协议特点
/*
MQTT (Message Queuing Telemetry Transport)

核心特性:
  ✅ 轻量级 (2字节固定头)
  ✅ 低带宽 (压缩高效)
  ✅ QoS保证 (0, 1, 2三个级别)
  ✅ 持久会话
  ✅ 遗嘱消息 (Last Will)

QoS级别:
  • QoS 0: At most once  (最多一次，可能丢失)
  • QoS 1: At least once (至少一次，可能重复)
  • QoS 2: Exactly once  (恰好一次，最可靠) ✅

Topic通配符:
  • + : 单层通配符  (sensor/+/temperature)
  • # : 多层通配符  (sensor/#)
*/

// MQTTClient MQTT客户端封装
type MQTTClient struct {
 client  paho.Client
 broker  string
 options *paho.ClientOptions
 mu      sync.RWMutex
 handlers map[string]paho.MessageHandler
}

// NewMQTTClient 创建MQTT客户端
func NewMQTTClient(broker, clientID string) *MQTTClient {
 opts := paho.NewClientOptions()
 opts.AddBroker(broker)
 opts.SetClientID(clientID)
 opts.SetCleanSession(false) // 持久会话
 opts.SetAutoReconnect(true)
 opts.SetMaxReconnectInterval(1 * time.Minute)
 
 // 连接超时
 opts.SetConnectTimeout(10 * time.Second)
 opts.SetKeepAlive(30 * time.Second)
 
 // 遗嘱消息
 opts.SetWill(
  fmt.Sprintf("device/%s/status", clientID),
  "offline",
  1, // QoS 1
  true, // Retained
 )

 mc := &MQTTClient{
  broker:   broker,
  options:  opts,
  handlers: make(map[string]paho.MessageHandler),
 }

 // 连接成功回调
 opts.SetOnConnectHandler(func(c paho.Client) {
  log.Printf("✅ 连接到MQTT Broker: %s", broker)
 })

 // 连接丢失回调
 opts.SetConnectionLostHandler(func(c paho.Client, err error) {
  log.Printf("❌ 连接丢失: %v", err)
 })

 return mc
}

// Connect 连接到Broker
func (mc *MQTTClient) Connect(ctx context.Context) error {
 mc.client = paho.NewClient(mc.options)
 token := mc.client.Connect()

 select {
 case <-token.Done():
  if err := token.Error(); err != nil {
   return fmt.Errorf("连接失败: %w", err)
  }
  return nil
 case <-ctx.Done():
  return ctx.Err()
 }
}

// Publish 发布消息
func (mc *MQTTClient) Publish(topic string, qos byte, payload []byte) error {
 token := mc.client.Publish(topic, qos, false, payload)
 token.Wait()
 return token.Error()
}

// Subscribe 订阅主题
func (mc *MQTTClient) Subscribe(topic string, qos byte, handler paho.MessageHandler) error {
 mc.mu.Lock()
 mc.handlers[topic] = handler
 mc.mu.Unlock()

 token := mc.client.Subscribe(topic, qos, handler)
 token.Wait()
 return token.Error()
}

// Disconnect 断开连接
func (mc *MQTTClient) Disconnect(waitMs uint) {
 mc.client.Disconnect(waitMs)
}
```

### 2.2 设备数据采集与上报

```go
package device

import (
 "context"
 "encoding/json"
 "fmt"
 "log"
 "math/rand"
 "time"
)

// TemperatureSensor 温度传感器
type TemperatureSensor struct {
 SensorID string
 Location string
 client   *MQTTClient
}

// TelemetryData 遥测数据
type TelemetryData struct {
 SensorID  string  `json:"sensor_id"`
 Type      string  `json:"type"`
 Value     float64 `json:"value"`
 Unit      string  `json:"unit"`
 Location  string  `json:"location"`
 Timestamp int64   `json:"timestamp"`
}

// StartReporting 开始上报数据
func (ts *TemperatureSensor) StartReporting(ctx context.Context, interval time.Duration) {
 ticker := time.NewTicker(interval)
 defer ticker.Stop()

 for {
  select {
  case <-ctx.Done():
   return
  case <-ticker.C:
   // 读取传感器数据 (模拟)
   temp := ts.readTemperature()

   // 构造遥测数据
   data := TelemetryData{
    SensorID:  ts.SensorID,
    Type:      "temperature",
    Value:     temp,
    Unit:      "°C",
    Location:  ts.Location,
    Timestamp: time.Now().Unix(),
   }

   // 发布到MQTT
   if err := ts.publishTelemetry(data); err != nil {
    log.Printf("❌ 发布失败: %v", err)
   } else {
    log.Printf("📤 上报数据: %.2f°C", temp)
   }
  }
 }
}

// readTemperature 读取温度 (模拟)
func (ts *TemperatureSensor) readTemperature() float64 {
 // 模拟温度波动: 20-30°C
 return 20.0 + rand.Float64()*10.0
}

// publishTelemetry 发布遥测数据
func (ts *TemperatureSensor) publishTelemetry(data TelemetryData) error {
 topic := fmt.Sprintf("sensor/%s/telemetry", ts.SensorID)
 payload, _ := json.Marshal(data)

 // QoS 1: 至少一次
 return ts.client.Publish(topic, 1, payload)
}
```

### 2.3 命令下发与执行

```go
package actuator

import (
 "encoding/json"
 "fmt"
 "log"
)

// Command 控制命令
type Command struct {
 CommandID  string                 `json:"command_id"`
 Type       string                 `json:"type"` // "set_temperature", "restart", etc.
 Parameters map[string]interface{} `json:"parameters"`
 Timestamp  int64                  `json:"timestamp"`
}

// CommandResponse 命令响应
type CommandResponse struct {
 CommandID string `json:"command_id"`
 Status    string `json:"status"` // "success", "failed"
 Message   string `json:"message"`
 Timestamp int64  `json:"timestamp"`
}

// Thermostat 恒温器 (执行器示例)
type Thermostat struct {
 DeviceID  string
 client    *MQTTClient
 targetTemp float64
}

// Start 启动执行器
func (t *Thermostat) Start(ctx context.Context) error {
 // 订阅命令主题
 commandTopic := fmt.Sprintf("device/%s/command", t.DeviceID)
 
 return t.client.Subscribe(commandTopic, 1, func(client paho.Client, msg paho.Message) {
  t.handleCommand(msg.Payload())
 })
}

// handleCommand 处理命令
func (t *Thermostat) handleCommand(payload []byte) {
 var cmd Command
 if err := json.Unmarshal(payload, &cmd); err != nil {
  log.Printf("❌ 解析命令失败: %v", err)
  return
 }

 log.Printf("📥 收到命令: %s (%s)", cmd.Type, cmd.CommandID)

 var resp CommandResponse
 resp.CommandID = cmd.CommandID
 resp.Timestamp = time.Now().Unix()

 switch cmd.Type {
 case "set_temperature":
  temp, ok := cmd.Parameters["temperature"].(float64)
  if !ok {
   resp.Status = "failed"
   resp.Message = "invalid temperature parameter"
  } else {
   t.targetTemp = temp
   resp.Status = "success"
   resp.Message = fmt.Sprintf("temperature set to %.1f°C", temp)
   log.Printf("🌡️  设置目标温度: %.1f°C", temp)
  }

 case "restart":
  resp.Status = "success"
  resp.Message = "device restarting"
  log.Printf("🔄 设备重启中...")

 default:
  resp.Status = "failed"
  resp.Message = "unknown command type"
 }

 // 发送响应
 t.sendResponse(resp)
}

// sendResponse 发送命令响应
func (t *Thermostat) sendResponse(resp CommandResponse) {
 topic := fmt.Sprintf("device/%s/response", t.DeviceID)
 payload, _ := json.Marshal(resp)
 t.client.Publish(topic, 1, payload)
}
```

---

## 3. CoAP协议实战

### 3.1 CoAP协议基础

```go
package coap

import (
 "context"
 "fmt"
 "log"
 "time"

 "github.com/plgd-dev/go-coap/v3/udp"
 "github.com/plgd-dev/go-coap/v3/message"
)

// CoAP协议特点
/*
CoAP (Constrained Application Protocol)

核心特性:
  ✅ 超轻量级 (比MQTT更轻)
  ✅ 基于UDP (低开销)
  ✅ RESTful设计 (GET/POST/PUT/DELETE)
  ✅ 资源发现 (/.well-known/core)
  ✅ 观察模式 (Observe)

vs MQTT:
  CoAP           | MQTT
  ------------------------------
  UDP (无连接)    | TCP (连接)
  RESTful        | Pub/Sub
  请求/响应       | 发布/订阅
  资源寻址       | 主题寻址

适用场景:
  • 极度资源受限设备 (RAM < 10KB)
  • 一对一通信
  • 需要RESTful语义
*/

// CoapServer CoAP服务器
type CoapServer struct {
 addr      string
 resources map[string]ResourceHandler
 mu        sync.RWMutex
}

// ResourceHandler 资源处理器
type ResourceHandler func(req *message.Message) (*message.Message, error)

// NewCoapServer 创建CoAP服务器
func NewCoapServer(addr string) *CoapServer {
 return &CoapServer{
  addr:      addr,
  resources: make(map[string]ResourceHandler),
 }
}

// RegisterResource 注册资源
func (cs *CoapServer) RegisterResource(path string, handler ResourceHandler) {
 cs.mu.Lock()
 defer cs.mu.Unlock()
 cs.resources[path] = handler
 log.Printf("📍 注册CoAP资源: %s", path)
}

// Start 启动服务器
func (cs *CoapServer) Start(ctx context.Context) error {
 handler := func(w *udp.ResponseWriter, r *udp.Message) {
  path, _ := r.Options().Path()
  log.Printf("📥 CoAP请求: %s %s", r.Code(), path)

  cs.mu.RLock()
  handler, ok := cs.resources[path]
  cs.mu.RUnlock()

  if !ok {
   // 404 Not Found
   w.SetResponse(message.NotFound, message.TextPlain, nil)
   return
  }

  // 调用资源处理器
  resp, err := handler(r.Message)
  if err != nil {
   w.SetResponse(message.InternalServerError, message.TextPlain, []byte(err.Error()))
   return
  }

  // 发送响应
  w.SetResponse(resp.Code(), resp.Options().ContentFormat(), resp.Body())
 }

 log.Printf("🚀 CoAP服务器启动: %s", cs.addr)
 return udp.ListenAndServe("udp", cs.addr, handler)
}
```

### 3.2 资源读取与观察模式

```go
package coap

import (
 "encoding/json"
 "fmt"
 "sync"
 "time"
)

// SensorResource 传感器资源
type SensorResource struct {
 sensorID  string
 mu        sync.RWMutex
 lastValue float64
 observers []Observer
}

// Observer 观察者
type Observer struct {
 Token    []byte
 Observe  uint32
 Callback func(value float64)
}

// HandleGet 处理GET请求
func (sr *SensorResource) HandleGet(req *message.Message) (*message.Message, error) {
 sr.mu.RLock()
 value := sr.lastValue
 sr.mu.RUnlock()

 // 构造响应数据
 data := map[string]interface{}{
  "sensor_id": sr.sensorID,
  "value":     value,
  "unit":      "°C",
  "timestamp": time.Now().Unix(),
 }

 payload, _ := json.Marshal(data)

 // 创建响应消息
 resp := message.Message{}
 resp.SetCode(message.Content)
 resp.SetContentFormat(message.AppJSON)
 resp.SetBody(payload)

 // 检查是否为Observe请求
 observe, err := req.Options().Observe()
 if err == nil && observe == 0 {
  // 添加观察者
  sr.addObserver(req.Token())
  log.Printf("👀 添加观察者: %s", sr.sensorID)
 }

 return &resp, nil
}

// HandlePut 处理PUT请求 (设置值)
func (sr *SensorResource) HandlePut(req *message.Message) (*message.Message, error) {
 var data struct {
  Value float64 `json:"value"`
 }

 if err := json.Unmarshal(req.Body(), &data); err != nil {
  return nil, fmt.Errorf("invalid payload: %w", err)
 }

 sr.mu.Lock()
 sr.lastValue = data.Value
 sr.mu.Unlock()

 log.Printf("✍️  设置传感器值: %.2f", data.Value)

 // 通知观察者
 sr.notifyObservers(data.Value)

 // 响应
 resp := message.Message{}
 resp.SetCode(message.Changed)
 return &resp, nil
}

// addObserver 添加观察者
func (sr *SensorResource) addObserver(token []byte) {
 sr.mu.Lock()
 defer sr.mu.Unlock()

 sr.observers = append(sr.observers, Observer{
  Token:   token,
  Observe: uint32(time.Now().Unix()),
 })
}

// notifyObservers 通知所有观察者
func (sr *SensorResource) notifyObservers(value float64) {
 sr.mu.RLock()
 observers := sr.observers
 sr.mu.RUnlock()

 for _, obs := range observers {
  if obs.Callback != nil {
   obs.Callback(value)
  }
 }
}

// StartDataUpdate 模拟数据更新
func (sr *SensorResource) StartDataUpdate(ctx context.Context, interval time.Duration) {
 ticker := time.NewTicker(interval)
 defer ticker.Stop()

 for {
  select {
  case <-ctx.Done():
   return
  case <-ticker.C:
   // 模拟传感器数据变化
   newValue := 20.0 + rand.Float64()*10.0

   sr.mu.Lock()
   sr.lastValue = newValue
   sr.mu.Unlock()

   // 通知观察者
   sr.notifyObservers(newValue)
  }
 }
}
```

---

## 4. 设备管理系统

### 4.1 设备生命周期管理

```go
package device

import (
 "context"
 "database/sql"
 "fmt"
 "time"

 _ "github.com/lib/pq"
)

// DeviceStatus 设备状态
type DeviceStatus string

const (
 StatusOnline    DeviceStatus = "online"
 StatusOffline   DeviceStatus = "offline"
 StatusMaintenance DeviceStatus = "maintenance"
 StatusError     DeviceStatus = "error"
)

// Device 设备信息
type Device struct {
 DeviceID     string       `json:"device_id"`
 Name         string       `json:"name"`
 Type         string       `json:"type"` // "sensor", "actuator", "gateway"
 Model        string       `json:"model"`
 FirmwareVer  string       `json:"firmware_version"`
 Status       DeviceStatus `json:"status"`
 Location     string       `json:"location"`
 LastSeen     time.Time    `json:"last_seen"`
 RegisteredAt time.Time    `json:"registered_at"`
 Metadata     map[string]string `json:"metadata"`
}

// DeviceManager 设备管理器
type DeviceManager struct {
 db *sql.DB
}

// NewDeviceManager 创建设备管理器
func NewDeviceManager(dbURL string) (*DeviceManager, error) {
 db, err := sql.Open("postgres", dbURL)
 if err != nil {
  return nil, err
 }

 // 创建设备表
 _, err = db.Exec(`
  CREATE TABLE IF NOT EXISTS devices (
   device_id VARCHAR(255) PRIMARY KEY,
   name VARCHAR(255) NOT NULL,
   type VARCHAR(50) NOT NULL,
   model VARCHAR(255),
   firmware_version VARCHAR(50),
   status VARCHAR(50) NOT NULL,
   location VARCHAR(255),
   last_seen TIMESTAMP,
   registered_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
   metadata JSONB
  )
 `)
 if err != nil {
  return nil, err
 }

 return &DeviceManager{db: db}, nil
}

// RegisterDevice 注册设备
func (dm *DeviceManager) RegisterDevice(ctx context.Context, device *Device) error {
 device.RegisteredAt = time.Now()
 device.Status = StatusOffline

 _, err := dm.db.ExecContext(ctx, `
  INSERT INTO devices (device_id, name, type, model, firmware_version, status, location, registered_at)
  VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
  ON CONFLICT (device_id) DO UPDATE
  SET name = EXCLUDED.name,
      type = EXCLUDED.type,
      model = EXCLUDED.model
 `, device.DeviceID, device.Name, device.Type, device.Model, 
    device.FirmwareVer, device.Status, device.Location, device.RegisteredAt)

 if err != nil {
  return fmt.Errorf("注册设备失败: %w", err)
 }

 log.Printf("✅ 设备已注册: %s (%s)", device.Name, device.DeviceID)
 return nil
}

// UpdateDeviceStatus 更新设备状态
func (dm *DeviceManager) UpdateDeviceStatus(ctx context.Context, deviceID string, status DeviceStatus) error {
 _, err := dm.db.ExecContext(ctx, `
  UPDATE devices
  SET status = $1, last_seen = $2
  WHERE device_id = $3
 `, status, time.Now(), deviceID)

 if err != nil {
  return fmt.Errorf("更新设备状态失败: %w", err)
 }

 return nil
}

// GetDevice 获取设备信息
func (dm *DeviceManager) GetDevice(ctx context.Context, deviceID string) (*Device, error) {
 var device Device
 err := dm.db.QueryRowContext(ctx, `
  SELECT device_id, name, type, model, firmware_version, status, location, last_seen, registered_at
  FROM devices
  WHERE device_id = $1
 `, deviceID).Scan(
  &device.DeviceID, &device.Name, &device.Type, &device.Model,
  &device.FirmwareVer, &device.Status, &device.Location,
  &device.LastSeen, &device.RegisteredAt,
 )

 if err != nil {
  return nil, fmt.Errorf("获取设备失败: %w", err)
 }

 return &device, nil
}

// ListDevices 列出设备
func (dm *DeviceManager) ListDevices(ctx context.Context, filter DeviceFilter) ([]*Device, error) {
 query := `SELECT device_id, name, type, model, firmware_version, status, location, last_seen, registered_at
           FROM devices WHERE 1=1`
 args := []interface{}{}
 argIdx := 1

 if filter.Type != "" {
  query += fmt.Sprintf(" AND type = $%d", argIdx)
  args = append(args, filter.Type)
  argIdx++
 }

 if filter.Status != "" {
  query += fmt.Sprintf(" AND status = $%d", argIdx)
  args = append(args, filter.Status)
  argIdx++
 }

 query += " ORDER BY registered_at DESC"

 rows, err := dm.db.QueryContext(ctx, query, args...)
 if err != nil {
  return nil, err
 }
 defer rows.Close()

 var devices []*Device
 for rows.Next() {
  var device Device
  if err := rows.Scan(
   &device.DeviceID, &device.Name, &device.Type, &device.Model,
   &device.FirmwareVer, &device.Status, &device.Location,
   &device.LastSeen, &device.RegisteredAt,
  ); err != nil {
   return nil, err
  }
  devices = append(devices, &device)
 }

 return devices, nil
}

// DeviceFilter 设备过滤器
type DeviceFilter struct {
 Type   string
 Status DeviceStatus
}

// DeleteDevice 删除设备
func (dm *DeviceManager) DeleteDevice(ctx context.Context, deviceID string) error {
 _, err := dm.db.ExecContext(ctx, `DELETE FROM devices WHERE device_id = $1`, deviceID)
 if err != nil {
  return fmt.Errorf("删除设备失败: %w", err)
 }

 log.Printf("🗑️  设备已删除: %s", deviceID)
 return nil
}
```

### 4.2 设备影子 (Device Shadow)

```go
package shadow

import (
 "context"
 "encoding/json"
 "fmt"
 "sync"
 "time"
)

// DeviceShadow 设备影子
/*
设备影子 (Device Shadow/Digital Twin):
  • 云端维护的设备状态副本
  • 解决设备离线问题
  • 期望状态 (Desired) vs 实际状态 (Reported)

架构:
  Device → 上报实际状态 → Shadow (Reported State)
  Cloud  → 下发期望状态 → Shadow (Desired State)
  Device → 同步差异     → 最终一致
*/

// Shadow 影子文档
type Shadow struct {
 State ShadowState `json:"state"`
 Metadata Metadata `json:"metadata"`
 Version  int64    `json:"version"`
}

// ShadowState 影子状态
type ShadowState struct {
 Desired  map[string]interface{} `json:"desired"`  // 期望状态
 Reported map[string]interface{} `json:"reported"` // 实际状态
 Delta    map[string]interface{} `json:"delta"`    // 差异
}

// Metadata 元数据
type Metadata struct {
 Desired  map[string]Timestamp `json:"desired"`
 Reported map[string]Timestamp `json:"reported"`
}

// Timestamp 时间戳
type Timestamp struct {
 Timestamp int64 `json:"timestamp"`
}

// ShadowService 影子服务
type ShadowService struct {
 mu      sync.RWMutex
 shadows map[string]*Shadow // deviceID -> Shadow
}

// NewShadowService 创建影子服务
func NewShadowService() *ShadowService {
 return &ShadowService{
  shadows: make(map[string]*Shadow),
 }
}

// UpdateReported 更新实际状态 (设备上报)
func (ss *ShadowService) UpdateReported(deviceID string, reported map[string]interface{}) (*Shadow, error) {
 ss.mu.Lock()
 defer ss.mu.Unlock()

 shadow, ok := ss.shadows[deviceID]
 if !ok {
  // 创建新影子
  shadow = &Shadow{
   State: ShadowState{
    Desired:  make(map[string]interface{}),
    Reported: make(map[string]interface{}),
    Delta:    make(map[string]interface{}),
   },
   Metadata: Metadata{
    Desired:  make(map[string]Timestamp),
    Reported: make(map[string]Timestamp),
   },
   Version: 1,
  }
  ss.shadows[deviceID] = shadow
 } else {
  shadow.Version++
 }

 // 更新reported状态
 now := time.Now().Unix()
 for key, value := range reported {
  shadow.State.Reported[key] = value
  shadow.Metadata.Reported[key] = Timestamp{Timestamp: now}
 }

 // 计算delta (desired - reported)
 shadow.State.Delta = ss.calculateDelta(shadow.State.Desired, shadow.State.Reported)

 log.Printf("📊 更新设备影子(Reported): %s, version: %d", deviceID, shadow.Version)
 return shadow, nil
}

// UpdateDesired 更新期望状态 (云端下发)
func (ss *ShadowService) UpdateDesired(deviceID string, desired map[string]interface{}) (*Shadow, error) {
 ss.mu.Lock()
 defer ss.mu.Unlock()

 shadow, ok := ss.shadows[deviceID]
 if !ok {
  shadow = &Shadow{
   State: ShadowState{
    Desired:  make(map[string]interface{}),
    Reported: make(map[string]interface{}),
    Delta:    make(map[string]interface{}),
   },
   Metadata: Metadata{
    Desired:  make(map[string]Timestamp),
    Reported: make(map[string]Timestamp),
   },
   Version: 1,
  }
  ss.shadows[deviceID] = shadow
 } else {
  shadow.Version++
 }

 // 更新desired状态
 now := time.Now().Unix()
 for key, value := range desired {
  shadow.State.Desired[key] = value
  shadow.Metadata.Desired[key] = Timestamp{Timestamp: now}
 }

 // 计算delta
 shadow.State.Delta = ss.calculateDelta(shadow.State.Desired, shadow.State.Reported)

 log.Printf("🎯 更新设备影子(Desired): %s, version: %d", deviceID, shadow.Version)
 return shadow, nil
}

// GetShadow 获取影子
func (ss *ShadowService) GetShadow(deviceID string) (*Shadow, error) {
 ss.mu.RLock()
 defer ss.mu.RUnlock()

 shadow, ok := ss.shadows[deviceID]
 if !ok {
  return nil, fmt.Errorf("设备影子不存在: %s", deviceID)
 }

 return shadow, nil
}

// calculateDelta 计算差异
func (ss *ShadowService) calculateDelta(desired, reported map[string]interface{}) map[string]interface{} {
 delta := make(map[string]interface{})

 for key, desiredValue := range desired {
  reportedValue, exists := reported[key]
  if !exists || desiredValue != reportedValue {
   delta[key] = desiredValue
  }
 }

 return delta
}
```

---

## 5. OTA固件升级

### 5.1 OTA升级架构

```go
package ota

import (
 "context"
 "crypto/sha256"
 "encoding/hex"
 "fmt"
 "io"
 "log"
 "os"
 "sync"
)

// OTA (Over-The-Air) 固件升级
/*
OTA升级流程:
  1. 检查更新: 设备请求固件版本
  2. 下载固件: 分块下载 (Chunked)
  3. 校验固件: SHA256哈希校验
  4. 安装固件: 写入Flash
  5. 重启设备: 启动新固件
  6. 回滚机制: 失败时回滚

关键技术:
  ✅ 断点续传 (Resume)
  ✅ 差分升级 (Delta Update)
  ✅ A/B分区 (Dual Boot)
  ✅ 签名验证 (Signature Verification)
  ✅ 批量升级 (Batch Update)
*/

// Firmware 固件信息
type Firmware struct {
 Version     string            `json:"version"`
 URL         string            `json:"url"`
 Size        int64             `json:"size"`
 SHA256      string            `json:"sha256"`
 ReleaseNote string            `json:"release_note"`
 Metadata    map[string]string `json:"metadata"`
}

// OTAManager OTA管理器
type OTAManager struct {
 mu              sync.RWMutex
 firmwareRepo    map[string]*Firmware // version -> firmware
 deviceFirmware  map[string]string    // deviceID -> currentVersion
 upgradeProgress map[string]*UpgradeProgress
}

// UpgradeProgress 升级进度
type UpgradeProgress struct {
 DeviceID       string
 TargetVersion  string
 Status         UpgradeStatus
 Progress       float64 // 0-100
 BytesDownloaded int64
 TotalBytes     int64
 StartTime      time.Time
 Error          string
}

// UpgradeStatus 升级状态
type UpgradeStatus string

const (
 StatusPending    UpgradeStatus = "pending"
 StatusDownloading UpgradeStatus = "downloading"
 StatusVerifying   UpgradeStatus = "verifying"
 StatusInstalling  UpgradeStatus = "installing"
 StatusCompleted   UpgradeStatus = "completed"
 StatusFailed      UpgradeStatus = "failed"
)

// NewOTAManager 创建OTA管理器
func NewOTAManager() *OTAManager {
 return &OTAManager{
  firmwareRepo:    make(map[string]*Firmware),
  deviceFirmware:  make(map[string]string),
  upgradeProgress: make(map[string]*UpgradeProgress),
 }
}

// RegisterFirmware 注册固件
func (om *OTAManager) RegisterFirmware(firmware *Firmware) error {
 om.mu.Lock()
 defer om.mu.Unlock()

 om.firmwareRepo[firmware.Version] = firmware
 log.Printf("📦 注册固件: %s (%d bytes)", firmware.Version, firmware.Size)
 return nil
}

// CheckUpdate 检查更新
func (om *OTAManager) CheckUpdate(deviceID, currentVersion string) (*Firmware, bool) {
 om.mu.RLock()
 defer om.mu.RUnlock()

 // 简单版本比较 (实际应用应使用semver)
 latestVersion := om.getLatestVersion()
 if latestVersion == "" || latestVersion == currentVersion {
  return nil, false // 无更新
 }

 firmware := om.firmwareRepo[latestVersion]
 log.Printf("🔄 设备 %s 有更新: %s -> %s", deviceID, currentVersion, latestVersion)
 return firmware, true
}

// getLatestVersion 获取最新版本
func (om *OTAManager) getLatestVersion() string {
 var latest string
 for version := range om.firmwareRepo {
  if latest == "" || version > latest {
   latest = version
  }
 }
 return latest
}

// StartUpgrade 开始升级
func (om *OTAManager) StartUpgrade(ctx context.Context, deviceID, targetVersion string) error {
 om.mu.RLock()
 firmware, ok := om.firmwareRepo[targetVersion]
 om.mu.RUnlock()

 if !ok {
  return fmt.Errorf("固件版本不存在: %s", targetVersion)
 }

 // 创建升级进度
 progress := &UpgradeProgress{
  DeviceID:      deviceID,
  TargetVersion: targetVersion,
  Status:        StatusPending,
  Progress:      0,
  TotalBytes:    firmware.Size,
  StartTime:     time.Now(),
 }

 om.mu.Lock()
 om.upgradeProgress[deviceID] = progress
 om.mu.Unlock()

 // 异步执行升级
 go om.performUpgrade(ctx, deviceID, firmware, progress)

 return nil
}

// performUpgrade 执行升级
func (om *OTAManager) performUpgrade(ctx context.Context, deviceID string, firmware *Firmware, progress *UpgradeProgress) {
 // 1. 下载固件
 progress.Status = StatusDownloading
 log.Printf("⬇️  下载固件: %s", firmware.Version)

 firmwarePath, err := om.downloadFirmware(ctx, firmware, progress)
 if err != nil {
  progress.Status = StatusFailed
  progress.Error = err.Error()
  log.Printf("❌ 下载失败: %v", err)
  return
 }

 // 2. 校验固件
 progress.Status = StatusVerifying
 log.Printf("🔍 校验固件...")

 if err := om.verifyFirmware(firmwarePath, firmware.SHA256); err != nil {
  progress.Status = StatusFailed
  progress.Error = err.Error()
  log.Printf("❌ 校验失败: %v", err)
  return
 }

 // 3. 安装固件
 progress.Status = StatusInstalling
 log.Printf("⚙️  安装固件...")

 if err := om.installFirmware(deviceID, firmwarePath); err != nil {
  progress.Status = StatusFailed
  progress.Error = err.Error()
  log.Printf("❌ 安装失败: %v", err)
  return
 }

 // 4. 完成
 progress.Status = StatusCompleted
 progress.Progress = 100
 om.deviceFirmware[deviceID] = firmware.Version
 log.Printf("✅ 升级完成: %s -> %s", deviceID, firmware.Version)
}

// downloadFirmware 下载固件
func (om *OTAManager) downloadFirmware(ctx context.Context, firmware *Firmware, progress *UpgradeProgress) (string, error) {
 // 这里应该实现HTTP(S)下载，支持断点续传
 // 简化示例: 假设固件已存在本地
 firmwarePath := fmt.Sprintf("/tmp/firmware_%s.bin", firmware.Version)

 // 模拟下载进度
 chunkSize := int64(1024 * 1024) // 1MB
 for downloaded := int64(0); downloaded < firmware.Size; downloaded += chunkSize {
  select {
  case <-ctx.Done():
   return "", ctx.Err()
  default:
   progress.BytesDownloaded = downloaded
   progress.Progress = float64(downloaded) / float64(firmware.Size) * 100
   time.Sleep(100 * time.Millisecond) // 模拟下载延迟
  }
 }

 progress.BytesDownloaded = firmware.Size
 progress.Progress = 100

 return firmwarePath, nil
}

// verifyFirmware 校验固件
func (om *OTAManager) verifyFirmware(path, expectedSHA256 string) error {
 file, err := os.Open(path)
 if err != nil {
  return err
 }
 defer file.Close()

 hash := sha256.New()
 if _, err := io.Copy(hash, file); err != nil {
  return err
 }

 actualSHA256 := hex.EncodeToString(hash.Sum(nil))
 if actualSHA256 != expectedSHA256 {
  return fmt.Errorf("SHA256不匹配: expected=%s, actual=%s", expectedSHA256, actualSHA256)
 }

 return nil
}

// installFirmware 安装固件
func (om *OTAManager) installFirmware(deviceID, firmwarePath string) error {
 // 实际实现应该:
 // 1. 通过MQTT/CoAP发送固件给设备
 // 2. 设备写入Flash
 // 3. 设备重启并验证

 log.Printf("📤 发送固件到设备: %s", deviceID)
 time.Sleep(2 * time.Second) // 模拟安装延迟

 return nil
}

// GetUpgradeProgress 获取升级进度
func (om *OTAManager) GetUpgradeProgress(deviceID string) (*UpgradeProgress, error) {
 om.mu.RLock()
 defer om.mu.RUnlock()

 progress, ok := om.upgradeProgress[deviceID]
 if !ok {
  return nil, fmt.Errorf("无升级任务: %s", deviceID)
 }

 return progress, nil
}
```

---

## 6. 边缘数据处理

### 6.1 时序数据库集成

```go
package timeseries

import (
 "context"
 "fmt"
 "time"

 influxdb2 "github.com/influxdata/influxdb-client-go/v2"
 "github.com/influxdata/influxdb-client-go/v2/api"
)

// InfluxDB时序数据库
/*
时序数据库特点:
  ✅ 高写入吞吐 (100K+ writes/sec)
  ✅ 数据压缩 (压缩比10:1)
  ✅ 数据保留策略 (Retention Policy)
  ✅ 连续查询 (Continuous Query)
  ✅ 降采样 (Downsampling)

InfluxDB核心概念:
  • Measurement: 类似SQL表
  • Tags: 索引字段 (deviceID, location)
  • Fields: 数值字段 (temperature, humidity)
  • Timestamp: 时间戳 (纳秒精度)
*/

// TimeSeriesDB 时序数据库
type TimeSeriesDB struct {
 client   influxdb2.Client
 writeAPI api.WriteAPI
 queryAPI api.QueryAPI
 bucket   string
 org      string
}

// NewTimeSeriesDB 创建时序数据库
func NewTimeSeriesDB(url, token, org, bucket string) *TimeSeriesDB {
 client := influxdb2.NewClient(url, token)

 return &TimeSeriesDB{
  client:   client,
  writeAPI: client.WriteAPI(org, bucket),
  queryAPI: client.QueryAPI(org),
  bucket:   bucket,
  org:      org,
 }
}

// WriteSensorData 写入传感器数据
func (ts *TimeSeriesDB) WriteSensorData(data SensorData) error {
 // 创建数据点
 p := influxdb2.NewPoint(
  "sensor_data",                    // measurement
  map[string]string{                // tags
   "sensor_id": data.SensorID,
   "type":      string(data.Type),
   "location":  data.Location,
  },
  map[string]interface{}{           // fields
   "value":   data.Value,
   "quality": data.Quality,
  },
  time.Unix(data.Timestamp, 0),
 )

 // 异步写入
 ts.writeAPI.WritePoint(p)
 return nil
}

// QueryLatest 查询最新数据
func (ts *TimeSeriesDB) QueryLatest(ctx context.Context, sensorID string) (float64, error) {
 query := fmt.Sprintf(`
  from(bucket:"%s")
   |> range(start: -1h)
   |> filter(fn: (r) => r._measurement == "sensor_data")
   |> filter(fn: (r) => r.sensor_id == "%s")
   |> filter(fn: (r) => r._field == "value")
   |> last()
 `, ts.bucket, sensorID)

 result, err := ts.queryAPI.Query(ctx, query)
 if err != nil {
  return 0, err
 }
 defer result.Close()

 if result.Next() {
  value := result.Record().Value()
  if v, ok := value.(float64); ok {
   return v, nil
  }
 }

 return 0, fmt.Errorf("无数据")
}

// QueryAverage 查询平均值
func (ts *TimeSeriesDB) QueryAverage(ctx context.Context, sensorID string, duration time.Duration) (float64, error) {
 query := fmt.Sprintf(`
  from(bucket:"%s")
   |> range(start: -%s)
   |> filter(fn: (r) => r._measurement == "sensor_data")
   |> filter(fn: (r) => r.sensor_id == "%s")
   |> filter(fn: (r) => r._field == "value")
   |> mean()
 `, ts.bucket, duration.String(), sensorID)

 result, err := ts.queryAPI.Query(ctx, query)
 if err != nil {
  return 0, err
 }
 defer result.Close()

 if result.Next() {
  value := result.Record().Value()
  if v, ok := value.(float64); ok {
   return v, nil
  }
 }

 return 0, fmt.Errorf("无数据")
}

// Close 关闭连接
func (ts *TimeSeriesDB) Close() {
 ts.writeAPI.Flush()
 ts.client.Close()
}
```

### 6.2 边缘数据聚合与预处理

```go
package aggregation

import (
 "context"
 "sync"
 "time"
)

// DataAggregator 数据聚合器
/*
边缘数据聚合:
  • 减少上行数据量 (降低云成本)
  • 本地快速响应 (低延迟)
  • 异常检测 (实时告警)

聚合策略:
  1. 时间窗口聚合 (Tumbling/Sliding)
  2. 采样聚合 (Sampling)
  3. 变化驱动上报 (Change-Driven)
  4. 阈值过滤 (Threshold Filter)
*/

// DataAggregator 数据聚合器
type DataAggregator struct {
 windowSize time.Duration
 mu         sync.RWMutex
 windows    map[string]*AggregationWindow
 outputCh   chan AggregatedData
}

// AggregationWindow 聚合窗口
type AggregationWindow struct {
 SensorID    string
 StartTime   time.Time
 Values      []float64
 Sum         float64
 Count       int64
 Min         float64
 Max         float64
}

// AggregatedData 聚合后数据
type AggregatedData struct {
 SensorID  string
 StartTime time.Time
 EndTime   time.Time
 Count     int64
 Mean      float64
 Min       float64
 Max       float64
 StdDev    float64
}

// NewDataAggregator 创建数据聚合器
func NewDataAggregator(windowSize time.Duration) *DataAggregator {
 return &DataAggregator{
  windowSize: windowSize,
  windows:    make(map[string]*AggregationWindow),
  outputCh:   make(chan AggregatedData, 100),
 }
}

// AddDataPoint 添加数据点
func (da *DataAggregator) AddDataPoint(sensorID string, value float64, timestamp time.Time) {
 da.mu.Lock()
 defer da.mu.Unlock()

 window, ok := da.windows[sensorID]
 if !ok {
  // 创建新窗口
  window = &AggregationWindow{
   SensorID:  sensorID,
   StartTime: timestamp.Truncate(da.windowSize),
   Values:    make([]float64, 0, 100),
   Min:       value,
   Max:       value,
  }
  da.windows[sensorID] = window
 }

 // 检查是否需要关闭当前窗口
 windowEnd := window.StartTime.Add(da.windowSize)
 if timestamp.After(windowEnd) {
  // 计算聚合结果
  aggData := da.computeAggregation(window)
  da.outputCh <- aggData

  // 创建新窗口
  window = &AggregationWindow{
   SensorID:  sensorID,
   StartTime: timestamp.Truncate(da.windowSize),
   Values:    make([]float64, 0, 100),
   Min:       value,
   Max:       value,
  }
  da.windows[sensorID] = window
 }

 // 添加数据点
 window.Values = append(window.Values, value)
 window.Sum += value
 window.Count++

 if value < window.Min {
  window.Min = value
 }
 if value > window.Max {
  window.Max = value
 }
}

// computeAggregation 计算聚合
func (da *DataAggregator) computeAggregation(window *AggregationWindow) AggregatedData {
 mean := window.Sum / float64(window.Count)

 // 计算标准差
 var variance float64
 for _, value := range window.Values {
  diff := value - mean
  variance += diff * diff
 }
 variance /= float64(window.Count)
 stdDev := math.Sqrt(variance)

 return AggregatedData{
  SensorID:  window.SensorID,
  StartTime: window.StartTime,
  EndTime:   window.StartTime.Add(da.windowSize),
  Count:     window.Count,
  Mean:      mean,
  Min:       window.Min,
  Max:       window.Max,
  StdDev:    stdDev,
 }
}

// GetOutputChannel 获取输出通道
func (da *DataAggregator) GetOutputChannel() <-chan AggregatedData {
 return da.outputCh
}

// Close 关闭聚合器
func (da *DataAggregator) Close() {
 close(da.outputCh)
}
```

---

## 7. 边缘-云协同

### 7.1 数据同步策略

```go
package sync

import (
 "context"
 "log"
 "sync"
 "time"
)

// 边缘-云数据同步
/*
同步策略:
  1. 实时同步: 高优先级数据立即上传
  2. 批量同步: 低优先级数据批量上传 (节省带宽)
  3. 增量同步: 只同步变更数据
  4. 离线缓存: 断网时本地缓存，恢复后同步

数据优先级:
  High   : 告警、异常 → 实时上传
  Medium : 统计数据   → 批量上传 (5分钟)
  Low    : 日志       → 批量上传 (1小时)
*/

// DataSyncManager 数据同步管理器
type DataSyncManager struct {
 mu            sync.RWMutex
 highPrioQueue chan SyncData
 medPrioQueue  chan SyncData
 lowPrioQueue  chan SyncData
 cache         *SyncCache
 cloudClient   CloudClient
 online        bool
}

// SyncData 同步数据
type SyncData struct {
 ID        string
 Type      string
 Payload   []byte
 Priority  Priority
 Timestamp time.Time
 Retries   int
}

// Priority 优先级
type Priority int

const (
 PriorityHigh   Priority = 1
 PriorityMedium Priority = 2
 PriorityLow    Priority = 3
)

// CloudClient 云端客户端接口
type CloudClient interface {
 Upload(ctx context.Context, data SyncData) error
 IsOnline() bool
}

// NewDataSyncManager 创建同步管理器
func NewDataSyncManager(cloudClient CloudClient) *DataSyncManager {
 return &DataSyncManager{
  highPrioQueue: make(chan SyncData, 1000),
  medPrioQueue:  make(chan SyncData, 5000),
  lowPrioQueue:  make(chan SyncData, 10000),
  cache:         NewSyncCache(),
  cloudClient:   cloudClient,
  online:        true,
 }
}

// Start 启动同步服务
func (dsm *DataSyncManager) Start(ctx context.Context) {
 // 高优先级: 实时同步
 go dsm.syncWorker(ctx, dsm.highPrioQueue, time.Second*0)

 // 中优先级: 5分钟批量同步
 go dsm.syncWorker(ctx, dsm.medPrioQueue, time.Minute*5)

 // 低优先级: 1小时批量同步
 go dsm.syncWorker(ctx, dsm.lowPrioQueue, time.Hour*1)

 // 监控网络状态
 go dsm.monitorNetworkStatus(ctx)

 // 离线数据恢复
 go dsm.recoverOfflineData(ctx)
}

// Enqueue 加入同步队列
func (dsm *DataSyncManager) Enqueue(data SyncData) error {
 if !dsm.cloudClient.IsOnline() {
  // 离线时缓存到本地
  dsm.cache.Add(data)
  log.Printf("📦 数据已缓存 (离线): %s", data.ID)
  return nil
 }

 // 根据优先级加入不同队列
 switch data.Priority {
 case PriorityHigh:
  select {
  case dsm.highPrioQueue <- data:
  default:
   // 队列满，降级到缓存
   dsm.cache.Add(data)
  }
 case PriorityMedium:
  select {
  case dsm.medPrioQueue <- data:
  default:
   dsm.cache.Add(data)
  }
 case PriorityLow:
  select {
  case dsm.lowPrioQueue <- data:
  default:
   dsm.cache.Add(data)
  }
 }

 return nil
}

// syncWorker 同步工作线程
func (dsm *DataSyncManager) syncWorker(ctx context.Context, queue <-chan SyncData, batchInterval time.Duration) {
 if batchInterval == 0 {
  // 实时同步
  for {
   select {
   case <-ctx.Done():
    return
   case data := <-queue:
    dsm.uploadData(ctx, data)
   }
  }
 } else {
  // 批量同步
  ticker := time.NewTicker(batchInterval)
  defer ticker.Stop()

  var batch []SyncData

  for {
   select {
   case <-ctx.Done():
    return
   case data := <-queue:
    batch = append(batch, data)
   case <-ticker.C:
    if len(batch) > 0 {
     dsm.uploadBatch(ctx, batch)
     batch = batch[:0]
    }
   }
  }
 }
}

// uploadData 上传单条数据
func (dsm *DataSyncManager) uploadData(ctx context.Context, data SyncData) {
 if err := dsm.cloudClient.Upload(ctx, data); err != nil {
  log.Printf("❌ 上传失败: %s, error: %v", data.ID, err)

  // 重试逻辑
  if data.Retries < 3 {
   data.Retries++
   time.Sleep(time.Second * time.Duration(data.Retries))
   dsm.uploadData(ctx, data)
  } else {
   // 放入缓存
   dsm.cache.Add(data)
  }
 } else {
  log.Printf("✅ 上传成功: %s", data.ID)
 }
}

// uploadBatch 批量上传
func (dsm *DataSyncManager) uploadBatch(ctx context.Context, batch []SyncData) {
 log.Printf("📤 批量上传: %d 条数据", len(batch))

 for _, data := range batch {
  dsm.uploadData(ctx, data)
 }
}

// monitorNetworkStatus 监控网络状态
func (dsm *DataSyncManager) monitorNetworkStatus(ctx context.Context) {
 ticker := time.NewTicker(30 * time.Second)
 defer ticker.Stop()

 for {
  select {
  case <-ctx.Done():
   return
  case <-ticker.C:
   online := dsm.cloudClient.IsOnline()
   if online != dsm.online {
    dsm.online = online
    if online {
     log.Printf("🌐 网络已恢复")
    } else {
     log.Printf("❌ 网络已断开")
    }
   }
  }
 }
}

// recoverOfflineData 恢复离线数据
func (dsm *DataSyncManager) recoverOfflineData(ctx context.Context) {
 ticker := time.NewTicker(10 * time.Minute)
 defer ticker.Stop()

 for {
  select {
  case <-ctx.Done():
   return
  case <-ticker.C:
   if dsm.cloudClient.IsOnline() {
    cachedData := dsm.cache.GetAll()
    if len(cachedData) > 0 {
     log.Printf("🔄 恢复离线数据: %d 条", len(cachedData))
     for _, data := range cachedData {
      dsm.Enqueue(data)
     }
     dsm.cache.Clear()
    }
   }
  }
 }
}

// SyncCache 同步缓存
type SyncCache struct {
 mu   sync.RWMutex
 data []SyncData
}

func NewSyncCache() *SyncCache {
 return &SyncCache{
  data: make([]SyncData, 0),
 }
}

func (sc *SyncCache) Add(data SyncData) {
 sc.mu.Lock()
 defer sc.mu.Unlock()
 sc.data = append(sc.data, data)
}

func (sc *SyncCache) GetAll() []SyncData {
 sc.mu.RLock()
 defer sc.mu.RUnlock()
 return append([]SyncData{}, sc.data...)
}

func (sc *SyncCache) Clear() {
 sc.mu.Lock()
 defer sc.mu.Unlock()
 sc.data = sc.data[:0]
}
```

---

## 8. 完整IoT平台

### 8.1 IoT平台架构

```go
package platform

import (
 "context"
 "log"
 "sync"
)

// IoT平台完整架构
/*
┌─────────────────────────────────────────────────────────┐
│                     Cloud Platform                       │
│  ┌───────────┐  ┌──────────┐  ┌────────────┐           │
│  │ Device    │  │  Data    │  │  Analytics │           │
│  │ Management│  │  Storage │  │  & AI      │           │
│  └───────────┘  └──────────┘  └────────────┘           │
└─────────────────────────────────────────────────────────┘
                          ↕
┌─────────────────────────────────────────────────────────┐
│                     Edge Gateway                         │
│  ┌───────────┐  ┌──────────┐  ┌────────────┐           │
│  │ Protocol  │  │  Data    │  │  Local     │           │
│  │ Gateway   │  │  Process │  │  Storage   │           │
│  └───────────┘  └──────────┘  └────────────┘           │
└─────────────────────────────────────────────────────────┘
          ↕                  ↕                  ↕
  ┌─────────────┐    ┌─────────────┐   ┌─────────────┐
  │   Sensors   │    │  Actuators  │   │   Devices   │
  └─────────────┘    └─────────────┘   └─────────────┘
*/

// IoTPlatform IoT平台
type IoTPlatform struct {
 // 设备管理
 DeviceManager *DeviceManager

 // 数据处理
 DataAggregator *DataAggregator
 TimeSeriesDB   *TimeSeriesDB

 // 通信协议
 MQTTBroker  *MQTTClient
 CoapServer  *CoapServer

 // OTA升级
 OTAManager *OTAManager

 // 设备影子
 ShadowService *ShadowService

 // 数据同步
 SyncManager *DataSyncManager

 // 规则引擎
 RuleEngine *RuleEngine

 mu sync.RWMutex
}

// NewIoTPlatform 创建IoT平台
func NewIoTPlatform(config PlatformConfig) (*IoTPlatform, error) {
 // 初始化设备管理
 deviceMgr, err := NewDeviceManager(config.DatabaseURL)
 if err != nil {
  return nil, err
 }

 // 初始化时序数据库
 tsdb := NewTimeSeriesDB(
  config.InfluxURL,
  config.InfluxToken,
  config.InfluxOrg,
  config.InfluxBucket,
 )

 // 初始化MQTT
 mqttClient := NewMQTTClient(config.MQTTBroker, "platform-client")

 // 初始化CoAP
 coapServer := NewCoapServer(config.CoapAddr)

 // 初始化OTA
 otaMgr := NewOTAManager()

 // 初始化设备影子
 shadowSvc := NewShadowService()

 // 初始化数据聚合
 aggregator := NewDataAggregator(config.AggregationWindow)

 // 初始化规则引擎
 ruleEngine := NewRuleEngine()

 return &IoTPlatform{
  DeviceManager:  deviceMgr,
  TimeSeriesDB:   tsdb,
  MQTTBroker:     mqttClient,
  CoapServer:     coapServer,
  OTAManager:     otaMgr,
  ShadowService:  shadowSvc,
  DataAggregator: aggregator,
  RuleEngine:     ruleEngine,
 }, nil
}

// Start 启动平台
func (p *IoTPlatform) Start(ctx context.Context) error {
 // 连接MQTT
 if err := p.MQTTBroker.Connect(ctx); err != nil {
  return fmt.Errorf("MQTT连接失败: %w", err)
 }

 // 启动CoAP服务器
 go func() {
  if err := p.CoapServer.Start(ctx); err != nil {
   log.Printf("CoAP启动失败: %v", err)
  }
 }()

 // 订阅设备遥测数据
 p.subscribeDeviceData()

 // 启动规则引擎
 go p.RuleEngine.Start(ctx)

 log.Println("🚀 IoT平台已启动")
 return nil
}

// subscribeDeviceData 订阅设备数据
func (p *IoTPlatform) subscribeDeviceData() {
 // 订阅所有传感器遥测数据
 p.MQTTBroker.Subscribe("sensor/+/telemetry", 1, func(client paho.Client, msg paho.Message) {
  var data TelemetryData
  if err := json.Unmarshal(msg.Payload(), &data); err != nil {
   log.Printf("❌ 解析遥测数据失败: %v", err)
   return
  }

  // 写入时序数据库
  sensorData := SensorData{
   SensorID:  data.SensorID,
   Type:      SensorType(data.Type),
   Value:     data.Value,
   Timestamp: data.Timestamp,
   Quality:   1.0,
  }

  p.TimeSeriesDB.WriteSensorData(sensorData)

  // 数据聚合
  p.DataAggregator.AddDataPoint(data.SensorID, data.Value, time.Unix(data.Timestamp, 0))

  // 更新设备影子
  reported := map[string]interface{}{
   data.Type: data.Value,
  }
  p.ShadowService.UpdateReported(data.SensorID, reported)

  // 触发规则引擎
  p.RuleEngine.EvaluateRules(data)
 })

 log.Println("📡 已订阅设备遥测数据")
}

// PlatformConfig 平台配置
type PlatformConfig struct {
 DatabaseURL       string
 MQTTBroker        string
 CoapAddr          string
 InfluxURL         string
 InfluxToken       string
 InfluxOrg         string
 InfluxBucket      string
 AggregationWindow time.Duration
}
```

### 8.2 规则引擎

```go
package rules

import (
 "context"
 "fmt"
 "log"
 "sync"
)

// 规则引擎
/*
规则引擎功能:
  • 实时数据监控
  • 阈值告警
  • 自动化控制
  • 复杂事件处理 (CEP)

规则示例:
  IF temperature > 80°C
  THEN send_alert("High Temperature") AND activate_cooling()

  IF vibration > threshold FOR 5 minutes
  THEN send_alert("Abnormal Vibration") AND shutdown_machine()
*/

// RuleEngine 规则引擎
type RuleEngine struct {
 mu     sync.RWMutex
 rules  []*Rule
 actions map[string]ActionFunc
}

// Rule 规则
type Rule struct {
 ID        string
 Name      string
 Condition ConditionFunc
 Actions   []string
 Enabled   bool
}

// ConditionFunc 条件函数
type ConditionFunc func(data TelemetryData) bool

// ActionFunc 动作函数
type ActionFunc func(data TelemetryData) error

// NewRuleEngine 创建规则引擎
func NewRuleEngine() *RuleEngine {
 return &RuleEngine{
  rules:   make([]*Rule, 0),
  actions: make(map[string]ActionFunc),
 }
}

// RegisterAction 注册动作
func (re *RuleEngine) RegisterAction(name string, action ActionFunc) {
 re.mu.Lock()
 defer re.mu.Unlock()

 re.actions[name] = action
 log.Printf("📝 注册动作: %s", name)
}

// AddRule 添加规则
func (re *RuleEngine) AddRule(rule *Rule) {
 re.mu.Lock()
 defer re.mu.Unlock()

 re.rules = append(re.rules, rule)
 log.Printf("✅ 添加规则: %s (%s)", rule.Name, rule.ID)
}

// EvaluateRules 评估规则
func (re *RuleEngine) EvaluateRules(data TelemetryData) {
 re.mu.RLock()
 rules := re.rules
 re.mu.RUnlock()

 for _, rule := range rules {
  if !rule.Enabled {
   continue
  }

  // 评估条件
  if rule.Condition(data) {
   log.Printf("🔔 规则触发: %s (sensor=%s, value=%.2f)", 
    rule.Name, data.SensorID, data.Value)

   // 执行动作
   re.executeActions(rule.Actions, data)
  }
 }
}

// executeActions 执行动作
func (re *RuleEngine) executeActions(actionNames []string, data TelemetryData) {
 re.mu.RLock()
 defer re.mu.RUnlock()

 for _, name := range actionNames {
  action, ok := re.actions[name]
  if !ok {
   log.Printf("❌ 动作不存在: %s", name)
   continue
  }

  if err := action(data); err != nil {
   log.Printf("❌ 执行动作失败 (%s): %v", name, err)
  } else {
   log.Printf("✅ 执行动作: %s", name)
  }
 }
}

// Start 启动规则引擎
func (re *RuleEngine) Start(ctx context.Context) {
 log.Println("🚀 规则引擎已启动")

 <-ctx.Done()
 log.Println("🛑 规则引擎已停止")
}

// 示例规则定义

// HighTemperatureRule 高温告警规则
func HighTemperatureRule(threshold float64) *Rule {
 return &Rule{
  ID:   "rule-high-temp",
  Name: "High Temperature Alert",
  Condition: func(data TelemetryData) bool {
   return data.Type == "temperature" && data.Value > threshold
  },
  Actions: []string{"send_alert", "activate_cooling"},
  Enabled: true,
 }
}

// AbnormalVibrationRule 异常振动规则
func AbnormalVibrationRule(threshold float64) *Rule {
 return &Rule{
  ID:   "rule-vibration",
  Name: "Abnormal Vibration Alert",
  Condition: func(data TelemetryData) bool {
   return data.Type == "vibration" && data.Value > threshold
  },
  Actions: []string{"send_alert", "shutdown_machine"},
  Enabled: true,
 }
}

// 示例动作实现

// SendAlertAction 发送告警动作
func SendAlertAction(alertService AlertService) ActionFunc {
 return func(data TelemetryData) error {
  alert := Alert{
   Title:     fmt.Sprintf("%s Abnormal", data.Type),
   Message:   fmt.Sprintf("Sensor %s reported value %.2f", data.SensorID, data.Value),
   Severity:  "high",
   Timestamp: time.Now(),
  }

  return alertService.Send(alert)
 }
}

// ActivateCoolingAction 启动冷却动作
func ActivateCoolingAction(mqttClient *MQTTClient) ActionFunc {
 return func(data TelemetryData) error {
  cmd := Command{
   CommandID: fmt.Sprintf("cmd-%d", time.Now().Unix()),
   Type:      "activate_cooling",
   Parameters: map[string]interface{}{
    "device_id": data.SensorID,
   },
   Timestamp: time.Now().Unix(),
  }

  payload, _ := json.Marshal(cmd)
  topic := fmt.Sprintf("device/%s/command", data.SensorID)
  
  return mqttClient.Publish(topic, 1, payload)
 }
}

// AlertService 告警服务接口
type AlertService interface {
 Send(alert Alert) error
}

// Alert 告警
type Alert struct {
 Title     string
 Message   string
 Severity  string
 Timestamp time.Time
}
```

---

## 9. 监控与告警

### 9.1 平台监控

```go
package monitoring

import (
 "github.com/prometheus/client_golang/prometheus"
 "github.com/prometheus/client_golang/prometheus/promauto"
)

// IoT平台Prometheus监控指标

var (
 // 设备指标
 DeviceTotal = promauto.NewGaugeVec(
  prometheus.GaugeOpts{
   Name: "iot_device_total",
   Help: "Total number of devices",
  },
  []string{"status", "type"},
 )

 DeviceDataReceived = promauto.NewCounterVec(
  prometheus.CounterOpts{
   Name: "iot_device_data_received_total",
   Help: "Total device data points received",
  },
  []string{"device_id", "type"},
 )

 // MQTT指标
 MQTTMessagesPublished = promauto.NewCounter(
  prometheus.CounterOpts{
   Name: "iot_mqtt_messages_published_total",
   Help: "Total MQTT messages published",
  },
 )

 MQTTMessagesReceived = promauto.NewCounter(
  prometheus.CounterOpts{
   Name: "iot_mqtt_messages_received_total",
   Help: "Total MQTT messages received",
  },
 )

 // OTA指标
 OTAUpgradeTotal = promauto.NewCounterVec(
  prometheus.CounterOpts{
   Name: "iot_ota_upgrade_total",
   Help: "Total OTA upgrades",
  },
  []string{"status"},
 )

 OTAUpgradeDuration = promauto.NewHistogram(
  prometheus.HistogramOpts{
   Name:    "iot_ota_upgrade_duration_seconds",
   Help:    "OTA upgrade duration in seconds",
   Buckets: prometheus.ExponentialBuckets(10, 2, 10), // 10s to 2.8h
  },
 )

 // 边缘计算指标
 EdgeDataProcessed = promauto.NewCounter(
  prometheus.CounterOpts{
   Name: "iot_edge_data_processed_total",
   Help: "Total data points processed at edge",
  },
 )

 EdgeLatency = promauto.NewHistogram(
  prometheus.HistogramOpts{
   Name:    "iot_edge_processing_latency_ms",
   Help:    "Edge data processing latency in milliseconds",
   Buckets: prometheus.ExponentialBuckets(1, 2, 10), // 1ms to 0.5s
  },
 )

 // 规则引擎指标
 RulesEvaluated = promauto.NewCounter(
  prometheus.CounterOpts{
   Name: "iot_rules_evaluated_total",
   Help: "Total rules evaluated",
  },
 )

 RulesTriggered = promauto.NewCounterVec(
  prometheus.CounterOpts{
   Name: "iot_rules_triggered_total",
   Help: "Total rules triggered",
  },
  []string{"rule_id", "rule_name"},
 )

 // 数据同步指标
 DataSyncSuccess = promauto.NewCounter(
  prometheus.CounterOpts{
   Name: "iot_data_sync_success_total",
   Help: "Total successful data syncs",
  },
 )

 DataSyncFailed = promauto.NewCounter(
  prometheus.CounterOpts{
   Name: "iot_data_sync_failed_total",
   Help: "Total failed data syncs",
  },
 )

 DataSyncCached = promauto.NewGauge(
  prometheus.GaugeOpts{
   Name: "iot_data_sync_cached",
   Help: "Number of data points cached (offline)",
  },
 )
)
```

---

## 10. 生产部署

### 10.1 Docker部署

```dockerfile
# Dockerfile
FROM golang:1.25-alpine AS builder

WORKDIR /app

# 复制依赖文件
COPY go.mod go.sum ./
RUN go mod download

# 复制源码
COPY . .

# 编译
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o iot-platform ./cmd/platform

# 运行镜像
FROM alpine:latest

RUN apk --no-cache add ca-certificates

WORKDIR /root/

# 从builder复制二进制文件
COPY --from=builder /app/iot-platform .

# 暴露端口
EXPOSE 8080 1883 5683

# 启动
CMD ["./iot-platform"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  # IoT平台
  iot-platform:
    build: .
    ports:
      - "8080:8080"   # HTTP API
      - "1883:1883"   # MQTT
      - "5683:5683/udp" # CoAP
    environment:
      - DATABASE_URL=postgres://user:pass@postgres:5432/iot?sslmode=disable
      - MQTT_BROKER=tcp://mosquitto:1883
      - INFLUXDB_URL=http://influxdb:8086
      - INFLUXDB_TOKEN=${INFLUXDB_TOKEN}
    depends_on:
      - postgres
      - mosquitto
      - influxdb
    restart: unless-stopped

  # PostgreSQL
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: iot
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
    volumes:
      - postgres-data:/var/lib/postgresql/data
    restart: unless-stopped

  # MQTT Broker (Mosquitto)
  mosquitto:
    image: eclipse-mosquitto:2
    ports:
      - "1883:1883"
      - "9001:9001"
    volumes:
      - ./mosquitto.conf:/mosquitto/config/mosquitto.conf
      - mosquitto-data:/mosquitto/data
      - mosquitto-log:/mosquitto/log
    restart: unless-stopped

  # InfluxDB (时序数据库)
  influxdb:
    image: influxdb:2.7-alpine
    ports:
      - "8086:8086"
    environment:
      - DOCKER_INFLUXDB_INIT_MODE=setup
      - DOCKER_INFLUXDB_INIT_USERNAME=admin
      - DOCKER_INFLUXDB_INIT_PASSWORD=adminpass
      - DOCKER_INFLUXDB_INIT_ORG=iot-org
      - DOCKER_INFLUXDB_INIT_BUCKET=iot-data
      - DOCKER_INFLUXDB_INIT_ADMIN_TOKEN=${INFLUXDB_TOKEN}
    volumes:
      - influxdb-data:/var/lib/influxdb2
    restart: unless-stopped

  # Prometheus (监控)
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus-data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
    restart: unless-stopped

  # Grafana (可视化)
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana-data:/var/lib/grafana
      - ./grafana-dashboards:/etc/grafana/provisioning/dashboards
    depends_on:
      - prometheus
      - influxdb
    restart: unless-stopped

volumes:
  postgres-data:
  mosquitto-data:
  mosquitto-log:
  influxdb-data:
  prometheus-data:
  grafana-data:
```

### 10.2 Kubernetes部署

```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: iot-platform
  namespace: iot
spec:
  replicas: 3
  selector:
    matchLabels:
      app: iot-platform
  template:
    metadata:
      labels:
        app: iot-platform
    spec:
      containers:
      - name: iot-platform
        image: myregistry/iot-platform:v1.0.0
        ports:
        - containerPort: 8080
          name: http
        - containerPort: 1883
          name: mqtt
        - containerPort: 5683
          name: coap
          protocol: UDP
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: iot-secrets
              key: database-url
        - name: INFLUXDB_TOKEN
          valueFrom:
            secretKeyRef:
              name: iot-secrets
              key: influxdb-token
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: iot-platform
  namespace: iot
spec:
  selector:
    app: iot-platform
  type: LoadBalancer
  ports:
  - name: http
    port: 80
    targetPort: 8080
  - name: mqtt
    port: 1883
    targetPort: 1883
  - name: coap
    port: 5683
    targetPort: 5683
    protocol: UDP
```

---

## 总结

### ✅ 核心成果

1. **完整IoT协议栈**
   - MQTT (Pub/Sub, QoS, 遗嘱消息)
   - CoAP (RESTful, 观察模式)
   - Protocol Buffers (二进制序列化)

2. **边缘计算架构**
   - 三层架构 (设备-边缘-云)
   - 数据聚合与预处理
   - 本地推理与决策

3. **设备管理系统**
   - 设备生命周期管理
   - 设备影子 (Digital Twin)
   - OTA固件升级

4. **边缘-云协同**
   - 数据同步策略 (实时/批量)
   - 离线缓存与恢复
   - 优先级队列

5. **规则引擎与告警**
   - 实时数据监控
   - 阈值告警
   - 自动化控制

### 🌟 Go 1.25.3应用

| 特性 | 应用 |
|------|------|
| Goroutine | MQTT/CoAP异步处理 |
| Channel | 数据管道与同步 |
| Context | 超时与取消 |
| Generic | 类型安全的队列 |
| iter.Seq | 传感器数据迭代 |

### 📊 架构亮点

- **低延迟**: 边缘计算 <10ms
- **高可用**: 离线可用 + 自动恢复
- **可扩展**: 水平扩展 + 负载均衡
- **低成本**: 数据聚合降低云成本

### 🎯 适用场景

- 工业物联网 (IIoT)
- 智能交通 (V2X)
- 智能家居
- 智慧城市

---

## 下一步学习

- [ ] LoRaWAN协议实战
- [ ] 边缘AI推理 (TensorFlow Lite)
- [ ] 时序数据库深入 (ClickHouse)
- [ ] 数字孪生 (Digital Twin)

---

> **延伸阅读**:  
> • [MQTT协议规范](https://mqtt.org)  
> • [CoAP协议RFC 7252](https://tools.ietf.org/html/rfc7252)  
> • [AWS IoT Core文档](https://docs.aws.amazon.com/iot/)  
> • [Azure IoT Hub文档](https://docs.microsoft.com/azure/iot-hub/)
