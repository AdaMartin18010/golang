# Go 1.25.3è¾¹ç¼˜è®¡ç®—ä¸IoTå®Œæ•´å®æˆ˜

> **è¾¹ç¼˜è®¡ç®—Â·MQTT/CoAPÂ·è®¾å¤‡ç®¡ç†Â·OTAå‡çº§Â·å®æ—¶æ•°æ®å¤„ç†**
> ğŸ“ **éš¾åº¦**ï¼šâ­â­â­â­â­ (é«˜çº§)
> ğŸ¯ **ç›®æ ‡**ï¼šæ„å»ºç”Ÿäº§çº§IoTè¾¹ç¼˜è®¡ç®—å¹³å°
> â± **é¢„è®¡æ—¶é—´**ï¼š6-8å°æ—¶
> ğŸ”§ **æŠ€æœ¯æ ˆ**ï¼šMQTTÂ·CoAPÂ·NATSÂ·InfluxDBÂ·Protocol BuffersÂ·è¾¹ç¼˜AI

---

## ğŸ“‹ ç›®å½•

- [Go 1.25.3è¾¹ç¼˜è®¡ç®—ä¸IoTå®Œæ•´å®æˆ˜](#go-1253è¾¹ç¼˜è®¡ç®—ä¸iotå®Œæ•´å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ç›®å½•](#ç›®å½•)
  - [1. è¾¹ç¼˜è®¡ç®—æ¶æ„](#1-è¾¹ç¼˜è®¡ç®—æ¶æ„)
    - [1.1 ä¸ºä»€ä¹ˆéœ€è¦è¾¹ç¼˜è®¡ç®—ï¼Ÿ](#11-ä¸ºä»€ä¹ˆéœ€è¦è¾¹ç¼˜è®¡ç®—)
    - [1.2 è¾¹ç¼˜è®¡ç®—ä¸‰å±‚æ¶æ„](#12-è¾¹ç¼˜è®¡ç®—ä¸‰å±‚æ¶æ„)
  - [2. MQTTåè®®å®æˆ˜](#2-mqttåè®®å®æˆ˜)
    - [2.1 MQTTåŸºç¡€æ¶æ„](#21-mqttåŸºç¡€æ¶æ„)
    - [2.2 è®¾å¤‡æ•°æ®é‡‡é›†ä¸ä¸ŠæŠ¥](#22-è®¾å¤‡æ•°æ®é‡‡é›†ä¸ä¸ŠæŠ¥)
    - [2.3 å‘½ä»¤ä¸‹å‘ä¸æ‰§è¡Œ](#23-å‘½ä»¤ä¸‹å‘ä¸æ‰§è¡Œ)
  - [3. CoAPåè®®å®æˆ˜](#3-coapåè®®å®æˆ˜)
    - [3.1 CoAPåè®®åŸºç¡€](#31-coapåè®®åŸºç¡€)
    - [3.2 èµ„æºè¯»å–ä¸è§‚å¯Ÿæ¨¡å¼](#32-èµ„æºè¯»å–ä¸è§‚å¯Ÿæ¨¡å¼)
  - [4. è®¾å¤‡ç®¡ç†ç³»ç»Ÿ](#4-è®¾å¤‡ç®¡ç†ç³»ç»Ÿ)
    - [4.1 è®¾å¤‡ç”Ÿå‘½å‘¨æœŸç®¡ç†](#41-è®¾å¤‡ç”Ÿå‘½å‘¨æœŸç®¡ç†)
    - [4.2 è®¾å¤‡å½±å­ (Device Shadow)](#42-è®¾å¤‡å½±å­-device-shadow)
  - [5. OTAå›ºä»¶å‡çº§](#5-otaå›ºä»¶å‡çº§)
    - [5.1 OTAå‡çº§æ¶æ„](#51-otaå‡çº§æ¶æ„)
  - [6. è¾¹ç¼˜æ•°æ®å¤„ç†](#6-è¾¹ç¼˜æ•°æ®å¤„ç†)
    - [6.1 æ—¶åºæ•°æ®åº“é›†æˆ](#61-æ—¶åºæ•°æ®åº“é›†æˆ)
    - [6.2 è¾¹ç¼˜æ•°æ®èšåˆä¸é¢„å¤„ç†](#62-è¾¹ç¼˜æ•°æ®èšåˆä¸é¢„å¤„ç†)
  - [7. è¾¹ç¼˜-äº‘ååŒ](#7-è¾¹ç¼˜-äº‘ååŒ)
    - [7.1 æ•°æ®åŒæ­¥ç­–ç•¥](#71-æ•°æ®åŒæ­¥ç­–ç•¥)
  - [8. å®Œæ•´IoTå¹³å°](#8-å®Œæ•´iotå¹³å°)
    - [8.1 IoTå¹³å°æ¶æ„](#81-iotå¹³å°æ¶æ„)
    - [8.2 è§„åˆ™å¼•æ“](#82-è§„åˆ™å¼•æ“)
  - [9. ç›‘æ§ä¸å‘Šè­¦](#9-ç›‘æ§ä¸å‘Šè­¦)
    - [9.1 å¹³å°ç›‘æ§](#91-å¹³å°ç›‘æ§)
  - [10. ç”Ÿäº§éƒ¨ç½²](#10-ç”Ÿäº§éƒ¨ç½²)
    - [10.1 Dockeréƒ¨ç½²](#101-dockeréƒ¨ç½²)
    - [10.2 Kuberneteséƒ¨ç½²](#102-kuberneteséƒ¨ç½²)
  - [æ€»ç»“](#æ€»ç»“)
    - [âœ… æ ¸å¿ƒæˆæœ](#-æ ¸å¿ƒæˆæœ)
    - [ğŸŒŸ Go 1.25.3åº”ç”¨](#-go-1253åº”ç”¨)
    - [ğŸ“Š æ¶æ„äº®ç‚¹](#-æ¶æ„äº®ç‚¹)
    - [ğŸ¯ é€‚ç”¨åœºæ™¯](#-é€‚ç”¨åœºæ™¯)
  - [ä¸‹ä¸€æ­¥å­¦ä¹ ](#ä¸‹ä¸€æ­¥å­¦ä¹ )

## ç›®å½•

- [Go 1.25.3è¾¹ç¼˜è®¡ç®—ä¸IoTå®Œæ•´å®æˆ˜](#go-1253è¾¹ç¼˜è®¡ç®—ä¸iotå®Œæ•´å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ç›®å½•](#ç›®å½•)
  - [1. è¾¹ç¼˜è®¡ç®—æ¶æ„](#1-è¾¹ç¼˜è®¡ç®—æ¶æ„)
    - [1.1 ä¸ºä»€ä¹ˆéœ€è¦è¾¹ç¼˜è®¡ç®—ï¼Ÿ](#11-ä¸ºä»€ä¹ˆéœ€è¦è¾¹ç¼˜è®¡ç®—)
    - [1.2 è¾¹ç¼˜è®¡ç®—ä¸‰å±‚æ¶æ„](#12-è¾¹ç¼˜è®¡ç®—ä¸‰å±‚æ¶æ„)
  - [2. MQTTåè®®å®æˆ˜](#2-mqttåè®®å®æˆ˜)
    - [2.1 MQTTåŸºç¡€æ¶æ„](#21-mqttåŸºç¡€æ¶æ„)
    - [2.2 è®¾å¤‡æ•°æ®é‡‡é›†ä¸ä¸ŠæŠ¥](#22-è®¾å¤‡æ•°æ®é‡‡é›†ä¸ä¸ŠæŠ¥)
    - [2.3 å‘½ä»¤ä¸‹å‘ä¸æ‰§è¡Œ](#23-å‘½ä»¤ä¸‹å‘ä¸æ‰§è¡Œ)
  - [3. CoAPåè®®å®æˆ˜](#3-coapåè®®å®æˆ˜)
    - [3.1 CoAPåè®®åŸºç¡€](#31-coapåè®®åŸºç¡€)
    - [3.2 èµ„æºè¯»å–ä¸è§‚å¯Ÿæ¨¡å¼](#32-èµ„æºè¯»å–ä¸è§‚å¯Ÿæ¨¡å¼)
  - [4. è®¾å¤‡ç®¡ç†ç³»ç»Ÿ](#4-è®¾å¤‡ç®¡ç†ç³»ç»Ÿ)
    - [4.1 è®¾å¤‡ç”Ÿå‘½å‘¨æœŸç®¡ç†](#41-è®¾å¤‡ç”Ÿå‘½å‘¨æœŸç®¡ç†)
    - [4.2 è®¾å¤‡å½±å­ (Device Shadow)](#42-è®¾å¤‡å½±å­-device-shadow)
  - [5. OTAå›ºä»¶å‡çº§](#5-otaå›ºä»¶å‡çº§)
    - [5.1 OTAå‡çº§æ¶æ„](#51-otaå‡çº§æ¶æ„)
  - [6. è¾¹ç¼˜æ•°æ®å¤„ç†](#6-è¾¹ç¼˜æ•°æ®å¤„ç†)
    - [6.1 æ—¶åºæ•°æ®åº“é›†æˆ](#61-æ—¶åºæ•°æ®åº“é›†æˆ)
    - [6.2 è¾¹ç¼˜æ•°æ®èšåˆä¸é¢„å¤„ç†](#62-è¾¹ç¼˜æ•°æ®èšåˆä¸é¢„å¤„ç†)
  - [7. è¾¹ç¼˜-äº‘ååŒ](#7-è¾¹ç¼˜-äº‘ååŒ)
    - [7.1 æ•°æ®åŒæ­¥ç­–ç•¥](#71-æ•°æ®åŒæ­¥ç­–ç•¥)
  - [8. å®Œæ•´IoTå¹³å°](#8-å®Œæ•´iotå¹³å°)
    - [8.1 IoTå¹³å°æ¶æ„](#81-iotå¹³å°æ¶æ„)
    - [8.2 è§„åˆ™å¼•æ“](#82-è§„åˆ™å¼•æ“)
  - [9. ç›‘æ§ä¸å‘Šè­¦](#9-ç›‘æ§ä¸å‘Šè­¦)
    - [9.1 å¹³å°ç›‘æ§](#91-å¹³å°ç›‘æ§)
  - [10. ç”Ÿäº§éƒ¨ç½²](#10-ç”Ÿäº§éƒ¨ç½²)
    - [10.1 Dockeréƒ¨ç½²](#101-dockeréƒ¨ç½²)
    - [10.2 Kuberneteséƒ¨ç½²](#102-kuberneteséƒ¨ç½²)
  - [æ€»ç»“](#æ€»ç»“)
    - [âœ… æ ¸å¿ƒæˆæœ](#-æ ¸å¿ƒæˆæœ)
    - [ğŸŒŸ Go 1.25.3åº”ç”¨](#-go-1253åº”ç”¨)
    - [ğŸ“Š æ¶æ„äº®ç‚¹](#-æ¶æ„äº®ç‚¹)
    - [ğŸ¯ é€‚ç”¨åœºæ™¯](#-é€‚ç”¨åœºæ™¯)
  - [ä¸‹ä¸€æ­¥å­¦ä¹ ](#ä¸‹ä¸€æ­¥å­¦ä¹ )

---

## 1. è¾¹ç¼˜è®¡ç®—æ¶æ„

### 1.1 ä¸ºä»€ä¹ˆéœ€è¦è¾¹ç¼˜è®¡ç®—ï¼Ÿ

```go
// è¾¹ç¼˜è®¡ç®— vs äº‘è®¡ç®—å¯¹æ¯”
type ComputingParadigm struct {
 CloudComputing struct {
  Latency    string // "100-500ms"
  Bandwidth  string // "é«˜å¸¦å®½æ¶ˆè€—"
  Offline    string // "ç¦»çº¿ä¸å¯ç”¨" âŒ
  Cost       string // "æŒ‰æµé‡è®¡è´¹"
  Privacy    string // "æ•°æ®ä¸Šäº‘"
 }

 EdgeComputing struct {
  Latency    string // "<10ms" âœ…
  Bandwidth  string // "ä½å¸¦å®½æ¶ˆè€—" âœ…
  Offline    string // "ç¦»çº¿å¯ç”¨" âœ…
  Cost       string // "é™ä½äº‘æˆæœ¬" âœ…
  Privacy    string // "æœ¬åœ°å¤„ç†" âœ…
 }
}

// è¾¹ç¼˜è®¡ç®—å…¸å‹åœºæ™¯
/*
1. å·¥ä¸šç‰©è”ç½‘ (IIoT)
   â€¢ è®¾å¤‡é¢„æµ‹æ€§ç»´æŠ¤
   â€¢ å®æ—¶è´¨é‡æ£€æµ‹
   â€¢ ç”Ÿäº§çº¿ç›‘æ§

2. æ™ºèƒ½äº¤é€š
   â€¢ è½¦è”ç½‘ (V2X)
   â€¢ è‡ªåŠ¨é©¾é©¶
   â€¢ äº¤é€šæµé‡ä¼˜åŒ–

3. æ™ºèƒ½å®¶å±…
   â€¢ è¯­éŸ³æ§åˆ¶
   â€¢ å®‰é˜²ç›‘æ§
   â€¢ èƒ½æºç®¡ç†

4. æ™ºæ…§åŸå¸‚
   â€¢ ç¯å¢ƒç›‘æµ‹
   â€¢ æ™ºèƒ½è·¯ç¯
   â€¢ åƒåœ¾ç®¡ç†
*/
```

### 1.2 è¾¹ç¼˜è®¡ç®—ä¸‰å±‚æ¶æ„

```go
package edge

import (
 "context"
 "sync"
)

// è¾¹ç¼˜è®¡ç®—ä¸‰å±‚æ¶æ„
/*
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Cloud Layer (äº‘å±‚)              â”‚
â”‚  â€¢ æ•°æ®å­˜å‚¨ä¸åˆ†æ                     â”‚
â”‚  â€¢ AIæ¨¡å‹è®­ç»ƒ                        â”‚
â”‚  â€¢ è®¾å¤‡ç®¡ç†å¹³å°                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â†• (æ•°æ®åŒæ­¥)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Edge Layer (è¾¹ç¼˜å±‚)             â”‚
â”‚  â€¢ æœ¬åœ°æ•°æ®å¤„ç†                      â”‚
â”‚  â€¢ AIæ¨ç†                           â”‚
â”‚  â€¢ åè®®è½¬æ¢                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â†• (MQTT/CoAP)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Device Layer (è®¾å¤‡å±‚)            â”‚
â”‚  â€¢ ä¼ æ„Ÿå™¨ (Sensors)                 â”‚
â”‚  â€¢ æ‰§è¡Œå™¨ (Actuators)               â”‚
â”‚  â€¢ å·¥ä¸šè®¾å¤‡                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
*/

// EdgeArchitecture è¾¹ç¼˜è®¡ç®—æ¶æ„å®šä¹‰
type EdgeArchitecture struct {
 // è®¾å¤‡å±‚
 DeviceLayer struct {
  Sensors   []Sensor
  Actuators []Actuator
 }

 // è¾¹ç¼˜å±‚
 EdgeLayer struct {
  EdgeNodes []EdgeNode
  Gateway   EdgeGateway
 }

 // äº‘å±‚
 CloudLayer struct {
  Platform string // "IoTå¹³å°"
  Storage  string // "æ—¶åºæ•°æ®åº“"
 }
}

// EdgeNode è¾¹ç¼˜èŠ‚ç‚¹
type EdgeNode struct {
 NodeID   string
 Location string
 CPU      string // "ARM Cortex-A72"
 Memory   string // "4GB"
 OS       string // "Linux"
}

// Sensor ä¼ æ„Ÿå™¨
type Sensor interface {
 Read(ctx context.Context) (SensorData, error)
 GetType() SensorType
}

// SensorType ä¼ æ„Ÿå™¨ç±»å‹
type SensorType string

const (
 SensorTemperature SensorType = "temperature"
 SensorHumidity    SensorType = "humidity"
 SensorPressure    SensorType = "pressure"
 SensorVibration   SensorType = "vibration"
 SensorCamera      SensorType = "camera"
)

// SensorData ä¼ æ„Ÿå™¨æ•°æ®
type SensorData struct {
 SensorID  string
 Type      SensorType
 Value     interface{}
 Unit      string
 Timestamp int64
 Quality   float64 // æ•°æ®è´¨é‡ 0-1
}
```

---

## 2. MQTTåè®®å®æˆ˜

### 2.1 MQTTåŸºç¡€æ¶æ„

```go
package mqtt

import (
 "context"
 "fmt"
 "log"
 "time"

 paho "github.com/eclipse/paho.mqtt.golang"
)

// MQTTåè®®ç‰¹ç‚¹
/*
MQTT (Message Queuing Telemetry Transport)

æ ¸å¿ƒç‰¹æ€§:
  âœ… è½»é‡çº§ (2å­—èŠ‚å›ºå®šå¤´)
  âœ… ä½å¸¦å®½ (å‹ç¼©é«˜æ•ˆ)
  âœ… QoSä¿è¯ (0, 1, 2ä¸‰ä¸ªçº§åˆ«)
  âœ… æŒä¹…ä¼šè¯
  âœ… é—å˜±æ¶ˆæ¯ (Last Will)

QoSçº§åˆ«:
  â€¢ QoS 0: At most once  (æœ€å¤šä¸€æ¬¡ï¼Œå¯èƒ½ä¸¢å¤±)
  â€¢ QoS 1: At least once (è‡³å°‘ä¸€æ¬¡ï¼Œå¯èƒ½é‡å¤)
  â€¢ QoS 2: Exactly once  (æ°å¥½ä¸€æ¬¡ï¼Œæœ€å¯é ) âœ…

Topicé€šé…ç¬¦:
  â€¢ + : å•å±‚é€šé…ç¬¦  (sensor/+/temperature)
  â€¢ # : å¤šå±‚é€šé…ç¬¦  (sensor/#)
*/

// MQTTClient MQTTå®¢æˆ·ç«¯å°è£…
type MQTTClient struct {
 client  paho.Client
 broker  string
 options *paho.ClientOptions
 mu      sync.RWMutex
 handlers map[string]paho.MessageHandler
}

// NewMQTTClient åˆ›å»ºMQTTå®¢æˆ·ç«¯
func NewMQTTClient(broker, clientID string) *MQTTClient {
 opts := paho.NewClientOptions()
 opts.AddBroker(broker)
 opts.SetClientID(clientID)
 opts.SetCleanSession(false) // æŒä¹…ä¼šè¯
 opts.SetAutoReconnect(true)
 opts.SetMaxReconnectInterval(1 * time.Minute)

 // è¿æ¥è¶…æ—¶
 opts.SetConnectTimeout(10 * time.Second)
 opts.SetKeepAlive(30 * time.Second)

 // é—å˜±æ¶ˆæ¯
 opts.SetWill(
  fmt.Sprintf("device/%s/status", clientID),
  "offline",
  1, // QoS 1
  true, // Retained
 )

 mc := &MQTTClient{
  broker:   broker,
  options:  opts,
  handlers: make(map[string]paho.MessageHandler),
 }

 // è¿æ¥æˆåŠŸå›è°ƒ
 opts.SetOnConnectHandler(func(c paho.Client) {
  log.Printf("âœ… è¿æ¥åˆ°MQTT Broker: %s", broker)
 })

 // è¿æ¥ä¸¢å¤±å›è°ƒ
 opts.SetConnectionLostHandler(func(c paho.Client, err error) {
  log.Printf("âŒ è¿æ¥ä¸¢å¤±: %v", err)
 })

 return mc
}

// Connect è¿æ¥åˆ°Broker
func (mc *MQTTClient) Connect(ctx context.Context) error {
 mc.client = paho.NewClient(mc.options)
 token := mc.client.Connect()

 select {
 case <-token.Done():
  if err := token.Error(); err != nil {
   return fmt.Errorf("è¿æ¥å¤±è´¥: %w", err)
  }
  return nil
 case <-ctx.Done():
  return ctx.Err()
 }
}

// Publish å‘å¸ƒæ¶ˆæ¯
func (mc *MQTTClient) Publish(topic string, qos byte, payload []byte) error {
 token := mc.client.Publish(topic, qos, false, payload)
 token.Wait()
 return token.Error()
}

// Subscribe è®¢é˜…ä¸»é¢˜
func (mc *MQTTClient) Subscribe(topic string, qos byte, handler paho.MessageHandler) error {
 mc.mu.Lock()
 mc.handlers[topic] = handler
 mc.mu.Unlock()

 token := mc.client.Subscribe(topic, qos, handler)
 token.Wait()
 return token.Error()
}

// Disconnect æ–­å¼€è¿æ¥
func (mc *MQTTClient) Disconnect(waitMs uint) {
 mc.client.Disconnect(waitMs)
}
```

### 2.2 è®¾å¤‡æ•°æ®é‡‡é›†ä¸ä¸ŠæŠ¥

```go
package device

import (
 "context"
 "encoding/json"
 "fmt"
 "log"
 "math/rand"
 "time"
)

// TemperatureSensor æ¸©åº¦ä¼ æ„Ÿå™¨
type TemperatureSensor struct {
 SensorID string
 Location string
 client   *MQTTClient
}

// TelemetryData é¥æµ‹æ•°æ®
type TelemetryData struct {
 SensorID  string  `json:"sensor_id"`
 Type      string  `json:"type"`
 Value     float64 `json:"value"`
 Unit      string  `json:"unit"`
 Location  string  `json:"location"`
 Timestamp int64   `json:"timestamp"`
}

// StartReporting å¼€å§‹ä¸ŠæŠ¥æ•°æ®
func (ts *TemperatureSensor) StartReporting(ctx context.Context, interval time.Duration) {
 ticker := time.NewTicker(interval)
 defer ticker.Stop()

 for {
  select {
  case <-ctx.Done():
   return
  case <-ticker.C:
   // è¯»å–ä¼ æ„Ÿå™¨æ•°æ® (æ¨¡æ‹Ÿ)
   temp := ts.readTemperature()

   // æ„é€ é¥æµ‹æ•°æ®
   data := TelemetryData{
    SensorID:  ts.SensorID,
    Type:      "temperature",
    Value:     temp,
    Unit:      "Â°C",
    Location:  ts.Location,
    Timestamp: time.Now().Unix(),
   }

   // å‘å¸ƒåˆ°MQTT
   if err := ts.publishTelemetry(data); err != nil {
    log.Printf("âŒ å‘å¸ƒå¤±è´¥: %v", err)
   } else {
    log.Printf("ğŸ“¤ ä¸ŠæŠ¥æ•°æ®: %.2fÂ°C", temp)
   }
  }
 }
}

// readTemperature è¯»å–æ¸©åº¦ (æ¨¡æ‹Ÿ)
func (ts *TemperatureSensor) readTemperature() float64 {
 // æ¨¡æ‹Ÿæ¸©åº¦æ³¢åŠ¨: 20-30Â°C
 return 20.0 + rand.Float64()*10.0
}

// publishTelemetry å‘å¸ƒé¥æµ‹æ•°æ®
func (ts *TemperatureSensor) publishTelemetry(data TelemetryData) error {
 topic := fmt.Sprintf("sensor/%s/telemetry", ts.SensorID)
 payload, _ := json.Marshal(data)

 // QoS 1: è‡³å°‘ä¸€æ¬¡
 return ts.client.Publish(topic, 1, payload)
}
```

### 2.3 å‘½ä»¤ä¸‹å‘ä¸æ‰§è¡Œ

```go
package actuator

import (
 "encoding/json"
 "fmt"
 "log"
)

// Command æ§åˆ¶å‘½ä»¤
type Command struct {
 CommandID  string                 `json:"command_id"`
 Type       string                 `json:"type"` // "set_temperature", "restart", etc.
 Parameters map[string]interface{} `json:"parameters"`
 Timestamp  int64                  `json:"timestamp"`
}

// CommandResponse å‘½ä»¤å“åº”
type CommandResponse struct {
 CommandID string `json:"command_id"`
 Status    string `json:"status"` // "success", "failed"
 Message   string `json:"message"`
 Timestamp int64  `json:"timestamp"`
}

// Thermostat æ’æ¸©å™¨ (æ‰§è¡Œå™¨ç¤ºä¾‹)
type Thermostat struct {
 DeviceID  string
 client    *MQTTClient
 targetTemp float64
}

// Start å¯åŠ¨æ‰§è¡Œå™¨
func (t *Thermostat) Start(ctx context.Context) error {
 // è®¢é˜…å‘½ä»¤ä¸»é¢˜
 commandTopic := fmt.Sprintf("device/%s/command", t.DeviceID)

 return t.client.Subscribe(commandTopic, 1, func(client paho.Client, msg paho.Message) {
  t.handleCommand(msg.Payload())
 })
}

// handleCommand å¤„ç†å‘½ä»¤
func (t *Thermostat) handleCommand(payload []byte) {
 var cmd Command
 if err := json.Unmarshal(payload, &cmd); err != nil {
  log.Printf("âŒ è§£æå‘½ä»¤å¤±è´¥: %v", err)
  return
 }

 log.Printf("ğŸ“¥ æ”¶åˆ°å‘½ä»¤: %s (%s)", cmd.Type, cmd.CommandID)

 var resp CommandResponse
 resp.CommandID = cmd.CommandID
 resp.Timestamp = time.Now().Unix()

 switch cmd.Type {
 case "set_temperature":
  temp, ok := cmd.Parameters["temperature"].(float64)
  if !ok {
   resp.Status = "failed"
   resp.Message = "invalid temperature parameter"
  } else {
   t.targetTemp = temp
   resp.Status = "success"
   resp.Message = fmt.Sprintf("temperature set to %.1fÂ°C", temp)
   log.Printf("ğŸŒ¡ï¸  è®¾ç½®ç›®æ ‡æ¸©åº¦: %.1fÂ°C", temp)
  }

 case "restart":
  resp.Status = "success"
  resp.Message = "device restarting"
  log.Printf("ğŸ”„ è®¾å¤‡é‡å¯ä¸­...")

 default:
  resp.Status = "failed"
  resp.Message = "unknown command type"
 }

 // å‘é€å“åº”
 t.sendResponse(resp)
}

// sendResponse å‘é€å‘½ä»¤å“åº”
func (t *Thermostat) sendResponse(resp CommandResponse) {
 topic := fmt.Sprintf("device/%s/response", t.DeviceID)
 payload, _ := json.Marshal(resp)
 t.client.Publish(topic, 1, payload)
}
```

---

## 3. CoAPåè®®å®æˆ˜

### 3.1 CoAPåè®®åŸºç¡€

```go
package coap

import (
 "context"
 "fmt"
 "log"
 "time"

 "github.com/plgd-dev/go-coap/v3/udp"
 "github.com/plgd-dev/go-coap/v3/message"
)

// CoAPåè®®ç‰¹ç‚¹
/*
CoAP (Constrained Application Protocol)

æ ¸å¿ƒç‰¹æ€§:
  âœ… è¶…è½»é‡çº§ (æ¯”MQTTæ›´è½»)
  âœ… åŸºäºUDP (ä½å¼€é”€)
  âœ… RESTfulè®¾è®¡ (GET/POST/PUT/DELETE)
  âœ… èµ„æºå‘ç° (/.well-known/core)
  âœ… è§‚å¯Ÿæ¨¡å¼ (Observe)

vs MQTT:
  CoAP           | MQTT
  ------------------------------
  UDP (æ— è¿æ¥)    | TCP (è¿æ¥)
  RESTful        | Pub/Sub
  è¯·æ±‚/å“åº”       | å‘å¸ƒ/è®¢é˜…
  èµ„æºå¯»å€       | ä¸»é¢˜å¯»å€

é€‚ç”¨åœºæ™¯:
  â€¢ æåº¦èµ„æºå—é™è®¾å¤‡ (RAM < 10KB)
  â€¢ ä¸€å¯¹ä¸€é€šä¿¡
  â€¢ éœ€è¦RESTfulè¯­ä¹‰
*/

// CoapServer CoAPæœåŠ¡å™¨
type CoapServer struct {
 addr      string
 resources map[string]ResourceHandler
 mu        sync.RWMutex
}

// ResourceHandler èµ„æºå¤„ç†å™¨
type ResourceHandler func(req *message.Message) (*message.Message, error)

// NewCoapServer åˆ›å»ºCoAPæœåŠ¡å™¨
func NewCoapServer(addr string) *CoapServer {
 return &CoapServer{
  addr:      addr,
  resources: make(map[string]ResourceHandler),
 }
}

// RegisterResource æ³¨å†Œèµ„æº
func (cs *CoapServer) RegisterResource(path string, handler ResourceHandler) {
 cs.mu.Lock()
 defer cs.mu.Unlock()
 cs.resources[path] = handler
 log.Printf("ğŸ“ æ³¨å†ŒCoAPèµ„æº: %s", path)
}

// Start å¯åŠ¨æœåŠ¡å™¨
func (cs *CoapServer) Start(ctx context.Context) error {
 handler := func(w *udp.ResponseWriter, r *udp.Message) {
  path, _ := r.Options().Path()
  log.Printf("ğŸ“¥ CoAPè¯·æ±‚: %s %s", r.Code(), path)

  cs.mu.RLock()
  handler, ok := cs.resources[path]
  cs.mu.RUnlock()

  if !ok {
   // 404 Not Found
   w.SetResponse(message.NotFound, message.TextPlain, nil)
   return
  }

  // è°ƒç”¨èµ„æºå¤„ç†å™¨
  resp, err := handler(r.Message)
  if err != nil {
   w.SetResponse(message.InternalServerError, message.TextPlain, []byte(err.Error()))
   return
  }

  // å‘é€å“åº”
  w.SetResponse(resp.Code(), resp.Options().ContentFormat(), resp.Body())
 }

 log.Printf("ğŸš€ CoAPæœåŠ¡å™¨å¯åŠ¨: %s", cs.addr)
 return udp.ListenAndServe("udp", cs.addr, handler)
}
```

### 3.2 èµ„æºè¯»å–ä¸è§‚å¯Ÿæ¨¡å¼

```go
package coap

import (
 "encoding/json"
 "fmt"
 "sync"
 "time"
)

// SensorResource ä¼ æ„Ÿå™¨èµ„æº
type SensorResource struct {
 sensorID  string
 mu        sync.RWMutex
 lastValue float64
 observers []Observer
}

// Observer è§‚å¯Ÿè€…
type Observer struct {
 Token    []byte
 Observe  uint32
 Callback func(value float64)
}

// HandleGet å¤„ç†GETè¯·æ±‚
func (sr *SensorResource) HandleGet(req *message.Message) (*message.Message, error) {
 sr.mu.RLock()
 value := sr.lastValue
 sr.mu.RUnlock()

 // æ„é€ å“åº”æ•°æ®
 data := map[string]interface{}{
  "sensor_id": sr.sensorID,
  "value":     value,
  "unit":      "Â°C",
  "timestamp": time.Now().Unix(),
 }

 payload, _ := json.Marshal(data)

 // åˆ›å»ºå“åº”æ¶ˆæ¯
 resp := message.Message{}
 resp.SetCode(message.Content)
 resp.SetContentFormat(message.AppJSON)
 resp.SetBody(payload)

 // æ£€æŸ¥æ˜¯å¦ä¸ºObserveè¯·æ±‚
 observe, err := req.Options().Observe()
 if err == nil && observe == 0 {
  // æ·»åŠ è§‚å¯Ÿè€…
  sr.addObserver(req.Token())
  log.Printf("ğŸ‘€ æ·»åŠ è§‚å¯Ÿè€…: %s", sr.sensorID)
 }

 return &resp, nil
}

// HandlePut å¤„ç†PUTè¯·æ±‚ (è®¾ç½®å€¼)
func (sr *SensorResource) HandlePut(req *message.Message) (*message.Message, error) {
 var data struct {
  Value float64 `json:"value"`
 }

 if err := json.Unmarshal(req.Body(), &data); err != nil {
  return nil, fmt.Errorf("invalid payload: %w", err)
 }

 sr.mu.Lock()
 sr.lastValue = data.Value
 sr.mu.Unlock()

 log.Printf("âœï¸  è®¾ç½®ä¼ æ„Ÿå™¨å€¼: %.2f", data.Value)

 // é€šçŸ¥è§‚å¯Ÿè€…
 sr.notifyObservers(data.Value)

 // å“åº”
 resp := message.Message{}
 resp.SetCode(message.Changed)
 return &resp, nil
}

// addObserver æ·»åŠ è§‚å¯Ÿè€…
func (sr *SensorResource) addObserver(token []byte) {
 sr.mu.Lock()
 defer sr.mu.Unlock()

 sr.observers = append(sr.observers, Observer{
  Token:   token,
  Observe: uint32(time.Now().Unix()),
 })
}

// notifyObservers é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€…
func (sr *SensorResource) notifyObservers(value float64) {
 sr.mu.RLock()
 observers := sr.observers
 sr.mu.RUnlock()

 for _, obs := range observers {
  if obs.Callback != nil {
   obs.Callback(value)
  }
 }
}

// StartDataUpdate æ¨¡æ‹Ÿæ•°æ®æ›´æ–°
func (sr *SensorResource) StartDataUpdate(ctx context.Context, interval time.Duration) {
 ticker := time.NewTicker(interval)
 defer ticker.Stop()

 for {
  select {
  case <-ctx.Done():
   return
  case <-ticker.C:
   // æ¨¡æ‹Ÿä¼ æ„Ÿå™¨æ•°æ®å˜åŒ–
   newValue := 20.0 + rand.Float64()*10.0

   sr.mu.Lock()
   sr.lastValue = newValue
   sr.mu.Unlock()

   // é€šçŸ¥è§‚å¯Ÿè€…
   sr.notifyObservers(newValue)
  }
 }
}
```

---

## 4. è®¾å¤‡ç®¡ç†ç³»ç»Ÿ

### 4.1 è®¾å¤‡ç”Ÿå‘½å‘¨æœŸç®¡ç†

```go
package device

import (
 "context"
 "database/sql"
 "fmt"
 "time"

 _ "github.com/lib/pq"
)

// DeviceStatus è®¾å¤‡çŠ¶æ€
type DeviceStatus string

const (
 StatusOnline    DeviceStatus = "online"
 StatusOffline   DeviceStatus = "offline"
 StatusMaintenance DeviceStatus = "maintenance"
 StatusError     DeviceStatus = "error"
)

// Device è®¾å¤‡ä¿¡æ¯
type Device struct {
 DeviceID     string       `json:"device_id"`
 Name         string       `json:"name"`
 Type         string       `json:"type"` // "sensor", "actuator", "gateway"
 Model        string       `json:"model"`
 FirmwareVer  string       `json:"firmware_version"`
 Status       DeviceStatus `json:"status"`
 Location     string       `json:"location"`
 LastSeen     time.Time    `json:"last_seen"`
 RegisteredAt time.Time    `json:"registered_at"`
 Metadata     map[string]string `json:"metadata"`
}

// DeviceManager è®¾å¤‡ç®¡ç†å™¨
type DeviceManager struct {
 db *sql.DB
}

// NewDeviceManager åˆ›å»ºè®¾å¤‡ç®¡ç†å™¨
func NewDeviceManager(dbURL string) (*DeviceManager, error) {
 db, err := sql.Open("postgres", dbURL)
 if err != nil {
  return nil, err
 }

 // åˆ›å»ºè®¾å¤‡è¡¨
 _, err = db.Exec(`
  CREATE TABLE IF NOT EXISTS devices (
   device_id VARCHAR(255) PRIMARY KEY,
   name VARCHAR(255) NOT NULL,
   type VARCHAR(50) NOT NULL,
   model VARCHAR(255),
   firmware_version VARCHAR(50),
   status VARCHAR(50) NOT NULL,
   location VARCHAR(255),
   last_seen TIMESTAMP,
   registered_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
   metadata JSONB
  )
 `)
 if err != nil {
  return nil, err
 }

 return &DeviceManager{db: db}, nil
}

// RegisterDevice æ³¨å†Œè®¾å¤‡
func (dm *DeviceManager) RegisterDevice(ctx context.Context, device *Device) error {
 device.RegisteredAt = time.Now()
 device.Status = StatusOffline

 _, err := dm.db.ExecContext(ctx, `
  INSERT INTO devices (device_id, name, type, model, firmware_version, status, location, registered_at)
  VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
  ON CONFLICT (device_id) DO UPDATE
  SET name = EXCLUDED.name,
      type = EXCLUDED.type,
      model = EXCLUDED.model
 `, device.DeviceID, device.Name, device.Type, device.Model,
    device.FirmwareVer, device.Status, device.Location, device.RegisteredAt)

 if err != nil {
  return fmt.Errorf("æ³¨å†Œè®¾å¤‡å¤±è´¥: %w", err)
 }

 log.Printf("âœ… è®¾å¤‡å·²æ³¨å†Œ: %s (%s)", device.Name, device.DeviceID)
 return nil
}

// UpdateDeviceStatus æ›´æ–°è®¾å¤‡çŠ¶æ€
func (dm *DeviceManager) UpdateDeviceStatus(ctx context.Context, deviceID string, status DeviceStatus) error {
 _, err := dm.db.ExecContext(ctx, `
  UPDATE devices
  SET status = $1, last_seen = $2
  WHERE device_id = $3
 `, status, time.Now(), deviceID)

 if err != nil {
  return fmt.Errorf("æ›´æ–°è®¾å¤‡çŠ¶æ€å¤±è´¥: %w", err)
 }

 return nil
}

// GetDevice è·å–è®¾å¤‡ä¿¡æ¯
func (dm *DeviceManager) GetDevice(ctx context.Context, deviceID string) (*Device, error) {
 var device Device
 err := dm.db.QueryRowContext(ctx, `
  SELECT device_id, name, type, model, firmware_version, status, location, last_seen, registered_at
  FROM devices
  WHERE device_id = $1
 `, deviceID).Scan(
  &device.DeviceID, &device.Name, &device.Type, &device.Model,
  &device.FirmwareVer, &device.Status, &device.Location,
  &device.LastSeen, &device.RegisteredAt,
 )

 if err != nil {
  return nil, fmt.Errorf("è·å–è®¾å¤‡å¤±è´¥: %w", err)
 }

 return &device, nil
}

// ListDevices åˆ—å‡ºè®¾å¤‡
func (dm *DeviceManager) ListDevices(ctx context.Context, filter DeviceFilter) ([]*Device, error) {
 query := `SELECT device_id, name, type, model, firmware_version, status, location, last_seen, registered_at
           FROM devices WHERE 1=1`
 args := []interface{}{}
 argIdx := 1

 if filter.Type != "" {
  query += fmt.Sprintf(" AND type = $%d", argIdx)
  args = append(args, filter.Type)
  argIdx++
 }

 if filter.Status != "" {
  query += fmt.Sprintf(" AND status = $%d", argIdx)
  args = append(args, filter.Status)
  argIdx++
 }

 query += " ORDER BY registered_at DESC"

 rows, err := dm.db.QueryContext(ctx, query, args...)
 if err != nil {
  return nil, err
 }
 defer rows.Close()

 var devices []*Device
 for rows.Next() {
  var device Device
  if err := rows.Scan(
   &device.DeviceID, &device.Name, &device.Type, &device.Model,
   &device.FirmwareVer, &device.Status, &device.Location,
   &device.LastSeen, &device.RegisteredAt,
  ); err != nil {
   return nil, err
  }
  devices = append(devices, &device)
 }

 return devices, nil
}

// DeviceFilter è®¾å¤‡è¿‡æ»¤å™¨
type DeviceFilter struct {
 Type   string
 Status DeviceStatus
}

// DeleteDevice åˆ é™¤è®¾å¤‡
func (dm *DeviceManager) DeleteDevice(ctx context.Context, deviceID string) error {
 _, err := dm.db.ExecContext(ctx, `DELETE FROM devices WHERE device_id = $1`, deviceID)
 if err != nil {
  return fmt.Errorf("åˆ é™¤è®¾å¤‡å¤±è´¥: %w", err)
 }

 log.Printf("ğŸ—‘ï¸  è®¾å¤‡å·²åˆ é™¤: %s", deviceID)
 return nil
}
```

### 4.2 è®¾å¤‡å½±å­ (Device Shadow)

```go
package shadow

import (
 "context"
 "encoding/json"
 "fmt"
 "sync"
 "time"
)

// DeviceShadow è®¾å¤‡å½±å­
/*
è®¾å¤‡å½±å­ (Device Shadow/Digital Twin):
  â€¢ äº‘ç«¯ç»´æŠ¤çš„è®¾å¤‡çŠ¶æ€å‰¯æœ¬
  â€¢ è§£å†³è®¾å¤‡ç¦»çº¿é—®é¢˜
  â€¢ æœŸæœ›çŠ¶æ€ (Desired) vs å®é™…çŠ¶æ€ (Reported)

æ¶æ„:
  Device â†’ ä¸ŠæŠ¥å®é™…çŠ¶æ€ â†’ Shadow (Reported State)
  Cloud  â†’ ä¸‹å‘æœŸæœ›çŠ¶æ€ â†’ Shadow (Desired State)
  Device â†’ åŒæ­¥å·®å¼‚     â†’ æœ€ç»ˆä¸€è‡´
*/

// Shadow å½±å­æ–‡æ¡£
type Shadow struct {
 State ShadowState `json:"state"`
 Metadata Metadata `json:"metadata"`
 Version  int64    `json:"version"`
}

// ShadowState å½±å­çŠ¶æ€
type ShadowState struct {
 Desired  map[string]interface{} `json:"desired"`  // æœŸæœ›çŠ¶æ€
 Reported map[string]interface{} `json:"reported"` // å®é™…çŠ¶æ€
 Delta    map[string]interface{} `json:"delta"`    // å·®å¼‚
}

// Metadata å…ƒæ•°æ®
type Metadata struct {
 Desired  map[string]Timestamp `json:"desired"`
 Reported map[string]Timestamp `json:"reported"`
}

// Timestamp æ—¶é—´æˆ³
type Timestamp struct {
 Timestamp int64 `json:"timestamp"`
}

// ShadowService å½±å­æœåŠ¡
type ShadowService struct {
 mu      sync.RWMutex
 shadows map[string]*Shadow // deviceID -> Shadow
}

// NewShadowService åˆ›å»ºå½±å­æœåŠ¡
func NewShadowService() *ShadowService {
 return &ShadowService{
  shadows: make(map[string]*Shadow),
 }
}

// UpdateReported æ›´æ–°å®é™…çŠ¶æ€ (è®¾å¤‡ä¸ŠæŠ¥)
func (ss *ShadowService) UpdateReported(deviceID string, reported map[string]interface{}) (*Shadow, error) {
 ss.mu.Lock()
 defer ss.mu.Unlock()

 shadow, ok := ss.shadows[deviceID]
 if !ok {
  // åˆ›å»ºæ–°å½±å­
  shadow = &Shadow{
   State: ShadowState{
    Desired:  make(map[string]interface{}),
    Reported: make(map[string]interface{}),
    Delta:    make(map[string]interface{}),
   },
   Metadata: Metadata{
    Desired:  make(map[string]Timestamp),
    Reported: make(map[string]Timestamp),
   },
   Version: 1,
  }
  ss.shadows[deviceID] = shadow
 } else {
  shadow.Version++
 }

 // æ›´æ–°reportedçŠ¶æ€
 now := time.Now().Unix()
 for key, value := range reported {
  shadow.State.Reported[key] = value
  shadow.Metadata.Reported[key] = Timestamp{Timestamp: now}
 }

 // è®¡ç®—delta (desired - reported)
 shadow.State.Delta = ss.calculateDelta(shadow.State.Desired, shadow.State.Reported)

 log.Printf("ğŸ“Š æ›´æ–°è®¾å¤‡å½±å­(Reported): %s, version: %d", deviceID, shadow.Version)
 return shadow, nil
}

// UpdateDesired æ›´æ–°æœŸæœ›çŠ¶æ€ (äº‘ç«¯ä¸‹å‘)
func (ss *ShadowService) UpdateDesired(deviceID string, desired map[string]interface{}) (*Shadow, error) {
 ss.mu.Lock()
 defer ss.mu.Unlock()

 shadow, ok := ss.shadows[deviceID]
 if !ok {
  shadow = &Shadow{
   State: ShadowState{
    Desired:  make(map[string]interface{}),
    Reported: make(map[string]interface{}),
    Delta:    make(map[string]interface{}),
   },
   Metadata: Metadata{
    Desired:  make(map[string]Timestamp),
    Reported: make(map[string]Timestamp),
   },
   Version: 1,
  }
  ss.shadows[deviceID] = shadow
 } else {
  shadow.Version++
 }

 // æ›´æ–°desiredçŠ¶æ€
 now := time.Now().Unix()
 for key, value := range desired {
  shadow.State.Desired[key] = value
  shadow.Metadata.Desired[key] = Timestamp{Timestamp: now}
 }

 // è®¡ç®—delta
 shadow.State.Delta = ss.calculateDelta(shadow.State.Desired, shadow.State.Reported)

 log.Printf("ğŸ¯ æ›´æ–°è®¾å¤‡å½±å­(Desired): %s, version: %d", deviceID, shadow.Version)
 return shadow, nil
}

// GetShadow è·å–å½±å­
func (ss *ShadowService) GetShadow(deviceID string) (*Shadow, error) {
 ss.mu.RLock()
 defer ss.mu.RUnlock()

 shadow, ok := ss.shadows[deviceID]
 if !ok {
  return nil, fmt.Errorf("è®¾å¤‡å½±å­ä¸å­˜åœ¨: %s", deviceID)
 }

 return shadow, nil
}

// calculateDelta è®¡ç®—å·®å¼‚
func (ss *ShadowService) calculateDelta(desired, reported map[string]interface{}) map[string]interface{} {
 delta := make(map[string]interface{})

 for key, desiredValue := range desired {
  reportedValue, exists := reported[key]
  if !exists || desiredValue != reportedValue {
   delta[key] = desiredValue
  }
 }

 return delta
}
```

---

## 5. OTAå›ºä»¶å‡çº§

### 5.1 OTAå‡çº§æ¶æ„

```go
package ota

import (
 "context"
 "crypto/sha256"
 "encoding/hex"
 "fmt"
 "io"
 "log"
 "os"
 "sync"
)

// OTA (Over-The-Air) å›ºä»¶å‡çº§
/*
OTAå‡çº§æµç¨‹:
  1. æ£€æŸ¥æ›´æ–°: è®¾å¤‡è¯·æ±‚å›ºä»¶ç‰ˆæœ¬
  2. ä¸‹è½½å›ºä»¶: åˆ†å—ä¸‹è½½ (Chunked)
  3. æ ¡éªŒå›ºä»¶: SHA256å“ˆå¸Œæ ¡éªŒ
  4. å®‰è£…å›ºä»¶: å†™å…¥Flash
  5. é‡å¯è®¾å¤‡: å¯åŠ¨æ–°å›ºä»¶
  6. å›æ»šæœºåˆ¶: å¤±è´¥æ—¶å›æ»š

å…³é”®æŠ€æœ¯:
  âœ… æ–­ç‚¹ç»­ä¼  (Resume)
  âœ… å·®åˆ†å‡çº§ (Delta Update)
  âœ… A/Båˆ†åŒº (Dual Boot)
  âœ… ç­¾åéªŒè¯ (Signature Verification)
  âœ… æ‰¹é‡å‡çº§ (Batch Update)
*/

// Firmware å›ºä»¶ä¿¡æ¯
type Firmware struct {
 Version     string            `json:"version"`
 URL         string            `json:"url"`
 Size        int64             `json:"size"`
 SHA256      string            `json:"sha256"`
 ReleaseNote string            `json:"release_note"`
 Metadata    map[string]string `json:"metadata"`
}

// OTAManager OTAç®¡ç†å™¨
type OTAManager struct {
 mu              sync.RWMutex
 firmwareRepo    map[string]*Firmware // version -> firmware
 deviceFirmware  map[string]string    // deviceID -> currentVersion
 upgradeProgress map[string]*UpgradeProgress
}

// UpgradeProgress å‡çº§è¿›åº¦
type UpgradeProgress struct {
 DeviceID       string
 TargetVersion  string
 Status         UpgradeStatus
 Progress       float64 // 0-100
 BytesDownloaded int64
 TotalBytes     int64
 StartTime      time.Time
 Error          string
}

// UpgradeStatus å‡çº§çŠ¶æ€
type UpgradeStatus string

const (
 StatusPending    UpgradeStatus = "pending"
 StatusDownloading UpgradeStatus = "downloading"
 StatusVerifying   UpgradeStatus = "verifying"
 StatusInstalling  UpgradeStatus = "installing"
 StatusCompleted   UpgradeStatus = "completed"
 StatusFailed      UpgradeStatus = "failed"
)

// NewOTAManager åˆ›å»ºOTAç®¡ç†å™¨
func NewOTAManager() *OTAManager {
 return &OTAManager{
  firmwareRepo:    make(map[string]*Firmware),
  deviceFirmware:  make(map[string]string),
  upgradeProgress: make(map[string]*UpgradeProgress),
 }
}

// RegisterFirmware æ³¨å†Œå›ºä»¶
func (om *OTAManager) RegisterFirmware(firmware *Firmware) error {
 om.mu.Lock()
 defer om.mu.Unlock()

 om.firmwareRepo[firmware.Version] = firmware
 log.Printf("ğŸ“¦ æ³¨å†Œå›ºä»¶: %s (%d bytes)", firmware.Version, firmware.Size)
 return nil
}

// CheckUpdate æ£€æŸ¥æ›´æ–°
func (om *OTAManager) CheckUpdate(deviceID, currentVersion string) (*Firmware, bool) {
 om.mu.RLock()
 defer om.mu.RUnlock()

 // ç®€å•ç‰ˆæœ¬æ¯”è¾ƒ (å®é™…åº”ç”¨åº”ä½¿ç”¨semver)
 latestVersion := om.getLatestVersion()
 if latestVersion == "" || latestVersion == currentVersion {
  return nil, false // æ— æ›´æ–°
 }

 firmware := om.firmwareRepo[latestVersion]
 log.Printf("ğŸ”„ è®¾å¤‡ %s æœ‰æ›´æ–°: %s -> %s", deviceID, currentVersion, latestVersion)
 return firmware, true
}

// getLatestVersion è·å–æœ€æ–°ç‰ˆæœ¬
func (om *OTAManager) getLatestVersion() string {
 var latest string
 for version := range om.firmwareRepo {
  if latest == "" || version > latest {
   latest = version
  }
 }
 return latest
}

// StartUpgrade å¼€å§‹å‡çº§
func (om *OTAManager) StartUpgrade(ctx context.Context, deviceID, targetVersion string) error {
 om.mu.RLock()
 firmware, ok := om.firmwareRepo[targetVersion]
 om.mu.RUnlock()

 if !ok {
  return fmt.Errorf("å›ºä»¶ç‰ˆæœ¬ä¸å­˜åœ¨: %s", targetVersion)
 }

 // åˆ›å»ºå‡çº§è¿›åº¦
 progress := &UpgradeProgress{
  DeviceID:      deviceID,
  TargetVersion: targetVersion,
  Status:        StatusPending,
  Progress:      0,
  TotalBytes:    firmware.Size,
  StartTime:     time.Now(),
 }

 om.mu.Lock()
 om.upgradeProgress[deviceID] = progress
 om.mu.Unlock()

 // å¼‚æ­¥æ‰§è¡Œå‡çº§
 go om.performUpgrade(ctx, deviceID, firmware, progress)

 return nil
}

// performUpgrade æ‰§è¡Œå‡çº§
func (om *OTAManager) performUpgrade(ctx context.Context, deviceID string, firmware *Firmware, progress *UpgradeProgress) {
 // 1. ä¸‹è½½å›ºä»¶
 progress.Status = StatusDownloading
 log.Printf("â¬‡ï¸  ä¸‹è½½å›ºä»¶: %s", firmware.Version)

 firmwarePath, err := om.downloadFirmware(ctx, firmware, progress)
 if err != nil {
  progress.Status = StatusFailed
  progress.Error = err.Error()
  log.Printf("âŒ ä¸‹è½½å¤±è´¥: %v", err)
  return
 }

 // 2. æ ¡éªŒå›ºä»¶
 progress.Status = StatusVerifying
 log.Printf("ğŸ” æ ¡éªŒå›ºä»¶...")

 if err := om.verifyFirmware(firmwarePath, firmware.SHA256); err != nil {
  progress.Status = StatusFailed
  progress.Error = err.Error()
  log.Printf("âŒ æ ¡éªŒå¤±è´¥: %v", err)
  return
 }

 // 3. å®‰è£…å›ºä»¶
 progress.Status = StatusInstalling
 log.Printf("âš™ï¸  å®‰è£…å›ºä»¶...")

 if err := om.installFirmware(deviceID, firmwarePath); err != nil {
  progress.Status = StatusFailed
  progress.Error = err.Error()
  log.Printf("âŒ å®‰è£…å¤±è´¥: %v", err)
  return
 }

 // 4. å®Œæˆ
 progress.Status = StatusCompleted
 progress.Progress = 100
 om.deviceFirmware[deviceID] = firmware.Version
 log.Printf("âœ… å‡çº§å®Œæˆ: %s -> %s", deviceID, firmware.Version)
}

// downloadFirmware ä¸‹è½½å›ºä»¶
func (om *OTAManager) downloadFirmware(ctx context.Context, firmware *Firmware, progress *UpgradeProgress) (string, error) {
 // è¿™é‡Œåº”è¯¥å®ç°HTTP(S)ä¸‹è½½ï¼Œæ”¯æŒæ–­ç‚¹ç»­ä¼ 
 // ç®€åŒ–ç¤ºä¾‹: å‡è®¾å›ºä»¶å·²å­˜åœ¨æœ¬åœ°
 firmwarePath := fmt.Sprintf("/tmp/firmware_%s.bin", firmware.Version)

 // æ¨¡æ‹Ÿä¸‹è½½è¿›åº¦
 chunkSize := int64(1024 * 1024) // 1MB
 for downloaded := int64(0); downloaded < firmware.Size; downloaded += chunkSize {
  select {
  case <-ctx.Done():
   return "", ctx.Err()
  default:
   progress.BytesDownloaded = downloaded
   progress.Progress = float64(downloaded) / float64(firmware.Size) * 100
   time.Sleep(100 * time.Millisecond) // æ¨¡æ‹Ÿä¸‹è½½å»¶è¿Ÿ
  }
 }

 progress.BytesDownloaded = firmware.Size
 progress.Progress = 100

 return firmwarePath, nil
}

// verifyFirmware æ ¡éªŒå›ºä»¶
func (om *OTAManager) verifyFirmware(path, expectedSHA256 string) error {
 file, err := os.Open(path)
 if err != nil {
  return err
 }
 defer file.Close()

 hash := sha256.New()
 if _, err := io.Copy(hash, file); err != nil {
  return err
 }

 actualSHA256 := hex.EncodeToString(hash.Sum(nil))
 if actualSHA256 != expectedSHA256 {
  return fmt.Errorf("SHA256ä¸åŒ¹é…: expected=%s, actual=%s", expectedSHA256, actualSHA256)
 }

 return nil
}

// installFirmware å®‰è£…å›ºä»¶
func (om *OTAManager) installFirmware(deviceID, firmwarePath string) error {
 // å®é™…å®ç°åº”è¯¥:
 // 1. é€šè¿‡MQTT/CoAPå‘é€å›ºä»¶ç»™è®¾å¤‡
 // 2. è®¾å¤‡å†™å…¥Flash
 // 3. è®¾å¤‡é‡å¯å¹¶éªŒè¯

 log.Printf("ğŸ“¤ å‘é€å›ºä»¶åˆ°è®¾å¤‡: %s", deviceID)
 time.Sleep(2 * time.Second) // æ¨¡æ‹Ÿå®‰è£…å»¶è¿Ÿ

 return nil
}

// GetUpgradeProgress è·å–å‡çº§è¿›åº¦
func (om *OTAManager) GetUpgradeProgress(deviceID string) (*UpgradeProgress, error) {
 om.mu.RLock()
 defer om.mu.RUnlock()

 progress, ok := om.upgradeProgress[deviceID]
 if !ok {
  return nil, fmt.Errorf("æ— å‡çº§ä»»åŠ¡: %s", deviceID)
 }

 return progress, nil
}
```

---

## 6. è¾¹ç¼˜æ•°æ®å¤„ç†

### 6.1 æ—¶åºæ•°æ®åº“é›†æˆ

```go
package timeseries

import (
 "context"
 "fmt"
 "time"

 influxdb2 "github.com/influxdata/influxdb-client-go/v2"
 "github.com/influxdata/influxdb-client-go/v2/api"
)

// InfluxDBæ—¶åºæ•°æ®åº“
/*
æ—¶åºæ•°æ®åº“ç‰¹ç‚¹:
  âœ… é«˜å†™å…¥åå (100K+ writes/sec)
  âœ… æ•°æ®å‹ç¼© (å‹ç¼©æ¯”10:1)
  âœ… æ•°æ®ä¿ç•™ç­–ç•¥ (Retention Policy)
  âœ… è¿ç»­æŸ¥è¯¢ (Continuous Query)
  âœ… é™é‡‡æ · (Downsampling)

InfluxDBæ ¸å¿ƒæ¦‚å¿µ:
  â€¢ Measurement: ç±»ä¼¼SQLè¡¨
  â€¢ Tags: ç´¢å¼•å­—æ®µ (deviceID, location)
  â€¢ Fields: æ•°å€¼å­—æ®µ (temperature, humidity)
  â€¢ Timestamp: æ—¶é—´æˆ³ (çº³ç§’ç²¾åº¦)
*/

// TimeSeriesDB æ—¶åºæ•°æ®åº“
type TimeSeriesDB struct {
 client   influxdb2.Client
 writeAPI api.WriteAPI
 queryAPI api.QueryAPI
 bucket   string
 org      string
}

// NewTimeSeriesDB åˆ›å»ºæ—¶åºæ•°æ®åº“
func NewTimeSeriesDB(url, token, org, bucket string) *TimeSeriesDB {
 client := influxdb2.NewClient(url, token)

 return &TimeSeriesDB{
  client:   client,
  writeAPI: client.WriteAPI(org, bucket),
  queryAPI: client.QueryAPI(org),
  bucket:   bucket,
  org:      org,
 }
}

// WriteSensorData å†™å…¥ä¼ æ„Ÿå™¨æ•°æ®
func (ts *TimeSeriesDB) WriteSensorData(data SensorData) error {
 // åˆ›å»ºæ•°æ®ç‚¹
 p := influxdb2.NewPoint(
  "sensor_data",                    // measurement
  map[string]string{                // tags
   "sensor_id": data.SensorID,
   "type":      string(data.Type),
   "location":  data.Location,
  },
  map[string]interface{}{           // fields
   "value":   data.Value,
   "quality": data.Quality,
  },
  time.Unix(data.Timestamp, 0),
 )

 // å¼‚æ­¥å†™å…¥
 ts.writeAPI.WritePoint(p)
 return nil
}

// QueryLatest æŸ¥è¯¢æœ€æ–°æ•°æ®
func (ts *TimeSeriesDB) QueryLatest(ctx context.Context, sensorID string) (float64, error) {
 query := fmt.Sprintf(`
  from(bucket:"%s")
   |> range(start: -1h)
   |> filter(fn: (r) => r._measurement == "sensor_data")
   |> filter(fn: (r) => r.sensor_id == "%s")
   |> filter(fn: (r) => r._field == "value")
   |> last()
 `, ts.bucket, sensorID)

 result, err := ts.queryAPI.Query(ctx, query)
 if err != nil {
  return 0, err
 }
 defer result.Close()

 if result.Next() {
  value := result.Record().Value()
  if v, ok := value.(float64); ok {
   return v, nil
  }
 }

 return 0, fmt.Errorf("æ— æ•°æ®")
}

// QueryAverage æŸ¥è¯¢å¹³å‡å€¼
func (ts *TimeSeriesDB) QueryAverage(ctx context.Context, sensorID string, duration time.Duration) (float64, error) {
 query := fmt.Sprintf(`
  from(bucket:"%s")
   |> range(start: -%s)
   |> filter(fn: (r) => r._measurement == "sensor_data")
   |> filter(fn: (r) => r.sensor_id == "%s")
   |> filter(fn: (r) => r._field == "value")
   |> mean()
 `, ts.bucket, duration.String(), sensorID)

 result, err := ts.queryAPI.Query(ctx, query)
 if err != nil {
  return 0, err
 }
 defer result.Close()

 if result.Next() {
  value := result.Record().Value()
  if v, ok := value.(float64); ok {
   return v, nil
  }
 }

 return 0, fmt.Errorf("æ— æ•°æ®")
}

// Close å…³é—­è¿æ¥
func (ts *TimeSeriesDB) Close() {
 ts.writeAPI.Flush()
 ts.client.Close()
}
```

### 6.2 è¾¹ç¼˜æ•°æ®èšåˆä¸é¢„å¤„ç†

```go
package aggregation

import (
 "context"
 "sync"
 "time"
)

// DataAggregator æ•°æ®èšåˆå™¨
/*
è¾¹ç¼˜æ•°æ®èšåˆ:
  â€¢ å‡å°‘ä¸Šè¡Œæ•°æ®é‡ (é™ä½äº‘æˆæœ¬)
  â€¢ æœ¬åœ°å¿«é€Ÿå“åº” (ä½å»¶è¿Ÿ)
  â€¢ å¼‚å¸¸æ£€æµ‹ (å®æ—¶å‘Šè­¦)

èšåˆç­–ç•¥:
  1. æ—¶é—´çª—å£èšåˆ (Tumbling/Sliding)
  2. é‡‡æ ·èšåˆ (Sampling)
  3. å˜åŒ–é©±åŠ¨ä¸ŠæŠ¥ (Change-Driven)
  4. é˜ˆå€¼è¿‡æ»¤ (Threshold Filter)
*/

// DataAggregator æ•°æ®èšåˆå™¨
type DataAggregator struct {
 windowSize time.Duration
 mu         sync.RWMutex
 windows    map[string]*AggregationWindow
 outputCh   chan AggregatedData
}

// AggregationWindow èšåˆçª—å£
type AggregationWindow struct {
 SensorID    string
 StartTime   time.Time
 Values      []float64
 Sum         float64
 Count       int64
 Min         float64
 Max         float64
}

// AggregatedData èšåˆåæ•°æ®
type AggregatedData struct {
 SensorID  string
 StartTime time.Time
 EndTime   time.Time
 Count     int64
 Mean      float64
 Min       float64
 Max       float64
 StdDev    float64
}

// NewDataAggregator åˆ›å»ºæ•°æ®èšåˆå™¨
func NewDataAggregator(windowSize time.Duration) *DataAggregator {
 return &DataAggregator{
  windowSize: windowSize,
  windows:    make(map[string]*AggregationWindow),
  outputCh:   make(chan AggregatedData, 100),
 }
}

// AddDataPoint æ·»åŠ æ•°æ®ç‚¹
func (da *DataAggregator) AddDataPoint(sensorID string, value float64, timestamp time.Time) {
 da.mu.Lock()
 defer da.mu.Unlock()

 window, ok := da.windows[sensorID]
 if !ok {
  // åˆ›å»ºæ–°çª—å£
  window = &AggregationWindow{
   SensorID:  sensorID,
   StartTime: timestamp.Truncate(da.windowSize),
   Values:    make([]float64, 0, 100),
   Min:       value,
   Max:       value,
  }
  da.windows[sensorID] = window
 }

 // æ£€æŸ¥æ˜¯å¦éœ€è¦å…³é—­å½“å‰çª—å£
 windowEnd := window.StartTime.Add(da.windowSize)
 if timestamp.After(windowEnd) {
  // è®¡ç®—èšåˆç»“æœ
  aggData := da.computeAggregation(window)
  da.outputCh <- aggData

  // åˆ›å»ºæ–°çª—å£
  window = &AggregationWindow{
   SensorID:  sensorID,
   StartTime: timestamp.Truncate(da.windowSize),
   Values:    make([]float64, 0, 100),
   Min:       value,
   Max:       value,
  }
  da.windows[sensorID] = window
 }

 // æ·»åŠ æ•°æ®ç‚¹
 window.Values = append(window.Values, value)
 window.Sum += value
 window.Count++

 if value < window.Min {
  window.Min = value
 }
 if value > window.Max {
  window.Max = value
 }
}

// computeAggregation è®¡ç®—èšåˆ
func (da *DataAggregator) computeAggregation(window *AggregationWindow) AggregatedData {
 mean := window.Sum / float64(window.Count)

 // è®¡ç®—æ ‡å‡†å·®
 var variance float64
 for _, value := range window.Values {
  diff := value - mean
  variance += diff * diff
 }
 variance /= float64(window.Count)
 stdDev := math.Sqrt(variance)

 return AggregatedData{
  SensorID:  window.SensorID,
  StartTime: window.StartTime,
  EndTime:   window.StartTime.Add(da.windowSize),
  Count:     window.Count,
  Mean:      mean,
  Min:       window.Min,
  Max:       window.Max,
  StdDev:    stdDev,
 }
}

// GetOutputChannel è·å–è¾“å‡ºé€šé“
func (da *DataAggregator) GetOutputChannel() <-chan AggregatedData {
 return da.outputCh
}

// Close å…³é—­èšåˆå™¨
func (da *DataAggregator) Close() {
 close(da.outputCh)
}
```

---

## 7. è¾¹ç¼˜-äº‘ååŒ

### 7.1 æ•°æ®åŒæ­¥ç­–ç•¥

```go
package sync

import (
 "context"
 "log"
 "sync"
 "time"
)

// è¾¹ç¼˜-äº‘æ•°æ®åŒæ­¥
/*
åŒæ­¥ç­–ç•¥:
  1. å®æ—¶åŒæ­¥: é«˜ä¼˜å…ˆçº§æ•°æ®ç«‹å³ä¸Šä¼ 
  2. æ‰¹é‡åŒæ­¥: ä½ä¼˜å…ˆçº§æ•°æ®æ‰¹é‡ä¸Šä¼  (èŠ‚çœå¸¦å®½)
  3. å¢é‡åŒæ­¥: åªåŒæ­¥å˜æ›´æ•°æ®
  4. ç¦»çº¿ç¼“å­˜: æ–­ç½‘æ—¶æœ¬åœ°ç¼“å­˜ï¼Œæ¢å¤ååŒæ­¥

æ•°æ®ä¼˜å…ˆçº§:
  High   : å‘Šè­¦ã€å¼‚å¸¸ â†’ å®æ—¶ä¸Šä¼ 
  Medium : ç»Ÿè®¡æ•°æ®   â†’ æ‰¹é‡ä¸Šä¼  (5åˆ†é’Ÿ)
  Low    : æ—¥å¿—       â†’ æ‰¹é‡ä¸Šä¼  (1å°æ—¶)
*/

// DataSyncManager æ•°æ®åŒæ­¥ç®¡ç†å™¨
type DataSyncManager struct {
 mu            sync.RWMutex
 highPrioQueue chan SyncData
 medPrioQueue  chan SyncData
 lowPrioQueue  chan SyncData
 cache         *SyncCache
 cloudClient   CloudClient
 online        bool
}

// SyncData åŒæ­¥æ•°æ®
type SyncData struct {
 ID        string
 Type      string
 Payload   []byte
 Priority  Priority
 Timestamp time.Time
 Retries   int
}

// Priority ä¼˜å…ˆçº§
type Priority int

const (
 PriorityHigh   Priority = 1
 PriorityMedium Priority = 2
 PriorityLow    Priority = 3
)

// CloudClient äº‘ç«¯å®¢æˆ·ç«¯æ¥å£
type CloudClient interface {
 Upload(ctx context.Context, data SyncData) error
 IsOnline() bool
}

// NewDataSyncManager åˆ›å»ºåŒæ­¥ç®¡ç†å™¨
func NewDataSyncManager(cloudClient CloudClient) *DataSyncManager {
 return &DataSyncManager{
  highPrioQueue: make(chan SyncData, 1000),
  medPrioQueue:  make(chan SyncData, 5000),
  lowPrioQueue:  make(chan SyncData, 10000),
  cache:         NewSyncCache(),
  cloudClient:   cloudClient,
  online:        true,
 }
}

// Start å¯åŠ¨åŒæ­¥æœåŠ¡
func (dsm *DataSyncManager) Start(ctx context.Context) {
 // é«˜ä¼˜å…ˆçº§: å®æ—¶åŒæ­¥
 go dsm.syncWorker(ctx, dsm.highPrioQueue, time.Second*0)

 // ä¸­ä¼˜å…ˆçº§: 5åˆ†é’Ÿæ‰¹é‡åŒæ­¥
 go dsm.syncWorker(ctx, dsm.medPrioQueue, time.Minute*5)

 // ä½ä¼˜å…ˆçº§: 1å°æ—¶æ‰¹é‡åŒæ­¥
 go dsm.syncWorker(ctx, dsm.lowPrioQueue, time.Hour*1)

 // ç›‘æ§ç½‘ç»œçŠ¶æ€
 go dsm.monitorNetworkStatus(ctx)

 // ç¦»çº¿æ•°æ®æ¢å¤
 go dsm.recoverOfflineData(ctx)
}

// Enqueue åŠ å…¥åŒæ­¥é˜Ÿåˆ—
func (dsm *DataSyncManager) Enqueue(data SyncData) error {
 if !dsm.cloudClient.IsOnline() {
  // ç¦»çº¿æ—¶ç¼“å­˜åˆ°æœ¬åœ°
  dsm.cache.Add(data)
  log.Printf("ğŸ“¦ æ•°æ®å·²ç¼“å­˜ (ç¦»çº¿): %s", data.ID)
  return nil
 }

 // æ ¹æ®ä¼˜å…ˆçº§åŠ å…¥ä¸åŒé˜Ÿåˆ—
 switch data.Priority {
 case PriorityHigh:
  select {
  case dsm.highPrioQueue <- data:
  default:
   // é˜Ÿåˆ—æ»¡ï¼Œé™çº§åˆ°ç¼“å­˜
   dsm.cache.Add(data)
  }
 case PriorityMedium:
  select {
  case dsm.medPrioQueue <- data:
  default:
   dsm.cache.Add(data)
  }
 case PriorityLow:
  select {
  case dsm.lowPrioQueue <- data:
  default:
   dsm.cache.Add(data)
  }
 }

 return nil
}

// syncWorker åŒæ­¥å·¥ä½œçº¿ç¨‹
func (dsm *DataSyncManager) syncWorker(ctx context.Context, queue <-chan SyncData, batchInterval time.Duration) {
 if batchInterval == 0 {
  // å®æ—¶åŒæ­¥
  for {
   select {
   case <-ctx.Done():
    return
   case data := <-queue:
    dsm.uploadData(ctx, data)
   }
  }
 } else {
  // æ‰¹é‡åŒæ­¥
  ticker := time.NewTicker(batchInterval)
  defer ticker.Stop()

  var batch []SyncData

  for {
   select {
   case <-ctx.Done():
    return
   case data := <-queue:
    batch = append(batch, data)
   case <-ticker.C:
    if len(batch) > 0 {
     dsm.uploadBatch(ctx, batch)
     batch = batch[:0]
    }
   }
  }
 }
}

// uploadData ä¸Šä¼ å•æ¡æ•°æ®
func (dsm *DataSyncManager) uploadData(ctx context.Context, data SyncData) {
 if err := dsm.cloudClient.Upload(ctx, data); err != nil {
  log.Printf("âŒ ä¸Šä¼ å¤±è´¥: %s, error: %v", data.ID, err)

  // é‡è¯•é€»è¾‘
  if data.Retries < 3 {
   data.Retries++
   time.Sleep(time.Second * time.Duration(data.Retries))
   dsm.uploadData(ctx, data)
  } else {
   // æ”¾å…¥ç¼“å­˜
   dsm.cache.Add(data)
  }
 } else {
  log.Printf("âœ… ä¸Šä¼ æˆåŠŸ: %s", data.ID)
 }
}

// uploadBatch æ‰¹é‡ä¸Šä¼ 
func (dsm *DataSyncManager) uploadBatch(ctx context.Context, batch []SyncData) {
 log.Printf("ğŸ“¤ æ‰¹é‡ä¸Šä¼ : %d æ¡æ•°æ®", len(batch))

 for _, data := range batch {
  dsm.uploadData(ctx, data)
 }
}

// monitorNetworkStatus ç›‘æ§ç½‘ç»œçŠ¶æ€
func (dsm *DataSyncManager) monitorNetworkStatus(ctx context.Context) {
 ticker := time.NewTicker(30 * time.Second)
 defer ticker.Stop()

 for {
  select {
  case <-ctx.Done():
   return
  case <-ticker.C:
   online := dsm.cloudClient.IsOnline()
   if online != dsm.online {
    dsm.online = online
    if online {
     log.Printf("ğŸŒ ç½‘ç»œå·²æ¢å¤")
    } else {
     log.Printf("âŒ ç½‘ç»œå·²æ–­å¼€")
    }
   }
  }
 }
}

// recoverOfflineData æ¢å¤ç¦»çº¿æ•°æ®
func (dsm *DataSyncManager) recoverOfflineData(ctx context.Context) {
 ticker := time.NewTicker(10 * time.Minute)
 defer ticker.Stop()

 for {
  select {
  case <-ctx.Done():
   return
  case <-ticker.C:
   if dsm.cloudClient.IsOnline() {
    cachedData := dsm.cache.GetAll()
    if len(cachedData) > 0 {
     log.Printf("ğŸ”„ æ¢å¤ç¦»çº¿æ•°æ®: %d æ¡", len(cachedData))
     for _, data := range cachedData {
      dsm.Enqueue(data)
     }
     dsm.cache.Clear()
    }
   }
  }
 }
}

// SyncCache åŒæ­¥ç¼“å­˜
type SyncCache struct {
 mu   sync.RWMutex
 data []SyncData
}

func NewSyncCache() *SyncCache {
 return &SyncCache{
  data: make([]SyncData, 0),
 }
}

func (sc *SyncCache) Add(data SyncData) {
 sc.mu.Lock()
 defer sc.mu.Unlock()
 sc.data = append(sc.data, data)
}

func (sc *SyncCache) GetAll() []SyncData {
 sc.mu.RLock()
 defer sc.mu.RUnlock()
 return append([]SyncData{}, sc.data...)
}

func (sc *SyncCache) Clear() {
 sc.mu.Lock()
 defer sc.mu.Unlock()
 sc.data = sc.data[:0]
}
```

---

## 8. å®Œæ•´IoTå¹³å°

### 8.1 IoTå¹³å°æ¶æ„

```go
package platform

import (
 "context"
 "log"
 "sync"
)

// IoTå¹³å°å®Œæ•´æ¶æ„
/*
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Cloud Platform                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ Device    â”‚  â”‚  Data    â”‚  â”‚  Analytics â”‚           â”‚
â”‚  â”‚ Managementâ”‚  â”‚  Storage â”‚  â”‚  & AI      â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Edge Gateway                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ Protocol  â”‚  â”‚  Data    â”‚  â”‚  Local     â”‚           â”‚
â”‚  â”‚ Gateway   â”‚  â”‚  Process â”‚  â”‚  Storage   â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â†•                  â†•                  â†•
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Sensors   â”‚    â”‚  Actuators  â”‚   â”‚   Devices   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
*/

// IoTPlatform IoTå¹³å°
type IoTPlatform struct {
 // è®¾å¤‡ç®¡ç†
 DeviceManager *DeviceManager

 // æ•°æ®å¤„ç†
 DataAggregator *DataAggregator
 TimeSeriesDB   *TimeSeriesDB

 // é€šä¿¡åè®®
 MQTTBroker  *MQTTClient
 CoapServer  *CoapServer

 // OTAå‡çº§
 OTAManager *OTAManager

 // è®¾å¤‡å½±å­
 ShadowService *ShadowService

 // æ•°æ®åŒæ­¥
 SyncManager *DataSyncManager

 // è§„åˆ™å¼•æ“
 RuleEngine *RuleEngine

 mu sync.RWMutex
}

// NewIoTPlatform åˆ›å»ºIoTå¹³å°
func NewIoTPlatform(config PlatformConfig) (*IoTPlatform, error) {
 // åˆå§‹åŒ–è®¾å¤‡ç®¡ç†
 deviceMgr, err := NewDeviceManager(config.DatabaseURL)
 if err != nil {
  return nil, err
 }

 // åˆå§‹åŒ–æ—¶åºæ•°æ®åº“
 tsdb := NewTimeSeriesDB(
  config.InfluxURL,
  config.InfluxToken,
  config.InfluxOrg,
  config.InfluxBucket,
 )

 // åˆå§‹åŒ–MQTT
 mqttClient := NewMQTTClient(config.MQTTBroker, "platform-client")

 // åˆå§‹åŒ–CoAP
 coapServer := NewCoapServer(config.CoapAddr)

 // åˆå§‹åŒ–OTA
 otaMgr := NewOTAManager()

 // åˆå§‹åŒ–è®¾å¤‡å½±å­
 shadowSvc := NewShadowService()

 // åˆå§‹åŒ–æ•°æ®èšåˆ
 aggregator := NewDataAggregator(config.AggregationWindow)

 // åˆå§‹åŒ–è§„åˆ™å¼•æ“
 ruleEngine := NewRuleEngine()

 return &IoTPlatform{
  DeviceManager:  deviceMgr,
  TimeSeriesDB:   tsdb,
  MQTTBroker:     mqttClient,
  CoapServer:     coapServer,
  OTAManager:     otaMgr,
  ShadowService:  shadowSvc,
  DataAggregator: aggregator,
  RuleEngine:     ruleEngine,
 }, nil
}

// Start å¯åŠ¨å¹³å°
func (p *IoTPlatform) Start(ctx context.Context) error {
 // è¿æ¥MQTT
 if err := p.MQTTBroker.Connect(ctx); err != nil {
  return fmt.Errorf("MQTTè¿æ¥å¤±è´¥: %w", err)
 }

 // å¯åŠ¨CoAPæœåŠ¡å™¨
 go func() {
  if err := p.CoapServer.Start(ctx); err != nil {
   log.Printf("CoAPå¯åŠ¨å¤±è´¥: %v", err)
  }
 }()

 // è®¢é˜…è®¾å¤‡é¥æµ‹æ•°æ®
 p.subscribeDeviceData()

 // å¯åŠ¨è§„åˆ™å¼•æ“
 go p.RuleEngine.Start(ctx)

 log.Println("ğŸš€ IoTå¹³å°å·²å¯åŠ¨")
 return nil
}

// subscribeDeviceData è®¢é˜…è®¾å¤‡æ•°æ®
func (p *IoTPlatform) subscribeDeviceData() {
 // è®¢é˜…æ‰€æœ‰ä¼ æ„Ÿå™¨é¥æµ‹æ•°æ®
 p.MQTTBroker.Subscribe("sensor/+/telemetry", 1, func(client paho.Client, msg paho.Message) {
  var data TelemetryData
  if err := json.Unmarshal(msg.Payload(), &data); err != nil {
   log.Printf("âŒ è§£æé¥æµ‹æ•°æ®å¤±è´¥: %v", err)
   return
  }

  // å†™å…¥æ—¶åºæ•°æ®åº“
  sensorData := SensorData{
   SensorID:  data.SensorID,
   Type:      SensorType(data.Type),
   Value:     data.Value,
   Timestamp: data.Timestamp,
   Quality:   1.0,
  }

  p.TimeSeriesDB.WriteSensorData(sensorData)

  // æ•°æ®èšåˆ
  p.DataAggregator.AddDataPoint(data.SensorID, data.Value, time.Unix(data.Timestamp, 0))

  // æ›´æ–°è®¾å¤‡å½±å­
  reported := map[string]interface{}{
   data.Type: data.Value,
  }
  p.ShadowService.UpdateReported(data.SensorID, reported)

  // è§¦å‘è§„åˆ™å¼•æ“
  p.RuleEngine.EvaluateRules(data)
 })

 log.Println("ğŸ“¡ å·²è®¢é˜…è®¾å¤‡é¥æµ‹æ•°æ®")
}

// PlatformConfig å¹³å°é…ç½®
type PlatformConfig struct {
 DatabaseURL       string
 MQTTBroker        string
 CoapAddr          string
 InfluxURL         string
 InfluxToken       string
 InfluxOrg         string
 InfluxBucket      string
 AggregationWindow time.Duration
}
```

### 8.2 è§„åˆ™å¼•æ“

```go
package rules

import (
 "context"
 "fmt"
 "log"
 "sync"
)

// è§„åˆ™å¼•æ“
/*
è§„åˆ™å¼•æ“åŠŸèƒ½:
  â€¢ å®æ—¶æ•°æ®ç›‘æ§
  â€¢ é˜ˆå€¼å‘Šè­¦
  â€¢ è‡ªåŠ¨åŒ–æ§åˆ¶
  â€¢ å¤æ‚äº‹ä»¶å¤„ç† (CEP)

è§„åˆ™ç¤ºä¾‹:
  IF temperature > 80Â°C
  THEN send_alert("High Temperature") AND activate_cooling()

  IF vibration > threshold FOR 5 minutes
  THEN send_alert("Abnormal Vibration") AND shutdown_machine()
*/

// RuleEngine è§„åˆ™å¼•æ“
type RuleEngine struct {
 mu     sync.RWMutex
 rules  []*Rule
 actions map[string]ActionFunc
}

// Rule è§„åˆ™
type Rule struct {
 ID        string
 Name      string
 Condition ConditionFunc
 Actions   []string
 Enabled   bool
}

// ConditionFunc æ¡ä»¶å‡½æ•°
type ConditionFunc func(data TelemetryData) bool

// ActionFunc åŠ¨ä½œå‡½æ•°
type ActionFunc func(data TelemetryData) error

// NewRuleEngine åˆ›å»ºè§„åˆ™å¼•æ“
func NewRuleEngine() *RuleEngine {
 return &RuleEngine{
  rules:   make([]*Rule, 0),
  actions: make(map[string]ActionFunc),
 }
}

// RegisterAction æ³¨å†ŒåŠ¨ä½œ
func (re *RuleEngine) RegisterAction(name string, action ActionFunc) {
 re.mu.Lock()
 defer re.mu.Unlock()

 re.actions[name] = action
 log.Printf("ğŸ“ æ³¨å†ŒåŠ¨ä½œ: %s", name)
}

// AddRule æ·»åŠ è§„åˆ™
func (re *RuleEngine) AddRule(rule *Rule) {
 re.mu.Lock()
 defer re.mu.Unlock()

 re.rules = append(re.rules, rule)
 log.Printf("âœ… æ·»åŠ è§„åˆ™: %s (%s)", rule.Name, rule.ID)
}

// EvaluateRules è¯„ä¼°è§„åˆ™
func (re *RuleEngine) EvaluateRules(data TelemetryData) {
 re.mu.RLock()
 rules := re.rules
 re.mu.RUnlock()

 for _, rule := range rules {
  if !rule.Enabled {
   continue
  }

  // è¯„ä¼°æ¡ä»¶
  if rule.Condition(data) {
   log.Printf("ğŸ”” è§„åˆ™è§¦å‘: %s (sensor=%s, value=%.2f)",
    rule.Name, data.SensorID, data.Value)

   // æ‰§è¡ŒåŠ¨ä½œ
   re.executeActions(rule.Actions, data)
  }
 }
}

// executeActions æ‰§è¡ŒåŠ¨ä½œ
func (re *RuleEngine) executeActions(actionNames []string, data TelemetryData) {
 re.mu.RLock()
 defer re.mu.RUnlock()

 for _, name := range actionNames {
  action, ok := re.actions[name]
  if !ok {
   log.Printf("âŒ åŠ¨ä½œä¸å­˜åœ¨: %s", name)
   continue
  }

  if err := action(data); err != nil {
   log.Printf("âŒ æ‰§è¡ŒåŠ¨ä½œå¤±è´¥ (%s): %v", name, err)
  } else {
   log.Printf("âœ… æ‰§è¡ŒåŠ¨ä½œ: %s", name)
  }
 }
}

// Start å¯åŠ¨è§„åˆ™å¼•æ“
func (re *RuleEngine) Start(ctx context.Context) {
 log.Println("ğŸš€ è§„åˆ™å¼•æ“å·²å¯åŠ¨")

 <-ctx.Done()
 log.Println("ğŸ›‘ è§„åˆ™å¼•æ“å·²åœæ­¢")
}

// ç¤ºä¾‹è§„åˆ™å®šä¹‰

// HighTemperatureRule é«˜æ¸©å‘Šè­¦è§„åˆ™
func HighTemperatureRule(threshold float64) *Rule {
 return &Rule{
  ID:   "rule-high-temp",
  Name: "High Temperature Alert",
  Condition: func(data TelemetryData) bool {
   return data.Type == "temperature" && data.Value > threshold
  },
  Actions: []string{"send_alert", "activate_cooling"},
  Enabled: true,
 }
}

// AbnormalVibrationRule å¼‚å¸¸æŒ¯åŠ¨è§„åˆ™
func AbnormalVibrationRule(threshold float64) *Rule {
 return &Rule{
  ID:   "rule-vibration",
  Name: "Abnormal Vibration Alert",
  Condition: func(data TelemetryData) bool {
   return data.Type == "vibration" && data.Value > threshold
  },
  Actions: []string{"send_alert", "shutdown_machine"},
  Enabled: true,
 }
}

// ç¤ºä¾‹åŠ¨ä½œå®ç°

// SendAlertAction å‘é€å‘Šè­¦åŠ¨ä½œ
func SendAlertAction(alertService AlertService) ActionFunc {
 return func(data TelemetryData) error {
  alert := Alert{
   Title:     fmt.Sprintf("%s Abnormal", data.Type),
   Message:   fmt.Sprintf("Sensor %s reported value %.2f", data.SensorID, data.Value),
   Severity:  "high",
   Timestamp: time.Now(),
  }

  return alertService.Send(alert)
 }
}

// ActivateCoolingAction å¯åŠ¨å†·å´åŠ¨ä½œ
func ActivateCoolingAction(mqttClient *MQTTClient) ActionFunc {
 return func(data TelemetryData) error {
  cmd := Command{
   CommandID: fmt.Sprintf("cmd-%d", time.Now().Unix()),
   Type:      "activate_cooling",
   Parameters: map[string]interface{}{
    "device_id": data.SensorID,
   },
   Timestamp: time.Now().Unix(),
  }

  payload, _ := json.Marshal(cmd)
  topic := fmt.Sprintf("device/%s/command", data.SensorID)

  return mqttClient.Publish(topic, 1, payload)
 }
}

// AlertService å‘Šè­¦æœåŠ¡æ¥å£
type AlertService interface {
 Send(alert Alert) error
}

// Alert å‘Šè­¦
type Alert struct {
 Title     string
 Message   string
 Severity  string
 Timestamp time.Time
}
```

---

## 9. ç›‘æ§ä¸å‘Šè­¦

### 9.1 å¹³å°ç›‘æ§

```go
package monitoring

import (
 "github.com/prometheus/client_golang/prometheus"
 "github.com/prometheus/client_golang/prometheus/promauto"
)

// IoTå¹³å°Prometheusç›‘æ§æŒ‡æ ‡

var (
 // è®¾å¤‡æŒ‡æ ‡
 DeviceTotal = promauto.NewGaugeVec(
  prometheus.GaugeOpts{
   Name: "iot_device_total",
   Help: "Total number of devices",
  },
  []string{"status", "type"},
 )

 DeviceDataReceived = promauto.NewCounterVec(
  prometheus.CounterOpts{
   Name: "iot_device_data_received_total",
   Help: "Total device data points received",
  },
  []string{"device_id", "type"},
 )

 // MQTTæŒ‡æ ‡
 MQTTMessagesPublished = promauto.NewCounter(
  prometheus.CounterOpts{
   Name: "iot_mqtt_messages_published_total",
   Help: "Total MQTT messages published",
  },
 )

 MQTTMessagesReceived = promauto.NewCounter(
  prometheus.CounterOpts{
   Name: "iot_mqtt_messages_received_total",
   Help: "Total MQTT messages received",
  },
 )

 // OTAæŒ‡æ ‡
 OTAUpgradeTotal = promauto.NewCounterVec(
  prometheus.CounterOpts{
   Name: "iot_ota_upgrade_total",
   Help: "Total OTA upgrades",
  },
  []string{"status"},
 )

 OTAUpgradeDuration = promauto.NewHistogram(
  prometheus.HistogramOpts{
   Name:    "iot_ota_upgrade_duration_seconds",
   Help:    "OTA upgrade duration in seconds",
   Buckets: prometheus.ExponentialBuckets(10, 2, 10), // 10s to 2.8h
  },
 )

 // è¾¹ç¼˜è®¡ç®—æŒ‡æ ‡
 EdgeDataProcessed = promauto.NewCounter(
  prometheus.CounterOpts{
   Name: "iot_edge_data_processed_total",
   Help: "Total data points processed at edge",
  },
 )

 EdgeLatency = promauto.NewHistogram(
  prometheus.HistogramOpts{
   Name:    "iot_edge_processing_latency_ms",
   Help:    "Edge data processing latency in milliseconds",
   Buckets: prometheus.ExponentialBuckets(1, 2, 10), // 1ms to 0.5s
  },
 )

 // è§„åˆ™å¼•æ“æŒ‡æ ‡
 RulesEvaluated = promauto.NewCounter(
  prometheus.CounterOpts{
   Name: "iot_rules_evaluated_total",
   Help: "Total rules evaluated",
  },
 )

 RulesTriggered = promauto.NewCounterVec(
  prometheus.CounterOpts{
   Name: "iot_rules_triggered_total",
   Help: "Total rules triggered",
  },
  []string{"rule_id", "rule_name"},
 )

 // æ•°æ®åŒæ­¥æŒ‡æ ‡
 DataSyncSuccess = promauto.NewCounter(
  prometheus.CounterOpts{
   Name: "iot_data_sync_success_total",
   Help: "Total successful data syncs",
  },
 )

 DataSyncFailed = promauto.NewCounter(
  prometheus.CounterOpts{
   Name: "iot_data_sync_failed_total",
   Help: "Total failed data syncs",
  },
 )

 DataSyncCached = promauto.NewGauge(
  prometheus.GaugeOpts{
   Name: "iot_data_sync_cached",
   Help: "Number of data points cached (offline)",
  },
 )
)
```

---

## 10. ç”Ÿäº§éƒ¨ç½²

### 10.1 Dockeréƒ¨ç½²

```dockerfile
# Dockerfile
FROM golang:1.25-alpine AS builder

WORKDIR /app

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY go.mod go.sum ./
RUN go mod download

# å¤åˆ¶æºç 
COPY . .

# ç¼–è¯‘
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o iot-platform ./cmd/platform

# è¿è¡Œé•œåƒ
FROM alpine:latest

RUN apk --no-cache add ca-certificates

WORKDIR /root/

# ä»builderå¤åˆ¶äºŒè¿›åˆ¶æ–‡ä»¶
COPY --from=builder /app/iot-platform .

# æš´éœ²ç«¯å£
EXPOSE 8080 1883 5683

# å¯åŠ¨
CMD ["./iot-platform"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  # IoTå¹³å°
  iot-platform:
    build: .
    ports:
      - "8080:8080"   # HTTP API
      - "1883:1883"   # MQTT
      - "5683:5683/udp" # CoAP
    environment:
      - DATABASE_URL=postgres://user:pass@postgres:5432/iot?sslmode=disable
      - MQTT_BROKER=tcp://mosquitto:1883
      - INFLUXDB_URL=http://influxdb:8086
      - INFLUXDB_TOKEN=${INFLUXDB_TOKEN}
    depends_on:
      - postgres
      - mosquitto
      - influxdb
    restart: unless-stopped

  # PostgreSQL
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: iot
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
    volumes:
      - postgres-data:/var/lib/postgresql/data
    restart: unless-stopped

  # MQTT Broker (Mosquitto)
  mosquitto:
    image: eclipse-mosquitto:2
    ports:
      - "1883:1883"
      - "9001:9001"
    volumes:
      - ./mosquitto.conf:/mosquitto/config/mosquitto.conf
      - mosquitto-data:/mosquitto/data
      - mosquitto-log:/mosquitto/log
    restart: unless-stopped

  # InfluxDB (æ—¶åºæ•°æ®åº“)
  influxdb:
    image: influxdb:2.7-alpine
    ports:
      - "8086:8086"
    environment:
      - DOCKER_INFLUXDB_INIT_MODE=setup
      - DOCKER_INFLUXDB_INIT_USERNAME=admin
      - DOCKER_INFLUXDB_INIT_PASSWORD=adminpass
      - DOCKER_INFLUXDB_INIT_ORG=iot-org
      - DOCKER_INFLUXDB_INIT_BUCKET=iot-data
      - DOCKER_INFLUXDB_INIT_ADMIN_TOKEN=${INFLUXDB_TOKEN}
    volumes:
      - influxdb-data:/var/lib/influxdb2
    restart: unless-stopped

  # Prometheus (ç›‘æ§)
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus-data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
    restart: unless-stopped

  # Grafana (å¯è§†åŒ–)
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana-data:/var/lib/grafana
      - ./grafana-dashboards:/etc/grafana/provisioning/dashboards
    depends_on:
      - prometheus
      - influxdb
    restart: unless-stopped

volumes:
  postgres-data:
  mosquitto-data:
  mosquitto-log:
  influxdb-data:
  prometheus-data:
  grafana-data:
```

### 10.2 Kuberneteséƒ¨ç½²

```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: iot-platform
  namespace: iot
spec:
  replicas: 3
  selector:
    matchLabels:
      app: iot-platform
  template:
    metadata:
      labels:
        app: iot-platform
    spec:
      containers:
      - name: iot-platform
        image: myregistry/iot-platform:v1.0.0
        ports:
        - containerPort: 8080
          name: http
        - containerPort: 1883
          name: mqtt
        - containerPort: 5683
          name: coap
          protocol: UDP
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: iot-secrets
              key: database-url
        - name: INFLUXDB_TOKEN
          valueFrom:
            secretKeyRef:
              name: iot-secrets
              key: influxdb-token
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: iot-platform
  namespace: iot
spec:
  selector:
    app: iot-platform
  type: LoadBalancer
  ports:
  - name: http
    port: 80
    targetPort: 8080
  - name: mqtt
    port: 1883
    targetPort: 1883
  - name: coap
    port: 5683
    targetPort: 5683
    protocol: UDP
```

---

## æ€»ç»“

### âœ… æ ¸å¿ƒæˆæœ

1. **å®Œæ•´IoTåè®®æ ˆ**
   - MQTT (Pub/Sub, QoS, é—å˜±æ¶ˆæ¯)
   - CoAP (RESTful, è§‚å¯Ÿæ¨¡å¼)
   - Protocol Buffers (äºŒè¿›åˆ¶åºåˆ—åŒ–)

2. **è¾¹ç¼˜è®¡ç®—æ¶æ„**
   - ä¸‰å±‚æ¶æ„ (è®¾å¤‡-è¾¹ç¼˜-äº‘)
   - æ•°æ®èšåˆä¸é¢„å¤„ç†
   - æœ¬åœ°æ¨ç†ä¸å†³ç­–

3. **è®¾å¤‡ç®¡ç†ç³»ç»Ÿ**
   - è®¾å¤‡ç”Ÿå‘½å‘¨æœŸç®¡ç†
   - è®¾å¤‡å½±å­ (Digital Twin)
   - OTAå›ºä»¶å‡çº§

4. **è¾¹ç¼˜-äº‘ååŒ**
   - æ•°æ®åŒæ­¥ç­–ç•¥ (å®æ—¶/æ‰¹é‡)
   - ç¦»çº¿ç¼“å­˜ä¸æ¢å¤
   - ä¼˜å…ˆçº§é˜Ÿåˆ—

5. **è§„åˆ™å¼•æ“ä¸å‘Šè­¦**
   - å®æ—¶æ•°æ®ç›‘æ§
   - é˜ˆå€¼å‘Šè­¦
   - è‡ªåŠ¨åŒ–æ§åˆ¶

### ğŸŒŸ Go 1.25.3åº”ç”¨

| ç‰¹æ€§ | åº”ç”¨ |
|------|------|
| Goroutine | MQTT/CoAPå¼‚æ­¥å¤„ç† |
| Channel | æ•°æ®ç®¡é“ä¸åŒæ­¥ |
| Context | è¶…æ—¶ä¸å–æ¶ˆ |
| Generic | ç±»å‹å®‰å…¨çš„é˜Ÿåˆ— |
| iter.Seq | ä¼ æ„Ÿå™¨æ•°æ®è¿­ä»£ |

### ğŸ“Š æ¶æ„äº®ç‚¹

- **ä½å»¶è¿Ÿ**: è¾¹ç¼˜è®¡ç®— <10ms
- **é«˜å¯ç”¨**: ç¦»çº¿å¯ç”¨ + è‡ªåŠ¨æ¢å¤
- **å¯æ‰©å±•**: æ°´å¹³æ‰©å±• + è´Ÿè½½å‡è¡¡
- **ä½æˆæœ¬**: æ•°æ®èšåˆé™ä½äº‘æˆæœ¬

### ğŸ¯ é€‚ç”¨åœºæ™¯

- å·¥ä¸šç‰©è”ç½‘ (IIoT)
- æ™ºèƒ½äº¤é€š (V2X)
- æ™ºèƒ½å®¶å±…
- æ™ºæ…§åŸå¸‚

---

## ä¸‹ä¸€æ­¥å­¦ä¹ 

- [ ] LoRaWANåè®®å®æˆ˜
- [ ] è¾¹ç¼˜AIæ¨ç† (TensorFlow Lite)
- [ ] æ—¶åºæ•°æ®åº“æ·±å…¥ (ClickHouse)
- [ ] æ•°å­—å­ªç”Ÿ (Digital Twin)

---

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.25.3

---
