# Go 1.25.3 安全加固与认证授权完整实战

**文档类型**: 安全工程指南  
**Go版本**: Go 1.25.3  
**难度等级**: ⭐⭐⭐⭐⭐ (专家级)  
**最后更新**: 2025年10月22日

---


## 📋 目录


- [📖 文档说明](#-文档说明)
- [目录](#目录)
- [1. JWT认证](#1-jwt认证)
  - [1.1 JWT生成与验证](#11-jwt生成与验证)
  - [1.2 JWT中间件](#12-jwt中间件)
- [2. OAuth 2.0认证](#2-oauth-20认证)
  - [2.1 OAuth 2.0服务器](#21-oauth-20服务器)
  - [2.2 OAuth 2.0客户端](#22-oauth-20客户端)
- [3. RBAC权限管理](#3-rbac权限管理)
  - [3.1 RBAC核心模型](#31-rbac核心模型)
  - [3.2 RBAC中间件](#32-rbac中间件)
- [4. 密码安全](#4-密码安全)
  - [4.1 密码哈希与验证](#41-密码哈希与验证)
  - [4.2 密码策略](#42-密码策略)
- [5. HTTPS/TLS](#5-httpstls)
  - [5.1 TLS配置](#51-tls配置)
- [6. 安全防护](#6-安全防护)
  - [6.1 SQL注入防护](#61-sql注入防护)
  - [6.2 XSS防护](#62-xss防护)
  - [6.3 CSRF防护](#63-csrf防护)
- [7. 审计日志](#7-审计日志)
  - [7.1 审计日志系统](#71-审计日志系统)
- [8. 完整案例](#8-完整案例)
  - [8.1 安全的用户服务](#81-安全的用户服务)
- [📚 安全最佳实践](#-安全最佳实践)
  - [认证授权](#认证授权)
  - [密码安全](#密码安全)
  - [传输安全](#传输安全)
  - [输入验证](#输入验证)
- [🎯 总结](#-总结)

## 📖 文档说明

本文档展示Go 1.25.3的**安全加固与认证授权完整方案**，构建企业级安全系统：

- ✅ JWT认证完整实现
- ✅ OAuth 2.0 & OIDC
- ✅ RBAC权限管理
- ✅ 密码安全与加密
- ✅ HTTPS/TLS配置
- ✅ SQL注入防护
- ✅ XSS/CSRF防护
- ✅ 安全审计日志

---

## 目录

- [Go 1.25.3 安全加固与认证授权完整实战](#go-1253-安全加固与认证授权完整实战)
  - [📖 文档说明](#-文档说明)
  - [目录](#目录)
  - [1. JWT认证](#1-jwt认证)
    - [1.1 JWT生成与验证](#11-jwt生成与验证)
    - [1.2 JWT中间件](#12-jwt中间件)
  - [2. OAuth 2.0认证](#2-oauth-20认证)
    - [2.1 OAuth 2.0服务器](#21-oauth-20服务器)
    - [2.2 OAuth 2.0客户端](#22-oauth-20客户端)
  - [3. RBAC权限管理](#3-rbac权限管理)
    - [3.1 RBAC核心模型](#31-rbac核心模型)
    - [3.2 RBAC中间件](#32-rbac中间件)
  - [4. 密码安全](#4-密码安全)
    - [4.1 密码哈希与验证](#41-密码哈希与验证)
    - [4.2 密码策略](#42-密码策略)
  - [5. HTTPS/TLS](#5-httpstls)
    - [5.1 TLS配置](#51-tls配置)
  - [6. 安全防护](#6-安全防护)
    - [6.1 SQL注入防护](#61-sql注入防护)
    - [6.2 XSS防护](#62-xss防护)
    - [6.3 CSRF防护](#63-csrf防护)
  - [7. 审计日志](#7-审计日志)
    - [7.1 审计日志系统](#71-审计日志系统)
  - [8. 完整案例](#8-完整案例)
    - [8.1 安全的用户服务](#81-安全的用户服务)
  - [📚 安全最佳实践](#-安全最佳实践)
    - [认证授权](#认证授权)
    - [密码安全](#密码安全)
    - [传输安全](#传输安全)
    - [输入验证](#输入验证)
  - [🎯 总结](#-总结)

---

## 1. JWT认证

### 1.1 JWT生成与验证

```go
package auth

import (
 "context"
 "errors"
 "fmt"
 "time"
 
 "github.com/golang-jwt/jwt/v5"
)

// Claims JWT声明
type Claims struct {
 UserID   string   `json:"user_id"`
 Username string   `json:"username"`
 Roles    []string `json:"roles"`
 jwt.RegisteredClaims
}

// JWTManager JWT管理器
type JWTManager struct {
 secretKey     []byte
 accessExpiry  time.Duration
 refreshExpiry time.Duration
}

// NewJWTManager 创建JWT管理器
func NewJWTManager(secretKey string, accessExpiry, refreshExpiry time.Duration) *JWTManager {
 return &JWTManager{
  secretKey:     []byte(secretKey),
  accessExpiry:  accessExpiry,
  refreshExpiry: refreshExpiry,
 }
}

// GenerateAccessToken 生成访问令牌
func (jm *JWTManager) GenerateAccessToken(userID, username string, roles []string) (string, error) {
 claims := &Claims{
  UserID:   userID,
  Username: username,
  Roles:    roles,
  RegisteredClaims: jwt.RegisteredClaims{
   ExpiresAt: jwt.NewNumericDate(time.Now().Add(jm.accessExpiry)),
   IssuedAt:  jwt.NewNumericDate(time.Now()),
   NotBefore: jwt.NewNumericDate(time.Now()),
   Issuer:    "my-app",
   Subject:   userID,
  },
 }
 
 token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
 return token.SignedString(jm.secretKey)
}

// GenerateRefreshToken 生成刷新令牌
func (jm *JWTManager) GenerateRefreshToken(userID string) (string, error) {
 claims := &jwt.RegisteredClaims{
  ExpiresAt: jwt.NewNumericDate(time.Now().Add(jm.refreshExpiry)),
  IssuedAt:  jwt.NewNumericDate(time.Now()),
  Subject:   userID,
 }
 
 token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
 return token.SignedString(jm.secretKey)
}

// ValidateToken 验证令牌
func (jm *JWTManager) ValidateToken(tokenString string) (*Claims, error) {
 token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
  // 验证签名方法
  if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
   return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
  }
  return jm.secretKey, nil
 })
 
 if err != nil {
  return nil, err
 }
 
 claims, ok := token.Claims.(*Claims)
 if !ok || !token.Valid {
  return nil, errors.New("invalid token")
 }
 
 return claims, nil
}

// RefreshAccessToken 刷新访问令牌
func (jm *JWTManager) RefreshAccessToken(refreshToken string) (string, error) {
 token, err := jwt.ParseWithClaims(refreshToken, &jwt.RegisteredClaims{}, func(token *jwt.Token) (interface{}, error) {
  return jm.secretKey, nil
 })
 
 if err != nil {
  return "", err
 }
 
 claims, ok := token.Claims.(*jwt.RegisteredClaims)
 if !ok || !token.Valid {
  return "", errors.New("invalid refresh token")
 }
 
 // 这里应该从数据库获取用户信息
 // 简化示例，直接使用subject
 return jm.GenerateAccessToken(claims.Subject, "", nil)
}
```

---

### 1.2 JWT中间件

```go
package middleware

import (
 "context"
 "net/http"
 "strings"
)

// JWTAuth JWT认证中间件
func JWTAuth(jwtManager *auth.JWTManager) func(http.Handler) http.Handler {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   // 获取Authorization header
   authHeader := r.Header.Get("Authorization")
   if authHeader == "" {
    http.Error(w, "missing authorization header", http.StatusUnauthorized)
    return
   }
   
   // 提取Bearer token
   parts := strings.SplitN(authHeader, " ", 2)
   if len(parts) != 2 || parts[0] != "Bearer" {
    http.Error(w, "invalid authorization header format", http.StatusUnauthorized)
    return
   }
   
   tokenString := parts[1]
   
   // 验证token
   claims, err := jwtManager.ValidateToken(tokenString)
   if err != nil {
    http.Error(w, "invalid token: "+err.Error(), http.StatusUnauthorized)
    return
   }
   
   // 将claims存入context
   ctx := context.WithValue(r.Context(), "claims", claims)
   next.ServeHTTP(w, r.WithContext(ctx))
  })
 }
}

// GetClaims 从context获取claims
func GetClaims(ctx context.Context) (*auth.Claims, error) {
 claims, ok := ctx.Value("claims").(*auth.Claims)
 if !ok {
  return nil, errors.New("claims not found in context")
 }
 return claims, nil
}

// RequireRole 要求特定角色
func RequireRole(roles ...string) func(http.Handler) http.Handler {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   claims, err := GetClaims(r.Context())
   if err != nil {
    http.Error(w, "unauthorized", http.StatusUnauthorized)
    return
   }
   
   // 检查角色
   hasRole := false
   for _, role := range roles {
    for _, userRole := range claims.Roles {
     if userRole == role {
      hasRole = true
      break
     }
    }
    if hasRole {
     break
    }
   }
   
   if !hasRole {
    http.Error(w, "insufficient permissions", http.StatusForbidden)
    return
   }
   
   next.ServeHTTP(w, r)
  })
 }
}
```

---

## 2. OAuth 2.0认证

### 2.1 OAuth 2.0服务器

```go
package oauth2

import (
 "context"
 "crypto/rand"
 "encoding/base64"
 "errors"
 "sync"
 "time"
)

// AuthorizationServer OAuth 2.0授权服务器
type AuthorizationServer struct {
 clients      map[string]*Client
 authCodes    map[string]*AuthorizationCode
 accessTokens map[string]*AccessToken
 mu           sync.RWMutex
}

// Client OAuth客户端
type Client struct {
 ClientID     string
 ClientSecret string
 RedirectURIs []string
 Scopes       []string
}

// AuthorizationCode 授权码
type AuthorizationCode struct {
 Code        string
 ClientID    string
 UserID      string
 RedirectURI string
 Scopes      []string
 ExpiresAt   time.Time
}

// AccessToken 访问令牌
type AccessToken struct {
 Token        string
 RefreshToken string
 ClientID     string
 UserID       string
 Scopes       []string
 ExpiresAt    time.Time
}

// NewAuthorizationServer 创建授权服务器
func NewAuthorizationServer() *AuthorizationServer {
 return &AuthorizationServer{
  clients:      make(map[string]*Client),
  authCodes:    make(map[string]*AuthorizationCode),
  accessTokens: make(map[string]*AccessToken),
 }
}

// RegisterClient 注册客户端
func (as *AuthorizationServer) RegisterClient(client *Client) {
 as.mu.Lock()
 defer as.mu.Unlock()
 
 as.clients[client.ClientID] = client
}

// GenerateAuthorizationCode 生成授权码
func (as *AuthorizationServer) GenerateAuthorizationCode(
 clientID, userID, redirectURI string,
 scopes []string,
) (string, error) {
 as.mu.Lock()
 defer as.mu.Unlock()
 
 // 验证客户端
 client, ok := as.clients[clientID]
 if !ok {
  return "", errors.New("invalid client")
 }
 
 // 验证redirect URI
 validURI := false
 for _, uri := range client.RedirectURIs {
  if uri == redirectURI {
   validURI = true
   break
  }
 }
 if !validURI {
  return "", errors.New("invalid redirect URI")
 }
 
 // 生成授权码
 code := generateRandomString(32)
 
 as.authCodes[code] = &AuthorizationCode{
  Code:        code,
  ClientID:    clientID,
  UserID:      userID,
  RedirectURI: redirectURI,
  Scopes:      scopes,
  ExpiresAt:   time.Now().Add(10 * time.Minute),
 }
 
 return code, nil
}

// ExchangeAuthorizationCode 交换授权码
func (as *AuthorizationServer) ExchangeAuthorizationCode(
 code, clientID, clientSecret, redirectURI string,
) (*AccessToken, error) {
 as.mu.Lock()
 defer as.mu.Unlock()
 
 // 验证客户端
 client, ok := as.clients[clientID]
 if !ok || client.ClientSecret != clientSecret {
  return nil, errors.New("invalid client credentials")
 }
 
 // 验证授权码
 authCode, ok := as.authCodes[code]
 if !ok {
  return nil, errors.New("invalid authorization code")
 }
 
 // 检查过期
 if time.Now().After(authCode.ExpiresAt) {
  delete(as.authCodes, code)
  return nil, errors.New("authorization code expired")
 }
 
 // 验证redirect URI
 if authCode.RedirectURI != redirectURI {
  return nil, errors.New("redirect URI mismatch")
 }
 
 // 删除已使用的授权码
 delete(as.authCodes, code)
 
 // 生成访问令牌
 accessToken := &AccessToken{
  Token:        generateRandomString(64),
  RefreshToken: generateRandomString(64),
  ClientID:     clientID,
  UserID:       authCode.UserID,
  Scopes:       authCode.Scopes,
  ExpiresAt:    time.Now().Add(1 * time.Hour),
 }
 
 as.accessTokens[accessToken.Token] = accessToken
 
 return accessToken, nil
}

// ValidateAccessToken 验证访问令牌
func (as *AuthorizationServer) ValidateAccessToken(token string) (*AccessToken, error) {
 as.mu.RLock()
 defer as.mu.RUnlock()
 
 accessToken, ok := as.accessTokens[token]
 if !ok {
  return nil, errors.New("invalid access token")
 }
 
 if time.Now().After(accessToken.ExpiresAt) {
  return nil, errors.New("access token expired")
 }
 
 return accessToken, nil
}

// generateRandomString 生成随机字符串
func generateRandomString(length int) string {
 b := make([]byte, length)
 rand.Read(b)
 return base64.URLEncoding.EncodeToString(b)[:length]
}
```

---

### 2.2 OAuth 2.0客户端

```go
package oauth2client

import (
 "context"
 "encoding/json"
 "fmt"
 "net/http"
 "net/url"
 "strings"
)

// Client OAuth 2.0客户端
type Client struct {
 ClientID     string
 ClientSecret string
 RedirectURI  string
 AuthURL      string
 TokenURL     string
}

// TokenResponse 令牌响应
type TokenResponse struct {
 AccessToken  string `json:"access_token"`
 TokenType    string `json:"token_type"`
 ExpiresIn    int    `json:"expires_in"`
 RefreshToken string `json:"refresh_token"`
 Scope        string `json:"scope"`
}

// GetAuthorizationURL 获取授权URL
func (c *Client) GetAuthorizationURL(state string, scopes []string) string {
 params := url.Values{}
 params.Add("response_type", "code")
 params.Add("client_id", c.ClientID)
 params.Add("redirect_uri", c.RedirectURI)
 params.Add("scope", strings.Join(scopes, " "))
 params.Add("state", state)
 
 return fmt.Sprintf("%s?%s", c.AuthURL, params.Encode())
}

// ExchangeCode 交换授权码
func (c *Client) ExchangeCode(ctx context.Context, code string) (*TokenResponse, error) {
 data := url.Values{}
 data.Set("grant_type", "authorization_code")
 data.Set("code", code)
 data.Set("redirect_uri", c.RedirectURI)
 data.Set("client_id", c.ClientID)
 data.Set("client_secret", c.ClientSecret)
 
 req, err := http.NewRequestWithContext(ctx, "POST", c.TokenURL, strings.NewReader(data.Encode()))
 if err != nil {
  return nil, err
 }
 
 req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
 
 resp, err := http.DefaultClient.Do(req)
 if err != nil {
  return nil, err
 }
 defer resp.Body.Close()
 
 if resp.StatusCode != http.StatusOK {
  return nil, fmt.Errorf("unexpected status: %d", resp.StatusCode)
 }
 
 var tokenResp TokenResponse
 if err := json.NewDecoder(resp.Body).Decode(&tokenResp); err != nil {
  return nil, err
 }
 
 return &tokenResp, nil
}

// RefreshToken 刷新令牌
func (c *Client) RefreshToken(ctx context.Context, refreshToken string) (*TokenResponse, error) {
 data := url.Values{}
 data.Set("grant_type", "refresh_token")
 data.Set("refresh_token", refreshToken)
 data.Set("client_id", c.ClientID)
 data.Set("client_secret", c.ClientSecret)
 
 req, err := http.NewRequestWithContext(ctx, "POST", c.TokenURL, strings.NewReader(data.Encode()))
 if err != nil {
  return nil, err
 }
 
 req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
 
 resp, err := http.DefaultClient.Do(req)
 if err != nil {
  return nil, err
 }
 defer resp.Body.Close()
 
 var tokenResp TokenResponse
 if err := json.NewDecoder(resp.Body).Decode(&tokenResp); err != nil {
  return nil, err
 }
 
 return &tokenResp, nil
}
```

---

## 3. RBAC权限管理

### 3.1 RBAC核心模型

```go
package rbac

import (
 "context"
 "errors"
 "sync"
)

// RBAC 基于角色的访问控制
type RBAC struct {
 roles       map[string]*Role
 permissions map[string]*Permission
 userRoles   map[string][]string // userID -> roleIDs
 mu          sync.RWMutex
}

// Role 角色
type Role struct {
 ID          string
 Name        string
 Description string
 Permissions []string
}

// Permission 权限
type Permission struct {
 ID          string
 Resource    string
 Action      string
 Description string
}

// NewRBAC 创建RBAC
func NewRBAC() *RBAC {
 return &RBAC{
  roles:       make(map[string]*Role),
  permissions: make(map[string]*Permission),
  userRoles:   make(map[string][]string),
 }
}

// AddRole 添加角色
func (r *RBAC) AddRole(role *Role) {
 r.mu.Lock()
 defer r.mu.Unlock()
 
 r.roles[role.ID] = role
}

// AddPermission 添加权限
func (r *RBAC) AddPermission(perm *Permission) {
 r.mu.Lock()
 defer r.mu.Unlock()
 
 r.permissions[perm.ID] = perm
}

// AssignRoleToUser 为用户分配角色
func (r *RBAC) AssignRoleToUser(userID, roleID string) error {
 r.mu.Lock()
 defer r.mu.Unlock()
 
 if _, ok := r.roles[roleID]; !ok {
  return errors.New("role not found")
 }
 
 r.userRoles[userID] = append(r.userRoles[userID], roleID)
 return nil
}

// CheckPermission 检查权限
func (r *RBAC) CheckPermission(userID, resource, action string) bool {
 r.mu.RLock()
 defer r.mu.RUnlock()
 
 // 获取用户角色
 roleIDs, ok := r.userRoles[userID]
 if !ok {
  return false
 }
 
 // 检查每个角色的权限
 for _, roleID := range roleIDs {
  role, ok := r.roles[roleID]
  if !ok {
   continue
  }
  
  // 检查角色是否有该权限
  for _, permID := range role.Permissions {
   perm, ok := r.permissions[permID]
   if !ok {
    continue
   }
   
   if perm.Resource == resource && perm.Action == action {
    return true
   }
   
   // 通配符匹配
   if perm.Resource == "*" || perm.Action == "*" {
    return true
   }
  }
 }
 
 return false
}

// GetUserRoles 获取用户角色
func (r *RBAC) GetUserRoles(userID string) []*Role {
 r.mu.RLock()
 defer r.mu.RUnlock()
 
 roleIDs, ok := r.userRoles[userID]
 if !ok {
  return nil
 }
 
 roles := make([]*Role, 0, len(roleIDs))
 for _, roleID := range roleIDs {
  if role, ok := r.roles[roleID]; ok {
   roles = append(roles, role)
  }
 }
 
 return roles
}

// GetUserPermissions 获取用户所有权限
func (r *RBAC) GetUserPermissions(userID string) []*Permission {
 r.mu.RLock()
 defer r.mu.RUnlock()
 
 roleIDs, ok := r.userRoles[userID]
 if !ok {
  return nil
 }
 
 permMap := make(map[string]*Permission)
 
 for _, roleID := range roleIDs {
  role, ok := r.roles[roleID]
  if !ok {
   continue
  }
  
  for _, permID := range role.Permissions {
   if perm, ok := r.permissions[permID]; ok {
    permMap[permID] = perm
   }
  }
 }
 
 permissions := make([]*Permission, 0, len(permMap))
 for _, perm := range permMap {
  permissions = append(permissions, perm)
 }
 
 return permissions
}
```

---

### 3.2 RBAC中间件

```go
// RequirePermission 要求特定权限
func RequirePermission(rbac *rbac.RBAC, resource, action string) func(http.Handler) http.Handler {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   claims, err := GetClaims(r.Context())
   if err != nil {
    http.Error(w, "unauthorized", http.StatusUnauthorized)
    return
   }
   
   // 检查权限
   if !rbac.CheckPermission(claims.UserID, resource, action) {
    http.Error(w, "forbidden", http.StatusForbidden)
    return
   }
   
   next.ServeHTTP(w, r)
  })
 }
}
```

---

## 4. 密码安全

### 4.1 密码哈希与验证

```go
package security

import (
 "crypto/rand"
 "crypto/subtle"
 "encoding/base64"
 "errors"
 "fmt"
 "strings"
 
 "golang.org/x/crypto/argon2"
)

// PasswordHasher 密码哈希器
type PasswordHasher struct {
 memory      uint32
 iterations  uint32
 parallelism uint8
 saltLength  uint32
 keyLength   uint32
}

// NewPasswordHasher 创建密码哈希器
func NewPasswordHasher() *PasswordHasher {
 return &PasswordHasher{
  memory:      64 * 1024, // 64 MB
  iterations:  3,
  parallelism: 2,
  saltLength:  16,
  keyLength:   32,
 }
}

// Hash 哈希密码
func (ph *PasswordHasher) Hash(password string) (string, error) {
 // 生成盐
 salt := make([]byte, ph.saltLength)
 if _, err := rand.Read(salt); err != nil {
  return "", err
 }
 
 // 使用Argon2id哈希
 hash := argon2.IDKey(
  []byte(password),
  salt,
  ph.iterations,
  ph.memory,
  ph.parallelism,
  ph.keyLength,
 )
 
 // 编码为字符串：$argon2id$v=19$m=65536,t=3,p=2$salt$hash
 b64Salt := base64.RawStdEncoding.EncodeToString(salt)
 b64Hash := base64.RawStdEncoding.EncodeToString(hash)
 
 return fmt.Sprintf("$argon2id$v=%d$m=%d,t=%d,p=%d$%s$%s",
  argon2.Version, ph.memory, ph.iterations, ph.parallelism,
  b64Salt, b64Hash), nil
}

// Verify 验证密码
func (ph *PasswordHasher) Verify(password, encodedHash string) (bool, error) {
 // 解析编码的哈希
 parts := strings.Split(encodedHash, "$")
 if len(parts) != 6 {
  return false, errors.New("invalid hash format")
 }
 
 var version int
 _, err := fmt.Sscanf(parts[2], "v=%d", &version)
 if err != nil {
  return false, err
 }
 
 if version != argon2.Version {
  return false, errors.New("incompatible argon2 version")
 }
 
 var memory, iterations uint32
 var parallelism uint8
 _, err = fmt.Sscanf(parts[3], "m=%d,t=%d,p=%d", &memory, &iterations, &parallelism)
 if err != nil {
  return false, err
 }
 
 salt, err := base64.RawStdEncoding.DecodeString(parts[4])
 if err != nil {
  return false, err
 }
 
 hash, err := base64.RawStdEncoding.DecodeString(parts[5])
 if err != nil {
  return false, err
 }
 
 // 计算密码的哈希
 computedHash := argon2.IDKey(
  []byte(password),
  salt,
  iterations,
  memory,
  parallelism,
  uint32(len(hash)),
 )
 
 // 常量时间比较
 return subtle.ConstantTimeCompare(hash, computedHash) == 1, nil
}
```

---

### 4.2 密码策略

```go
// PasswordValidator 密码验证器
type PasswordValidator struct {
 MinLength      int
 RequireUpper   bool
 RequireLower   bool
 RequireNumber  bool
 RequireSpecial bool
}

// Validate 验证密码强度
func (pv *PasswordValidator) Validate(password string) error {
 if len(password) < pv.MinLength {
  return fmt.Errorf("password must be at least %d characters", pv.MinLength)
 }
 
 var hasUpper, hasLower, hasNumber, hasSpecial bool
 
 for _, char := range password {
  switch {
  case char >= 'A' && char <= 'Z':
   hasUpper = true
  case char >= 'a' && char <= 'z':
   hasLower = true
  case char >= '0' && char <= '9':
   hasNumber = true
  case strings.ContainsRune("!@#$%^&*()-_=+[]{}|;:,.<>?", char):
   hasSpecial = true
  }
 }
 
 if pv.RequireUpper && !hasUpper {
  return errors.New("password must contain at least one uppercase letter")
 }
 
 if pv.RequireLower && !hasLower {
  return errors.New("password must contain at least one lowercase letter")
 }
 
 if pv.RequireNumber && !hasNumber {
  return errors.New("password must contain at least one number")
 }
 
 if pv.RequireSpecial && !hasSpecial {
  return errors.New("password must contain at least one special character")
 }
 
 return nil
}
```

---

## 5. HTTPS/TLS

### 5.1 TLS配置

```go
package tlsconfig

import (
 "crypto/tls"
 "crypto/x509"
 "os"
)

// LoadTLSConfig 加载TLS配置
func LoadTLSConfig(certFile, keyFile, caFile string) (*tls.Config, error) {
 // 加载证书
 cert, err := tls.LoadX509KeyPair(certFile, keyFile)
 if err != nil {
  return nil, err
 }
 
 // 加载CA证书
 caCert, err := os.ReadFile(caFile)
 if err != nil {
  return nil, err
 }
 
 caCertPool := x509.NewCertPool()
 caCertPool.AppendCertsFromPEM(caCert)
 
 return &tls.Config{
  Certificates: []tls.Certificate{cert},
  ClientCAs:    caCertPool,
  ClientAuth:   tls.RequireAndVerifyClientCert,
  MinVersion:   tls.VersionTLS13,
  CipherSuites: []uint16{
   tls.TLS_AES_256_GCM_SHA384,
   tls.TLS_AES_128_GCM_SHA256,
   tls.TLS_CHACHA20_POLY1305_SHA256,
  },
 }, nil
}

// NewSecureServer 创建安全HTTP服务器
func NewSecureServer(addr string, handler http.Handler, tlsConfig *tls.Config) *http.Server {
 return &http.Server{
  Addr:      addr,
  Handler:   handler,
  TLSConfig: tlsConfig,
  // 安全配置
  ReadTimeout:       10 * time.Second,
  WriteTimeout:      10 * time.Second,
  IdleTimeout:       120 * time.Second,
  ReadHeaderTimeout: 5 * time.Second,
  MaxHeaderBytes:    1 << 20, // 1 MB
 }
}
```

---

## 6. 安全防护

### 6.1 SQL注入防护

```go
// ❌ 错误示例：SQL注入风险
func GetUserBad(db *sql.DB, username string) (*User, error) {
 query := fmt.Sprintf("SELECT * FROM users WHERE username = '%s'", username)
 // 如果username是 "admin' OR '1'='1"，将绕过认证
 row := db.QueryRow(query)
 // ...
}

// ✅ 正确示例：使用参数化查询
func GetUserGood(db *sql.DB, username string) (*User, error) {
 query := "SELECT id, username, email FROM users WHERE username = ?"
 row := db.QueryRow(query, username)
 
 var user User
 err := row.Scan(&user.ID, &user.Username, &user.Email)
 if err != nil {
  return nil, err
 }
 
 return &user, nil
}
```

---

### 6.2 XSS防护

```go
package security

import (
 "html"
 "html/template"
)

// SanitizeHTML 清理HTML
func SanitizeHTML(input string) string {
 return html.EscapeString(input)
}

// RenderSafe 安全渲染模板
func RenderSafe(tmpl *template.Template, data interface{}) (string, error) {
 var buf strings.Builder
 err := tmpl.Execute(&buf, data)
 if err != nil {
  return "", err
 }
 return buf.String(), nil
}

// ❌ 错误示例：XSS风险
func HandleCommentBad(w http.ResponseWriter, r *http.Request) {
 comment := r.FormValue("comment")
 fmt.Fprintf(w, "<div>%s</div>", comment) // 如果comment包含<script>，将被执行
}

// ✅ 正确示例：使用template自动转义
func HandleCommentGood(w http.ResponseWriter, r *http.Request) {
 comment := r.FormValue("comment")
 tmpl := template.Must(template.New("comment").Parse("<div>{{.}}</div>"))
 tmpl.Execute(w, comment) // 自动HTML转义
}
```

---

### 6.3 CSRF防护

```go
package csrf

import (
 "crypto/rand"
 "encoding/base64"
 "errors"
 "net/http"
 "sync"
 "time"
)

// CSRFProtector CSRF保护器
type CSRFProtector struct {
 tokens map[string]time.Time
 mu     sync.RWMutex
}

// NewCSRFProtector 创建CSRF保护器
func NewCSRFProtector() *CSRFProtector {
 cp := &CSRFProtector{
  tokens: make(map[string]time.Time),
 }
 
 // 启动清理过期token
 go cp.cleanup()
 
 return cp
}

// GenerateToken 生成CSRF token
func (cp *CSRFProtector) GenerateToken() (string, error) {
 b := make([]byte, 32)
 if _, err := rand.Read(b); err != nil {
  return "", err
 }
 
 token := base64.URLEncoding.EncodeToString(b)
 
 cp.mu.Lock()
 cp.tokens[token] = time.Now().Add(1 * time.Hour)
 cp.mu.Unlock()
 
 return token, nil
}

// ValidateToken 验证CSRF token
func (cp *CSRFProtector) ValidateToken(token string) error {
 cp.mu.RLock()
 expiresAt, ok := cp.tokens[token]
 cp.mu.RUnlock()
 
 if !ok {
  return errors.New("invalid CSRF token")
 }
 
 if time.Now().After(expiresAt) {
  cp.mu.Lock()
  delete(cp.tokens, token)
  cp.mu.Unlock()
  return errors.New("CSRF token expired")
 }
 
 return nil
}

// cleanup 清理过期token
func (cp *CSRFProtector) cleanup() {
 ticker := time.NewTicker(10 * time.Minute)
 defer ticker.Stop()
 
 for range ticker.C {
  cp.mu.Lock()
  now := time.Now()
  for token, expiresAt := range cp.tokens {
   if now.After(expiresAt) {
    delete(cp.tokens, token)
   }
  }
  cp.mu.Unlock()
 }
}

// Middleware CSRF中间件
func (cp *CSRFProtector) Middleware(next http.Handler) http.Handler {
 return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  // GET/HEAD/OPTIONS请求跳过验证
  if r.Method == "GET" || r.Method == "HEAD" || r.Method == "OPTIONS" {
   next.ServeHTTP(w, r)
   return
  }
  
  // 验证CSRF token
  token := r.Header.Get("X-CSRF-Token")
  if token == "" {
   token = r.FormValue("csrf_token")
  }
  
  if err := cp.ValidateToken(token); err != nil {
   http.Error(w, "CSRF validation failed", http.StatusForbidden)
   return
  }
  
  next.ServeHTTP(w, r)
 })
}
```

---

## 7. 审计日志

### 7.1 审计日志系统

```go
package audit

import (
 "context"
 "encoding/json"
 "log"
 "time"
)

// AuditLogger 审计日志记录器
type AuditLogger struct {
 storage AuditStorage
}

// AuditLog 审计日志
type AuditLog struct {
 ID         string                 `json:"id"`
 Timestamp  time.Time              `json:"timestamp"`
 UserID     string                 `json:"user_id"`
 Action     string                 `json:"action"`
 Resource   string                 `json:"resource"`
 Method     string                 `json:"method"`
 Path       string                 `json:"path"`
 StatusCode int                    `json:"status_code"`
 IP         string                 `json:"ip"`
 UserAgent  string                 `json:"user_agent"`
 Duration   time.Duration          `json:"duration"`
 Metadata   map[string]interface{} `json:"metadata"`
}

// AuditStorage 审计存储接口
type AuditStorage interface {
 Save(ctx context.Context, log *AuditLog) error
 Query(ctx context.Context, filter AuditFilter) ([]*AuditLog, error)
}

// NewAuditLogger 创建审计日志记录器
func NewAuditLogger(storage AuditStorage) *AuditLogger {
 return &AuditLogger{
  storage: storage,
 }
}

// Log 记录审计日志
func (al *AuditLogger) Log(ctx context.Context, log *AuditLog) error {
 log.ID = generateID()
 log.Timestamp = time.Now()
 
 return al.storage.Save(ctx, log)
}

// Middleware 审计日志中间件
func (al *AuditLogger) Middleware(next http.Handler) http.Handler {
 return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  start := time.Now()
  
  // 创建响应记录器
  recorder := &responseRecorder{
   ResponseWriter: w,
   statusCode:     http.StatusOK,
  }
  
  // 处理请求
  next.ServeHTTP(recorder, r)
  
  // 获取用户信息
  userID := ""
  if claims, err := GetClaims(r.Context()); err == nil {
   userID = claims.UserID
  }
  
  // 记录审计日志
  auditLog := &AuditLog{
   UserID:     userID,
   Action:     r.Method,
   Resource:   r.URL.Path,
   Method:     r.Method,
   Path:       r.URL.Path,
   StatusCode: recorder.statusCode,
   IP:         r.RemoteAddr,
   UserAgent:  r.UserAgent(),
   Duration:   time.Since(start),
   Metadata: map[string]interface{}{
    "query": r.URL.Query(),
   },
  }
  
  if err := al.Log(r.Context(), auditLog); err != nil {
   log.Printf("Failed to log audit: %v", err)
  }
 })
}

type responseRecorder struct {
 http.ResponseWriter
 statusCode int
}

func (rr *responseRecorder) WriteHeader(code int) {
 rr.statusCode = code
 rr.ResponseWriter.WriteHeader(code)
}
```

---

## 8. 完整案例

### 8.1 安全的用户服务

```go
package main

import (
 "context"
 "database/sql"
 "log"
 "net/http"
 "time"
)

// UserService 用户服务
type UserService struct {
 db       *sql.DB
 jwt      *auth.JWTManager
 hasher   *security.PasswordHasher
 validator *security.PasswordValidator
 rbac     *rbac.RBAC
 audit    *audit.AuditLogger
}

// NewUserService 创建用户服务
func NewUserService(
 db *sql.DB,
 jwt *auth.JWTManager,
 hasher *security.PasswordHasher,
 validator *security.PasswordValidator,
 rbac *rbac.RBAC,
 audit *audit.AuditLogger,
) *UserService {
 return &UserService{
  db:        db,
  jwt:       jwt,
  hasher:    hasher,
  validator: validator,
  rbac:      rbac,
  audit:     audit,
 }
}

// Register 注册用户
func (us *UserService) Register(ctx context.Context, req *RegisterRequest) (*RegisterResponse, error) {
 // 1. 验证密码强度
 if err := us.validator.Validate(req.Password); err != nil {
  return nil, err
 }
 
 // 2. 哈希密码
 hashedPassword, err := us.hasher.Hash(req.Password)
 if err != nil {
  return nil, err
 }
 
 // 3. 保存用户（使用参数化查询防止SQL注入）
 query := "INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)"
 result, err := us.db.ExecContext(ctx, query, req.Username, req.Email, hashedPassword)
 if err != nil {
  return nil, err
 }
 
 userID, _ := result.LastInsertId()
 
 // 4. 分配默认角色
 us.rbac.AssignRoleToUser(fmt.Sprint(userID), "user")
 
 // 5. 记录审计日志
 us.audit.Log(ctx, &audit.AuditLog{
  UserID:   fmt.Sprint(userID),
  Action:   "register",
  Resource: "user",
 })
 
 return &RegisterResponse{
  UserID:   fmt.Sprint(userID),
  Username: req.Username,
 }, nil
}

// Login 登录
func (us *UserService) Login(ctx context.Context, req *LoginRequest) (*LoginResponse, error) {
 // 1. 查询用户
 query := "SELECT id, username, password_hash FROM users WHERE username = ?"
 row := us.db.QueryRowContext(ctx, query, req.Username)
 
 var user struct {
  ID           string
  Username     string
  PasswordHash string
 }
 
 if err := row.Scan(&user.ID, &user.Username, &user.PasswordHash); err != nil {
  return nil, errors.New("invalid credentials")
 }
 
 // 2. 验证密码
 valid, err := us.hasher.Verify(req.Password, user.PasswordHash)
 if err != nil || !valid {
  return nil, errors.New("invalid credentials")
 }
 
 // 3. 获取用户角色
 roles := us.rbac.GetUserRoles(user.ID)
 roleNames := make([]string, len(roles))
 for i, role := range roles {
  roleNames[i] = role.Name
 }
 
 // 4. 生成JWT
 accessToken, err := us.jwt.GenerateAccessToken(user.ID, user.Username, roleNames)
 if err != nil {
  return nil, err
 }
 
 refreshToken, err := us.jwt.GenerateRefreshToken(user.ID)
 if err != nil {
  return nil, err
 }
 
 // 5. 记录审计日志
 us.audit.Log(ctx, &audit.AuditLog{
  UserID:   user.ID,
  Action:   "login",
  Resource: "auth",
 })
 
 return &LoginResponse{
  AccessToken:  accessToken,
  RefreshToken: refreshToken,
  ExpiresIn:    3600,
 }, nil
}

func main() {
 // 1. 初始化组件
 db, _ := sql.Open("mysql", "user:pass@tcp(localhost:3306)/db")
 jwt := auth.NewJWTManager("secret-key", 1*time.Hour, 7*24*time.Hour)
 hasher := security.NewPasswordHasher()
 validator := &security.PasswordValidator{
  MinLength:      8,
  RequireUpper:   true,
  RequireLower:   true,
  RequireNumber:  true,
  RequireSpecial: true,
 }
 rbacSys := rbac.NewRBAC()
 auditStorage := &PostgresAuditStorage{db: db}
 audit := audit.NewAuditLogger(auditStorage)
 
 // 2. 初始化RBAC
 initRBAC(rbacSys)
 
 // 3. 创建服务
 userService := NewUserService(db, jwt, hasher, validator, rbacSys, audit)
 
 // 4. 设置路由
 mux := http.NewServeMux()
 
 // 公开路由
 mux.HandleFunc("/api/register", userService.HandleRegister)
 mux.HandleFunc("/api/login", userService.HandleLogin)
 
 // 受保护路由
 protected := http.NewServeMux()
 protected.HandleFunc("/api/users/me", userService.HandleGetMe)
 protected.HandleFunc("/api/admin/users", userService.HandleListUsers)
 
 // 应用中间件
 handler := middleware.Chain(
  mux,
  audit.Middleware,
  middleware.JWTAuth(jwt),
  middleware.RequirePermission(rbacSys, "users", "read"),
 )
 
 // 5. 启动HTTPS服务器
 tlsConfig, _ := tlsconfig.LoadTLSConfig("cert.pem", "key.pem", "ca.pem")
 server := tlsconfig.NewSecureServer(":8443", handler, tlsConfig)
 
 log.Println("Secure server starting on :8443")
 log.Fatal(server.ListenAndServeTLS("", ""))
}

func initRBAC(rbac *rbac.RBAC) {
 // 添加权限
 rbac.AddPermission(&rbac.Permission{
  ID:       "users:read",
  Resource: "users",
  Action:   "read",
 })
 rbac.AddPermission(&rbac.Permission{
  ID:       "users:write",
  Resource: "users",
  Action:   "write",
 })
 
 // 添加角色
 rbac.AddRole(&rbac.Role{
  ID:          "user",
  Name:        "User",
  Permissions: []string{"users:read"},
 })
 rbac.AddRole(&rbac.Role{
  ID:          "admin",
  Name:        "Admin",
  Permissions: []string{"users:read", "users:write"},
 })
}
```

---

## 📚 安全最佳实践

### 认证授权

- ✅ 使用JWT + 刷新令牌机制
- ✅ 实施RBAC权限管理
- ✅ 支持OAuth 2.0/OIDC
- ✅ 实现多因素认证(MFA)

### 密码安全

- ✅ 使用Argon2id哈希
- ✅ 强制密码策略
- ✅ 定期密码轮换
- ✅ 密码历史记录

### 传输安全

- ✅ 强制HTTPS/TLS 1.3
- ✅ 使用强加密套件
- ✅ 实施证书固定
- ✅ HSTS头部

### 输入验证

- ✅ 参数化SQL查询
- ✅ HTML/JavaScript转义
- ✅ CSRF token验证
- ✅ 输入长度限制

---

## 🎯 总结

Go 1.25.3安全加固关键点：

1. **JWT认证**: 生成/验证/刷新、中间件、角色检查
2. **OAuth 2.0**: 授权服务器、客户端、令牌交换
3. **RBAC**: 角色/权限模型、权限检查
4. **密码安全**: Argon2id哈希、密码策略
5. **TLS/HTTPS**: 证书配置、安全参数
6. **防护**: SQL注入、XSS、CSRF
7. **审计**: 完整审计日志、查询分析

**安全是企业应用的生命线！**

---

<div align="center">

**构建安全可信的Go应用**——

[📚 返回目录](../README.md) | [📖 下一章](23-分布式追踪完整实战.md)

Made with ❤️ for Go Developers

</div>

---

**文档版本**: v1.0  
**最后更新**: 2025-10-22  
**Go版本**: Go 1.25.3  
**生产就绪**: ✅
