# Go 1.25.3 å®‰å…¨åŠ å›ºä¸è®¤è¯æˆæƒå®Œæ•´å®æˆ˜

**æ–‡æ¡£ç±»å‹**: å®‰å…¨å·¥ç¨‹æŒ‡å—  
**Goç‰ˆæœ¬**: Go 1.25.3  
**éš¾åº¦ç­‰çº§**: â­â­â­â­â­ (ä¸“å®¶çº§)  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ22æ—¥

---


## ğŸ“‹ ç›®å½•


- [ğŸ“– æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
- [ç›®å½•](#ç›®å½•)
- [1. JWTè®¤è¯](#1-jwtè®¤è¯)
  - [1.1 JWTç”Ÿæˆä¸éªŒè¯](#11-jwtç”Ÿæˆä¸éªŒè¯)
  - [1.2 JWTä¸­é—´ä»¶](#12-jwtä¸­é—´ä»¶)
- [2. OAuth 2.0è®¤è¯](#2-oauth-20è®¤è¯)
  - [2.1 OAuth 2.0æœåŠ¡å™¨](#21-oauth-20æœåŠ¡å™¨)
  - [2.2 OAuth 2.0å®¢æˆ·ç«¯](#22-oauth-20å®¢æˆ·ç«¯)
- [3. RBACæƒé™ç®¡ç†](#3-rbacæƒé™ç®¡ç†)
  - [3.1 RBACæ ¸å¿ƒæ¨¡å‹](#31-rbacæ ¸å¿ƒæ¨¡å‹)
  - [3.2 RBACä¸­é—´ä»¶](#32-rbacä¸­é—´ä»¶)
- [4. å¯†ç å®‰å…¨](#4-å¯†ç å®‰å…¨)
  - [4.1 å¯†ç å“ˆå¸Œä¸éªŒè¯](#41-å¯†ç å“ˆå¸Œä¸éªŒè¯)
  - [4.2 å¯†ç ç­–ç•¥](#42-å¯†ç ç­–ç•¥)
- [5. HTTPS/TLS](#5-httpstls)
  - [5.1 TLSé…ç½®](#51-tlsé…ç½®)
- [6. å®‰å…¨é˜²æŠ¤](#6-å®‰å…¨é˜²æŠ¤)
  - [6.1 SQLæ³¨å…¥é˜²æŠ¤](#61-sqlæ³¨å…¥é˜²æŠ¤)
  - [6.2 XSSé˜²æŠ¤](#62-xssé˜²æŠ¤)
  - [6.3 CSRFé˜²æŠ¤](#63-csrfé˜²æŠ¤)
- [7. å®¡è®¡æ—¥å¿—](#7-å®¡è®¡æ—¥å¿—)
  - [7.1 å®¡è®¡æ—¥å¿—ç³»ç»Ÿ](#71-å®¡è®¡æ—¥å¿—ç³»ç»Ÿ)
- [8. å®Œæ•´æ¡ˆä¾‹](#8-å®Œæ•´æ¡ˆä¾‹)
  - [8.1 å®‰å…¨çš„ç”¨æˆ·æœåŠ¡](#81-å®‰å…¨çš„ç”¨æˆ·æœåŠ¡)
- [ğŸ“š å®‰å…¨æœ€ä½³å®è·µ](#-å®‰å…¨æœ€ä½³å®è·µ)
  - [è®¤è¯æˆæƒ](#è®¤è¯æˆæƒ)
  - [å¯†ç å®‰å…¨](#å¯†ç å®‰å…¨)
  - [ä¼ è¾“å®‰å…¨](#ä¼ è¾“å®‰å…¨)
  - [è¾“å…¥éªŒè¯](#è¾“å…¥éªŒè¯)
- [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

## ğŸ“– æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£å±•ç¤ºGo 1.25.3çš„**å®‰å…¨åŠ å›ºä¸è®¤è¯æˆæƒå®Œæ•´æ–¹æ¡ˆ**ï¼Œæ„å»ºä¼ä¸šçº§å®‰å…¨ç³»ç»Ÿï¼š

- âœ… JWTè®¤è¯å®Œæ•´å®ç°
- âœ… OAuth 2.0 & OIDC
- âœ… RBACæƒé™ç®¡ç†
- âœ… å¯†ç å®‰å…¨ä¸åŠ å¯†
- âœ… HTTPS/TLSé…ç½®
- âœ… SQLæ³¨å…¥é˜²æŠ¤
- âœ… XSS/CSRFé˜²æŠ¤
- âœ… å®‰å…¨å®¡è®¡æ—¥å¿—

---

## ç›®å½•

- [Go 1.25.3 å®‰å…¨åŠ å›ºä¸è®¤è¯æˆæƒå®Œæ•´å®æˆ˜](#go-1253-å®‰å…¨åŠ å›ºä¸è®¤è¯æˆæƒå®Œæ•´å®æˆ˜)
  - [ğŸ“– æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. JWTè®¤è¯](#1-jwtè®¤è¯)
    - [1.1 JWTç”Ÿæˆä¸éªŒè¯](#11-jwtç”Ÿæˆä¸éªŒè¯)
    - [1.2 JWTä¸­é—´ä»¶](#12-jwtä¸­é—´ä»¶)
  - [2. OAuth 2.0è®¤è¯](#2-oauth-20è®¤è¯)
    - [2.1 OAuth 2.0æœåŠ¡å™¨](#21-oauth-20æœåŠ¡å™¨)
    - [2.2 OAuth 2.0å®¢æˆ·ç«¯](#22-oauth-20å®¢æˆ·ç«¯)
  - [3. RBACæƒé™ç®¡ç†](#3-rbacæƒé™ç®¡ç†)
    - [3.1 RBACæ ¸å¿ƒæ¨¡å‹](#31-rbacæ ¸å¿ƒæ¨¡å‹)
    - [3.2 RBACä¸­é—´ä»¶](#32-rbacä¸­é—´ä»¶)
  - [4. å¯†ç å®‰å…¨](#4-å¯†ç å®‰å…¨)
    - [4.1 å¯†ç å“ˆå¸Œä¸éªŒè¯](#41-å¯†ç å“ˆå¸Œä¸éªŒè¯)
    - [4.2 å¯†ç ç­–ç•¥](#42-å¯†ç ç­–ç•¥)
  - [5. HTTPS/TLS](#5-httpstls)
    - [5.1 TLSé…ç½®](#51-tlsé…ç½®)
  - [6. å®‰å…¨é˜²æŠ¤](#6-å®‰å…¨é˜²æŠ¤)
    - [6.1 SQLæ³¨å…¥é˜²æŠ¤](#61-sqlæ³¨å…¥é˜²æŠ¤)
    - [6.2 XSSé˜²æŠ¤](#62-xssé˜²æŠ¤)
    - [6.3 CSRFé˜²æŠ¤](#63-csrfé˜²æŠ¤)
  - [7. å®¡è®¡æ—¥å¿—](#7-å®¡è®¡æ—¥å¿—)
    - [7.1 å®¡è®¡æ—¥å¿—ç³»ç»Ÿ](#71-å®¡è®¡æ—¥å¿—ç³»ç»Ÿ)
  - [8. å®Œæ•´æ¡ˆä¾‹](#8-å®Œæ•´æ¡ˆä¾‹)
    - [8.1 å®‰å…¨çš„ç”¨æˆ·æœåŠ¡](#81-å®‰å…¨çš„ç”¨æˆ·æœåŠ¡)
  - [ğŸ“š å®‰å…¨æœ€ä½³å®è·µ](#-å®‰å…¨æœ€ä½³å®è·µ)
    - [è®¤è¯æˆæƒ](#è®¤è¯æˆæƒ)
    - [å¯†ç å®‰å…¨](#å¯†ç å®‰å…¨)
    - [ä¼ è¾“å®‰å…¨](#ä¼ è¾“å®‰å…¨)
    - [è¾“å…¥éªŒè¯](#è¾“å…¥éªŒè¯)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

---

## 1. JWTè®¤è¯

### 1.1 JWTç”Ÿæˆä¸éªŒè¯

```go
package auth

import (
 "context"
 "errors"
 "fmt"
 "time"
 
 "github.com/golang-jwt/jwt/v5"
)

// Claims JWTå£°æ˜
type Claims struct {
 UserID   string   `json:"user_id"`
 Username string   `json:"username"`
 Roles    []string `json:"roles"`
 jwt.RegisteredClaims
}

// JWTManager JWTç®¡ç†å™¨
type JWTManager struct {
 secretKey     []byte
 accessExpiry  time.Duration
 refreshExpiry time.Duration
}

// NewJWTManager åˆ›å»ºJWTç®¡ç†å™¨
func NewJWTManager(secretKey string, accessExpiry, refreshExpiry time.Duration) *JWTManager {
 return &JWTManager{
  secretKey:     []byte(secretKey),
  accessExpiry:  accessExpiry,
  refreshExpiry: refreshExpiry,
 }
}

// GenerateAccessToken ç”Ÿæˆè®¿é—®ä»¤ç‰Œ
func (jm *JWTManager) GenerateAccessToken(userID, username string, roles []string) (string, error) {
 claims := &Claims{
  UserID:   userID,
  Username: username,
  Roles:    roles,
  RegisteredClaims: jwt.RegisteredClaims{
   ExpiresAt: jwt.NewNumericDate(time.Now().Add(jm.accessExpiry)),
   IssuedAt:  jwt.NewNumericDate(time.Now()),
   NotBefore: jwt.NewNumericDate(time.Now()),
   Issuer:    "my-app",
   Subject:   userID,
  },
 }
 
 token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
 return token.SignedString(jm.secretKey)
}

// GenerateRefreshToken ç”Ÿæˆåˆ·æ–°ä»¤ç‰Œ
func (jm *JWTManager) GenerateRefreshToken(userID string) (string, error) {
 claims := &jwt.RegisteredClaims{
  ExpiresAt: jwt.NewNumericDate(time.Now().Add(jm.refreshExpiry)),
  IssuedAt:  jwt.NewNumericDate(time.Now()),
  Subject:   userID,
 }
 
 token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
 return token.SignedString(jm.secretKey)
}

// ValidateToken éªŒè¯ä»¤ç‰Œ
func (jm *JWTManager) ValidateToken(tokenString string) (*Claims, error) {
 token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
  // éªŒè¯ç­¾åæ–¹æ³•
  if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
   return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
  }
  return jm.secretKey, nil
 })
 
 if err != nil {
  return nil, err
 }
 
 claims, ok := token.Claims.(*Claims)
 if !ok || !token.Valid {
  return nil, errors.New("invalid token")
 }
 
 return claims, nil
}

// RefreshAccessToken åˆ·æ–°è®¿é—®ä»¤ç‰Œ
func (jm *JWTManager) RefreshAccessToken(refreshToken string) (string, error) {
 token, err := jwt.ParseWithClaims(refreshToken, &jwt.RegisteredClaims{}, func(token *jwt.Token) (interface{}, error) {
  return jm.secretKey, nil
 })
 
 if err != nil {
  return "", err
 }
 
 claims, ok := token.Claims.(*jwt.RegisteredClaims)
 if !ok || !token.Valid {
  return "", errors.New("invalid refresh token")
 }
 
 // è¿™é‡Œåº”è¯¥ä»æ•°æ®åº“è·å–ç”¨æˆ·ä¿¡æ¯
 // ç®€åŒ–ç¤ºä¾‹ï¼Œç›´æ¥ä½¿ç”¨subject
 return jm.GenerateAccessToken(claims.Subject, "", nil)
}
```

---

### 1.2 JWTä¸­é—´ä»¶

```go
package middleware

import (
 "context"
 "net/http"
 "strings"
)

// JWTAuth JWTè®¤è¯ä¸­é—´ä»¶
func JWTAuth(jwtManager *auth.JWTManager) func(http.Handler) http.Handler {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   // è·å–Authorization header
   authHeader := r.Header.Get("Authorization")
   if authHeader == "" {
    http.Error(w, "missing authorization header", http.StatusUnauthorized)
    return
   }
   
   // æå–Bearer token
   parts := strings.SplitN(authHeader, " ", 2)
   if len(parts) != 2 || parts[0] != "Bearer" {
    http.Error(w, "invalid authorization header format", http.StatusUnauthorized)
    return
   }
   
   tokenString := parts[1]
   
   // éªŒè¯token
   claims, err := jwtManager.ValidateToken(tokenString)
   if err != nil {
    http.Error(w, "invalid token: "+err.Error(), http.StatusUnauthorized)
    return
   }
   
   // å°†claimså­˜å…¥context
   ctx := context.WithValue(r.Context(), "claims", claims)
   next.ServeHTTP(w, r.WithContext(ctx))
  })
 }
}

// GetClaims ä»contextè·å–claims
func GetClaims(ctx context.Context) (*auth.Claims, error) {
 claims, ok := ctx.Value("claims").(*auth.Claims)
 if !ok {
  return nil, errors.New("claims not found in context")
 }
 return claims, nil
}

// RequireRole è¦æ±‚ç‰¹å®šè§’è‰²
func RequireRole(roles ...string) func(http.Handler) http.Handler {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   claims, err := GetClaims(r.Context())
   if err != nil {
    http.Error(w, "unauthorized", http.StatusUnauthorized)
    return
   }
   
   // æ£€æŸ¥è§’è‰²
   hasRole := false
   for _, role := range roles {
    for _, userRole := range claims.Roles {
     if userRole == role {
      hasRole = true
      break
     }
    }
    if hasRole {
     break
    }
   }
   
   if !hasRole {
    http.Error(w, "insufficient permissions", http.StatusForbidden)
    return
   }
   
   next.ServeHTTP(w, r)
  })
 }
}
```

---

## 2. OAuth 2.0è®¤è¯

### 2.1 OAuth 2.0æœåŠ¡å™¨

```go
package oauth2

import (
 "context"
 "crypto/rand"
 "encoding/base64"
 "errors"
 "sync"
 "time"
)

// AuthorizationServer OAuth 2.0æˆæƒæœåŠ¡å™¨
type AuthorizationServer struct {
 clients      map[string]*Client
 authCodes    map[string]*AuthorizationCode
 accessTokens map[string]*AccessToken
 mu           sync.RWMutex
}

// Client OAuthå®¢æˆ·ç«¯
type Client struct {
 ClientID     string
 ClientSecret string
 RedirectURIs []string
 Scopes       []string
}

// AuthorizationCode æˆæƒç 
type AuthorizationCode struct {
 Code        string
 ClientID    string
 UserID      string
 RedirectURI string
 Scopes      []string
 ExpiresAt   time.Time
}

// AccessToken è®¿é—®ä»¤ç‰Œ
type AccessToken struct {
 Token        string
 RefreshToken string
 ClientID     string
 UserID       string
 Scopes       []string
 ExpiresAt    time.Time
}

// NewAuthorizationServer åˆ›å»ºæˆæƒæœåŠ¡å™¨
func NewAuthorizationServer() *AuthorizationServer {
 return &AuthorizationServer{
  clients:      make(map[string]*Client),
  authCodes:    make(map[string]*AuthorizationCode),
  accessTokens: make(map[string]*AccessToken),
 }
}

// RegisterClient æ³¨å†Œå®¢æˆ·ç«¯
func (as *AuthorizationServer) RegisterClient(client *Client) {
 as.mu.Lock()
 defer as.mu.Unlock()
 
 as.clients[client.ClientID] = client
}

// GenerateAuthorizationCode ç”Ÿæˆæˆæƒç 
func (as *AuthorizationServer) GenerateAuthorizationCode(
 clientID, userID, redirectURI string,
 scopes []string,
) (string, error) {
 as.mu.Lock()
 defer as.mu.Unlock()
 
 // éªŒè¯å®¢æˆ·ç«¯
 client, ok := as.clients[clientID]
 if !ok {
  return "", errors.New("invalid client")
 }
 
 // éªŒè¯redirect URI
 validURI := false
 for _, uri := range client.RedirectURIs {
  if uri == redirectURI {
   validURI = true
   break
  }
 }
 if !validURI {
  return "", errors.New("invalid redirect URI")
 }
 
 // ç”Ÿæˆæˆæƒç 
 code := generateRandomString(32)
 
 as.authCodes[code] = &AuthorizationCode{
  Code:        code,
  ClientID:    clientID,
  UserID:      userID,
  RedirectURI: redirectURI,
  Scopes:      scopes,
  ExpiresAt:   time.Now().Add(10 * time.Minute),
 }
 
 return code, nil
}

// ExchangeAuthorizationCode äº¤æ¢æˆæƒç 
func (as *AuthorizationServer) ExchangeAuthorizationCode(
 code, clientID, clientSecret, redirectURI string,
) (*AccessToken, error) {
 as.mu.Lock()
 defer as.mu.Unlock()
 
 // éªŒè¯å®¢æˆ·ç«¯
 client, ok := as.clients[clientID]
 if !ok || client.ClientSecret != clientSecret {
  return nil, errors.New("invalid client credentials")
 }
 
 // éªŒè¯æˆæƒç 
 authCode, ok := as.authCodes[code]
 if !ok {
  return nil, errors.New("invalid authorization code")
 }
 
 // æ£€æŸ¥è¿‡æœŸ
 if time.Now().After(authCode.ExpiresAt) {
  delete(as.authCodes, code)
  return nil, errors.New("authorization code expired")
 }
 
 // éªŒè¯redirect URI
 if authCode.RedirectURI != redirectURI {
  return nil, errors.New("redirect URI mismatch")
 }
 
 // åˆ é™¤å·²ä½¿ç”¨çš„æˆæƒç 
 delete(as.authCodes, code)
 
 // ç”Ÿæˆè®¿é—®ä»¤ç‰Œ
 accessToken := &AccessToken{
  Token:        generateRandomString(64),
  RefreshToken: generateRandomString(64),
  ClientID:     clientID,
  UserID:       authCode.UserID,
  Scopes:       authCode.Scopes,
  ExpiresAt:    time.Now().Add(1 * time.Hour),
 }
 
 as.accessTokens[accessToken.Token] = accessToken
 
 return accessToken, nil
}

// ValidateAccessToken éªŒè¯è®¿é—®ä»¤ç‰Œ
func (as *AuthorizationServer) ValidateAccessToken(token string) (*AccessToken, error) {
 as.mu.RLock()
 defer as.mu.RUnlock()
 
 accessToken, ok := as.accessTokens[token]
 if !ok {
  return nil, errors.New("invalid access token")
 }
 
 if time.Now().After(accessToken.ExpiresAt) {
  return nil, errors.New("access token expired")
 }
 
 return accessToken, nil
}

// generateRandomString ç”Ÿæˆéšæœºå­—ç¬¦ä¸²
func generateRandomString(length int) string {
 b := make([]byte, length)
 rand.Read(b)
 return base64.URLEncoding.EncodeToString(b)[:length]
}
```

---

### 2.2 OAuth 2.0å®¢æˆ·ç«¯

```go
package oauth2client

import (
 "context"
 "encoding/json"
 "fmt"
 "net/http"
 "net/url"
 "strings"
)

// Client OAuth 2.0å®¢æˆ·ç«¯
type Client struct {
 ClientID     string
 ClientSecret string
 RedirectURI  string
 AuthURL      string
 TokenURL     string
}

// TokenResponse ä»¤ç‰Œå“åº”
type TokenResponse struct {
 AccessToken  string `json:"access_token"`
 TokenType    string `json:"token_type"`
 ExpiresIn    int    `json:"expires_in"`
 RefreshToken string `json:"refresh_token"`
 Scope        string `json:"scope"`
}

// GetAuthorizationURL è·å–æˆæƒURL
func (c *Client) GetAuthorizationURL(state string, scopes []string) string {
 params := url.Values{}
 params.Add("response_type", "code")
 params.Add("client_id", c.ClientID)
 params.Add("redirect_uri", c.RedirectURI)
 params.Add("scope", strings.Join(scopes, " "))
 params.Add("state", state)
 
 return fmt.Sprintf("%s?%s", c.AuthURL, params.Encode())
}

// ExchangeCode äº¤æ¢æˆæƒç 
func (c *Client) ExchangeCode(ctx context.Context, code string) (*TokenResponse, error) {
 data := url.Values{}
 data.Set("grant_type", "authorization_code")
 data.Set("code", code)
 data.Set("redirect_uri", c.RedirectURI)
 data.Set("client_id", c.ClientID)
 data.Set("client_secret", c.ClientSecret)
 
 req, err := http.NewRequestWithContext(ctx, "POST", c.TokenURL, strings.NewReader(data.Encode()))
 if err != nil {
  return nil, err
 }
 
 req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
 
 resp, err := http.DefaultClient.Do(req)
 if err != nil {
  return nil, err
 }
 defer resp.Body.Close()
 
 if resp.StatusCode != http.StatusOK {
  return nil, fmt.Errorf("unexpected status: %d", resp.StatusCode)
 }
 
 var tokenResp TokenResponse
 if err := json.NewDecoder(resp.Body).Decode(&tokenResp); err != nil {
  return nil, err
 }
 
 return &tokenResp, nil
}

// RefreshToken åˆ·æ–°ä»¤ç‰Œ
func (c *Client) RefreshToken(ctx context.Context, refreshToken string) (*TokenResponse, error) {
 data := url.Values{}
 data.Set("grant_type", "refresh_token")
 data.Set("refresh_token", refreshToken)
 data.Set("client_id", c.ClientID)
 data.Set("client_secret", c.ClientSecret)
 
 req, err := http.NewRequestWithContext(ctx, "POST", c.TokenURL, strings.NewReader(data.Encode()))
 if err != nil {
  return nil, err
 }
 
 req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
 
 resp, err := http.DefaultClient.Do(req)
 if err != nil {
  return nil, err
 }
 defer resp.Body.Close()
 
 var tokenResp TokenResponse
 if err := json.NewDecoder(resp.Body).Decode(&tokenResp); err != nil {
  return nil, err
 }
 
 return &tokenResp, nil
}
```

---

## 3. RBACæƒé™ç®¡ç†

### 3.1 RBACæ ¸å¿ƒæ¨¡å‹

```go
package rbac

import (
 "context"
 "errors"
 "sync"
)

// RBAC åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶
type RBAC struct {
 roles       map[string]*Role
 permissions map[string]*Permission
 userRoles   map[string][]string // userID -> roleIDs
 mu          sync.RWMutex
}

// Role è§’è‰²
type Role struct {
 ID          string
 Name        string
 Description string
 Permissions []string
}

// Permission æƒé™
type Permission struct {
 ID          string
 Resource    string
 Action      string
 Description string
}

// NewRBAC åˆ›å»ºRBAC
func NewRBAC() *RBAC {
 return &RBAC{
  roles:       make(map[string]*Role),
  permissions: make(map[string]*Permission),
  userRoles:   make(map[string][]string),
 }
}

// AddRole æ·»åŠ è§’è‰²
func (r *RBAC) AddRole(role *Role) {
 r.mu.Lock()
 defer r.mu.Unlock()
 
 r.roles[role.ID] = role
}

// AddPermission æ·»åŠ æƒé™
func (r *RBAC) AddPermission(perm *Permission) {
 r.mu.Lock()
 defer r.mu.Unlock()
 
 r.permissions[perm.ID] = perm
}

// AssignRoleToUser ä¸ºç”¨æˆ·åˆ†é…è§’è‰²
func (r *RBAC) AssignRoleToUser(userID, roleID string) error {
 r.mu.Lock()
 defer r.mu.Unlock()
 
 if _, ok := r.roles[roleID]; !ok {
  return errors.New("role not found")
 }
 
 r.userRoles[userID] = append(r.userRoles[userID], roleID)
 return nil
}

// CheckPermission æ£€æŸ¥æƒé™
func (r *RBAC) CheckPermission(userID, resource, action string) bool {
 r.mu.RLock()
 defer r.mu.RUnlock()
 
 // è·å–ç”¨æˆ·è§’è‰²
 roleIDs, ok := r.userRoles[userID]
 if !ok {
  return false
 }
 
 // æ£€æŸ¥æ¯ä¸ªè§’è‰²çš„æƒé™
 for _, roleID := range roleIDs {
  role, ok := r.roles[roleID]
  if !ok {
   continue
  }
  
  // æ£€æŸ¥è§’è‰²æ˜¯å¦æœ‰è¯¥æƒé™
  for _, permID := range role.Permissions {
   perm, ok := r.permissions[permID]
   if !ok {
    continue
   }
   
   if perm.Resource == resource && perm.Action == action {
    return true
   }
   
   // é€šé…ç¬¦åŒ¹é…
   if perm.Resource == "*" || perm.Action == "*" {
    return true
   }
  }
 }
 
 return false
}

// GetUserRoles è·å–ç”¨æˆ·è§’è‰²
func (r *RBAC) GetUserRoles(userID string) []*Role {
 r.mu.RLock()
 defer r.mu.RUnlock()
 
 roleIDs, ok := r.userRoles[userID]
 if !ok {
  return nil
 }
 
 roles := make([]*Role, 0, len(roleIDs))
 for _, roleID := range roleIDs {
  if role, ok := r.roles[roleID]; ok {
   roles = append(roles, role)
  }
 }
 
 return roles
}

// GetUserPermissions è·å–ç”¨æˆ·æ‰€æœ‰æƒé™
func (r *RBAC) GetUserPermissions(userID string) []*Permission {
 r.mu.RLock()
 defer r.mu.RUnlock()
 
 roleIDs, ok := r.userRoles[userID]
 if !ok {
  return nil
 }
 
 permMap := make(map[string]*Permission)
 
 for _, roleID := range roleIDs {
  role, ok := r.roles[roleID]
  if !ok {
   continue
  }
  
  for _, permID := range role.Permissions {
   if perm, ok := r.permissions[permID]; ok {
    permMap[permID] = perm
   }
  }
 }
 
 permissions := make([]*Permission, 0, len(permMap))
 for _, perm := range permMap {
  permissions = append(permissions, perm)
 }
 
 return permissions
}
```

---

### 3.2 RBACä¸­é—´ä»¶

```go
// RequirePermission è¦æ±‚ç‰¹å®šæƒé™
func RequirePermission(rbac *rbac.RBAC, resource, action string) func(http.Handler) http.Handler {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   claims, err := GetClaims(r.Context())
   if err != nil {
    http.Error(w, "unauthorized", http.StatusUnauthorized)
    return
   }
   
   // æ£€æŸ¥æƒé™
   if !rbac.CheckPermission(claims.UserID, resource, action) {
    http.Error(w, "forbidden", http.StatusForbidden)
    return
   }
   
   next.ServeHTTP(w, r)
  })
 }
}
```

---

## 4. å¯†ç å®‰å…¨

### 4.1 å¯†ç å“ˆå¸Œä¸éªŒè¯

```go
package security

import (
 "crypto/rand"
 "crypto/subtle"
 "encoding/base64"
 "errors"
 "fmt"
 "strings"
 
 "golang.org/x/crypto/argon2"
)

// PasswordHasher å¯†ç å“ˆå¸Œå™¨
type PasswordHasher struct {
 memory      uint32
 iterations  uint32
 parallelism uint8
 saltLength  uint32
 keyLength   uint32
}

// NewPasswordHasher åˆ›å»ºå¯†ç å“ˆå¸Œå™¨
func NewPasswordHasher() *PasswordHasher {
 return &PasswordHasher{
  memory:      64 * 1024, // 64 MB
  iterations:  3,
  parallelism: 2,
  saltLength:  16,
  keyLength:   32,
 }
}

// Hash å“ˆå¸Œå¯†ç 
func (ph *PasswordHasher) Hash(password string) (string, error) {
 // ç”Ÿæˆç›
 salt := make([]byte, ph.saltLength)
 if _, err := rand.Read(salt); err != nil {
  return "", err
 }
 
 // ä½¿ç”¨Argon2idå“ˆå¸Œ
 hash := argon2.IDKey(
  []byte(password),
  salt,
  ph.iterations,
  ph.memory,
  ph.parallelism,
  ph.keyLength,
 )
 
 // ç¼–ç ä¸ºå­—ç¬¦ä¸²ï¼š$argon2id$v=19$m=65536,t=3,p=2$salt$hash
 b64Salt := base64.RawStdEncoding.EncodeToString(salt)
 b64Hash := base64.RawStdEncoding.EncodeToString(hash)
 
 return fmt.Sprintf("$argon2id$v=%d$m=%d,t=%d,p=%d$%s$%s",
  argon2.Version, ph.memory, ph.iterations, ph.parallelism,
  b64Salt, b64Hash), nil
}

// Verify éªŒè¯å¯†ç 
func (ph *PasswordHasher) Verify(password, encodedHash string) (bool, error) {
 // è§£æç¼–ç çš„å“ˆå¸Œ
 parts := strings.Split(encodedHash, "$")
 if len(parts) != 6 {
  return false, errors.New("invalid hash format")
 }
 
 var version int
 _, err := fmt.Sscanf(parts[2], "v=%d", &version)
 if err != nil {
  return false, err
 }
 
 if version != argon2.Version {
  return false, errors.New("incompatible argon2 version")
 }
 
 var memory, iterations uint32
 var parallelism uint8
 _, err = fmt.Sscanf(parts[3], "m=%d,t=%d,p=%d", &memory, &iterations, &parallelism)
 if err != nil {
  return false, err
 }
 
 salt, err := base64.RawStdEncoding.DecodeString(parts[4])
 if err != nil {
  return false, err
 }
 
 hash, err := base64.RawStdEncoding.DecodeString(parts[5])
 if err != nil {
  return false, err
 }
 
 // è®¡ç®—å¯†ç çš„å“ˆå¸Œ
 computedHash := argon2.IDKey(
  []byte(password),
  salt,
  iterations,
  memory,
  parallelism,
  uint32(len(hash)),
 )
 
 // å¸¸é‡æ—¶é—´æ¯”è¾ƒ
 return subtle.ConstantTimeCompare(hash, computedHash) == 1, nil
}
```

---

### 4.2 å¯†ç ç­–ç•¥

```go
// PasswordValidator å¯†ç éªŒè¯å™¨
type PasswordValidator struct {
 MinLength      int
 RequireUpper   bool
 RequireLower   bool
 RequireNumber  bool
 RequireSpecial bool
}

// Validate éªŒè¯å¯†ç å¼ºåº¦
func (pv *PasswordValidator) Validate(password string) error {
 if len(password) < pv.MinLength {
  return fmt.Errorf("password must be at least %d characters", pv.MinLength)
 }
 
 var hasUpper, hasLower, hasNumber, hasSpecial bool
 
 for _, char := range password {
  switch {
  case char >= 'A' && char <= 'Z':
   hasUpper = true
  case char >= 'a' && char <= 'z':
   hasLower = true
  case char >= '0' && char <= '9':
   hasNumber = true
  case strings.ContainsRune("!@#$%^&*()-_=+[]{}|;:,.<>?", char):
   hasSpecial = true
  }
 }
 
 if pv.RequireUpper && !hasUpper {
  return errors.New("password must contain at least one uppercase letter")
 }
 
 if pv.RequireLower && !hasLower {
  return errors.New("password must contain at least one lowercase letter")
 }
 
 if pv.RequireNumber && !hasNumber {
  return errors.New("password must contain at least one number")
 }
 
 if pv.RequireSpecial && !hasSpecial {
  return errors.New("password must contain at least one special character")
 }
 
 return nil
}
```

---

## 5. HTTPS/TLS

### 5.1 TLSé…ç½®

```go
package tlsconfig

import (
 "crypto/tls"
 "crypto/x509"
 "os"
)

// LoadTLSConfig åŠ è½½TLSé…ç½®
func LoadTLSConfig(certFile, keyFile, caFile string) (*tls.Config, error) {
 // åŠ è½½è¯ä¹¦
 cert, err := tls.LoadX509KeyPair(certFile, keyFile)
 if err != nil {
  return nil, err
 }
 
 // åŠ è½½CAè¯ä¹¦
 caCert, err := os.ReadFile(caFile)
 if err != nil {
  return nil, err
 }
 
 caCertPool := x509.NewCertPool()
 caCertPool.AppendCertsFromPEM(caCert)
 
 return &tls.Config{
  Certificates: []tls.Certificate{cert},
  ClientCAs:    caCertPool,
  ClientAuth:   tls.RequireAndVerifyClientCert,
  MinVersion:   tls.VersionTLS13,
  CipherSuites: []uint16{
   tls.TLS_AES_256_GCM_SHA384,
   tls.TLS_AES_128_GCM_SHA256,
   tls.TLS_CHACHA20_POLY1305_SHA256,
  },
 }, nil
}

// NewSecureServer åˆ›å»ºå®‰å…¨HTTPæœåŠ¡å™¨
func NewSecureServer(addr string, handler http.Handler, tlsConfig *tls.Config) *http.Server {
 return &http.Server{
  Addr:      addr,
  Handler:   handler,
  TLSConfig: tlsConfig,
  // å®‰å…¨é…ç½®
  ReadTimeout:       10 * time.Second,
  WriteTimeout:      10 * time.Second,
  IdleTimeout:       120 * time.Second,
  ReadHeaderTimeout: 5 * time.Second,
  MaxHeaderBytes:    1 << 20, // 1 MB
 }
}
```

---

## 6. å®‰å…¨é˜²æŠ¤

### 6.1 SQLæ³¨å…¥é˜²æŠ¤

```go
// âŒ é”™è¯¯ç¤ºä¾‹ï¼šSQLæ³¨å…¥é£é™©
func GetUserBad(db *sql.DB, username string) (*User, error) {
 query := fmt.Sprintf("SELECT * FROM users WHERE username = '%s'", username)
 // å¦‚æœusernameæ˜¯ "admin' OR '1'='1"ï¼Œå°†ç»•è¿‡è®¤è¯
 row := db.QueryRow(query)
 // ...
}

// âœ… æ­£ç¡®ç¤ºä¾‹ï¼šä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
func GetUserGood(db *sql.DB, username string) (*User, error) {
 query := "SELECT id, username, email FROM users WHERE username = ?"
 row := db.QueryRow(query, username)
 
 var user User
 err := row.Scan(&user.ID, &user.Username, &user.Email)
 if err != nil {
  return nil, err
 }
 
 return &user, nil
}
```

---

### 6.2 XSSé˜²æŠ¤

```go
package security

import (
 "html"
 "html/template"
)

// SanitizeHTML æ¸…ç†HTML
func SanitizeHTML(input string) string {
 return html.EscapeString(input)
}

// RenderSafe å®‰å…¨æ¸²æŸ“æ¨¡æ¿
func RenderSafe(tmpl *template.Template, data interface{}) (string, error) {
 var buf strings.Builder
 err := tmpl.Execute(&buf, data)
 if err != nil {
  return "", err
 }
 return buf.String(), nil
}

// âŒ é”™è¯¯ç¤ºä¾‹ï¼šXSSé£é™©
func HandleCommentBad(w http.ResponseWriter, r *http.Request) {
 comment := r.FormValue("comment")
 fmt.Fprintf(w, "<div>%s</div>", comment) // å¦‚æœcommentåŒ…å«<script>ï¼Œå°†è¢«æ‰§è¡Œ
}

// âœ… æ­£ç¡®ç¤ºä¾‹ï¼šä½¿ç”¨templateè‡ªåŠ¨è½¬ä¹‰
func HandleCommentGood(w http.ResponseWriter, r *http.Request) {
 comment := r.FormValue("comment")
 tmpl := template.Must(template.New("comment").Parse("<div>{{.}}</div>"))
 tmpl.Execute(w, comment) // è‡ªåŠ¨HTMLè½¬ä¹‰
}
```

---

### 6.3 CSRFé˜²æŠ¤

```go
package csrf

import (
 "crypto/rand"
 "encoding/base64"
 "errors"
 "net/http"
 "sync"
 "time"
)

// CSRFProtector CSRFä¿æŠ¤å™¨
type CSRFProtector struct {
 tokens map[string]time.Time
 mu     sync.RWMutex
}

// NewCSRFProtector åˆ›å»ºCSRFä¿æŠ¤å™¨
func NewCSRFProtector() *CSRFProtector {
 cp := &CSRFProtector{
  tokens: make(map[string]time.Time),
 }
 
 // å¯åŠ¨æ¸…ç†è¿‡æœŸtoken
 go cp.cleanup()
 
 return cp
}

// GenerateToken ç”ŸæˆCSRF token
func (cp *CSRFProtector) GenerateToken() (string, error) {
 b := make([]byte, 32)
 if _, err := rand.Read(b); err != nil {
  return "", err
 }
 
 token := base64.URLEncoding.EncodeToString(b)
 
 cp.mu.Lock()
 cp.tokens[token] = time.Now().Add(1 * time.Hour)
 cp.mu.Unlock()
 
 return token, nil
}

// ValidateToken éªŒè¯CSRF token
func (cp *CSRFProtector) ValidateToken(token string) error {
 cp.mu.RLock()
 expiresAt, ok := cp.tokens[token]
 cp.mu.RUnlock()
 
 if !ok {
  return errors.New("invalid CSRF token")
 }
 
 if time.Now().After(expiresAt) {
  cp.mu.Lock()
  delete(cp.tokens, token)
  cp.mu.Unlock()
  return errors.New("CSRF token expired")
 }
 
 return nil
}

// cleanup æ¸…ç†è¿‡æœŸtoken
func (cp *CSRFProtector) cleanup() {
 ticker := time.NewTicker(10 * time.Minute)
 defer ticker.Stop()
 
 for range ticker.C {
  cp.mu.Lock()
  now := time.Now()
  for token, expiresAt := range cp.tokens {
   if now.After(expiresAt) {
    delete(cp.tokens, token)
   }
  }
  cp.mu.Unlock()
 }
}

// Middleware CSRFä¸­é—´ä»¶
func (cp *CSRFProtector) Middleware(next http.Handler) http.Handler {
 return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  // GET/HEAD/OPTIONSè¯·æ±‚è·³è¿‡éªŒè¯
  if r.Method == "GET" || r.Method == "HEAD" || r.Method == "OPTIONS" {
   next.ServeHTTP(w, r)
   return
  }
  
  // éªŒè¯CSRF token
  token := r.Header.Get("X-CSRF-Token")
  if token == "" {
   token = r.FormValue("csrf_token")
  }
  
  if err := cp.ValidateToken(token); err != nil {
   http.Error(w, "CSRF validation failed", http.StatusForbidden)
   return
  }
  
  next.ServeHTTP(w, r)
 })
}
```

---

## 7. å®¡è®¡æ—¥å¿—

### 7.1 å®¡è®¡æ—¥å¿—ç³»ç»Ÿ

```go
package audit

import (
 "context"
 "encoding/json"
 "log"
 "time"
)

// AuditLogger å®¡è®¡æ—¥å¿—è®°å½•å™¨
type AuditLogger struct {
 storage AuditStorage
}

// AuditLog å®¡è®¡æ—¥å¿—
type AuditLog struct {
 ID         string                 `json:"id"`
 Timestamp  time.Time              `json:"timestamp"`
 UserID     string                 `json:"user_id"`
 Action     string                 `json:"action"`
 Resource   string                 `json:"resource"`
 Method     string                 `json:"method"`
 Path       string                 `json:"path"`
 StatusCode int                    `json:"status_code"`
 IP         string                 `json:"ip"`
 UserAgent  string                 `json:"user_agent"`
 Duration   time.Duration          `json:"duration"`
 Metadata   map[string]interface{} `json:"metadata"`
}

// AuditStorage å®¡è®¡å­˜å‚¨æ¥å£
type AuditStorage interface {
 Save(ctx context.Context, log *AuditLog) error
 Query(ctx context.Context, filter AuditFilter) ([]*AuditLog, error)
}

// NewAuditLogger åˆ›å»ºå®¡è®¡æ—¥å¿—è®°å½•å™¨
func NewAuditLogger(storage AuditStorage) *AuditLogger {
 return &AuditLogger{
  storage: storage,
 }
}

// Log è®°å½•å®¡è®¡æ—¥å¿—
func (al *AuditLogger) Log(ctx context.Context, log *AuditLog) error {
 log.ID = generateID()
 log.Timestamp = time.Now()
 
 return al.storage.Save(ctx, log)
}

// Middleware å®¡è®¡æ—¥å¿—ä¸­é—´ä»¶
func (al *AuditLogger) Middleware(next http.Handler) http.Handler {
 return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  start := time.Now()
  
  // åˆ›å»ºå“åº”è®°å½•å™¨
  recorder := &responseRecorder{
   ResponseWriter: w,
   statusCode:     http.StatusOK,
  }
  
  // å¤„ç†è¯·æ±‚
  next.ServeHTTP(recorder, r)
  
  // è·å–ç”¨æˆ·ä¿¡æ¯
  userID := ""
  if claims, err := GetClaims(r.Context()); err == nil {
   userID = claims.UserID
  }
  
  // è®°å½•å®¡è®¡æ—¥å¿—
  auditLog := &AuditLog{
   UserID:     userID,
   Action:     r.Method,
   Resource:   r.URL.Path,
   Method:     r.Method,
   Path:       r.URL.Path,
   StatusCode: recorder.statusCode,
   IP:         r.RemoteAddr,
   UserAgent:  r.UserAgent(),
   Duration:   time.Since(start),
   Metadata: map[string]interface{}{
    "query": r.URL.Query(),
   },
  }
  
  if err := al.Log(r.Context(), auditLog); err != nil {
   log.Printf("Failed to log audit: %v", err)
  }
 })
}

type responseRecorder struct {
 http.ResponseWriter
 statusCode int
}

func (rr *responseRecorder) WriteHeader(code int) {
 rr.statusCode = code
 rr.ResponseWriter.WriteHeader(code)
}
```

---

## 8. å®Œæ•´æ¡ˆä¾‹

### 8.1 å®‰å…¨çš„ç”¨æˆ·æœåŠ¡

```go
package main

import (
 "context"
 "database/sql"
 "log"
 "net/http"
 "time"
)

// UserService ç”¨æˆ·æœåŠ¡
type UserService struct {
 db       *sql.DB
 jwt      *auth.JWTManager
 hasher   *security.PasswordHasher
 validator *security.PasswordValidator
 rbac     *rbac.RBAC
 audit    *audit.AuditLogger
}

// NewUserService åˆ›å»ºç”¨æˆ·æœåŠ¡
func NewUserService(
 db *sql.DB,
 jwt *auth.JWTManager,
 hasher *security.PasswordHasher,
 validator *security.PasswordValidator,
 rbac *rbac.RBAC,
 audit *audit.AuditLogger,
) *UserService {
 return &UserService{
  db:        db,
  jwt:       jwt,
  hasher:    hasher,
  validator: validator,
  rbac:      rbac,
  audit:     audit,
 }
}

// Register æ³¨å†Œç”¨æˆ·
func (us *UserService) Register(ctx context.Context, req *RegisterRequest) (*RegisterResponse, error) {
 // 1. éªŒè¯å¯†ç å¼ºåº¦
 if err := us.validator.Validate(req.Password); err != nil {
  return nil, err
 }
 
 // 2. å“ˆå¸Œå¯†ç 
 hashedPassword, err := us.hasher.Hash(req.Password)
 if err != nil {
  return nil, err
 }
 
 // 3. ä¿å­˜ç”¨æˆ·ï¼ˆä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢é˜²æ­¢SQLæ³¨å…¥ï¼‰
 query := "INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)"
 result, err := us.db.ExecContext(ctx, query, req.Username, req.Email, hashedPassword)
 if err != nil {
  return nil, err
 }
 
 userID, _ := result.LastInsertId()
 
 // 4. åˆ†é…é»˜è®¤è§’è‰²
 us.rbac.AssignRoleToUser(fmt.Sprint(userID), "user")
 
 // 5. è®°å½•å®¡è®¡æ—¥å¿—
 us.audit.Log(ctx, &audit.AuditLog{
  UserID:   fmt.Sprint(userID),
  Action:   "register",
  Resource: "user",
 })
 
 return &RegisterResponse{
  UserID:   fmt.Sprint(userID),
  Username: req.Username,
 }, nil
}

// Login ç™»å½•
func (us *UserService) Login(ctx context.Context, req *LoginRequest) (*LoginResponse, error) {
 // 1. æŸ¥è¯¢ç”¨æˆ·
 query := "SELECT id, username, password_hash FROM users WHERE username = ?"
 row := us.db.QueryRowContext(ctx, query, req.Username)
 
 var user struct {
  ID           string
  Username     string
  PasswordHash string
 }
 
 if err := row.Scan(&user.ID, &user.Username, &user.PasswordHash); err != nil {
  return nil, errors.New("invalid credentials")
 }
 
 // 2. éªŒè¯å¯†ç 
 valid, err := us.hasher.Verify(req.Password, user.PasswordHash)
 if err != nil || !valid {
  return nil, errors.New("invalid credentials")
 }
 
 // 3. è·å–ç”¨æˆ·è§’è‰²
 roles := us.rbac.GetUserRoles(user.ID)
 roleNames := make([]string, len(roles))
 for i, role := range roles {
  roleNames[i] = role.Name
 }
 
 // 4. ç”ŸæˆJWT
 accessToken, err := us.jwt.GenerateAccessToken(user.ID, user.Username, roleNames)
 if err != nil {
  return nil, err
 }
 
 refreshToken, err := us.jwt.GenerateRefreshToken(user.ID)
 if err != nil {
  return nil, err
 }
 
 // 5. è®°å½•å®¡è®¡æ—¥å¿—
 us.audit.Log(ctx, &audit.AuditLog{
  UserID:   user.ID,
  Action:   "login",
  Resource: "auth",
 })
 
 return &LoginResponse{
  AccessToken:  accessToken,
  RefreshToken: refreshToken,
  ExpiresIn:    3600,
 }, nil
}

func main() {
 // 1. åˆå§‹åŒ–ç»„ä»¶
 db, _ := sql.Open("mysql", "user:pass@tcp(localhost:3306)/db")
 jwt := auth.NewJWTManager("secret-key", 1*time.Hour, 7*24*time.Hour)
 hasher := security.NewPasswordHasher()
 validator := &security.PasswordValidator{
  MinLength:      8,
  RequireUpper:   true,
  RequireLower:   true,
  RequireNumber:  true,
  RequireSpecial: true,
 }
 rbacSys := rbac.NewRBAC()
 auditStorage := &PostgresAuditStorage{db: db}
 audit := audit.NewAuditLogger(auditStorage)
 
 // 2. åˆå§‹åŒ–RBAC
 initRBAC(rbacSys)
 
 // 3. åˆ›å»ºæœåŠ¡
 userService := NewUserService(db, jwt, hasher, validator, rbacSys, audit)
 
 // 4. è®¾ç½®è·¯ç”±
 mux := http.NewServeMux()
 
 // å…¬å¼€è·¯ç”±
 mux.HandleFunc("/api/register", userService.HandleRegister)
 mux.HandleFunc("/api/login", userService.HandleLogin)
 
 // å—ä¿æŠ¤è·¯ç”±
 protected := http.NewServeMux()
 protected.HandleFunc("/api/users/me", userService.HandleGetMe)
 protected.HandleFunc("/api/admin/users", userService.HandleListUsers)
 
 // åº”ç”¨ä¸­é—´ä»¶
 handler := middleware.Chain(
  mux,
  audit.Middleware,
  middleware.JWTAuth(jwt),
  middleware.RequirePermission(rbacSys, "users", "read"),
 )
 
 // 5. å¯åŠ¨HTTPSæœåŠ¡å™¨
 tlsConfig, _ := tlsconfig.LoadTLSConfig("cert.pem", "key.pem", "ca.pem")
 server := tlsconfig.NewSecureServer(":8443", handler, tlsConfig)
 
 log.Println("Secure server starting on :8443")
 log.Fatal(server.ListenAndServeTLS("", ""))
}

func initRBAC(rbac *rbac.RBAC) {
 // æ·»åŠ æƒé™
 rbac.AddPermission(&rbac.Permission{
  ID:       "users:read",
  Resource: "users",
  Action:   "read",
 })
 rbac.AddPermission(&rbac.Permission{
  ID:       "users:write",
  Resource: "users",
  Action:   "write",
 })
 
 // æ·»åŠ è§’è‰²
 rbac.AddRole(&rbac.Role{
  ID:          "user",
  Name:        "User",
  Permissions: []string{"users:read"},
 })
 rbac.AddRole(&rbac.Role{
  ID:          "admin",
  Name:        "Admin",
  Permissions: []string{"users:read", "users:write"},
 })
}
```

---

## ğŸ“š å®‰å…¨æœ€ä½³å®è·µ

### è®¤è¯æˆæƒ

- âœ… ä½¿ç”¨JWT + åˆ·æ–°ä»¤ç‰Œæœºåˆ¶
- âœ… å®æ–½RBACæƒé™ç®¡ç†
- âœ… æ”¯æŒOAuth 2.0/OIDC
- âœ… å®ç°å¤šå› ç´ è®¤è¯(MFA)

### å¯†ç å®‰å…¨

- âœ… ä½¿ç”¨Argon2idå“ˆå¸Œ
- âœ… å¼ºåˆ¶å¯†ç ç­–ç•¥
- âœ… å®šæœŸå¯†ç è½®æ¢
- âœ… å¯†ç å†å²è®°å½•

### ä¼ è¾“å®‰å…¨

- âœ… å¼ºåˆ¶HTTPS/TLS 1.3
- âœ… ä½¿ç”¨å¼ºåŠ å¯†å¥—ä»¶
- âœ… å®æ–½è¯ä¹¦å›ºå®š
- âœ… HSTSå¤´éƒ¨

### è¾“å…¥éªŒè¯

- âœ… å‚æ•°åŒ–SQLæŸ¥è¯¢
- âœ… HTML/JavaScriptè½¬ä¹‰
- âœ… CSRF tokenéªŒè¯
- âœ… è¾“å…¥é•¿åº¦é™åˆ¶

---

## ğŸ¯ æ€»ç»“

Go 1.25.3å®‰å…¨åŠ å›ºå…³é”®ç‚¹ï¼š

1. **JWTè®¤è¯**: ç”Ÿæˆ/éªŒè¯/åˆ·æ–°ã€ä¸­é—´ä»¶ã€è§’è‰²æ£€æŸ¥
2. **OAuth 2.0**: æˆæƒæœåŠ¡å™¨ã€å®¢æˆ·ç«¯ã€ä»¤ç‰Œäº¤æ¢
3. **RBAC**: è§’è‰²/æƒé™æ¨¡å‹ã€æƒé™æ£€æŸ¥
4. **å¯†ç å®‰å…¨**: Argon2idå“ˆå¸Œã€å¯†ç ç­–ç•¥
5. **TLS/HTTPS**: è¯ä¹¦é…ç½®ã€å®‰å…¨å‚æ•°
6. **é˜²æŠ¤**: SQLæ³¨å…¥ã€XSSã€CSRF
7. **å®¡è®¡**: å®Œæ•´å®¡è®¡æ—¥å¿—ã€æŸ¥è¯¢åˆ†æ

**å®‰å…¨æ˜¯ä¼ä¸šåº”ç”¨çš„ç”Ÿå‘½çº¿ï¼**

---

<div align="center">

**æ„å»ºå®‰å…¨å¯ä¿¡çš„Goåº”ç”¨**â€”â€”

[ğŸ“š è¿”å›ç›®å½•](../README.md) | [ğŸ“– ä¸‹ä¸€ç« ](23-åˆ†å¸ƒå¼è¿½è¸ªå®Œæ•´å®æˆ˜.md)

Made with â¤ï¸ for Go Developers

</div>

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-10-22  
**Goç‰ˆæœ¬**: Go 1.25.3  
**ç”Ÿäº§å°±ç»ª**: âœ…
