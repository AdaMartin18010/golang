# Go内存优化

> **简介**: Go内存优化完整指南，包括内存逃逸、sync.Pool、对象复用和最佳实践

> **版本**: Go 1.25.3  
> **难度**: ⭐⭐⭐⭐  
> **标签**: #性能优化 #内存 #GC #逃逸分析

---

## 📚 目录

1. [内存分配基础](#内存分配基础)
2. [内存逃逸分析](#内存逃逸分析)
3. [sync.Pool](#syncpool)
4. [减少内存分配](#减少内存分配)
5. [GC优化](#gc优化)
6. [最佳实践](#最佳实践)

---

## 1. 内存分配基础

### 栈vs堆

```go
// 栈分配（快速）
func stackAlloc() int {
    x := 42  // 分配在栈上
    return x
}

// 堆分配（较慢）
func heapAlloc() *int {
    x := 42
    return &x  // 逃逸到堆
}
```

---

### 查看内存分配

```bash
# 查看内存分配
go build -gcflags="-m" main.go

# 输出示例：
# ./main.go:5:2: moved to heap: x
```

---

## 2. 内存逃逸分析

### 逃逸场景1: 返回指针

```go
// ❌ 逃逸到堆
func newUser() *User {
    u := User{Name: "Alice"}
    return &u  // u逃逸到堆
}

// ✅ 在栈上分配
func newUser() User {
    return User{Name: "Alice"}  // 返回值，不逃逸
}
```

---

### 逃逸场景2: 接口赋值

```go
// ❌ 逃逸到堆
func printValue(v interface{}) {
    fmt.Println(v)
}

func main() {
    x := 42
    printValue(x)  // x逃逸到堆
}

// ✅ 避免接口（如果可能）
func printInt(v int) {
    fmt.Println(v)  // 不逃逸
}
```

---

### 逃逸场景3: 闭包捕获

```go
// ❌ 逃逸到堆
func makeIncrementer() func() int {
    i := 0
    return func() int {
        i++  // i逃逸到堆
        return i
    }
}

// ✅ 使用参数传递
type Counter struct {
    count int
}

func (c *Counter) Increment() int {
    c.count++
    return c.count
}
```

---

### 逃逸场景4: 大对象

```go
// ❌ 大对象逃逸到堆
func largeArray() {
    var arr [1000000]int  // 太大，逃逸到堆
    _ = arr
}

// ✅ 使用切片（按需分配）
func largeSlice() {
    arr := make([]int, 0, 1000000)
    _ = arr
}
```

---

## 3. sync.Pool

### 基本使用

```go
var bufferPool = sync.Pool{
    New: func() interface{} {
        return new(bytes.Buffer)
    },
}

func processData(data []byte) []byte {
    // 从池中获取
    buf := bufferPool.Get().(*bytes.Buffer)
    defer func() {
        buf.Reset()
        bufferPool.Put(buf)  // 放回池中
    }()
    
    buf.Write(data)
    buf.WriteString(" processed")
    
    return buf.Bytes()
}
```

---

### HTTP Handler中使用

```go
var responsePool = sync.Pool{
    New: func() interface{} {
        return &Response{
            Data: make(map[string]interface{}),
        }
    },
}

func handler(w http.ResponseWriter, r *http.Request) {
    resp := responsePool.Get().(*Response)
    defer responsePool.Put(resp)
    
    resp.Reset()
    resp.Data["message"] = "Hello"
    
    json.NewEncoder(w).Encode(resp)
}
```

---

### 注意事项

```go
// ❌ 错误：Pool中的对象会被GC回收
var badPool = sync.Pool{
    New: func() interface{} {
        return &BigObject{}
    },
}

func wrong() {
    obj := badPool.Get().(*BigObject)
    // 如果GC运行，对象可能被回收
    // 不要依赖对象一直存在
}

// ✅ 正确：总是Reset后再Put
func correct() {
    obj := badPool.Get().(*BigObject)
    defer func() {
        obj.Reset()  // 清理状态
        badPool.Put(obj)
    }()
    
    // 使用obj
}
```

---

## 4. 减少内存分配

### 预分配切片

```go
// ❌ 不推荐：多次分配
func buildSlice() []int {
    var result []int
    for i := 0; i < 1000; i++ {
        result = append(result, i)  // 可能多次重新分配
    }
    return result
}

// ✅ 推荐：预分配容量
func buildSlice() []int {
    result := make([]int, 0, 1000)  // 预分配容量
    for i := 0; i < 1000; i++ {
        result = append(result, i)  // 不需要重新分配
    }
    return result
}
```

---

### 字符串拼接

```go
// ❌ 不推荐：字符串拼接（每次分配新字符串）
func concat(strs []string) string {
    result := ""
    for _, s := range strs {
        result += s  // 每次分配新字符串
    }
    return result
}

// ✅ 推荐：使用strings.Builder
func concat(strs []string) string {
    var builder strings.Builder
    for _, s := range strs {
        builder.WriteString(s)
    }
    return builder.String()
}

// ✅ 更好：预分配容量
func concat(strs []string) string {
    totalLen := 0
    for _, s := range strs {
        totalLen += len(s)
    }
    
    var builder strings.Builder
    builder.Grow(totalLen)  // 预分配
    for _, s := range strs {
        builder.WriteString(s)
    }
    return builder.String()
}
```

---

### 复用buffer

```go
// ❌ 不推荐：每次分配新buffer
func process(items []Item) [][]byte {
    var results [][]byte
    for _, item := range items {
        buf := new(bytes.Buffer)
        buf.WriteString(item.Name)
        results = append(results, buf.Bytes())
    }
    return results
}

// ✅ 推荐：复用buffer
func process(items []Item) [][]byte {
    var results [][]byte
    buf := new(bytes.Buffer)
    for _, item := range items {
        buf.Reset()  // 复用buffer
        buf.WriteString(item.Name)
        // 复制数据（因为buf会被Reset）
        data := make([]byte, buf.Len())
        copy(data, buf.Bytes())
        results = append(results, data)
    }
    return results
}
```

---

### Map预分配

```go
// ❌ 不推荐
func buildMap() map[string]int {
    m := make(map[string]int)
    for i := 0; i < 1000; i++ {
        m[fmt.Sprintf("key%d", i)] = i
    }
    return m
}

// ✅ 推荐：预分配容量
func buildMap() map[string]int {
    m := make(map[string]int, 1000)  // 预分配
    for i := 0; i < 1000; i++ {
        m[fmt.Sprintf("key%d", i)] = i
    }
    return m
}
```

---

## 5. GC优化

### 减少指针数量

```go
// ❌ 不推荐：大量指针
type SlowStruct struct {
    A *int
    B *string
    C *float64
    // GC需要扫描所有指针
}

// ✅ 推荐：减少指针
type FastStruct struct {
    A int
    B string
    C float64
    // 没有指针，GC扫描更快
}
```

---

### 控制GC频率

```go
// 设置GC触发百分比
// GOGC=100 (默认): 堆大小增长100%时触发GC
// GOGC=200: 堆大小增长200%时触发GC（减少GC频率）
// GOGC=50: 堆大小增长50%时触发GC（增加GC频率）

// Go 1.19+: 设置内存限制
// GOMEMLIMIT=4GiB

// 代码中设置
debug.SetGCPercent(200)  // 减少GC频率
```

---

### 批量分配

```go
// ❌ 不推荐：逐个分配
func allocateMany() []*Object {
    var objects []*Object
    for i := 0; i < 1000; i++ {
        objects = append(objects, &Object{ID: i})
    }
    return objects
}

// ✅ 推荐：批量分配
func allocateMany() []*Object {
    // 分配连续内存
    objects := make([]Object, 1000)
    ptrs := make([]*Object, 1000)
    
    for i := range objects {
        objects[i].ID = i
        ptrs[i] = &objects[i]
    }
    
    return ptrs
}
```

---

## 6. 最佳实践

### 1. 使用基准测试

```go
func BenchmarkConcat(b *testing.B) {
    strs := []string{"hello", "world", "foo", "bar"}
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = concat(strs)
    }
}

// 运行
// go test -bench=. -benchmem
```

---

### 2. 分析内存使用

```bash
# CPU和内存profile
go test -cpuprofile=cpu.prof -memprofile=mem.prof -bench=.

# 查看内存分配
go tool pprof -alloc_space mem.prof
go tool pprof -alloc_objects mem.prof

# 查看内存使用
go tool pprof -inuse_space mem.prof
go tool pprof -inuse_objects mem.prof
```

---

### 3. 避免不必要的拷贝

```go
// ❌ 不推荐：拷贝大结构体
func process(data LargeStruct) {
    // data是拷贝
}

// ✅ 推荐：使用指针
func process(data *LargeStruct) {
    // 只传递指针
}
```

---

### 4. 使用[]byte而不是string

```go
// ❌ 不推荐：string拼接
func buildJSON(data map[string]string) string {
    result := "{"
    for k, v := range data {
        result += fmt.Sprintf(`"%s":"%s",`, k, v)
    }
    result += "}"
    return result
}

// ✅ 推荐：使用[]byte或bytes.Buffer
func buildJSON(data map[string]string) []byte {
    var buf bytes.Buffer
    buf.WriteString("{")
    for k, v := range data {
        fmt.Fprintf(&buf, `"%s":"%s",`, k, v)
    }
    buf.WriteString("}")
    return buf.Bytes()
}
```

---

### 5. 及时释放资源

```go
// ✅ 推荐：及时置nil
func process() {
    largeData := make([]byte, 10*1024*1024)
    
    // 使用largeData
    doSomething(largeData)
    
    // 及时释放
    largeData = nil
    
    // 继续其他操作
    doOtherThings()
}
```

---

## 🎯 性能对比

### 字符串拼接

```go
// 基准测试结果
BenchmarkStringConcat-8         1000000    1200 ns/op    512 B/op    10 allocs/op
BenchmarkStringBuilder-8       10000000     120 ns/op     64 B/op     1 allocs/op
BenchmarkStringBuilderGrow-8   20000000      60 ns/op     64 B/op     1 allocs/op
```

### sync.Pool

```go
// 基准测试结果
BenchmarkWithoutPool-8    1000000    1500 ns/op    1024 B/op    1 allocs/op
BenchmarkWithPool-8      10000000     150 ns/op       0 B/op    0 allocs/op
```

---

## 🔗 相关资源

- [性能分析工具](./01-性能分析工具.md)
- [GC调优](./05-GC调优.md)
- [并发优化](./03-并发优化.md)

---

**最后更新**: 2025-10-28  
**Go版本**: 1.25.3
