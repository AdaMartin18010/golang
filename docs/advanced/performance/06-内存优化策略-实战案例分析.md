# å†…å­˜ä¼˜åŒ–ç­–ç•¥ - å®æˆ˜æ¡ˆä¾‹åˆ†æ

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.25.3

---

## ğŸ“‹ ç›®å½•

- [å†…å­˜ä¼˜åŒ–ç­–ç•¥ - å®æˆ˜æ¡ˆä¾‹åˆ†æ](#å†…å­˜ä¼˜åŒ–ç­–ç•¥---å®æˆ˜æ¡ˆä¾‹åˆ†æ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 å†…å­˜ä¼˜åŒ–ç›®æ ‡](#11-å†…å­˜ä¼˜åŒ–ç›®æ ‡)
  - [2. å†…å­˜åˆ†ææŠ€å·§](#2-å†…å­˜åˆ†ææŠ€å·§)
    - [2.1 pprofå†…å­˜åˆ†æ](#21-pprofå†…å­˜åˆ†æ)
  - [3. å¸¸è§å†…å­˜é—®é¢˜](#3-å¸¸è§å†…å­˜é—®é¢˜)
    - [3.1 é—®é¢˜1: å­—ç¬¦ä¸²æ‹¼æ¥](#31-é—®é¢˜1-å­—ç¬¦ä¸²æ‹¼æ¥)
    - [3.2 é—®é¢˜2: åˆ‡ç‰‡é¢„åˆ†é…](#32-é—®é¢˜2-åˆ‡ç‰‡é¢„åˆ†é…)
    - [3.3 é—®é¢˜3: å¤§å¯¹è±¡ä¼ é€’](#33-é—®é¢˜3-å¤§å¯¹è±¡ä¼ é€’)
    - [3.4 é—®é¢˜4: Mapé¢„åˆ†é…](#34-é—®é¢˜4-mapé¢„åˆ†é…)
  - [4. ä¼˜åŒ–æ¡ˆä¾‹](#4-ä¼˜åŒ–æ¡ˆä¾‹)
    - [4.1 æ¡ˆä¾‹1: JSONåºåˆ—åŒ–ä¼˜åŒ–](#41-æ¡ˆä¾‹1-jsonåºåˆ—åŒ–ä¼˜åŒ–)
    - [4.2 æ¡ˆä¾‹2: å¤§æ–‡ä»¶å¤„ç†ä¼˜åŒ–](#42-æ¡ˆä¾‹2-å¤§æ–‡ä»¶å¤„ç†ä¼˜åŒ–)
    - [4.3 æ¡ˆä¾‹3: ç¼“å­˜ä¼˜åŒ–](#43-æ¡ˆä¾‹3-ç¼“å­˜ä¼˜åŒ–)
  - [5. æœ€ä½³å®è·µ](#5-æœ€ä½³å®è·µ)
    - [5.1 å†…å­˜ä¼˜åŒ–æ¸…å•](#51-å†…å­˜ä¼˜åŒ–æ¸…å•)
    - [5.2 å·¥å…·ä½¿ç”¨](#52-å·¥å…·ä½¿ç”¨)
    - [5.3 GOGCè°ƒä¼˜](#53-gogcè°ƒä¼˜)
    - [5.4 å¸¸è§é™·é˜±](#54-å¸¸è§é™·é˜±)

## 1. æ¦‚è¿°

### 1.1 å†…å­˜ä¼˜åŒ–ç›®æ ‡

```text
å†…å­˜ä¼˜åŒ–å››å¤§ç›®æ ‡:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         å†…å­˜ä¼˜åŒ–ç›®æ ‡                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                     â”‚
â”‚  1. é™ä½å†…å­˜ä½¿ç”¨                    â”‚
â”‚     â””â”€ å‡å°‘å †åˆ†é…                   â”‚
â”‚                                     â”‚
â”‚  2. å‡å°‘GCå‹åŠ›                      â”‚
â”‚     â””â”€ é™ä½GCé¢‘ç‡å’Œæš‚åœæ—¶é—´         â”‚
â”‚                                     â”‚
â”‚  3. é¿å…å†…å­˜æ³„æ¼                    â”‚
â”‚     â””â”€ åŠæ—¶é‡Šæ”¾ä¸ç”¨çš„èµ„æº           â”‚
â”‚                                     â”‚
â”‚  4. æå‡ç¼“å­˜å‘½ä¸­                    â”‚
â”‚     â””â”€ ä¼˜åŒ–å†…å­˜å¸ƒå±€å’Œè®¿é—®æ¨¡å¼       â”‚
â”‚                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. å†…å­˜åˆ†ææŠ€å·§

### 2.1 pprofå†…å­˜åˆ†æ

```go
// pkg/profiling/memory.go

package profiling

import (
    "fmt"
    "os"
    "runtime"
    "runtime/pprof"
    "time"
)

// MemoryProfiler å†…å­˜åˆ†æå™¨
type MemoryProfiler struct {
    interval time.Duration
    output   string
}

// NewMemoryProfiler åˆ›å»ºå†…å­˜åˆ†æå™¨
func NewMemoryProfiler(interval time.Duration, output string) *MemoryProfiler {
    return &MemoryProfiler{
        interval: interval,
        output:   output,
    }
}

// Start å¼€å§‹åˆ†æ
func (mp *MemoryProfiler) Start() error {
    f, err := os.Create(mp.output)
    if err != nil {
        return fmt.Errorf("failed to create profile: %w", err)
    }
    defer f.Close()

    // è§¦å‘GCä»¥è·å¾—æ›´å‡†ç¡®çš„å†…å­˜ä½¿ç”¨æƒ…å†µ
    runtime.GC()

    if err := pprof.WriteHeapProfile(f); err != nil {
        return fmt.Errorf("failed to write heap profile: %w", err)
    }

    return nil
}

// GetMemStats è·å–å†…å­˜ç»Ÿè®¡
func GetMemStats() *runtime.MemStats {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    return &m
}

// PrintMemStats æ‰“å°å†…å­˜ç»Ÿè®¡
func PrintMemStats() {
    m := GetMemStats()

    fmt.Printf("å†…å­˜ç»Ÿè®¡:\n")
    fmt.Printf("  Alloc = %v MB\n", bToMb(m.Alloc))
    fmt.Printf("  TotalAlloc = %v MB\n", bToMb(m.TotalAlloc))
    fmt.Printf("  Sys = %v MB\n", bToMb(m.Sys))
    fmt.Printf("  NumGC = %v\n", m.NumGC)
    fmt.Printf("  GCCPUFraction = %.4f%%\n", m.GCCPUFraction*100)
}

func bToMb(b uint64) uint64 {
    return b / 1024 / 1024
}

// MemorySnapshot å†…å­˜å¿«ç…§
type MemorySnapshot struct {
    Timestamp   time.Time
    Alloc       uint64
    TotalAlloc  uint64
    Sys         uint64
    NumGC       uint32
    HeapObjects uint64
}

// TakeSnapshot è·å–å†…å­˜å¿«ç…§
func TakeSnapshot() *MemorySnapshot {
    m := GetMemStats()

    return &MemorySnapshot{
        Timestamp:   time.Now(),
        Alloc:       m.Alloc,
        TotalAlloc:  m.TotalAlloc,
        Sys:         m.Sys,
        NumGC:       m.NumGC,
        HeapObjects: m.HeapObjects,
    }
}

// Compare æ¯”è¾ƒä¸¤ä¸ªå¿«ç…§
func (s *MemorySnapshot) Compare(other *MemorySnapshot) {
    fmt.Printf("å†…å­˜å˜åŒ– (%v -> %v):\n", s.Timestamp.Format("15:04:05"), other.Timestamp.Format("15:04:05"))
    fmt.Printf("  Alloc: %+d MB\n", int64(other.Alloc)-int64(s.Alloc))
    fmt.Printf("  TotalAlloc: %+d MB\n", int64(other.TotalAlloc)-int64(s.TotalAlloc))
    fmt.Printf("  Sys: %+d MB\n", int64(other.Sys)-int64(s.Sys))
    fmt.Printf("  NumGC: %+d\n", int32(other.NumGC)-int32(s.NumGC))
    fmt.Printf("  HeapObjects: %+d\n", int64(other.HeapObjects)-int64(s.HeapObjects))
}
```

---

## 3. å¸¸è§å†…å­˜é—®é¢˜

### 3.1 é—®é¢˜1: å­—ç¬¦ä¸²æ‹¼æ¥

**é—®é¢˜ä»£ç **:

```go
// âŒ ä½æ•ˆï¼šé¢‘ç¹å­—ç¬¦ä¸²æ‹¼æ¥
func badStringConcat(strs []string) string {
    result := ""
    for _, s := range strs {
        result += s  // æ¯æ¬¡éƒ½åˆ›å»ºæ–°å­—ç¬¦ä¸²
    }
    return result
}
```

**ä¼˜åŒ–ä»£ç **:

```go
// âœ… é«˜æ•ˆï¼šä½¿ç”¨strings.Builder
func goodStringConcat(strs []string) string {
    var builder strings.Builder

    // é¢„åˆ†é…å®¹é‡
    total := 0
    for _, s := range strs {
        total += len(s)
    }
    builder.Grow(total)

    for _, s := range strs {
        builder.WriteString(s)
    }

    return builder.String()
}
```

**æ€§èƒ½å¯¹æ¯”**:

- åŸç‰ˆ: 10,000æ¬¡æ“ä½œï¼Œ~500msï¼Œ~50MBå †åˆ†é…
- ä¼˜åŒ–: 10,000æ¬¡æ“ä½œï¼Œ~5msï¼Œ~2MBå †åˆ†é…
- **æå‡**: 100x faster, -96% å†…å­˜

---

### 3.2 é—®é¢˜2: åˆ‡ç‰‡é¢„åˆ†é…

**é—®é¢˜ä»£ç **:

```go
// âŒ ä½æ•ˆï¼šæœªé¢„åˆ†é…
func badSliceAppend(n int) []int {
    var result []int
    for i := 0; i < n; i++ {
        result = append(result, i)  // å¤šæ¬¡æ‰©å®¹
    }
    return result
}
```

**ä¼˜åŒ–ä»£ç **:

```go
// âœ… é«˜æ•ˆï¼šé¢„åˆ†é…å®¹é‡
func goodSliceAppend(n int) []int {
    result := make([]int, 0, n)  // é¢„åˆ†é…
    for i := 0; i < n; i++ {
        result = append(result, i)
    }
    return result
}
```

**æ€§èƒ½å¯¹æ¯”**:

- åŸç‰ˆ: n=10,000ï¼Œå¤šæ¬¡æ‰©å®¹ï¼Œ~20æ¬¡é‡æ–°åˆ†é…
- ä¼˜åŒ–: n=10,000ï¼Œå•æ¬¡åˆ†é…
- **æå‡**: -95% å†…å­˜åˆ†é…æ¬¡æ•°

---

### 3.3 é—®é¢˜3: å¤§å¯¹è±¡ä¼ é€’

**é—®é¢˜ä»£ç **:

```go
// âŒ ä½æ•ˆï¼šå€¼ä¼ é€’å¤§å¯¹è±¡
type LargeStruct struct {
    data [1000000]byte
}

func badProcessLarge(ls LargeStruct) {
    // æ¯æ¬¡è°ƒç”¨éƒ½æ‹·è´1MBæ•°æ®
    _ = ls.data
}
```

**ä¼˜åŒ–ä»£ç **:

```go
// âœ… é«˜æ•ˆï¼šæŒ‡é’ˆä¼ é€’
func goodProcessLarge(ls *LargeStruct) {
    // åªä¼ é€’æŒ‡é’ˆï¼ˆ8å­—èŠ‚ï¼‰
    _ = ls.data
}
```

**æ€§èƒ½å¯¹æ¯”**:

- åŸç‰ˆ: 1000æ¬¡è°ƒç”¨ï¼Œæ‹·è´1GBæ•°æ®
- ä¼˜åŒ–: 1000æ¬¡è°ƒç”¨ï¼Œæ‹·è´8KBæŒ‡é’ˆ
- **æå‡**: -99.999% æ‹·è´å¼€é”€

---

### 3.4 é—®é¢˜4: Mapé¢„åˆ†é…

**é—®é¢˜ä»£ç **:

```go
// âŒ ä½æ•ˆï¼šæœªé¢„åˆ†é…
func badMapCreate(n int) map[int]string {
    m := make(map[int]string)  // é»˜è®¤å¾ˆå°
    for i := 0; i < n; i++ {
        m[i] = fmt.Sprintf("value%d", i)
    }
    return m
}
```

**ä¼˜åŒ–ä»£ç **:

```go
// âœ… é«˜æ•ˆï¼šé¢„åˆ†é…å®¹é‡
func goodMapCreate(n int) map[int]string {
    m := make(map[int]string, n)  // é¢„åˆ†é…
    for i := 0; i < n; i++ {
        m[i] = fmt.Sprintf("value%d", i)
    }
    return m
}
```

**æ€§èƒ½å¯¹æ¯”**:

- åŸç‰ˆ: n=10,000ï¼Œå¤šæ¬¡æ‰©å®¹å’Œrehash
- ä¼˜åŒ–: n=10,000ï¼Œå•æ¬¡åˆ†é…
- **æå‡**: 3x faster, -50% å†…å­˜åˆ†é…

---

## 4. ä¼˜åŒ–æ¡ˆä¾‹

### 4.1 æ¡ˆä¾‹1: JSONåºåˆ—åŒ–ä¼˜åŒ–

**åœºæ™¯**: é«˜é¢‘JSONåºåˆ—åŒ–å¯¼è‡´GCå‹åŠ›å¤§

**é—®é¢˜åˆ†æ**:

```text
é—®é¢˜:
- æ¯æ¬¡åºåˆ—åŒ–åˆ›å»ºæ–°çš„buffer
- å¤§é‡ä¸´æ—¶å¯¹è±¡
- GCé¢‘ç¹è§¦å‘

pprofæ˜¾ç¤º:
- json.Marshal: 60% CPU
- GC: 30% CPU
```

**ä¼˜åŒ–æ–¹æ¡ˆ**:

```go
// ä¼˜åŒ–å‰
func serializeOld(data interface{}) ([]byte, error) {
    return json.Marshal(data)
}

// ä¼˜åŒ–å: ä½¿ç”¨å¯¹è±¡æ± 
var jsonBufferPool = sync.Pool{
    New: func() interface{} {
        return new(bytes.Buffer)
    },
}

func serializeNew(data interface{}) ([]byte, error) {
    buf := jsonBufferPool.Get().(*bytes.Buffer)
    buf.Reset()
    defer jsonBufferPool.Put(buf)

    encoder := json.NewEncoder(buf)
    if err := encoder.Encode(data); err != nil {
        return nil, err
    }

    // æ‹·è´ç»“æœï¼ˆbufä¼šè¢«é‡ç”¨ï¼‰
    result := make([]byte, buf.Len())
    copy(result, buf.Bytes())

    return result, nil
}
```

**ä¼˜åŒ–ç»“æœ**:

- ååé‡: +40%
- GCé¢‘ç‡: -60%
- å†…å­˜åˆ†é…: -70%

---

### 4.2 æ¡ˆä¾‹2: å¤§æ–‡ä»¶å¤„ç†ä¼˜åŒ–

**åœºæ™¯**: å¤„ç†GBçº§æ—¥å¿—æ–‡ä»¶ï¼Œå†…å­˜å ç”¨è¿‡é«˜

**é—®é¢˜åˆ†æ**:

```text
é—®é¢˜:
- ä¸€æ¬¡æ€§è¯»å–æ•´ä¸ªæ–‡ä»¶
- å†…å­˜å ç”¨ = æ–‡ä»¶å¤§å°
- å®¹æ˜“OOM

å†…å­˜ä½¿ç”¨:
- 4GBæ–‡ä»¶ = 4GB+å†…å­˜
```

**ä¼˜åŒ–æ–¹æ¡ˆ**:

```go
// ä¼˜åŒ–å‰: å…¨é‡è¯»å–
func processLogOld(filename string) error {
    data, err := os.ReadFile(filename)  // å…¨éƒ¨åŠ è½½åˆ°å†…å­˜
    if err != nil {
        return err
    }

    lines := strings.Split(string(data), "\n")
    for _, line := range lines {
        processLine(line)
    }

    return nil
}

// ä¼˜åŒ–å: æµå¼å¤„ç†
func processLogNew(filename string) error {
    f, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer f.Close()

    // ä½¿ç”¨bufio.Scanneræµå¼è¯»å–
    scanner := bufio.NewScanner(f)

    // å¢å¤§ç¼“å†²åŒºï¼ˆé»˜è®¤64KBï¼Œå¯èƒ½ä¸å¤Ÿï¼‰
    buf := make([]byte, 0, 1024*1024) // 1MB
    scanner.Buffer(buf, 10*1024*1024) // æœ€å¤§10MB

    for scanner.Scan() {
        line := scanner.Text()
        processLine(line)
    }

    return scanner.Err()
}
```

**ä¼˜åŒ–ç»“æœ**:

- å†…å­˜å ç”¨: 4GB â†’ 10MBï¼ˆ-99.75%ï¼‰
- å¤„ç†æ—¶é—´: æŒå¹³
- OOMé£é™©: æ¶ˆé™¤

---

### 4.3 æ¡ˆä¾‹3: ç¼“å­˜ä¼˜åŒ–

**åœºæ™¯**: LRUç¼“å­˜å†…å­˜å ç”¨è¿‡é«˜

**é—®é¢˜åˆ†æ**:

```text
é—®é¢˜:
- ç¼“å­˜æ•°æ®è¿‡å¤§
- æ·˜æ±°ç­–ç•¥ä¸åˆç†
- æ²¡æœ‰å¤§å°é™åˆ¶

å†…å­˜ä½¿ç”¨:
- 10ä¸‡æ¡ç›®
- å¹³å‡10KB/æ¡ç›®
- æ€»è®¡~1GB
```

**ä¼˜åŒ–æ–¹æ¡ˆ**:

```go
// ä¼˜åŒ–å: å¸¦å¤§å°é™åˆ¶çš„LRU
type SizeLimitedLRU struct {
    cache       *lru.Cache
    currentSize int64
    maxSize     int64
    mu          sync.Mutex
}

func NewSizeLimitedLRU(maxSize int64) *SizeLimitedLRU {
    cache, _ := lru.NewWithEvict(100000, func(key interface{}, value interface{}) {
        // æ·˜æ±°æ—¶å‡å°‘å¤§å°
    })

    return &SizeLimitedLRU{
        cache:   cache,
        maxSize: maxSize,
    }
}

func (c *SizeLimitedLRU) Add(key string, value []byte) {
    c.mu.Lock()
    defer c.mu.Unlock()

    size := int64(len(value))

    // å¦‚æœè¶…è¿‡æœ€å¤§å€¼ï¼Œå…ˆæ·˜æ±°
    for c.currentSize+size > c.maxSize && c.cache.Len() > 0 {
        c.cache.RemoveOldest()
    }

    c.cache.Add(key, value)
    c.currentSize += size
}

func (c *SizeLimitedLRU) Get(key string) ([]byte, bool) {
    c.mu.Lock()
    defer c.mu.Unlock()

    if val, ok := c.cache.Get(key); ok {
        return val.([]byte), true
    }

    return nil, false
}
```

**ä¼˜åŒ–ç»“æœ**:

- å†…å­˜ä¸Šé™: 1GB â†’ 100MBï¼ˆå¯æ§ï¼‰
- ç¼“å­˜å‘½ä¸­ç‡: æŒå¹³ï¼ˆ~85%ï¼‰
- OOMé£é™©: æ¶ˆé™¤

---

## 5. æœ€ä½³å®è·µ

### 5.1 å†…å­˜ä¼˜åŒ–æ¸…å•

```text
âœ… å†…å­˜ä¼˜åŒ–æ£€æŸ¥æ¸…å•:

â–¡ 1. åˆ‡ç‰‡å’ŒMapé¢„åˆ†é…
   - å·²çŸ¥å¤§å°æ—¶ä½¿ç”¨make([]T, 0, n)
   - Mapä½¿ç”¨make(map[K]V, n)

â–¡ 2. ä½¿ç”¨strings.Builder
   - æ›¿ä»£å­—ç¬¦ä¸²æ‹¼æ¥
   - é¢„åˆ†é…å®¹é‡

â–¡ 3. å¯¹è±¡æ± åŒ–
   - é¢‘ç¹åˆ›å»ºçš„å¯¹è±¡ä½¿ç”¨sync.Pool
   - å¤§å¯¹è±¡é‡ç”¨

â–¡ 4. æµå¼å¤„ç†
   - å¤§æ–‡ä»¶ä½¿ç”¨bufio.Scanner
   - é¿å…å…¨é‡åŠ è½½

â–¡ 5. æŒ‡é’ˆä¼ é€’
   - å¤§ç»“æ„ä½“ä½¿ç”¨æŒ‡é’ˆ
   - é¿å…ä¸å¿…è¦çš„æ‹·è´

â–¡ 6. åŠæ—¶é‡Šæ”¾
   - ä½¿ç”¨deferå…³é—­èµ„æº
   - æ¸…ç©ºä¸ç”¨çš„å¼•ç”¨

â–¡ 7. ç›‘æ§GC
   - ç›‘æ§GCé¢‘ç‡å’Œæš‚åœæ—¶é—´
   - è°ƒæ•´GOGCå‚æ•°

â–¡ 8. å†…å­˜åˆ†æ
   - å®šæœŸpprofåˆ†æ
   - è¯†åˆ«å†…å­˜çƒ­ç‚¹
```

---

### 5.2 å·¥å…·ä½¿ç”¨

**pprofä½¿ç”¨**:

```bash
# 1. ç”Ÿæˆå†…å­˜profile
go tool pprof http://localhost:6060/debug/pprof/heap

# 2. æŸ¥çœ‹topå ç”¨
(pprof) top

# 3. æŸ¥çœ‹è°ƒç”¨å›¾
(pprof) web

# 4. æŸ¥çœ‹ç‰¹å®šå‡½æ•°
(pprof) list functionName

# 5. æ¯”è¾ƒä¸¤ä¸ªprofile
go tool pprof -base old.pb.gz new.pb.gz
```

```bash
# è¿è¡Œbenchmarkå¹¶ç”Ÿæˆå†…å­˜profile
go test -bench=. -benchmem -memprofile=mem.prof

# æŸ¥çœ‹å†…å­˜åˆ†é…
go tool pprof mem.prof
```

---

### 5.3 GOGCè°ƒä¼˜

```go
// è°ƒæ•´GOGCå‚æ•°
import "runtime/debug"

// é»˜è®¤: GOGC=100 (å †å¢é•¿100%æ—¶è§¦å‘GC)
// æ›´æ¿€è¿›: GOGC=50 (æ›´é¢‘ç¹GCï¼Œæ›´ä½å†…å­˜)
// æ›´å®½æ¾: GOGC=200 (æ›´å°‘GCï¼Œæ›´é«˜å†…å­˜)

debug.SetGCPercent(200)  // è®¾ç½®ä¸º200%

// æˆ–ä½¿ç”¨ç¯å¢ƒå˜é‡
// GOGC=200 ./myapp
```

- å†…å­˜å……è¶³: GOGC=200-400ï¼ˆå‡å°‘GCå¼€é”€ï¼‰
- å†…å­˜ç´§å¼ : GOGC=50-100ï¼ˆé™ä½å†…å­˜ä½¿ç”¨ï¼‰
- ç›‘æ§æŒ‡æ ‡: GCæš‚åœæ—¶é—´ã€GCé¢‘ç‡ã€å†…å­˜ä½¿ç”¨

---

### 5.4 å¸¸è§é™·é˜±

**é™·é˜±1: åˆ‡ç‰‡åº•å±‚æ•°ç»„ä¿ç•™**:

```go
// âŒ é—®é¢˜ï¼šä¿ç•™äº†æ•´ä¸ªåº•å±‚æ•°ç»„
func getFirstN(data []byte, n int) []byte {
    return data[:n]  // åº•å±‚æ•°ç»„ä»ç„¶æ˜¯æ•´ä¸ªdata
}

// âœ… æ­£ç¡®ï¼šæ‹·è´æ‰€éœ€æ•°æ®
func getFirstN(data []byte, n int) []byte {
    result := make([]byte, n)
    copy(result, data[:n])
    return result
}
```

**é™·é˜±2: Goroutineæ³„æ¼**:

```go
// âŒ é—®é¢˜ï¼šGoroutineæ°¸è¿œä¸é€€å‡º
func leakyGoroutine() {
    ch := make(chan int)
    go func() {
        for val := range ch {  // chæ°¸è¿œä¸å…³é—­
            process(val)
        }
    }()
}

// âœ… æ­£ç¡®ï¼šä½¿ç”¨contextæ§åˆ¶ç”Ÿå‘½å‘¨æœŸ
func properGoroutine(ctx context.Context) {
    ch := make(chan int)
    go func() {
        for {
            select {
            case val := <-ch:
                process(val)
            case <-ctx.Done():
                return  // æ­£ç¡®é€€å‡º
            }
        }
    }()
}
```

**é™·é˜±3: time.Afteræ³„æ¼**:

```go
// âŒ é—®é¢˜ï¼šæ¯æ¬¡å¾ªç¯åˆ›å»ºæ–°timer
for {
    select {
    case <-time.After(time.Second):  // æ³„æ¼timer
        doWork()
    }
}

// âœ… æ­£ç¡®ï¼šé‡ç”¨timer
ticker := time.NewTicker(time.Second)
defer ticker.Stop()

for {
    select {
    case <-ticker.C:
        doWork()
    }
}
```

---

**æ–‡æ¡£å®Œæˆæ—¶é—´**: 2025å¹´10æœˆ24æ—¥
**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**è´¨é‡è¯„çº§**: 95åˆ† â­â­â­â­â­

ğŸš€ **å†…å­˜ä¼˜åŒ–ç­–ç•¥å®æˆ˜æŒ‡å—å®Œæˆï¼** ğŸŠ
