# Go性能分析工具

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---

> **难度**: ⭐⭐⭐⭐
> **标签**: #性能分析 #pprof #trace #benchmark

## 📋 目录

- [1. pprof性能分析](#1-pprof性能分析)
  - [CPU性能分析](#cpu性能分析)
  - [内存性能分析](#内存性能分析)
  - [HTTP服务性能分析](#http服务性能分析)
- [2. Execution Trace](#2-execution-trace)
  - [收集trace数据](#收集trace数据)
  - [分析trace](#分析trace)
- [3. Benchmark基准测试](#3-benchmark基准测试)
  - [基本benchmark](#基本benchmark)
  - [并行benchmark](#并行benchmark)
  - [子benchmark](#子benchmark)
- [4. 实战案例](#4-实战案例)
  - [案例1: 找出CPU热点](#案例1-找出cpu热点)
  - [案例2: 内存泄漏检测](#案例2-内存泄漏检测)
  - [案例3: GC压力分析](#案例3-gc压力分析)
- [5. 最佳实践](#5-最佳实践)
  - [性能分析流程](#性能分析流程)
  - [pprof技巧](#pprof技巧)
  - [benchmark技巧](#benchmark技巧)
  - [生产环境监控](#生产环境监控)
- [🔗 相关资源](#相关资源)

## 1. pprof性能分析

### CPU性能分析

```go
import (
    "os"
    "runtime/pprof"
)

func main() {
    // 创建CPU profile文件
    f, _ := os.Create("cpu.pprof")
    defer f.Close()
    
    // 开始CPU profiling
    pprof.StartCPUProfile(f)
    defer pprof.StopCPUProfile()
    
    // 运行你的代码
    doWork()
}
```

**分析**:
```bash
go tool pprof cpu.pprof
(pprof) top
(pprof) list functionName
(pprof) web  # 生成可视化图表
```

---

### 内存性能分析

```go
import (
    "os"
    "runtime"
    "runtime/pprof"
)

func main() {
    doWork()
    
    // 创建内存profile文件
    f, _ := os.Create("mem.pprof")
    defer f.Close()
    
    runtime.GC()  // 触发GC
    pprof.WriteHeapProfile(f)
}
```

**分析**:
```bash
go tool pprof mem.pprof
(pprof) top
(pprof) list functionName
```

---

### HTTP服务性能分析

```go
import (
    _ "net/http/pprof"
    "net/http"
)

func main() {
    // pprof会自动注册HTTP端点
    go http.ListenAndServe("localhost:6060", nil)
    
    // 你的服务代码
    startServer()
}
```

**访问端点**:
- http://localhost:6060/debug/pprof/
- http://localhost:6060/debug/pprof/heap
- http://localhost:6060/debug/pprof/goroutine
- http://localhost:6060/debug/pprof/profile?seconds=30

**实时分析**:
```bash
# CPU profile
go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30

# 内存 profile
go tool pprof http://localhost:6060/debug/pprof/heap

# Goroutine profile
go tool pprof http://localhost:6060/debug/pprof/goroutine

# 可视化
go tool pprof -http=:8080 profile.pprof
```

---

## 2. Execution Trace

### 收集trace数据

```go
import (
    "os"
    "runtime/trace"
)

func main() {
    f, _ := os.Create("trace.out")
    defer f.Close()
    
    trace.Start(f)
    defer trace.Stop()
    
    // 运行你的代码
    doWork()
}
```

### 分析trace

```bash
go tool trace trace.out
```

**trace可以看到**:
- Goroutine调度
- 系统调用
- GC事件
- Network I/O
- 用户自定义事件

---

## 3. Benchmark基准测试

### 基本benchmark

```go
func BenchmarkFibonacci(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Fibonacci(20)
    }
}
```

**运行**:
```bash
go test -bench=. -benchmem
```

**输出**:
```
BenchmarkFibonacci-8   30000   50000 ns/op   0 B/op   0 allocs/op
```

---

### 并行benchmark

```go
func BenchmarkParallel(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            doWork()
        }
    })
}
```

---

### 子benchmark

```go
func BenchmarkCompare(b *testing.B) {
    for _, size := range []int{100, 1000, 10000} {
        b.Run(fmt.Sprintf("Size_%d", size), func(b *testing.B) {
            for i := 0; i < b.N; i++ {
                processData(size)
            }
        })
    }
}
```

---

## 4. 实战案例

### 案例1: 找出CPU热点

```go
// 优化前
func processData(data []int) int {
    sum := 0
    for _, v := range data {
        sum += expensiveOperation(v)  // 热点函数
    }
    return sum
}

// 使用pprof发现expensiveOperation是热点
// 优化后：缓存结果
var cache = make(map[int]int)

func processDataOptimized(data []int) int {
    sum := 0
    for _, v := range data {
        if result, ok := cache[v]; ok {
            sum += result
        } else {
            result := expensiveOperation(v)
            cache[v] = result
            sum += result
        }
    }
    return sum
}
```

---

### 案例2: 内存泄漏检测

```go
// 问题代码：Goroutine泄漏
func leakyFunction() {
    ch := make(chan int)
    go func() {
        val := <-ch  // 永远阻塞，goroutine泄漏
        fmt.Println(val)
    }()
    // ch没有被写入，goroutine永远等待
}

// 使用goroutine profile检测
// http://localhost:6060/debug/pprof/goroutine

// 修复：使用context取消
func fixedFunction(ctx context.Context) {
    ch := make(chan int)
    go func() {
        select {
        case val := <-ch:
            fmt.Println(val)
        case <-ctx.Done():
            return  // 正常退出
        }
    }()
}
```

---

### 案例3: GC压力分析

```bash
# 查看GC统计
GODEBUG=gctrace=1 ./myapp

# 分析堆内存
go tool pprof -alloc_space http://localhost:6060/debug/pprof/heap
```

---

## 5. 最佳实践

### 性能分析流程

```
1. 建立基准
   ↓
2. 运行pprof/trace
   ↓
3. 识别瓶颈
   ↓
4. 优化代码
   ↓
5. 对比基准
   ↓
6. 重复2-5直到满意
```

---

### pprof技巧

**1. 对比profile**:
```bash
go tool pprof -base=old.pprof new.pprof
```

**2. 火焰图**:
```bash
go tool pprof -http=:8080 cpu.pprof
```

**3. 查看调用图**:
```bash
(pprof) web
```

---

### benchmark技巧

**1. 避免编译器优化**:
```go
var result int

func BenchmarkFunction(b *testing.B) {
    var r int
    for i := 0; i < b.N; i++ {
        r = function()  // 将结果赋值给局部变量
    }
    result = r  // 防止编译器优化掉整个循环
}
```

**2. 重置定时器**:
```go
func BenchmarkWithSetup(b *testing.B) {
    heavySetup()  // 耗时的准备工作
    
    b.ResetTimer()  // 重置计时器
    
    for i := 0; i < b.N; i++ {
        function()
    }
}
```

---

### 生产环境监控

```go
import (
    "expvar"
    "net/http"
)

func init() {
    // 暴露运行时统计
    expvar.Publish("goroutines", expvar.Func(func() any {
        return runtime.NumGoroutine()
    }))
}

func main() {
    // expvar + pprof
    go http.ListenAndServe(":6060", nil)
    
    // 你的服务
    startServer()
}
```

---

## 🔗 相关资源

- [pprof官方文档](https://pkg.go.dev/runtime/pprof)
- [trace工具](https://pkg.go.dev/runtime/trace)
- [性能优化指南](../02-内存优化.md)

---

**最后更新**: 2025-10-29  
**Go版本**: 1.25.3
