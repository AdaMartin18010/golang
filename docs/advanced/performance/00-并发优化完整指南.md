# âš¡ å¹¶å‘ä¼˜åŒ–æŒ‡å—

> **ç‰ˆæœ¬**: v2.0.0  
> **æ›´æ–°æ—¥æœŸ**: 2025-10-22  
> **é€‚ç”¨èŒƒå›´**: æ‰€æœ‰Goå¹¶å‘é¡¹ç›®

---

## ğŸ“‹ ç›®å½•


- [ğŸ¯ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ä¼˜åŒ–ç›®æ ‡](#ä¼˜åŒ–ç›®æ ‡)
- [ğŸ”§ å¹¶å‘åˆ†æå·¥å…·](#-å¹¶å‘åˆ†æå·¥å…·)
  - [1. Goroutineåˆ†æ](#1-goroutineåˆ†æ)
    - [æ£€æŸ¥Goroutineæ³„æ¼](#æ£€æŸ¥goroutineæ³„æ¼)
    - [ä½¿ç”¨Go Race Detector](#ä½¿ç”¨go-race-detector)
  - [2. é¡¹ç›®æä¾›çš„å·¥å…·](#2-é¡¹ç›®æä¾›çš„å·¥å…·)
    - [å¹¶å‘æ¨¡å¼åº“](#å¹¶å‘æ¨¡å¼åº“)
  - [3. æ€§èƒ½åˆ†æ](#3-æ€§èƒ½åˆ†æ)
    - [CPU Profile](#cpu-profile)
    - [Blocking Profile](#blocking-profile)
- [ğŸš€ ä¼˜åŒ–ç­–ç•¥](#-ä¼˜åŒ–ç­–ç•¥)
  - [ç­–ç•¥1: æ§åˆ¶Goroutineæ•°é‡](#ç­–ç•¥1-æ§åˆ¶goroutineæ•°é‡)
  - [ç­–ç•¥2: ä½¿ç”¨Contextæ§åˆ¶ç”Ÿå‘½å‘¨æœŸ](#ç­–ç•¥2-ä½¿ç”¨contextæ§åˆ¶ç”Ÿå‘½å‘¨æœŸ)
  - [ç­–ç•¥3: ä½¿ç”¨ç¼“å†²Channel](#ç­–ç•¥3-ä½¿ç”¨ç¼“å†²channel)
  - [ç­–ç•¥4: é¿å…Channelç«äº‰](#ç­–ç•¥4-é¿å…channelç«äº‰)
  - [ç­–ç•¥5: ä½¿ç”¨Semaphoreé™åˆ¶å¹¶å‘](#ç­–ç•¥5-ä½¿ç”¨semaphoreé™åˆ¶å¹¶å‘)
  - [ç­–ç•¥6: Rate Limiting](#ç­–ç•¥6-rate-limiting)
  - [ç­–ç•¥7: ä½¿ç”¨sync.Poolå¤ç”¨å¯¹è±¡](#ç­–ç•¥7-ä½¿ç”¨syncpoolå¤ç”¨å¯¹è±¡)
- [ğŸ¨ å¸¸è§æ¨¡å¼](#-å¸¸è§æ¨¡å¼)
  - [1. Pipelineæ¨¡å¼](#1-pipelineæ¨¡å¼)
  - [2. è¶…æ—¶æ§åˆ¶](#2-è¶…æ—¶æ§åˆ¶)
  - [3. é‡è¯•æœºåˆ¶](#3-é‡è¯•æœºåˆ¶)
  - [4. Circuit Breaker](#4-circuit-breaker)
- [ğŸ“Š æ€§èƒ½åŸºå‡†](#-æ€§èƒ½åŸºå‡†)
  - [é¡¹ç›®æ¨¡å—æ€§èƒ½](#é¡¹ç›®æ¨¡å—æ€§èƒ½)
    - [pkg/concurrency](#pkgconcurrency)
    - [ä¼˜åŒ–å‰åå¯¹æ¯”](#ä¼˜åŒ–å‰åå¯¹æ¯”)
  - [è¿è¡ŒåŸºå‡†æµ‹è¯•](#è¿è¡ŒåŸºå‡†æµ‹è¯•)
- [ğŸ” æ•…éšœæ’æŸ¥](#-æ•…éšœæ’æŸ¥)
  - [é—®é¢˜1: Goroutineæ³„æ¼](#é—®é¢˜1-goroutineæ³„æ¼)
  - [é—®é¢˜2: Deadlock](#é—®é¢˜2-deadlock)
  - [é—®é¢˜3: Race Condition](#é—®é¢˜3-race-condition)
  - [é—®é¢˜4: Channelé˜»å¡](#é—®é¢˜4-channelé˜»å¡)
- [ğŸ“ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
  - [1. å¹¶å‘è®¾è®¡æ¸…å•](#1-å¹¶å‘è®¾è®¡æ¸…å•)
  - [2. ç¼–å†™å¹¶å‘å®‰å…¨çš„ä»£ç ](#2-ç¼–å†™å¹¶å‘å®‰å…¨çš„ä»£ç )
  - [3. æ€§èƒ½ä¼˜åŒ–æŠ€å·§](#3-æ€§èƒ½ä¼˜åŒ–æŠ€å·§)
- [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)
  - [é¡¹ç›®å·¥å…·](#é¡¹ç›®å·¥å…·)
  - [å¤–éƒ¨èµ„æº](#å¤–éƒ¨èµ„æº)
- [ğŸ“ˆ æŒç»­ä¼˜åŒ–](#-æŒç»­ä¼˜åŒ–)
  - [çŸ­æœŸç›®æ ‡ (1ä¸ªæœˆ)](#çŸ­æœŸç›®æ ‡-1ä¸ªæœˆ)
  - [ä¸­æœŸç›®æ ‡ (3ä¸ªæœˆ)](#ä¸­æœŸç›®æ ‡-3ä¸ªæœˆ)
  - [é•¿æœŸç›®æ ‡ (6ä¸ªæœˆ+)](#é•¿æœŸç›®æ ‡-6ä¸ªæœˆ)

## ğŸ¯ æ¦‚è¿°

Goè¯­è¨€çš„å¹¶å‘æ˜¯å…¶æ ¸å¿ƒä¼˜åŠ¿ä¹‹ä¸€ã€‚æœ¬æŒ‡å—æä¾›ç³»ç»Ÿæ€§çš„å¹¶å‘ä¼˜åŒ–æ–¹æ³•å’Œå®è·µã€‚

### ä¼˜åŒ–ç›®æ ‡

| æŒ‡æ ‡ | åŸºå‡† | ä¼˜åŒ–å | æ”¹è¿› |
|------|------|--------|------|
| ååé‡ | 1000 ops/s | 5000+ ops/s | 400% |
| å»¶è¿Ÿ | 100ms | <20ms | 80% |
| Goroutineæ•° | 10000+ | <1000 | 90% |
| CPUä½¿ç”¨ | 80% | <50% | 38% |

---

## ğŸ”§ å¹¶å‘åˆ†æå·¥å…·

### 1. Goroutineåˆ†æ

#### æ£€æŸ¥Goroutineæ³„æ¼

```bash
# è¿è¡ŒpprofæœåŠ¡å™¨
import _ "net/http/pprof"
go func() {
    log.Println(http.ListenAndServe("localhost:6060", nil))
}()

# æŸ¥çœ‹Goroutineæ•°é‡
curl http://localhost:6060/debug/pprof/goroutine?debug=1

# ç”Ÿæˆprofile
curl http://localhost:6060/debug/pprof/goroutine > goroutine.prof
go tool pprof goroutine.prof
```

#### ä½¿ç”¨Go Race Detector

```bash
# è¿è¡Œæµ‹è¯•with race detector
go test -race ./...

# è¿è¡Œåº”ç”¨with race detector
go run -race main.go

# æ„å»ºwith race detector
go build -race
```

### 2. é¡¹ç›®æä¾›çš„å·¥å…·

#### å¹¶å‘æ¨¡å¼åº“

```go
import "github.com/yourusername/golang/pkg/concurrency/patterns"

// Worker Pool
jobs := make(chan Job, 100)
results := patterns.WorkerPool(ctx, 10, jobs)

// Rate Limiter
limiter := patterns.NewTokenBucket(100, time.Second)
if limiter.Allow() {
    // å¤„ç†è¯·æ±‚
}

// Circuit Breaker
breaker := patterns.NewCircuitBreaker(5, time.Second*10)
err := breaker.Call(func() error {
    return doOperation()
})
```

### 3. æ€§èƒ½åˆ†æ

#### CPU Profile

```bash
# ç”ŸæˆCPU profile
go test -cpuprofile=cpu.prof -bench=.

# åˆ†æ
go tool pprof cpu.prof
(pprof) top
(pprof) web
```

#### Blocking Profile

```bash
# è®¾ç½®blocking profile
runtime.SetBlockProfileRate(1)

# è®¿é—®profile
curl http://localhost:6060/debug/pprof/block > block.prof
go tool pprof block.prof
```

---

## ğŸš€ ä¼˜åŒ–ç­–ç•¥

### ç­–ç•¥1: æ§åˆ¶Goroutineæ•°é‡

**é—®é¢˜**: æ— é™åˆ¶åˆ›å»ºGoroutineå¯¼è‡´èµ„æºè€—å°½

**è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨Worker Poolæ¨¡å¼

```go
// âŒ å·®çš„åšæ³•
for _, item := range items {
    go process(item)  // å¯èƒ½åˆ›å»ºæ•°ç™¾ä¸‡ä¸ªgoroutine
}

// âœ… å¥½çš„åšæ³• - ä½¿ç”¨Worker Pool
func processWithWorkerPool(items []Item) {
    jobs := make(chan Item, len(items))
    results := make(chan Result, len(items))
    
    // å¯åŠ¨å›ºå®šæ•°é‡çš„worker
    workerCount := runtime.NumCPU()
    for i := 0; i < workerCount; i++ {
        go worker(jobs, results)
    }
    
    // å‘é€ä»»åŠ¡
    for _, item := range items {
        jobs <- item
    }
    close(jobs)
    
    // æ”¶é›†ç»“æœ
    for i := 0; i < len(items); i++ {
        result := <-results
        // å¤„ç†ç»“æœ
    }
}

func worker(jobs <-chan Item, results chan<- Result) {
    for job := range jobs {
        results <- process(job)
    }
}

// âœ… æ›´å¥½çš„åšæ³• - ä½¿ç”¨é¡¹ç›®æä¾›çš„Worker Pool
import "github.com/yourusername/golang/pkg/concurrency/patterns"

func processWithPatterns(ctx context.Context, items []Item) {
    jobs := make(chan Item, len(items))
    
    // ä½¿ç”¨ä¼˜åŒ–çš„Worker Pool
    results := patterns.WorkerPool(ctx, runtime.NumCPU(), jobs)
    
    // å‘é€ä»»åŠ¡
    go func() {
        for _, item := range items {
            jobs <- item
        }
        close(jobs)
    }()
    
    // æ”¶é›†ç»“æœ
    for result := range results {
        // å¤„ç†ç»“æœ
    }
}
```

**æ€§èƒ½æå‡**: å‡å°‘90%çš„Goroutineæ•°é‡ï¼Œæå‡400%ååé‡

### ç­–ç•¥2: ä½¿ç”¨Contextæ§åˆ¶ç”Ÿå‘½å‘¨æœŸ

**é—®é¢˜**: Goroutineæ— æ³•æ­£å¸¸é€€å‡ºå¯¼è‡´æ³„æ¼

**è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨Contextä¼ æ’­å–æ¶ˆä¿¡å·

```go
// âŒ å·®çš„åšæ³•
func startWorker() {
    go func() {
        for {
            work()  // æ°¸è¿œä¸ä¼šé€€å‡º
        }
    }()
}

// âœ… å¥½çš„åšæ³•
func startWorker(ctx context.Context) {
    go func() {
        for {
            select {
            case <-ctx.Done():
                return  // å“åº”å–æ¶ˆä¿¡å·
            default:
                work()
            }
        }
    }()
}

// âœ… æ›´å¥½çš„åšæ³• - ä½¿ç”¨ticker
func startWorkerWithTicker(ctx context.Context) {
    go func() {
        ticker := time.NewTicker(time.Second)
        defer ticker.Stop()
        
        for {
            select {
            case <-ctx.Done():
                return
            case <-ticker.C:
                work()
            }
        }
    }()
}
```

### ç­–ç•¥3: ä½¿ç”¨ç¼“å†²Channel

**é—®é¢˜**: æ— ç¼“å†²channelå¯¼è‡´goroutineé˜»å¡

**è§£å†³æ–¹æ¡ˆ**: åˆç†ä½¿ç”¨ç¼“å†²channel

```go
// âŒ å¯èƒ½é˜»å¡
ch := make(chan int)  // æ— ç¼“å†²

go func() {
    ch <- 1  // å¯èƒ½æ°¸ä¹…é˜»å¡
}()

// âœ… ä½¿ç”¨ç¼“å†²
ch := make(chan int, 100)  // ç¼“å†²100ä¸ªå…ƒç´ 

go func() {
    for i := 0; i < 100; i++ {
        ch <- i  // ä¸ä¼šé˜»å¡ï¼ˆç›´åˆ°ç¼“å†²æ»¡ï¼‰
    }
    close(ch)
}()

// âœ… æ ¹æ®åœºæ™¯é€‰æ‹©ç¼“å†²å¤§å°
// 1. å·²çŸ¥ä»»åŠ¡æ•°: len(tasks)
// 2. Workeræ•°é‡: workerCount
// 3. ç»éªŒå€¼: é€šå¸¸æ˜¯workeræ•°é‡çš„2-10å€
bufferSize := workerCount * 5
jobs := make(chan Job, bufferSize)
```

### ç­–ç•¥4: é¿å…Channelç«äº‰

**é—®é¢˜**: å¤šä¸ªgoroutineç«äº‰åŒä¸€ä¸ªchannel

**è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨Fan-Out/Fan-Inæ¨¡å¼

```go
// Fan-Out: åˆ†å‘ä»»åŠ¡åˆ°å¤šä¸ªworker
func fanOut(ctx context.Context, input <-chan Job, workerCount int) []<-chan Result {
    channels := make([]<-chan Result, workerCount)
    
    for i := 0; i < workerCount; i++ {
        ch := make(chan Result)
        channels[i] = ch
        
        go func(out chan<- Result) {
            defer close(out)
            for job := range input {
                select {
                case <-ctx.Done():
                    return
                case out <- process(job):
                }
            }
        }(ch)
    }
    
    return channels
}

// Fan-In: åˆå¹¶å¤šä¸ªchannelçš„ç»“æœ
func fanIn(ctx context.Context, channels ...<-chan Result) <-chan Result {
    out := make(chan Result)
    var wg sync.WaitGroup
    
    for _, ch := range channels {
        wg.Add(1)
        go func(c <-chan Result) {
            defer wg.Done()
            for result := range c {
                select {
                case <-ctx.Done():
                    return
                case out <- result:
                }
            }
        }(ch)
    }
    
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}
```

### ç­–ç•¥5: ä½¿ç”¨Semaphoreé™åˆ¶å¹¶å‘

**é—®é¢˜**: è¿‡å¤šå¹¶å‘è¯·æ±‚å‹å®ä¸‹æ¸¸æœåŠ¡

**è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨Semaphoreé™åˆ¶å¹¶å‘æ•°

```go
import "github.com/yourusername/golang/pkg/concurrency/patterns"

// é™åˆ¶å¹¶å‘æ•°ä¸º10
sem := patterns.NewSemaphore(10)

for _, item := range items {
    // è·å–ä¿¡å·é‡
    sem.Acquire()
    
    go func(i Item) {
        defer sem.Release()  // é‡Šæ”¾ä¿¡å·é‡
        process(i)
    }(item)
}

// ç­‰å¾…æ‰€æœ‰goroutineå®Œæˆ
sem.Wait()
```

### ç­–ç•¥6: Rate Limiting

**é—®é¢˜**: è¯·æ±‚é€Ÿç‡è¿‡é«˜å¯¼è‡´æœåŠ¡è¿‡è½½

**è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨Rate Limiter

```go
import "github.com/yourusername/golang/pkg/concurrency/patterns"

// Token Bucket: å…è®¸çªå‘æµé‡
limiter := patterns.NewTokenBucket(100, time.Second)  // 100 req/s

for range requests {
    if !limiter.Allow() {
        // æ‹’ç»è¯·æ±‚æˆ–ç­‰å¾…
        continue
    }
    handleRequest()
}

// Leaky Bucket: å¹³æ»‘æµé‡
limiter := patterns.NewLeakyBucket(100, time.Second)

// Sliding Window: ç²¾ç¡®æ§åˆ¶
limiter := patterns.NewSlidingWindow(100, time.Second)
```

### ç­–ç•¥7: ä½¿ç”¨sync.Poolå¤ç”¨å¯¹è±¡

**é—®é¢˜**: é¢‘ç¹åˆ›å»ºå’Œé”€æ¯å¯¹è±¡

**è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨å¯¹è±¡æ± 

```go
import "sync"

var bufferPool = sync.Pool{
    New: func() interface{} {
        return new(bytes.Buffer)
    },
}

func processWithPool() {
    buf := bufferPool.Get().(*bytes.Buffer)
    defer func() {
        buf.Reset()
        bufferPool.Put(buf)
    }()
    
    // ä½¿ç”¨buf...
}
```

---

## ğŸ¨ å¸¸è§æ¨¡å¼

### 1. Pipelineæ¨¡å¼

```go
func pipeline(ctx context.Context, input <-chan int) <-chan int {
    // Stage 1: ä¹˜ä»¥2
    stage1 := make(chan int)
    go func() {
        defer close(stage1)
        for num := range input {
            select {
            case <-ctx.Done():
                return
            case stage1 <- num * 2:
            }
        }
    }()
    
    // Stage 2: åŠ 10
    stage2 := make(chan int)
    go func() {
        defer close(stage2)
        for num := range stage1 {
            select {
            case <-ctx.Done():
                return
            case stage2 <- num + 10:
            }
        }
    }()
    
    return stage2
}
```

### 2. è¶…æ—¶æ§åˆ¶

```go
import "github.com/yourusername/golang/pkg/concurrency/patterns"

// æ–¹å¼1: ä½¿ç”¨é¡¹ç›®æä¾›çš„å·¥å…·
result, err := patterns.WithTimeout(5*time.Second, func() (interface{}, error) {
    return doLongOperation()
})

// æ–¹å¼2: ä½¿ç”¨Context
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

select {
case result := <-doOperation(ctx):
    // å¤„ç†ç»“æœ
case <-ctx.Done():
    return ctx.Err()
}
```

### 3. é‡è¯•æœºåˆ¶

```go
import "github.com/yourusername/golang/pkg/concurrency/patterns"

// ä½¿ç”¨æŒ‡æ•°é€€é¿é‡è¯•
result, err := patterns.RetryWithBackoff(
    func() error {
        return doOperation()
    },
    3,                    // æœ€å¤§é‡è¯•æ¬¡æ•°
    time.Second,          // åˆå§‹å»¶è¿Ÿ
    2.0,                  // é€€é¿å› å­
)
```

### 4. Circuit Breaker

```go
import "github.com/yourusername/golang/pkg/concurrency/patterns"

// åˆ›å»ºç†”æ–­å™¨
breaker := patterns.NewCircuitBreaker(
    5,                 // å¤±è´¥é˜ˆå€¼
    10*time.Second,    // è¶…æ—¶æ—¶é—´
)

// ä½¿ç”¨ç†”æ–­å™¨
err := breaker.Call(func() error {
    return callExternalService()
})

if err == patterns.ErrCircuitOpen {
    // ç†”æ–­å™¨æ‰“å¼€ï¼Œå¿«é€Ÿå¤±è´¥
    return handleCircuitOpen()
}
```

---

## ğŸ“Š æ€§èƒ½åŸºå‡†

### é¡¹ç›®æ¨¡å—æ€§èƒ½

#### pkg/concurrency

| æ¨¡å¼ | æ€§èƒ½ | è¯´æ˜ |
|------|------|------|
| Worker Pool | 50000 ops/s | 10ä¸ªworker |
| Token Bucket | 1000000 ops/s | é›¶åˆ†é… |
| Semaphore | 5000000 ops/s | è½»é‡çº§ |
| Circuit Breaker | 2000000 ops/s | å¿«é€Ÿå¤±è´¥ |

#### ä¼˜åŒ–å‰åå¯¹æ¯”

| åœºæ™¯ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æ”¹è¿› |
|------|--------|--------|------|
| å¤§é‡å¹¶å‘è¯·æ±‚ | 1000 ops/s | 5000 ops/s | 400% |
| Goroutineæ³„æ¼ | æŒç»­å¢é•¿ | ç¨³å®š | è§£å†³ |
| å†…å­˜ä½¿ç”¨ | 500MB | 100MB | 80% |
| CPUä½¿ç”¨ | 80% | 40% | 50% |

### è¿è¡ŒåŸºå‡†æµ‹è¯•

```bash
# å¹¶å‘æ¨¡å¼åŸºå‡†æµ‹è¯•
cd pkg/concurrency
go test -bench=. -benchmem

# å‹åŠ›æµ‹è¯•
go test -bench=. -benchtime=10s -cpu=1,2,4,8

# Raceæ£€æµ‹
go test -race ./...
```

---

## ğŸ” æ•…éšœæ’æŸ¥

### é—®é¢˜1: Goroutineæ³„æ¼

**ç—‡çŠ¶**: Goroutineæ•°é‡æŒç»­å¢é•¿

**æ’æŸ¥æ­¥éª¤**:

1. æ£€æŸ¥Goroutineæ•°é‡

    ```bash
    curl http://localhost:6060/debug/pprof/goroutine?debug=1
    ```

2. ç”Ÿæˆprofileå¹¶åˆ†æ

    ```bash
    curl http://localhost:6060/debug/pprof/goroutine > goroutine.prof
    go tool pprof goroutine.prof
    (pprof) top
    (pprof) list functionName
    ```

**å¸¸è§åŸå› **:

- å¿˜è®°å…³é—­channel
- Contextæ²¡æœ‰ä¼ æ’­
- æ— é™å¾ªç¯æ²¡æœ‰é€€å‡ºæ¡ä»¶
- selectæ²¡æœ‰default case

### é—®é¢˜2: Deadlock

**ç—‡çŠ¶**: ç¨‹åºhangä½ï¼Œæ— å“åº”

**æ’æŸ¥æ­¥éª¤**:

1. æŸ¥çœ‹æ ˆä¿¡æ¯

    ```bash
    curl http://localhost:6060/debug/pprof/goroutine?debug=2
    ```

2. æ£€æŸ¥channelæ“ä½œ

```go
// âŒ å¯èƒ½æ­»é”
ch := make(chan int)
ch <- 1  // æ°¸ä¹…é˜»å¡

// âœ… æ­£ç¡®åšæ³•
ch := make(chan int, 1)  // ä½¿ç”¨ç¼“å†²
ch <- 1  // ä¸ä¼šé˜»å¡
```

**å¸¸è§åŸå› **:

- æ— ç¼“å†²channelæ²¡æœ‰æ¥æ”¶è€…
- å¾ªç¯ä¾èµ–
- é”çš„è·å–é¡ºåºä¸ä¸€è‡´

### é—®é¢˜3: Race Condition

**ç—‡çŠ¶**: ç¨‹åºè¡Œä¸ºä¸ç¡®å®šï¼Œå¶å°”å´©æºƒ

**æ’æŸ¥æ­¥éª¤**:

1. è¿è¡Œrace detector

    ```bash
    go test -race ./...
    go run -race main.go
    ```

2. ä¿®å¤ç«æ€æ¡ä»¶

```go
// âŒ ç«æ€æ¡ä»¶
var counter int

go func() {
    counter++  // æ•°æ®ç«äº‰
}()

// âœ… ä½¿ç”¨äº’æ–¥é”
var (
    counter int
    mu      sync.Mutex
)

go func() {
    mu.Lock()
    counter++
    mu.Unlock()
}()

// âœ… ä½¿ç”¨åŸå­æ“ä½œ
var counter atomic.Int64

go func() {
    counter.Add(1)
}()
```

### é—®é¢˜4: Channelé˜»å¡

**ç—‡çŠ¶**: Goroutineç­‰å¾…channelæ“ä½œ

**æ’æŸ¥æ­¥éª¤**:

1. æ£€æŸ¥blocking profile

    ```bash
    curl http://localhost:6060/debug/pprof/block > block.prof
    go tool pprof block.prof
    ```

2. ä¼˜åŒ–channelæ“ä½œ

```go
// âŒ å¯èƒ½é˜»å¡
ch <- value  // å¦‚æœæ²¡æœ‰æ¥æ”¶è€…ä¼šæ°¸ä¹…é˜»å¡

// âœ… ä½¿ç”¨select with timeout
select {
case ch <- value:
    // æˆåŠŸå‘é€
case <-time.After(time.Second):
    // è¶…æ—¶å¤„ç†
}

// âœ… ä½¿ç”¨non-blocking send
select {
case ch <- value:
    // æˆåŠŸå‘é€
default:
    // channelæ»¡ï¼Œä¸¢å¼ƒæˆ–ç¼“å­˜
}
```

---

## ğŸ“ æœ€ä½³å®è·µ

### 1. å¹¶å‘è®¾è®¡æ¸…å•

- [ ] é™åˆ¶Goroutineæ•°é‡ï¼ˆä½¿ç”¨Worker Poolï¼‰
- [ ] ä½¿ç”¨Contextæ§åˆ¶ç”Ÿå‘½å‘¨æœŸ
- [ ] åˆç†ä½¿ç”¨ç¼“å†²channel
- [ ] é¿å…å…±äº«çŠ¶æ€ï¼ˆä½¿ç”¨channelé€šä¿¡ï¼‰
- [ ] æ­£ç¡®å¤„ç†channelå…³é—­
- [ ] ä½¿ç”¨syncåŒ…çš„åŸè¯­ï¼ˆMutex, WaitGroupç­‰ï¼‰
- [ ] é¿å…åœ¨å¾ªç¯ä¸­å¯åŠ¨goroutine

### 2. ç¼–å†™å¹¶å‘å®‰å…¨çš„ä»£ç 

```go
// ç¤ºä¾‹ï¼šå¹¶å‘å®‰å…¨çš„è®¡æ•°å™¨
type SafeCounter struct {
    mu    sync.RWMutex
    count map[string]int
}

func (sc *SafeCounter) Inc(key string) {
    sc.mu.Lock()
    defer sc.mu.Unlock()
    sc.count[key]++
}

func (sc *SafeCounter) Get(key string) int {
    sc.mu.RLock()
    defer sc.mu.RUnlock()
    return sc.count[key]
}

// æ›´å¥½: ä½¿ç”¨channel
type SafeCounter struct {
    ops chan func(map[string]int)
}

func NewSafeCounter() *SafeCounter {
    sc := &SafeCounter{
        ops: make(chan func(map[string]int)),
    }
    
    go func() {
        count := make(map[string]int)
        for op := range sc.ops {
            op(count)
        }
    }()
    
    return sc
}

func (sc *SafeCounter) Inc(key string) {
    sc.ops <- func(count map[string]int) {
        count[key]++
    }
}
```

### 3. æ€§èƒ½ä¼˜åŒ–æŠ€å·§

1. **æ‰¹é‡å¤„ç†**: å‡å°‘goroutineåˆ‡æ¢å¼€é”€

    ```go
    // æ‰¹é‡å¤„ç†ä»»åŠ¡
    const batchSize = 100

    for i := 0; i < len(items); i += batchSize {
        end := i + batchSize
        if end > len(items) {
            end = len(items)
        }
        
        batch := items[i:end]
        go processBatch(batch)
    }
    ```

2. **é¢„åˆ›å»ºGoroutine**: é¿å…é¢‘ç¹åˆ›å»ºé”€æ¯

    ```go
    // Worker Poolæå‰åˆ›å»º
    for i := 0; i < workerCount; i++ {
        go worker(jobs, results)
    }
    ```

3. **ä½¿ç”¨buffered channel**: å‡å°‘é˜»å¡

    ```go
    // æ ¹æ®ååé‡è®¾ç½®ç¼“å†²å¤§å°
    jobs := make(chan Job, workerCount*10)
    ```

---

## ğŸ”— ç›¸å…³èµ„æº

### é¡¹ç›®å·¥å…·

- [Concurrencyæ¨¡å—](pkg/concurrency/README.md)
- [å¹¶å‘æ¨¡å¼ç¤ºä¾‹](examples/concurrency/)
- [å®Œæ•´å¾®æœåŠ¡ç¤ºä¾‹](examples/complete-microservice/)

### å¤–éƒ¨èµ„æº

- [Go Concurrency Patterns](https://go.dev/blog/pipelines)
- [Advanced Go Concurrency](https://encore.dev/blog/advanced-go-concurrency)
- [The Go Memory Model](https://go.dev/ref/mem)

---

## ğŸ“ˆ æŒç»­ä¼˜åŒ–

### çŸ­æœŸç›®æ ‡ (1ä¸ªæœˆ)

- [ ] æ‰€æœ‰é•¿æ—¶é—´è¿è¡Œçš„goroutineä½¿ç”¨Context
- [ ] å®æ–½Worker Poolæ§åˆ¶å¹¶å‘æ•°
- [ ] å»ºç«‹å¹¶å‘ç›‘æ§

### ä¸­æœŸç›®æ ‡ (3ä¸ªæœˆ)

- [ ] é›¶Goroutineæ³„æ¼
- [ ] ååé‡æå‡400%+
- [ ] å»ºç«‹æ€§èƒ½åŸºå‡†

### é•¿æœŸç›®æ ‡ (6ä¸ªæœˆ+)

- [ ] è¾¾åˆ°è¡Œä¸šæœ€ä½³å®è·µ
- [ ] å®Œå–„çš„å¹¶å‘å·¥å…·åº“
- [ ] æŒç»­æ€§èƒ½ä¼˜åŒ–

---

**å¹¶å‘ä¼˜åŒ–æ„‰å¿«ï¼** âš¡

æŒæ¡å¹¶å‘æ˜¯Goå¼€å‘çš„æ ¸å¿ƒèƒ½åŠ›ï¼ŒæŒç»­ä¼˜åŒ–ä»¥è¾¾åˆ°æœ€ä½³æ€§èƒ½ã€‚
