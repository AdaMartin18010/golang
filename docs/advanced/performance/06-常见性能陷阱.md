# 常见性能陷阱

> **简介**: Go性能陷阱识别与规避，掌握切片扩容、Goroutine泄漏等常见问题的解决方案
> **版本**: Go 1.23+  
> **难度**: ⭐⭐⭐  
> **标签**: #性能优化 #陷阱 #最佳实践 #问题排查

<!-- TOC START -->
- [常见性能陷阱](#常见性能陷阱)
  - [📚 **理论分析**](#-理论分析)
  - [💻 **典型陷阱与代码示例**](#-典型陷阱与代码示例)
    - [**切片扩容导致性能抖动**](#切片扩容导致性能抖动)
    - [**map并发写导致崩溃**](#map并发写导致崩溃)
    - [**Goroutine泄漏**](#goroutine泄漏)
  - [🛠️ **分析与排查方法**](#️-分析与排查方法)
  - [🎯 **最佳实践**](#-最佳实践)
  - [🔍 **常见问题**](#-常见问题)
  - [📚 **扩展阅读**](#-扩展阅读)
<!-- TOC END -->

## 📚 **理论分析**

- 性能陷阱常因误用语言特性、库、并发模型、I/O等导致。
- 典型陷阱：切片扩容、map并发写、Goroutine泄漏、过度GC、锁粒度过大、I/O阻塞等。

## 💻 **典型陷阱与代码示例**

### **切片扩容导致性能抖动**

```go
s := []int{}
for i := 0; i < 1e6; i++ {
    s = append(s, i) // 未预分配容量，频繁扩容
}
```

### **map并发写导致崩溃**

```go
m := make(map[int]int)
go func() { m[1] = 1 }() // 并发写，未加锁，panic
```

### **Goroutine泄漏**

```go
func leak() {
    ch := make(chan int)
    go func() { ch <- 1 }() // 未消费，Goroutine阻塞泄漏
}
```

## 🛠️ **分析与排查方法**

- 使用pprof、race detector、go tool trace定位问题
- 代码审查，关注资源释放与并发安全

## 🎯 **最佳实践**

- 预分配切片容量
- map并发写用sync.Map或加锁
- 控制Goroutine生命周期，及时回收
- 监控GC与内存分配
- 定期性能回归测试

## 🔍 **常见问题**

- Q: map并发写如何安全？
  A: 使用sync.Map或加锁
- Q: 如何避免Goroutine泄漏？
  A: 保证通道有消费方，及时关闭

## 📚 **扩展阅读**

- [Go性能陷阱与优化](https://geektutu.com/post/hpg-golang-trap.html)
- [Go官方FAQ](https://golang.org/doc/faq)

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025年10月20日  
**文档状态**: 完成  
**适用版本**: Go 1.25.3+
