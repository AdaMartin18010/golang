# 常见性能陷阱

**版本**: v1.0
**更新日期**: 2025-10-29
**适用于**: Go 1.25.3

---
## 📋 目录

- [常见性能陷阱](#常见性能陷阱)
  - [概述](#概述)
  - [1. Goroutine泄漏陷阱](#1-goroutine泄漏陷阱)
  - [2. 内存泄漏陷阱](#2-内存泄漏陷阱)
  - [3. 过度使用反射](#3-过度使用反射)
  - [4. 锁使用不当](#4-锁使用不当)
  - [5. 字符串拼接陷阱](#5-字符串拼接陷阱)
  - [6. 切片预分配不足](#6-切片预分配不足)
  - [7. defer性能开销](#7-defer性能开销)
  - [8. map并发读写](#8-map并发读写)
  - [最佳实践总结](#最佳实践总结)
  - [诊断工具](#诊断工具)
- [CPU profile](#cpu-profile)
- [内存profile](#内存profile)
- [Goroutine分析](#goroutine分析)
  - [参考资料](#参考资料)

---

## 概述

在Go开发中，即使是经验丰富的开发者也可能陷入一些常见的性能陷阱。这些陷阱可能导致内存泄漏、CPU过度使用、Goroutine泄漏等问题。本文详细介绍8大常见性能陷阱及其解决方案。

---

## 1. Goroutine泄漏陷阱

### 问题描述

Goroutine泄漏是最常见且危险的性能问题之一。泄漏的Goroutine会持续消耗内存，最终导致OOM。

### 常见原因

**原因1：Channel发送者阻塞**

```go
// ❌ 错误：接收者退出，发送者永久阻塞
func badPattern() {
    ch := make(Channel int)
    go func() {
        ch <- 1 // 这个goroutine永远阻塞
    }()
    // 主goroutine不读取channel就退出
}
```

**原因2：无超时的select**

```go
// ❌ 错误：select没有超时，永久等待
func badSelect() {
    ch := make(Channel int)
    go func() {
        select {
        case <-ch: // 永远等待
        }
    }()
}
```

**原因3：循环中启动但不退出**

```go
// ❌ 错误：goroutine永不退出
func badLoop() {
    for i := 0; i < 100; i++ {
        go func() {
            for {
                time.Sleep(time.Second)
                // 没有退出机制
            }
        }()
    }
}
```

### 正确做法

**使用context控制生命周期**

```go
// ✅ 正确：使用context
func goodPattern(ctx Context.Context) {
    ch := make(Channel int)

    go func() {
        select {
        case ch <- 1:
        case <-ctx.Done():
            return // 正确退出
        case <-time.After(5 * time.Second):
            return // 超时退出
        }
    }()
}
```

**使用done Channel**

```go
// ✅ 正确：使用done Channel
func goodWithDone() {
    ch := make(Channel int)
    done := make(Channel struct{})

    go func() {
        defer close(done)
        for {
            select {
            case data := <-ch:
                process(data)
            case <-done:
                return
            }
        }
    }()

    // 清理时关闭done
    close(done)
}
```

**使用WaitGroup追踪**

```go
// ✅ 正确：使用WaitGroup
func goodWithWaitGroup() {
    var wg sync.WaitGroup
    ctx, cancel := Context.WithCancel(Context.Background())
    defer cancel()

    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            worker(ctx, id)
        }(i)
    }

    wg.Wait() // 等待所有goroutine完成
}
```

### 检测方法

```go
// 监控Goroutine数量
func monitorGoroutines() {
    ticker := time.NewTicker(1 * time.Minute)
    for range ticker.C {
        count := runtime.NumGoroutine()
        if count > 10000 {
            log.Printf("WARNING: Too many goroutines: %d", count)

            // 获取goroutine stack
            buf := make([]byte, 1<<20)
            stackLen := runtime.Stack(buf, true)
            log.Printf("Stacks:\n%s", buf[:stackLen])
        }
    }
}
```

---

## 2. 内存泄漏陷阱

### 切片底层数组未释放

```go
// ❌ 错误：返回小切片但保留大数组
func badSlice() []byte {
    data := make([]byte, 1024*1024) // 1MB
    return data[:100] // 只返回100字节，但1MB无法释放
}

// ✅ 正确：复制需要的数据
func goodSlice() []byte {
    data := make([]byte, 1024*1024)
    result := make([]byte, 100)
    copy(result, data[:100])
    return result // 1MB可以被GC
}
```

### Map只增不减

```go
// ❌ 错误：map永远增长
var cache = make(map[string][]byte)

func badCache(key string, value []byte) {
    cache[key] = value // 永远不删除
}

// ✅ 正确：使用LRU缓存
type LRUCache struct {
    capacity int
    cache    map[string]*list.Element
    list     *list.List
}

func (c *LRUCache) Set(key string, value []byte) {
    if c.list.Len() >= c.capacity {
        oldest := c.list.Back()
        c.list.Remove(oldest)
        delete(c.cache, oldest.Value.(string))
    }
    elem := c.list.PushFront(key)
    c.cache[key] = elem
}
```

### 定时器未停止

```go
// ❌ 错误：ticker未停止
func badTimer() {
    ticker := time.NewTicker(time.Second)
    go func() {
        for range ticker.C {
            // 处理
        }
    }()
}

// ✅ 正确：停止定时器
func goodTimer(ctx Context.Context) {
    ticker := time.NewTicker(time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            // 处理
        case <-ctx.Done():
            return
        }
    }
}
```

---

## 3. 过度使用反射

### 性能影响

- 反射比直接调用慢10-100倍
- 增加GC压力
- 无法内联优化

### 示例对比

```go
// ❌ 错误：频繁使用反射
func badReflect(data interface{}) {
    v := reflect.ValueOf(data)
    for i := 0; i < 1000000; i++ {
        _ = v.Kind() // 每次都反射
    }
}

// ✅ 正确：类型断言
func goodTypeAssert(data interface{}) {
    switch v := data.(type) {
    case int:
        // 处理int
    case string:
        // 处理string
    }
}

// ✅ 更好：使用泛型（Go 1.18+）
func goodGeneric[T any](data T) {
    // 类型安全且高性能
}
```

---

## 4. 锁使用不当

### 过度使用锁

```go
// ❌ 错误：全局锁保护所有操作
type BadCache struct {
    mu    sync.Mutex
    cache map[string]string
}

func (c *BadCache) Get(key string) string {
    c.mu.Lock()
    defer c.mu.Unlock()
    time.Sleep(100 * time.Millisecond) // 慢操作也持锁
    return c.cache[key]
}

// ✅ 正确：使用读写锁
type GoodCache struct {
    mu    sync.RWMutex
    cache map[string]string
}

func (c *GoodCache) Get(key string) string {
    c.mu.RLock() // 读锁，允许并发读
    defer c.mu.RUnlock()
    return c.cache[key]
}

// ✅ 更好：使用sync.Map
var cache sync.Map

func betterGet(key string) (string, bool) {
    val, ok := cache.Load(key)
    if !ok {
        return "", false
    }
    return val.(string), true
}
```

### 分片锁优化

```go
// ✅ 最佳：分片锁减少竞争
type ShardedCache struct {
    shards [256]*CacheShard
}

type CacheShard struct {
    mu    sync.RWMutex
    cache map[string]string
}

func (c *ShardedCache) Get(key string) string {
    shard := c.getShard(key)
    shard.mu.RLock()
    defer shard.mu.RUnlock()
    return shard.cache[key]
}
```

---

## 5. 字符串拼接陷阱

```go
// ❌ 错误：+=拼接（O(n²)复杂度）
func badConcat(n int) string {
    var s string
    for i := 0; i < n; i++ {
        s += "hello"
    }
    return s
}

// ✅ 正确：使用strings.Builder
func goodConcat(n int) string {
    var builder strings.Builder
    builder.Grow(n * 5) // 预分配
    for i := 0; i < n; i++ {
        builder.WriteString("hello")
    }
    return builder.String()
}

// 性能对比（n=10000）：
// badConcat: ~500ms, 250MB分配
// goodConcat: ~1ms, 50KB分配
```

---

## 6. 切片预分配不足

```go
// ❌ 错误：未预分配
func badSlice() []int {
    var s []int
    for i := 0; i < 100000; i++ {
        s = append(s, i) // 多次扩容和复制
    }
    return s
}

// ✅ 正确：预分配容量
func goodSlice() []int {
    s := make([]int, 0, 100000)
    for i := 0; i < 100000; i++ {
        s = append(s, i)
    }
    return s
}
```

---

## 7. defer性能开销

```go
// ❌ 错误：在热路径中使用defer
func badDefer() {
    for i := 0; i < 100000; i++ {
        func() {
            defer mu.Unlock()
            mu.Lock()
            // 操作
        }()
    }
}

// ✅ 正确：手动解锁
func goodDefer() {
    for i := 0; i < 100000; i++ {
        mu.Lock()
        // 操作
        mu.Unlock()
    }
}
```

---

## 8. map并发读写

```go
// ❌ 错误：并发读写map会panic
var m = make(map[string]int)

func badMap() {
    go func() {
        for { m["key"] = 1 }
    }()
    go func() {
        for { _ = m["key"] }
    }()
}

// ✅ 正确：使用锁或sync.Map
type SafeMap struct {
    mu sync.RWMutex
    m  map[string]int
}

func (s *SafeMap) Set(key string, val int) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.m[key] = val
}
```

---

## 最佳实践总结

| 陷阱 | 避坑方法 | 性能提升 |
|------|----------|----------|
| Goroutine泄漏 | Context、done Channel | 防止内存泄漏 |
| 内存泄漏 | 及时释放、LRU | 降低内存50%+ |
| 过度反射 | 类型断言、泛型 | 提升10-100倍 |
| 过度使用锁 | RWMutex、sync.Map、分片 | 提升并发10倍+ |
| 字符串拼接 | strings.Builder | 提升100倍+ |
| 切片扩容 | 预分配容量 | 提升5-10倍 |
| defer开销 | 热路径避免defer | 提升5-10% |
| map并发 | sync.Map、加锁 | 防止panic |

---

## 诊断工具

### pprof分析

```bash
# CPU profile
go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30

# 内存profile
go tool pprof http://localhost:6060/debug/pprof/heap

# Goroutine分析
go tool pprof http://localhost:6060/debug/pprof/Goroutine
```

### race detector

```bash
go test -race ./...
go build -race
```

### trace工具

```bash
go test -trace=trace.out
go tool trace trace.out
```

---

## 参考资料
