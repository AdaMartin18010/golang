# Goå¹¶å‘ä¼˜åŒ–

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.23+

---

## ğŸ“‹ ç›®å½•

- [Goå¹¶å‘ä¼˜åŒ–](#goå¹¶å‘ä¼˜åŒ–)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. ç†è®ºåŸºç¡€](#1-ç†è®ºåŸºç¡€)
    - [Goå¹¶å‘æ¨¡å‹ï¼šG-P-Mè°ƒåº¦å™¨](#goå¹¶å‘æ¨¡å‹g-p-mè°ƒåº¦å™¨)
    - [æ€§èƒ½ä¼˜åŒ–å…³æ³¨ç‚¹](#æ€§èƒ½ä¼˜åŒ–å…³æ³¨ç‚¹)
  - [2. è°ƒåº¦å™¨ä¸GOMAXPROCS](#2-è°ƒåº¦å™¨ä¸gomaxprocs)
    - [GOMAXPROCSè¯¦è§£](#gomaxprocsè¯¦è§£)
    - [é€‚ç”¨åœºæ™¯ä¸æœ€ä½³å®è·µ](#é€‚ç”¨åœºæ™¯ä¸æœ€ä½³å®è·µ)
    - [æ€§èƒ½ç›‘æ§](#æ€§èƒ½ç›‘æ§)
  - [3. é”ä¼˜åŒ–ä¸æ— é”å¹¶å‘](#3-é”ä¼˜åŒ–ä¸æ— é”å¹¶å‘)
    - [é”ä¼˜åŒ–ç­–ç•¥](#é”ä¼˜åŒ–ç­–ç•¥)
    - [æ— é”å¹¶å‘ï¼ˆAtomicæ“ä½œï¼‰](#æ— é”å¹¶å‘atomicæ“ä½œ)
  - [4. Goroutineæ³„æ¼ä¸èµ„æºå›æ”¶](#4-goroutineæ³„æ¼ä¸èµ„æºå›æ”¶)
    - [å¸¸è§æ³„æ¼åœºæ™¯](#å¸¸è§æ³„æ¼åœºæ™¯)
    - [ç”Ÿå‘½å‘¨æœŸç®¡ç†æœ€ä½³å®è·µ](#ç”Ÿå‘½å‘¨æœŸç®¡ç†æœ€ä½³å®è·µ)
    - [æ³„æ¼æ£€æµ‹](#æ³„æ¼æ£€æµ‹)
  - [5. å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ](#5-å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ)
    - [å¸¸è§é™·é˜±](#å¸¸è§é™·é˜±)
    - [æœ€ä½³å®è·µæ€»ç»“](#æœ€ä½³å®è·µæ€»ç»“)
  - [6. å‚è€ƒæ–‡çŒ®](#6-å‚è€ƒæ–‡çŒ®)

## 1. ç†è®ºåŸºç¡€

### Goå¹¶å‘æ¨¡å‹ï¼šG-P-Mè°ƒåº¦å™¨

Goçš„å¹¶å‘æ€§èƒ½ä¼˜åŠ¿æ¥è‡ªäºå…¶ç‹¬ç‰¹çš„è°ƒåº¦å™¨è®¾è®¡ï¼š

- **G (Goroutine)**ï¼šè½»é‡çº§ç”¨æˆ·æ€çº¿ç¨‹ï¼Œæ ˆåˆå§‹2KBï¼Œå¯åŠ¨æ€æ‰©ç¼©å®¹
- **P (Processor)**ï¼šé€»è¾‘å¤„ç†å™¨ï¼Œç®¡ç†æœ¬åœ°Gé˜Ÿåˆ—ï¼Œæ•°é‡ç”±GOMAXPROCSæ§åˆ¶
- **M (Machine)**ï¼šOSçº¿ç¨‹ï¼Œå®é™…æ‰§è¡Œå•å…ƒ

**å…³é”®ä¼˜åŠ¿ï¼š**

- **M:Nè°ƒåº¦**ï¼šå¤šä¸ªGoroutineå¤ç”¨å°‘é‡OSçº¿ç¨‹ï¼Œé™ä½ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€
- **Work Stealing**ï¼šPä¹‹é—´å¯çªƒå–ä»»åŠ¡ï¼Œæå‡è´Ÿè½½å‡è¡¡
- **åä½œå¼æŠ¢å **ï¼šGo 1.14+æ”¯æŒå¼‚æ­¥æŠ¢å ï¼Œé¿å…é•¿æ—¶é—´è¿è¡Œé˜»å¡è°ƒåº¦

### æ€§èƒ½ä¼˜åŒ–å…³æ³¨ç‚¹

1. **è°ƒåº¦å¼€é”€**ï¼šGoroutineåˆ›å»º/é”€æ¯ã€ä¸Šä¸‹æ–‡åˆ‡æ¢ã€ä»»åŠ¡çªƒå–
2. **é”ç«äº‰**ï¼šå¤šGoroutineç«äº‰å…±äº«èµ„æºå¯¼è‡´çš„æ€§èƒ½ä¸‹é™
3. **èµ„æºåˆ©ç”¨ç‡**ï¼šCPUã€å†…å­˜ã€ç½‘ç»œå¸¦å®½çš„åˆ©ç”¨æ•ˆç‡
4. **Goroutineæ³„æ¼**ï¼šæœªæ­£ç¡®å›æ”¶çš„Goroutineå¯¼è‡´å†…å­˜æ³„æ¼

## 2. è°ƒåº¦å™¨ä¸GOMAXPROCS

### GOMAXPROCSè¯¦è§£

`GOMAXPROCS`æ§åˆ¶å¯åŒæ—¶æ‰§è¡Œçš„Pï¼ˆé€»è¾‘å¤„ç†å™¨ï¼‰æ•°é‡ï¼Œç›´æ¥å½±å“å¹¶è¡Œåº¦ï¼š

```go
import "runtime"

// æŸ¥çœ‹å½“å‰GOMAXPROCS
current := runtime.GOMAXPROCS(0)
fmt.Printf("Current GOMAXPROCS: %d\n", current)

// è®¾ç½®ä¸ºCPUæ ¸æ•°çš„80%ï¼ˆé€‚åˆCPUå¯†é›†å‹ï¼‰
numCPU := runtime.NumCPU()
runtime.GOMAXPROCS(int(float64(numCPU) * 0.8))

// ä¹Ÿå¯ä»¥é€šè¿‡ç¯å¢ƒå˜é‡è®¾ç½®
// export GOMAXPROCS=4
```

### é€‚ç”¨åœºæ™¯ä¸æœ€ä½³å®è·µ

**CPUå¯†é›†å‹ä»»åŠ¡ï¼š**

```go
// è®¾ç½®ä¸ºCPUæ ¸æ•°æˆ–ç•¥å°‘ï¼Œé¿å…è¿‡åº¦ç«äº‰
runtime.GOMAXPROCS(runtime.NumCPU())
```

**I/Oå¯†é›†å‹ä»»åŠ¡ï¼š**

```go
// å¯ä»¥è®¾ç½®æ›´å¤šï¼Œå› ä¸ºå¤§é‡æ—¶é—´åœ¨ç­‰å¾…I/O
runtime.GOMAXPROCS(runtime.NumCPU() * 2)
```

**æ··åˆå‹ä»»åŠ¡ï¼š**

```go
// æ ¹æ®å®é™…å‹æµ‹è°ƒæ•´ï¼Œç›‘æ§CPUåˆ©ç”¨ç‡
runtime.GOMAXPROCS(runtime.NumCPU())
```

### æ€§èƒ½ç›‘æ§

```go
// ç›‘æ§Goroutineæ•°é‡
numGoroutine := runtime.NumGoroutine()
fmt.Printf("Active Goroutines: %d\n", numGoroutine)

// å®šæœŸæ£€æŸ¥ï¼Œé¿å…æ³„æ¼
ticker := time.NewTicker(10 * time.Second)
go func() {
    for range ticker.C {
        n := runtime.NumGoroutine()
        if n > 10000 { // è®¾ç½®é˜ˆå€¼
            log.Printf("WARNING: Too many goroutines: %d", n)
        }
    }
}()
```

## 3. é”ä¼˜åŒ–ä¸æ— é”å¹¶å‘

### é”ä¼˜åŒ–ç­–ç•¥

**1. ä¼˜å…ˆä½¿ç”¨Channelé€šä¿¡**

Goçš„è®¾è®¡å“²å­¦ï¼š"ä¸è¦é€šè¿‡å…±äº«å†…å­˜æ¥é€šä¿¡ï¼Œè€Œåº”é€šè¿‡é€šä¿¡æ¥å…±äº«å†…å­˜"ã€‚

```go
// âŒ å…±äº«å†…å­˜+é”
type Counter struct {
    mu    sync.Mutex
    count int
}

func (c *Counter) Inc() {
    c.mu.Lock()
    c.count++
    c.mu.Unlock()
}

// âœ… Channelé€šä¿¡
type Counter struct {
    ch chan int
}

func (c *Counter) Inc() {
    c.ch <- 1
}

func (c *Counter) worker() {
    count := 0
    for range c.ch {
        count++
    }
}
```

**2. ç¼©å°é”ç²’åº¦**

```go
// âŒ é”ç²’åº¦è¿‡å¤§
func (s *Service) Process(data string) error {
    s.mu.Lock()
    defer s.mu.Unlock()

    // è€—æ—¶çš„I/Oæ“ä½œä¹Ÿåœ¨é”å†…
    result := heavyComputation(data)
    err := s.db.Save(result)
    s.cache.Set(data, result)
    return err
}

// âœ… ç¼©å°ä¸´ç•ŒåŒº
func (s *Service) Process(data string) error {
    result := heavyComputation(data) // é”å¤–æ‰§è¡Œ

    s.mu.Lock()
    s.cache.Set(data, result) // åªä¿æŠ¤å¿…è¦çš„å…±äº«èµ„æº
    s.mu.Unlock()

    return s.db.Save(result) // é”å¤–æ‰§è¡Œ
}
```

**3. è¯»å†™é”ä¼˜åŒ–ï¼ˆRWMutexï¼‰**

è¯»å¤šå†™å°‘åœºæ™¯ä½¿ç”¨`sync.RWMutex`ï¼š

```go
type Cache struct {
    mu    sync.RWMutex
    data  map[string]interface{}
}

func (c *Cache) Get(key string) (interface{}, bool) {
    c.mu.RLock()         // è¯»é”ï¼Œå…è®¸å¹¶å‘è¯»
    defer c.mu.RUnlock()
    val, ok := c.data[key]
    return val, ok
}

func (c *Cache) Set(key string, value interface{}) {
    c.mu.Lock()          // å†™é”ï¼Œç‹¬å è®¿é—®
    defer c.mu.Unlock()
    c.data[key] = value
}
```

**4. sync.Mapé€‚ç”¨åœºæ™¯**

é€‚åˆä»¥ä¸‹åœºæ™¯ï¼š

- ç»™å®škeyçš„æ¡ç›®åªå†™ä¸€æ¬¡ï¼Œä½†è¯»å¤šæ¬¡ï¼ˆå¦‚åªå¢é•¿çš„ç¼“å­˜ï¼‰
- å¤šä¸ªGoroutineè¯»å†™ä¸ç›¸äº¤çš„keyé›†åˆ

```go
var cache sync.Map

// å¹¶å‘å®‰å…¨ï¼Œæ— éœ€é¢å¤–é”
cache.Store("key", "value")
val, ok := cache.Load("key")
cache.Delete("key")

// é«˜æ•ˆéå†
cache.Range(func(key, value interface{}) bool {
    fmt.Println(key, value)
    return true
})
```

### æ— é”å¹¶å‘ï¼ˆAtomicæ“ä½œï¼‰

**é€‚ç”¨åœºæ™¯ï¼š**

- ç®€å•è®¡æ•°å™¨
- çŠ¶æ€æ ‡å¿—ä½
- é…ç½®çƒ­æ›´æ–°
- ç»Ÿè®¡æŒ‡æ ‡

**å¸¸ç”¨åŸå­æ“ä½œï¼š**

```go
import "sync/atomic"

// 1. è®¡æ•°å™¨
var counter int64
atomic.AddInt64(&counter, 1)            // åŠ 
atomic.AddInt64(&counter, -1)           // å‡
val := atomic.LoadInt64(&counter)       // è¯»
atomic.StoreInt64(&counter, 0)          // å†™

// 2. CASï¼ˆCompare-And-Swapï¼‰
var config int64
old := atomic.LoadInt64(&config)
swapped := atomic.CompareAndSwapInt64(&config, old, new)

// 3. å¸ƒå°”æ ‡å¿—
var flag int32 // 0=false, 1=true
atomic.StoreInt32(&flag, 1)             // è®¾ç½®
if atomic.LoadInt32(&flag) == 1 {       // æ£€æŸ¥
    // do something
}

// 4. æŒ‡é’ˆåŸå­æ“ä½œ
var ptr unsafe.Pointer
atomic.StorePointer(&ptr, unsafe.Pointer(&newValue))
loadedPtr := atomic.LoadPointer(&ptr)
```

**å®æˆ˜æ¡ˆä¾‹ï¼šé«˜æ€§èƒ½è®¡æ•°å™¨**

```go
// ä¼ ç»Ÿé”æ–¹æ¡ˆ
type LockCounter struct {
    mu    sync.Mutex
    count int64
}

func (c *LockCounter) Inc() {
    c.mu.Lock()
    c.count++
    c.mu.Unlock()
}

// åŸå­æ“ä½œæ–¹æ¡ˆï¼ˆæ€§èƒ½æå‡10-20å€ï¼‰
type AtomicCounter struct {
    count int64
}

func (c *AtomicCounter) Inc() {
    atomic.AddInt64(&c.count, 1)
}

// Benchmarkç»“æœï¼š
// LockCounter.Inc     50000000    25.4 ns/op
// AtomicCounter.Inc   200000000    1.8 ns/op
```

## 4. Goroutineæ³„æ¼ä¸èµ„æºå›æ”¶

### å¸¸è§æ³„æ¼åœºæ™¯

**1. Channelé˜»å¡å¯¼è‡´çš„æ³„æ¼**

```go
// âŒ æ³„æ¼ï¼šworkeræ°¸è¿œé˜»å¡åœ¨channelå‘é€
func leak() {
    ch := make(chan int)
    go func() {
        ch <- 42  // æ°¸è¿œé˜»å¡ï¼Œæ²¡æœ‰æ¥æ”¶è€…
    }()
    // å‡½æ•°è¿”å›ï¼Œä½†goroutineæ°¸è¿œå­˜æ´»
}

// âœ… æ­£ç¡®ï¼šä½¿ç”¨ç¼“å†²channelæˆ–ç¡®ä¿æ¥æ”¶
func noLeak() {
    ch := make(chan int, 1)  // ç¼“å†²channel
    go func() {
        ch <- 42
    }()
    // æˆ–è€…ç¡®ä¿æœ‰æ¥æ”¶è€…
}
```

**2. æœªæ­£ç¡®ä½¿ç”¨Context**

```go
// âŒ æ³„æ¼ï¼šæ²¡æœ‰ç›‘å¬ctx.Done()
func leak(ctx context.Context) {
    go func() {
        for {
            // æ— æ³•å–æ¶ˆçš„æ­»å¾ªç¯
            doWork()
        }
    }()
}

// âœ… æ­£ç¡®ï¼šç›‘å¬å–æ¶ˆä¿¡å·
func noLeak(ctx context.Context) {
    go func() {
        for {
            select {
            case <-ctx.Done():
                log.Println("Worker stopped")
                return
            default:
                doWork()
            }
        }
    }()
}
```

**3. æ°¸ä¹…é˜»å¡çš„Select**

```go
// âŒ æ³„æ¼ï¼šSelectæ°¸ä¹…é˜»å¡
func leak() {
    ch := make(chan int)
    go func() {
        select {
        case val := <-ch:
            process(val)
        // æ²¡æœ‰é€€å‡ºæœºåˆ¶
        }
    }()
}

// âœ… æ­£ç¡®ï¼šæ·»åŠ è¶…æ—¶æˆ–å–æ¶ˆæœºåˆ¶
func noLeak(ctx context.Context) {
    ch := make(chan int)
    go func() {
        select {
        case val := <-ch:
            process(val)
        case <-ctx.Done():
            return
        case <-time.After(10 * time.Second):
            return
        }
    }()
}
```

### ç”Ÿå‘½å‘¨æœŸç®¡ç†æœ€ä½³å®è·µ

**1. ä½¿ç”¨Contextæ§åˆ¶**

```go
func worker(ctx context.Context, input <-chan Task) {
    for {
        select {
        case <-ctx.Done():
            log.Println("Worker shutting down")
            return
        case task := <-input:
            if err := task.Execute(); err != nil {
                log.Printf("Task failed: %v", err)
            }
        }
    }
}

// ä½¿ç”¨
ctx, cancel := context.WithCancel(context.Background())
defer cancel()  // ç¡®ä¿å–æ¶ˆ

go worker(ctx, taskCh)
// ...
cancel()  // ä¼˜é›…å…³é—­
```

**2. ä½¿ç”¨Done Channel**

```go
type Worker struct {
    done chan struct{}
}

func (w *Worker) Start() {
    w.done = make(chan struct{})
    go func() {
        ticker := time.NewTicker(time.Second)
        defer ticker.Stop()

        for {
            select {
            case <-w.done:
                return
            case <-ticker.C:
                w.doWork()
            }
        }
    }()
}

func (w *Worker) Stop() {
    close(w.done)
}
```

**3. ä½¿ç”¨WaitGroupç¡®ä¿å®Œæˆ**

```go
func processAll(ctx context.Context, tasks []Task) {
    var wg sync.WaitGroup

    for _, task := range tasks {
        wg.Add(1)
        go func(t Task) {
            defer wg.Done()

            select {
            case <-ctx.Done():
                return
            default:
                t.Execute()
            }
        }(task)
    }

    // ç­‰å¾…æ‰€æœ‰goroutineå®Œæˆ
    wg.Wait()
}
```

### æ³„æ¼æ£€æµ‹

**ä½¿ç”¨pprofæ£€æµ‹**

```go
import _ "net/http/pprof"

func main() {
    go func() {
        http.ListenAndServe(":6060", nil)
    }()

    // è¿è¡Œä¸šåŠ¡é€»è¾‘
}

// è®¿é—® http://localhost:6060/debug/pprof/goroutine
// æŸ¥çœ‹æ‰€æœ‰goroutineçš„è°ƒç”¨æ ˆ
```

**å®šæœŸç›‘æ§**

```go
func monitorGoroutines() {
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()

    for range ticker.C {
        n := runtime.NumGoroutine()
        if n > 1000 {
            buf := make([]byte, 1<<20)
            stackSize := runtime.Stack(buf, true)
            log.Printf("LEAK DETECTED: %d goroutines\n%s",
                n, buf[:stackSize])
        }
    }
}
```

## 5. å¸¸è§é™·é˜±ä¸æœ€ä½³å®è·µ

### å¸¸è§é™·é˜±

**1. è¿‡åº¦å¹¶å‘**

- **é—®é¢˜**ï¼šåˆ›å»ºè¿‡å¤šGoroutineå¯¼è‡´è°ƒåº¦å‹åŠ›ã€å†…å­˜è†¨èƒ€
- **è§£å†³**ï¼šä½¿ç”¨Worker Poolæ¨¡å¼é™åˆ¶å¹¶å‘æ•°

```go
func workerPool(tasks <-chan Task, workers int) {
    var wg sync.WaitGroup
    for i := 0; i < workers; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for task := range tasks {
                task.Execute()
            }
        }()
    }
    wg.Wait()
}
```

**2. é”ç²’åº¦è¿‡å¤§**

- **é—®é¢˜**ï¼šé•¿æ—¶é—´æŒé”ï¼Œå¯¼è‡´å¹¶å‘æ€§èƒ½ä¸‹é™
- **è§£å†³**ï¼šç¼©å°ä¸´ç•ŒåŒºï¼Œä½¿ç”¨è¯»å†™é”æˆ–åˆ†æ®µé”

**3. æ•°æ®ç«äº‰**

- **æ£€æµ‹**ï¼šä½¿ç”¨`-race`æ ‡å¿—

```bash
go test -race ./...
go build -race
```

### æœ€ä½³å®è·µæ€»ç»“

âœ… **å¹¶å‘è®¾è®¡**

- ä¼˜å…ˆä½¿ç”¨Channelé€šä¿¡è€Œéå…±äº«å†…å­˜
- åˆç†è®¾ç½®GOMAXPROCSï¼ˆé»˜è®¤å³å¯ï¼‰
- ä½¿ç”¨Worker Poolé™åˆ¶å¹¶å‘æ•°

âœ… **é”ä½¿ç”¨**

- ç¼©å°é”ç²’åº¦ï¼Œå‡å°‘ä¸´ç•ŒåŒº
- è¯»å¤šå†™å°‘åœºæ™¯ä½¿ç”¨RWMutex
- ç®€å•åœºæ™¯ä½¿ç”¨atomicæ“ä½œ

âœ… **èµ„æºç®¡ç†**

- ä½¿ç”¨Contextæ§åˆ¶ç”Ÿå‘½å‘¨æœŸ
- å®šæœŸç›‘æ§Goroutineæ•°é‡
- ä½¿ç”¨pprof/traceåˆ†ææ€§èƒ½

âœ… **æµ‹è¯•éªŒè¯**

- ä½¿ç”¨`-race`æ£€æµ‹æ•°æ®ç«äº‰
- ç¼–å†™å¹¶å‘å‹æµ‹
- æŒç»­ç›‘æ§ç”Ÿäº§ç¯å¢ƒæŒ‡æ ‡

## 6. å‚è€ƒæ–‡çŒ®

- Goå®˜æ–¹å¹¶å‘æ–‡æ¡£ï¼š<https://golang.org/doc/>
- Goè°ƒåº¦å™¨å‰–æï¼š<https://draveness.me/golang/>
- Goå¤œè¯»æ€§èƒ½ä¼˜åŒ–ä¸“æ ï¼š<https://github.com/developer-learning/night-reading-go>

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team
**æœ€åæ›´æ–°**: 2025-10-29
**æ–‡æ¡£çŠ¶æ€**: å®Œæˆ
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
