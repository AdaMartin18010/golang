# Go并发优化

> **简介**: Go并发性能优化实战，掌握调度器优化、锁优化和无锁并发技术
> **版本**: Go 1.23+  
> **难度**: ⭐⭐⭐⭐  
> **标签**: #性能优化 #并发 #调度器 #无锁

<!-- TOC START -->
- [Go并发优化](#go并发优化)
  - [1. 理论基础](#1-理论基础)
  - [2. 调度器与GOMAXPROCS](#2-调度器与gomaxprocs)
  - [3. 锁优化与无锁并发](#3-锁优化与无锁并发)
    - [锁优化](#锁优化)
    - [无锁并发](#无锁并发)
  - [4. Goroutine泄漏与资源回收](#4-goroutine泄漏与资源回收)
  - [5. 常见陷阱与最佳实践](#5-常见陷阱与最佳实践)
  - [6. 参考文献](#6-参考文献)
<!-- TOC END -->

## 1. 理论基础

### Go并发模型：G-P-M调度器

Go的并发性能优势来自于其独特的调度器设计：

- **G (Goroutine)**：轻量级用户态线程，栈初始2KB，可动态扩缩容
- **P (Processor)**：逻辑处理器，管理本地G队列，数量由GOMAXPROCS控制
- **M (Machine)**：OS线程，实际执行单元

**关键优势：**
- **M:N调度**：多个Goroutine复用少量OS线程，降低上下文切换开销
- **Work Stealing**：P之间可窃取任务，提升负载均衡
- **协作式抢占**：Go 1.14+支持异步抢占，避免长时间运行阻塞调度

### 性能优化关注点

1. **调度开销**：Goroutine创建/销毁、上下文切换、任务窃取
2. **锁竞争**：多Goroutine竞争共享资源导致的性能下降
3. **资源利用率**：CPU、内存、网络带宽的利用效率
4. **Goroutine泄漏**：未正确回收的Goroutine导致内存泄漏

## 2. 调度器与GOMAXPROCS

### GOMAXPROCS详解

`GOMAXPROCS`控制可同时执行的P（逻辑处理器）数量，直接影响并行度：

```go
import "runtime"

// 查看当前GOMAXPROCS
current := runtime.GOMAXPROCS(0)
fmt.Printf("Current GOMAXPROCS: %d\n", current)

// 设置为CPU核数的80%（适合CPU密集型）
numCPU := runtime.NumCPU()
runtime.GOMAXPROCS(int(float64(numCPU) * 0.8))

// 也可以通过环境变量设置
// export GOMAXPROCS=4
```

### 适用场景与最佳实践

**CPU密集型任务：**
```go
// 设置为CPU核数或略少，避免过度竞争
runtime.GOMAXPROCS(runtime.NumCPU())
```

**I/O密集型任务：**
```go
// 可以设置更多，因为大量时间在等待I/O
runtime.GOMAXPROCS(runtime.NumCPU() * 2)
```

**混合型任务：**
```go
// 根据实际压测调整，监控CPU利用率
runtime.GOMAXPROCS(runtime.NumCPU())
```

### 性能监控

```go
// 监控Goroutine数量
numGoroutine := runtime.NumGoroutine()
fmt.Printf("Active Goroutines: %d\n", numGoroutine)

// 定期检查，避免泄漏
ticker := time.NewTicker(10 * time.Second)
go func() {
    for range ticker.C {
        n := runtime.NumGoroutine()
        if n > 10000 { // 设置阈值
            log.Printf("WARNING: Too many goroutines: %d", n)
        }
    }
}()
```

## 3. 锁优化与无锁并发

### 锁优化策略

**1. 优先使用Channel通信**

Go的设计哲学："不要通过共享内存来通信，而应通过通信来共享内存"。

```go
// ❌ 共享内存+锁
type Counter struct {
    mu    sync.Mutex
    count int
}

func (c *Counter) Inc() {
    c.mu.Lock()
    c.count++
    c.mu.Unlock()
}

// ✅ Channel通信
type Counter struct {
    ch chan int
}

func (c *Counter) Inc() {
    c.ch <- 1
}

func (c *Counter) worker() {
    count := 0
    for range c.ch {
        count++
    }
}
```

**2. 缩小锁粒度**

```go
// ❌ 锁粒度过大
func (s *Service) Process(data string) error {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    // 耗时的I/O操作也在锁内
    result := heavyComputation(data)
    err := s.db.Save(result)
    s.cache.Set(data, result)
    return err
}

// ✅ 缩小临界区
func (s *Service) Process(data string) error {
    result := heavyComputation(data) // 锁外执行
    
    s.mu.Lock()
    s.cache.Set(data, result) // 只保护必要的共享资源
    s.mu.Unlock()
    
    return s.db.Save(result) // 锁外执行
}
```

**3. 读写锁优化（RWMutex）**

读多写少场景使用`sync.RWMutex`：

```go
type Cache struct {
    mu    sync.RWMutex
    data  map[string]interface{}
}

func (c *Cache) Get(key string) (interface{}, bool) {
    c.mu.RLock()         // 读锁，允许并发读
    defer c.mu.RUnlock()
    val, ok := c.data[key]
    return val, ok
}

func (c *Cache) Set(key string, value interface{}) {
    c.mu.Lock()          // 写锁，独占访问
    defer c.mu.Unlock()
    c.data[key] = value
}
```

**4. sync.Map适用场景**

适合以下场景：
- 给定key的条目只写一次，但读多次（如只增长的缓存）
- 多个Goroutine读写不相交的key集合

```go
var cache sync.Map

// 并发安全，无需额外锁
cache.Store("key", "value")
val, ok := cache.Load("key")
cache.Delete("key")

// 高效遍历
cache.Range(func(key, value interface{}) bool {
    fmt.Println(key, value)
    return true
})
```

### 无锁并发（Atomic操作）

**适用场景：**
- 简单计数器
- 状态标志位
- 配置热更新
- 统计指标

**常用原子操作：**

```go
import "sync/atomic"

// 1. 计数器
var counter int64
atomic.AddInt64(&counter, 1)            // 加
atomic.AddInt64(&counter, -1)           // 减
val := atomic.LoadInt64(&counter)       // 读
atomic.StoreInt64(&counter, 0)          // 写

// 2. CAS（Compare-And-Swap）
var config int64
old := atomic.LoadInt64(&config)
swapped := atomic.CompareAndSwapInt64(&config, old, new)

// 3. 布尔标志
var flag int32 // 0=false, 1=true
atomic.StoreInt32(&flag, 1)             // 设置
if atomic.LoadInt32(&flag) == 1 {       // 检查
    // do something
}

// 4. 指针原子操作
var ptr unsafe.Pointer
atomic.StorePointer(&ptr, unsafe.Pointer(&newValue))
loadedPtr := atomic.LoadPointer(&ptr)
```

**实战案例：高性能计数器**

```go
// 传统锁方案
type LockCounter struct {
    mu    sync.Mutex
    count int64
}

func (c *LockCounter) Inc() {
    c.mu.Lock()
    c.count++
    c.mu.Unlock()
}

// 原子操作方案（性能提升10-20倍）
type AtomicCounter struct {
    count int64
}

func (c *AtomicCounter) Inc() {
    atomic.AddInt64(&c.count, 1)
}

// Benchmark结果：
// LockCounter.Inc     50000000    25.4 ns/op
// AtomicCounter.Inc   200000000    1.8 ns/op
```

## 4. Goroutine泄漏与资源回收

### 常见泄漏场景

**1. Channel阻塞导致的泄漏**

```go
// ❌ 泄漏：worker永远阻塞在channel发送
func leak() {
    ch := make(chan int)
    go func() {
        ch <- 42  // 永远阻塞，没有接收者
    }()
    // 函数返回，但goroutine永远存活
}

// ✅ 正确：使用缓冲channel或确保接收
func noLeak() {
    ch := make(chan int, 1)  // 缓冲channel
    go func() {
        ch <- 42
    }()
    // 或者确保有接收者
}
```

**2. 未正确使用Context**

```go
// ❌ 泄漏：没有监听ctx.Done()
func leak(ctx context.Context) {
    go func() {
        for {
            // 无法取消的死循环
            doWork()
        }
    }()
}

// ✅ 正确：监听取消信号
func noLeak(ctx context.Context) {
    go func() {
        for {
            select {
            case <-ctx.Done():
                log.Println("Worker stopped")
                return
            default:
                doWork()
            }
        }
    }()
}
```

**3. 永久阻塞的Select**

```go
// ❌ 泄漏：Select永久阻塞
func leak() {
    ch := make(chan int)
    go func() {
        select {
        case val := <-ch:
            process(val)
        // 没有退出机制
        }
    }()
}

// ✅ 正确：添加超时或取消机制
func noLeak(ctx context.Context) {
    ch := make(chan int)
    go func() {
        select {
        case val := <-ch:
            process(val)
        case <-ctx.Done():
            return
        case <-time.After(10 * time.Second):
            return
        }
    }()
}
```

### 生命周期管理最佳实践

**1. 使用Context控制**

```go
func worker(ctx context.Context, input <-chan Task) {
    for {
        select {
        case <-ctx.Done():
            log.Println("Worker shutting down")
            return
        case task := <-input:
            if err := task.Execute(); err != nil {
                log.Printf("Task failed: %v", err)
            }
        }
    }
}

// 使用
ctx, cancel := context.WithCancel(context.Background())
defer cancel()  // 确保取消

go worker(ctx, taskCh)
// ... 
cancel()  // 优雅关闭
```

**2. 使用Done Channel**

```go
type Worker struct {
    done chan struct{}
}

func (w *Worker) Start() {
    w.done = make(chan struct{})
    go func() {
        ticker := time.NewTicker(time.Second)
        defer ticker.Stop()
        
        for {
            select {
            case <-w.done:
                return
            case <-ticker.C:
                w.doWork()
            }
        }
    }()
}

func (w *Worker) Stop() {
    close(w.done)
}
```

**3. 使用WaitGroup确保完成**

```go
func processAll(ctx context.Context, tasks []Task) {
    var wg sync.WaitGroup
    
    for _, task := range tasks {
        wg.Add(1)
        go func(t Task) {
            defer wg.Done()
            
            select {
            case <-ctx.Done():
                return
            default:
                t.Execute()
            }
        }(task)
    }
    
    // 等待所有goroutine完成
    wg.Wait()
}
```

### 泄漏检测

**使用pprof检测**

```go
import _ "net/http/pprof"

func main() {
    go func() {
        http.ListenAndServe(":6060", nil)
    }()
    
    // 运行业务逻辑
}

// 访问 http://localhost:6060/debug/pprof/goroutine
// 查看所有goroutine的调用栈
```

**定期监控**

```go
func monitorGoroutines() {
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        n := runtime.NumGoroutine()
        if n > 1000 {
            buf := make([]byte, 1<<20)
            stackSize := runtime.Stack(buf, true)
            log.Printf("LEAK DETECTED: %d goroutines\n%s", 
                n, buf[:stackSize])
        }
    }
}
```

## 5. 常见陷阱与最佳实践

### 常见陷阱

**1. 过度并发**
- **问题**：创建过多Goroutine导致调度压力、内存膨胀
- **解决**：使用Worker Pool模式限制并发数

```go
func workerPool(tasks <-chan Task, workers int) {
    var wg sync.WaitGroup
    for i := 0; i < workers; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for task := range tasks {
                task.Execute()
            }
        }()
    }
    wg.Wait()
}
```

**2. 锁粒度过大**
- **问题**：长时间持锁，导致并发性能下降
- **解决**：缩小临界区，使用读写锁或分段锁

**3. 数据竞争**
- **检测**：使用`-race`标志

```bash
go test -race ./...
go build -race
```

### 最佳实践总结

✅ **并发设计**
- 优先使用Channel通信而非共享内存
- 合理设置GOMAXPROCS（默认即可）
- 使用Worker Pool限制并发数

✅ **锁使用**
- 缩小锁粒度，减少临界区
- 读多写少场景使用RWMutex
- 简单场景使用atomic操作

✅ **资源管理**
- 使用Context控制生命周期
- 定期监控Goroutine数量
- 使用pprof/trace分析性能

✅ **测试验证**
- 使用`-race`检测数据竞争
- 编写并发压测
- 持续监控生产环境指标

## 6. 参考文献

- Go官方并发文档：<https://golang.org/doc/>
- Go调度器剖析：<https://draveness.me/golang/>
- Go夜读性能优化专栏：<https://github.com/developer-learning/night-reading-go>

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025年10月20日  
**文档状态**: 完成  
**适用版本**: Go 1.25.3+
