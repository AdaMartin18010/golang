# Go GCè°ƒä¼˜

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.23+

---

## ğŸ“‹ ç›®å½•

- [Go GCè°ƒä¼˜](#go-gcè°ƒä¼˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. GCåŸç†æ¦‚è¿°](#1-gcåŸç†æ¦‚è¿°)
    - [1.1 Go GCæ¼”è¿›å†å²](#11-go-gcæ¼”è¿›å†å²)
    - [1.2 ä¸‰è‰²æ ‡è®°ç®—æ³•](#12-ä¸‰è‰²æ ‡è®°ç®—æ³•)
    - [1.3 å¹¶å‘æ ‡è®°ä¸å†™å±éšœ](#13-å¹¶å‘æ ‡è®°ä¸å†™å±éšœ)
    - [1.4 GCè§¦å‘æ—¶æœº](#14-gcè§¦å‘æ—¶æœº)
  - [2. GOGCå‚æ•°ä¸è°ƒä¼˜](#2-gogcå‚æ•°ä¸è°ƒä¼˜)
    - [2.1 GOGCå‚æ•°è¯¦è§£](#21-gogcå‚æ•°è¯¦è§£)
    - [2.2 GOGCè°ƒä¼˜ç­–ç•¥](#22-gogcè°ƒä¼˜ç­–ç•¥)
    - [2.3 GOMEMLIMITï¼ˆGo 1.19+ï¼‰](#23-gomemlimitgo-119)
    - [2.4 åŠ¨æ€è°ƒæ•´GOGC](#24-åŠ¨æ€è°ƒæ•´gogc)
  - [3. GCç›‘æ§ä¸åˆ†æ](#3-gcç›‘æ§ä¸åˆ†æ)
    - [3.1 runtime.MemStatsç›‘æ§](#31-runtimememstatsç›‘æ§)
    - [3.2 å…³é”®GCæŒ‡æ ‡](#32-å…³é”®gcæŒ‡æ ‡)
    - [3.3 ä½¿ç”¨pprofåˆ†æå †å†…å­˜](#33-ä½¿ç”¨pprofåˆ†æå †å†…å­˜)
    - [3.4 ä½¿ç”¨traceåˆ†æGCè¡Œä¸º](#34-ä½¿ç”¨traceåˆ†ægcè¡Œä¸º)
    - [3.5 é›†æˆPrometheusç›‘æ§](#35-é›†æˆprometheusç›‘æ§)
  - [4. å¸¸è§é—®é¢˜ä¸æœ€ä½³å®è·µ](#4-å¸¸è§é—®é¢˜ä¸æœ€ä½³å®è·µ)
    - [4.1 å¸¸è§GCé—®é¢˜è¯Šæ–­](#41-å¸¸è§gcé—®é¢˜è¯Šæ–­)
    - [4.2 GCè°ƒä¼˜æœ€ä½³å®è·µ](#42-gcè°ƒä¼˜æœ€ä½³å®è·µ)
    - [4.3 Go 1.25.3 GCæ–°ç‰¹æ€§](#43-go-1253-gcæ–°ç‰¹æ€§)
  - [5. å‚è€ƒæ–‡çŒ®](#5-å‚è€ƒæ–‡çŒ®)

## 1. GCåŸç†æ¦‚è¿°

### 1.1 Go GCæ¼”è¿›å†å²

Goçš„åƒåœ¾å›æ”¶å™¨ç»å†äº†å¤šä¸ªç‰ˆæœ¬çš„æ¼”è¿›ï¼š

- **Go 1.0-1.3**: Stop-The-Worldï¼ˆSTWï¼‰æ ‡è®°æ¸…é™¤ï¼Œæš‚åœæ—¶é—´è¾ƒé•¿
- **Go 1.5**: å¼•å…¥å¹¶å‘æ ‡è®°æ¸…é™¤ï¼Œæš‚åœæ—¶é—´é™è‡³10msä»¥ä¸‹
- **Go 1.8**: è¿›ä¸€æ­¥ä¼˜åŒ–ï¼Œç›®æ ‡æš‚åœæ—¶é—´<1ms
- **Go 1.12**: æ ‡è®°ç»ˆæ­¢é˜¶æ®µä¼˜åŒ–
- **Go 1.18**: å¹¶å‘æ¸…ç†ä¼˜åŒ–
- **Go 1.19+**: è½¯å†…å­˜é™åˆ¶ï¼ˆGOMEMLIMITï¼‰
- **Go 1.25.3**: æœ€æ–°çš„GCä¼˜åŒ–å’Œæ€§èƒ½æ”¹è¿›

### 1.2 ä¸‰è‰²æ ‡è®°ç®—æ³•

Goé‡‡ç”¨**ä¸‰è‰²æ ‡è®°-æ¸…é™¤ï¼ˆTricolor Mark-Sweepï¼‰**å¹¶å‘GCç®—æ³•ï¼š

1. **ç™½è‰²**ï¼šæœªè¢«æ ‡è®°çš„å¯¹è±¡ï¼ˆå¾…å›æ”¶ï¼‰
2. **ç°è‰²**ï¼šå·²æ ‡è®°ä½†å…¶å¼•ç”¨çš„å¯¹è±¡æœªå®Œå…¨æ ‡è®°
3. **é»‘è‰²**ï¼šå·²æ ‡è®°ä¸”å…¶å¼•ç”¨çš„å¯¹è±¡ä¹Ÿå·²æ ‡è®°

**æ ‡è®°æµç¨‹ï¼š**

```
åˆå§‹çŠ¶æ€ï¼šæ‰€æœ‰å¯¹è±¡ä¸ºç™½è‰²
â†“
ä»æ ¹å¯¹è±¡å¼€å§‹ï¼Œæ ‡è®°ä¸ºç°è‰²
â†“
éå†ç°è‰²å¯¹è±¡çš„å¼•ç”¨ï¼Œå°†å¼•ç”¨å¯¹è±¡æ ‡è®°ä¸ºç°è‰²
å°†å½“å‰ç°è‰²å¯¹è±¡æ ‡è®°ä¸ºé»‘è‰²
â†“
é‡å¤ç›´åˆ°æ²¡æœ‰ç°è‰²å¯¹è±¡
â†“
æ¸…é™¤æ‰€æœ‰ç™½è‰²å¯¹è±¡
```

### 1.3 å¹¶å‘æ ‡è®°ä¸å†™å±éšœ

ä¸ºäº†åœ¨å¹¶å‘æ ‡è®°è¿‡ç¨‹ä¸­ä¿è¯æ­£ç¡®æ€§ï¼ŒGoä½¿ç”¨**å†™å±éšœï¼ˆWrite Barrierï¼‰**ï¼š

- **æ··åˆå†™å±éšœ**ï¼šç»“åˆDijkstraæ’å…¥å±éšœå’ŒYuasaåˆ é™¤å±éšœ
- ç¡®ä¿å¹¶å‘æ ‡è®°æœŸé—´æ–°åˆ†é…çš„å¯¹è±¡ä¸ä¼šè¢«è¯¯å›æ”¶
- STWæ—¶é—´æçŸ­ï¼ˆé€šå¸¸<1msï¼‰

### 1.4 GCè§¦å‘æ—¶æœº

GCè§¦å‘æ¡ä»¶ï¼š

1. **å †å¤§å°è¾¾åˆ°é˜ˆå€¼**ï¼šå½“å‰å †å†…å­˜è¾¾åˆ°ä¸Šæ¬¡GCåçš„ `GOGC%` å€
2. **å®šæ—¶è§¦å‘**ï¼šè¶…è¿‡2åˆ†é’Ÿæœªæ‰§è¡ŒGC
3. **æ‰‹åŠ¨è§¦å‘**ï¼šè°ƒç”¨ `runtime.GC()`

**GC Pacerï¼ˆæ­¥è°ƒå™¨ï¼‰**ï¼š

Goè¿è¡Œæ—¶çš„Pacerè´Ÿè´£å†³å®šä½•æ—¶è§¦å‘GCï¼Œå¹³è¡¡ååé‡å’Œå»¶è¿Ÿã€‚

## 2. GOGCå‚æ•°ä¸è°ƒä¼˜

### 2.1 GOGCå‚æ•°è¯¦è§£

`GOGC` ç¯å¢ƒå˜é‡æ§åˆ¶GCè§¦å‘çš„ç›®æ ‡å †å¢é•¿ç™¾åˆ†æ¯”ï¼š

- **é»˜è®¤å€¼ï¼š100**ï¼ˆå †å¢é•¿100%æ—¶è§¦å‘GCï¼‰
- **èŒƒå›´ï¼š0-æ— ç©·å¤§**
- **ç‰¹æ®Šå€¼ï¼šoff**ï¼ˆç¦ç”¨è‡ªåŠ¨GCï¼‰

**è®¡ç®—å…¬å¼ï¼š**

```
ä¸‹æ¬¡GCç›®æ ‡å †å¤§å° = å­˜æ´»å †å¤§å° Ã— (1 + GOGC/100)
```

### 2.2 GOGCè°ƒä¼˜ç­–ç•¥

**åœºæ™¯ä¸€ï¼šå†…å­˜æ•æ„Ÿå‹åº”ç”¨**

é€‚ç”¨äºå®¹å™¨ç¯å¢ƒã€å†…å­˜å—é™åœºæ™¯ï¼š

```bash
export GOGC=50  # æ›´é¢‘ç¹GCï¼Œæ§åˆ¶å†…å­˜
```

**æ•ˆæœï¼š**

- âœ… é™ä½å†…å­˜å³°å€¼ 30-50%
- âš ï¸ å¢åŠ GCé¢‘ç‡ 2å€
- âš ï¸ å¯èƒ½å½±å“ååé‡ 10-15%

**åœºæ™¯äºŒï¼šååé‡ä¼˜å…ˆå‹åº”ç”¨**

é€‚ç”¨äºæ‰¹å¤„ç†ã€å¤§æ•°æ®å¤„ç†ï¼š

```bash
export GOGC=200  # å‡å°‘GCé¢‘ç‡ï¼Œæå‡åå
```

**æ•ˆæœï¼š**

- âœ… æå‡ååé‡ 15-30%
- âœ… å‡å°‘GCé¢‘ç‡ 50%
- âš ï¸ å¢åŠ å†…å­˜å ç”¨ 2å€

**åœºæ™¯ä¸‰ï¼šå»¶è¿Ÿæ•æ„Ÿå‹åº”ç”¨**

é€‚ç”¨äºåœ¨çº¿æœåŠ¡ã€å®æ—¶ç³»ç»Ÿï¼š

```bash
export GOGC=100  # ä¿æŒé»˜è®¤ï¼Œé…åˆå…¶ä»–ä¼˜åŒ–
```

### 2.3 GOMEMLIMITï¼ˆGo 1.19+ï¼‰

è½¯å†…å­˜é™åˆ¶ï¼Œé™åˆ¶Goç¨‹åºçš„æœ€å¤§å†…å­˜ä½¿ç”¨ï¼š

```bash
export GOMEMLIMIT=2GiB  # é™åˆ¶æœ€å¤§2GBå†…å­˜
```

**ä¸GOGCé…åˆä½¿ç”¨ï¼š**

```go
import "runtime/debug"

// è®¾ç½®å†…å­˜é™åˆ¶
debug.SetMemoryLimit(2 * 1024 * 1024 * 1024) // 2GB

// è®¾ç½®GOGC
debug.SetGCPercent(100)
```

**æœ€ä½³å®è·µï¼š**

```go
// æ ¹æ®å®¹å™¨å†…å­˜è‡ªåŠ¨è®¾ç½®
func setupGC() {
    // è·å–å®¹å™¨å†…å­˜é™åˆ¶ï¼ˆå¦‚Kubernetesï¼‰
    containerMemory := getContainerMemory()

    // è®¾ç½®ä¸ºå®¹å™¨å†…å­˜çš„90%
    memLimit := int64(float64(containerMemory) * 0.9)
    debug.SetMemoryLimit(memLimit)

    // æ ¹æ®å†…å­˜å¤§å°è°ƒæ•´GOGC
    if containerMemory < 512*1024*1024 { // <512MB
        debug.SetGCPercent(50)  // æ›´é¢‘ç¹GC
    } else if containerMemory > 4*1024*1024*1024 { // >4GB
        debug.SetGCPercent(200) // å‡å°‘GCé¢‘ç‡
    } else {
        debug.SetGCPercent(100) // é»˜è®¤
    }
}
```

### 2.4 åŠ¨æ€è°ƒæ•´GOGC

æ ¹æ®è¿è¡Œæ—¶è´Ÿè½½åŠ¨æ€è°ƒæ•´ï¼š

```go
import (
    "runtime"
    "runtime/debug"
    "time"
)

// åŠ¨æ€GCè°ƒä¼˜å™¨
type GCTuner struct {
    targetPause time.Duration
    minGOGC     int
    maxGOGC     int
}

func (t *GCTuner) Run(ctx context.Context) {
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            t.adjust()
        }
    }
}

func (t *GCTuner) adjust() {
    var stats runtime.MemStats
    runtime.ReadMemStats(&stats)

    // è®¡ç®—å¹³å‡æš‚åœæ—¶é—´
    avgPause := time.Duration(stats.PauseTotalNs / uint64(stats.NumGC))

    currentGOGC := debug.SetGCPercent(-1)
    debug.SetGCPercent(currentGOGC) // æ¢å¤

    // å¦‚æœæš‚åœæ—¶é—´è¿‡é•¿ï¼Œé™ä½GOGCï¼ˆæ›´é¢‘ç¹GCï¼‰
    if avgPause > t.targetPause && currentGOGC > t.minGOGC {
        newGOGC := int(float64(currentGOGC) * 0.9)
        if newGOGC < t.minGOGC {
            newGOGC = t.minGOGC
        }
        debug.SetGCPercent(newGOGC)
        log.Printf("GC Tuner: Decreased GOGC to %d (avgPause=%v)", newGOGC, avgPause)
    }

    // å¦‚æœæš‚åœæ—¶é—´è¾ƒçŸ­ï¼Œå¢åŠ GOGCï¼ˆå‡å°‘GCé¢‘ç‡ï¼‰
    if avgPause < t.targetPause/2 && currentGOGC < t.maxGOGC {
        newGOGC := int(float64(currentGOGC) * 1.1)
        if newGOGC > t.maxGOGC {
            newGOGC = t.maxGOGC
        }
        debug.SetGCPercent(newGOGC)
        log.Printf("GC Tuner: Increased GOGC to %d (avgPause=%v)", newGOGC, avgPause)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    tuner := &GCTuner{
        targetPause: 2 * time.Millisecond,
        minGOGC:     50,
        maxGOGC:     200,
    }

    go tuner.Run(context.Background())

    // åº”ç”¨ä¸»é€»è¾‘...
}
```

## 3. GCç›‘æ§ä¸åˆ†æ

### 3.1 runtime.MemStatsç›‘æ§

æœ€åŸºç¡€çš„GCç›‘æ§æ–¹å¼ï¼š

```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

// GCç›‘æ§å™¨
type GCMonitor struct {
    interval time.Duration
}

func (m *GCMonitor) Start() {
    ticker := time.NewTicker(m.interval)
    defer ticker.Stop()

    var lastNumGC uint32
    var lastPauseTotal uint64

    for range ticker.C {
        var stats runtime.MemStats
        runtime.ReadMemStats(&stats)

        // è®¡ç®—å¢é‡
        numGC := stats.NumGC - lastNumGC
        pauseDelta := stats.PauseTotalNs - lastPauseTotal

        fmt.Printf(`
GC Statistics:
--------------
Total GC: %d (Î”%d)
Heap Alloc: %.2f MB
Heap Sys: %.2f MB
Heap Objects: %d
Next GC: %.2f MB
GC CPU Fraction: %.4f%%
Pause Total: %.2f ms (Î”%.2f ms)
Avg Pause: %.2f ms
Max Pause: %.2f ms
`,
            stats.NumGC, numGC,
            float64(stats.HeapAlloc)/1024/1024,
            float64(stats.HeapSys)/1024/1024,
            stats.HeapObjects,
            float64(stats.NextGC)/1024/1024,
            stats.GCCPUFraction*100,
            float64(stats.PauseTotalNs)/1e6,
            float64(pauseDelta)/1e6,
            float64(stats.PauseTotalNs/uint64(stats.NumGC))/1e6,
            float64(stats.PauseNs[(stats.NumGC+255)%256])/1e6,
        )

        lastNumGC = stats.NumGC
        lastPauseTotal = stats.PauseTotalNs
    }
}

func main() {
    monitor := &GCMonitor{interval: 10 * time.Second}
    go monitor.Start()

    // åº”ç”¨é€»è¾‘...
    select {}
}
```

### 3.2 å…³é”®GCæŒ‡æ ‡

| æŒ‡æ ‡ | è¯´æ˜ | ç›®æ ‡å€¼ |
|------|------|--------|
| `NumGC` | GCæ€»æ¬¡æ•° | æ ¹æ®åº”ç”¨ç±»å‹ |
| `PauseTotalNs` | GCæ€»æš‚åœæ—¶é—´ | è¶Šä½è¶Šå¥½ |
| `PauseNs` | æœ€è¿‘256æ¬¡GCæš‚åœæ—¶é—´ | <1ms |
| `GCCPUFraction` | GCå ç”¨CPUæ¯”ä¾‹ | <5% |
| `HeapAlloc` | å½“å‰å †åˆ†é… | å¹³ç¨³ |
| `HeapSys` | ç³»ç»Ÿåˆ†é…çš„å †å†…å­˜ | å¯æ§å¢é•¿ |
| `NextGC` | ä¸‹æ¬¡GCè§¦å‘é˜ˆå€¼ | åˆç†é—´éš” |

### 3.3 ä½¿ç”¨pprofåˆ†æå †å†…å­˜

**å¯åŠ¨pprofæœåŠ¡ï¼š**

```go
import _ "net/http/pprof"
import "net/http"

func init() {
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
}
```

**é‡‡é›†å †å†…å­˜å¿«ç…§ï¼š**

```bash
# é‡‡é›†å½“å‰å †å†…å­˜
go tool pprof http://localhost:6060/debug/pprof/heap

# é‡‡é›†åˆ†é…å¯¹è±¡
go tool pprof http://localhost:6060/debug/pprof/allocs

# å¯¹æ¯”ä¸¤ä¸ªæ—¶é—´ç‚¹çš„å †å†…å­˜
go tool pprof -base heap1.pb.gz heap2.pb.gz
```

**åˆ†æå †å†…å­˜å¢é•¿ï¼š**

```bash
# åˆ†æå †å†…å­˜Topå ç”¨
(pprof) top10
(pprof) list functionName
(pprof) web
```

### 3.4 ä½¿ç”¨traceåˆ†æGCè¡Œä¸º

**é‡‡é›†traceï¼š**

```go
import (
    "os"
    "runtime/trace"
)

func main() {
    f, _ := os.Create("trace.out")
    defer f.Close()

    trace.Start(f)
    defer trace.Stop()

    // åº”ç”¨é€»è¾‘...
}
```

**æŸ¥çœ‹traceï¼š**

```bash
go tool trace trace.out
```

traceå·¥å…·å¯ä»¥å¯è§†åŒ–ï¼š

- GCäº‹ä»¶æ—¶é—´è½´
- STWæ—¶é—´
- Goroutineè°ƒåº¦
- å †å†…å­˜å˜åŒ–

### 3.5 é›†æˆPrometheusç›‘æ§

```go
import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
    "runtime"
    "time"
)

var (
    gcDuration = promauto.NewHistogram(prometheus.HistogramOpts{
        Name: "go_gc_duration_seconds",
        Help: "GC duration in seconds",
    })

    heapAlloc = promauto.NewGauge(prometheus.GaugeOpts{
        Name: "go_heap_alloc_bytes",
        Help: "Heap allocated bytes",
    })

    numGC = promauto.NewCounter(prometheus.CounterOpts{
        Name: "go_gc_total",
        Help: "Total number of GC runs",
    })
)

func collectGCMetrics() {
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()

    var lastNumGC uint32

    for range ticker.C {
        var stats runtime.MemStats
        runtime.ReadMemStats(&stats)

        heapAlloc.Set(float64(stats.HeapAlloc))

        if stats.NumGC > lastNumGC {
            numGC.Add(float64(stats.NumGC - lastNumGC))

            // è®°å½•æœ€è¿‘ä¸€æ¬¡GCæš‚åœæ—¶é—´
            pause := stats.PauseNs[(stats.NumGC+255)%256]
            gcDuration.Observe(float64(pause) / 1e9)
        }

        lastNumGC = stats.NumGC
    }
}
```

## 4. å¸¸è§é—®é¢˜ä¸æœ€ä½³å®è·µ

### 4.1 å¸¸è§GCé—®é¢˜è¯Šæ–­

**é—®é¢˜ä¸€ï¼šGCé¢‘ç‡è¿‡é«˜**

**ç—‡çŠ¶ï¼š**

- GCæ¬¡æ•°æ¯ç§’è¶…è¿‡100æ¬¡
- `GCCPUFraction` > 10%
- ååé‡ä¸‹é™

**åŸå› ï¼š**

- GOGCè®¾ç½®è¿‡å°
- å¤§é‡å°å¯¹è±¡é¢‘ç¹åˆ†é…
- å¯¹è±¡é€ƒé€¸è¿‡å¤š

**è§£å†³æ–¹æ¡ˆï¼š**

```go
// 1. å¢å¤§GOGC
debug.SetGCPercent(200)

// 2. ä½¿ç”¨å¯¹è±¡æ± å‡å°‘åˆ†é…
var bufferPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 4096)
    },
}

func processData(data []byte) {
    buf := bufferPool.Get().([]byte)
    defer bufferPool.Put(buf)

    // ä½¿ç”¨bufå¤„ç†æ•°æ®...
}

// 3. å‡å°‘å¯¹è±¡é€ƒé€¸
// é”™è¯¯ï¼šè¿”å›æŒ‡é’ˆå¯¼è‡´é€ƒé€¸
func createObject() *MyStruct {
    return &MyStruct{}
}

// æ­£ç¡®ï¼šè¿”å›å€¼
func createObject() MyStruct {
    return MyStruct{}
}
```

**é—®é¢˜äºŒï¼šå†…å­˜æŒç»­å¢é•¿ï¼ˆå†…å­˜æ³„æ¼ï¼‰**

**ç—‡çŠ¶ï¼š**

- `HeapAlloc` æŒç»­å¢é•¿
- `NextGC` ä¸æ–­æé«˜
- æœ€ç»ˆOOM

**åŸå› ï¼š**

- Goroutineæ³„æ¼
- å…¨å±€å˜é‡æŒæœ‰å¤§é‡å¯¹è±¡
- å¾ªç¯å¼•ç”¨

**è§£å†³æ–¹æ¡ˆï¼š**

```go
// 1. æ£€æµ‹Goroutineæ³„æ¼
func monitorGoroutines() {
    ticker := time.NewTicker(1 * time.Minute)
    for range ticker.C {
        count := runtime.NumGoroutine()
        if count > 10000 { // è®¾ç½®é˜ˆå€¼
            log.Printf("WARNING: Too many goroutines: %d", count)

            // è·å–goroutine stack
            buf := make([]byte, 1<<20)
            stackLen := runtime.Stack(buf, true)
            log.Printf("Goroutine stacks:\n%s", buf[:stackLen])
        }
    }
}

// 2. ä½¿ç”¨contextç®¡ç†Goroutineç”Ÿå‘½å‘¨æœŸ
func worker(ctx context.Context) {
    ticker := time.NewTicker(time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return // æ­£ç¡®é€€å‡º
        case <-ticker.C:
            // å·¥ä½œ...
        }
    }
}

// 3. åŠæ—¶é‡Šæ”¾å¤§å¯¹è±¡
func process LargeData(data []byte) {
    // å¤„ç†å®Œåï¼Œæ˜¾å¼è®¾ç½®ä¸ºnil
    data = nil
    runtime.GC() // å¿…è¦æ—¶æ‰‹åŠ¨è§¦å‘GC
}
```

**é—®é¢˜ä¸‰ï¼šGCæš‚åœæ—¶é—´è¿‡é•¿**

**ç—‡çŠ¶ï¼š**

- P99å»¶è¿Ÿå³°å€¼é«˜
- `PauseNs` ç»å¸¸ > 10ms
- ç”¨æˆ·ä½“éªŒå—å½±å“

**åŸå› ï¼š**

- å †å†…å­˜è¿‡å¤§
- å¯¹è±¡æ•°é‡è¿‡å¤š
- æŒ‡é’ˆæ‰«æè¿‡å¤š

**è§£å†³æ–¹æ¡ˆï¼š**

```go
// 1. å‡å°å †å¤§å°
debug.SetGCPercent(50)
debug.SetMemoryLimit(2 * 1024 * 1024 * 1024)

// 2. ä½¿ç”¨å€¼ç±»å‹å‡å°‘æŒ‡é’ˆæ‰«æ
// é”™è¯¯ï¼šå¤§é‡æŒ‡é’ˆ
type BadStruct struct {
    Data *[]byte
    Metadata *map[string]string
}

// æ­£ç¡®ï¼šå€¼ç±»å‹
type GoodStruct struct {
    Data []byte
    Metadata map[string]string
}

// 3. ä½¿ç”¨mmapç­‰æŠ€æœ¯ç»•è¿‡GC
import "golang.org/x/exp/mmap"

func loadLargeFile(path string) (*mmap.ReaderAt, error) {
    // mmapçš„å†…å­˜ä¸å—GCç®¡ç†
    return mmap.Open(path)
}
```

### 4.2 GCè°ƒä¼˜æœ€ä½³å®è·µ

**å®è·µ1ï¼šæ ¹æ®åº”ç”¨ç±»å‹é€‰æ‹©GOGC**

| åº”ç”¨ç±»å‹ | GOGCå»ºè®® | è¯´æ˜ |
|---------|---------|------|
| æ‰¹å¤„ç†ä»»åŠ¡ | 200-300 | ä¼˜å…ˆååé‡ |
| WebæœåŠ¡ | 100-150 | å¹³è¡¡å»¶è¿Ÿå’Œåå |
| å®æ—¶ç³»ç»Ÿ | 50-100 | ä¼˜å…ˆä½å»¶è¿Ÿ |
| å®¹å™¨åº”ç”¨ | 50+GOMEMLIMIT | æ§åˆ¶å†…å­˜ |

**å®è·µ2ï¼šå‡å°‘å †åˆ†é…çš„æŠ€å·§**

```go
// 1. é¢„åˆ†é…åˆ‡ç‰‡
// é”™è¯¯
var slice []int
for i := 0; i < 10000; i++ {
    slice = append(slice, i) // å¤šæ¬¡æ‰©å®¹
}

// æ­£ç¡®
slice := make([]int, 0, 10000) // é¢„åˆ†é…å®¹é‡
for i := 0; i < 10000; i++ {
    slice = append(slice, i)
}

// 2. å­—ç¬¦ä¸²æ‹¼æ¥ä½¿ç”¨strings.Builder
// é”™è¯¯
var s string
for i := 0; i < 1000; i++ {
    s += "hello" // æ¯æ¬¡éƒ½åˆ†é…æ–°å­—ç¬¦ä¸²
}

// æ­£ç¡®
var builder strings.Builder
builder.Grow(5000) // é¢„åˆ†é…
for i := 0; i < 1000; i++ {
    builder.WriteString("hello")
}
s := builder.String()

// 3. ä½¿ç”¨å¯¹è±¡æ± å¤ç”¨å¯¹è±¡
var requestPool = sync.Pool{
    New: func() interface{} {
        return &Request{}
    },
}
```

**å®è·µ3ï¼šç›‘æ§å’Œå‘Šè­¦**

```go
// è®¾ç½®GCå‘Šè­¦é˜ˆå€¼
func setupGCAlerts() {
    go func() {
        ticker := time.NewTicker(30 * time.Second)
        for range ticker.C {
            var stats runtime.MemStats
            runtime.ReadMemStats(&stats)

            // æ£€æŸ¥GCé¢‘ç‡
            if stats.GCCPUFraction > 0.1 { // CPUå ç”¨>10%
                alert("High GC CPU usage: %.2f%%", stats.GCCPUFraction*100)
            }

            // æ£€æŸ¥æš‚åœæ—¶é—´
            avgPause := time.Duration(stats.PauseTotalNs / uint64(stats.NumGC))
            if avgPause > 5*time.Millisecond {
                alert("High GC pause time: %v", avgPause)
            }

            // æ£€æŸ¥å†…å­˜å¢é•¿
            heapGrowth := float64(stats.HeapAlloc) / float64(stats.HeapSys)
            if heapGrowth > 0.9 { // å †ä½¿ç”¨ç‡>90%
                alert("High heap usage: %.2f%%", heapGrowth*100)
            }
        }
    }()
}
```

**å®è·µ4ï¼šä¸åŒç¯å¢ƒçš„GCé…ç½®**

```go
// æ ¹æ®ç¯å¢ƒè‡ªåŠ¨é…ç½®GC
func setupGCForEnvironment() {
    env := os.Getenv("ENV")

    switch env {
    case "production":
        // ç”Ÿäº§ç¯å¢ƒï¼šå¹³è¡¡æ€§èƒ½
        debug.SetGCPercent(100)
        if memLimit := getK8sMemoryLimit(); memLimit > 0 {
            debug.SetMemoryLimit(int64(float64(memLimit) * 0.9))
        }

    case "staging":
        // æµ‹è¯•ç¯å¢ƒï¼šæ¥è¿‘ç”Ÿäº§
        debug.SetGCPercent(100)

    case "development":
        // å¼€å‘ç¯å¢ƒï¼šå¿«é€ŸGCå‘ç°é—®é¢˜
        debug.SetGCPercent(50)

    case "benchmark":
        // æ€§èƒ½æµ‹è¯•ï¼šæœ€å¤§åå
        debug.SetGCPercent(off) // æˆ–è€…å¾ˆå¤§çš„å€¼
    }
}
```

### 4.3 Go 1.25.3 GCæ–°ç‰¹æ€§

**æ”¹è¿›çš„GC pacerï¼š**

- æ›´æ™ºèƒ½çš„GCè§¦å‘æ—¶æœº
- æ›´å¥½çš„å†…å­˜é¢„æµ‹
- é™ä½GCæš‚åœæ—¶é—´æ³¢åŠ¨

**ä½¿ç”¨å»ºè®®ï¼š**

```go
// Go 1.25.3çš„æ–°ç‰¹æ€§
import "runtime"

func optimizeForGo125() {
    // 1. ä½¿ç”¨æ–°çš„å†…å­˜é™åˆ¶API
    debug.SetMemoryLimit(2 * 1024 * 1024 * 1024)

    // 2. ç›‘æ§æ–°çš„GCæŒ‡æ ‡
    var stats runtime.MemStats
    runtime.ReadMemStats(&stats)

    // æ–°å¢çš„å­—æ®µï¼ˆç¤ºä¾‹ï¼‰
    log.Printf("GC efficiency: %.2f%%",
        float64(stats.HeapAlloc)/float64(stats.TotalAlloc)*100)
}

## 5. å‚è€ƒæ–‡çŒ®

- Goå®˜æ–¹GCæ–‡æ¡£ï¼š<https://golang.org/doc/gc-guide>
- Go GCåŸç†ä¸è°ƒä¼˜ï¼š<https://github.com/golang/go/wiki/Performance>
- Goå¤œè¯»æ€§èƒ½ä¼˜åŒ–ä¸“æ ï¼š<https://github.com/developer-learning/night-reading-go>

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team
**æœ€åæ›´æ–°**: 2025-10-29
**æ–‡æ¡£çŠ¶æ€**: å®Œæˆ
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
