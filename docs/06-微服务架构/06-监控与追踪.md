# 13.6 ç›‘æ§ä¸è¿½è¸ª

<!-- TOC START -->
- [13.6 ç›‘æ§ä¸è¿½è¸ª](#136-ç›‘æ§ä¸è¿½è¸ª)
  - [13.6.1 ğŸ“š ç†è®ºåˆ†æ](#1361--ç†è®ºåˆ†æ)
    - [13.6.1.1 å¯è§‚æµ‹æ€§ä¸‰å¤§æ”¯æŸ±](#13611-å¯è§‚æµ‹æ€§ä¸‰å¤§æ”¯æŸ±)
    - [13.6.1.2 ç›‘æ§æŒ‡æ ‡ä½“ç³»](#13612-ç›‘æ§æŒ‡æ ‡ä½“ç³»)
    - [13.6.1.3 åˆ†å¸ƒå¼è¿½è¸ªåŸç†](#13613-åˆ†å¸ƒå¼è¿½è¸ªåŸç†)
    - [13.6.1.4 å‘Šè­¦ä¸SLOè®¾è®¡](#13614-å‘Šè­¦ä¸sloè®¾è®¡)
  - [13.6.2 ğŸ’» ä»£ç ç¤ºä¾‹](#1362--ä»£ç ç¤ºä¾‹)
    - [13.6.2.1 PrometheusæŒ‡æ ‡æ”¶é›†](#13621-prometheusæŒ‡æ ‡æ”¶é›†)
    - [13.6.2.2 Jaegeråˆ†å¸ƒå¼è¿½è¸ª](#13622-jaegeråˆ†å¸ƒå¼è¿½è¸ª)
    - [13.6.2.3 ç»“æ„åŒ–æ—¥å¿—](#13623-ç»“æ„åŒ–æ—¥å¿—)
    - [13.6.2.4 å¥åº·æ£€æŸ¥ä¸æ¢é’ˆ](#13624-å¥åº·æ£€æŸ¥ä¸æ¢é’ˆ)
  - [13.6.3 ğŸ¯ æœ€ä½³å®è·µ](#1363--æœ€ä½³å®è·µ)
  - [13.6.4 ğŸ” å¸¸è§é—®é¢˜](#1364--å¸¸è§é—®é¢˜)
  - [13.6.5 ğŸ“š æ‰©å±•é˜…è¯»](#1365--æ‰©å±•é˜…è¯»)
  - [13.6.6 âœ… è½åœ°æ£€æŸ¥æ¸…å•](#1366--è½åœ°æ£€æŸ¥æ¸…å•)
  - [13.6.7 ğŸ§ª æœ¬åœ°å¿«é€ŸéªŒè¯](#1367--æœ¬åœ°å¿«é€ŸéªŒè¯)
<!-- TOC END -->

## 13.6.1 ğŸ“š ç†è®ºåˆ†æ

### 13.6.1.1 å¯è§‚æµ‹æ€§ä¸‰å¤§æ”¯æŸ±

**Metricsï¼ˆæŒ‡æ ‡ï¼‰**:

- æ•°å€¼å‹æ•°æ®ï¼Œç”¨äºç›‘æ§ç³»ç»ŸçŠ¶æ€
- æ”¯æŒèšåˆã€æŸ¥è¯¢ã€å‘Šè­¦
- é€‚åˆç›‘æ§è¶‹åŠ¿å’Œå¼‚å¸¸

**Logsï¼ˆæ—¥å¿—ï¼‰**:

- äº‹ä»¶è®°å½•ï¼ŒåŒ…å«æ—¶é—´æˆ³å’Œä¸Šä¸‹æ–‡
- ç»“æ„åŒ–æ—¥å¿—ä¾¿äºåˆ†æ
- é€‚åˆé—®é¢˜æ’æŸ¥å’Œå®¡è®¡

**Tracesï¼ˆè¿½è¸ªï¼‰**:

- è¯·æ±‚åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„å®Œæ•´è·¯å¾„
- æ˜¾ç¤ºæœåŠ¡é—´çš„è°ƒç”¨å…³ç³»
- é€‚åˆæ€§èƒ½åˆ†æå’Œä¾èµ–åˆ†æ

### 13.6.1.2 ç›‘æ§æŒ‡æ ‡ä½“ç³»

**REDæŒ‡æ ‡ï¼ˆé¢å‘è¯·æ±‚ï¼‰**:

- Rateï¼ˆé€Ÿç‡ï¼‰ï¼šæ¯ç§’è¯·æ±‚æ•°
- Errorsï¼ˆé”™è¯¯ï¼‰ï¼šé”™è¯¯ç‡
- Durationï¼ˆæŒç»­æ—¶é—´ï¼‰ï¼šå“åº”æ—¶é—´

**USEæŒ‡æ ‡ï¼ˆé¢å‘èµ„æºï¼‰**:

- Utilizationï¼ˆåˆ©ç”¨ç‡ï¼‰ï¼šèµ„æºä½¿ç”¨ç‡
- Saturationï¼ˆé¥±å’Œåº¦ï¼‰ï¼šèµ„æºæ’é˜Ÿæƒ…å†µ
- Errorsï¼ˆé”™è¯¯ï¼‰ï¼šèµ„æºé”™è¯¯ç‡

**ä¸šåŠ¡æŒ‡æ ‡**:

- ç”¨æˆ·æ´»è·ƒåº¦ã€è½¬åŒ–ç‡
- ä¸šåŠ¡å…³é”®è·¯å¾„æŒ‡æ ‡
- è‡ªå®šä¹‰ä¸šåŠ¡KPI

### 13.6.1.3 åˆ†å¸ƒå¼è¿½è¸ªåŸç†

```text
è¯·æ±‚ID: trace-123
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å‰ç«¯æœåŠ¡ (100ms)                                            â”‚
â”‚ â”œâ”€ APIç½‘å…³ (20ms)                                          â”‚
â”‚ â”‚  â”œâ”€ ç”¨æˆ·æœåŠ¡ (50ms)                                      â”‚
â”‚ â”‚  â”‚  â””â”€ æ•°æ®åº“ (30ms)                                     â”‚
â”‚ â”‚  â””â”€ è®¢å•æœåŠ¡ (80ms)                                      â”‚
â”‚ â”‚     â”œâ”€ æ”¯ä»˜æœåŠ¡ (60ms)                                   â”‚
â”‚ â”‚     â””â”€ åº“å­˜æœåŠ¡ (40ms)                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 13.6.1.4 å‘Šè­¦ä¸SLOè®¾è®¡

**SLOï¼ˆService Level Objectivesï¼‰**:

- å¯ç”¨æ€§ï¼š99.9% uptime
- å»¶è¿Ÿï¼š95%è¯·æ±‚ < 200ms
- é”™è¯¯ç‡ï¼š< 0.1%

**å‘Šè­¦ç­–ç•¥**:

- åŸºäºSLOçš„å‘Šè­¦é˜ˆå€¼
- å¤šçº§å‘Šè­¦ï¼ˆWarning/Criticalï¼‰
- å‘Šè­¦æŠ‘åˆ¶å’Œèšåˆ

## 13.6.2 ğŸ’» ä»£ç ç¤ºä¾‹

### 13.6.2.1 PrometheusæŒ‡æ ‡æ”¶é›†

```go
package main

import (
    "net/http"
    "time"

    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
    "github.com/prometheus/client_golang/prometheus/promhttp"
)

type Metrics struct {
    // HTTPè¯·æ±‚æŒ‡æ ‡
    httpRequestsTotal    *prometheus.CounterVec
    httpRequestDuration  *prometheus.HistogramVec
    httpRequestsInFlight prometheus.Gauge
    
    // ä¸šåŠ¡æŒ‡æ ‡
    activeUsers     prometheus.Gauge
    ordersProcessed *prometheus.CounterVec
    cacheHits       *prometheus.CounterVec
}

func NewMetrics() *Metrics {
    return &Metrics{
        httpRequestsTotal: promauto.NewCounterVec(
            prometheus.CounterOpts{
                Name: "http_requests_total",
                Help: "Total number of HTTP requests",
            },
            []string{"method", "endpoint", "status"},
        ),
        
        httpRequestDuration: promauto.NewHistogramVec(
            prometheus.HistogramOpts{
                Name:    "http_request_duration_seconds",
                Help:    "HTTP request duration in seconds",
                Buckets: prometheus.DefBuckets,
            },
            []string{"method", "endpoint"},
        ),
        
        httpRequestsInFlight: promauto.NewGauge(
            prometheus.GaugeOpts{
                Name: "http_requests_in_flight",
                Help: "Current number of HTTP requests being processed",
            },
        ),
        
        activeUsers: promauto.NewGauge(
            prometheus.GaugeOpts{
                Name: "active_users_total",
                Help: "Current number of active users",
            },
        ),
        
        ordersProcessed: promauto.NewCounterVec(
            prometheus.CounterOpts{
                Name: "orders_processed_total",
                Help: "Total number of orders processed",
            },
            []string{"status", "payment_method"},
        ),
        
        cacheHits: promauto.NewCounterVec(
            prometheus.CounterOpts{
                Name: "cache_hits_total",
                Help: "Total number of cache hits",
            },
            []string{"cache_type"},
        ),
    }
}

func (m *Metrics) RecordHTTPRequest(method, endpoint, status string, duration time.Duration) {
    m.httpRequestsTotal.WithLabelValues(method, endpoint, status).Inc()
    m.httpRequestDuration.WithLabelValues(method, endpoint).Observe(duration.Seconds())
}

func (m *Metrics) IncHTTPRequestsInFlight() {
    m.httpRequestsInFlight.Inc()
}

func (m *Metrics) DecHTTPRequestsInFlight() {
    m.httpRequestsInFlight.Dec()
}

func (m *Metrics) SetActiveUsers(count float64) {
    m.activeUsers.Set(count)
}

func (m *Metrics) RecordOrderProcessed(status, paymentMethod string) {
    m.ordersProcessed.WithLabelValues(status, paymentMethod).Inc()
}

func (m *Metrics) RecordCacheHit(cacheType string) {
    m.cacheHits.WithLabelValues(cacheType).Inc()
}

// HTTPä¸­é—´ä»¶
func MetricsMiddleware(metrics *Metrics) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()
            metrics.IncHTTPRequestsInFlight()
            defer metrics.DecHTTPRequestsInFlight()
            
            // åŒ…è£…ResponseWriterä»¥æ•è·çŠ¶æ€ç 
            rw := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
            
            next.ServeHTTP(rw, r)
            
            duration := time.Since(start)
            status := http.StatusText(rw.statusCode)
            metrics.RecordHTTPRequest(r.Method, r.URL.Path, status, duration)
        })
    }
}

type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    metrics := NewMetrics()
    
    // è®¾ç½®è·¯ç”±
    mux := http.NewServeMux()
    
    // ä¸šåŠ¡è·¯ç”±
    mux.HandleFunc("/api/users", func(w http.ResponseWriter, r *http.Request) {
        // æ¨¡æ‹Ÿä¸šåŠ¡é€»è¾‘
        time.Sleep(100 * time.Millisecond)
        w.Write([]byte("Users endpoint"))
    })
    
    mux.HandleFunc("/api/orders", func(w http.ResponseWriter, r *http.Request) {
        // æ¨¡æ‹Ÿè®¢å•å¤„ç†
        metrics.RecordOrderProcessed("success", "credit_card")
        w.Write([]byte("Orders endpoint"))
    })
    
    // æŒ‡æ ‡ç«¯ç‚¹
    mux.Handle("/metrics", promhttp.Handler())
    
    // åº”ç”¨ä¸­é—´ä»¶
    handler := MetricsMiddleware(metrics)(mux)
    
    // æ¨¡æ‹Ÿä¸šåŠ¡æŒ‡æ ‡æ›´æ–°
    go func() {
        ticker := time.NewTicker(5 * time.Second)
        defer ticker.Stop()
        
        for range ticker.C {
            // æ¨¡æ‹Ÿæ´»è·ƒç”¨æˆ·æ•°
            metrics.SetActiveUsers(1000 + float64(time.Now().Unix()%100))
            
            // æ¨¡æ‹Ÿç¼“å­˜å‘½ä¸­
            metrics.RecordCacheHit("redis")
        }
    }()
    
    // å¯åŠ¨æœåŠ¡å™¨
    server := &http.Server{
        Addr:    ":8080",
        Handler: handler,
    }
    
    log.Println("æœåŠ¡å™¨å¯åŠ¨åœ¨ :8080")
    log.Println("æŒ‡æ ‡ç«¯ç‚¹: http://localhost:8080/metrics")
    log.Fatal(server.ListenAndServe())
}
```

### 13.6.2.2 Jaegeråˆ†å¸ƒå¼è¿½è¸ª

```go
package main

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "time"

    "github.com/opentracing/opentracing-go"
    "github.com/opentracing/opentracing-go/ext"
    "github.com/uber/jaeger-client-go"
    "github.com/uber/jaeger-client-go/config"
)

func initTracer() (opentracing.Tracer, error) {
    cfg := config.Configuration{
        ServiceName: "user-service",
        Sampler: &config.SamplerConfig{
            Type:  jaeger.SamplerTypeConst,
            Param: 1,
        },
        Reporter: &config.ReporterConfig{
            LogSpans:           true,
            LocalAgentHostPort: "localhost:6831",
        },
    }
    
    tracer, _, err := cfg.NewTracer()
    if err != nil {
        return nil, err
    }
    
    opentracing.SetGlobalTracer(tracer)
    return tracer, nil
}

func TracingMiddleware() func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // ä»è¯·æ±‚å¤´ä¸­æå–è¿½è¸ªä¿¡æ¯
            spanCtx, _ := opentracing.GlobalTracer().Extract(
                opentracing.HTTPHeaders,
                opentracing.HTTPHeadersCarrier(r.Header),
            )
            
            // åˆ›å»ºæ–°çš„span
            span := opentracing.GlobalTracer().StartSpan(
                r.Method+" "+r.URL.Path,
                ext.RPCServerOption(spanCtx),
                ext.SpanKindRPCServer,
            )
            defer span.Finish()
            
            // è®¾ç½®spanæ ‡ç­¾
            ext.HTTPMethod.Set(span, r.Method)
            ext.HTTPUrl.Set(span, r.URL.String())
            span.SetTag("component", "http")
            
            // å°†spanæ·»åŠ åˆ°ä¸Šä¸‹æ–‡
            ctx := opentracing.ContextWithSpan(r.Context(), span)
            r = r.WithContext(ctx)
            
            // åŒ…è£…ResponseWriterä»¥æ•è·çŠ¶æ€ç 
            rw := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
            
            next.ServeHTTP(rw, r)
            
            // è®¾ç½®å“åº”çŠ¶æ€ç 
            ext.HTTPStatusCode.Set(span, uint16(rw.statusCode))
        })
    }
}

func callExternalService(ctx context.Context, serviceName, endpoint string) error {
    span, ctx := opentracing.StartSpanFromContext(ctx, "call_external_service")
    defer span.Finish()
    
    span.SetTag("service.name", serviceName)
    span.SetTag("service.endpoint", endpoint)
    
    // æ¨¡æ‹Ÿå¤–éƒ¨æœåŠ¡è°ƒç”¨
    time.Sleep(50 * time.Millisecond)
    
    // æ¨¡æ‹Ÿå¶å°”çš„é”™è¯¯
    if time.Now().UnixNano()%10 == 0 {
        span.SetTag("error", true)
        return fmt.Errorf("external service error")
    }
    
    return nil
}

func databaseQuery(ctx context.Context, query string) error {
    span, ctx := opentracing.StartSpanFromContext(ctx, "database_query")
    defer span.Finish()
    
    span.SetTag("db.statement", query)
    span.SetTag("db.type", "postgresql")
    
    // æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
    time.Sleep(30 * time.Millisecond)
    
    return nil
}

func getUserHandler(w http.ResponseWriter, r *http.Request) {
    span, ctx := opentracing.StartSpanFromContext(r.Context(), "get_user_handler")
    defer span.Finish()
    
    userID := r.URL.Query().Get("id")
    span.SetTag("user.id", userID)
    
    // æ•°æ®åº“æŸ¥è¯¢
    if err := databaseQuery(ctx, "SELECT * FROM users WHERE id = ?"); err != nil {
        span.SetTag("error", true)
        http.Error(w, "Database error", http.StatusInternalServerError)
        return
    }
    
    // è°ƒç”¨å¤–éƒ¨æœåŠ¡
    if err := callExternalService(ctx, "notification-service", "/send-notification"); err != nil {
        span.SetTag("error", true)
        log.Printf("Notification service error: %v", err)
    }
    
    w.Write([]byte(fmt.Sprintf("User %s retrieved", userID)))
}

func createOrderHandler(w http.ResponseWriter, r *http.Request) {
    span, ctx := opentracing.StartSpanFromContext(r.Context(), "create_order_handler")
    defer span.Finish()
    
    // æ¨¡æ‹Ÿè®¢å•åˆ›å»ºæµç¨‹
    steps := []string{"validate_input", "check_inventory", "process_payment", "create_order"}
    
    for _, step := range steps {
        stepSpan, stepCtx := opentracing.StartSpanFromContext(ctx, step)
        
        // æ¨¡æ‹Ÿæ¯ä¸ªæ­¥éª¤çš„å¤„ç†æ—¶é—´
        time.Sleep(time.Duration(20+time.Now().UnixNano()%30) * time.Millisecond)
        
        stepSpan.SetTag("step", step)
        stepSpan.Finish()
        
        ctx = stepCtx
    }
    
    w.Write([]byte("Order created successfully"))
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    // åˆå§‹åŒ–è¿½è¸ªå™¨
    tracer, err := initTracer()
    if err != nil {
        log.Fatal(err)
    }
    defer tracer.Close()
    
    // è®¾ç½®è·¯ç”±
    mux := http.NewServeMux()
    mux.HandleFunc("/api/users", getUserHandler)
    mux.HandleFunc("/api/orders", createOrderHandler)
    
    // åº”ç”¨è¿½è¸ªä¸­é—´ä»¶
    handler := TracingMiddleware()(mux)
    
    // å¯åŠ¨æœåŠ¡å™¨
    server := &http.Server{
        Addr:    ":8080",
        Handler: handler,
    }
    
    log.Println("æœåŠ¡å™¨å¯åŠ¨åœ¨ :8080")
    log.Println("Jaeger UI: http://localhost:16686")
    log.Fatal(server.ListenAndServe())
}
```

### 13.6.2.3 ç»“æ„åŒ–æ—¥å¿—

```go
package main

import (
    "context"
    "log"
    "net/http"
    "os"
    "time"

    "go.uber.org/zap"
    "go.uber.org/zap/zapcore"
)

type Logger struct {
    *zap.Logger
}

func NewLogger() *Logger {
    config := zap.NewProductionConfig()
    config.EncoderConfig.TimeKey = "timestamp"
    config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
    config.EncoderConfig.LevelKey = "level"
    config.EncoderConfig.MessageKey = "message"
    config.EncoderConfig.CallerKey = "caller"
    
    logger, err := config.Build()
    if err != nil {
        log.Fatal(err)
    }
    
    return &Logger{Logger: logger}
}

func (l *Logger) WithContext(ctx context.Context) *zap.Logger {
    // ä»ä¸Šä¸‹æ–‡è·å–è¿½è¸ªID
    if traceID := ctx.Value("trace_id"); traceID != nil {
        return l.Logger.With(zap.String("trace_id", traceID.(string)))
    }
    return l.Logger
}

func (l *Logger) LogHTTPRequest(r *http.Request, statusCode int, duration time.Duration) {
    l.Info("HTTP request",
        zap.String("method", r.Method),
        zap.String("path", r.URL.Path),
        zap.String("query", r.URL.RawQuery),
        zap.String("user_agent", r.UserAgent()),
        zap.String("remote_addr", r.RemoteAddr),
        zap.Int("status_code", statusCode),
        zap.Duration("duration", duration),
    )
}

func (l *Logger) LogBusinessEvent(event string, fields ...zap.Field) {
    l.Info("Business event",
        append([]zap.Field{zap.String("event", event)}, fields...)...,
    )
}

func (l *Logger) LogError(err error, message string, fields ...zap.Field) {
    l.Error(message,
        append([]zap.Field{zap.Error(err)}, fields...)...,
    )
}

// æ—¥å¿—ä¸­é—´ä»¶
func LoggingMiddleware(logger *Logger) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()
            
            // ç”Ÿæˆè¿½è¸ªID
            traceID := generateTraceID()
            ctx := context.WithValue(r.Context(), "trace_id", traceID)
            r = r.WithContext(ctx)
            
            // åŒ…è£…ResponseWriter
            rw := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
            
            next.ServeHTTP(rw, r)
            
            duration := time.Since(start)
            logger.LogHTTPRequest(r, rw.statusCode, duration)
        })
    }
}

func generateTraceID() string {
    return fmt.Sprintf("trace-%d", time.Now().UnixNano())
}

// ä¸šåŠ¡æœåŠ¡ç¤ºä¾‹
type UserService struct {
    logger *Logger
}

func NewUserService(logger *Logger) *UserService {
    return &UserService{logger: logger}
}

func (s *UserService) GetUser(ctx context.Context, userID string) (*User, error) {
    logger := s.logger.WithContext(ctx)
    
    logger.Info("Getting user",
        zap.String("user_id", userID),
    )
    
    // æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
    time.Sleep(100 * time.Millisecond)
    
    user := &User{
        ID:    userID,
        Name:  "John Doe",
        Email: "john@example.com",
    }
    
    logger.Info("User retrieved successfully",
        zap.String("user_id", userID),
        zap.String("user_name", user.Name),
    )
    
    return user, nil
}

func (s *UserService) CreateUser(ctx context.Context, user *User) error {
    logger := s.logger.WithContext(ctx)
    
    logger.Info("Creating user",
        zap.String("user_name", user.Name),
        zap.String("user_email", user.Email),
    )
    
    // æ¨¡æ‹Ÿåˆ›å»ºç”¨æˆ·
    time.Sleep(50 * time.Millisecond)
    
    logger.LogBusinessEvent("user_created",
        zap.String("user_id", user.ID),
        zap.String("user_name", user.Name),
    )
    
    return nil
}

type User struct {
    ID    string `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    logger := NewLogger()
    defer logger.Sync()
    
    userService := NewUserService(logger)
    
    // è®¾ç½®è·¯ç”±
    mux := http.NewServeMux()
    
    mux.HandleFunc("/api/users", func(w http.ResponseWriter, r *http.Request) {
        ctx := r.Context()
        
        if r.Method == "GET" {
            userID := r.URL.Query().Get("id")
            user, err := userService.GetUser(ctx, userID)
            if err != nil {
                logger.LogError(err, "Failed to get user",
                    zap.String("user_id", userID),
                )
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
            }
            
            w.Header().Set("Content-Type", "application/json")
            w.Write([]byte(fmt.Sprintf(`{"id":"%s","name":"%s","email":"%s"}`, 
                user.ID, user.Name, user.Email)))
        } else if r.Method == "POST" {
            user := &User{
                ID:    "123",
                Name:  "Jane Doe",
                Email: "jane@example.com",
            }
            
            if err := userService.CreateUser(ctx, user); err != nil {
                logger.LogError(err, "Failed to create user")
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
            }
            
            w.WriteHeader(http.StatusCreated)
            w.Write([]byte("User created"))
        }
    })
    
    // åº”ç”¨æ—¥å¿—ä¸­é—´ä»¶
    handler := LoggingMiddleware(logger)(mux)
    
    // å¯åŠ¨æœåŠ¡å™¨
    server := &http.Server{
        Addr:    ":8080",
        Handler: handler,
    }
    
    logger.Info("Server starting",
        zap.String("addr", ":8080"),
    )
    
    log.Fatal(server.ListenAndServe())
}
```

### 13.6.2.4 å¥åº·æ£€æŸ¥ä¸æ¢é’ˆ

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
    "net/http"
    "time"

    _ "github.com/lib/pq"
    "github.com/redis/go-redis/v9"
)

type HealthChecker struct {
    checks map[string]func() error
}

func NewHealthChecker() *HealthChecker {
    return &HealthChecker{
        checks: make(map[string]func() error),
    }
}

func (hc *HealthChecker) AddCheck(name string, check func() error) {
    hc.checks[name] = check
}

func (hc *HealthChecker) CheckHealth() map[string]error {
    results := make(map[string]error)
    
    for name, check := range hc.checks {
        results[name] = check()
    }
    
    return results
}

func (hc *HealthChecker) IsHealthy() bool {
    results := hc.CheckHealth()
    for _, err := range results {
        if err != nil {
            return false
        }
    }
    return true
}

func (hc *HealthChecker) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    results := hc.CheckHealth()
    
    w.Header().Set("Content-Type", "application/json")
    
    if hc.IsHealthy() {
        w.WriteHeader(http.StatusOK)
        fmt.Fprintf(w, `{"status":"healthy","checks":%v}`, results)
    } else {
        w.WriteHeader(http.StatusServiceUnavailable)
        fmt.Fprintf(w, `{"status":"unhealthy","checks":%v}`, results)
    }
}

// æ•°æ®åº“å¥åº·æ£€æŸ¥
func (hc *HealthChecker) AddDatabaseCheck(db *sql.DB) {
    hc.AddCheck("database", func() error {
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        
        if err := db.PingContext(ctx); err != nil {
            return fmt.Errorf("database ping failed: %w", err)
        }
        
        // æ‰§è¡Œç®€å•æŸ¥è¯¢
        var result int
        if err := db.QueryRowContext(ctx, "SELECT 1").Scan(&result); err != nil {
            return fmt.Errorf("database query failed: %w", err)
        }
        
        return nil
    })
}

// Rediså¥åº·æ£€æŸ¥
func (hc *HealthChecker) AddRedisCheck(rdb *redis.Client) {
    hc.AddCheck("redis", func() error {
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        
        if err := rdb.Ping(ctx).Err(); err != nil {
            return fmt.Errorf("redis ping failed: %w", err)
        }
        
        return nil
    })
}

// å¤–éƒ¨æœåŠ¡å¥åº·æ£€æŸ¥
func (hc *HealthChecker) AddExternalServiceCheck(name, url string) {
    hc.AddCheck(name, func() error {
        client := &http.Client{
            Timeout: 5 * time.Second,
        }
        
        resp, err := client.Get(url)
        if err != nil {
            return fmt.Errorf("external service %s check failed: %w", name, err)
        }
        defer resp.Body.Close()
        
        if resp.StatusCode >= 400 {
            return fmt.Errorf("external service %s returned status %d", name, resp.StatusCode)
        }
        
        return nil
    })
}

// å†…å­˜å¥åº·æ£€æŸ¥
func (hc *HealthChecker) AddMemoryCheck() {
    hc.AddCheck("memory", func() error {
        // è¿™é‡Œå¯ä»¥æ·»åŠ å†…å­˜ä½¿ç”¨ç‡æ£€æŸ¥
        // ç¤ºä¾‹ï¼šæ£€æŸ¥å†…å­˜ä½¿ç”¨ç‡æ˜¯å¦è¶…è¿‡é˜ˆå€¼
        return nil
    })
}

// ç£ç›˜å¥åº·æ£€æŸ¥
func (hc *HealthChecker) AddDiskCheck() {
    hc.AddCheck("disk", func() error {
        // è¿™é‡Œå¯ä»¥æ·»åŠ ç£ç›˜ç©ºé—´æ£€æŸ¥
        // ç¤ºä¾‹ï¼šæ£€æŸ¥ç£ç›˜ä½¿ç”¨ç‡æ˜¯å¦è¶…è¿‡é˜ˆå€¼
        return nil
    })
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    checker := NewHealthChecker()
    
    // æ·»åŠ å„ç§å¥åº·æ£€æŸ¥
    checker.AddMemoryCheck()
    checker.AddDiskCheck()
    
    // æ¨¡æ‹Ÿæ•°æ®åº“è¿æ¥
    db, err := sql.Open("postgres", "user=postgres dbname=test sslmode=disable")
    if err == nil {
        checker.AddDatabaseCheck(db)
    }
    
    // æ¨¡æ‹ŸRedisè¿æ¥
    rdb := redis.NewClient(&redis.Options{
        Addr: "localhost:6379",
    })
    checker.AddRedisCheck(rdb)
    
    // æ·»åŠ å¤–éƒ¨æœåŠ¡æ£€æŸ¥
    checker.AddExternalServiceCheck("payment-service", "http://localhost:8081/health")
    checker.AddExternalServiceCheck("notification-service", "http://localhost:8082/health")
    
    // è®¾ç½®è·¯ç”±
    mux := http.NewServeMux()
    
    // å¥åº·æ£€æŸ¥ç«¯ç‚¹
    mux.Handle("/health", checker)
    
    // å°±ç»ªæ£€æŸ¥ç«¯ç‚¹ï¼ˆæ›´ä¸¥æ ¼çš„æ£€æŸ¥ï¼‰
    mux.HandleFunc("/ready", func(w http.ResponseWriter, r *http.Request) {
        // åªæ£€æŸ¥å…³é”®ä¾èµ–
        criticalChecks := []string{"database", "redis"}
        allHealthy := true
        
        for _, checkName := range criticalChecks {
            if check, exists := checker.checks[checkName]; exists {
                if err := check(); err != nil {
                    allHealthy = false
                    break
                }
            }
        }
        
        if allHealthy {
            w.WriteHeader(http.StatusOK)
            w.Write([]byte("ready"))
        } else {
            w.WriteHeader(http.StatusServiceUnavailable)
            w.Write([]byte("not ready"))
        }
    })
    
    // å­˜æ´»æ£€æŸ¥ç«¯ç‚¹ï¼ˆæœ€ç®€å•çš„æ£€æŸ¥ï¼‰
    mux.HandleFunc("/live", func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("alive"))
    })
    
    // ä¸šåŠ¡è·¯ç”±
    mux.HandleFunc("/api/users", func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("Users endpoint"))
    })
    
    // å¯åŠ¨æœåŠ¡å™¨
    server := &http.Server{
        Addr:    ":8080",
        Handler: mux,
    }
    
    log.Println("æœåŠ¡å™¨å¯åŠ¨åœ¨ :8080")
    log.Println("å¥åº·æ£€æŸ¥ç«¯ç‚¹:")
    log.Println("  /health - å®Œæ•´å¥åº·æ£€æŸ¥")
    log.Println("  /ready  - å°±ç»ªæ£€æŸ¥")
    log.Println("  /live   - å­˜æ´»æ£€æŸ¥")
    
    log.Fatal(server.ListenAndServe())
}
```

## 13.6.3 ğŸ¯ æœ€ä½³å®è·µ

1. **ç›‘æ§ç­–ç•¥**
   - ä½¿ç”¨REDå’ŒUSEæŒ‡æ ‡
   - è®¾ç½®åˆç†çš„å‘Šè­¦é˜ˆå€¼
   - å®ç°å¤šçº§å‘Šè­¦

2. **æ—¥å¿—ç®¡ç†**
   - ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—
   - åŒ…å«è¿½è¸ªID
   - è®¾ç½®æ—¥å¿—çº§åˆ«

3. **è¿½è¸ªè®¾è®¡**
   - åœ¨æœåŠ¡è¾¹ç•Œåˆ›å»ºspan
   - æ·»åŠ æœ‰æ„ä¹‰çš„æ ‡ç­¾
   - æ§åˆ¶é‡‡æ ·ç‡

4. **å¥åº·æ£€æŸ¥**
   - åŒºåˆ†livenesså’Œreadiness
   - æ£€æŸ¥å…³é”®ä¾èµ–
   - è®¾ç½®åˆç†çš„è¶…æ—¶

## 13.6.4 ğŸ” å¸¸è§é—®é¢˜

1. **ç›‘æ§æ•°æ®è¿‡å¤š**
   - åˆç†è®¾ç½®æŒ‡æ ‡ç»´åº¦
   - ä½¿ç”¨é‡‡æ ·å‡å°‘æ•°æ®é‡
   - å®šæœŸæ¸…ç†å†å²æ•°æ®

2. **å‘Šè­¦é£æš´**
   - è®¾ç½®å‘Šè­¦æŠ‘åˆ¶è§„åˆ™
   - ä½¿ç”¨å‘Šè­¦èšåˆ
   - åˆ†çº§å‘Šè­¦å¤„ç†

3. **è¿½è¸ªæ€§èƒ½å½±å“**
   - æ§åˆ¶é‡‡æ ·ç‡
   - å¼‚æ­¥å‘é€è¿½è¸ªæ•°æ®
   - ä¼˜åŒ–spanåˆ›å»º

4. **æ—¥å¿—å­˜å‚¨æˆæœ¬**
   - è®¾ç½®æ—¥å¿—ä¿ç•™ç­–ç•¥
   - ä½¿ç”¨æ—¥å¿—å‹ç¼©
   - åˆ†çº§å­˜å‚¨

## 13.6.5 ğŸ“š æ‰©å±•é˜…è¯»

- [Prometheuså®˜æ–¹æ–‡æ¡£](https://prometheus.io/docs/)
- [Jaegerå®˜æ–¹æ–‡æ¡£](https://www.jaegertracing.io/docs/)
- [Zapæ—¥å¿—åº“](https://github.com/uber-go/zap)
- [å¯è§‚æµ‹æ€§æœ€ä½³å®è·µ](https://sre.google/sre-book/monitoring-distributed-systems/)

## 13.6.6 âœ… è½åœ°æ£€æŸ¥æ¸…å•

- ç›‘æ§ä½“ç³»ï¼šRED/USEæŒ‡æ ‡è¦†ç›–ã€å‘Šè­¦è§„åˆ™ã€SLOå®šä¹‰
- åˆ†å¸ƒå¼è¿½è¸ªï¼šé‡‡æ ·ç­–ç•¥ã€spanæ ‡ç­¾ã€æ€§èƒ½å½±å“æ§åˆ¶
- ç»“æ„åŒ–æ—¥å¿—ï¼šæ—¥å¿—æ ¼å¼ã€è¿½è¸ªIDã€æ—¥å¿—çº§åˆ«ç®¡ç†
- å¥åº·æ£€æŸ¥ï¼šliveness/readinessåŒºåˆ†ã€ä¾èµ–æ£€æŸ¥ã€è¶…æ—¶è®¾ç½®
- å‘Šè­¦ç®¡ç†ï¼šé˜ˆå€¼è®¾ç½®ã€æŠ‘åˆ¶è§„åˆ™ã€å‡çº§ç­–ç•¥
- å­˜å‚¨ç®¡ç†ï¼šæ•°æ®ä¿ç•™ã€å‹ç¼©ç­–ç•¥ã€æˆæœ¬æ§åˆ¶

## 13.6.7 ğŸ§ª æœ¬åœ°å¿«é€ŸéªŒè¯

1. å¯åŠ¨ç›‘æ§æ ˆï¼š
   - Prometheus: `prometheus --config.file=prometheus.yml`
   - Jaeger: `jaeger-all-in-one`
   - Grafana: `grafana-server`
2. è¿è¡ŒPrometheusæŒ‡æ ‡æ”¶é›†ç¤ºä¾‹ï¼Œè®¿é—® `/metrics` ç«¯ç‚¹
3. è¿è¡ŒJaegeråˆ†å¸ƒå¼è¿½è¸ªç¤ºä¾‹ï¼Œåœ¨Jaeger UIä¸­æŸ¥çœ‹è¿½è¸ª
4. è¿è¡Œç»“æ„åŒ–æ—¥å¿—ç¤ºä¾‹ï¼Œè§‚å¯ŸJSONæ ¼å¼æ—¥å¿—è¾“å‡º
5. è¿è¡Œå¥åº·æ£€æŸ¥ç¤ºä¾‹ï¼Œæµ‹è¯• `/health`ã€`/ready`ã€`/live` ç«¯ç‚¹
6. ä½¿ç”¨å‹æµ‹å·¥å…·éªŒè¯ç›‘æ§æ•°æ®çš„å‡†ç¡®æ€§
