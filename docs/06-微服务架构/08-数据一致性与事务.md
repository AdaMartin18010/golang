# 13.8 æ•°æ®ä¸€è‡´æ€§ä¸äº‹åŠ¡

<!-- TOC START -->
- [13.8 æ•°æ®ä¸€è‡´æ€§ä¸äº‹åŠ¡](#138-æ•°æ®ä¸€è‡´æ€§ä¸äº‹åŠ¡)
  - [13.8.1 ğŸ“š ç†è®ºåˆ†æ](#1381--ç†è®ºåˆ†æ)
    - [13.8.1.1 ä¸€è‡´æ€§æ¨¡å‹](#13811-ä¸€è‡´æ€§æ¨¡å‹)
    - [13.8.1.2 åˆ†å¸ƒå¼äº‹åŠ¡æ¨¡å¼](#13812-åˆ†å¸ƒå¼äº‹åŠ¡æ¨¡å¼)
    - [13.8.1.3 Sagaæ¨¡å¼](#13813-sagaæ¨¡å¼)
    - [13.8.1.4 äº‹ä»¶æº¯æº](#13814-äº‹ä»¶æº¯æº)
  - [13.8.2 ğŸ’» ä»£ç ç¤ºä¾‹](#1382--ä»£ç ç¤ºä¾‹)
    - [13.8.2.1 ä¸¤é˜¶æ®µæäº¤](#13821-ä¸¤é˜¶æ®µæäº¤)
    - [13.8.2.2 Sagaç¼–æ’æ¨¡å¼](#13822-sagaç¼–æ’æ¨¡å¼)
    - [13.8.2.3 äº‹ä»¶æº¯æºå®ç°](#13823-äº‹ä»¶æº¯æºå®ç°)
    - [13.8.2.4 æœ€ç»ˆä¸€è‡´æ€§](#13824-æœ€ç»ˆä¸€è‡´æ€§)
  - [13.8.3 ğŸ¯ æœ€ä½³å®è·µ](#1383--æœ€ä½³å®è·µ)
  - [13.8.4 ğŸ” å¸¸è§é—®é¢˜](#1384--å¸¸è§é—®é¢˜)
  - [13.8.5 ğŸ“š æ‰©å±•é˜…è¯»](#1385--æ‰©å±•é˜…è¯»)
  - [13.8.6 âœ… è½åœ°æ£€æŸ¥æ¸…å•](#1386--è½åœ°æ£€æŸ¥æ¸…å•)
  - [13.8.7 ğŸ§ª æœ¬åœ°å¿«é€ŸéªŒè¯](#1387--æœ¬åœ°å¿«é€ŸéªŒè¯)
<!-- TOC END -->

## 13.8.1 ğŸ“š ç†è®ºåˆ†æ

### 13.8.1.1 ä¸€è‡´æ€§æ¨¡å‹

#### å¼ºä¸€è‡´æ€§ï¼ˆStrong Consistencyï¼‰

- æ‰€æœ‰èŠ‚ç‚¹åŒæ—¶çœ‹åˆ°ç›¸åŒæ•°æ®
- æ€§èƒ½è¾ƒä½ï¼Œå¯ç”¨æ€§å—é™
- é€‚ç”¨äºé‡‘èã€æ”¯ä»˜ç­‰åœºæ™¯

#### æœ€ç»ˆä¸€è‡´æ€§ï¼ˆEventual Consistencyï¼‰

- ç³»ç»Ÿæœ€ç»ˆä¼šè¾¾åˆ°ä¸€è‡´çŠ¶æ€
- æ€§èƒ½é«˜ï¼Œå¯ç”¨æ€§å¥½
- é€‚ç”¨äºå¤§å¤šæ•°ä¸šåŠ¡åœºæ™¯

#### å¼±ä¸€è‡´æ€§ï¼ˆWeak Consistencyï¼‰

- ä¸ä¿è¯æ•°æ®ä¸€è‡´æ€§
- æ€§èƒ½æœ€é«˜
- é€‚ç”¨äºç¼“å­˜ã€æ—¥å¿—ç­‰åœºæ™¯

### 13.8.1.2 åˆ†å¸ƒå¼äº‹åŠ¡æ¨¡å¼

#### ä¸¤é˜¶æ®µæäº¤ï¼ˆ2PCï¼‰

- åè°ƒè€…åè°ƒæ‰€æœ‰å‚ä¸è€…
- å‡†å¤‡é˜¶æ®µå’Œæäº¤é˜¶æ®µ
- é˜»å¡æ€§åè®®ï¼Œæ€§èƒ½è¾ƒä½

#### ä¸‰é˜¶æ®µæäº¤ï¼ˆ3PCï¼‰

- å¢åŠ é¢„æäº¤é˜¶æ®µ
- å‡å°‘é˜»å¡æ—¶é—´
- ä»ç„¶å­˜åœ¨é˜»å¡é—®é¢˜

### 13.8.1.3 Sagaæ¨¡å¼

#### ç¼–æ’æ¨¡å¼ï¼ˆOrchestrationï¼‰

- ä¸­å¤®åè°ƒå™¨æ§åˆ¶æµç¨‹
- é›†ä¸­å¼ç®¡ç†
- æ˜“äºç†è§£å’Œè°ƒè¯•

#### èˆè¹ˆæ¨¡å¼ï¼ˆChoreographyï¼‰

- æœåŠ¡é—´ç›´æ¥é€šä¿¡
- åˆ†å¸ƒå¼ç®¡ç†
- æ¾è€¦åˆï¼Œä½†éš¾ä»¥è°ƒè¯•

### 13.8.1.4 äº‹ä»¶æº¯æº

- ä»¥äº‹ä»¶ä¸ºä¸­å¿ƒçš„æ•°æ®æ¨¡å‹
- å®Œæ•´çš„äº‹ä»¶å†å²è®°å½•
- æ”¯æŒæ—¶é—´æ—…è¡ŒæŸ¥è¯¢
- ä¸CQRSæ¨¡å¼ç»“åˆä½¿ç”¨

## 13.8.2 ğŸ’» ä»£ç ç¤ºä¾‹

### 13.8.2.1 ä¸¤é˜¶æ®µæäº¤

```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

type TransactionState int

const (
    StatePreparing TransactionState = iota
    StatePrepared
    StateCommitted
    StateAborted
)

type Participant struct {
    ID     string
    Prepare func() error
    Commit  func() error
    Abort   func() error
}

type TwoPhaseCommit struct {
    participants []*Participant
    state        TransactionState
    mutex        sync.RWMutex
}

func NewTwoPhaseCommit() *TwoPhaseCommit {
    return &TwoPhaseCommit{
        participants: make([]*Participant, 0),
        state:        StatePreparing,
    }
}

func (tpc *TwoPhaseCommit) AddParticipant(participant *Participant) {
    tpc.participants = append(tpc.participants, participant)
}

func (tpc *TwoPhaseCommit) Execute(ctx context.Context) error {
    tpc.mutex.Lock()
    defer tpc.mutex.Unlock()
    
    // é˜¶æ®µ1ï¼šå‡†å¤‡é˜¶æ®µ
    if err := tpc.preparePhase(ctx); err != nil {
        tpc.abortPhase(ctx)
        return err
    }
    
    // é˜¶æ®µ2ï¼šæäº¤é˜¶æ®µ
    return tpc.commitPhase(ctx)
}

func (tpc *TwoPhaseCommit) preparePhase(ctx context.Context) error {
    tpc.state = StatePreparing
    
    for _, participant := range tpc.participants {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
        }
        
        if err := participant.Prepare(); err != nil {
            fmt.Printf("å‚ä¸è€… %s å‡†å¤‡å¤±è´¥: %v\n", participant.ID, err)
            return err
        }
    }
    
    tpc.state = StatePrepared
    return nil
}

func (tpc *TwoPhaseCommit) commitPhase(ctx context.Context) error {
    tpc.state = StateCommitted
    
    for _, participant := range tpc.participants {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
        }
        
        if err := participant.Commit(); err != nil {
            fmt.Printf("å‚ä¸è€… %s æäº¤å¤±è´¥: %v\n", participant.ID, err)
            // æ³¨æ„ï¼šè¿™é‡Œæ— æ³•å›æ»šå·²æäº¤çš„äº‹åŠ¡
        }
    }
    
    return nil
}

func (tpc *TwoPhaseCommit) abortPhase(ctx context.Context) {
    tpc.state = StateAborted
    
    for _, participant := range tpc.participants {
        select {
        case <-ctx.Done():
            return
        default:
        }
        
        if err := participant.Abort(); err != nil {
            fmt.Printf("å‚ä¸è€… %s å›æ»šå¤±è´¥: %v\n", participant.ID, err)
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    tpc := NewTwoPhaseCommit()
    
    // æ·»åŠ å‚ä¸è€…
    tpc.AddParticipant(&Participant{
        ID: "database",
        Prepare: func() error {
            fmt.Println("æ•°æ®åº“å‡†å¤‡äº‹åŠ¡")
            time.Sleep(100 * time.Millisecond)
            return nil
        },
        Commit: func() error {
            fmt.Println("æ•°æ®åº“æäº¤äº‹åŠ¡")
            return nil
        },
        Abort: func() error {
            fmt.Println("æ•°æ®åº“å›æ»šäº‹åŠ¡")
            return nil
        },
    })
    
    tpc.AddParticipant(&Participant{
        ID: "message_queue",
        Prepare: func() error {
            fmt.Println("æ¶ˆæ¯é˜Ÿåˆ—å‡†å¤‡äº‹åŠ¡")
            time.Sleep(50 * time.Millisecond)
            return nil
        },
        Commit: func() error {
            fmt.Println("æ¶ˆæ¯é˜Ÿåˆ—æäº¤äº‹åŠ¡")
            return nil
        },
        Abort: func() error {
            fmt.Println("æ¶ˆæ¯é˜Ÿåˆ—å›æ»šäº‹åŠ¡")
            return nil
        },
    })
    
    // æ‰§è¡Œä¸¤é˜¶æ®µæäº¤
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    if err := tpc.Execute(ctx); err != nil {
        fmt.Printf("äº‹åŠ¡æ‰§è¡Œå¤±è´¥: %v\n", err)
    } else {
        fmt.Println("äº‹åŠ¡æ‰§è¡ŒæˆåŠŸ")
    }
}
```

### 13.8.2.2 Sagaç¼–æ’æ¨¡å¼

```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

type SagaStep struct {
    ID          string
    Execute     func(context.Context) error
    Compensate  func(context.Context) error
    Completed   bool
    Compensated bool
}

type SagaOrchestrator struct {
    steps []*SagaStep
    mutex sync.RWMutex
}

func NewSagaOrchestrator() *SagaOrchestrator {
    return &SagaOrchestrator{
        steps: make([]*SagaStep, 0),
    }
}

func (so *SagaOrchestrator) AddStep(step *SagaStep) {
    so.steps = append(so.steps, step)
}

func (so *SagaOrchestrator) Execute(ctx context.Context) error {
    so.mutex.Lock()
    defer so.mutex.Unlock()
    
    // æ‰§è¡Œæ‰€æœ‰æ­¥éª¤
    for i, step := range so.steps {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
        }
        
        fmt.Printf("æ‰§è¡Œæ­¥éª¤ %d: %s\n", i+1, step.ID)
        
        if err := step.Execute(ctx); err != nil {
            fmt.Printf("æ­¥éª¤ %s æ‰§è¡Œå¤±è´¥: %vï¼Œå¼€å§‹è¡¥å¿\n", step.ID, err)
            
            // è¡¥å¿å·²å®Œæˆçš„æ­¥éª¤
            if err := so.compensate(ctx, i-1); err != nil {
                return fmt.Errorf("è¡¥å¿å¤±è´¥: %w", err)
            }
            
            return err
        }
        
        step.Completed = true
        fmt.Printf("æ­¥éª¤ %s æ‰§è¡ŒæˆåŠŸ\n", step.ID)
    }
    
    fmt.Println("Sagaæ‰§è¡ŒæˆåŠŸ")
    return nil
}

func (so *SagaOrchestrator) compensate(ctx context.Context, lastStepIndex int) error {
    // ä»æœ€åä¸€ä¸ªå®Œæˆçš„æ­¥éª¤å¼€å§‹è¡¥å¿
    for i := lastStepIndex; i >= 0; i-- {
        step := so.steps[i]
        if step.Completed && !step.Compensated {
            select {
            case <-ctx.Done():
                return ctx.Err()
            default:
            }
            
            fmt.Printf("è¡¥å¿æ­¥éª¤: %s\n", step.ID)
            
            if err := step.Compensate(ctx); err != nil {
                return fmt.Errorf("æ­¥éª¤ %s è¡¥å¿å¤±è´¥: %w", step.ID, err)
            }
            
            step.Compensated = true
            fmt.Printf("æ­¥éª¤ %s è¡¥å¿æˆåŠŸ\n", step.ID)
        }
    }
    
    return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    saga := NewSagaOrchestrator()
    
    // æ·»åŠ æ­¥éª¤
    saga.AddStep(&SagaStep{
        ID: "create_order",
        Execute: func(ctx context.Context) error {
            fmt.Println("åˆ›å»ºè®¢å•")
            time.Sleep(100 * time.Millisecond)
            return nil
        },
        Compensate: func(ctx context.Context) error {
            fmt.Println("åˆ é™¤è®¢å•")
            return nil
        },
    })
    
    saga.AddStep(&SagaStep{
        ID: "reserve_inventory",
        Execute: func(ctx context.Context) error {
            fmt.Println("é¢„ç•™åº“å­˜")
            time.Sleep(50 * time.Millisecond)
            return nil
        },
        Compensate: func(ctx context.Context) error {
            fmt.Println("é‡Šæ”¾åº“å­˜")
            return nil
        },
    })
    
    saga.AddStep(&SagaStep{
        ID: "process_payment",
        Execute: func(ctx context.Context) error {
            fmt.Println("å¤„ç†æ”¯ä»˜")
            time.Sleep(200 * time.Millisecond)
            // æ¨¡æ‹Ÿæ”¯ä»˜å¤±è´¥
            return fmt.Errorf("æ”¯ä»˜å¤±è´¥")
        },
        Compensate: func(ctx context.Context) error {
            fmt.Println("é€€æ¬¾")
            return nil
        },
    })
    
    saga.AddStep(&SagaStep{
        ID: "send_notification",
        Execute: func(ctx context.Context) error {
            fmt.Println("å‘é€é€šçŸ¥")
            return nil
        },
        Compensate: func(ctx context.Context) error {
            fmt.Println("å–æ¶ˆé€šçŸ¥")
            return nil
        },
    })
    
    // æ‰§è¡ŒSaga
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    if err := saga.Execute(ctx); err != nil {
        fmt.Printf("Sagaæ‰§è¡Œå¤±è´¥: %v\n", err)
    }
}
```

### 13.8.2.3 äº‹ä»¶æº¯æºå®ç°

```go
package main

import (
    "encoding/json"
    "fmt"
    "sync"
    "time"
)

type Event struct {
    ID        string                 `json:"id"`
    Type      string                 `json:"type"`
    AggregateID string               `json:"aggregate_id"`
    Data      map[string]interface{} `json:"data"`
    Version   int                    `json:"version"`
    Timestamp time.Time              `json:"timestamp"`
}

type EventStore struct {
    events []Event
    mutex  sync.RWMutex
}

func NewEventStore() *EventStore {
    return &EventStore{
        events: make([]Event, 0),
    }
}

func (es *EventStore) Append(aggregateID string, eventType string, data map[string]interface{}) (*Event, error) {
    es.mutex.Lock()
    defer es.mutex.Unlock()
    
    event := Event{
        ID:          fmt.Sprintf("event-%d", time.Now().UnixNano()),
        Type:        eventType,
        AggregateID: aggregateID,
        Data:        data,
        Version:     len(es.events) + 1,
        Timestamp:   time.Now(),
    }
    
    es.events = append(es.events, event)
    return &event, nil
}

func (es *EventStore) GetEvents(aggregateID string) ([]Event, error) {
    es.mutex.RLock()
    defer es.mutex.RUnlock()
    
    var events []Event
    for _, event := range es.events {
        if event.AggregateID == aggregateID {
            events = append(events, event)
        }
    }
    
    return events, nil
}

func (es *EventStore) GetAllEvents() []Event {
    es.mutex.RLock()
    defer es.mutex.RUnlock()
    
    events := make([]Event, len(es.events))
    copy(events, es.events)
    return events
}

type User struct {
    ID       string
    Name     string
    Email    string
    Balance  int
    Version  int
}

type UserAggregate struct {
    eventStore *EventStore
    user       *User
}

func NewUserAggregate(eventStore *EventStore, userID string) *UserAggregate {
    return &UserAggregate{
        eventStore: eventStore,
        user: &User{
            ID:      userID,
            Version: 0,
        },
    }
}

func (ua *UserAggregate) CreateUser(name, email string) error {
    event, err := ua.eventStore.Append(ua.user.ID, "UserCreated", map[string]interface{}{
        "name":  name,
        "email": email,
    })
    if err != nil {
        return err
    }
    
    ua.applyEvent(event)
    return nil
}

func (ua *UserAggregate) UpdateBalance(amount int) error {
    if ua.user.Balance+amount < 0 {
        return fmt.Errorf("ä½™é¢ä¸è¶³")
    }
    
    event, err := ua.eventStore.Append(ua.user.ID, "BalanceUpdated", map[string]interface{}{
        "amount": amount,
        "new_balance": ua.user.Balance + amount,
    })
    if err != nil {
        return err
    }
    
    ua.applyEvent(event)
    return nil
}

func (ua *UserAggregate) applyEvent(event *Event) {
    switch event.Type {
    case "UserCreated":
        ua.user.Name = event.Data["name"].(string)
        ua.user.Email = event.Data["email"].(string)
    case "BalanceUpdated":
        ua.user.Balance = event.Data["new_balance"].(int)
    }
    ua.user.Version = event.Version
}

func (ua *UserAggregate) ReplayEvents() error {
    events, err := ua.eventStore.GetEvents(ua.user.ID)
    if err != nil {
        return err
    }
    
    // é‡ç½®ç”¨æˆ·çŠ¶æ€
    ua.user = &User{
        ID:      ua.user.ID,
        Version: 0,
    }
    
    // é‡æ”¾æ‰€æœ‰äº‹ä»¶
    for _, event := range events {
        ua.applyEvent(&event)
    }
    
    return nil
}

func (ua *UserAggregate) GetUser() *User {
    return ua.user
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    eventStore := NewEventStore()
    userAggregate := NewUserAggregate(eventStore, "user-1")
    
    // åˆ›å»ºç”¨æˆ·
    if err := userAggregate.CreateUser("Alice", "alice@example.com"); err != nil {
        fmt.Printf("åˆ›å»ºç”¨æˆ·å¤±è´¥: %v\n", err)
        return
    }
    
    // æ›´æ–°ä½™é¢
    if err := userAggregate.UpdateBalance(100); err != nil {
        fmt.Printf("æ›´æ–°ä½™é¢å¤±è´¥: %v\n", err)
        return
    }
    
    if err := userAggregate.UpdateBalance(-50); err != nil {
        fmt.Printf("æ›´æ–°ä½™é¢å¤±è´¥: %v\n", err)
        return
    }
    
    // æ˜¾ç¤ºå½“å‰ç”¨æˆ·çŠ¶æ€
    user := userAggregate.GetUser()
    fmt.Printf("å½“å‰ç”¨æˆ·: %+v\n", user)
    
    // æ˜¾ç¤ºæ‰€æœ‰äº‹ä»¶
    events := eventStore.GetAllEvents()
    fmt.Printf("æ‰€æœ‰äº‹ä»¶æ•°é‡: %d\n", len(events))
    
    for _, event := range events {
        data, _ := json.Marshal(event)
        fmt.Printf("äº‹ä»¶: %s\n", string(data))
    }
    
    // é‡æ–°åˆ›å»ºèšåˆå¹¶é‡æ”¾äº‹ä»¶
    newUserAggregate := NewUserAggregate(eventStore, "user-1")
    if err := newUserAggregate.ReplayEvents(); err != nil {
        fmt.Printf("é‡æ”¾äº‹ä»¶å¤±è´¥: %v\n", err)
        return
    }
    
    replayedUser := newUserAggregate.GetUser()
    fmt.Printf("é‡æ”¾åçš„ç”¨æˆ·: %+v\n", replayedUser)
}
```

### 13.8.2.4 æœ€ç»ˆä¸€è‡´æ€§

```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

type Event struct {
    ID        string
    Type      string
    Data      interface{}
    Timestamp time.Time
}

type EventBus struct {
    subscribers map[string][]func(Event)
    mutex       sync.RWMutex
}

func NewEventBus() *EventBus {
    return &EventBus{
        subscribers: make(map[string][]func(Event)),
    }
}

func (eb *EventBus) Subscribe(eventType string, handler func(Event)) {
    eb.mutex.Lock()
    defer eb.mutex.Unlock()
    
    eb.subscribers[eventType] = append(eb.subscribers[eventType], handler)
}

func (eb *EventBus) Publish(event Event) {
    eb.mutex.RLock()
    handlers := eb.subscribers[event.Type]
    eb.mutex.RUnlock()
    
    for _, handler := range handlers {
        go handler(event) // å¼‚æ­¥å¤„ç†
    }
}

type OrderService struct {
    eventBus *EventBus
}

func NewOrderService(eventBus *EventBus) *OrderService {
    return &OrderService{eventBus: eventBus}
}

func (os *OrderService) CreateOrder(orderID string) {
    fmt.Printf("åˆ›å»ºè®¢å•: %s\n", orderID)
    
    // å‘å¸ƒè®¢å•åˆ›å»ºäº‹ä»¶
    os.eventBus.Publish(Event{
        ID:        fmt.Sprintf("event-%d", time.Now().UnixNano()),
        Type:      "OrderCreated",
        Data:      map[string]interface{}{"order_id": orderID},
        Timestamp: time.Now(),
    })
}

type InventoryService struct {
    reserved map[string]int
    mutex    sync.RWMutex
}

func NewInventoryService() *InventoryService {
    return &InventoryService{
        reserved: make(map[string]int),
    }
}

func (is *InventoryService) HandleOrderCreated(event Event) {
    orderID := event.Data.(map[string]interface{})["order_id"].(string)
    
    is.mutex.Lock()
    is.reserved[orderID] = 10 // é¢„ç•™10ä¸ªå•†å“
    is.mutex.Unlock()
    
    fmt.Printf("åº“å­˜æœåŠ¡ï¼šä¸ºè®¢å• %s é¢„ç•™åº“å­˜\n", orderID)
}

type PaymentService struct {
    processed map[string]bool
    mutex     sync.RWMutex
}

func NewPaymentService() *PaymentService {
    return &PaymentService{
        processed: make(map[string]bool),
    }
}

func (ps *PaymentService) HandleOrderCreated(event Event) {
    orderID := event.Data.(map[string]interface{})["order_id"].(string)
    
    // æ¨¡æ‹Ÿæ”¯ä»˜å¤„ç†å»¶è¿Ÿ
    time.Sleep(100 * time.Millisecond)
    
    ps.mutex.Lock()
    ps.processed[orderID] = true
    ps.mutex.Unlock()
    
    fmt.Printf("æ”¯ä»˜æœåŠ¡ï¼šå¤„ç†è®¢å• %s çš„æ”¯ä»˜\n", orderID)
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    eventBus := NewEventBus()
    
    // åˆ›å»ºæœåŠ¡
    orderService := NewOrderService(eventBus)
    inventoryService := NewInventoryService()
    paymentService := NewPaymentService()
    
    // è®¢é˜…äº‹ä»¶
    eventBus.Subscribe("OrderCreated", inventoryService.HandleOrderCreated)
    eventBus.Subscribe("OrderCreated", paymentService.HandleOrderCreated)
    
    // åˆ›å»ºè®¢å•
    orderService.CreateOrder("order-123")
    
    // ç­‰å¾…äº‹ä»¶å¤„ç†
    time.Sleep(200 * time.Millisecond)
    
    fmt.Println("æœ€ç»ˆä¸€è‡´æ€§ç¤ºä¾‹å®Œæˆ")
}
```

## 13.8.3 ğŸ¯ æœ€ä½³å®è·µ

1. **é€‰æ‹©åˆé€‚çš„ä¸€è‡´æ€§æ¨¡å‹**
   - æ ¹æ®ä¸šåŠ¡éœ€æ±‚é€‰æ‹©
   - å¹³è¡¡æ€§èƒ½å’Œä¸€è‡´æ€§
   - è€ƒè™‘ç”¨æˆ·ä½“éªŒ

2. **è®¾è®¡è¡¥å¿æœºåˆ¶**
   - æ¯ä¸ªæ“ä½œéƒ½æœ‰è¡¥å¿æ“ä½œ
   - è¡¥å¿æ“ä½œè¦å¹‚ç­‰
   - æµ‹è¯•è¡¥å¿åœºæ™¯

3. **äº‹ä»¶è®¾è®¡**
   - äº‹ä»¶è¦åŒ…å«å®Œæ•´ä¿¡æ¯
   - äº‹ä»¶è¦ç‰ˆæœ¬åŒ–
   - äº‹ä»¶è¦å¯é‡æ”¾

4. **ç›‘æ§å’Œå‘Šè­¦**
   - ç›‘æ§äº‹åŠ¡çŠ¶æ€
   - å‘Šè­¦å¼‚å¸¸æƒ…å†µ
   - è®°å½•è¯¦ç»†æ—¥å¿—

## 13.8.4 ğŸ” å¸¸è§é—®é¢˜

1. **åˆ†å¸ƒå¼äº‹åŠ¡æ€§èƒ½é—®é¢˜**
   - é¿å…é•¿æ—¶é—´äº‹åŠ¡
   - ä½¿ç”¨å¼‚æ­¥å¤„ç†
   - ä¼˜åŒ–ç½‘ç»œè°ƒç”¨

2. **è¡¥å¿æ“ä½œå¤æ‚**
   - ç®€åŒ–è¡¥å¿é€»è¾‘
   - ä½¿ç”¨å¹‚ç­‰è®¾è®¡
   - æµ‹è¯•è¡¥å¿åœºæ™¯

3. **äº‹ä»¶é¡ºåºé—®é¢˜**
   - ä½¿ç”¨ç‰ˆæœ¬å·
   - å®ç°å†²çªè§£å†³
   - è€ƒè™‘åˆ†åŒºç­–ç•¥

4. **æ•°æ®ä¸€è‡´æ€§é—®é¢˜**
   - è®¾ç½®åˆç†çš„è¶…æ—¶
   - å®ç°é‡è¯•æœºåˆ¶
   - ç›‘æ§ä¸€è‡´æ€§çŠ¶æ€

## 13.8.5 ğŸ“š æ‰©å±•é˜…è¯»

- [Sagaæ¨¡å¼è¯¦è§£](https://microservices.io/patterns/data/saga.html)
- [äº‹ä»¶æº¯æºæ¨¡å¼](https://microservices.io/patterns/data/event-sourcing.html)
- [CQRSæ¨¡å¼](https://microservices.io/patterns/data/cqrs.html)
- [åˆ†å¸ƒå¼äº‹åŠ¡](https://en.wikipedia.org/wiki/Distributed_transaction)

## 13.8.6 âœ… è½åœ°æ£€æŸ¥æ¸…å•

- ä¸€è‡´æ€§æ¨¡å‹ï¼šå¼ºä¸€è‡´/æœ€ç»ˆä¸€è‡´çš„é€‰æ‹©ä¾æ®
- äº‹åŠ¡æ¨¡å¼ï¼š2PC/Saga/äº‹ä»¶æº¯æºçš„é€‚ç”¨åœºæ™¯
- è¡¥å¿æœºåˆ¶ï¼šè¡¥å¿æ“ä½œè®¾è®¡ã€å¹‚ç­‰æ€§ã€æµ‹è¯•è¦†ç›–
- äº‹ä»¶è®¾è®¡ï¼šäº‹ä»¶ç»“æ„ã€ç‰ˆæœ¬ç®¡ç†ã€é‡æ”¾èƒ½åŠ›
- ç›‘æ§å‘Šè­¦ï¼šäº‹åŠ¡çŠ¶æ€ã€å¼‚å¸¸æƒ…å†µã€æ€§èƒ½æŒ‡æ ‡
- æµ‹è¯•éªŒè¯ï¼šæ•…éšœæ³¨å…¥ã€ä¸€è‡´æ€§æµ‹è¯•ã€è¡¥å¿æµ‹è¯•

## 13.8.7 ğŸ§ª æœ¬åœ°å¿«é€ŸéªŒè¯

1. è¿è¡Œä¸¤é˜¶æ®µæäº¤ç¤ºä¾‹ï¼Œè§‚å¯Ÿäº‹åŠ¡æ‰§è¡Œæµç¨‹
2. è¿è¡ŒSagaç¼–æ’ç¤ºä¾‹ï¼Œæµ‹è¯•è¡¥å¿æœºåˆ¶
3. è¿è¡Œäº‹ä»¶æº¯æºç¤ºä¾‹ï¼ŒéªŒè¯äº‹ä»¶é‡æ”¾
4. è¿è¡Œæœ€ç»ˆä¸€è‡´æ€§ç¤ºä¾‹ï¼Œè§‚å¯Ÿå¼‚æ­¥å¤„ç†
5. æ¨¡æ‹Ÿç½‘ç»œæ•…éšœï¼Œæµ‹è¯•äº‹åŠ¡å›æ»š
6. ä½¿ç”¨å‹æµ‹å·¥å…·éªŒè¯äº‹åŠ¡æ€§èƒ½
