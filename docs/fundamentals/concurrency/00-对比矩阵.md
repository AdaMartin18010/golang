# 对比矩阵

**版本**: v1.0
**更新日期**: 2025-10-29
**适用于**: Go 1.25.3
**文件夹**: fundamentals/concurrency

---

## 📋 目录

- [对比矩阵](#对比矩阵)
  - [1. 并发概念对比](#1-并发概念对比)
  - [2. Goroutine特性对比](#2-goroutine特性对比)
  - [3. Channel类型对比](#3-channel类型对比)
  - [4. Context类型对比](#4-context类型对比)
  - [5. 并发模式对比](#5-并发模式对比)
  - [6. 最佳实践对比](#6-最佳实践对比)
  - [📊 选择指南](#选择指南)
  - [🔗 相关文档](#相关文档)

---

## 1. 并发概念对比

### 1.1 并发 vs 并行

| 维度 | 并发 (Concurrency) | 并行 (Parallelism) |
|------|-------------------|-------------------|
| **定义** | 同时处理多个任务 | 同时执行多个任务 |
| **关键** | 任务结构 | 任务执行 |
| **CPU** | 单核或多核 | 必须多核 |
| **执行方式** | 交替执行（时间片） | 真正同时执行 |
| **目标** | 提高吞吐量、响应性 | 提高计算速度 |
| **典型场景** | I/O密集、事件驱动 | CPU密集、科学计算 |
| **Go实现** | Goroutine | Goroutine + GOMAXPROCS |

**Rob Pike的经典定义**:
> Concurrency is about dealing with lots of things at once.
> Parallelism is about doing lots of things at once.

**示例**:

```go
// 并发：结构化处理多个任务
go handleRequest1()
go handleRequest2()
// 两个请求可能交替执行（单核）或同时执行（多核）

// 并行：真正同时执行
runtime.GOMAXPROCS(4)  // 设置4个核心
for i := 0; i < 4; i++ {
    go compute(i)  // 4个goroutine真正并行执行
}
```

### 1.2 CSP vs Actor模型

| 维度 | CSP (Go) | Actor (Erlang/Akka) |
|------|---------|---------------------|
| **通信方式** | Channel（匿名管道） | Mailbox（邮箱） |
| **寻址** | 通过Channel | 通过Actor地址 |
| **耦合度** | 低（通过Channel解耦） | 中（需要Actor引用） |
| **发送** | 阻塞式（无缓冲）或异步（缓冲） | 异步 |
| **消息顺序** | FIFO保证 | FIFO保证 |
| **失败处理** | 通过error返回 | 监督树（supervisor） |
| **语言级支持** | 内置（Goroutine+Channel） | 内置（Erlang）/库（Akka） |

**Go (CSP)示例**:

```go
ch := make(Channel int)
go func() {
    ch <- 42  // 发送到channel
}()
v := <-ch    // 从channel接收
```

**Erlang (Actor)示例**:

```erlang
spawn(fun() -> receive Msg -> handle(Msg) end end),  % 创建actor
ActorPid ! {message, Data}  % 发送消息到actor
```

---

## 2. Goroutine特性对比

### 2.1 Goroutine vs Thread vs Process

| 维度 | Goroutine | Thread | Process |
|------|-----------|--------|---------|
| **创建成本** | 极低（~2KB栈） | 中（~1MB栈） | 高（完整内存空间） |
| **切换成本** | 极低（用户态） | 中（内核态） | 高（内核态+Context） |
| **数量上限** | 百万级 | 千级 | 百级 |
| **调度** | Go调度器（用户态） | OS调度器 | OS调度器 |
| **内存共享** | 共享 | 共享（同进程） | 隔离 |
| **创建语法** | `go func()` | `pthread_create` | `fork()` |
| **适用场景** | 大规模并发 | 中等并发 | 进程隔离 |

### 2.2 Goroutine栈：动态 vs 固定

| 维度 | Goroutine（Go） | Thread（C/Java） |
|------|----------------|------------------|
| **初始大小** | 2KB | 1-2MB |
| **最大大小** | 1GB | 固定 |
| **增长方式** | 动态按需 | 固定不变 |
| **内存效率** | 高 | 低 |
| **栈溢出** | 自动增长 | panic/segfault |
| **逃逸分析** | 编译器优化 | 无 |

---

## 3. Channel类型对比

### 3.1 无缓冲 vs 缓冲Channel

| 维度 | 无缓冲Channel | 缓冲Channel |
|------|-------------|-----------|
| **定义** | `make(Channel T)` | `make(Channel T, n)` |
| **容量** | 0 | n |
| **发送行为** | 阻塞直到接收 | 缓冲区满时阻塞 |
| **接收行为** | 阻塞直到发送 | 缓冲区空时阻塞 |
| **同步性** | 强同步（握手） | 异步（缓冲区内） |
| **性能** | 较慢（每次同步） | 较快（批量） |
| **语义** | Rendezvous | Mailbox |
| **使用场景** | 强同步、确保交付 | 解耦、流量控制 |

**示例对比**:

```go
// 无缓冲：强同步
ch := make(Channel int)
go func() {
    ch <- 1  // 阻塞直到被接收
}()
<-ch  // 接收

// 缓冲：异步
ch := make(Channel int, 10)
ch <- 1   // 不阻塞（缓冲区未满）
ch <- 2   // 不阻塞
v := <-ch // 接收1
```

### 3.2 单向 vs 双向Channel

| 维度 | 双向Channel | 只发送Channel | 只接收Channel |
|------|------------|--------------|--------------|
| **类型** | `Channel T` | `Channel<- T` | `<-Channel T` |
| **发送** | ✅ | ✅ | ❌ |
| **接收** | ✅ | ❌ | ✅ |
| **转换** | 可转换为单向 | 不可转换 | 不可转换 |
| **使用场景** | 灵活使用 | 函数参数（发送方） | 函数参数（接收方） |
| **类型安全** | 弱 | 强 | 强 |

**示例**:

```go
// 双向channel
ch := make(Channel int)

// 单向channel（函数参数）
func send(ch Channel<- int) {  // 只能发送
    ch <- 42
}

func receive(ch <-Channel int) {  // 只能接收
    v := <-ch
}

send(ch)     // 隐式转换为chan<- int
receive(ch)  // 隐式转换为<-Channel int
```

### 3.3 关闭Channel的影响

| 操作 | 关闭前 | 关闭后 |
|------|-------|-------|
| **发送** | 正常发送 | panic |
| **接收** | 阻塞/接收值 | 立即返回零值 |
| **range** | 阻塞等待 | 立即终止 |
| **select** | 等待就绪 | 立即就绪（零值） |
| **再次关闭** | N/A | panic |

**最佳实践**:

- ✅ 发送方关闭channel
- ❌ 接收方关闭channel
- ✅ 关闭前确保没有其他goroutine会发送

---

## 4. Context类型对比

### 4.1 Context创建方式对比

| 类型 | WithCancel | WithTimeout | WithDeadline | WithValue |
|------|-----------|-------------|--------------|-----------|
| **触发方式** | 手动cancel() | 超时自动 | 到期自动 | N/A |
| **取消时机** | 任意时刻 | 超时后 | deadline后 | N/A |
| **返回cancel** | 是 | 是 | 是 | 否 |
| **携带值** | 否 | 否 | 否 | 是 |
| **使用场景** | 主动取消 | 超时控制 | 截止时间 | 传递值 |

**示例对比**:

```go
// WithCancel - 手动取消
ctx, cancel := Context.WithCancel(Context.Background())
defer cancel()
go work(ctx)
cancel()  // 主动取消

// WithTimeout - 超时取消
ctx, cancel := Context.WithTimeout(Context.Background(), 5*time.Second)
defer cancel()
result, err := callAPI(ctx)

// WithDeadline - 截止时间
deadline := time.Now().Add(10 * time.Second)
ctx, cancel := Context.WithDeadline(Context.Background(), deadline)
defer cancel()

// WithValue - 传递值
ctx := Context.WithValue(Context.Background(), "userID", 42)
userID := ctx.Value("userID").(int)
```

### 4.2 Context取消传播

| 场景 | 父Context | 子Context | 行为 |
|------|----------|----------|------|
| **父取消** | Canceled | Canceled | 自动传播 |
| **子取消** | Active | Canceled | 不影响父 |
| **父超时** | Timeout | Timeout | 自动传播 |
| **子超时** | Active | Timeout | 不影响父 |

**原则**: 取消信号向下传播，不向上传播

---

## 5. 并发模式对比

### 5.1 Pipeline vs Worker Pool

| 维度 | Pipeline | Worker Pool |
|------|----------|-------------|
| **结构** | 多阶段串行 | 单阶段并行 |
| **数据流** | 单向流动 | 任务分发 |
| **并发点** | 每阶段并发 | 多worker并发 |
| **适用场景** | 数据转换流程 | 任务批量处理 |
| **复杂度** | 中（多stage） | 低（单stage） |
| **扩展性** | 分阶段扩展 | worker数量扩展 |

**Pipeline示例**:

```go
// Stage 1 → Stage 2 → Stage 3
gen := generate(nums)
sq := square(gen)
result := sum(sq)
```

**Worker Pool示例**:

```go
// Jobs → [Worker1, Worker2, ...] → Results
jobs := make(Channel Job, 100)
results := make(Channel Result, 100)
for i := 0; i < 10; i++ {
    go worker(jobs, results)
}
```

### 5.2 Fan-out vs Fan-in

| 维度 | Fan-out | Fan-in |
|------|---------|--------|
| **定义** | 1个输入 → N个输出 | N个输入 → 1个输出 |
| **数据流** | 分发 | 聚合 |
| **Channel数** | 1 → N | N → 1 |
| **目的** | 并行处理 | 结果收集 |
| **使用场景** | 任务分发 | 结果汇总 |

**示例**:

```go
// Fan-out: 分发到多个worker
func fanOut(in <-Channel int) []<-Channel int {
    outs := make([]<-Channel int, 5)
    for i := 0; i < 5; i++ {
        outs[i] = worker(in)
    }
    return outs
}

// Fan-in: 多个channel合并
func fanIn(channels ...<-Channel int) <-Channel int {
    out := make(Channel int)
    for _, ch := range channels {
        go func(c <-Channel int) {
            for v := range c {
                out <- v
            }
        }(ch)
    }
    return out
}
```

---

## 6. 最佳实践对比

### 6.1 Channel vs Mutex

| 场景 | 推荐Channel | 推荐Mutex | 理由 |
|------|-----------|----------|------|
| goroutine通信 | ✅ | ❌ | Channel天然支持 |
| 共享状态保护 | ❌ | ✅ | Mutex性能更好 |
| 数据流处理 | ✅ | ❌ | Channel更清晰 |
| 计数器 | ❌ | ✅ | Mutex简单 |
| 任务队列 | ✅ | ❌ | Channel天然队列 |
| 短临界区 | ❌ | ✅ | Mutex开销小 |

**Go谚语**:
> "Don't communicate by sharing memory; share memory by communicating."

### 6.2 Context传递 vs 全局变量

| 维度 | Context传递 | 全局变量 |
|------|-----------|---------|
| **线程安全** | 是 | 否（需要锁） |
| **作用范围** | 请求级别 | 全局 |
| **测试友好** | 是 | 否 |
| **取消控制** | 支持 | 不支持 |
| **推荐度** | ⭐⭐⭐⭐⭐ | ⭐ |

**最佳实践**:

```go
// ✅ 推荐：Context传递
func HandleRequest(ctx Context.Context, req Request) {
    userID := ctx.Value("userID")
    // ...
}

// ❌ 不推荐：全局变量
var globalUserID int
func HandleRequest(req Request) {
    userID := globalUserID  // 竞态风险
}
```

### 6.3 Select vs 多个if

| 维度 | Select | 多个if |
|------|--------|-------|
| **语法** | 统一select语法 | 多个if判断 |
| **等待** | 同时等待多个 | 顺序等待 |
| **随机性** | 随机选择（公平） | 固定顺序 |
| **适用** | Channel操作 | 条件判断 |
| **性能** | 高 | 低（阻塞式） |

---

## 📊 选择指南

### 并发原语选择

| 场景 | 推荐方案 | 备选 | 理由 |
|------|---------|-----|------|
| goroutine通信 | Channel | - | CSP模型 |
| 共享状态 | Mutex | atomic | 简单场景 |
| 超时控制 | Context | time.After | 标准做法 |
| 多路监听 | Select | - | Channel专用 |
| 任务队列 | Channel | - | 天然队列 |
| 等待完成 | WaitGroup | Channel | 简单直接 |

### 并发模式选择

| 场景 | 推荐模式 | 理由 |
|------|---------|------|
| 数据转换 | Pipeline | 清晰的数据流 |
| 任务处理 | Worker Pool | 并行处理 |
| 结果汇总 | Fan-in | 多源合一 |
| 任务分发 | Fan-out | 并行执行 |
| 流量控制 | Rate Limiting | 保护资源 |

---

## 🔗 相关文档
