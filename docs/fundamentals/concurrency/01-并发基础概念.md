# 并发基础概念

**难度**: 中级  
**预计阅读时间**: 15分钟  
**前置知识**: Go基础语法、函数

---

## 📋 目录

- [1. 📖 概念介绍](#1--概念介绍)
- [2. 🎯 核心知识点](#2--核心知识点)
  - [1. 并发 vs 并行](#1-并发-vs-并行)
    - [并发（Concurrency）](#并发concurrency)
    - [并行（Parallelism）](#并行parallelism)
    - [关系对比](#关系对比)
  - [2. CSP模型详解](#2-csp模型详解)
    - [什么是CSP？](#什么是csp)
    - [传统共享内存模型](#传统共享内存模型)
    - [CSP模型（Go方式）](#csp模型go方式)
  - [3. Go并发模型的优势](#3-go并发模型的优势)
    - [优势1：轻量级协程](#优势1轻量级协程)
    - [优势2：内置调度器](#优势2内置调度器)
    - [优势3：Channel原语](#优势3channel原语)
  - [4. 并发原语概览](#4-并发原语概览)
  - [5. 并发安全](#5-并发安全)
    - [什么是并发安全？](#什么是并发安全)
    - [检测竞态条件](#检测竞态条件)
- [3. ⚠️ 常见问题](#3--常见问题)
  - [Q1: 什么时候应该使用并发？](#q1-什么时候应该使用并发)
  - [Q2: Goroutine会自动清理吗？](#q2-goroutine会自动清理吗)
  - [Q3: Channel和Mutex如何选择？](#q3-channel和mutex如何选择)
  - [Q4: 如何限制Goroutine数量？](#q4-如何限制goroutine数量)
- [4. 📚 相关资源](#4--相关资源)
  - [推荐阅读](#推荐阅读)
  - [下一步学习](#下一步学习)

## 1. 📖 概念介绍

并发（Concurrency）是Go语言的核心特性之一，也是Go能够高效处理大规模系统的关键。本文将深入讲解并发的基础概念，帮助你建立正确的并发思维模型。

> **关键理解**: 并发不是并行，并发是关于结构，并行是关于执行。—— Rob Pike

---

## 2. 🎯 核心知识点

### 1. 并发 vs 并行

#### 并发（Concurrency）

**定义**: 同时处理（dealing with）多个任务的能力

```go
package main

import (
    "fmt"
    "time"
)

// 并发示例：一个人同时处理多个任务
func concurrent() {
    // 任务1：下载文件
    go func() {
        fmt.Println("开始下载文件A...")
        time.Sleep(2 * time.Second)
        fmt.Println("文件A下载完成")
    }()
    
    // 任务2：下载文件
    go func() {
        fmt.Println("开始下载文件B...")
        time.Sleep(1 * time.Second)
        fmt.Println("文件B下载完成")
    }()
    
    // 任务3：处理用户输入
    fmt.Println("等待下载完成...")
    time.Sleep(3 * time.Second)
}

func main() {
    concurrent()
}
```

**特点**:

- 逻辑上同时进行
- 可以在单核CPU上运行
- 关注程序结构设计
- 通过时间分片实现

#### 并行（Parallelism）

**定义**: 同时执行（doing）多个任务的能力

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
)

// 并行示例：多个CPU核心同时工作
func parallel() {
    // 设置使用所有CPU核心
    runtime.GOMAXPROCS(runtime.NumCPU())
    
    var wg sync.WaitGroup
    
    // 在多个核心上并行计算
    for i := 0; i < 4; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            // 密集计算任务
            sum := 0
            for j := 0; j < 1000000000; j++ {
                sum += j
            }
            fmt.Printf("Goroutine %d 完成计算，结果: %d\n", id, sum)
        }(i)
    }
    
    wg.Wait()
}

func main() {
    fmt.Printf("CPU核心数: %d\n", runtime.NumCPU())
    parallel()
}
```

**特点**:

- 物理上同时执行
- 需要多核CPU支持
- 关注执行效率
- 真正的同时运行

#### 关系对比

| 维度 | 并发 | 并行 |
|------|------|------|
| 定义 | 同时处理多个任务 | 同时执行多个任务 |
| CPU | 单核或多核 | 必须多核 |
| 目标 | 程序结构 | 执行效率 |
| 实现 | 时间分片、异步 | 多核同时运行 |
| 例子 | 一个人切换做多件事 | 多个人同时做事 |

---

### 2. CSP模型详解

#### 什么是CSP？

CSP（Communicating Sequential Processes，通信顺序进程）是由Tony Hoare在1978年提出的并发模型。

**核心思想**:

- **Don't communicate by sharing memory; share memory by communicating**
- 不要通过共享内存来通信，而要通过通信来共享内存

#### 传统共享内存模型

```go
package main

import (
    "fmt"
    "sync"
)

// 传统方式：使用共享内存和锁
type Counter struct {
    mu    sync.Mutex
    value int
}

func (c *Counter) Increment() {
    c.mu.Lock()
    c.value++
    c.mu.Unlock()
}

func (c *Counter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}

func traditionalWay() {
    counter := &Counter{}
    var wg sync.WaitGroup
    
    // 100个Goroutine同时增加计数器
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j < 1000; j++ {
                counter.Increment()
            }
        }()
    }
    
    wg.Wait()
    fmt.Printf("传统方式 - 最终计数: %d\n", counter.Value())
}

func main() {
    traditionalWay()
}
```

**问题**:

- 需要显式加锁
- 容易死锁
- 难以理解和维护
- 性能瓶颈

#### CSP模型（Go方式）

```go
package main

import (
    "fmt"
)

// CSP方式：使用Channel通信
func cspWay() {
    // 创建Channel
    ch := make(chan int)
    done := make(chan bool)
    
    // 计数器Goroutine（唯一访问counter的地方）
    go func() {
        counter := 0
        for range ch {
            counter++
        }
        done <- true
    }()
    
    // 100个Goroutine发送增加请求
    for i := 0; i < 100; i++ {
        go func() {
            for j := 0; j < 1000; j++ {
                ch <- 1
            }
        }()
    }
    
    // 等待所有操作完成
    // 注意：这里简化了实际的同步逻辑
    close(ch)
    <-done
    
    fmt.Println("CSP方式完成")
}

func main() {
    cspWay()
}
```

**优势**:

- 无需显式加锁
- 逻辑清晰
- 易于理解和维护
- 天然避免竞态条件

---

### 3. Go并发模型的优势

#### 优势1：轻量级协程

```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func goroutineOverhead() {
    // 打印初始内存使用
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    fmt.Printf("初始内存: %d KB\n", m.Alloc/1024)
    
    // 创建100,000个Goroutine
    for i := 0; i < 100000; i++ {
        go func() {
            time.Sleep(10 * time.Second)
        }()
    }
    
    // 打印内存使用
    runtime.ReadMemStats(&m)
    fmt.Printf("创建10万个Goroutine后: %d KB\n", m.Alloc/1024)
    fmt.Printf("平均每个Goroutine: %d KB\n", m.Alloc/1024/100000)
}

func main() {
    goroutineOverhead()
}
```

**特点**:

- 初始栈仅2KB
- 动态增长（最大1GB）
- 创建速度快
- 可以创建成千上万个

#### 优势2：内置调度器

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
)

func schedulerDemo() {
    // 查看调度器参数
    fmt.Printf("GOMAXPROCS: %d\n", runtime.GOMAXPROCS(0))
    fmt.Printf("NumGoroutine: %d\n", runtime.NumGoroutine())
    fmt.Printf("NumCPU: %d\n", runtime.NumCPU())
    
    var wg sync.WaitGroup
    
    // 创建10个Goroutine
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            fmt.Printf("Goroutine %d 运行在线程 %d\n", id, runtime.GOMAXPROCS(0))
        }(i)
    }
    
    wg.Wait()
}

func main() {
    schedulerDemo()
}
```

**特点**:

- G-P-M调度模型
- Work Stealing算法
- 自动负载均衡
- 抢占式调度

#### 优势3：Channel原语

```go
package main

import (
    "fmt"
    "time"
)

func channelDemo() {
    // 无缓冲Channel：同步通信
    ch1 := make(chan string)
    go func() {
        ch1 <- "Hello"
    }()
    msg := <-ch1
    fmt.Println("无缓冲:", msg)
    
    // 缓冲Channel：异步通信
    ch2 := make(chan int, 3)
    ch2 <- 1
    ch2 <- 2
    ch2 <- 3
    fmt.Println("缓冲:", <-ch2, <-ch2, <-ch2)
    
    // select多路复用
    ch3 := make(chan string)
    ch4 := make(chan string)
    
    go func() {
        time.Sleep(1 * time.Second)
        ch3 <- "from ch3"
    }()
    
    go func() {
        time.Sleep(2 * time.Second)
        ch4 <- "from ch4"
    }()
    
    for i := 0; i < 2; i++ {
        select {
        case msg := <-ch3:
            fmt.Println("select:", msg)
        case msg := <-ch4:
            fmt.Println("select:", msg)
        }
    }
}

func main() {
    channelDemo()
}
```

---

### 4. 并发原语概览

Go提供了丰富的并发原语：

| 原语 | 用途 | 特点 |
|------|------|------|
| `goroutine` | 轻量级线程 | 2KB初始栈，快速创建 |
| `channel` | 通信管道 | CSP模型，类型安全 |
| `select` | 多路复用 | 同时监听多个Channel |
| `sync.Mutex` | 互斥锁 | 保护共享资源 |
| `sync.RWMutex` | 读写锁 | 读多写少优化 |
| `sync.WaitGroup` | 等待组 | 等待多个Goroutine完成 |
| `sync.Once` | 单次执行 | 确保代码只执行一次 |
| `sync/atomic` | 原子操作 | 无锁操作 |
| `context` | 上下文 | 超时、取消、值传递 |

---

### 5. 并发安全

#### 什么是并发安全？

```go
package main

import (
    "fmt"
    "sync"
)

// 不安全的并发访问
func unsafeCounter() {
    counter := 0
    var wg sync.WaitGroup
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter++ // 竞态条件！
        }()
    }
    
    wg.Wait()
    fmt.Printf("不安全计数器: %d (应该是1000)\n", counter)
}

// 安全的并发访问
func safeCounter() {
    counter := 0
    var mu sync.Mutex
    var wg sync.WaitGroup
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            mu.Lock()
            counter++
            mu.Unlock()
        }()
    }
    
    wg.Wait()
    fmt.Printf("安全计数器: %d\n", counter)
}

func main() {
    unsafeCounter()
    safeCounter()
}
```

#### 检测竞态条件

```bash
# 使用race detector
go run -race main.go
go test -race
go build -race
```

---

## 3. ⚠️ 常见问题

### Q1: 什么时候应该使用并发？

**答**:

- I/O密集型任务（网络请求、文件读写）
- 需要提高响应性的场景
- 任务可以独立执行
- 不要为了并发而并发

### Q2: Goroutine会自动清理吗？

**答**:

- Goroutine会在函数返回后终止
- 但如果阻塞在Channel操作上，会造成泄漏
- 需要显式管理Goroutine生命周期

### Q3: Channel和Mutex如何选择？

**答**:

- 优先使用Channel（符合CSP模型）
- Mutex用于保护短时间的临界区
- 简单的计数器用atomic

### Q4: 如何限制Goroutine数量？

**答**:

```go
// 使用buffered channel作为信号量
sem := make(chan struct{}, 100) // 最多100个并发

for i := 0; i < 1000; i++ {
    sem <- struct{}{} // 获取信号
    go func() {
        defer func() { <-sem }() // 释放信号
        // 执行任务
    }()
}
```

---

## 4. 📚 相关资源

### 推荐阅读

- [Effective Go - Concurrency](https://go.dev/doc/effective_go#concurrency)
- [Go Concurrency Patterns](https://go.dev/blog/pipelines)
- [CSP论文原文](https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf)

### 下一步学习

- [02-Goroutine深入](./02-Goroutine深入.md) - 深入理解Goroutine
- [03-Channel深入](./03-Channel深入.md) - Channel高级用法
- [Go调度器](../language/02-并发编程/04-Go调度器.md) - 调度器原理

---

**最后更新**: 2025-10-27  
**作者**: Documentation Team
