# å¹¶å‘åŸºç¡€æ¦‚å¿µ

**éš¾åº¦**: ä¸­çº§  
**é¢„è®¡é˜…è¯»æ—¶é—´**: 15åˆ†é’Ÿ  
**å‰ç½®çŸ¥è¯†**: GoåŸºç¡€è¯­æ³•ã€å‡½æ•°

---

## ğŸ“‹ ç›®å½•

- [1. ğŸ“– æ¦‚å¿µä»‹ç»](#1--æ¦‚å¿µä»‹ç»)
- [2. ğŸ¯ æ ¸å¿ƒçŸ¥è¯†ç‚¹](#2--æ ¸å¿ƒçŸ¥è¯†ç‚¹)
  - [1. å¹¶å‘ vs å¹¶è¡Œ](#1-å¹¶å‘-vs-å¹¶è¡Œ)
    - [å¹¶å‘ï¼ˆConcurrencyï¼‰](#å¹¶å‘concurrency)
    - [å¹¶è¡Œï¼ˆParallelismï¼‰](#å¹¶è¡Œparallelism)
    - [å…³ç³»å¯¹æ¯”](#å…³ç³»å¯¹æ¯”)
  - [2. CSPæ¨¡å‹è¯¦è§£](#2-cspæ¨¡å‹è¯¦è§£)
    - [ä»€ä¹ˆæ˜¯CSPï¼Ÿ](#ä»€ä¹ˆæ˜¯csp)
    - [ä¼ ç»Ÿå…±äº«å†…å­˜æ¨¡å‹](#ä¼ ç»Ÿå…±äº«å†…å­˜æ¨¡å‹)
    - [CSPæ¨¡å‹ï¼ˆGoæ–¹å¼ï¼‰](#cspæ¨¡å‹goæ–¹å¼)
  - [3. Goå¹¶å‘æ¨¡å‹çš„ä¼˜åŠ¿](#3-goå¹¶å‘æ¨¡å‹çš„ä¼˜åŠ¿)
    - [ä¼˜åŠ¿1ï¼šè½»é‡çº§åç¨‹](#ä¼˜åŠ¿1è½»é‡çº§åç¨‹)
    - [ä¼˜åŠ¿2ï¼šå†…ç½®è°ƒåº¦å™¨](#ä¼˜åŠ¿2å†…ç½®è°ƒåº¦å™¨)
    - [ä¼˜åŠ¿3ï¼šChannelåŸè¯­](#ä¼˜åŠ¿3channelåŸè¯­)
  - [4. å¹¶å‘åŸè¯­æ¦‚è§ˆ](#4-å¹¶å‘åŸè¯­æ¦‚è§ˆ)
  - [5. å¹¶å‘å®‰å…¨](#5-å¹¶å‘å®‰å…¨)
    - [ä»€ä¹ˆæ˜¯å¹¶å‘å®‰å…¨ï¼Ÿ](#ä»€ä¹ˆæ˜¯å¹¶å‘å®‰å…¨)
    - [æ£€æµ‹ç«æ€æ¡ä»¶](#æ£€æµ‹ç«æ€æ¡ä»¶)
- [3. âš ï¸ å¸¸è§é—®é¢˜](#3--å¸¸è§é—®é¢˜)
  - [Q1: ä»€ä¹ˆæ—¶å€™åº”è¯¥ä½¿ç”¨å¹¶å‘ï¼Ÿ](#q1-ä»€ä¹ˆæ—¶å€™åº”è¯¥ä½¿ç”¨å¹¶å‘)
  - [Q2: Goroutineä¼šè‡ªåŠ¨æ¸…ç†å—ï¼Ÿ](#q2-goroutineä¼šè‡ªåŠ¨æ¸…ç†å—)
  - [Q3: Channelå’ŒMutexå¦‚ä½•é€‰æ‹©ï¼Ÿ](#q3-channelå’Œmutexå¦‚ä½•é€‰æ‹©)
  - [Q4: å¦‚ä½•é™åˆ¶Goroutineæ•°é‡ï¼Ÿ](#q4-å¦‚ä½•é™åˆ¶goroutineæ•°é‡)
- [4. ğŸ“š ç›¸å…³èµ„æº](#4--ç›¸å…³èµ„æº)
  - [æ¨èé˜…è¯»](#æ¨èé˜…è¯»)
  - [ä¸‹ä¸€æ­¥å­¦ä¹ ](#ä¸‹ä¸€æ­¥å­¦ä¹ )

## 1. ğŸ“– æ¦‚å¿µä»‹ç»

å¹¶å‘ï¼ˆConcurrencyï¼‰æ˜¯Goè¯­è¨€çš„æ ¸å¿ƒç‰¹æ€§ä¹‹ä¸€ï¼Œä¹Ÿæ˜¯Goèƒ½å¤Ÿé«˜æ•ˆå¤„ç†å¤§è§„æ¨¡ç³»ç»Ÿçš„å…³é”®ã€‚æœ¬æ–‡å°†æ·±å…¥è®²è§£å¹¶å‘çš„åŸºç¡€æ¦‚å¿µï¼Œå¸®åŠ©ä½ å»ºç«‹æ­£ç¡®çš„å¹¶å‘æ€ç»´æ¨¡å‹ã€‚

> **å…³é”®ç†è§£**: å¹¶å‘ä¸æ˜¯å¹¶è¡Œï¼Œå¹¶å‘æ˜¯å…³äºç»“æ„ï¼Œå¹¶è¡Œæ˜¯å…³äºæ‰§è¡Œã€‚â€”â€” Rob Pike

---

## 2. ğŸ¯ æ ¸å¿ƒçŸ¥è¯†ç‚¹

### 1. å¹¶å‘ vs å¹¶è¡Œ

#### å¹¶å‘ï¼ˆConcurrencyï¼‰

**å®šä¹‰**: åŒæ—¶å¤„ç†ï¼ˆdealing withï¼‰å¤šä¸ªä»»åŠ¡çš„èƒ½åŠ›

```go
package main

import (
    "fmt"
    "time"
)

// å¹¶å‘ç¤ºä¾‹ï¼šä¸€ä¸ªäººåŒæ—¶å¤„ç†å¤šä¸ªä»»åŠ¡
func concurrent() {
    // ä»»åŠ¡1ï¼šä¸‹è½½æ–‡ä»¶
    go func() {
        fmt.Println("å¼€å§‹ä¸‹è½½æ–‡ä»¶A...")
        time.Sleep(2 * time.Second)
        fmt.Println("æ–‡ä»¶Aä¸‹è½½å®Œæˆ")
    }()
    
    // ä»»åŠ¡2ï¼šä¸‹è½½æ–‡ä»¶
    go func() {
        fmt.Println("å¼€å§‹ä¸‹è½½æ–‡ä»¶B...")
        time.Sleep(1 * time.Second)
        fmt.Println("æ–‡ä»¶Bä¸‹è½½å®Œæˆ")
    }()
    
    // ä»»åŠ¡3ï¼šå¤„ç†ç”¨æˆ·è¾“å…¥
    fmt.Println("ç­‰å¾…ä¸‹è½½å®Œæˆ...")
    time.Sleep(3 * time.Second)
}

func main() {
    concurrent()
}
```

**ç‰¹ç‚¹**:

- é€»è¾‘ä¸ŠåŒæ—¶è¿›è¡Œ
- å¯ä»¥åœ¨å•æ ¸CPUä¸Šè¿è¡Œ
- å…³æ³¨ç¨‹åºç»“æ„è®¾è®¡
- é€šè¿‡æ—¶é—´åˆ†ç‰‡å®ç°

#### å¹¶è¡Œï¼ˆParallelismï¼‰

**å®šä¹‰**: åŒæ—¶æ‰§è¡Œï¼ˆdoingï¼‰å¤šä¸ªä»»åŠ¡çš„èƒ½åŠ›

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
)

// å¹¶è¡Œç¤ºä¾‹ï¼šå¤šä¸ªCPUæ ¸å¿ƒåŒæ—¶å·¥ä½œ
func parallel() {
    // è®¾ç½®ä½¿ç”¨æ‰€æœ‰CPUæ ¸å¿ƒ
    runtime.GOMAXPROCS(runtime.NumCPU())
    
    var wg sync.WaitGroup
    
    // åœ¨å¤šä¸ªæ ¸å¿ƒä¸Šå¹¶è¡Œè®¡ç®—
    for i := 0; i < 4; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            // å¯†é›†è®¡ç®—ä»»åŠ¡
            sum := 0
            for j := 0; j < 1000000000; j++ {
                sum += j
            }
            fmt.Printf("Goroutine %d å®Œæˆè®¡ç®—ï¼Œç»“æœ: %d\n", id, sum)
        }(i)
    }
    
    wg.Wait()
}

func main() {
    fmt.Printf("CPUæ ¸å¿ƒæ•°: %d\n", runtime.NumCPU())
    parallel()
}
```

**ç‰¹ç‚¹**:

- ç‰©ç†ä¸ŠåŒæ—¶æ‰§è¡Œ
- éœ€è¦å¤šæ ¸CPUæ”¯æŒ
- å…³æ³¨æ‰§è¡Œæ•ˆç‡
- çœŸæ­£çš„åŒæ—¶è¿è¡Œ

#### å…³ç³»å¯¹æ¯”

| ç»´åº¦ | å¹¶å‘ | å¹¶è¡Œ |
|------|------|------|
| å®šä¹‰ | åŒæ—¶å¤„ç†å¤šä¸ªä»»åŠ¡ | åŒæ—¶æ‰§è¡Œå¤šä¸ªä»»åŠ¡ |
| CPU | å•æ ¸æˆ–å¤šæ ¸ | å¿…é¡»å¤šæ ¸ |
| ç›®æ ‡ | ç¨‹åºç»“æ„ | æ‰§è¡Œæ•ˆç‡ |
| å®ç° | æ—¶é—´åˆ†ç‰‡ã€å¼‚æ­¥ | å¤šæ ¸åŒæ—¶è¿è¡Œ |
| ä¾‹å­ | ä¸€ä¸ªäººåˆ‡æ¢åšå¤šä»¶äº‹ | å¤šä¸ªäººåŒæ—¶åšäº‹ |

---

### 2. CSPæ¨¡å‹è¯¦è§£

#### ä»€ä¹ˆæ˜¯CSPï¼Ÿ

CSPï¼ˆCommunicating Sequential Processesï¼Œé€šä¿¡é¡ºåºè¿›ç¨‹ï¼‰æ˜¯ç”±Tony Hoareåœ¨1978å¹´æå‡ºçš„å¹¶å‘æ¨¡å‹ã€‚

**æ ¸å¿ƒæ€æƒ³**:

- **Don't communicate by sharing memory; share memory by communicating**
- ä¸è¦é€šè¿‡å…±äº«å†…å­˜æ¥é€šä¿¡ï¼Œè€Œè¦é€šè¿‡é€šä¿¡æ¥å…±äº«å†…å­˜

#### ä¼ ç»Ÿå…±äº«å†…å­˜æ¨¡å‹

```go
package main

import (
    "fmt"
    "sync"
)

// ä¼ ç»Ÿæ–¹å¼ï¼šä½¿ç”¨å…±äº«å†…å­˜å’Œé”
type Counter struct {
    mu    sync.Mutex
    value int
}

func (c *Counter) Increment() {
    c.mu.Lock()
    c.value++
    c.mu.Unlock()
}

func (c *Counter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}

func traditionalWay() {
    counter := &Counter{}
    var wg sync.WaitGroup
    
    // 100ä¸ªGoroutineåŒæ—¶å¢åŠ è®¡æ•°å™¨
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j < 1000; j++ {
                counter.Increment()
            }
        }()
    }
    
    wg.Wait()
    fmt.Printf("ä¼ ç»Ÿæ–¹å¼ - æœ€ç»ˆè®¡æ•°: %d\n", counter.Value())
}

func main() {
    traditionalWay()
}
```

**é—®é¢˜**:

- éœ€è¦æ˜¾å¼åŠ é”
- å®¹æ˜“æ­»é”
- éš¾ä»¥ç†è§£å’Œç»´æŠ¤
- æ€§èƒ½ç“¶é¢ˆ

#### CSPæ¨¡å‹ï¼ˆGoæ–¹å¼ï¼‰

```go
package main

import (
    "fmt"
)

// CSPæ–¹å¼ï¼šä½¿ç”¨Channelé€šä¿¡
func cspWay() {
    // åˆ›å»ºChannel
    ch := make(chan int)
    done := make(chan bool)
    
    // è®¡æ•°å™¨Goroutineï¼ˆå”¯ä¸€è®¿é—®counterçš„åœ°æ–¹ï¼‰
    go func() {
        counter := 0
        for range ch {
            counter++
        }
        done <- true
    }()
    
    // 100ä¸ªGoroutineå‘é€å¢åŠ è¯·æ±‚
    for i := 0; i < 100; i++ {
        go func() {
            for j := 0; j < 1000; j++ {
                ch <- 1
            }
        }()
    }
    
    // ç­‰å¾…æ‰€æœ‰æ“ä½œå®Œæˆ
    // æ³¨æ„ï¼šè¿™é‡Œç®€åŒ–äº†å®é™…çš„åŒæ­¥é€»è¾‘
    close(ch)
    <-done
    
    fmt.Println("CSPæ–¹å¼å®Œæˆ")
}

func main() {
    cspWay()
}
```

**ä¼˜åŠ¿**:

- æ— éœ€æ˜¾å¼åŠ é”
- é€»è¾‘æ¸…æ™°
- æ˜“äºç†è§£å’Œç»´æŠ¤
- å¤©ç„¶é¿å…ç«æ€æ¡ä»¶

---

### 3. Goå¹¶å‘æ¨¡å‹çš„ä¼˜åŠ¿

#### ä¼˜åŠ¿1ï¼šè½»é‡çº§åç¨‹

```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func goroutineOverhead() {
    // æ‰“å°åˆå§‹å†…å­˜ä½¿ç”¨
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    fmt.Printf("åˆå§‹å†…å­˜: %d KB\n", m.Alloc/1024)
    
    // åˆ›å»º100,000ä¸ªGoroutine
    for i := 0; i < 100000; i++ {
        go func() {
            time.Sleep(10 * time.Second)
        }()
    }
    
    // æ‰“å°å†…å­˜ä½¿ç”¨
    runtime.ReadMemStats(&m)
    fmt.Printf("åˆ›å»º10ä¸‡ä¸ªGoroutineå: %d KB\n", m.Alloc/1024)
    fmt.Printf("å¹³å‡æ¯ä¸ªGoroutine: %d KB\n", m.Alloc/1024/100000)
}

func main() {
    goroutineOverhead()
}
```

**ç‰¹ç‚¹**:

- åˆå§‹æ ˆä»…2KB
- åŠ¨æ€å¢é•¿ï¼ˆæœ€å¤§1GBï¼‰
- åˆ›å»ºé€Ÿåº¦å¿«
- å¯ä»¥åˆ›å»ºæˆåƒä¸Šä¸‡ä¸ª

#### ä¼˜åŠ¿2ï¼šå†…ç½®è°ƒåº¦å™¨

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
)

func schedulerDemo() {
    // æŸ¥çœ‹è°ƒåº¦å™¨å‚æ•°
    fmt.Printf("GOMAXPROCS: %d\n", runtime.GOMAXPROCS(0))
    fmt.Printf("NumGoroutine: %d\n", runtime.NumGoroutine())
    fmt.Printf("NumCPU: %d\n", runtime.NumCPU())
    
    var wg sync.WaitGroup
    
    // åˆ›å»º10ä¸ªGoroutine
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            fmt.Printf("Goroutine %d è¿è¡Œåœ¨çº¿ç¨‹ %d\n", id, runtime.GOMAXPROCS(0))
        }(i)
    }
    
    wg.Wait()
}

func main() {
    schedulerDemo()
}
```

**ç‰¹ç‚¹**:

- G-P-Mè°ƒåº¦æ¨¡å‹
- Work Stealingç®—æ³•
- è‡ªåŠ¨è´Ÿè½½å‡è¡¡
- æŠ¢å å¼è°ƒåº¦

#### ä¼˜åŠ¿3ï¼šChannelåŸè¯­

```go
package main

import (
    "fmt"
    "time"
)

func channelDemo() {
    // æ— ç¼“å†²Channelï¼šåŒæ­¥é€šä¿¡
    ch1 := make(chan string)
    go func() {
        ch1 <- "Hello"
    }()
    msg := <-ch1
    fmt.Println("æ— ç¼“å†²:", msg)
    
    // ç¼“å†²Channelï¼šå¼‚æ­¥é€šä¿¡
    ch2 := make(chan int, 3)
    ch2 <- 1
    ch2 <- 2
    ch2 <- 3
    fmt.Println("ç¼“å†²:", <-ch2, <-ch2, <-ch2)
    
    // selectå¤šè·¯å¤ç”¨
    ch3 := make(chan string)
    ch4 := make(chan string)
    
    go func() {
        time.Sleep(1 * time.Second)
        ch3 <- "from ch3"
    }()
    
    go func() {
        time.Sleep(2 * time.Second)
        ch4 <- "from ch4"
    }()
    
    for i := 0; i < 2; i++ {
        select {
        case msg := <-ch3:
            fmt.Println("select:", msg)
        case msg := <-ch4:
            fmt.Println("select:", msg)
        }
    }
}

func main() {
    channelDemo()
}
```

---

### 4. å¹¶å‘åŸè¯­æ¦‚è§ˆ

Goæä¾›äº†ä¸°å¯Œçš„å¹¶å‘åŸè¯­ï¼š

| åŸè¯­ | ç”¨é€” | ç‰¹ç‚¹ |
|------|------|------|
| `goroutine` | è½»é‡çº§çº¿ç¨‹ | 2KBåˆå§‹æ ˆï¼Œå¿«é€Ÿåˆ›å»º |
| `channel` | é€šä¿¡ç®¡é“ | CSPæ¨¡å‹ï¼Œç±»å‹å®‰å…¨ |
| `select` | å¤šè·¯å¤ç”¨ | åŒæ—¶ç›‘å¬å¤šä¸ªChannel |
| `sync.Mutex` | äº’æ–¥é” | ä¿æŠ¤å…±äº«èµ„æº |
| `sync.RWMutex` | è¯»å†™é” | è¯»å¤šå†™å°‘ä¼˜åŒ– |
| `sync.WaitGroup` | ç­‰å¾…ç»„ | ç­‰å¾…å¤šä¸ªGoroutineå®Œæˆ |
| `sync.Once` | å•æ¬¡æ‰§è¡Œ | ç¡®ä¿ä»£ç åªæ‰§è¡Œä¸€æ¬¡ |
| `sync/atomic` | åŸå­æ“ä½œ | æ— é”æ“ä½œ |
| `context` | ä¸Šä¸‹æ–‡ | è¶…æ—¶ã€å–æ¶ˆã€å€¼ä¼ é€’ |

---

### 5. å¹¶å‘å®‰å…¨

#### ä»€ä¹ˆæ˜¯å¹¶å‘å®‰å…¨ï¼Ÿ

```go
package main

import (
    "fmt"
    "sync"
)

// ä¸å®‰å…¨çš„å¹¶å‘è®¿é—®
func unsafeCounter() {
    counter := 0
    var wg sync.WaitGroup
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter++ // ç«æ€æ¡ä»¶ï¼
        }()
    }
    
    wg.Wait()
    fmt.Printf("ä¸å®‰å…¨è®¡æ•°å™¨: %d (åº”è¯¥æ˜¯1000)\n", counter)
}

// å®‰å…¨çš„å¹¶å‘è®¿é—®
func safeCounter() {
    counter := 0
    var mu sync.Mutex
    var wg sync.WaitGroup
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            mu.Lock()
            counter++
            mu.Unlock()
        }()
    }
    
    wg.Wait()
    fmt.Printf("å®‰å…¨è®¡æ•°å™¨: %d\n", counter)
}

func main() {
    unsafeCounter()
    safeCounter()
}
```

#### æ£€æµ‹ç«æ€æ¡ä»¶

```bash
# ä½¿ç”¨race detector
go run -race main.go
go test -race
go build -race
```

---

## 3. âš ï¸ å¸¸è§é—®é¢˜

### Q1: ä»€ä¹ˆæ—¶å€™åº”è¯¥ä½¿ç”¨å¹¶å‘ï¼Ÿ

**ç­”**:

- I/Oå¯†é›†å‹ä»»åŠ¡ï¼ˆç½‘ç»œè¯·æ±‚ã€æ–‡ä»¶è¯»å†™ï¼‰
- éœ€è¦æé«˜å“åº”æ€§çš„åœºæ™¯
- ä»»åŠ¡å¯ä»¥ç‹¬ç«‹æ‰§è¡Œ
- ä¸è¦ä¸ºäº†å¹¶å‘è€Œå¹¶å‘

### Q2: Goroutineä¼šè‡ªåŠ¨æ¸…ç†å—ï¼Ÿ

**ç­”**:

- Goroutineä¼šåœ¨å‡½æ•°è¿”å›åç»ˆæ­¢
- ä½†å¦‚æœé˜»å¡åœ¨Channelæ“ä½œä¸Šï¼Œä¼šé€ æˆæ³„æ¼
- éœ€è¦æ˜¾å¼ç®¡ç†Goroutineç”Ÿå‘½å‘¨æœŸ

### Q3: Channelå’ŒMutexå¦‚ä½•é€‰æ‹©ï¼Ÿ

**ç­”**:

- ä¼˜å…ˆä½¿ç”¨Channelï¼ˆç¬¦åˆCSPæ¨¡å‹ï¼‰
- Mutexç”¨äºä¿æŠ¤çŸ­æ—¶é—´çš„ä¸´ç•ŒåŒº
- ç®€å•çš„è®¡æ•°å™¨ç”¨atomic

### Q4: å¦‚ä½•é™åˆ¶Goroutineæ•°é‡ï¼Ÿ

**ç­”**:

```go
// ä½¿ç”¨buffered channelä½œä¸ºä¿¡å·é‡
sem := make(chan struct{}, 100) // æœ€å¤š100ä¸ªå¹¶å‘

for i := 0; i < 1000; i++ {
    sem <- struct{}{} // è·å–ä¿¡å·
    go func() {
        defer func() { <-sem }() // é‡Šæ”¾ä¿¡å·
        // æ‰§è¡Œä»»åŠ¡
    }()
}
```

---

## 4. ğŸ“š ç›¸å…³èµ„æº

### æ¨èé˜…è¯»

- [Effective Go - Concurrency](https://go.dev/doc/effective_go#concurrency)
- [Go Concurrency Patterns](https://go.dev/blog/pipelines)
- [CSPè®ºæ–‡åŸæ–‡](https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf)

### ä¸‹ä¸€æ­¥å­¦ä¹ 

- [02-Goroutineæ·±å…¥](./02-Goroutineæ·±å…¥.md) - æ·±å…¥ç†è§£Goroutine
- [03-Channelæ·±å…¥](./03-Channelæ·±å…¥.md) - Channelé«˜çº§ç”¨æ³•
- [Goè°ƒåº¦å™¨](../language/02-å¹¶å‘ç¼–ç¨‹/04-Goè°ƒåº¦å™¨.md) - è°ƒåº¦å™¨åŸç†

---

**æœ€åæ›´æ–°**: 2025-10-27  
**ä½œè€…**: Documentation Team
