# 并发基础概念

**版本**: v1.0
**更新日期**: 2025-11-11
**适用于**: Go 1.25.3

---

## 📋 目录

- [并发基础概念](#并发基础概念)
  - [1. 📖 概念介绍](#1-概念介绍)
  - [2. 🎯 核心知识点](#2-核心知识点)
- [使用race detector](#使用race-detector)
  - [3. ⚠️ 常见问题](#3-️-常见问题)
  - [4. 📚 相关资源](#4-相关资源)

---

## 1. 📖 概念介绍

并发（Concurrency）是Go语言的核心特性之一，也是Go能够高效处理大规模系统的关键。本文将深入讲解并发的基础概念，帮助你建立正确的并发思维模型。

---

## 2. 🎯 核心知识点

### 1. 并发 vs 并行

#### 并发（Concurrency）

**定义**: 同时处理（dealing with）多个任务的能力

```go
package main

import (
    "fmt"
    "time"
)

// 并发示例：一个人同时处理多个任务
func concurrent() {
    // 任务1：下载文件
    go func() {
        fmt.Println("开始下载文件A...")
        time.Sleep(2 * time.Second)
        fmt.Println("文件A下载完成")
    }()

    // 任务2：下载文件
    go func() {
        fmt.Println("开始下载文件B...")
        time.Sleep(1 * time.Second)
        fmt.Println("文件B下载完成")
    }()

    // 任务3：处理用户输入
    fmt.Println("等待下载完成...")
    time.Sleep(3 * time.Second)
}

func main() {
    concurrent()
}
```

**特点**:

- 逻辑上同时进行
- 可以在单核CPU上运行
- 关注程序结构设计
- 通过时间分片实现

#### 并行（Parallelism）

**定义**: 同时执行（doing）多个任务的能力

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
)

// 并行示例：多个CPU核心同时工作
func parallel() {
    // 设置使用所有CPU核心
    runtime.GOMAXPROCS(runtime.NumCPU())

    var wg sync.WaitGroup

    // 在多个核心上并行计算
    for i := 0; i < 4; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()

            // 密集计算任务
            sum := 0
            for j := 0; j < 1000000000; j++ {
                sum += j
            }
            fmt.Printf("Goroutine %d 完成计算，结果: %d\n", id, sum)
        }(i)
    }

    wg.Wait()
}

func main() {
    fmt.Printf("CPU核心数: %d\n", runtime.NumCPU())
    parallel()
}
```

**特点**:

- 物理上同时执行
- 需要多核CPU支持
- 关注执行效率
- 真正的同时运行

#### 关系对比

| 维度 | 并发 | 并行 |
|------|------|------|
| 定义 | 同时处理多个任务 | 同时执行多个任务 |
| CPU | 单核或多核 | 必须多核 |
| 目标 | 程序结构 | 执行效率 |
| 实现 | 时间分片、异步 | 多核同时运行 |
| 例子 | 一个人切换做多件事 | 多个人同时做事 |

---

### 2. CSP模型详解

#### 什么是CSP？

CSP（Communicating Sequential Processes，通信顺序进程）是由Tony Hoare在1978年提出的并发模型。

**核心思想**:

- **Don't communicate by sharing memory; share memory by communicating**
- 不要通过共享内存来通信，而要通过通信来共享内存

#### 传统共享内存模型

```go
package main

import (
    "fmt"
    "sync"
)

// 传统方式：使用共享内存和锁
type Counter struct {
    mu    sync.Mutex
    value int
}

func (c *Counter) Increment() {
    c.mu.Lock()
    c.value++
    c.mu.Unlock()
}

func (c *Counter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}

func traditionalWay() {
    counter := &Counter{}
    var wg sync.WaitGroup

    // 100个Goroutine同时增加计数器
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j < 1000; j++ {
                counter.Increment()
            }
        }()
    }

    wg.Wait()
    fmt.Printf("传统方式 - 最终计数: %d\n", counter.Value())
}

func main() {
    traditionalWay()
}
```

**问题**:

- 需要显式加锁
- 容易死锁
- 难以理解和维护
- 性能瓶颈

#### CSP模型（Go方式）

```go
package main

import (
    "fmt"
)

// CSP方式：使用Channel通信
func cspWay() {
    // 创建Channel
    ch := make(Channel int)
    done := make(Channel bool)

    // 计数器Goroutine（唯一访问counter的地方）
    go func() {
        counter := 0
        for range ch {
            counter++
        }
        done <- true
    }()

    // 100个Goroutine发送增加请求
    for i := 0; i < 100; i++ {
        go func() {
            for j := 0; j < 1000; j++ {
                ch <- 1
            }
        }()
    }

    // 等待所有操作完成
    // 注意：这里简化了实际的同步逻辑
    close(ch)
    <-done

    fmt.Println("CSP方式完成")
}

func main() {
    cspWay()
}
```

**优势**:

- 无需显式加锁
- 逻辑清晰
- 易于理解和维护
- 天然避免竞态条件

---

### 3. Go并发模型的优势

#### 优势1：轻量级协程

```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func goroutineOverhead() {
    // 打印初始内存使用
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    fmt.Printf("初始内存: %d KB\n", m.Alloc/1024)

    // 创建100,000个Goroutine
    for i := 0; i < 100000; i++ {
        go func() {
            time.Sleep(10 * time.Second)
        }()
    }

    // 打印内存使用
    runtime.ReadMemStats(&m)
    fmt.Printf("创建10万个Goroutine后: %d KB\n", m.Alloc/1024)
    fmt.Printf("平均每个Goroutine: %d KB\n", m.Alloc/1024/100000)
}

func main() {
    goroutineOverhead()
}
```

**特点**:

- 初始栈仅2KB
- 动态增长（最大1GB）
- 创建速度快
- 可以创建成千上万个

#### 优势2：内置调度器

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
)

func schedulerDemo() {
    // 查看调度器参数
    fmt.Printf("GOMAXPROCS: %d\n", runtime.GOMAXPROCS(0))
    fmt.Printf("NumGoroutine: %d\n", runtime.NumGoroutine())
    fmt.Printf("NumCPU: %d\n", runtime.NumCPU())

    var wg sync.WaitGroup

    // 创建10个Goroutine
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            fmt.Printf("Goroutine %d 运行在线程 %d\n", id, runtime.GOMAXPROCS(0))
        }(i)
    }

    wg.Wait()
}

func main() {
    schedulerDemo()
}
```

**特点**:

- G-P-M调度模型
- Work Stealing算法
- 自动负载均衡
- 抢占式调度

#### 优势3：Channel原语

```go
package main

import (
    "fmt"
    "time"
)

func channelDemo() {
    // 无缓冲Channel：同步通信
    ch1 := make(Channel string)
    go func() {
        ch1 <- "Hello"
    }()
    msg := <-ch1
    fmt.Println("无缓冲:", msg)

    // 缓冲Channel：异步通信
    ch2 := make(Channel int, 3)
    ch2 <- 1
    ch2 <- 2
    ch2 <- 3
    fmt.Println("缓冲:", <-ch2, <-ch2, <-ch2)

    // select多路复用
    ch3 := make(Channel string)
    ch4 := make(Channel string)

    go func() {
        time.Sleep(1 * time.Second)
        ch3 <- "from ch3"
    }()

    go func() {
        time.Sleep(2 * time.Second)
        ch4 <- "from ch4"
    }()

    for i := 0; i < 2; i++ {
        select {
        case msg := <-ch3:
            fmt.Println("select:", msg)
        case msg := <-ch4:
            fmt.Println("select:", msg)
        }
    }
}

func main() {
    channelDemo()
}
```

---

### 4. 并发原语概览

Go提供了丰富的并发原语：

| 原语 | 用途 | 特点 |
|------|------|------|
| `Goroutine` | 轻量级线程 | 2KB初始栈，快速创建 |
| `Channel` | 通信管道 | CSP模型，类型安全 |
| `select` | 多路复用 | 同时监听多个Channel |
| `sync.Mutex` | Mutex | 保护共享资源 |
| `sync.RWMutex` | 读写锁 | 读多写少优化 |
| `sync.WaitGroup` | WaitGroup | 等待多个Goroutine完成 |
| `sync.Once` | 单次执行 | 确保代码只执行一次 |
| `sync/atomic` | 原子操作 | 无锁操作 |
| `Context` | Context | 超时、取消、值传递 |

---

### 5. 并发安全

#### 什么是并发安全？

```go
package main

import (
    "fmt"
    "sync"
)

// 不安全的并发访问
func unsafeCounter() {
    counter := 0
    var wg sync.WaitGroup

    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter++ // 竞态条件！
        }()
    }

    wg.Wait()
    fmt.Printf("不安全计数器: %d (应该是1000)\n", counter)
}

// 安全的并发访问
func safeCounter() {
    counter := 0
    var mu sync.Mutex
    var wg sync.WaitGroup

    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            mu.Lock()
            counter++
            mu.Unlock()
        }()
    }

    wg.Wait()
    fmt.Printf("安全计数器: %d\n", counter)
}

func main() {
    unsafeCounter()
    safeCounter()
}
```

#### 检测竞态条件

```bash
# 使用race detector
go run -race main.go
go test -race
go build -race
```

---

## 3. ⚠️ 常见问题

### Q1: 什么时候应该使用并发？

- I/O密集型任务（网络请求、文件读写）
- 需要提高响应性的场景
- 任务可以独立执行
- 不要为了并发而并发

### Q2: Goroutine会自动清理吗？

**答**:

- Goroutine会在函数返回后终止
- 但如果阻塞在Channel操作上，会造成泄漏
- 需要显式管理Goroutine生命周期

### Q3: Channel和Mutex如何选择？

**答**:

- 优先使用Channel（符合CSP模型）
- Mutex用于保护短时间的临界区
- 简单的计数器用atomic

### Q4: 如何限制Goroutine数量？

**答**:

```go
// 使用buffered channel作为信号量
sem := make(Channel struct{}, 100) // 最多100个并发

for i := 0; i < 1000; i++ {
    sem <- struct{}{} // 获取信号
    go func() {
        defer func() { <-sem }() // 释放信号
        // 执行任务
    }()
}
```

---

## 4. 📚 相关资源

### 推荐阅读

- [Effective Go - Concurrency](https://go.dev/doc/effective_go#concurrency)
- [Go Concurrency Patterns](https://go.dev/blog/pipelines)
- [CSP论文原文](https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf)

### 下一步学习
