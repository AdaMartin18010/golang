# 02-常用算法

> Go语言中常用算法的实现与应用

---

## 📋 目录

- [📚 章节概览](#章节概览)
- [1. 排序算法](#1.-排序算法)
  - [1.1 冒泡排序 (Bubble Sort)](#1.1-冒泡排序-bubble-sort)
  - [1.2 快速排序 (Quick Sort)](#1.2-快速排序-quick-sort)
  - [1.3 归并排序 (Merge Sort)](#1.3-归并排序-merge-sort)
- [2. 查找算法](#2.-查找算法)
  - [2.1 二分查找 (Binary Search)](#2.1-二分查找-binary-search)
- [3. 字符串算法](#3.-字符串算法)
  - [3.1 KMP算法（字符串匹配）](#3.1-kmp算法字符串匹配)
- [4. 动态规划](#4.-动态规划)
  - [4.1 斐波那契数列](#4.1-斐波那契数列)
  - [4.2 最长公共子序列 (LCS)](#4.2-最长公共子序列-lcs)
  - [4.3 背包问题](#4.3-背包问题)
- [5. 贪心算法](#5.-贪心算法)
  - [5.1 活动选择问题](#5.1-活动选择问题)
- [6. 回溯算法](#6.-回溯算法)
  - [6.1 全排列](#6.1-全排列)
- [💡 算法总结](#算法总结)
  - [时间复杂度对比](#时间复杂度对比)
  - [应用场景](#应用场景)
- [🔗 相关章节](#相关章节)

## 📚 章节概览

本章介绍Go语言中的常用算法，包括排序算法、查找算法、字符串算法、动态规划和贪心算法等。

---

## 1. 排序算法

### 1.1 冒泡排序 (Bubble Sort)

**时间复杂度**: O(n²)  
**空间复杂度**: O(1)  
**稳定性**: 稳定

```go
package main

import "fmt"

// 冒泡排序
func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        swapped := false
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = true
            }
        }
        // 如果没有交换，说明已经有序
        if !swapped {
            break
        }
    }
}

func main() {
    arr := []int{64, 34, 25, 12, 22, 11, 90}
    bubbleSort(arr)
    fmt.Println("排序后:", arr)
}
```

### 1.2 快速排序 (Quick Sort)

**时间复杂度**: O(n log n) 平均，O(n²) 最坏  
**空间复杂度**: O(log n)  
**稳定性**: 不稳定

```go
package main

import "fmt"

// 快速排序
func quickSort(arr []int, low, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    }
}

// 分区函数
func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low - 1
    
    for j := low; j < high; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

func main() {
    arr := []int{10, 7, 8, 9, 1, 5}
    quickSort(arr, 0, len(arr)-1)
    fmt.Println("排序后:", arr)
}
```

### 1.3 归并排序 (Merge Sort)

**时间复杂度**: O(n log n)  
**空间复杂度**: O(n)  
**稳定性**: 稳定

```go
package main

import "fmt"

// 归并排序
func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])
    
    return merge(left, right)
}

// 合并两个有序数组
func merge(left, right []int) []int {
    result := make([]int, 0, len(left)+len(right))
    i, j := 0, 0
    
    for i < len(left) && j < len(right) {
        if left[i] <= right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }
    
    result = append(result, left[i:]...)
    result = append(result, right[j:]...)
    
    return result
}

func main() {
    arr := []int{38, 27, 43, 3, 9, 82, 10}
    sorted := mergeSort(arr)
    fmt.Println("排序后:", sorted)
}
```

---

## 2. 查找算法

### 2.1 二分查找 (Binary Search)

**时间复杂度**: O(log n)  
**空间复杂度**: O(1)  
**前提**: 数组必须有序

```go
package main

import "fmt"

// 二分查找（迭代）
func binarySearch(arr []int, target int) int {
    left, right := 0, len(arr)-1
    
    for left <= right {
        mid := left + (right-left)/2
        
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return -1 // 未找到
}

// 二分查找（递归）
func binarySearchRecursive(arr []int, target, left, right int) int {
    if left > right {
        return -1
    }
    
    mid := left + (right-left)/2
    
    if arr[mid] == target {
        return mid
    } else if arr[mid] < target {
        return binarySearchRecursive(arr, target, mid+1, right)
    } else {
        return binarySearchRecursive(arr, target, left, mid-1)
    }
}

func main() {
    arr := []int{2, 3, 4, 10, 40}
    target := 10
    
    result := binarySearch(arr, target)
    if result != -1 {
        fmt.Printf("元素 %d 在索引 %d\n", target, result)
    } else {
        fmt.Println("元素未找到")
    }
}
```

---

## 3. 字符串算法

### 3.1 KMP算法（字符串匹配）

**时间复杂度**: O(n + m)  
**空间复杂度**: O(m)

```go
package main

import "fmt"

// 构建部分匹配表
func buildNext(pattern string) []int {
    m := len(pattern)
    next := make([]int, m)
    next[0] = -1
    
    i, j := 0, -1
    for i < m-1 {
        if j == -1 || pattern[i] == pattern[j] {
            i++
            j++
            next[i] = j
        } else {
            j = next[j]
        }
    }
    
    return next
}

// KMP字符串匹配
func kmpSearch(text, pattern string) int {
    if len(pattern) == 0 {
        return 0
    }
    
    next := buildNext(pattern)
    i, j := 0, 0
    
    for i < len(text) && j < len(pattern) {
        if j == -1 || text[i] == pattern[j] {
            i++
            j++
        } else {
            j = next[j]
        }
        
        if j == len(pattern) {
            return i - j
        }
    }
    
    return -1
}

func main() {
    text := "ABABDABACDABABCABAB"
    pattern := "ABABCABAB"
    
    pos := kmpSearch(text, pattern)
    if pos != -1 {
        fmt.Printf("模式串在位置 %d 找到\n", pos)
    } else {
        fmt.Println("模式串未找到")
    }
}
```

---

## 4. 动态规划

### 4.1 斐波那契数列

```go
package main

import "fmt"

// 递归方法（效率低）
func fibRecursive(n int) int {
    if n <= 1 {
        return n
    }
    return fibRecursive(n-1) + fibRecursive(n-2)
}

// 动态规划（自底向上）
func fibDP(n int) int {
    if n <= 1 {
        return n
    }
    
    dp := make([]int, n+1)
    dp[0], dp[1] = 0, 1
    
    for i := 2; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    
    return dp[n]
}

// 空间优化版本
func fibOptimized(n int) int {
    if n <= 1 {
        return n
    }
    
    prev, curr := 0, 1
    for i := 2; i <= n; i++ {
        prev, curr = curr, prev+curr
    }
    
    return curr
}

func main() {
    n := 10
    fmt.Printf("Fibonacci(%d) = %d\n", n, fibDP(n))
}
```

### 4.2 最长公共子序列 (LCS)

```go
package main

import "fmt"

// 最长公共子序列
func longestCommonSubsequence(text1, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    text1 := "abcde"
    text2 := "ace"
    
    result := longestCommonSubsequence(text1, text2)
    fmt.Printf("最长公共子序列长度: %d\n", result)
}
```

### 4.3 背包问题

```go
package main

import "fmt"

// 0-1背包问题
func knapsack(weights, values []int, capacity int) int {
    n := len(weights)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, capacity+1)
    }
    
    for i := 1; i <= n; i++ {
        for w := 1; w <= capacity; w++ {
            if weights[i-1] <= w {
                // 取max(不放入, 放入)
                dp[i][w] = max(
                    dp[i-1][w],
                    dp[i-1][w-weights[i-1]]+values[i-1],
                )
            } else {
                dp[i][w] = dp[i-1][w]
            }
        }
    }
    
    return dp[n][capacity]
}

func main() {
    weights := []int{1, 3, 4, 5}
    values := []int{1, 4, 5, 7}
    capacity := 7
    
    maxValue := knapsack(weights, values, capacity)
    fmt.Printf("最大价值: %d\n", maxValue)
}
```

---

## 5. 贪心算法

### 5.1 活动选择问题

```go
package main

import (
    "fmt"
    "sort"
)

type Activity struct {
    start int
    end   int
}

// 按结束时间排序
func activitySelection(activities []Activity) []Activity {
    // 按结束时间排序
    sort.Slice(activities, func(i, j int) bool {
        return activities[i].end < activities[j].end
    })
    
    result := []Activity{activities[0]}
    lastEnd := activities[0].end
    
    for i := 1; i < len(activities); i++ {
        if activities[i].start >= lastEnd {
            result = append(result, activities[i])
            lastEnd = activities[i].end
        }
    }
    
    return result
}

func main() {
    activities := []Activity{
        {1, 4}, {3, 5}, {0, 6},
        {5, 7}, {3, 9}, {5, 9},
        {6, 10}, {8, 11}, {8, 12},
        {2, 14}, {12, 16},
    }
    
    selected := activitySelection(activities)
    fmt.Printf("选择的活动数: %d\n", len(selected))
    for _, act := range selected {
        fmt.Printf("[%d, %d] ", act.start, act.end)
    }
}
```

---

## 6. 回溯算法

### 6.1 全排列

```go
package main

import "fmt"

// 全排列
func permute(nums []int) [][]int {
    result := [][]int{}
    backtrack(nums, []int{}, &result)
    return result
}

func backtrack(nums []int, path []int, result *[][]int) {
    if len(path) == len(nums) {
        temp := make([]int, len(path))
        copy(temp, path)
        *result = append(*result, temp)
        return
    }
    
    for i := 0; i < len(nums); i++ {
        if contains(path, nums[i]) {
            continue
        }
        path = append(path, nums[i])
        backtrack(nums, path, result)
        path = path[:len(path)-1]
    }
}

func contains(slice []int, val int) bool {
    for _, v := range slice {
        if v == val {
            return true
        }
    }
    return false
}

func main() {
    nums := []int{1, 2, 3}
    result := permute(nums)
    fmt.Println("全排列:", result)
}
```

---

## 💡 算法总结

### 时间复杂度对比

| 算法 | 最好 | 平均 | 最坏 | 空间 |
|------|------|------|------|------|
| 冒泡排序 | O(n) | O(n²) | O(n²) | O(1) |
| 快速排序 | O(n log n) | O(n log n) | O(n²) | O(log n) |
| 归并排序 | O(n log n) | O(n log n) | O(n log n) | O(n) |
| 二分查找 | O(1) | O(log n) | O(log n) | O(1) |

### 应用场景

| 算法类型 | 适用场景 |
|---------|---------|
| **排序** | 数据整理、优先级队列 |
| **查找** | 快速定位、去重 |
| **字符串** | 文本处理、模式匹配 |
| **动态规划** | 最优化问题、路径问题 |
| **贪心** | 局部最优解、调度问题 |
| **回溯** | 组合问题、约束满足 |

---

## 🔗 相关章节

- [01-基础数据结构](01-基础数据结构.md) - 数据结构基础
- [03-算法模式](03-算法模式.md) - 常见解题模式
- [04-实战案例](04-实战案例.md) - LeetCode题目

---

**维护者**: Documentation Team  
**创建日期**: 2025-10-22  
**最后更新**: 2025-10-29  
**文档状态**: ✅ 完成
