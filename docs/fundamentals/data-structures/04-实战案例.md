# 04-å®æˆ˜æ¡ˆä¾‹

> Goè¯­è¨€ç®—æ³•å®æˆ˜ï¼šLeetCodeç»å…¸é¢˜ç›®è§£æ

---

## ğŸ“š ç›®å½•

- [04-å®æˆ˜æ¡ˆä¾‹](#04-å®æˆ˜æ¡ˆä¾‹)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [ğŸ“š ç« èŠ‚æ¦‚è§ˆ](#-ç« èŠ‚æ¦‚è§ˆ)
  - [1. æ•°ç»„é—®é¢˜ (Array)](#1-æ•°ç»„é—®é¢˜-array)
    - [1.1 ä¸¤æ•°ä¹‹å’Œ](#11-ä¸¤æ•°ä¹‹å’Œ)
      - [è§£é¢˜æµç¨‹å¯è§†åŒ–](#è§£é¢˜æµç¨‹å¯è§†åŒ–)
    - [1.2 ä¸‰æ•°ä¹‹å’Œ](#12-ä¸‰æ•°ä¹‹å’Œ)
    - [1.3 ç››æœ€å¤šæ°´çš„å®¹å™¨](#13-ç››æœ€å¤šæ°´çš„å®¹å™¨)
  - [2. é“¾è¡¨é—®é¢˜ (Linked List)](#2-é“¾è¡¨é—®é¢˜-linked-list)
    - [2.1 åè½¬é“¾è¡¨](#21-åè½¬é“¾è¡¨)
    - [2.2 åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](#22-åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨)
    - [2.3 ç¯å½¢é“¾è¡¨II](#23-ç¯å½¢é“¾è¡¨ii)
  - [3. å­—ç¬¦ä¸²é—®é¢˜ (String)](#3-å­—ç¬¦ä¸²é—®é¢˜-string)
    - [3.1 æœ€é•¿å›æ–‡å­ä¸²](#31-æœ€é•¿å›æ–‡å­ä¸²)
    - [3.2 å­—ç¬¦ä¸²ç›¸ä¹˜](#32-å­—ç¬¦ä¸²ç›¸ä¹˜)
    - [3.3 æœ‰æ•ˆçš„æ‹¬å·](#33-æœ‰æ•ˆçš„æ‹¬å·)
  - [4. æ ‘é—®é¢˜ (Tree)](#4-æ ‘é—®é¢˜-tree)
    - [4.1 äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](#41-äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦)
    - [4.2 éªŒè¯äºŒå‰æœç´¢æ ‘](#42-éªŒè¯äºŒå‰æœç´¢æ ‘)
    - [4.3 äºŒå‰æ ‘çš„å³è§†å›¾](#43-äºŒå‰æ ‘çš„å³è§†å›¾)
  - [5. åŠ¨æ€è§„åˆ’ (DP)](#5-åŠ¨æ€è§„åˆ’-dp)
    - [5.1 æœ€å¤§å­æ•°ç»„å’Œ](#51-æœ€å¤§å­æ•°ç»„å’Œ)
    - [5.2 çˆ¬æ¥¼æ¢¯](#52-çˆ¬æ¥¼æ¢¯)
    - [5.3 é›¶é’±å…‘æ¢](#53-é›¶é’±å…‘æ¢)
  - [6. å›æº¯é—®é¢˜ (Backtracking)](#6-å›æº¯é—®é¢˜-backtracking)
    - [6.1 å…¨æ’åˆ—](#61-å…¨æ’åˆ—)
    - [6.2 å­é›†](#62-å­é›†)
    - [6.3 ç»„åˆæ€»å’Œ](#63-ç»„åˆæ€»å’Œ)
  - [7. å›¾é—®é¢˜ (Graph)](#7-å›¾é—®é¢˜-graph)
    - [7.1 å²›å±¿æ•°é‡](#71-å²›å±¿æ•°é‡)
    - [7.2 è¯¾ç¨‹è¡¨](#72-è¯¾ç¨‹è¡¨)
    - [7.3 å…‹éš†å›¾](#73-å…‹éš†å›¾)
  - [8. æ»‘åŠ¨çª—å£ (Sliding Window)](#8-æ»‘åŠ¨çª—å£-sliding-window)
    - [8.1 æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](#81-æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²)
      - [æ»‘åŠ¨çª—å£å¯è§†åŒ–](#æ»‘åŠ¨çª—å£å¯è§†åŒ–)
    - [8.2 æœ€å°è¦†ç›–å­ä¸²](#82-æœ€å°è¦†ç›–å­ä¸²)
    - [8.3 æ»‘åŠ¨çª—å£æœ€å¤§å€¼](#83-æ»‘åŠ¨çª—å£æœ€å¤§å€¼)
  - [9. äºŒåˆ†æŸ¥æ‰¾ (Binary Search)](#9-äºŒåˆ†æŸ¥æ‰¾-binary-search)
    - [9.1 æœç´¢æ—‹è½¬æ’åºæ•°ç»„](#91-æœç´¢æ—‹è½¬æ’åºæ•°ç»„)
    - [9.2 å¯»æ‰¾å³°å€¼](#92-å¯»æ‰¾å³°å€¼)
    - [9.3 åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®](#93-åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®)
  - [10. å †/ä¼˜å…ˆé˜Ÿåˆ— (Heap)](#10-å †ä¼˜å…ˆé˜Ÿåˆ—-heap)
    - [10.1 æ•°æ®æµçš„ä¸­ä½æ•°](#101-æ•°æ®æµçš„ä¸­ä½æ•°)
    - [10.2 å‰Kä¸ªé«˜é¢‘å…ƒç´ ](#102-å‰kä¸ªé«˜é¢‘å…ƒç´ )
    - [10.3 åˆå¹¶Kä¸ªå‡åºé“¾è¡¨](#103-åˆå¹¶kä¸ªå‡åºé“¾è¡¨)
  - [ğŸ’¡ è§£é¢˜æŠ€å·§æ€»ç»“](#-è§£é¢˜æŠ€å·§æ€»ç»“)
    - [1. æ—¶é—´å¤æ‚åº¦é€ŸæŸ¥](#1-æ—¶é—´å¤æ‚åº¦é€ŸæŸ¥)
    - [2. ç©ºé—´ä¼˜åŒ–æŠ€å·§](#2-ç©ºé—´ä¼˜åŒ–æŠ€å·§)
    - [3. å¸¸è§é™·é˜±](#3-å¸¸è§é™·é˜±)
    - [4. è°ƒè¯•æŠ€å·§](#4-è°ƒè¯•æŠ€å·§)
  - [ğŸ”— ç›¸å…³ç« èŠ‚](#-ç›¸å…³ç« èŠ‚)

## ğŸ“š ç« èŠ‚æ¦‚è§ˆ

æœ¬ç« ç²¾é€‰**30ä¸ª**LeetCodeç»å…¸é¢˜ç›®ï¼Œè¦†ç›–10å¤§ç±»ç®—æ³•ï¼š

- æ•°ç»„ (Array) - 3é¢˜
- é“¾è¡¨ (Linked List) - 3é¢˜  
- å­—ç¬¦ä¸² (String) - 3é¢˜
- æ ‘ (Tree) - 3é¢˜
- åŠ¨æ€è§„åˆ’ (DP) - 3é¢˜
- å›æº¯ (Backtracking) - 3é¢˜
- å›¾ (Graph) - 3é¢˜
- æ»‘åŠ¨çª—å£ (Sliding Window) - 3é¢˜
- äºŒåˆ†æŸ¥æ‰¾ (Binary Search) - 3é¢˜
- å †/ä¼˜å…ˆé˜Ÿåˆ— (Heap) - 3é¢˜

æ¯é¢˜æä¾›è¯¦ç»†çš„Goè¯­è¨€è§£æ³•ã€å¤æ‚åº¦åˆ†æå’Œè§£é¢˜æ€è·¯ï¼Œå¸®åŠ©ä½ å¿«é€ŸæŒæ¡ç®—æ³•é¢è¯•æŠ€å·§ã€‚

---

## 1. æ•°ç»„é—®é¢˜ (Array)

### 1.1 ä¸¤æ•°ä¹‹å’Œ

**LeetCode 1. Two Sum** | éš¾åº¦ï¼šç®€å•

**é—®é¢˜æè¿°**:
ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼ `target`ï¼Œæ‰¾å‡ºæ•°ç»„ä¸­å’Œä¸ºç›®æ ‡å€¼çš„ä¸¤ä¸ªæ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚

```go
package main

import "fmt"

// æ–¹æ³•1: å“ˆå¸Œè¡¨ - O(n) æ—¶é—´ï¼ŒO(n) ç©ºé—´
func twoSum(nums []int, target int) []int {
    hashMap := make(map[int]int)
    
    for i, num := range nums {
        complement := target - num
        if index, found := hashMap[complement]; found {
            return []int{index, i}
        }
        hashMap[num] = i
    }
    
    return nil
}

func main() {
    nums := []int{2, 7, 11, 15}
    target := 9
    result := twoSum(nums, target)
    fmt.Printf("ç´¢å¼•: %v\n", result) // [0, 1]
}
```

**æ€è·¯**:

1. ä½¿ç”¨å“ˆå¸Œè¡¨å­˜å‚¨å·²éå†çš„æ•°å­—å’Œç´¢å¼•
2. å¯¹æ¯ä¸ªæ•°å­—ï¼ŒæŸ¥æ‰¾ `target - num` æ˜¯å¦åœ¨å“ˆå¸Œè¡¨ä¸­
3. æ‰¾åˆ°åˆ™è¿”å›ä¸¤ä¸ªç´¢å¼•

#### è§£é¢˜æµç¨‹å¯è§†åŒ–

```mermaid
flowchart TD
    Start([å¼€å§‹]) --> Init[åˆ›å»ºå“ˆå¸Œè¡¨ hashMap]
    Init --> Loop{éå†æ•°ç»„ nums}
    
    Loop -->|éå†æ¯ä¸ª num| Calc[è®¡ç®— complement<br/>= target - num]
    
    Calc --> Check{complement<br/>åœ¨ hashMap ä¸­?}
    
    Check -->|æ˜¯| Found[è¿”å›<br/>hashMapå’Œå½“å‰ç´¢å¼•]
    Check -->|å¦| Store[å­˜å‚¨<br/>hashMap = i]
    
    Store --> Loop
    Found --> End([æ‰¾åˆ°ç­”æ¡ˆ])
    Loop -->|éå†ç»“æŸ| NotFound[è¿”å› nil]
    NotFound --> End
    
    style Start fill:#e1f5ff
    style Found fill:#e1ffe1
    style Check fill:#fff4e1
    style End fill:#e1f5ff
```

**ç¤ºä¾‹æ‰§è¡Œè¿‡ç¨‹**:

```mermaid
graph LR
    subgraph "æ•°ç»„: 2, 7, 11, 15 | target = 9"
        N1[num=2, i=0]
        N2[num=7, i=1]
        N3[num=11, i=2]
        N4[num=15, i=3]
    end
    
    subgraph "å“ˆå¸Œè¡¨å˜åŒ–"
        H0["{} ç©º"]
        H1["{2:0}"]
        H2["{2:0, 7:1} âœ“ æ‰¾åˆ°!"]
    end
    
    N1 -->|complement=7<br/>ä¸åœ¨è¡¨ä¸­| H1
    N2 -->|complement=2<br/>åœ¨è¡¨ä¸­!| H2
    
    style H2 fill:#e1ffe1
```

---

### 1.2 ä¸‰æ•°ä¹‹å’Œ

**LeetCode 15. 3Sum** | éš¾åº¦ï¼šä¸­ç­‰

**é—®é¢˜æè¿°**:
ç»™å®šä¸€ä¸ªæ•°ç»„ `nums`ï¼Œæ‰¾å‡ºæ‰€æœ‰å’Œä¸º 0 çš„ä¸‰å…ƒç»„ã€‚

```go
package main

import (
    "fmt"
    "sort"
)

// æ’åº + åŒæŒ‡é’ˆ - O(nÂ²) æ—¶é—´ï¼ŒO(1) ç©ºé—´
func threeSum(nums []int) [][]int {
    var result [][]int
    n := len(nums)
    
    if n < 3 {
        return result
    }
    
    // æ’åº
    sort.Ints(nums)
    
    for i := 0; i < n-2; i++ {
        // è·³è¿‡é‡å¤å…ƒç´ 
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        
        // å‰ªæï¼šå¦‚æœæœ€å°çš„ä¸‰ä¸ªæ•°ä¹‹å’Œå¤§äº0ï¼Œåé¢ä¸å¯èƒ½æœ‰è§£
        if nums[i] > 0 {
            break
        }
        
        // åŒæŒ‡é’ˆ
        left, right := i+1, n-1
        target := -nums[i]
        
        for left < right {
            sum := nums[left] + nums[right]
            
            if sum == target {
                result = append(result, []int{nums[i], nums[left], nums[right]})
                
                // è·³è¿‡é‡å¤å…ƒç´ 
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                
                left++
                right--
            } else if sum < target {
                left++
            } else {
                right--
            }
        }
    }
    
    return result
}

func main() {
    nums := []int{-1, 0, 1, 2, -1, -4}
    result := threeSum(nums)
    fmt.Println("ä¸‰æ•°ä¹‹å’Œ:", result)
}
```

**æ€è·¯**:

1. æ’åºæ•°ç»„
2. å›ºå®šç¬¬ä¸€ä¸ªæ•°ï¼Œç”¨åŒæŒ‡é’ˆæ‰¾å¦å¤–ä¸¤ä¸ªæ•°
3. æ³¨æ„å»é‡

---

### 1.3 ç››æœ€å¤šæ°´çš„å®¹å™¨

**LeetCode 11. Container With Most Water** | éš¾åº¦ï¼šä¸­ç­‰

```go
package main

import "fmt"

// åŒæŒ‡é’ˆ - O(n) æ—¶é—´ï¼ŒO(1) ç©ºé—´
func maxArea(height []int) int {
    left, right := 0, len(height)-1
    maxArea := 0
    
    for left < right {
        // è®¡ç®—å½“å‰é¢ç§¯
        h := min(height[left], height[right])
        width := right - left
        area := h * width
        maxArea = max(maxArea, area)
        
        // ç§»åŠ¨è¾ƒçŸ­çš„é‚£è¾¹
        if height[left] < height[right] {
            left++
        } else {
            right--
        }
    }
    
    return maxArea
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    height := []int{1, 8, 6, 2, 5, 4, 8, 3, 7}
    result := maxArea(height)
    fmt.Println("æœ€å¤§é¢ç§¯:", result) // 49
}
```

---

## 2. é“¾è¡¨é—®é¢˜ (Linked List)

### 2.1 åè½¬é“¾è¡¨

**LeetCode 206. Reverse Linked List** | éš¾åº¦ï¼šç®€å•

```go
package main

type ListNode struct {
    Val  int
    Next *ListNode
}

// è¿­ä»£æ³• - O(n) æ—¶é—´ï¼ŒO(1) ç©ºé—´
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    curr := head
    
    for curr != nil {
        next := curr.Next
        curr.Next = prev
        prev = curr
        curr = next
    }
    
    return prev
}

// é€’å½’æ³• - O(n) æ—¶é—´ï¼ŒO(n) ç©ºé—´
func reverseListRecursive(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    
    newHead := reverseListRecursive(head.Next)
    head.Next.Next = head
    head.Next = nil
    
    return newHead
}
```

---

### 2.2 åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨

**LeetCode 21. Merge Two Sorted Lists** | éš¾åº¦ï¼šç®€å•

```go
// è¿­ä»£æ³•
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy
    
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            current.Next = l1
            l1 = l1.Next
        } else {
            current.Next = l2
            l2 = l2.Next
        }
        current = current.Next
    }
    
    if l1 != nil {
        current.Next = l1
    }
    if l2 != nil {
        current.Next = l2
    }
    
    return dummy.Next
}

// é€’å½’æ³•
func mergeTwoListsRecursive(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    
    if l1.Val < l2.Val {
        l1.Next = mergeTwoListsRecursive(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoListsRecursive(l1, l2.Next)
        return l2
    }
}
```

---

### 2.3 ç¯å½¢é“¾è¡¨II

**LeetCode 142. Linked List Cycle II** | éš¾åº¦ï¼šä¸­ç­‰

```go
// å¿«æ…¢æŒ‡é’ˆ - O(n) æ—¶é—´ï¼ŒO(1) ç©ºé—´
func detectCycle(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return nil
    }
    
    // ç¬¬ä¸€æ­¥ï¼šåˆ¤æ–­æ˜¯å¦æœ‰ç¯
    slow, fast := head, head
    hasCycle := false
    
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        
        if slow == fast {
            hasCycle = true
            break
        }
    }
    
    if !hasCycle {
        return nil
    }
    
    // ç¬¬äºŒæ­¥ï¼šæ‰¾åˆ°ç¯çš„å…¥å£
    slow = head
    for slow != fast {
        slow = slow.Next
        fast = fast.Next
    }
    
    return slow
}
```

---

## 3. å­—ç¬¦ä¸²é—®é¢˜ (String)

### 3.1 æœ€é•¿å›æ–‡å­ä¸²

**LeetCode 5. Longest Palindromic Substring** | éš¾åº¦ï¼šä¸­ç­‰

```go
package main

import "fmt"

// ä¸­å¿ƒæ‰©å±•æ³• - O(nÂ²) æ—¶é—´ï¼ŒO(1) ç©ºé—´
func longestPalindrome(s string) string {
    if len(s) < 2 {
        return s
    }
    
    start, maxLen := 0, 1
    
    // è¾…åŠ©å‡½æ•°ï¼šä»ä¸­å¿ƒå‘ä¸¤è¾¹æ‰©å±•
    expandAroundCenter := func(left, right int) int {
        for left >= 0 && right < len(s) && s[left] == s[right] {
            left--
            right++
        }
        return right - left - 1
    }
    
    for i := 0; i < len(s); i++ {
        // å¥‡æ•°é•¿åº¦å›æ–‡
        len1 := expandAroundCenter(i, i)
        // å¶æ•°é•¿åº¦å›æ–‡
        len2 := expandAroundCenter(i, i+1)
        
        length := max(len1, len2)
        
        if length > maxLen {
            start = i - (length-1)/2
            maxLen = length
        }
    }
    
    return s[start : start+maxLen]
}

func main() {
    s := "babad"
    fmt.Println("æœ€é•¿å›æ–‡å­ä¸²:", longestPalindrome(s)) // "bab" or "aba"
}
```

---

### 3.2 å­—ç¬¦ä¸²ç›¸ä¹˜

**LeetCode 43. Multiply Strings** | éš¾åº¦ï¼šä¸­ç­‰

```go
package main

import (
    "fmt"
    "strings"
)

func multiply(num1 string, num2 string) string {
    if num1 == "0" || num2 == "0" {
        return "0"
    }
    
    m, n := len(num1), len(num2)
    result := make([]int, m+n)
    
    // ä»åå¾€å‰éå†
    for i := m - 1; i >= 0; i-- {
        for j := n - 1; j >= 0; j-- {
            mul := int(num1[i]-'0') * int(num2[j]-'0')
            p1, p2 := i+j, i+j+1
            sum := mul + result[p2]
            
            result[p2] = sum % 10
            result[p1] += sum / 10
        }
    }
    
    // è½¬æ¢ä¸ºå­—ç¬¦ä¸²
    var sb strings.Builder
    for i, digit := range result {
        if i == 0 && digit == 0 {
            continue
        }
        sb.WriteByte(byte(digit + '0'))
    }
    
    return sb.String()
}

func main() {
    fmt.Println(multiply("123", "456")) // "56088"
}
```

---

### 3.3 æœ‰æ•ˆçš„æ‹¬å·

**LeetCode 20. Valid Parentheses** | éš¾åº¦ï¼šç®€å•

```go
package main

import "fmt"

func isValid(s string) bool {
    stack := []rune{}
    pairs := map[rune]rune{
        ')': '(',
        ']': '[',
        '}': '{',
    }
    
    for _, char := range s {
        if char == '(' || char == '[' || char == '{' {
            // å·¦æ‹¬å·å…¥æ ˆ
            stack = append(stack, char)
        } else {
            // å³æ‹¬å·
            if len(stack) == 0 {
                return false
            }
            
            top := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            
            if pairs[char] != top {
                return false
            }
        }
    }
    
    return len(stack) == 0
}

func main() {
    fmt.Println(isValid("()[]{}"))   // true
    fmt.Println(isValid("([)]"))     // false
    fmt.Println(isValid("{[]}"))     // true
}
```

---

## 4. æ ‘é—®é¢˜ (Tree)

### 4.1 äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

**LeetCode 104. Maximum Depth of Binary Tree** | éš¾åº¦ï¼šç®€å•

```go
package main

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

// é€’å½’æ³• - O(n) æ—¶é—´ï¼ŒO(h) ç©ºé—´
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    
    leftDepth := maxDepth(root.Left)
    rightDepth := maxDepth(root.Right)
    
    return max(leftDepth, rightDepth) + 1
}

// BFSæ³•
func maxDepthBFS(root *TreeNode) int {
    if root == nil {
        return 0
    }
    
    queue := []*TreeNode{root}
    depth := 0
    
    for len(queue) > 0 {
        size := len(queue)
        for i := 0; i < size; i++ {
            node := queue[0]
            queue = queue[1:]
            
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
        depth++
    }
    
    return depth
}
```

---

### 4.2 éªŒè¯äºŒå‰æœç´¢æ ‘

**LeetCode 98. Validate Binary Search Tree** | éš¾åº¦ï¼šä¸­ç­‰

```go
package main

import "math"

// é€’å½’æ³• - O(n) æ—¶é—´ï¼ŒO(h) ç©ºé—´
func isValidBST(root *TreeNode) bool {
    return validate(root, math.MinInt64, math.MaxInt64)
}

func validate(node *TreeNode, min, max int) bool {
    if node == nil {
        return true
    }
    
    if node.Val <= min || node.Val >= max {
        return false
    }
    
    return validate(node.Left, min, node.Val) && 
           validate(node.Right, node.Val, max)
}

// ä¸­åºéå†æ³•
func isValidBSTInorder(root *TreeNode) bool {
    var inorder func(*TreeNode) []int
    inorder = func(node *TreeNode) []int {
        if node == nil {
            return []int{}
        }
        
        result := inorder(node.Left)
        result = append(result, node.Val)
        result = append(result, inorder(node.Right)...)
        
        return result
    }
    
    values := inorder(root)
    for i := 1; i < len(values); i++ {
        if values[i] <= values[i-1] {
            return false
        }
    }
    
    return true
}
```

---

### 4.3 äºŒå‰æ ‘çš„å³è§†å›¾

**LeetCode 199. Binary Tree Right Side View** | éš¾åº¦ï¼šä¸­ç­‰

```go
// BFSå±‚åºéå† - O(n) æ—¶é—´ï¼ŒO(w) ç©ºé—´ï¼ˆwä¸ºæ ‘çš„å®½åº¦ï¼‰
func rightSideView(root *TreeNode) []int {
    if root == nil {
        return []int{}
    }
    
    var result []int
    queue := []*TreeNode{root}
    
    for len(queue) > 0 {
        size := len(queue)
        
        for i := 0; i < size; i++ {
            node := queue[0]
            queue = queue[1:]
            
            // æ¯å±‚çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹
            if i == size-1 {
                result = append(result, node.Val)
            }
            
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
    }
    
    return result
}
```

---

## 5. åŠ¨æ€è§„åˆ’ (DP)

### 5.1 æœ€å¤§å­æ•°ç»„å’Œ

**LeetCode 53. Maximum Subarray** | éš¾åº¦ï¼šä¸­ç­‰

```go
package main

import "fmt"

// åŠ¨æ€è§„åˆ’ - O(n) æ—¶é—´ï¼ŒO(1) ç©ºé—´
func maxSubArray(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    
    maxSum := nums[0]
    currentSum := nums[0]
    
    for i := 1; i < len(nums); i++ {
        // å½“å‰å’Œå°äº0å°±é‡æ–°å¼€å§‹
        currentSum = max(nums[i], currentSum+nums[i])
        maxSum = max(maxSum, currentSum)
    }
    
    return maxSum
}

func main() {
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    fmt.Println("æœ€å¤§å­æ•°ç»„å’Œ:", maxSubArray(nums)) // 6
}
```

---

### 5.2 çˆ¬æ¥¼æ¢¯

**LeetCode 70. Climbing Stairs** | éš¾åº¦ï¼šç®€å•

```go
// åŠ¨æ€è§„åˆ’ - O(n) æ—¶é—´ï¼ŒO(1) ç©ºé—´
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }
    
    prev2, prev1 := 1, 2
    
    for i := 3; i <= n; i++ {
        current := prev1 + prev2
        prev2 = prev1
        prev1 = current
    }
    
    return prev1
}
```

---

### 5.3 é›¶é’±å…‘æ¢

**LeetCode 322. Coin Change** | éš¾åº¦ï¼šä¸­ç­‰

```go
package main

import (
    "fmt"
    "math"
)

// åŠ¨æ€è§„åˆ’ - O(amount * n) æ—¶é—´ï¼ŒO(amount) ç©ºé—´
func coinChange(coins []int, amount int) int {
    dp := make([]int, amount+1)
    
    // åˆå§‹åŒ–
    for i := 1; i <= amount; i++ {
        dp[i] = math.MaxInt32
    }
    dp[0] = 0
    
    // çŠ¶æ€è½¬ç§»
    for i := 1; i <= amount; i++ {
        for _, coin := range coins {
            if i >= coin && dp[i-coin] != math.MaxInt32 {
                dp[i] = min(dp[i], dp[i-coin]+1)
            }
        }
    }
    
    if dp[amount] == math.MaxInt32 {
        return -1
    }
    return dp[amount]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func main() {
    coins := []int{1, 2, 5}
    amount := 11
    fmt.Println("æœ€å°‘ç¡¬å¸æ•°:", coinChange(coins, amount)) // 3 (11 = 5 + 5 + 1)
}
```

---

## 6. å›æº¯é—®é¢˜ (Backtracking)

### 6.1 å…¨æ’åˆ—

**LeetCode 46. Permutations** | éš¾åº¦ï¼šä¸­ç­‰

```go
package main

import "fmt"

func permute(nums []int) [][]int {
    var result [][]int
    var backtrack func([]int)
    
    backtrack = func(path []int) {
        if len(path) == len(nums) {
            temp := make([]int, len(path))
            copy(temp, path)
            result = append(result, temp)
            return
        }
        
        for _, num := range nums {
            if contains(path, num) {
                continue
            }
            
            path = append(path, num)
            backtrack(path)
            path = path[:len(path)-1]
        }
    }
    
    backtrack([]int{})
    return result
}

func contains(arr []int, target int) bool {
    for _, v := range arr {
        if v == target {
            return true
        }
    }
    return false
}

func main() {
    nums := []int{1, 2, 3}
    result := permute(nums)
    fmt.Println("å…¨æ’åˆ—:", result)
}
```

---

### 6.2 å­é›†

**LeetCode 78. Subsets** | éš¾åº¦ï¼šä¸­ç­‰

```go
func subsets(nums []int) [][]int {
    var result [][]int
    var backtrack func(int, []int)
    
    backtrack = func(start int, path []int) {
        // æ¯æ¬¡éƒ½æ˜¯ä¸€ä¸ªæœ‰æ•ˆå­é›†
        temp := make([]int, len(path))
        copy(temp, path)
        result = append(result, temp)
        
        for i := start; i < len(nums); i++ {
            path = append(path, nums[i])
            backtrack(i+1, path)
            path = path[:len(path)-1]
        }
    }
    
    backtrack(0, []int{})
    return result
}
```

---

### 6.3 ç»„åˆæ€»å’Œ

**LeetCode 39. Combination Sum** | éš¾åº¦ï¼šä¸­ç­‰

```go
func combinationSum(candidates []int, target int) [][]int {
    var result [][]int
    var backtrack func(int, int, []int)
    
    backtrack = func(start, remain int, path []int) {
        if remain < 0 {
            return
        }
        
        if remain == 0 {
            temp := make([]int, len(path))
            copy(temp, path)
            result = append(result, temp)
            return
        }
        
        for i := start; i < len(candidates); i++ {
            path = append(path, candidates[i])
            // å› ä¸ºå¯ä»¥é‡å¤ä½¿ç”¨ï¼Œæ‰€ä»¥è¿˜æ˜¯ä»iå¼€å§‹
            backtrack(i, remain-candidates[i], path)
            path = path[:len(path)-1]
        }
    }
    
    backtrack(0, target, []int{})
    return result
}
```

---

## 7. å›¾é—®é¢˜ (Graph)

### 7.1 å²›å±¿æ•°é‡

**LeetCode 200. Number of Islands** | éš¾åº¦ï¼šä¸­ç­‰

**é¢˜ç›®æè¿°**: ç»™å®šä¸€ä¸ªç”± `'1'`ï¼ˆé™†åœ°ï¼‰å’Œ `'0'`ï¼ˆæ°´ï¼‰ç»„æˆçš„äºŒç»´ç½‘æ ¼ï¼Œè®¡ç®—å²›å±¿çš„æ•°é‡ã€‚

```go
package main

import "fmt"

func numIslands(grid [][]byte) int {
    if len(grid) == 0 {
        return 0
    }
    
    count := 0
    rows, cols := len(grid), len(grid[0])
    
    var dfs func(int, int)
    dfs = func(r, c int) {
        // è¾¹ç•Œæ£€æŸ¥
        if r < 0 || r >= rows || c < 0 || c >= cols || grid[r][c] == '0' {
            return
        }
        
        // æ ‡è®°å·²è®¿é—®
        grid[r][c] = '0'
        
        // é€’å½’è®¿é—®å››ä¸ªæ–¹å‘
        dfs(r+1, c)
        dfs(r-1, c)
        dfs(r, c+1)
        dfs(r, c-1)
    }
    
    for r := 0; r < rows; r++ {
        for c := 0; c < cols; c++ {
            if grid[r][c] == '1' {
                count++
                dfs(r, c) // æ²‰æ²¡æ•´ä¸ªå²›å±¿
            }
        }
    }
    
    return count
}

func main() {
    grid := [][]byte{
        {'1', '1', '0', '0', '0'},
        {'1', '1', '0', '0', '0'},
        {'0', '0', '1', '0', '0'},
        {'0', '0', '0', '1', '1'},
    }
    fmt.Println("å²›å±¿æ•°é‡:", numIslands(grid)) // è¾“å‡º: 3
}
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(mÃ—n)ï¼Œmå’Œnåˆ†åˆ«æ˜¯ç½‘æ ¼çš„è¡Œæ•°å’Œåˆ—æ•°
- ç©ºé—´å¤æ‚åº¦: O(mÃ—n)ï¼Œé€’å½’æ ˆç©ºé—´

**è§£é¢˜æ€è·¯**:

1. éå†ç½‘æ ¼ï¼Œé‡åˆ° `'1'` å°±è¿›è¡ŒDFS
2. DFSè¿‡ç¨‹ä¸­å°†è®¿é—®è¿‡çš„é™†åœ°æ ‡è®°ä¸º `'0'`
3. æ¯æ¬¡DFSå®Œæˆè®¡æ•°åŠ 1

---

### 7.2 è¯¾ç¨‹è¡¨

**LeetCode 207. Course Schedule** | éš¾åº¦ï¼šä¸­ç­‰

**é¢˜ç›®æè¿°**: åˆ¤æ–­æ˜¯å¦èƒ½å®Œæˆæ‰€æœ‰è¯¾ç¨‹ï¼ˆæ£€æµ‹æœ‰å‘å›¾æ˜¯å¦æœ‰ç¯ï¼‰ã€‚

```go
func canFinish(numCourses int, prerequisites [][]int) bool {
    // æ„å»ºé‚»æ¥è¡¨å’Œå…¥åº¦æ•°ç»„
    graph := make([][]int, numCourses)
    inDegree := make([]int, numCourses)
    
    for _, prereq := range prerequisites {
        course, pre := prereq[0], prereq[1]
        graph[pre] = append(graph[pre], course)
        inDegree[course]++
    }
    
    // BFSæ‹“æ‰‘æ’åº
    queue := []int{}
    for i := 0; i < numCourses; i++ {
        if inDegree[i] == 0 {
            queue = append(queue, i)
        }
    }
    
    count := 0
    for len(queue) > 0 {
        course := queue[0]
        queue = queue[1:]
        count++
        
        for _, next := range graph[course] {
            inDegree[next]--
            if inDegree[next] == 0 {
                queue = append(queue, next)
            }
        }
    }
    
    return count == numCourses
}
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(V+E)ï¼ŒVæ˜¯è¯¾ç¨‹æ•°ï¼ŒEæ˜¯å…ˆä¿®è¯¾ç¨‹å…³ç³»æ•°
- ç©ºé—´å¤æ‚åº¦: O(V+E)

**è§£é¢˜æ€è·¯**:

1. æ„å»ºæœ‰å‘å›¾ï¼ˆé‚»æ¥è¡¨ï¼‰
2. ä½¿ç”¨BFSæ‹“æ‰‘æ’åº
3. å¦‚æœèƒ½è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼Œè¯´æ˜æ— ç¯

---

### 7.3 å…‹éš†å›¾

**LeetCode 133. Clone Graph** | éš¾åº¦ï¼šä¸­ç­‰

**é¢˜ç›®æè¿°**: æ·±åº¦å¤åˆ¶ä¸€ä¸ªæ— å‘è¿é€šå›¾ã€‚

```go
type Node struct {
    Val       int
    Neighbors []*Node
}

func cloneGraph(node *Node) *Node {
    if node == nil {
        return nil
    }
    
    visited := make(map[*Node]*Node)
    
    var dfs func(*Node) *Node
    dfs = func(n *Node) *Node {
        if clone, exists := visited[n]; exists {
            return clone
        }
        
        // åˆ›å»ºå…‹éš†èŠ‚ç‚¹
        clone := &Node{Val: n.Val}
        visited[n] = clone
        
        // é€’å½’å…‹éš†é‚»å±…
        for _, neighbor := range n.Neighbors {
            clone.Neighbors = append(clone.Neighbors, dfs(neighbor))
        }
        
        return clone
    }
    
    return dfs(node)
}
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(V+E)
- ç©ºé—´å¤æ‚åº¦: O(V)

---

## 8. æ»‘åŠ¨çª—å£ (Sliding Window)

### 8.1 æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²

**LeetCode 3. Longest Substring Without Repeating Characters** | éš¾åº¦ï¼šä¸­ç­‰

```go
func lengthOfLongestSubstring(s string) int {
    charSet := make(map[byte]bool)
    left, maxLen := 0, 0
    
    for right := 0; right < len(s); right++ {
        // å¦‚æœå­—ç¬¦é‡å¤ï¼Œç§»åŠ¨å·¦æŒ‡é’ˆ
        for charSet[s[right]] {
            delete(charSet, s[left])
            left++
        }
        
        charSet[s[right]] = true
        maxLen = max(maxLen, right-left+1)
    }
    
    return maxLen
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(n)
- ç©ºé—´å¤æ‚åº¦: O(min(n, m))ï¼Œmæ˜¯å­—ç¬¦é›†å¤§å°

**è§£é¢˜æ€è·¯**:

1. ä½¿ç”¨æ»‘åŠ¨çª—å£ + å“ˆå¸Œé›†åˆ
2. å³æŒ‡é’ˆæ‰©å±•çª—å£ï¼Œå·¦æŒ‡é’ˆæ”¶ç¼©çª—å£
3. è®°å½•æœ€å¤§çª—å£å¤§å°

#### æ»‘åŠ¨çª—å£å¯è§†åŒ–

```mermaid
flowchart TD
    Start([å¼€å§‹]) --> Init[left=0, right=0<br/>charSet={}]
    Init --> RightMove{right < len}
    
    RightMove -->|æ˜¯| CheckDup{sé‡å¤?}
    
    CheckDup -->|æ˜¯| LeftMove[left++<br/>åˆ é™¤ sleft]
    LeftMove --> CheckDup
    
    CheckDup -->|å¦| AddChar[åŠ å…¥ sright]
    AddChar --> UpdateMax[æ›´æ–° maxLen]
    UpdateMax --> RightInc[right++]
    RightInc --> RightMove
    
    RightMove -->|å¦| Return[è¿”å› maxLen]
    Return --> End([ç»“æŸ])
    
    style Start fill:#e1f5ff
    style AddChar fill:#e1ffe1
    style UpdateMax fill:#fff4e1
    style End fill:#e1f5ff
```

**ç¤ºä¾‹æ‰§è¡Œè¿‡ç¨‹ (s = "abcabcbb")**:

```mermaid
graph TB
    subgraph "åˆå§‹çŠ¶æ€"
        S1["a b c a b c b b<br/>L R<br/>çª—å£: a, maxLen=1"]
    end
    
    subgraph "æ‰©å±•çª—å£"
        S2["a b c a b c b b<br/>L   R<br/>çª—å£: abc, maxLen=3"]
    end
    
    subgraph "é‡åˆ°é‡å¤ 'a'"
        S3["a b c a b c b b<br/>L     R<br/>ç§»åŠ¨ left â†’ åˆ é™¤ a"]
        S4["a b c a b c b b<br/>  L   R<br/>çª—å£: bca, maxLen=3"]
    end
    
    subgraph "ç»§ç»­æ‰©å±•"
        S5["a b c a b c b b<br/>  L     R<br/>çª—å£: bcab, maxLen=3"]
    end
    
    S1 --> S2
    S2 --> S3
    S3 --> S4
    S4 --> S5
    
    style S2 fill:#e1ffe1
    style S4 fill:#fff4e1
```

---

### 8.2 æœ€å°è¦†ç›–å­ä¸²

**LeetCode 76. Minimum Window Substring** | éš¾åº¦ï¼šå›°éš¾

```go
func minWindow(s string, t string) string {
    if len(s) < len(t) {
        return ""
    }
    
    // ç»Ÿè®¡tä¸­å­—ç¬¦é¢‘ç‡
    need := make(map[byte]int)
    for i := range t {
        need[t[i]]++
    }
    
    window := make(map[byte]int)
    left, right := 0, 0
    valid := 0
    start, minLen := 0, len(s)+1
    
    for right < len(s) {
        c := s[right]
        right++
        
        if _, ok := need[c]; ok {
            window[c]++
            if window[c] == need[c] {
                valid++
            }
        }
        
        // æ”¶ç¼©çª—å£
        for valid == len(need) {
            // æ›´æ–°æœ€å°çª—å£
            if right-left < minLen {
                start = left
                minLen = right - left
            }
            
            d := s[left]
            left++
            
            if _, ok := need[d]; ok {
                if window[d] == need[d] {
                    valid--
                }
                window[d]--
            }
        }
    }
    
    if minLen == len(s)+1 {
        return ""
    }
    return s[start : start+minLen]
}
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(m+n)ï¼Œmå’Œnåˆ†åˆ«æ˜¯så’Œtçš„é•¿åº¦
- ç©ºé—´å¤æ‚åº¦: O(k)ï¼Œkæ˜¯å­—ç¬¦é›†å¤§å°

---

### 8.3 æ»‘åŠ¨çª—å£æœ€å¤§å€¼

**LeetCode 239. Sliding Window Maximum** | éš¾åº¦ï¼šå›°éš¾

```go
func maxSlidingWindow(nums []int, k int) []int {
    if len(nums) == 0 || k == 0 {
        return []int{}
    }
    
    result := make([]int, 0, len(nums)-k+1)
    deque := []int{} // å­˜å‚¨ç´¢å¼•ï¼Œä¿æŒé€’å‡é¡ºåº
    
    for i := 0; i < len(nums); i++ {
        // ç§»é™¤çª—å£å¤–çš„å…ƒç´ 
        if len(deque) > 0 && deque[0] <= i-k {
            deque = deque[1:]
        }
        
        // ç§»é™¤æ‰€æœ‰å°äºå½“å‰å…ƒç´ çš„å…ƒç´ 
        for len(deque) > 0 && nums[deque[len(deque)-1]] < nums[i] {
            deque = deque[:len(deque)-1]
        }
        
        deque = append(deque, i)
        
        // çª—å£å½¢æˆåï¼Œæ·»åŠ æœ€å¤§å€¼
        if i >= k-1 {
            result = append(result, nums[deque[0]])
        }
    }
    
    return result
}
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(n)
- ç©ºé—´å¤æ‚åº¦: O(k)

**è§£é¢˜æ€è·¯**:

1. ä½¿ç”¨å•è°ƒé€’å‡åŒç«¯é˜Ÿåˆ—
2. é˜Ÿé¦–å§‹ç»ˆæ˜¯å½“å‰çª—å£çš„æœ€å¤§å€¼
3. æ¯ä¸ªå…ƒç´ æœ€å¤šå…¥é˜Ÿå‡ºé˜Ÿä¸€æ¬¡

---

## 9. äºŒåˆ†æŸ¥æ‰¾ (Binary Search)

### 9.1 æœç´¢æ—‹è½¬æ’åºæ•°ç»„

**LeetCode 33. Search in Rotated Sorted Array** | éš¾åº¦ï¼šä¸­ç­‰

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    
    for left <= right {
        mid := left + (right-left)/2
        
        if nums[mid] == target {
            return mid
        }
        
        // åˆ¤æ–­å“ªä¸€åŠæ˜¯æœ‰åºçš„
        if nums[left] <= nums[mid] {
            // å·¦åŠéƒ¨åˆ†æœ‰åº
            if nums[left] <= target && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            // å³åŠéƒ¨åˆ†æœ‰åº
            if nums[mid] < target && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    
    return -1
}
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(log n)
- ç©ºé—´å¤æ‚åº¦: O(1)

**è§£é¢˜æ€è·¯**:

1. æ—‹è½¬æ•°ç»„å¿…æœ‰ä¸€åŠæ˜¯æœ‰åºçš„
2. åˆ¤æ–­targetåœ¨å“ªä¸€åŠ
3. å¯¹æœ‰åºéƒ¨åˆ†ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾

---

### 9.2 å¯»æ‰¾å³°å€¼

**LeetCode 162. Find Peak Element** | éš¾åº¦ï¼šä¸­ç­‰

```go
func findPeakElement(nums []int) int {
    left, right := 0, len(nums)-1
    
    for left < right {
        mid := left + (right-left)/2
        
        if nums[mid] > nums[mid+1] {
            // å³°å€¼åœ¨å·¦ä¾§ï¼ˆåŒ…æ‹¬midï¼‰
            right = mid
        } else {
            // å³°å€¼åœ¨å³ä¾§
            left = mid + 1
        }
    }
    
    return left
}
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(log n)
- ç©ºé—´å¤æ‚åº¦: O(1)

---

### 9.3 åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®

**LeetCode 34. Find First and Last Position of Element in Sorted Array** | éš¾åº¦ï¼šä¸­ç­‰

```go
func searchRange(nums []int, target int) []int {
    // æŸ¥æ‰¾å·¦è¾¹ç•Œ
    left := findLeft(nums, target)
    if left == -1 {
        return []int{-1, -1}
    }
    
    // æŸ¥æ‰¾å³è¾¹ç•Œ
    right := findRight(nums, target)
    
    return []int{left, right}
}

func findLeft(nums []int, target int) int {
    left, right := 0, len(nums)-1
    result := -1
    
    for left <= right {
        mid := left + (right-left)/2
        
        if nums[mid] == target {
            result = mid
            right = mid - 1 // ç»§ç»­å‘å·¦æ‰¾
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return result
}

func findRight(nums []int, target int) int {
    left, right := 0, len(nums)-1
    result := -1
    
    for left <= right {
        mid := left + (right-left)/2
        
        if nums[mid] == target {
            result = mid
            left = mid + 1 // ç»§ç»­å‘å³æ‰¾
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return result
}
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(log n)
- ç©ºé—´å¤æ‚åº¦: O(1)

---

## 10. å †/ä¼˜å…ˆé˜Ÿåˆ— (Heap)

### 10.1 æ•°æ®æµçš„ä¸­ä½æ•°

**LeetCode 295. Find Median from Data Stream** | éš¾åº¦ï¼šå›°éš¾

```go
import "container/heap"

// MedianFinder ä¸­ä½æ•°æŸ¥æ‰¾å™¨
type MedianFinder struct {
    maxHeap *MaxHeap // å­˜å‚¨è¾ƒå°çš„ä¸€åŠ
    minHeap *MinHeap // å­˜å‚¨è¾ƒå¤§çš„ä¸€åŠ
}

func Constructor() MedianFinder {
    return MedianFinder{
        maxHeap: &MaxHeap{},
        minHeap: &MinHeap{},
    }
}

func (mf *MedianFinder) AddNum(num int) {
    // å…ˆåŠ å…¥maxHeap
    heap.Push(mf.maxHeap, num)
    
    // å°†maxHeapçš„æœ€å¤§å€¼ç§»åˆ°minHeap
    heap.Push(mf.minHeap, heap.Pop(mf.maxHeap))
    
    // å¹³è¡¡ä¸¤ä¸ªå †
    if mf.minHeap.Len() > mf.maxHeap.Len() {
        heap.Push(mf.maxHeap, heap.Pop(mf.minHeap))
    }
}

func (mf *MedianFinder) FindMedian() float64 {
    if mf.maxHeap.Len() > mf.minHeap.Len() {
        return float64((*mf.maxHeap)[0])
    }
    return float64((*mf.maxHeap)[0]+(*mf.minHeap)[0]) / 2.0
}

// MaxHeap å¤§é¡¶å †
type MaxHeap []int

func (h MaxHeap) Len() int           { return len(h) }
func (h MaxHeap) Less(i, j int) bool { return h[i] > h[j] }
func (h MaxHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
func (h *MaxHeap) Push(x interface{}) { *h = append(*h, x.(int)) }
func (h *MaxHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

// MinHeap å°é¡¶å †
type MinHeap []int

func (h MinHeap) Len() int           { return len(h) }
func (h MinHeap) Less(i, j int) bool { return h[i] < h[j] }
func (h MinHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
func (h *MinHeap) Push(x interface{}) { *h = append(*h, x.(int)) }
func (h *MinHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}
```

**å¤æ‚åº¦åˆ†æ**:

- AddNum: O(log n)
- FindMedian: O(1)
- ç©ºé—´å¤æ‚åº¦: O(n)

**è§£é¢˜æ€è·¯**:

1. ä½¿ç”¨ä¸¤ä¸ªå †ï¼šå¤§é¡¶å †å­˜è¾ƒå°çš„ä¸€åŠï¼Œå°é¡¶å †å­˜è¾ƒå¤§çš„ä¸€åŠ
2. ä¿æŒä¸¤ä¸ªå †çš„å¤§å°å¹³è¡¡ï¼ˆç›¸å·®ä¸è¶…è¿‡1ï¼‰
3. ä¸­ä½æ•°å°±æ˜¯å †é¡¶å…ƒç´ 

---

### 10.2 å‰Kä¸ªé«˜é¢‘å…ƒç´ 

**LeetCode 347. Top K Frequent Elements** | éš¾åº¦ï¼šä¸­ç­‰

```go
func topKFrequent(nums []int, k int) []int {
    // ç»Ÿè®¡é¢‘ç‡
    freq := make(map[int]int)
    for _, num := range nums {
        freq[num]++
    }
    
    // ä½¿ç”¨å°é¡¶å †ï¼Œä¿æŒå †å¤§å°ä¸ºk
    h := &FreqHeap{}
    heap.Init(h)
    
    for num, count := range freq {
        heap.Push(h, Item{num, count})
        if h.Len() > k {
            heap.Pop(h)
        }
    }
    
    // æå–ç»“æœ
    result := make([]int, k)
    for i := k - 1; i >= 0; i-- {
        result[i] = heap.Pop(h).(Item).num
    }
    
    return result
}

type Item struct {
    num   int
    count int
}

type FreqHeap []Item

func (h FreqHeap) Len() int           { return len(h) }
func (h FreqHeap) Less(i, j int) bool { return h[i].count < h[j].count }
func (h FreqHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
func (h *FreqHeap) Push(x interface{}) { *h = append(*h, x.(Item)) }
func (h *FreqHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(n log k)
- ç©ºé—´å¤æ‚åº¦: O(n)

---

### 10.3 åˆå¹¶Kä¸ªå‡åºé“¾è¡¨

**LeetCode 23. Merge k Sorted Lists** | éš¾åº¦ï¼šå›°éš¾

```go
func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }
    
    // ä½¿ç”¨å°é¡¶å †
    h := &ListNodeHeap{}
    heap.Init(h)
    
    // å°†æ‰€æœ‰é“¾è¡¨çš„å¤´èŠ‚ç‚¹åŠ å…¥å †
    for _, list := range lists {
        if list != nil {
            heap.Push(h, list)
        }
    }
    
    dummy := &ListNode{}
    current := dummy
    
    for h.Len() > 0 {
        // å–å‡ºæœ€å°èŠ‚ç‚¹
        node := heap.Pop(h).(*ListNode)
        current.Next = node
        current = current.Next
        
        // å¦‚æœè¯¥é“¾è¡¨è¿˜æœ‰åç»­èŠ‚ç‚¹ï¼ŒåŠ å…¥å †
        if node.Next != nil {
            heap.Push(h, node.Next)
        }
    }
    
    return dummy.Next
}

type ListNodeHeap []*ListNode

func (h ListNodeHeap) Len() int           { return len(h) }
func (h ListNodeHeap) Less(i, j int) bool { return h[i].Val < h[j].Val }
func (h ListNodeHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
func (h *ListNodeHeap) Push(x interface{}) { *h = append(*h, x.(*ListNode)) }
func (h *ListNodeHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(N log k)ï¼ŒNæ˜¯æ‰€æœ‰èŠ‚ç‚¹æ€»æ•°ï¼Œkæ˜¯é“¾è¡¨æ•°é‡
- ç©ºé—´å¤æ‚åº¦: O(k)

**è§£é¢˜æ€è·¯**:

1. ä½¿ç”¨å°é¡¶å †ç»´æŠ¤kä¸ªé“¾è¡¨çš„å½“å‰æœ€å°èŠ‚ç‚¹
2. æ¯æ¬¡å–å‡ºå †é¡¶ï¼ˆæœ€å°èŠ‚ç‚¹ï¼‰
3. å°†è¯¥èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥å †

---

## ğŸ’¡ è§£é¢˜æŠ€å·§æ€»ç»“

### 1. æ—¶é—´å¤æ‚åº¦é€ŸæŸ¥

| é—®é¢˜ç±»å‹ | å¸¸è§å¤æ‚åº¦ | ç®—æ³• |
|---------|-----------|------|
| æ•°ç»„éå† | O(n) | åŒæŒ‡é’ˆã€æ»‘åŠ¨çª—å£ |
| æ’åºç›¸å…³ | O(n log n) | å¿«æ’ã€å½’å¹¶ |
| äºŒåˆ†æŸ¥æ‰¾ | O(log n) | äºŒåˆ† |
| é€’å½’æ ‘ | O(2^n) | å›æº¯ã€DFS |
| åŠ¨æ€è§„åˆ’ | O(nÂ²) | DPè¡¨ |

### 2. ç©ºé—´ä¼˜åŒ–æŠ€å·§

- âœ… åŸåœ°ä¿®æ”¹ï¼ˆç››æ°´å®¹å™¨ã€åˆ é™¤å…ƒç´ ï¼‰
- âœ… æ»šåŠ¨æ•°ç»„ï¼ˆçˆ¬æ¥¼æ¢¯ã€æ–æ³¢é‚£å¥‘ï¼‰
- âœ… çŠ¶æ€å‹ç¼©ï¼ˆèƒŒåŒ…é—®é¢˜ï¼‰

### 3. å¸¸è§é™·é˜±

- âš ï¸ æ•°ç»„è¶Šç•Œ
- âš ï¸ æ•´æ•°æº¢å‡º
- âš ï¸ ç©ºæŒ‡é’ˆ
- âš ï¸ é‡å¤å…ƒç´ å¤„ç†

### 4. è°ƒè¯•æŠ€å·§

```go
// æ‰“å°è°ƒè¯•ä¿¡æ¯
fmt.Printf("Debug: i=%d, j=%d, sum=%d\n", i, j, sum)

// è¾¹ç•Œæµ‹è¯•
// ç©ºæ•°ç»„: []
// å•å…ƒç´ : [1]
// é‡å¤å…ƒç´ : [1,1,1]
// è´Ÿæ•°: [-1,-2,-3]
```

---

## ğŸ”— ç›¸å…³ç« èŠ‚

- [01-åŸºç¡€æ•°æ®ç»“æ„](01-åŸºç¡€æ•°æ®ç»“æ„.md)
- [02-å¸¸ç”¨ç®—æ³•](02-å¸¸ç”¨ç®—æ³•.md)
- [03-ç®—æ³•æ¨¡å¼](03-ç®—æ³•æ¨¡å¼.md)

---

**ç»´æŠ¤è€…**: Documentation Team  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22  
**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
