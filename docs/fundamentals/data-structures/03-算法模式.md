# 03-ç®—æ³•æ¨¡å¼

> Goè¯­è¨€å¸¸è§ç®—æ³•è§£é¢˜æ¨¡å¼ä¸æŠ€å·§

---

## ğŸ“‹ ç›®å½•

- [03-ç®—æ³•æ¨¡å¼](#03-ç®—æ³•æ¨¡å¼)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“š ç« èŠ‚æ¦‚è§ˆ](#-ç« èŠ‚æ¦‚è§ˆ)
  - [1. åŒæŒ‡é’ˆæ¨¡å¼](#1-åŒæŒ‡é’ˆæ¨¡å¼)
    - [1.1 å¯¹æ’æŒ‡é’ˆ](#11-å¯¹æ’æŒ‡é’ˆ)
    - [1.2 å¿«æ…¢æŒ‡é’ˆ](#12-å¿«æ…¢æŒ‡é’ˆ)
    - [1.3 æ»‘åŠ¨çª—å£](#13-æ»‘åŠ¨çª—å£)
  - [2. é€’å½’ä¸åˆ†æ²»](#2-é€’å½’ä¸åˆ†æ²»)
    - [2.1 ç»å…¸é€’å½’](#21-ç»å…¸é€’å½’)
    - [2.2 åˆ†æ²»ç®—æ³•](#22-åˆ†æ²»ç®—æ³•)
  - [3. åŠ¨æ€è§„åˆ’æ¨¡å¼](#3-åŠ¨æ€è§„åˆ’æ¨¡å¼)
    - [3.1 åŠ¨æ€è§„åˆ’è§£é¢˜æµç¨‹](#31-åŠ¨æ€è§„åˆ’è§£é¢˜æµç¨‹)
    - [3.2 çº¿æ€§DPç¤ºä¾‹](#32-çº¿æ€§dpç¤ºä¾‹)
    - [3.2 åŒºé—´DP](#32-åŒºé—´dp)
  - [4. æœç´¢ç®—æ³•](#4-æœç´¢ç®—æ³•)
    - [4.1 DFS vs BFS å¯è§†åŒ–å¯¹æ¯”](#41-dfs-vs-bfs-å¯è§†åŒ–å¯¹æ¯”)
      - [å›æº¯ç®—æ³•æµç¨‹å›¾](#å›æº¯ç®—æ³•æµç¨‹å›¾)
    - [4.2 DFSæ·±åº¦ä¼˜å…ˆå®ç°](#42-dfsæ·±åº¦ä¼˜å…ˆå®ç°)
    - [4.3 BFSå¹¿åº¦ä¼˜å…ˆå®ç°](#43-bfså¹¿åº¦ä¼˜å…ˆå®ç°)
  - [5. è´ªå¿ƒç­–ç•¥](#5-è´ªå¿ƒç­–ç•¥)
    - [5.1 åŒºé—´è°ƒåº¦](#51-åŒºé—´è°ƒåº¦)
    - [5.2 æ•°å­—è´ªå¿ƒ](#52-æ•°å­—è´ªå¿ƒ)
  - [6. ä½è¿ç®—æŠ€å·§](#6-ä½è¿ç®—æŠ€å·§)
    - [6.1 åŸºæœ¬æŠ€å·§](#61-åŸºæœ¬æŠ€å·§)
    - [6.2 å®æˆ˜åº”ç”¨](#62-å®æˆ˜åº”ç”¨)
  - [ğŸ’¡ ç®—æ³•é€‰æ‹©æŒ‡å—](#-ç®—æ³•é€‰æ‹©æŒ‡å—)
    - [é—®é¢˜ç±»å‹è¯†åˆ«](#é—®é¢˜ç±»å‹è¯†åˆ«)
    - [æ—¶é—´å¤æ‚åº¦å‚è€ƒ](#æ—¶é—´å¤æ‚åº¦å‚è€ƒ)
  - [ğŸ”— ç›¸å…³ç« èŠ‚](#-ç›¸å…³ç« èŠ‚)

## ğŸ“š ç« èŠ‚æ¦‚è§ˆ

æœ¬ç« æ€»ç»“Goè¯­è¨€ä¸­å¸¸è§çš„ç®—æ³•è§£é¢˜æ¨¡å¼ï¼Œå¸®åŠ©å¿«é€Ÿè¯†åˆ«é—®é¢˜ç±»å‹å¹¶é€‰æ‹©åˆé€‚çš„è§£å†³æ–¹æ¡ˆã€‚

---

## 1. åŒæŒ‡é’ˆæ¨¡å¼

### 1.1 å¯¹æ’æŒ‡é’ˆ

**é€‚ç”¨åœºæ™¯**: æœ‰åºæ•°ç»„ã€å­—ç¬¦ä¸²å›æ–‡ã€ä¸¤æ•°ä¹‹å’Œ

```go
package main

import "fmt"

// ä¸¤æ•°ä¹‹å’Œï¼ˆæœ‰åºæ•°ç»„ï¼‰
func twoSum(numbers []int, target int) []int {
    left, right := 0, len(numbers)-1

    for left < right {
        sum := numbers[left] + numbers[right]
        if sum == target {
            return []int{left, right}
        } else if sum < target {
            left++
        } else {
            right--
        }
    }

    return nil
}

// åˆ¤æ–­å›æ–‡ä¸²
func isPalindrome(s string) bool {
    left, right := 0, len(s)-1

    for left < right {
        if s[left] != s[right] {
            return false
        }
        left++
        right--
    }

    return true
}

// åè½¬æ•°ç»„
func reverseArray(arr []int) {
    left, right := 0, len(arr)-1

    for left < right {
        arr[left], arr[right] = arr[right], arr[left]
        left++
        right--
    }
}

func main() {
    nums := []int{2, 7, 11, 15}
    result := twoSum(nums, 9)
    fmt.Println("Two Sum:", result)

    fmt.Println("Is Palindrome:", isPalindrome("racecar"))
}
```

### 1.2 å¿«æ…¢æŒ‡é’ˆ

**é€‚ç”¨åœºæ™¯**: é“¾è¡¨ç¯æ£€æµ‹ã€é“¾è¡¨ä¸­ç‚¹ã€åˆ é™¤å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹

```go
package main

type ListNode struct {
    Val  int
    Next *ListNode
}

// æ£€æµ‹é“¾è¡¨ç¯
func hasCycle(head *ListNode) bool {
    if head == nil || head.Next == nil {
        return false
    }

    slow, fast := head, head.Next

    for fast != nil && fast.Next != nil {
        if slow == fast {
            return true
        }
        slow = slow.Next
        fast = fast.Next.Next
    }

    return false
}

// æ‰¾åˆ°é“¾è¡¨ä¸­ç‚¹
func findMiddle(head *ListNode) *ListNode {
    if head == nil {
        return nil
    }

    slow, fast := head, head

    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }

    return slow
}

// åˆ é™¤å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{Next: head}
    slow, fast := dummy, dummy

    // fastå…ˆèµ°n+1æ­¥
    for i := 0; i <= n; i++ {
        fast = fast.Next
    }

    // åŒæ—¶ç§»åŠ¨
    for fast != nil {
        slow = slow.Next
        fast = fast.Next
    }

    // åˆ é™¤èŠ‚ç‚¹
    slow.Next = slow.Next.Next

    return dummy.Next
}
```

### 1.3 æ»‘åŠ¨çª—å£

**é€‚ç”¨åœºæ™¯**: å­æ•°ç»„/å­ä¸²é—®é¢˜ã€æœ€å¤§/æœ€å°é•¿åº¦

```go
package main

import "fmt"

// æœ€é•¿æ— é‡å¤å­ä¸²
func lengthOfLongestSubstring(s string) int {
    window := make(map[byte]int)
    left, maxLen := 0, 0

    for right := 0; right < len(s); right++ {
        char := s[right]
        window[char]++

        // æ”¶ç¼©çª—å£
        for window[char] > 1 {
            window[s[left]]--
            left++
        }

        maxLen = max(maxLen, right-left+1)
    }

    return maxLen
}

// æœ€å°è¦†ç›–å­ä¸²
func minWindow(s string, t string) string {
    need := make(map[byte]int)
    window := make(map[byte]int)

    for i := 0; i < len(t); i++ {
        need[t[i]]++
    }

    left, right := 0, 0
    valid := 0
    start, length := 0, len(s)+1

    for right < len(s) {
        c := s[right]
        right++

        if _, ok := need[c]; ok {
            window[c]++
            if window[c] == need[c] {
                valid++
            }
        }

        // æ”¶ç¼©çª—å£
        for valid == len(need) {
            if right-left < length {
                start = left
                length = right - left
            }

            d := s[left]
            left++

            if _, ok := need[d]; ok {
                if window[d] == need[d] {
                    valid--
                }
                window[d]--
            }
        }
    }

    if length == len(s)+1 {
        return ""
    }
    return s[start : start+length]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

---

## 2. é€’å½’ä¸åˆ†æ²»

### 2.1 ç»å…¸é€’å½’

```go
// æ ‘çš„æœ€å¤§æ·±åº¦
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }

    left := maxDepth(root.Left)
    right := maxDepth(root.Right)

    return max(left, right) + 1
}

// äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„
func binaryTreePaths(root *TreeNode) []string {
    if root == nil {
        return nil
    }

    var result []string
    var dfs func(node *TreeNode, path string)

    dfs = func(node *TreeNode, path string) {
        if node.Left == nil && node.Right == nil {
            result = append(result, path+fmt.Sprint(node.Val))
            return
        }

        path += fmt.Sprint(node.Val) + "->"
        if node.Left != nil {
            dfs(node.Left, path)
        }
        if node.Right != nil {
            dfs(node.Right, path)
        }
    }

    dfs(root, "")
    return result
}
```

### 2.2 åˆ†æ²»ç®—æ³•

```go
// å½’å¹¶æ’åºï¼ˆåˆ†æ²»ï¼‰
func mergeSort(nums []int) []int {
    if len(nums) <= 1 {
        return nums
    }

    mid := len(nums) / 2
    left := mergeSort(nums[:mid])
    right := mergeSort(nums[mid:])

    return merge(left, right)
}

func merge(left, right []int) []int {
    result := make([]int, 0, len(left)+len(right))
    i, j := 0, 0

    for i < len(left) && j < len(right) {
        if left[i] <= right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }

    result = append(result, left[i:]...)
    result = append(result, right[j:]...)

    return result
}
```

---

## 3. åŠ¨æ€è§„åˆ’æ¨¡å¼

### 3.1 åŠ¨æ€è§„åˆ’è§£é¢˜æµç¨‹

```mermaid
flowchart TD
    Start([å¼€å§‹: é‡åˆ°DPé—®é¢˜]) --> Step1{1. æ˜¯å¦æœ‰<br/>æœ€ä¼˜å­ç»“æ„?}

    Step1 -->|å¦| NotDP[ä¸é€‚åˆDP<br/>å°è¯•å…¶ä»–ç®—æ³•]
    Step1 -->|æ˜¯| Step2[2. å®šä¹‰çŠ¶æ€<br/>dpä»€ä¹ˆ?]

    Step2 --> Step3[3. çŠ¶æ€è½¬ç§»æ–¹ç¨‹<br/>dp=f]
    Step3 --> Step4[4. åˆå§‹æ¡ä»¶<br/>dp0=?]
    Step4 --> Step5[5. è®¡ç®—é¡ºåº<br/>éå†æ–¹å‘]

    Step5 --> Optimize{æ˜¯å¦å¯ä¼˜åŒ–?}
    Optimize -->|ç©ºé—´ä¼˜åŒ–| Space[æ»šåŠ¨æ•°ç»„<br/>é™ç»´]
    Optimize -->|æ—¶é—´ä¼˜åŒ–| Time[è®°å¿†åŒ–<br/>å‰ªæ]
    Optimize -->|æ— éœ€ä¼˜åŒ–| Implement

    Space --> Implement[6. ç¼–ç å®ç°]
    Time --> Implement

    Implement --> Test[7. æµ‹è¯•éªŒè¯]
    Test --> End([å®Œæˆ])

    NotDP --> End

    style Start fill:#e1f5ff
    style Step2 fill:#fff4e1
    style Step3 fill:#ffe1e1
    style Implement fill:#e1ffe1
    style End fill:#e1f5ff
```

### 3.2 çº¿æ€§DPç¤ºä¾‹

```go
// æœ€é•¿é€’å¢å­åºåˆ—
func lengthOfLIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }

    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }

    maxLen := 1
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
        maxLen = max(maxLen, dp[i])
    }

    return maxLen
}

// çˆ¬æ¥¼æ¢¯
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }

    dp := make([]int, n+1)
    dp[1], dp[2] = 1, 2

    for i := 3; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }

    return dp[n]
}
```

### 3.2 åŒºé—´DP

```go
// æœ€é•¿å›æ–‡å­ä¸²
func longestPalindrome(s string) string {
    n := len(s)
    if n < 2 {
        return s
    }

    dp := make([][]bool, n)
    for i := range dp {
        dp[i] = make([]bool, n)
        dp[i][i] = true
    }

    start, maxLen := 0, 1

    // æŒ‰é•¿åº¦éå†
    for length := 2; length <= n; length++ {
        for i := 0; i < n-length+1; i++ {
            j := i + length - 1

            if s[i] == s[j] {
                if length == 2 {
                    dp[i][j] = true
                } else {
                    dp[i][j] = dp[i+1][j-1]
                }

                if dp[i][j] && length > maxLen {
                    start = i
                    maxLen = length
                }
            }
        }
    }

    return s[start : start+maxLen]
}
```

---

## 4. æœç´¢ç®—æ³•

### 4.1 DFS vs BFS å¯è§†åŒ–å¯¹æ¯”

```mermaid
graph TB
    subgraph "DFS æ·±åº¦ä¼˜å…ˆæœç´¢ - æ ˆ/é€’å½’"
        D_Root[æ ¹èŠ‚ç‚¹]
        D_L1[å·¦å­æ ‘]
        D_L2[å·¦-å·¦]
        D_L3[å·¦-å³]
        D_R1[å³å­æ ‘]

        D_Root -->|â‘ è®¿é—®| D_L1
        D_L1 -->|â‘¡é€’å½’| D_L2
        D_L2 -.å›æº¯.-> D_L1
        D_L1 -->|â‘¢è®¿é—®| D_L3
        D_L3 -.å›æº¯.-> D_Root
        D_Root -->|â‘£è®¿é—®| D_R1
    end

    subgraph "BFS å¹¿åº¦ä¼˜å…ˆæœç´¢ - é˜Ÿåˆ—"
        B_Root[æ ¹èŠ‚ç‚¹]
        B_L1[å·¦å­æ ‘]
        B_R1[å³å­æ ‘]
        B_LL[å·¦-å·¦]
        B_LR[å·¦-å³]
        B_RL[å³-å·¦]
        B_RR[å³-å³]

        B_Root -->|Level 0| B_L1
        B_Root -->|Level 0| B_R1
        B_L1 -->|Level 1| B_LL
        B_L1 -->|Level 1| B_LR
        B_R1 -->|Level 1| B_RL
        B_R1 -->|Level 1| B_RR
    end

    style D_Root fill:#ffe1e1
    style D_L2 fill:#ffe1e1
    style B_Root fill:#e1ffe1
    style B_L1 fill:#fff4e1
    style B_R1 fill:#fff4e1
```

#### å›æº¯ç®—æ³•æµç¨‹å›¾

```mermaid
flowchart TD
    Start([å¼€å§‹å›æº¯]) --> CheckValid{å½“å‰çŠ¶æ€<br/>æ˜¯å¦åˆæ³•?}

    CheckValid -->|å¦| Return1[è¿”å›/å‰ªæ]
    CheckValid -->|æ˜¯| CheckGoal{æ˜¯å¦è¾¾åˆ°<br/>ç›®æ ‡?}

    CheckGoal -->|æ˜¯| SaveResult[ä¿å­˜ç»“æœ]
    CheckGoal -->|å¦| Loop[éå†æ‰€æœ‰é€‰æ‹©]

    SaveResult --> Return2[è¿”å›]

    Loop --> Choice[åšå‡ºé€‰æ‹©]
    Choice --> Recurse[é€’å½’å›æº¯]
    Recurse --> Undo[æ’¤é”€é€‰æ‹©]
    Undo --> MoreChoice{è¿˜æœ‰å…¶ä»–<br/>é€‰æ‹©?}

    MoreChoice -->|æ˜¯| Choice
    MoreChoice -->|å¦| Return3[è¿”å›]

    Return1 --> End([ç»“æŸ])
    Return2 --> End
    Return3 --> End

    style Start fill:#e1f5ff
    style Choice fill:#fff4e1
    style Recurse fill:#ffe1e1
    style Undo fill:#e1ffe1
    style SaveResult fill:#e1ffe1
    style End fill:#e1f5ff
```

### 4.2 DFSæ·±åº¦ä¼˜å…ˆå®ç°

```go
// å²›å±¿æ•°é‡
func numIslands(grid [][]byte) int {
    if len(grid) == 0 {
        return 0
    }

    count := 0
    for i := 0; i < len(grid); i++ {
        for j := 0; j < len(grid[0]); j++ {
            if grid[i][j] == '1' {
                dfs(grid, i, j)
                count++
            }
        }
    }

    return count
}

func dfs(grid [][]byte, i, j int) {
    if i < 0 || i >= len(grid) || j < 0 || j >= len(grid[0]) || grid[i][j] == '0' {
        return
    }

    grid[i][j] = '0'
    dfs(grid, i+1, j)
    dfs(grid, i-1, j)
    dfs(grid, i, j+1)
    dfs(grid, i, j-1)
}
```

### 4.3 BFSå¹¿åº¦ä¼˜å…ˆå®ç°

```go
// äºŒå‰æ ‘çš„å±‚åºéå†
func levelOrder(root *TreeNode) [][]int {
    if root == nil {
        return nil
    }

    var result [][]int
    queue := []*TreeNode{root}

    for len(queue) > 0 {
        size := len(queue)
        level := make([]int, 0, size)

        for i := 0; i < size; i++ {
            node := queue[0]
            queue = queue[1:]

            level = append(level, node.Val)

            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }

        result = append(result, level)
    }

    return result
}

// æœ€çŸ­è·¯å¾„
func shortestPath(grid [][]int) int {
    if len(grid) == 0 || grid[0][0] == 1 {
        return -1
    }

    m, n := len(grid), len(grid[0])
    queue := [][2]int{{0, 0}}
    visited := make(map[[2]int]bool)
    visited[[2]int{0, 0}] = true
    steps := 0

    dirs := [][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}

    for len(queue) > 0 {
        size := len(queue)
        for i := 0; i < size; i++ {
            pos := queue[0]
            queue = queue[1:]

            if pos[0] == m-1 && pos[1] == n-1 {
                return steps
            }

            for _, dir := range dirs {
                x, y := pos[0]+dir[0], pos[1]+dir[1]
                if x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == 0 && !visited[[2]int{x, y}] {
                    queue = append(queue, [2]int{x, y})
                    visited[[2]int{x, y}] = true
                }
            }
        }
        steps++
    }

    return -1
}
```

---

## 5. è´ªå¿ƒç­–ç•¥

### 5.1 åŒºé—´è°ƒåº¦

```go
import "sort"

type Interval struct {
    start, end int
}

// æœ€å¤šä¸é‡å åŒºé—´
func eraseOverlapIntervals(intervals [][]int) int {
    if len(intervals) == 0 {
        return 0
    }

    // æŒ‰ç»“æŸæ—¶é—´æ’åº
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][1] < intervals[j][1]
    })

    count := 1
    end := intervals[0][1]

    for i := 1; i < len(intervals); i++ {
        if intervals[i][0] >= end {
            count++
            end = intervals[i][1]
        }
    }

    return len(intervals) - count
}
```

### 5.2 æ•°å­—è´ªå¿ƒ

```go
// è·³è·ƒæ¸¸æˆ
func canJump(nums []int) bool {
    maxReach := 0

    for i := 0; i < len(nums); i++ {
        if i > maxReach {
            return false
        }
        maxReach = max(maxReach, i+nums[i])
    }

    return true
}

// ä¹°å–è‚¡ç¥¨æœ€ä½³æ—¶æœº
func maxProfit(prices []int) int {
    profit := 0

    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            profit += prices[i] - prices[i-1]
        }
    }

    return profit
}
```

---

## 6. ä½è¿ç®—æŠ€å·§

### 6.1 åŸºæœ¬æŠ€å·§

```go
package main

import "fmt"

// åŸºæœ¬ä½è¿ç®—æŠ€å·§
func bitOperations() {
    // åˆ¤æ–­å¥‡å¶
    isOdd := func(n int) bool {
        return n&1 == 1
    }

    // äº¤æ¢ä¸¤ä¸ªæ•°
    swap := func(a, b int) (int, int) {
        a ^= b
        b ^= a
        a ^= b
        return a, b
    }

    // è·å–æœ€ä½ä½çš„1
    lowbit := func(n int) int {
        return n & (-n)
    }

    // ç»Ÿè®¡1çš„ä¸ªæ•°
    countBits := func(n int) int {
        count := 0
        for n > 0 {
            n &= n - 1 // æ¸…é™¤æœ€ä½ä½çš„1
            count++
        }
        return count
    }

    fmt.Println("Is 5 odd:", isOdd(5))
    fmt.Println("Swap 3, 5:", swap(3, 5))
    fmt.Println("Lowbit of 12:", lowbit(12))
    fmt.Println("Count bits of 15:", countBits(15))
}
```

### 6.2 å®æˆ˜åº”ç”¨

```go
// åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—
func singleNumber(nums []int) int {
    result := 0
    for _, num := range nums {
        result ^= num
    }
    return result
}

// 2çš„å¹‚
func isPowerOfTwo(n int) bool {
    return n > 0 && (n&(n-1)) == 0
}

// æ±‰æ˜è·ç¦»
func hammingDistance(x, y int) int {
    xor := x ^ y
    count := 0
    for xor > 0 {
        count += xor & 1
        xor >>= 1
    }
    return count
}
```

---

## ğŸ’¡ ç®—æ³•é€‰æ‹©æŒ‡å—

### é—®é¢˜ç±»å‹è¯†åˆ«

| é—®é¢˜ç‰¹å¾ | æ¨èç®—æ³• | å…¸å‹é¢˜ç›® |
|---------|---------|---------|
| æœ‰åºæ•°ç»„ã€ä¸¤æ•°ä¹‹å’Œ | åŒæŒ‡é’ˆ | ä¸¤æ•°ä¹‹å’Œã€ä¸‰æ•°ä¹‹å’Œ |
| å­æ•°ç»„/å­ä¸² | æ»‘åŠ¨çª—å£ | æœ€é•¿æ— é‡å¤å­ä¸² |
| é“¾è¡¨ç¯ã€ä¸­ç‚¹ | å¿«æ…¢æŒ‡é’ˆ | ç¯å½¢é“¾è¡¨ã€é“¾è¡¨ä¸­ç‚¹ |
| æ ‘ã€å›¾éå† | DFS/BFS | å²›å±¿æ•°é‡ã€è·¯å¾„å’Œ |
| æœ€ä¼˜è§£ã€è·¯å¾„ | åŠ¨æ€è§„åˆ’ | èƒŒåŒ…é—®é¢˜ã€æœ€é•¿å­åºåˆ— |
| å±€éƒ¨æœ€ä¼˜ | è´ªå¿ƒ | åŒºé—´è°ƒåº¦ã€è·³è·ƒæ¸¸æˆ |
| äºŒè¿›åˆ¶æ“ä½œ | ä½è¿ç®— | å•ä¸€æ•°å­—ã€2çš„å¹‚ |

### æ—¶é—´å¤æ‚åº¦å‚è€ƒ

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | é€‚ç”¨æ•°æ®è§„æ¨¡ |
|------|-----------|-------------|
| åŒæŒ‡é’ˆ | O(n) | n â‰¤ 10^6 |
| æ»‘åŠ¨çª—å£ | O(n) | n â‰¤ 10^6 |
| äºŒåˆ†æŸ¥æ‰¾ | O(log n) | n â‰¤ 10^9 |
| DFS/BFS | O(n) | n â‰¤ 10^5 |
| åŠ¨æ€è§„åˆ’ | O(nÂ²) | n â‰¤ 10^3 |
| å›æº¯ | O(2^n) | n â‰¤ 20 |

---

## ğŸ”— ç›¸å…³ç« èŠ‚

- [01-åŸºç¡€æ•°æ®ç»“æ„](01-åŸºç¡€æ•°æ®ç»“æ„.md)
- [02-å¸¸ç”¨ç®—æ³•](02-å¸¸ç”¨ç®—æ³•.md)
- [04-å®æˆ˜æ¡ˆä¾‹](04-å®æˆ˜æ¡ˆä¾‹.md)

---

**ç»´æŠ¤è€…**: Documentation Team
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22
**æœ€åæ›´æ–°**: 2025-10-29
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
