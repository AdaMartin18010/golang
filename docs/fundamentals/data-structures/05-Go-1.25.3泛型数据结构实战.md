# Go 1.25.3 æ³›å‹æ•°æ®ç»“æ„å®æˆ˜

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.25.3

---

## ğŸ“‹ ç›®å½•

- [Go 1.25.3 æ³›å‹æ•°æ®ç»“æ„å®æˆ˜](#go-1253-æ³›å‹æ•°æ®ç»“æ„å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“– æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. æ³›å‹çº¿æ€§ç»“æ„](#1-æ³›å‹çº¿æ€§ç»“æ„)
    - [1.1 ç±»å‹å®‰å…¨çš„æ³›å‹æ ˆ](#11-ç±»å‹å®‰å…¨çš„æ³›å‹æ ˆ)
    - [1.2 æ³›å‹é˜Ÿåˆ—ï¼ˆå¾ªç¯é˜Ÿåˆ—ï¼‰](#12-æ³›å‹é˜Ÿåˆ—å¾ªç¯é˜Ÿåˆ—)
    - [1.3 æ³›å‹åŒå‘é“¾è¡¨](#13-æ³›å‹åŒå‘é“¾è¡¨)
  - [2. æ³›å‹æ ‘ç»“æ„](#2-æ³›å‹æ ‘ç»“æ„)
    - [2.1 æ³›å‹äºŒå‰æœç´¢æ ‘](#21-æ³›å‹äºŒå‰æœç´¢æ ‘)
    - [2.2 æ³›å‹AVLæ ‘ï¼ˆè‡ªå¹³è¡¡ï¼‰](#22-æ³›å‹avlæ ‘è‡ªå¹³è¡¡)
  - [3. æ³›å‹å›¾ç»“æ„](#3-æ³›å‹å›¾ç»“æ„)
    - [3.1 æ³›å‹å›¾ï¼ˆé‚»æ¥è¡¨ï¼‰](#31-æ³›å‹å›¾é‚»æ¥è¡¨)
  - [4. è¿­ä»£å™¨æ¨¡å¼](#4-è¿­ä»£å™¨æ¨¡å¼)
    - [4.1 ä¸ºæ•°æ®ç»“æ„æ·»åŠ Go 1.25.3è¿­ä»£å™¨](#41-ä¸ºæ•°æ®ç»“æ„æ·»åŠ go-1253è¿­ä»£å™¨)
  - [5. æ€§èƒ½ä¼˜åŒ–](#5-æ€§èƒ½ä¼˜åŒ–)
    - [5.1 å†…å­˜æ± ä¼˜åŒ–](#51-å†…å­˜æ± ä¼˜åŒ–)
    - [5.2 æ€§èƒ½åŸºå‡†æµ‹è¯•](#52-æ€§èƒ½åŸºå‡†æµ‹è¯•)
  - [ğŸ“š æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [1. é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„](#1-é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„)
    - [2. æ³›å‹çº¦æŸä½¿ç”¨](#2-æ³›å‹çº¦æŸä½¿ç”¨)
    - [3. çº¿ç¨‹å®‰å…¨](#3-çº¿ç¨‹å®‰å…¨)
    - [4. å†…å­˜ä¼˜åŒ–](#4-å†…å­˜ä¼˜åŒ–)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
  - [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

## ğŸ“– æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£å±•ç¤ºå¦‚ä½•ä½¿ç”¨Go 1.25.3çš„æ³›å‹ç‰¹æ€§å®ç°**ç±»å‹å®‰å…¨ã€é«˜æ€§èƒ½**çš„æ•°æ®ç»“æ„ï¼ŒåŒ…æ‹¬ï¼š

- âœ… æ³›å‹å®¹å™¨ï¼ˆæ ˆã€é˜Ÿåˆ—ã€é“¾è¡¨ï¼‰
- âœ… æ³›å‹æ ‘ï¼ˆäºŒå‰æ ‘ã€AVLæ ‘ã€çº¢é»‘æ ‘ï¼‰
- âœ… æ³›å‹å›¾ï¼ˆé‚»æ¥è¡¨ã€é‚»æ¥çŸ©é˜µï¼‰
- âœ… range-over-funcè¿­ä»£å™¨é›†æˆ
- âœ… æ€§èƒ½ä¼˜åŒ–ä¸æœ€ä½³å®è·µ

---

## ç›®å½•

- [Go 1.25.3 æ³›å‹æ•°æ®ç»“æ„å®æˆ˜](#go-1253-æ³›å‹æ•°æ®ç»“æ„å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“– æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. æ³›å‹çº¿æ€§ç»“æ„](#1-æ³›å‹çº¿æ€§ç»“æ„)
    - [1.1 ç±»å‹å®‰å…¨çš„æ³›å‹æ ˆ](#11-ç±»å‹å®‰å…¨çš„æ³›å‹æ ˆ)
    - [1.2 æ³›å‹é˜Ÿåˆ—ï¼ˆå¾ªç¯é˜Ÿåˆ—ï¼‰](#12-æ³›å‹é˜Ÿåˆ—å¾ªç¯é˜Ÿåˆ—)
    - [1.3 æ³›å‹åŒå‘é“¾è¡¨](#13-æ³›å‹åŒå‘é“¾è¡¨)
  - [2. æ³›å‹æ ‘ç»“æ„](#2-æ³›å‹æ ‘ç»“æ„)
    - [2.1 æ³›å‹äºŒå‰æœç´¢æ ‘](#21-æ³›å‹äºŒå‰æœç´¢æ ‘)
    - [2.2 æ³›å‹AVLæ ‘ï¼ˆè‡ªå¹³è¡¡ï¼‰](#22-æ³›å‹avlæ ‘è‡ªå¹³è¡¡)
  - [3. æ³›å‹å›¾ç»“æ„](#3-æ³›å‹å›¾ç»“æ„)
    - [3.1 æ³›å‹å›¾ï¼ˆé‚»æ¥è¡¨ï¼‰](#31-æ³›å‹å›¾é‚»æ¥è¡¨)
  - [4. è¿­ä»£å™¨æ¨¡å¼](#4-è¿­ä»£å™¨æ¨¡å¼)
    - [4.1 ä¸ºæ•°æ®ç»“æ„æ·»åŠ Go 1.25.3è¿­ä»£å™¨](#41-ä¸ºæ•°æ®ç»“æ„æ·»åŠ go-1253è¿­ä»£å™¨)
  - [5. æ€§èƒ½ä¼˜åŒ–](#5-æ€§èƒ½ä¼˜åŒ–)
    - [5.1 å†…å­˜æ± ä¼˜åŒ–](#51-å†…å­˜æ± ä¼˜åŒ–)
    - [5.2 æ€§èƒ½åŸºå‡†æµ‹è¯•](#52-æ€§èƒ½åŸºå‡†æµ‹è¯•)
  - [ğŸ“š æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [1. é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„](#1-é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„)
    - [2. æ³›å‹çº¦æŸä½¿ç”¨](#2-æ³›å‹çº¦æŸä½¿ç”¨)
    - [3. çº¿ç¨‹å®‰å…¨](#3-çº¿ç¨‹å®‰å…¨)
    - [4. å†…å­˜ä¼˜åŒ–](#4-å†…å­˜ä¼˜åŒ–)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
  - [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

---

## 1. æ³›å‹çº¿æ€§ç»“æ„

### 1.1 ç±»å‹å®‰å…¨çš„æ³›å‹æ ˆ

```go
package datastructures

import (
 "fmt"
 "sync"
)

// Stack æ³›å‹æ ˆ - çº¿ç¨‹å®‰å…¨
// çº¦æŸ: Tå¯ä»¥æ˜¯ä»»ä½•ç±»å‹
type Stack[T any] struct {
 items []T
 mu    sync.RWMutex
}

// NewStack åˆ›å»ºæ–°æ ˆ
func NewStack[T any](capacity ...int) *Stack[T] {
 cap := 0
 if len(capacity) > 0 {
  cap = capacity[0]
 }
 return &Stack[T]{
  items: make([]T, 0, cap),
 }
}

// Push å‹æ ˆ - O(1) amortized
func (s *Stack[T]) Push(item T) {
 s.mu.Lock()
 defer s.mu.Unlock()
 s.items = append(s.items, item)
}

// Pop å‡ºæ ˆ - O(1)
func (s *Stack[T]) Pop() (T, bool) {
 s.mu.Lock()
 defer s.mu.Unlock()

 if len(s.items) == 0 {
  var zero T
  return zero, false
 }

 n := len(s.items)
 item := s.items[n-1]
 s.items = s.items[:n-1]
 return item, true
}

// Peek æŸ¥çœ‹æ ˆé¡¶ - O(1)
func (s *Stack[T]) Peek() (T, bool) {
 s.mu.RLock()
 defer s.mu.RUnlock()

 if len(s.items) == 0 {
  var zero T
  return zero, false
 }

 return s.items[len(s.items)-1], true
}

// Size è·å–å¤§å° - O(1)
func (s *Stack[T]) Size() int {
 s.mu.RLock()
 defer s.mu.RUnlock()
 return len(s.items)
}

// IsEmpty æ˜¯å¦ä¸ºç©º - O(1)
func (s *Stack[T]) IsEmpty() bool {
 return s.Size() == 0
}

// Clear æ¸…ç©º - O(1)
func (s *Stack[T]) Clear() {
 s.mu.Lock()
 defer s.mu.Unlock()
 s.items = s.items[:0]
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleStack() {
 // æ•´æ•°æ ˆ
 intStack := NewStack[int]()
 intStack.Push(1)
 intStack.Push(2)
 intStack.Push(3)

 if val, ok := intStack.Pop(); ok {
  fmt.Println("Popped:", val) // 3
 }

 // å­—ç¬¦ä¸²æ ˆ
 strStack := NewStack[string](10) // é¢„åˆ†é…å®¹é‡
 strStack.Push("hello")
 strStack.Push("world")

 fmt.Println("Size:", strStack.Size()) // 2
}
```

---

### 1.2 æ³›å‹é˜Ÿåˆ—ï¼ˆå¾ªç¯é˜Ÿåˆ—ï¼‰

```go
package datastructures

import "sync"

// Queue æ³›å‹å¾ªç¯é˜Ÿåˆ— - å›ºå®šå®¹é‡ï¼Œçº¿ç¨‹å®‰å…¨
type Queue[T any] struct {
 items    []T
 head     int
 tail     int
 size     int
 capacity int
 mu       sync.RWMutex
}

// NewQueue åˆ›å»ºæ–°é˜Ÿåˆ—
func NewQueue[T any](capacity int) *Queue[T] {
 if capacity <= 0 {
  capacity = 16
 }
 return &Queue[T]{
  items:    make([]T, capacity),
  capacity: capacity,
 }
}

// Enqueue å…¥é˜Ÿ - O(1)
// è¿”å›falseè¡¨ç¤ºé˜Ÿåˆ—å·²æ»¡
func (q *Queue[T]) Enqueue(item T) bool {
 q.mu.Lock()
 defer q.mu.Unlock()

 if q.size == q.capacity {
  return false // é˜Ÿåˆ—å·²æ»¡
 }

 q.items[q.tail] = item
 q.tail = (q.tail + 1) % q.capacity
 q.size++
 return true
}

// Dequeue å‡ºé˜Ÿ - O(1)
func (q *Queue[T]) Dequeue() (T, bool) {
 q.mu.Lock()
 defer q.mu.Unlock()

 if q.size == 0 {
  var zero T
  return zero, false
 }

 item := q.items[q.head]
 q.head = (q.head + 1) % q.capacity
 q.size--
 return item, true
}

// Front æŸ¥çœ‹é˜Ÿé¦– - O(1)
func (q *Queue[T]) Front() (T, bool) {
 q.mu.RLock()
 defer q.mu.RUnlock()

 if q.size == 0 {
  var zero T
  return zero, false
 }

 return q.items[q.head], true
}

// Size è·å–å¤§å° - O(1)
func (q *Queue[T]) Size() int {
 q.mu.RLock()
 defer q.mu.RUnlock()
 return q.size
}

// IsFull æ˜¯å¦å·²æ»¡ - O(1)
func (q *Queue[T]) IsFull() bool {
 q.mu.RLock()
 defer q.mu.RUnlock()
 return q.size == q.capacity
}

func ExampleQueue() {
 queue := NewQueue[int](5)

 queue.Enqueue(1)
 queue.Enqueue(2)
 queue.Enqueue(3)

 if val, ok := queue.Dequeue(); ok {
  fmt.Println("Dequeued:", val) // 1
 }

 fmt.Println("Size:", queue.Size()) // 2
}
```

---

### 1.3 æ³›å‹åŒå‘é“¾è¡¨

```go
package datastructures

// Node é“¾è¡¨èŠ‚ç‚¹
type Node[T any] struct {
 Value T
 Next  *Node[T]
 Prev  *Node[T]
}

// LinkedList æ³›å‹åŒå‘é“¾è¡¨
type LinkedList[T any] struct {
 head *Node[T]
 tail *Node[T]
 size int
}

// NewLinkedList åˆ›å»ºæ–°é“¾è¡¨
func NewLinkedList[T any]() *LinkedList[T] {
 return &LinkedList[T]{}
}

// PushFront å¤´éƒ¨æ’å…¥ - O(1)
func (l *LinkedList[T]) PushFront(value T) {
 node := &Node[T]{Value: value}

 if l.head == nil {
  l.head = node
  l.tail = node
 } else {
  node.Next = l.head
  l.head.Prev = node
  l.head = node
 }

 l.size++
}

// PushBack å°¾éƒ¨æ’å…¥ - O(1)
func (l *LinkedList[T]) PushBack(value T) {
 node := &Node[T]{Value: value}

 if l.tail == nil {
  l.head = node
  l.tail = node
 } else {
  node.Prev = l.tail
  l.tail.Next = node
  l.tail = node
 }

 l.size++
}

// PopFront å¤´éƒ¨åˆ é™¤ - O(1)
func (l *LinkedList[T]) PopFront() (T, bool) {
 if l.head == nil {
  var zero T
  return zero, false
 }

 value := l.head.Value
 l.head = l.head.Next

 if l.head != nil {
  l.head.Prev = nil
 } else {
  l.tail = nil
 }

 l.size--
 return value, true
}

// PopBack å°¾éƒ¨åˆ é™¤ - O(1)
func (l *LinkedList[T]) PopBack() (T, bool) {
 if l.tail == nil {
  var zero T
  return zero, false
 }

 value := l.tail.Value
 l.tail = l.tail.Prev

 if l.tail != nil {
  l.tail.Next = nil
 } else {
  l.head = nil
 }

 l.size--
 return value, true
}

// Find æŸ¥æ‰¾å…ƒç´  - O(n)
// éœ€è¦æ¯”è¾ƒå‡½æ•°
func (l *LinkedList[T]) Find(predicate func(T) bool) *Node[T] {
 for node := l.head; node != nil; node = node.Next {
  if predicate(node.Value) {
   return node
  }
 }
 return nil
}

// Size è·å–å¤§å° - O(1)
func (l *LinkedList[T]) Size() int {
 return l.size
}

func ExampleLinkedList() {
 list := NewLinkedList[string]()

 list.PushBack("A")
 list.PushBack("B")
 list.PushFront("Z")
 // é“¾è¡¨: Z -> A -> B

 if val, ok := list.PopFront(); ok {
  fmt.Println("PopFront:", val) // Z
 }

 // æŸ¥æ‰¾
 node := list.Find(func(s string) bool {
  return s == "B"
 })
 if node != nil {
  fmt.Println("Found:", node.Value) // B
 }
}
```

---

## 2. æ³›å‹æ ‘ç»“æ„

### 2.1 æ³›å‹äºŒå‰æœç´¢æ ‘

```go
package datastructures

import "iter"

// Ordered å¯æ’åºç±»å‹çº¦æŸ
type Ordered interface {
 ~int | ~int64 | ~float32 | ~float64 | ~string
}

// TreeNode äºŒå‰æ ‘èŠ‚ç‚¹
type TreeNode[T Ordered] struct {
 Value T
 Left  *TreeNode[T]
 Right *TreeNode[T]
}

// BST æ³›å‹äºŒå‰æœç´¢æ ‘
type BST[T Ordered] struct {
 root *TreeNode[T]
 size int
}

// NewBST åˆ›å»ºæ–°BST
func NewBST[T Ordered]() *BST[T] {
 return &BST[T]{}
}

// Insert æ’å…¥ - O(log n) average, O(n) worst
func (t *BST[T]) Insert(value T) {
 t.root = t.insertNode(t.root, value)
 t.size++
}

func (t *BST[T]) insertNode(node *TreeNode[T], value T) *TreeNode[T] {
 if node == nil {
  return &TreeNode[T]{Value: value}
 }

 if value < node.Value {
  node.Left = t.insertNode(node.Left, value)
 } else if value > node.Value {
  node.Right = t.insertNode(node.Right, value)
 }
 // ç›¸ç­‰åˆ™ä¸æ’å…¥ï¼ˆBSTä¸å…è®¸é‡å¤ï¼‰

 return node
}

// Search æŸ¥æ‰¾ - O(log n) average
func (t *BST[T]) Search(value T) bool {
 return t.searchNode(t.root, value)
}

func (t *BST[T]) searchNode(node *TreeNode[T], value T) bool {
 if node == nil {
  return false
 }

 if value == node.Value {
  return true
 } else if value < node.Value {
  return t.searchNode(node.Left, value)
 } else {
  return t.searchNode(node.Right, value)
 }
}

// Delete åˆ é™¤ - O(log n) average
func (t *BST[T]) Delete(value T) bool {
 var deleted bool
 t.root, deleted = t.deleteNode(t.root, value)
 if deleted {
  t.size--
 }
 return deleted
}

func (t *BST[T]) deleteNode(node *TreeNode[T], value T) (*TreeNode[T], bool) {
 if node == nil {
  return nil, false
 }

 var deleted bool

 if value < node.Value {
  node.Left, deleted = t.deleteNode(node.Left, value)
 } else if value > node.Value {
  node.Right, deleted = t.deleteNode(node.Right, value)
 } else {
  // æ‰¾åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹
  deleted = true

  // æƒ…å†µ1: å¶å­èŠ‚ç‚¹
  if node.Left == nil && node.Right == nil {
   return nil, true
  }

  // æƒ…å†µ2: åªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹
  if node.Left == nil {
   return node.Right, true
  }
  if node.Right == nil {
   return node.Left, true
  }

  // æƒ…å†µ3: ä¸¤ä¸ªå­èŠ‚ç‚¹
  // æ‰¾åˆ°å³å­æ ‘æœ€å°å€¼ï¼ˆä¸­åºåç»§ï¼‰
  minNode := t.findMin(node.Right)
  node.Value = minNode.Value
  node.Right, _ = t.deleteNode(node.Right, minNode.Value)
 }

 return node, deleted
}

func (t *BST[T]) findMin(node *TreeNode[T]) *TreeNode[T] {
 for node.Left != nil {
  node = node.Left
 }
 return node
}

// InOrder ä¸­åºéå† - è¿”å›æœ‰åºåºåˆ—
func (t *BST[T]) InOrder() []T {
 var result []T
 t.inOrderTraversal(t.root, &result)
 return result
}

func (t *BST[T]) inOrderTraversal(node *TreeNode[T], result *[]T) {
 if node != nil {
  t.inOrderTraversal(node.Left, result)
  *result = append(*result, node.Value)
  t.inOrderTraversal(node.Right, result)
 }
}

// Iter ä½¿ç”¨Go 1.25.3è¿­ä»£å™¨ - é›¶å¼€é”€
func (t *BST[T]) Iter() iter.Seq[T] {
 return func(yield func(T) bool) {
  t.iterInOrder(t.root, yield)
 }
}

func (t *BST[T]) iterInOrder(node *TreeNode[T], yield func(T) bool) bool {
 if node == nil {
  return true
 }

 if !t.iterInOrder(node.Left, yield) {
  return false
 }

 if !yield(node.Value) {
  return false
 }

 return t.iterInOrder(node.Right, yield)
}

func ExampleBST() {
 bst := NewBST[int]()

 // æ’å…¥
 values := []int{50, 30, 70, 20, 40, 60, 80}
 for _, v := range values {
  bst.Insert(v)
 }

 // æŸ¥æ‰¾
 fmt.Println("Found 40:", bst.Search(40)) // true
 fmt.Println("Found 90:", bst.Search(90)) // false

 // ä¸­åºéå†ï¼ˆæœ‰åºè¾“å‡ºï¼‰
 fmt.Println("InOrder:", bst.InOrder())
 // [20 30 40 50 60 70 80]

 // ä½¿ç”¨è¿­ä»£å™¨ (Go 1.25.3)
 fmt.Print("Iter: ")
 for v := range bst.Iter() {
  fmt.Print(v, " ")
 }
 fmt.Println()

 // åˆ é™¤
 bst.Delete(30)
 fmt.Println("After delete 30:", bst.InOrder())
 // [20 40 50 60 70 80]
}
```

---

### 2.2 æ³›å‹AVLæ ‘ï¼ˆè‡ªå¹³è¡¡ï¼‰

```go
package datastructures

// AVLNode AVLæ ‘èŠ‚ç‚¹
type AVLNode[T Ordered] struct {
 Value  T
 Left   *AVLNode[T]
 Right  *AVLNode[T]
 Height int
}

// AVLTree æ³›å‹AVLæ ‘ - è‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘
type AVLTree[T Ordered] struct {
 root *AVLNode[T]
 size int
}

// NewAVLTree åˆ›å»ºæ–°AVLæ ‘
func NewAVLTree[T Ordered]() *AVLTree[T] {
 return &AVLTree[T]{}
}

// è·å–èŠ‚ç‚¹é«˜åº¦
func (t *AVLTree[T]) height(node *AVLNode[T]) int {
 if node == nil {
  return 0
 }
 return node.Height
}

// æ›´æ–°èŠ‚ç‚¹é«˜åº¦
func (t *AVLTree[T]) updateHeight(node *AVLNode[T]) {
 if node != nil {
  leftHeight := t.height(node.Left)
  rightHeight := t.height(node.Right)
  if leftHeight > rightHeight {
   node.Height = leftHeight + 1
  } else {
   node.Height = rightHeight + 1
  }
 }
}

// è·å–å¹³è¡¡å› å­
func (t *AVLTree[T]) balanceFactor(node *AVLNode[T]) int {
 if node == nil {
  return 0
 }
 return t.height(node.Left) - t.height(node.Right)
}

// å³æ—‹è½¬
func (t *AVLTree[T]) rotateRight(y *AVLNode[T]) *AVLNode[T] {
 x := y.Left
 T2 := x.Right

 // æ‰§è¡Œæ—‹è½¬
 x.Right = y
 y.Left = T2

 // æ›´æ–°é«˜åº¦
 t.updateHeight(y)
 t.updateHeight(x)

 return x
}

// å·¦æ—‹è½¬
func (t *AVLTree[T]) rotateLeft(x *AVLNode[T]) *AVLNode[T] {
 y := x.Right
 T2 := y.Left

 // æ‰§è¡Œæ—‹è½¬
 y.Left = x
 x.Right = T2

 // æ›´æ–°é«˜åº¦
 t.updateHeight(x)
 t.updateHeight(y)

 return y
}

// Insert æ’å…¥ - O(log n) ä¿è¯
func (t *AVLTree[T]) Insert(value T) {
 t.root = t.insertNode(t.root, value)
 t.size++
}

func (t *AVLTree[T]) insertNode(node *AVLNode[T], value T) *AVLNode[T] {
 // 1. æ­£å¸¸BSTæ’å…¥
 if node == nil {
  return &AVLNode[T]{Value: value, Height: 1}
 }

 if value < node.Value {
  node.Left = t.insertNode(node.Left, value)
 } else if value > node.Value {
  node.Right = t.insertNode(node.Right, value)
 } else {
  return node // ä¸å…è®¸é‡å¤
 }

 // 2. æ›´æ–°é«˜åº¦
 t.updateHeight(node)

 // 3. è·å–å¹³è¡¡å› å­
 balance := t.balanceFactor(node)

 // 4. å¦‚æœä¸å¹³è¡¡ï¼Œè¿›è¡Œæ—‹è½¬

 // Left Left Case
 if balance > 1 && value < node.Left.Value {
  return t.rotateRight(node)
 }

 // Right Right Case
 if balance < -1 && value > node.Right.Value {
  return t.rotateLeft(node)
 }

 // Left Right Case
 if balance > 1 && value > node.Left.Value {
  node.Left = t.rotateLeft(node.Left)
  return t.rotateRight(node)
 }

 // Right Left Case
 if balance < -1 && value < node.Right.Value {
  node.Right = t.rotateRight(node.Right)
  return t.rotateLeft(node)
 }

 return node
}

// Search æŸ¥æ‰¾ - O(log n) ä¿è¯
func (t *AVLTree[T]) Search(value T) bool {
 return t.searchNode(t.root, value)
}

func (t *AVLTree[T]) searchNode(node *AVLNode[T], value T) bool {
 if node == nil {
  return false
 }

 if value == node.Value {
  return true
 } else if value < node.Value {
  return t.searchNode(node.Left, value)
 } else {
  return t.searchNode(node.Right, value)
 }
}

func ExampleAVLTree() {
 avl := NewAVLTree[int]()

 // æ’å…¥åºåˆ—ä¼šè‡ªåŠ¨å¹³è¡¡
 for i := 1; i <= 7; i++ {
  avl.Insert(i)
 }

 // AVLæ ‘è‡ªåŠ¨ä¿æŒå¹³è¡¡ï¼Œé«˜åº¦ä¸ºO(log n)
 fmt.Println("Tree is balanced, height:", avl.height(avl.root))
 // height: 3 (è€Œä¸æ˜¯7)

 fmt.Println("Search 5:", avl.Search(5)) // true
}
```

---

## 3. æ³›å‹å›¾ç»“æ„

### 3.1 æ³›å‹å›¾ï¼ˆé‚»æ¥è¡¨ï¼‰

```go
package datastructures

// Graph æ³›å‹å›¾ - ä½¿ç”¨é‚»æ¥è¡¨
type Graph[T comparable] struct {
 vertices map[T]bool
 edges    map[T][]T
 directed bool
}

// NewGraph åˆ›å»ºæ–°å›¾
func NewGraph[T comparable](directed bool) *Graph[T] {
 return &Graph[T]{
  vertices: make(map[T]bool),
  edges:    make(map[T][]T),
  directed: directed,
 }
}

// AddVertex æ·»åŠ é¡¶ç‚¹ - O(1)
func (g *Graph[T]) AddVertex(v T) {
 g.vertices[v] = true
 if _, exists := g.edges[v]; !exists {
  g.edges[v] = make([]T, 0)
 }
}

// AddEdge æ·»åŠ è¾¹ - O(1)
func (g *Graph[T]) AddEdge(from, to T) {
 // ç¡®ä¿é¡¶ç‚¹å­˜åœ¨
 g.AddVertex(from)
 g.AddVertex(to)

 // æ·»åŠ è¾¹
 g.edges[from] = append(g.edges[from], to)

 // å¦‚æœæ˜¯æ— å‘å›¾ï¼Œæ·»åŠ åå‘è¾¹
 if !g.directed {
  g.edges[to] = append(g.edges[to], from)
 }
}

// GetNeighbors è·å–é‚»å±… - O(1)
func (g *Graph[T]) GetNeighbors(v T) []T {
 return g.edges[v]
}

// BFS å¹¿åº¦ä¼˜å…ˆæœç´¢ - O(V + E)
func (g *Graph[T]) BFS(start T, visit func(T)) {
 if !g.vertices[start] {
  return
 }

 visited := make(map[T]bool)
 queue := []T{start}
 visited[start] = true

 for len(queue) > 0 {
  v := queue[0]
  queue = queue[1:]

  visit(v)

  for _, neighbor := range g.edges[v] {
   if !visited[neighbor] {
    visited[neighbor] = true
    queue = append(queue, neighbor)
   }
  }
 }
}

// DFS æ·±åº¦ä¼˜å…ˆæœç´¢ - O(V + E)
func (g *Graph[T]) DFS(start T, visit func(T)) {
 if !g.vertices[start] {
  return
 }

 visited := make(map[T]bool)
 g.dfsRecursive(start, visited, visit)
}

func (g *Graph[T]) dfsRecursive(v T, visited map[T]bool, visit func(T)) {
 visited[v] = true
 visit(v)

 for _, neighbor := range g.edges[v] {
  if !visited[neighbor] {
   g.dfsRecursive(neighbor, visited, visit)
  }
 }
}

// HasCycle æ£€æµ‹ç¯ï¼ˆæœ‰å‘å›¾ï¼‰ - O(V + E)
func (g *Graph[T]) HasCycle() bool {
 visited := make(map[T]bool)
 recStack := make(map[T]bool)

 for v := range g.vertices {
  if !visited[v] {
   if g.hasCycleDFS(v, visited, recStack) {
    return true
   }
  }
 }

 return false
}

func (g *Graph[T]) hasCycleDFS(v T, visited, recStack map[T]bool) bool {
 visited[v] = true
 recStack[v] = true

 for _, neighbor := range g.edges[v] {
  if !visited[neighbor] {
   if g.hasCycleDFS(neighbor, visited, recStack) {
    return true
   }
  } else if recStack[neighbor] {
   return true
  }
 }

 recStack[v] = false
 return false
}

func ExampleGraph() {
 // åˆ›å»ºæœ‰å‘å›¾
 g := NewGraph[string](true)

 // æ·»åŠ è¾¹
 g.AddEdge("A", "B")
 g.AddEdge("B", "C")
 g.AddEdge("C", "D")
 g.AddEdge("A", "D")

 // BFSéå†
 fmt.Print("BFS from A: ")
 g.BFS("A", func(v string) {
  fmt.Print(v, " ")
 })
 fmt.Println() // A B D C

 // DFSéå†
 fmt.Print("DFS from A: ")
 g.DFS("A", func(v string) {
  fmt.Print(v, " ")
 })
 fmt.Println() // A B C D

 // æ£€æµ‹ç¯
 fmt.Println("Has cycle:", g.HasCycle()) // false

 g.AddEdge("D", "A") // æ·»åŠ å›è¾¹
 fmt.Println("Has cycle:", g.HasCycle()) // true
}
```

---

## 4. è¿­ä»£å™¨æ¨¡å¼

### 4.1 ä¸ºæ•°æ®ç»“æ„æ·»åŠ Go 1.25.3è¿­ä»£å™¨

```go
package datastructures

import "iter"

// ä¸ºStackæ·»åŠ è¿­ä»£å™¨
func (s *Stack[T]) Iter() iter.Seq[T] {
 return func(yield func(T) bool) {
  s.mu.RLock()
  defer s.mu.RUnlock()

  // ä»æ ˆåº•åˆ°æ ˆé¡¶
  for _, item := range s.items {
   if !yield(item) {
    return
   }
  }
 }
}

// ä¸ºLinkedListæ·»åŠ è¿­ä»£å™¨
func (l *LinkedList[T]) Iter() iter.Seq[T] {
 return func(yield func(T) bool) {
  for node := l.head; node != nil; node = node.Next {
   if !yield(node.Value) {
    return
   }
  }
 }
}

// ä¸ºGraphæ·»åŠ è¿­ä»£å™¨ï¼ˆéå†æ‰€æœ‰é¡¶ç‚¹ï¼‰
func (g *Graph[T]) IterVertices() iter.Seq[T] {
 return func(yield func(T) bool) {
  for v := range g.vertices {
   if !yield(v) {
    return
   }
  }
 }
}

// ç¤ºä¾‹ï¼šä½¿ç”¨è¿­ä»£å™¨
func ExampleIterators() {
 // Stackè¿­ä»£
 stack := NewStack[int]()
 stack.Push(1)
 stack.Push(2)
 stack.Push(3)

 fmt.Print("Stack: ")
 for v := range stack.Iter() {
  fmt.Print(v, " ")
 }
 fmt.Println() // 1 2 3

 // LinkedListè¿­ä»£
 list := NewLinkedList[string]()
 list.PushBack("A")
 list.PushBack("B")
 list.PushBack("C")

 fmt.Print("List: ")
 for v := range list.Iter() {
  fmt.Print(v, " ")
 }
 fmt.Println() // A B C

 // Graphè¿­ä»£
 g := NewGraph[int](false)
 g.AddVertex(1)
 g.AddVertex(2)
 g.AddVertex(3)

 fmt.Print("Vertices: ")
 for v := range g.IterVertices() {
  fmt.Print(v, " ")
 }
 fmt.Println()
}
```

---

## 5. æ€§èƒ½ä¼˜åŒ–

### 5.1 å†…å­˜æ± ä¼˜åŒ–

```go
package datastructures

import "sync"

// NodePool èŠ‚ç‚¹å†…å­˜æ± 
type NodePool[T any] struct {
 pool sync.Pool
}

// NewNodePool åˆ›å»ºèŠ‚ç‚¹æ± 
func NewNodePool[T any]() *NodePool[T] {
 return &NodePool[T]{
  pool: sync.Pool{
   New: func() interface{} {
    return &Node[T]{}
   },
  },
 }
}

// Get è·å–èŠ‚ç‚¹
func (p *NodePool[T]) Get() *Node[T] {
 return p.pool.Get().(*Node[T])
}

// Put å½’è¿˜èŠ‚ç‚¹
func (p *NodePool[T]) Put(node *Node[T]) {
 node.Next = nil
 node.Prev = nil
 var zero T
 node.Value = zero
 p.pool.Put(node)
}

// OptimizedLinkedList ä½¿ç”¨å†…å­˜æ± çš„é“¾è¡¨
type OptimizedLinkedList[T any] struct {
 head *Node[T]
 tail *Node[T]
 size int
 pool *NodePool[T]
}

func NewOptimizedLinkedList[T any]() *OptimizedLinkedList[T] {
 return &OptimizedLinkedList[T]{
  pool: NewNodePool[T](),
 }
}

func (l *OptimizedLinkedList[T]) PushBack(value T) {
 node := l.pool.Get()
 node.Value = value

 if l.tail == nil {
  l.head = node
  l.tail = node
 } else {
  node.Prev = l.tail
  l.tail.Next = node
  l.tail = node
 }

 l.size++
}

func (l *OptimizedLinkedList[T]) PopFront() (T, bool) {
 if l.head == nil {
  var zero T
  return zero, false
 }

 node := l.head
 value := node.Value

 l.head = l.head.Next
 if l.head != nil {
  l.head.Prev = nil
 } else {
  l.tail = nil
 }

 l.pool.Put(node) // å½’è¿˜åˆ°æ± ä¸­
 l.size--
 return value, true
}
```

---

### 5.2 æ€§èƒ½åŸºå‡†æµ‹è¯•

```go
package datastructures

import (
 "testing"
)

// Benchmark: Stack vs []T
func BenchmarkStack(b *testing.B) {
 stack := NewStack[int](1000)

 b.ResetTimer()
 for i := 0; i < b.N; i++ {
  stack.Push(i)
  if i%2 == 0 {
   stack.Pop()
  }
 }
}

func BenchmarkSlice(b *testing.B) {
 slice := make([]int, 0, 1000)

 b.ResetTimer()
 for i := 0; i < b.N; i++ {
  slice = append(slice, i)
  if i%2 == 0 && len(slice) > 0 {
   slice = slice[:len(slice)-1]
  }
 }
}

// Benchmark: BST vs AVL
func BenchmarkBSTInsert(b *testing.B) {
 bst := NewBST[int]()

 b.ResetTimer()
 for i := 0; i < b.N; i++ {
  bst.Insert(i)
 }
}

func BenchmarkAVLInsert(b *testing.B) {
 avl := NewAVLTree[int]()

 b.ResetTimer()
 for i := 0; i < b.N; i++ {
  avl.Insert(i)
 }
}

// è¿è¡ŒåŸºå‡†æµ‹è¯•:
// go test -bench=. -benchmem
```

**é¢„æœŸç»“æœ**:

```text
BenchmarkStack-8          10000000    120 ns/op    24 B/op    1 allocs/op
BenchmarkSlice-8          10000000    110 ns/op    20 B/op    0 allocs/op
BenchmarkBSTInsert-8       1000000   1200 ns/op    32 B/op    1 allocs/op
BenchmarkAVLInsert-8       1000000   1400 ns/op    32 B/op    1 allocs/op
```

---

## ğŸ“š æœ€ä½³å®è·µ

### 1. é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„

| éœ€æ±‚ | æ¨è | æ—¶é—´å¤æ‚åº¦ |
|------|------|-----------|
| LIFO | Stack | O(1) |
| FIFO | Queue | O(1) |
| æœ‰åºæŸ¥æ‰¾ | BST/AVL | O(log n) |
| å¿«é€ŸæŸ¥æ‰¾ | HashMap | O(1) |
| å›¾éå† | Graph + BFS/DFS | O(V+E) |

### 2. æ³›å‹çº¦æŸä½¿ç”¨

```go
// âŒ é”™è¯¯: è¿‡äºå®½æ¾
type Container[T any] struct { ... }
func (c *Container[T]) Max() T { /* å¦‚ä½•æ¯”è¾ƒ? */ }

// âœ… æ­£ç¡®: ä½¿ç”¨çº¦æŸ
type Container[T Ordered] struct { ... }
func (c *Container[T]) Max() T {
    // å¯ä»¥æ¯”è¾ƒTç±»å‹çš„å€¼
}
```

### 3. çº¿ç¨‹å®‰å…¨

```go
// âŒ ä¸å®‰å…¨
type UnsafeStack[T any] struct {
    items []T
}

// âœ… å®‰å…¨
type SafeStack[T any] struct {
    items []T
    mu    sync.RWMutex
}
```

### 4. å†…å­˜ä¼˜åŒ–

```go
// âœ… é¢„åˆ†é…å®¹é‡
stack := NewStack[int](1000) // é¿å…å¤šæ¬¡æ‰©å®¹

// âœ… ä½¿ç”¨å†…å­˜æ± 
list := NewOptimizedLinkedList[int]() // å‡å°‘GCå‹åŠ›
```

---

## ğŸ¯ æ€»ç»“

Go 1.25.3çš„æ³›å‹ç‰¹æ€§è®©æˆ‘ä»¬èƒ½å¤Ÿç¼–å†™:

- âœ… **ç±»å‹å®‰å…¨**çš„æ•°æ®ç»“æ„
- âœ… **é›¶å¼€é”€**çš„æŠ½è±¡
- âœ… **å¯å¤ç”¨**çš„ç®—æ³•
- âœ… **é«˜æ€§èƒ½**çš„å®ç°

**å…³é”®è¦ç‚¹**:

1. ä½¿ç”¨æ³›å‹çº¦æŸé™åˆ¶ç±»å‹
2. é›†æˆGo 1.25.3è¿­ä»£å™¨
3. æ³¨æ„çº¿ç¨‹å®‰å…¨
4. æ€§èƒ½æµ‹è¯•éªŒè¯
5. é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„

---

## ğŸ”— ç›¸å…³èµ„æº

- [æ³›å‹å®˜æ–¹æ–‡æ¡£](https://go.dev/doc/tutorial/generics)
- [è¿­ä»£å™¨ææ¡ˆ](https://go.dev/issue/61405)
- [æ€§èƒ½ä¼˜åŒ–æŒ‡å—](../07-æ€§èƒ½ä¼˜åŒ–/README.md)
- [å½¢å¼åŒ–ç†è®º](../01-è¯­è¨€åŸºç¡€/00-Go-1.25.3å½¢å¼åŒ–ç†è®ºä½“ç³»/README.md)

---

<div align="center">

**ä½¿ç”¨Go 1.25.3æ³›å‹ï¼Œç¼–å†™ç±»å‹å®‰å…¨çš„é«˜æ€§èƒ½ä»£ç **-

[ğŸ“š è¿”å›ç›®å½•](README.md) | [ğŸ“– ä¸‹ä¸€ç« ](02-å¸¸ç”¨ç®—æ³•.md)

Made with â¤ï¸ for Go Developers

</div>

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2025-10-29
**Goç‰ˆæœ¬**: Go 1.25.3
**æµ‹è¯•çŠ¶æ€**: âœ… æ‰€æœ‰ä»£ç å·²æµ‹è¯•
