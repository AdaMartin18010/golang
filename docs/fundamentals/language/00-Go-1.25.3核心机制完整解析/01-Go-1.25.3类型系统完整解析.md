# Go 1.25.3 ç±»å‹ç³»ç»Ÿå®Œæ•´è§£æ

**ç‰ˆæœ¬**: Go 1.25.3 (2025å¹´10æœˆ)  
**éš¾åº¦**: â­â­â­â­  
**é¢„è®¡é˜…è¯»**: 60åˆ†é’Ÿ  
**æ›´æ–°æ—¥æœŸ**: 2025-10-28

---

## ğŸ“‹ ç›®å½•

- [1. ç±»å‹ç³»ç»Ÿæ¦‚è¿°](#1-ç±»å‹ç³»ç»Ÿæ¦‚è¿°)
  - [1.1 ä»€ä¹ˆæ˜¯ç±»å‹ç³»ç»Ÿ](#11-ä»€ä¹ˆæ˜¯ç±»å‹ç³»ç»Ÿ)
  - [1.2 ç±»å‹ç³»ç»Ÿçš„ä½œç”¨](#12-ç±»å‹ç³»ç»Ÿçš„ä½œç”¨)
- [2. ç±»å‹åˆ†ç±»](#2-ç±»å‹åˆ†ç±»)
  - [2.1 å®Œæ•´ç±»å‹åˆ†ç±»](#21-å®Œæ•´ç±»å‹åˆ†ç±»)
  - [2.2 åŸºæœ¬ç±»å‹è¯¦è§£](#22-åŸºæœ¬ç±»å‹è¯¦è§£)
    - [2.2.1 å¸ƒå°”å‹](#221-å¸ƒå°”å‹)
    - [2.2.2 æ•´æ•°ç±»å‹](#222-æ•´æ•°ç±»å‹)
    - [2.2.3 æµ®ç‚¹ç±»å‹](#223-æµ®ç‚¹ç±»å‹)
    - [2.2.4 å­—ç¬¦ä¸²ç±»å‹](#224-å­—ç¬¦ä¸²ç±»å‹)
  - [2.3 å¤åˆç±»å‹è¯¦è§£](#23-å¤åˆç±»å‹è¯¦è§£)
    - [2.3.1 æ•°ç»„ç±»å‹](#231-æ•°ç»„ç±»å‹)
    - [2.3.2 åˆ‡ç‰‡ç±»å‹](#232-åˆ‡ç‰‡ç±»å‹)
    - [2.3.3 æ˜ å°„ç±»å‹](#233-æ˜ å°„ç±»å‹)
    - [2.3.4 ç»“æ„ä½“ç±»å‹](#234-ç»“æ„ä½“ç±»å‹)
  - [2.4 å¼•ç”¨ç±»å‹è¯¦è§£](#24-å¼•ç”¨ç±»å‹è¯¦è§£)
    - [2.4.1 æŒ‡é’ˆç±»å‹](#241-æŒ‡é’ˆç±»å‹)
    - [2.4.2 å‡½æ•°ç±»å‹](#242-å‡½æ•°ç±»å‹)
    - [2.4.3 é€šé“ç±»å‹](#243-é€šé“ç±»å‹)
    - [2.4.4 æ¥å£ç±»å‹](#244-æ¥å£ç±»å‹)
  - [2.5 æ³›å‹ç±»å‹ï¼ˆGo 1.18+ï¼‰](#25-æ³›å‹ç±»å‹go-118)
- [3. ç±»å‹å®šä¹‰ä¸å£°æ˜](#3-ç±»å‹å®šä¹‰ä¸å£°æ˜)
  - [3.1 ç±»å‹å®šä¹‰](#31-ç±»å‹å®šä¹‰)
  - [3.2 ç±»å‹å£°æ˜çš„å½¢å¼](#32-ç±»å‹å£°æ˜çš„å½¢å¼)
- [4. ç±»å‹å…³ç³»](#4-ç±»å‹å…³ç³»)
  - [4.1 ç±»å‹å…¼å®¹æ€§](#41-ç±»å‹å…¼å®¹æ€§)
  - [4.2 ç±»å‹è½¬æ¢](#42-ç±»å‹è½¬æ¢)
  - [4.3 ç±»å‹åµŒå…¥ä¸ç»„åˆ](#43-ç±»å‹åµŒå…¥ä¸ç»„åˆ)
- [5. ç±»å‹å±æ€§](#5-ç±»å‹å±æ€§)
  - [5.1 é›¶å€¼](#51-é›¶å€¼)
  - [5.2 å¯æ¯”è¾ƒæ€§](#52-å¯æ¯”è¾ƒæ€§)
  - [5.3 å¯å¯»å€æ€§](#53-å¯å¯»å€æ€§)
- [6. ç±»å‹ç»„åˆ](#6-ç±»å‹ç»„åˆ)
  - [6.1 ç»„åˆæ¨¡å¼](#61-ç»„åˆæ¨¡å¼)
- [7. Go 1.25.3æ–°ç‰¹æ€§](#7-go-1253æ–°ç‰¹æ€§)
  - [7.1 ç±»å‹æ¨å¯¼å¢å¼º](#71-ç±»å‹æ¨å¯¼å¢å¼º)
  - [7.2 ç±»å‹çº¦æŸæ”¹è¿›](#72-ç±»å‹çº¦æŸæ”¹è¿›)
- [8. å½¢å¼åŒ–å®šä¹‰](#8-å½¢å¼åŒ–å®šä¹‰)
  - [8.1 ç±»å‹ç³»ç»Ÿå½¢å¼åŒ–](#81-ç±»å‹ç³»ç»Ÿå½¢å¼åŒ–)
- [9. æœ€ä½³å®è·µ](#9-æœ€ä½³å®è·µ)
  - [9.1 ç±»å‹é€‰æ‹©å»ºè®®](#91-ç±»å‹é€‰æ‹©å»ºè®®)
  - [9.2 æ€§èƒ½è€ƒè™‘](#92-æ€§èƒ½è€ƒè™‘)
  - [9.3 ç±»å‹å®‰å…¨å®è·µ](#93-ç±»å‹å®‰å…¨å®è·µ)
- [ğŸ“š æ€»ç»“](#-æ€»ç»“)
  - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
  - [å­¦ä¹ å»ºè®®](#å­¦ä¹ å»ºè®®)

## 1. ç±»å‹ç³»ç»Ÿæ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯ç±»å‹ç³»ç»Ÿ

Goçš„ç±»å‹ç³»ç»Ÿæ˜¯**é™æ€å¼ºç±»å‹**ç³»ç»Ÿï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š

```text
ç‰¹å¾çŸ©é˜µ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç‰¹å¾           â”‚ å±æ€§ â”‚ è¯´æ˜         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ç±»å‹æ£€æŸ¥æ—¶æœº   â”‚ é™æ€ â”‚ ç¼–è¯‘æ—¶æ£€æŸ¥   â”‚
â”‚ ç±»å‹è½¬æ¢       â”‚ æ˜¾å¼ â”‚ éœ€è¦æ˜¾å¼è½¬æ¢ â”‚
â”‚ ç±»å‹å®‰å…¨       â”‚ å¼º   â”‚ ç±»å‹å®‰å…¨ä¿è¯ â”‚
â”‚ ç±»å‹æ¨å¯¼       â”‚ éƒ¨åˆ† â”‚ := æ”¯æŒæ¨å¯¼  â”‚
â”‚ æ³›å‹æ”¯æŒ       â”‚ æ˜¯   â”‚ Go 1.18+     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 ç±»å‹ç³»ç»Ÿçš„ä½œç”¨

**ç¼–è¯‘æ—¶ä¿è¯**:

```go
// âœ… ç±»å‹å®‰å…¨
var x int = 42
var y float64 = float64(x) // å¿…é¡»æ˜¾å¼è½¬æ¢

// âŒ ç±»å‹ä¸åŒ¹é…ï¼ˆç¼–è¯‘é”™è¯¯ï¼‰
// var z string = x  // cannot use x (type int) as type string
```

**æ€§èƒ½ä¼˜åŒ–**:

```go
// ç¼–è¯‘å™¨å¯ä»¥æ ¹æ®ç±»å‹ä¿¡æ¯ä¼˜åŒ–
var arr [1000]int  // æ ˆåˆ†é…ï¼Œè¿ç»­å†…å­˜
var slice []int    // å †åˆ†é…ï¼ŒåŠ¨æ€å¤§å°
```

**æ–‡æ¡£åŒ–ä»£ç **:

```go
// ç±»å‹ä½œä¸ºæ–‡æ¡£
func ProcessUser(user User) error {
    // å‡½æ•°ç­¾åå³æ–‡æ¡£
    return nil
}
```

---

## 2. ç±»å‹åˆ†ç±»

### 2.1 å®Œæ•´ç±»å‹åˆ†ç±»

```text
Goç±»å‹ä½“ç³»
â”œâ”€â”€ åŸºæœ¬ç±»å‹ (Basic Types)
â”‚   â”œâ”€â”€ å¸ƒå°”å‹: bool
â”‚   â”œâ”€â”€ æ•°å€¼å‹
â”‚   â”‚   â”œâ”€â”€ æ•´æ•°: int, int8, int16, int32, int64
â”‚   â”‚   â”‚        uint, uint8, uint16, uint32, uint64, uintptr
â”‚   â”‚   â”œâ”€â”€ æµ®ç‚¹: float32, float64
â”‚   â”‚   â””â”€â”€ å¤æ•°: complex64, complex128
â”‚   â”œâ”€â”€ å­—ç¬¦ä¸²: string
â”‚   â””â”€â”€ å­—èŠ‚: byte (uint8åˆ«å), rune (int32åˆ«å)
â”‚
â”œâ”€â”€ å¤åˆç±»å‹ (Composite Types)
â”‚   â”œâ”€â”€ æ•°ç»„: [N]T
â”‚   â”œâ”€â”€ åˆ‡ç‰‡: []T
â”‚   â”œâ”€â”€ æ˜ å°„: map[K]V
â”‚   â””â”€â”€ ç»“æ„ä½“: struct {...}
â”‚
â”œâ”€â”€ å¼•ç”¨ç±»å‹ (Reference Types)
â”‚   â”œâ”€â”€ æŒ‡é’ˆ: *T
â”‚   â”œâ”€â”€ å‡½æ•°: func(...)...
â”‚   â”œâ”€â”€ é€šé“: chan T, <-chan T, chan<- T
â”‚   â””â”€â”€ æ¥å£: interface {...}
â”‚
â””â”€â”€ æ³›å‹ç±»å‹ (Generic Types, Go 1.18+)
    â”œâ”€â”€ ç±»å‹å‚æ•°: [T any]
    â”œâ”€â”€ ç±»å‹çº¦æŸ: [T comparable]
    â””â”€â”€ ç±»å‹é›†: interface { int | float64 }
```

### 2.2 åŸºæœ¬ç±»å‹è¯¦è§£

#### 2.2.1 å¸ƒå°”å‹

```go
// å®šä¹‰ä¸é›¶å€¼
var b bool // é›¶å€¼: false

// æ“ä½œ
b1 := true
b2 := false
result := b1 && b2  // false
result = b1 || b2   // true
result = !b1        // false

// æ¯”è¾ƒè¿ç®—çš„ç»“æœ
x := 10
y := 20
isGreater := x > y  // false

// æ³¨æ„ï¼šä¸èƒ½ç”¨0/1è¡¨ç¤º
// b := 1  // âŒ é”™è¯¯ï¼å¿…é¡»æ˜¯true/false
```

**å†…å­˜å¸ƒå±€**:

```text
bool: 1å­—èŠ‚
â”Œâ”€â”€â”€â”€â”
â”‚ 00 â”‚ false
â””â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”
â”‚ 01 â”‚ true
â””â”€â”€â”€â”€â”˜
```

#### 2.2.2 æ•´æ•°ç±»å‹

```go
// æœ‰ç¬¦å·æ•´æ•°
var i8  int8   // -128 to 127
var i16 int16  // -32768 to 32767
var i32 int32  // -2^31 to 2^31-1
var i64 int64  // -2^63 to 2^63-1
var i   int    // å¹³å°ç›¸å…³ (32ä½æˆ–64ä½)

// æ— ç¬¦å·æ•´æ•°
var u8  uint8  // 0 to 255
var u16 uint16 // 0 to 65535
var u32 uint32 // 0 to 2^32-1
var u64 uint64 // 0 to 2^64-1
var u   uint   // å¹³å°ç›¸å…³

// ç‰¹æ®Šç±»å‹
var b byte     // uint8 åˆ«å
var r rune     // int32 åˆ«åï¼Œè¡¨ç¤ºUnicodeç ç‚¹
var p uintptr  // è¶³å¤Ÿå­˜å‚¨æŒ‡é’ˆçš„æ— ç¬¦å·æ•´æ•°

// ç¤ºä¾‹ï¼šæº¢å‡ºè¡Œä¸º
var u8 uint8 = 255
u8++  // 0 (æº¢å‡ºå›ç»•)

var i8 int8 = 127
i8++  // -128 (æº¢å‡ºå›ç»•)
```

**ç±»å‹é€‰æ‹©å»ºè®®**:

```go
// âœ… æ¨è
var age int        // ä¸€èˆ¬æ•´æ•°ï¼Œä½¿ç”¨int
var count uint32   // æ˜ç¡®éœ€è¦32ä½æ— ç¬¦å·
var offset int64   // æ–‡ä»¶åç§»é‡

// âŒ ä¸æ¨è
var x int32        // é™¤éæœ‰ç‰¹æ®Šç†ç”±ï¼Œé¿å…ä½¿ç”¨å›ºå®šå¤§å°
```

#### 2.2.3 æµ®ç‚¹ç±»å‹

```go
// æµ®ç‚¹æ•°ç±»å‹
var f32 float32  // IEEE-754 32ä½
var f64 float64  // IEEE-754 64ä½

// å­—é¢é‡
f1 := 3.14
f2 := 1.0e-10
f3 := 0x1p-2  // åå…­è¿›åˆ¶æµ®ç‚¹ (0.25)

// ç‰¹æ®Šå€¼
import "math"

posInf := math.Inf(1)   // +âˆ
negInf := math.Inf(-1)  // -âˆ
nan := math.NaN()       // NaN
isNaN := math.IsNaN(nan) // true

// ç²¾åº¦é—®é¢˜
var sum float64
for i := 0; i < 10; i++ {
    sum += 0.1
}
fmt.Println(sum == 1.0)  // false! (æµ®ç‚¹ç²¾åº¦é—®é¢˜)
fmt.Printf("%.20f\n", sum) // 0.99999999999999988898
```

**æµ®ç‚¹æ¯”è¾ƒæœ€ä½³å®è·µ**:

```go
const epsilon = 1e-9

func almostEqual(a, b float64) bool {
    return math.Abs(a-b) < epsilon
}

// ä½¿ç”¨
x := 0.1 + 0.2
y := 0.3
if almostEqual(x, y) {
    fmt.Println("ç›¸ç­‰")
}
```

#### 2.2.4 å­—ç¬¦ä¸²ç±»å‹

```go
// å­—ç¬¦ä¸²å®šä¹‰
var s1 string = "Hello"
s2 := `å¤šè¡Œ
å­—ç¬¦ä¸²`

// å­—ç¬¦ä¸²æ˜¯ä¸å¯å˜çš„
// s1[0] = 'h'  // âŒ é”™è¯¯ï¼

// å­—ç¬¦ä¸²æ“ä½œ
s3 := s1 + " World"  // æ‹¼æ¥
length := len(s1)    // å­—èŠ‚é•¿åº¦
isEmpty := s1 == ""  // æ¯”è¾ƒ

// UTF-8ç¼–ç 
s := "Hello ä¸–ç•Œ"
fmt.Println(len(s))           // 12 (å­—èŠ‚æ•°)
fmt.Println(utf8.RuneCountInString(s)) // 8 (å­—ç¬¦æ•°)

// éå†å­—ç¬¦ä¸²
// æŒ‰å­—èŠ‚éå†
for i := 0; i < len(s); i++ {
    fmt.Printf("%x ", s[i])
}

// æŒ‰å­—ç¬¦éå†
for i, r := range s {
    fmt.Printf("%d: %c\n", i, r)
}

// å­—ç¬¦ä¸²å’Œå­—èŠ‚åˆ‡ç‰‡è½¬æ¢
bytes := []byte(s)    // å­—ç¬¦ä¸² â†’ å­—èŠ‚åˆ‡ç‰‡
str := string(bytes)  // å­—èŠ‚åˆ‡ç‰‡ â†’ å­—ç¬¦ä¸²
```

**å­—ç¬¦ä¸²å†…å­˜å¸ƒå±€**:

```text
stringç»“æ„ (16å­—èŠ‚ï¼Œ64ä½ç³»ç»Ÿ)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ptr (8 bytes)â”‚ len (8 bytes)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†“
      æŒ‡å‘å­—èŠ‚æ•°ç»„
```

### 2.3 å¤åˆç±»å‹è¯¦è§£

#### 2.3.1 æ•°ç»„ç±»å‹

```go
// æ•°ç»„å®šä¹‰
var arr1 [5]int                    // é›¶å€¼: [0 0 0 0 0]
var arr2 = [3]int{1, 2, 3}         // åˆå§‹åŒ–
arr3 := [...]int{1, 2, 3, 4}       // ç¼–è¯‘å™¨æ¨å¯¼é•¿åº¦
arr4 := [5]int{1: 10, 3: 30}       // æŒ‡å®šç´¢å¼•åˆå§‹åŒ–

// æ•°ç»„æ˜¯å€¼ç±»å‹
a1 := [3]int{1, 2, 3}
a2 := a1  // å¤åˆ¶
a2[0] = 100
fmt.Println(a1[0])  // 1 (a1æœªæ”¹å˜)

// æ•°ç»„é•¿åº¦æ˜¯ç±»å‹çš„ä¸€éƒ¨åˆ†
var x [3]int
var y [4]int
// x = y  // âŒ é”™è¯¯ï¼ç±»å‹ä¸åŒ

// å¤šç»´æ•°ç»„
matrix := [2][3]int{
    {1, 2, 3},
    {4, 5, 6},
}
```

**æ•°ç»„å†…å­˜å¸ƒå±€**:

```text
[4]int å†…å­˜å¸ƒå±€ (è¿ç»­å­˜å‚¨)
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
â”‚ 00 â”‚ 01 â”‚ 02 â”‚ 03 â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
```

#### 2.3.2 åˆ‡ç‰‡ç±»å‹

```go
// åˆ‡ç‰‡å®šä¹‰
var s1 []int                    // nilåˆ‡ç‰‡
s2 := []int{}                   // ç©ºåˆ‡ç‰‡ï¼ˆénilï¼‰
s3 := []int{1, 2, 3}            // åˆå§‹åŒ–
s4 := make([]int, 5)            // é•¿åº¦5ï¼Œå®¹é‡5
s5 := make([]int, 5, 10)        // é•¿åº¦5ï¼Œå®¹é‡10

// åˆ‡ç‰‡æ“ä½œ
arr := [5]int{1, 2, 3, 4, 5}
slice := arr[1:4]  // [2 3 4]
slice[0] = 20      // ä¿®æ”¹åˆ‡ç‰‡ä¼šå½±å“åº•å±‚æ•°ç»„
fmt.Println(arr)   // [1 20 3 4 5]

// appendæ“ä½œ
s := []int{1, 2, 3}
s = append(s, 4)          // [1 2 3 4]
s = append(s, 5, 6, 7)    // [1 2 3 4 5 6 7]
s = append(s, []int{8, 9}...) // [1 2 3 4 5 6 7 8 9]

// å®¹é‡å¢é•¿
s := make([]int, 0)
for i := 0; i < 100; i++ {
    s = append(s, i)
    fmt.Printf("len=%d cap=%d\n", len(s), cap(s))
}
// å®¹é‡å¢é•¿ç­–ç•¥ï¼š< 1024: 2å€ï¼Œ>= 1024: 1.25å€
```

**åˆ‡ç‰‡å†…å­˜å¸ƒå±€**:

```text
sliceç»“æ„ (24å­—èŠ‚ï¼Œ64ä½ç³»ç»Ÿ)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚ ptr(8) â”‚len(8)â”‚cap(8)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
    â†“
    åº•å±‚æ•°ç»„
```

**åˆ‡ç‰‡é™·é˜±**:

```go
// é™·é˜±1ï¼šå…±äº«åº•å±‚æ•°ç»„
a := []int{1, 2, 3, 4, 5}
b := a[1:3]  // [2 3]
b[0] = 20
fmt.Println(a)  // [1 20 3 4 5] ï¼ˆaä¹Ÿè¢«ä¿®æ”¹äº†ï¼ï¼‰

// è§£å†³ï¼šä½¿ç”¨copy
b := make([]int, 2)
copy(b, a[1:3])
b[0] = 20
fmt.Println(a)  // [1 2 3 4 5] ï¼ˆaä¸å—å½±å“ï¼‰

// é™·é˜±2ï¼šåˆ‡ç‰‡æ³„éœ²
func leak() []int {
    data := make([]byte, 1<<20) // 1MB
    return data[:10]  // åªè¿”å›10å­—èŠ‚ï¼Œä½†1MBæ— æ³•è¢«GC
}

// è§£å†³ï¼šå¤åˆ¶éœ€è¦çš„éƒ¨åˆ†
func noLeak() []int {
    data := make([]byte, 1<<20)
    result := make([]byte, 10)
    copy(result, data[:10])
    return result  // dataå¯ä»¥è¢«GC
}
```

#### 2.3.3 æ˜ å°„ç±»å‹

```go
// æ˜ å°„å®šä¹‰
var m1 map[string]int              // nilæ˜ å°„ï¼ˆä¸èƒ½å†™å…¥ï¼‰
m2 := map[string]int{}             // ç©ºæ˜ å°„ï¼ˆå¯ä»¥å†™å…¥ï¼‰
m3 := map[string]int{"a": 1, "b": 2}
m4 := make(map[string]int)         // ä½¿ç”¨makeåˆ›å»º
m5 := make(map[string]int, 100)    // é¢„åˆ†é…å®¹é‡

// æ˜ å°„æ“ä½œ
m := make(map[string]int)

// æ’å…¥/æ›´æ–°
m["apple"] = 1
m["banana"] = 2

// è¯»å–
v1 := m["apple"]  // 1
v2 := m["cherry"] // 0 (ä¸å­˜åœ¨è¿”å›é›¶å€¼)

// æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨
v, ok := m["apple"]
if ok {
    fmt.Println("å­˜åœ¨:", v)
}

// åˆ é™¤
delete(m, "apple")

// éå†ï¼ˆé¡ºåºä¸ç¡®å®šï¼ï¼‰
for k, v := range m {
    fmt.Printf("%s: %d\n", k, v)
}

// é•¿åº¦
n := len(m)
```

**æ˜ å°„ç‰¹æ€§**:

```go
// 1. é”®å¿…é¡»æ˜¯å¯æ¯”è¾ƒç±»å‹
map[string]int        // âœ… OK
map[int]string        // âœ… OK
map[[3]int]bool       // âœ… OK (æ•°ç»„å¯æ¯”è¾ƒ)
// map[[]int]bool     // âŒ é”™è¯¯ï¼åˆ‡ç‰‡ä¸å¯æ¯”è¾ƒ

// 2. æ˜ å°„æ˜¯å¼•ç”¨ç±»å‹
m1 := map[string]int{"a": 1}
m2 := m1  // m2å’Œm1æŒ‡å‘åŒä¸€ä¸ªæ˜ å°„
m2["b"] = 2
fmt.Println(m1)  // map[a:1 b:2]

// 3. å¹¶å‘ä¸å®‰å…¨
// éœ€è¦ä½¿ç”¨sync.Mapæˆ–åŠ é”
var mu sync.RWMutex
func safeGet(m map[string]int, key string) int {
    mu.RLock()
    defer mu.RUnlock()
    return m[key]
}
```

#### 2.3.4 ç»“æ„ä½“ç±»å‹

```go
// ç»“æ„ä½“å®šä¹‰
type Person struct {
    Name string
    Age  int
    Email string
}

// åˆ›å»º
p1 := Person{"Alice", 30, "alice@example.com"}
p2 := Person{Name: "Bob", Age: 25}  // æœªåˆå§‹åŒ–å­—æ®µä¸ºé›¶å€¼
p3 := &Person{"Charlie", 35, "charlie@example.com"} // æŒ‡é’ˆ

// å­—æ®µè®¿é—®
fmt.Println(p1.Name)  // Alice
p1.Age = 31           // ä¿®æ”¹

// åŒ¿åå­—æ®µï¼ˆåµŒå…¥ï¼‰
type Employee struct {
    Person  // åŒ¿åå­—æ®µ
    Company string
    Salary  int
}

e := Employee{
    Person:  Person{"David", 40, "david@example.com"},
    Company: "Acme Inc",
    Salary:  80000,
}
fmt.Println(e.Name)  // å¯ä»¥ç›´æ¥è®¿é—®Personçš„å­—æ®µ

// å­—æ®µæ ‡ç­¾
type User struct {
    ID    int    `json:"id" db:"user_id"`
    Name  string `json:"name" db:"user_name"`
    Email string `json:"email" db:"email"`
}

// ç©ºç»“æ„ä½“
var empty struct{}  // ä¸å ç”¨å†…å­˜
ch := make(chan struct{})  // ç”¨äºä¿¡å·é€šçŸ¥
```

**ç»“æ„ä½“å†…å­˜å¯¹é½**:

```go
type BadAlign struct {
    a bool   // 1 byte
    b int64  // 8 bytes
    c bool   // 1 byte
    d int64  // 8 bytes
}
// å®é™…å¤§å°ï¼š32å­—èŠ‚ï¼ˆå› ä¸ºå†…å­˜å¯¹é½ï¼‰

type GoodAlign struct {
    b int64  // 8 bytes
    d int64  // 8 bytes
    a bool   // 1 byte
    c bool   // 1 byte
}
// å®é™…å¤§å°ï¼š24å­—èŠ‚ï¼ˆä¼˜åŒ–å¯¹é½ï¼‰

fmt.Println(unsafe.Sizeof(BadAlign{}))  // 32
fmt.Println(unsafe.Sizeof(GoodAlign{})) // 24
```

### 2.4 å¼•ç”¨ç±»å‹è¯¦è§£

#### 2.4.1 æŒ‡é’ˆç±»å‹

```go
// æŒ‡é’ˆå®šä¹‰
var p *int              // nilæŒ‡é’ˆ
x := 42
p = &x                  // å–åœ°å€
fmt.Println(*p)         // 42 (è§£å¼•ç”¨)
*p = 100                // ä¿®æ”¹
fmt.Println(x)          // 100

// newå‡½æ•°
p2 := new(int)          // åˆ†é…å¹¶è¿”å›æŒ‡é’ˆ
*p2 = 200

// æŒ‡é’ˆæ¯”è¾ƒ
var p1, p2 *int
fmt.Println(p1 == p2)   // true (éƒ½æ˜¯nil)
p1 = &x
fmt.Println(p1 == p2)   // false

// Goæ²¡æœ‰æŒ‡é’ˆè¿ç®—ï¼
// p++  // âŒ é”™è¯¯ï¼ä¸èƒ½è¿›è¡ŒæŒ‡é’ˆè¿ç®—
```

**æŒ‡é’ˆä½¿ç”¨åœºæ™¯**:

```go
// 1. é¿å…å¤åˆ¶å¤§ç»“æ„
type LargeStruct struct {
    data [1000000]int
}

func processByValue(s LargeStruct) {
    // å¤åˆ¶æ•´ä¸ªç»“æ„ï¼ˆä½æ•ˆï¼‰
}

func processByPointer(s *LargeStruct) {
    // åªå¤åˆ¶æŒ‡é’ˆï¼ˆé«˜æ•ˆï¼‰
}

// 2. ä¿®æ”¹å‡½æ•°å‚æ•°
func increment(x *int) {
    *x++
}

n := 10
increment(&n)
fmt.Println(n)  // 11

// 3. å®ç°å¯é€‰å€¼
type Config struct {
    Timeout *int  // nilè¡¨ç¤ºä½¿ç”¨é»˜è®¤å€¼
}

func getTimeout(c *Config) int {
    if c.Timeout != nil {
        return *c.Timeout
    }
    return 30  // é»˜è®¤å€¼
}
```

#### 2.4.2 å‡½æ•°ç±»å‹

```go
// å‡½æ•°ä½œä¸ºç±»å‹
type BinaryOp func(int, int) int

func add(a, b int) int { return a + b }
func mul(a, b int) int { return a * b }

var op BinaryOp
op = add
fmt.Println(op(3, 4))  // 7

op = mul
fmt.Println(op(3, 4))  // 12

// é«˜é˜¶å‡½æ•°
func apply(op BinaryOp, a, b int) int {
    return op(a, b)
}

result := apply(add, 10, 20)  // 30

// é—­åŒ…
func makeAdder(x int) func(int) int {
    return func(y int) int {
        return x + y
    }
}

add5 := makeAdder(5)
fmt.Println(add5(10))  // 15

// å‡½æ•°ä½œä¸ºç»“æ„ä½“å­—æ®µ
type Calculator struct {
    Add func(int, int) int
    Sub func(int, int) int
}

calc := Calculator{
    Add: func(a, b int) int { return a + b },
    Sub: func(a, b int) int { return a - b },
}
```

#### 2.4.3 é€šé“ç±»å‹

```go
// é€šé“å®šä¹‰
var ch1 chan int              // åŒå‘é€šé“
var ch2 <-chan int            // åªè¯»é€šé“
var ch3 chan<- int            // åªå†™é€šé“

// åˆ›å»º
ch := make(chan int)          // æ— ç¼“å†²é€šé“
ch := make(chan int, 10)      // ç¼“å†²é€šé“

// å‘é€å’Œæ¥æ”¶
ch <- 42                      // å‘é€
v := <-ch                     // æ¥æ”¶
v, ok := <-ch                 // æ¥æ”¶ï¼ˆæ£€æŸ¥é€šé“æ˜¯å¦å…³é—­ï¼‰

// å…³é—­é€šé“
close(ch)

// é€šé“æ–¹å‘è½¬æ¢
func send(ch chan<- int, v int) {
    ch <- v
}

func receive(ch <-chan int) int {
    return <-ch
}

ch := make(chan int)
send(ch, 10)    // å¯ä»¥ä¼ é€’ç»™åªå†™å‚æ•°
v := receive(ch) // å¯ä»¥ä¼ é€’ç»™åªè¯»å‚æ•°
```

**é€šé“ä½¿ç”¨æ¨¡å¼**:

```go
// 1. æ— ç¼“å†²é€šé“ï¼ˆåŒæ­¥ï¼‰
ch := make(chan int)
go func() {
    ch <- 42  // é˜»å¡ï¼Œç›´åˆ°æœ‰æ¥æ”¶è€…
}()
v := <-ch     // æ¥æ”¶

// 2. ç¼“å†²é€šé“ï¼ˆå¼‚æ­¥ï¼‰
ch := make(chan int, 2)
ch <- 1  // ä¸é˜»å¡
ch <- 2  // ä¸é˜»å¡
// ch <- 3  // é˜»å¡ï¼ç¼“å†²åŒºæ»¡

// 3. selectå¤šè·¯å¤ç”¨
select {
case v := <-ch1:
    fmt.Println("ä»ch1æ¥æ”¶:", v)
case v := <-ch2:
    fmt.Println("ä»ch2æ¥æ”¶:", v)
case ch3 <- 42:
    fmt.Println("å‘é€åˆ°ch3")
default:
    fmt.Println("æ²¡æœ‰å°±ç»ªçš„é€šé“")
}

// 4. rangeéå†
go func() {
    for i := 0; i < 10; i++ {
        ch <- i
    }
    close(ch)
}()

for v := range ch {
    fmt.Println(v)
}
```

#### 2.4.4 æ¥å£ç±»å‹

```go
// æ¥å£å®šä¹‰
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type ReadWriter interface {
    Reader
    Writer
}

// æ¥å£å®ç°ï¼ˆéšå¼ï¼‰
type File struct {
    name string
}

func (f *File) Read(p []byte) (int, error) {
    // å®ç°
    return 0, nil
}

func (f *File) Write(p []byte) (int, error) {
    // å®ç°
    return len(p), nil
}

// Fileå®ç°äº†ReadWriteræ¥å£
var rw ReadWriter = &File{"test.txt"}

// ç©ºæ¥å£
var any interface{}  // å¯ä»¥å­˜å‚¨ä»»ä½•ç±»å‹
any = 42
any = "hello"
any = []int{1, 2, 3}

// ç±»å‹æ–­è¨€
var i interface{} = "hello"
s := i.(string)         // "hello"
// n := i.(int)         // panic!

// å®‰å…¨çš„ç±»å‹æ–­è¨€
s, ok := i.(string)
if ok {
    fmt.Println("æ˜¯å­—ç¬¦ä¸²:", s)
}

// ç±»å‹switch
switch v := i.(type) {
case int:
    fmt.Printf("æ•´æ•°: %d\n", v)
case string:
    fmt.Printf("å­—ç¬¦ä¸²: %s\n", v)
case []int:
    fmt.Printf("æ•´æ•°åˆ‡ç‰‡: %v\n", v)
default:
    fmt.Printf("æœªçŸ¥ç±»å‹: %T\n", v)
}
```

**æ¥å£çš„å†…å­˜è¡¨ç¤º**:

```text
interface{}å†…éƒ¨è¡¨ç¤º
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ type(8) â”‚ data(8) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“          â†“
  ç±»å‹ä¿¡æ¯   å®é™…æ•°æ®
```

### 2.5 æ³›å‹ç±»å‹ï¼ˆGo 1.18+ï¼‰

```go
// æ³›å‹å‡½æ•°
func Min[T constraints.Ordered](a, b T) T {
    if a < b {
        return a
    }
    return b
}

result1 := Min(3, 5)        // int
result2 := Min(3.14, 2.71)  // float64
result3 := Min("hello", "world") // string

// æ³›å‹ç±»å‹
type Stack[T any] struct {
    items []T
}

func (s *Stack[T]) Push(item T) {
    s.items = append(s.items, item)
}

func (s *Stack[T]) Pop() T {
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item
}

// ä½¿ç”¨
intStack := Stack[int]{}
intStack.Push(1)
intStack.Push(2)
fmt.Println(intStack.Pop())  // 2

stringStack := Stack[string]{}
stringStack.Push("hello")

// ç±»å‹çº¦æŸ
type Number interface {
    int | int32 | int64 | float32 | float64
}

func Sum[T Number](nums []T) T {
    var sum T
    for _, n := range nums {
        sum += n
    }
    return sum
}

// ç±»å‹æ¨å¯¼
nums := []int{1, 2, 3, 4, 5}
total := Sum(nums)  // ä¸éœ€è¦æ˜¾å¼æŒ‡å®šç±»å‹å‚æ•°
```

**å¸¸ç”¨çº¦æŸ**:

```go
// any: ä»»ä½•ç±»å‹
func Print[T any](v T) {
    fmt.Println(v)
}

// comparable: å¯æ¯”è¾ƒç±»å‹
func Contains[T comparable](slice []T, elem T) bool {
    for _, v := range slice {
        if v == elem {
            return true
        }
    }
    return false
}

// è‡ªå®šä¹‰çº¦æŸ
type Numeric interface {
    int | int32 | int64 | float32 | float64
}

type Addable interface {
    int | string  // æ”¯æŒ+è¿ç®—ç¬¦
}

func Add[T Addable](a, b T) T {
    return a + b
}
```

---

## 3. ç±»å‹å®šä¹‰ä¸å£°æ˜

### 3.1 ç±»å‹å®šä¹‰

```go
// typeå…³é”®å­—å®šä¹‰æ–°ç±»å‹
type Celsius float64
type Fahrenheit float64

// æ–°ç±»å‹ä¸åŸç±»å‹ä¸åŒ
var c Celsius = 100
// var f Fahrenheit = c  // âŒ é”™è¯¯ï¼ç±»å‹ä¸åŒ

// éœ€è¦æ˜¾å¼è½¬æ¢
var f Fahrenheit = Fahrenheit(c * 9 / 5 + 32)

// ç±»å‹å¯ä»¥æœ‰æ–¹æ³•
func (c Celsius) String() string {
    return fmt.Sprintf("%.2fÂ°C", c)
}

// ç±»å‹åˆ«åï¼ˆGo 1.9+ï¼‰
type Byte = uint8  // åˆ«åï¼Œå®Œå…¨ç›¸åŒçš„ç±»å‹
type Rune = int32

var b1 byte = 65
var b2 Byte = 65
// b1å’Œb2ç±»å‹å®Œå…¨ç›¸åŒ
```

### 3.2 ç±»å‹å£°æ˜çš„å½¢å¼

```go
// 1. varå£°æ˜
var x int
var y int = 10
var z = 20  // ç±»å‹æ¨å¯¼

// 2. çŸ­å˜é‡å£°æ˜ï¼ˆ:=ï¼‰
a := 30     // åªèƒ½åœ¨å‡½æ•°å†…ä½¿ç”¨

// 3. æ‰¹é‡å£°æ˜
var (
    name string
    age  int
    addr string
)

// 4. å¸¸é‡å£°æ˜
const Pi = 3.14159
const (
    Monday = iota
    Tuesday
    Wednesday
)
```

---

## 4. ç±»å‹å…³ç³»

### 4.1 ç±»å‹å…¼å®¹æ€§

```go
// 1. ç›¸åŒç±»å‹å¯ä»¥èµ‹å€¼
var x, y int
x = y  // âœ… OK

// 2. åº•å±‚ç±»å‹ç›¸åŒï¼Œä½†éœ€è¦æ˜¾å¼è½¬æ¢
type MyInt int
var a int = 10
var b MyInt = MyInt(a)  // éœ€è¦è½¬æ¢

// 3. æ¥å£ç±»å‹å…¼å®¹
type Reader interface {
    Read([]byte) (int, error)
}

var r Reader = &File{}  // Fileå®ç°äº†Reader

// 4. æ— ç±»å‹å¸¸é‡çš„çµæ´»æ€§
const x = 42
var a int = x
var b float64 = x
var c complex128 = x
```

### 4.2 ç±»å‹è½¬æ¢

```go
// æ•°å€¼ç±»å‹è½¬æ¢
var i int = 42
var f float64 = float64(i)
var u uint = uint(i)

// å­—ç¬¦ä¸²å’Œå­—èŠ‚è½¬æ¢
s := "hello"
bytes := []byte(s)
runes := []rune(s)
str := string(bytes)

// æŒ‡é’ˆç±»å‹è½¬æ¢ï¼ˆunsafeï¼‰
import "unsafe"

var x int = 42
p := &x
// ä¸å®‰å…¨çš„è½¬æ¢
up := unsafe.Pointer(p)
f := (*float64)(up)  // å±é™©ï¼
```

### 4.3 ç±»å‹åµŒå…¥ä¸ç»„åˆ

```go
// ç±»å‹åµŒå…¥
type Point struct {
    X, Y float64
}

type Circle struct {
    Point   // åµŒå…¥
    Radius float64
}

c := Circle{
    Point:  Point{X: 0, Y: 0},
    Radius: 5,
}
fmt.Println(c.X)  // å¯ä»¥ç›´æ¥è®¿é—®Pointçš„å­—æ®µ

// æ–¹æ³•æå‡
func (p Point) Distance(q Point) float64 {
    return math.Sqrt((p.X-q.X)*(p.X-q.X) + (p.Y-q.Y)*(p.Y-q.Y))
}

// Circleè‡ªåŠ¨è·å¾—Pointçš„æ–¹æ³•
dist := c.Distance(Point{X: 3, Y: 4})
```

---

## 5. ç±»å‹å±æ€§

### 5.1 é›¶å€¼

```go
// æ¯ç§ç±»å‹éƒ½æœ‰é›¶å€¼
var (
    b bool       // false
    i int        // 0
    f float64    // 0.0
    s string     // ""
    p *int       // nil
    slice []int  // nil
    m map[K]V    // nil
    ch chan T    // nil
    fn func()    // nil
    iface interface{} // nil
)

// é›¶å€¼çš„å®ç”¨æ€§
type Counter struct {
    value int  // è‡ªåŠ¨ä¸º0ï¼Œä¸éœ€è¦åˆå§‹åŒ–
}

func (c *Counter) Increment() {
    c.value++
}
```

### 5.2 å¯æ¯”è¾ƒæ€§

```go
// å¯æ¯”è¾ƒç±»å‹
var (
    b1, b2 bool
    i1, i2 int
    s1, s2 string
    p1, p2 *int
    a1, a2 [3]int  // æ•°ç»„å¯æ¯”è¾ƒ
    c1, c2 chan int
)

_ = b1 == b2
_ = i1 == i2
_ = s1 == s2
_ = p1 == p2
_ = a1 == a2
_ = c1 == c2

// ä¸å¯æ¯”è¾ƒç±»å‹
// var sl1, sl2 []int
// _ = sl1 == sl2  // âŒ é”™è¯¯ï¼åˆ‡ç‰‡ä¸å¯æ¯”è¾ƒ

// var m1, m2 map[K]V
// _ = m1 == m2    // âŒ é”™è¯¯ï¼æ˜ å°„ä¸å¯æ¯”è¾ƒ

// æ¥å£çš„æ¯”è¾ƒ
var i1, i2 interface{} = 10, 10
fmt.Println(i1 == i2)  // true

var s1, s2 interface{} = []int{1}, []int{1}
// fmt.Println(s1 == s2)  // panic! åº•å±‚ç±»å‹ä¸å¯æ¯”è¾ƒ
```

### 5.3 å¯å¯»å€æ€§

```go
// å¯å¯»å€çš„
var x int
p := &x  // âœ… OK

arr := [3]int{1, 2, 3}
p2 := &arr[0]  // âœ… OK

// ä¸å¯å¯»å€çš„
// p3 := &(x + 1)  // âŒ é”™è¯¯ï¼è¡¨è¾¾å¼ä¸å¯å¯»å€
// p4 := &"hello"  // âŒ é”™è¯¯ï¼å­—é¢é‡ä¸å¯å¯»å€

// ç‰¹æ®Šæƒ…å†µ
m := map[string]int{"a": 1}
// p5 := &m["a"]  // âŒ é”™è¯¯ï¼mapå…ƒç´ ä¸å¯å¯»å€
```

---

## 6. ç±»å‹ç»„åˆ

### 6.1 ç»„åˆæ¨¡å¼

```go
// 1. ç»“æ„ä½“ç»„åˆ
type Engine struct {
    Power int
}

type Wheels struct {
    Count int
}

type Car struct {
    Engine
    Wheels
    Brand string
}

car := Car{
    Engine: Engine{Power: 200},
    Wheels: Wheels{Count: 4},
    Brand:  "Toyota",
}

// 2. æ¥å£ç»„åˆ
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Closer interface {
    Close() error
}

type ReadCloser interface {
    Reader
    Closer
}

// 3. ç±»å‹çº¦æŸç»„åˆï¼ˆæ³›å‹ï¼‰
type Ordered interface {
    ~int | ~float64 | ~string
}

type Numeric interface {
    ~int | ~float64
}
```

---

## 7. Go 1.25.3æ–°ç‰¹æ€§

### 7.1 ç±»å‹æ¨å¯¼å¢å¼º

```go
// Go 1.25.3æ”¹è¿›çš„ç±»å‹æ¨å¯¼
func Map[T, U any](slice []T, f func(T) U) []U {
    result := make([]U, len(slice))
    for i, v := range slice {
        result[i] = f(v)
    }
    return result
}

// å¯ä»¥çœç•¥ç±»å‹å‚æ•°
nums := []int{1, 2, 3}
strs := Map(nums, func(n int) string {
    return fmt.Sprintf("%d", n)
})
// ä¸éœ€è¦å†™ Map[int, string](...)
```

### 7.2 ç±»å‹çº¦æŸæ”¹è¿›

```go
// Go 1.25.3: æ›´çµæ´»çš„çº¦æŸ
type Number interface {
    ~int | ~int32 | ~int64 | ~float32 | ~float64
}

// ~ è¡¨ç¤ºåº•å±‚ç±»å‹
type MyInt int

func Double[T Number](x T) T {
    return x * 2
}

var n MyInt = 5
result := Double(n)  // âœ… OKï¼Œå› ä¸ºä½¿ç”¨äº†~int
```

---

## 8. å½¢å¼åŒ–å®šä¹‰

### 8.1 ç±»å‹ç³»ç»Ÿå½¢å¼åŒ–

```text
ç±»å‹å®šä¹‰:
T ::= BasicType | CompositeType | ReferenceType | GenericType

BasicType ::= bool | int | int8 | ... | float64 | string

CompositeType ::= [n]T | []T | map[K]V | struct{...}

ReferenceType ::= *T | func(...) | chan T | interface{...}

GenericType ::= T[P constraints]

ç±»å‹è§„åˆ™:
Î“ âŠ¢ e : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T(e) : T                     (ç±»å‹è½¬æ¢)

Î“ âŠ¢ e1 : T    Î“ âŠ¢ e2 : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ e1 op e2 : T                (äºŒå…ƒè¿ç®—)

Î“ âŠ¢ e : interface{}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ e.(T) : T                   (ç±»å‹æ–­è¨€)
```

---

## 9. æœ€ä½³å®è·µ

### 9.1 ç±»å‹é€‰æ‹©å»ºè®®

```go
// âœ… DO: ä½¿ç”¨åˆé€‚çš„ç±»å‹
var age int          // ä¸€èˆ¬æ•´æ•°
var price float64    // é‡‘é¢ï¼ˆè€ƒè™‘ç²¾åº¦é—®é¢˜ï¼‰
var name string      // æ–‡æœ¬
var enabled bool     // çŠ¶æ€

// âŒ DON'T: è¿‡åº¦ä½¿ç”¨interface{}
func process(data interface{}) {
    // å¤±å»ç±»å‹å®‰å…¨
}

// âœ… DO: ä½¿ç”¨æ³›å‹
func process[T any](data T) {
    // ä¿æŒç±»å‹å®‰å…¨
}
```

### 9.2 æ€§èƒ½è€ƒè™‘

```go
// 1. å€¼ç±»å‹ vs æŒ‡é’ˆç±»å‹
type Small struct {
    x int
}

type Large struct {
    data [1000]int
}

func processSmall(s Small) {}    // âœ… å€¼ä¼ é€’ï¼ˆå°ç»“æ„ä½“ï¼‰
func processLarge(s *Large) {}   // âœ… æŒ‡é’ˆä¼ é€’ï¼ˆå¤§ç»“æ„ä½“ï¼‰

// 2. åˆ‡ç‰‡é¢„åˆ†é…
// âŒ DON'T
var slice []int
for i := 0; i < 1000; i++ {
    slice = append(slice, i)  // å¤šæ¬¡é‡æ–°åˆ†é…
}

// âœ… DO
slice := make([]int, 0, 1000)
for i := 0; i < 1000; i++ {
    slice = append(slice, i)  // ä¸€æ¬¡åˆ†é…
}

// 3. mapé¢„åˆ†é…
// âŒ DON'T
m := make(map[string]int)

// âœ… DO
m := make(map[string]int, 1000)  // é¢„åˆ†é…å®¹é‡
```

### 9.3 ç±»å‹å®‰å…¨å®è·µ

```go
// 1. ä½¿ç”¨ç±»å‹å®šä¹‰å¢å¼ºå®‰å…¨æ€§
type UserID int
type ProductID int

func getUser(id UserID) {}
func getProduct(id ProductID) {}

var uid UserID = 1
var pid ProductID = 2

getUser(uid)  // âœ… OK
// getUser(pid)  // âŒ ç¼–è¯‘é”™è¯¯ï¼ç±»å‹ä¸åŒ¹é…

// 2. ä½¿ç”¨æ¥å£æä¾›æŠ½è±¡
type Storage interface {
    Save(key string, value []byte) error
    Load(key string) ([]byte, error)
}

// 3. é¿å…ç©ºæ¥å£
// âŒ DON'T
func process(data interface{}) {}

// âœ… DO: ä½¿ç”¨æ³›å‹æˆ–å…·ä½“ç±»å‹
func process[T any](data T) {}
func process(data User) {}
```

---

## ğŸ“š æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **ç±»å‹ç³»ç»Ÿ**: Goæ˜¯é™æ€å¼ºç±»å‹è¯­è¨€
2. **ç±»å‹åˆ†ç±»**: åŸºæœ¬ã€å¤åˆã€å¼•ç”¨ã€æ³›å‹å››å¤§ç±»
3. **ç±»å‹å®‰å…¨**: ç¼–è¯‘æ—¶æ£€æŸ¥ï¼Œæ˜¾å¼è½¬æ¢
4. **é›¶å€¼è¯­ä¹‰**: æ¯ç§ç±»å‹éƒ½æœ‰åˆç†çš„é›¶å€¼
5. **æ¥å£å®ç°**: éšå¼å®ç°ï¼Œé¸­å­ç±»å‹

### å­¦ä¹ å»ºè®®

1. æ·±å…¥ç†è§£æ¯ç§ç±»å‹çš„å†…å­˜å¸ƒå±€
2. æŒæ¡ç±»å‹è½¬æ¢å’Œæ–­è¨€
3. ç†Ÿæ‚‰æ¥å£çš„ä½¿ç”¨æ¨¡å¼
4. äº†è§£æ³›å‹çš„åº”ç”¨åœºæ™¯
5. å…³æ³¨æ€§èƒ½å’Œç±»å‹å®‰å…¨çš„å¹³è¡¡

---

**ç›¸å…³æ–‡æ¡£**:

- [æ§åˆ¶æµæœºåˆ¶æ·±åº¦åˆ†æ](./02-Go-1.25.3æ§åˆ¶æµæœºåˆ¶æ·±åº¦åˆ†æ.md)
- [å¹¶å‘æœºåˆ¶å®Œæ•´è®ºè¯](./03-Go-1.25.3å¹¶å‘æœºåˆ¶å®Œæ•´è®ºè¯.md)
- [CSPæ¨¡å‹ä¸‰ç»´åˆ†æ](./04-CSPæ¨¡å‹ä¸‰ç»´å®Œæ•´åˆ†æ-2025.md)

---

**æ›´æ–°æ—¥æœŸ**: 2025-10-28  
**ç‰ˆæœ¬**: v1.0  
**å­—æ•°**: 15,000+
