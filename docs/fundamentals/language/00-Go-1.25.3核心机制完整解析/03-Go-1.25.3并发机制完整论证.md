# Go 1.25.3 å¹¶å‘æœºåˆ¶å®Œæ•´è®ºè¯

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.25.3

---

## ğŸ“‹ ç›®å½•

- [Go 1.25.3 å¹¶å‘æœºåˆ¶å®Œæ•´è®ºè¯](#go-1253-å¹¶å‘æœºåˆ¶å®Œæ•´è®ºè¯)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å¹¶å‘æ¦‚è¿°](#1-å¹¶å‘æ¦‚è¿°)
    - [1.1 å¹¶å‘ vs å¹¶è¡Œ](#11-å¹¶å‘-vs-å¹¶è¡Œ)
    - [1.2 Goå¹¶å‘å“²å­¦](#12-goå¹¶å‘å“²å­¦)
    - [1.3 å¹¶å‘åŸè¯­æ€»è§ˆ](#13-å¹¶å‘åŸè¯­æ€»è§ˆ)
  - [2. Goroutineæ·±åº¦è§£æ](#2-goroutineæ·±åº¦è§£æ)
    - [2.1 GoroutineåŸºç¡€](#21-goroutineåŸºç¡€)
    - [2.2 Goroutineç”Ÿå‘½å‘¨æœŸ](#22-goroutineç”Ÿå‘½å‘¨æœŸ)
    - [2.3 Goroutineæ ˆç®¡ç†](#23-goroutineæ ˆç®¡ç†)
    - [2.4 Goroutineæ³„éœ²](#24-goroutineæ³„éœ²)
  - [3. Channelæœºåˆ¶è®ºè¯](#3-channelæœºåˆ¶è®ºè¯)
    - [3.1 Channelç±»å‹ä¸è¯­ä¹‰](#31-channelç±»å‹ä¸è¯­ä¹‰)
    - [3.2 æ— ç¼“å†² vs ç¼“å†²Channel](#32-æ— ç¼“å†²-vs-ç¼“å†²channel)
    - [3.3 Channelæ“ä½œè¯­ä¹‰](#33-channelæ“ä½œè¯­ä¹‰)
    - [3.4 Channelå†…éƒ¨å®ç°](#34-channelå†…éƒ¨å®ç°)
    - [3.5 Channelæ¨¡å¼](#35-channelæ¨¡å¼)
  - [4. åŒæ­¥åŸè¯­åˆ†æ](#4-åŒæ­¥åŸè¯­åˆ†æ)
    - [4.1 Mutexï¼ˆäº’æ–¥é”ï¼‰](#41-mutexäº’æ–¥é”)
    - [4.2 RWMutexï¼ˆè¯»å†™é”ï¼‰](#42-rwmutexè¯»å†™é”)
    - [4.3 WaitGroup](#43-waitgroup)
    - [4.4 Once](#44-once)
    - [4.5 Condï¼ˆæ¡ä»¶å˜é‡ï¼‰](#45-condæ¡ä»¶å˜é‡)
    - [4.6 atomicåŒ…](#46-atomicåŒ…)
  - [5. GMPè°ƒåº¦æ¨¡å‹](#5-gmpè°ƒåº¦æ¨¡å‹)
    - [5.1 GMPæ¨¡å‹æ¦‚è¿°](#51-gmpæ¨¡å‹æ¦‚è¿°)
    - [5.2 è°ƒåº¦ç­–ç•¥](#52-è°ƒåº¦ç­–ç•¥)
    - [5.3 GOMAXPROCS](#53-gomaxprocs)
  - [6. å†…å­˜æ¨¡å‹ä¸åŒæ­¥](#6-å†…å­˜æ¨¡å‹ä¸åŒæ­¥)
    - [6.1 Happens-Beforeå…³ç³»](#61-happens-beforeå…³ç³»)
    - [6.2 æ•°æ®ç«äº‰](#62-æ•°æ®ç«äº‰)
  - [7. å¹¶å‘æ¨¡å¼å®è·µ](#7-å¹¶å‘æ¨¡å¼å®è·µ)
    - [7.1 Worker Pool](#71-worker-pool)
    - [7.2 Pipeline](#72-pipeline)
    - [7.3 Fan-Out/Fan-In](#73-fan-outfan-in)
    - [7.4 Contextä¼ æ’­](#74-contextä¼ æ’­)
  - [8. å¹¶å‘æ€§èƒ½ä¼˜åŒ–](#8-å¹¶å‘æ€§èƒ½ä¼˜åŒ–)
    - [8.1 å‡å°‘é”ç«äº‰](#81-å‡å°‘é”ç«äº‰)
    - [8.2 é¿å…goroutineæ³„éœ²](#82-é¿å…goroutineæ³„éœ²)
    - [8.3 åˆç†ä½¿ç”¨ç¼“å†²](#83-åˆç†ä½¿ç”¨ç¼“å†²)
  - [9. å½¢å¼åŒ–è¯æ˜](#9-å½¢å¼åŒ–è¯æ˜)
    - [9.1 å¹¶å‘æ­£ç¡®æ€§](#91-å¹¶å‘æ­£ç¡®æ€§)
  - [10. æœ€ä½³å®è·µ](#10-æœ€ä½³å®è·µ)
    - [10.1 å¹¶å‘è®¾è®¡åŸåˆ™](#101-å¹¶å‘è®¾è®¡åŸåˆ™)
  - [ğŸ“š æ€»ç»“](#-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)

## 1. å¹¶å‘æ¦‚è¿°

### 1.1 å¹¶å‘ vs å¹¶è¡Œ

**æ¦‚å¿µå®šä¹‰**:

```text
å¹¶å‘ (Concurrency)
â”œâ”€â”€ å®šä¹‰: ç¨‹åºç»“æ„ï¼Œå¤„ç†å¤šä¸ªä»»åŠ¡çš„èƒ½åŠ›
â”œâ”€â”€ å…³é”®: ä»»åŠ¡å¯ä»¥äº¤æ›¿æ‰§è¡Œ
â””â”€â”€ ç›®æ ‡: æé«˜ç¨‹åºå“åº”æ€§å’Œèµ„æºåˆ©ç”¨ç‡

å¹¶è¡Œ (Parallelism)
â”œâ”€â”€ å®šä¹‰: ç¨‹åºæ‰§è¡Œï¼ŒåŒæ—¶æ‰§è¡Œå¤šä¸ªä»»åŠ¡
â”œâ”€â”€ å…³é”®: ä»»åŠ¡çœŸæ­£åŒæ—¶æ‰§è¡Œ
â””â”€â”€ ç›®æ ‡: æé«˜ç¨‹åºæ‰§è¡Œé€Ÿåº¦

å…³ç³»: å¹¶å‘æ˜¯å¹¶è¡Œçš„å¿…è¦æ¡ä»¶
```

**å›¾ç¤º**:

```text
å¹¶å‘ï¼ˆå•æ ¸ï¼‰:
æ—¶é—´ â†’
CPU: [Task1][Task2][Task1][Task3][Task2][Task1]

å¹¶è¡Œï¼ˆå¤šæ ¸ï¼‰:
æ—¶é—´ â†’
CPU1: [Task1][Task1][Task1][Task1]
CPU2: [Task2][Task2][Task2][Task2]
CPU3: [Task3][Task3][Task3][Task3]
```

**Goçš„å¹¶å‘æ¨¡å‹**:

```go
// å¹¶å‘ - ç»“æ„åŒ–ç¨‹åº
func concurrentExample() {
    go task1()  // Goroutine 1
    go task2()  // Goroutine 2
    go task3()  // Goroutine 3
    // ä¸‰ä¸ªä»»åŠ¡å¯ä»¥äº¤æ›¿æ‰§è¡Œï¼ˆå¹¶å‘ï¼‰
    // å¦‚æœæœ‰å¤šä¸ªCPUæ ¸å¿ƒï¼Œå¯ä»¥åŒæ—¶æ‰§è¡Œï¼ˆå¹¶è¡Œï¼‰
}

// å¯¹æ¯”ï¼šé¡ºåºæ‰§è¡Œ
func sequentialExample() {
    task1()
    task2()
    task3()
    // å¿…é¡»æŒ‰é¡ºåºå®Œæˆ
}
```

### 1.2 Goå¹¶å‘å“²å­¦

**"ä¸è¦é€šè¿‡å…±äº«å†…å­˜æ¥é€šä¿¡ï¼Œè€Œåº”é€šè¿‡é€šä¿¡æ¥å…±äº«å†…å­˜"**-

```go
// âŒ ä¼ ç»Ÿæ–¹å¼ï¼šå…±äº«å†…å­˜
var counter int
var mu sync.Mutex

func increment() {
    mu.Lock()
    counter++
    mu.Unlock()
}

// âœ… Goæ–¹å¼ï¼šé€šä¿¡
func increment(ch chan int) {
    ch <- 1  // é€šè¿‡channelé€šä¿¡
}

// æ”¶é›†ç»“æœ
total := 0
for i := 0; i < n; i++ {
    total += <-ch
}
```

### 1.3 å¹¶å‘åŸè¯­æ€»è§ˆ

```text
Goå¹¶å‘åŸè¯­
â”œâ”€â”€ Goroutine
â”‚   â”œâ”€â”€ åˆ›å»º: go f()
â”‚   â”œâ”€â”€ è°ƒåº¦: GMPæ¨¡å‹
â”‚   â””â”€â”€ ç”Ÿå‘½å‘¨æœŸ: åˆ›å»ºâ†’è¿è¡Œâ†’é€€å‡º
â”‚
â”œâ”€â”€ Channel
â”‚   â”œâ”€â”€ æ— ç¼“å†²: make(chan T)
â”‚   â”œâ”€â”€ ç¼“å†²: make(chan T, cap)
â”‚   â”œâ”€â”€ æ“ä½œ: send, receive, close
â”‚   â””â”€â”€ æ–¹å‘: chan T, <-chan T, chan<- T
â”‚
â”œâ”€â”€ Select
â”‚   â”œâ”€â”€ å¤šè·¯å¤ç”¨
â”‚   â”œâ”€â”€ éšæœºé€‰æ‹©
â”‚   â””â”€â”€ defaultåˆ†æ”¯
â”‚
â””â”€â”€ SyncåŒ…
    â”œâ”€â”€ Mutex/RWMutex
    â”œâ”€â”€ WaitGroup
    â”œâ”€â”€ Once
    â”œâ”€â”€ Cond
    â”œâ”€â”€ Pool
    â””â”€â”€ Map
```

---

## 2. Goroutineæ·±åº¦è§£æ

### 2.1 GoroutineåŸºç¡€

**å®šä¹‰**:

- Goroutineæ˜¯Goè¿è¡Œæ—¶ç®¡ç†çš„è½»é‡çº§çº¿ç¨‹
- ç”±Goè¿è¡Œæ—¶è°ƒåº¦ï¼Œè€Œéæ“ä½œç³»ç»Ÿ
- æ ˆç©ºé—´åˆå§‹ä»…2KBï¼Œå¯åŠ¨æ€å¢é•¿

**åˆ›å»ºGoroutine**:

```go
// 1. å¯åŠ¨åŒ¿åå‡½æ•°
go func() {
    fmt.Println("Hello from goroutine")
}()

// 2. å¯åŠ¨å‘½åå‡½æ•°
go myFunction()

// 3. å¯åŠ¨æ–¹æ³•
go obj.method()

// 4. ä¼ é€’å‚æ•°
for i := 0; i < 5; i++ {
    go func(id int) {  // å‚æ•°æŒ‰å€¼ä¼ é€’
        fmt.Println("Worker", id)
    }(i)
}

// âŒ é”™è¯¯ç¤ºä¾‹ï¼šé—­åŒ…é™·é˜±
for i := 0; i < 5; i++ {
    go func() {
        fmt.Println("Worker", i)  // iæ˜¯å…±äº«çš„ï¼
    }()
}
// å¯èƒ½è¾“å‡º: Worker 5 Worker 5 Worker 5 ...
```

### 2.2 Goroutineç”Ÿå‘½å‘¨æœŸ

```text
Goroutineç”Ÿå‘½å‘¨æœŸ
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                          â”‚
â”‚  åˆ›å»º â†’ å¯è¿è¡Œ â†’ è¿è¡Œä¸­ â†’ é€€å‡º            â”‚
â”‚   â†“       â†“        â†“                    â”‚
â”‚  New   Runnable  Running   Dead          â”‚
â”‚                    â†“                     â”‚
â”‚                  é˜»å¡                     â”‚
â”‚                    â†“                     â”‚
â”‚               Waiting                    â”‚
â”‚                    â†“                     â”‚
â”‚              å¯è¿è¡Œ (å”¤é†’)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**çŠ¶æ€è¯¦è§£**:

```go
// 1. åˆ›å»º (New)
go func() {
    // Goroutineè¢«åˆ›å»º
}()

// 2. å¯è¿è¡Œ (Runnable)
// Goroutineåœ¨è¿è¡Œé˜Ÿåˆ—ä¸­ç­‰å¾…è¢«è°ƒåº¦

// 3. è¿è¡Œä¸­ (Running)
// Goroutineæ­£åœ¨CPUä¸Šæ‰§è¡Œ

// 4. é˜»å¡ (Waiting)
ch := make(chan int)
go func() {
    v := <-ch  // é˜»å¡ï¼Œç­‰å¾…æ•°æ®
    fmt.Println(v)
}()

// 5. é€€å‡º (Dead)
go func() {
    fmt.Println("Done")
    return  // Goroutineé€€å‡º
}()
```

### 2.3 Goroutineæ ˆç®¡ç†

**æ ˆçš„åŠ¨æ€å¢é•¿**:

```go
// åˆå§‹æ ˆï¼š2KB
func recursiveFunction(n int) {
    if n == 0 {
        return
    }
    var buf [1024]byte  // åˆ†é…æ ˆç©ºé—´
    recursiveFunction(n - 1)
}

// Goè¿è¡Œæ—¶ä¼šè‡ªåŠ¨æ‰©å±•æ ˆ
// 2KB â†’ 4KB â†’ 8KB â†’ 16KB ...
```

**æ ˆåˆ†è£‚ä¸æ ˆæ”¶ç¼©**:

```text
æ ˆå¢é•¿ç­–ç•¥ï¼ˆGo 1.25.3ï¼‰:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ åˆå§‹å¤§å°: 2KB                   â”‚
â”‚ å¢é•¿: 2xå€å¢                    â”‚
â”‚ ä¸Šé™: 1GB (64ä½ç³»ç»Ÿ)            â”‚
â”‚ æ£€æŸ¥: å‡½æ•°åºè¨€æ£€æŸ¥æ ˆç©ºé—´         â”‚
â”‚ æ”¶ç¼©: GCæ—¶å›æ”¶è¿‡å¤§çš„æ ˆ           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.4 Goroutineæ³„éœ²

**æ³„éœ²åŸå› **:

```go
// 1. Channelæ°¸ä¸å…³é—­
func leak1() {
    ch := make(chan int)
    go func() {
        for v := range ch {  // æ°¸è¿œç­‰å¾…
            process(v)
        }
    }()
    // chä»æœªcloseï¼Œgoroutineæ³„éœ²
}

// 2. Channelæ°¸ä¸æ¥æ”¶
func leak2() {
    ch := make(chan int)
    go func() {
        ch <- 42  // æ°¸è¿œé˜»å¡
    }()
    // æ²¡æœ‰äººæ¥æ”¶ï¼Œgoroutineæ³„éœ²
}

// 3. æ°¸ä¸ç»“æŸçš„å¾ªç¯
func leak3() {
    go func() {
        for {
            // æ²¡æœ‰é€€å‡ºæ¡ä»¶
            doWork()
        }
    }()
}

// 4. WaitGroupæ°¸ä¸å®Œæˆ
func leak4() {
    var wg sync.WaitGroup
    wg.Add(1)
    go func() {
        defer wg.Done()
        <-make(chan struct{})  // æ°¸è¿œé˜»å¡
    }()
    wg.Wait()  // ä¸»goroutineæ°¸è¿œç­‰å¾…
}
```

**æ£€æµ‹ä¸é¢„é˜²**:

```go
// 1. ä½¿ç”¨timeout
func withTimeout() {
    ch := make(chan int)
    go func() {
        ch <- compute()
    }()

    select {
    case result := <-ch:
        fmt.Println("Result:", result)
    case <-time.After(5 * time.Second):
        fmt.Println("Timeout")
        return
    }
}

// 2. ä½¿ç”¨context
func withContext(ctx context.Context) {
    go func() {
        for {
            select {
            case <-ctx.Done():
                fmt.Println("Goroutineé€€å‡º")
                return
            default:
                doWork()
            }
        }
    }()
}

// 3. ä½¿ç”¨done channel
func withDone() {
    done := make(chan struct{})
    go func() {
        defer close(done)
        doWork()
    }()

    <-done  // ç­‰å¾…å®Œæˆ
}

// 4. è¿è¡Œæ—¶æ£€æµ‹
import _ "net/http/pprof"

// è®¿é—® http://localhost:6060/debug/pprof/goroutine
// æŸ¥çœ‹æ‰€æœ‰goroutineçš„çŠ¶æ€
```

---

## 3. Channelæœºåˆ¶è®ºè¯

### 3.1 Channelç±»å‹ä¸è¯­ä¹‰

**Channelå®šä¹‰**:

```go
// åŒå‘channel
var ch chan int = make(chan int)

// åªè¯»channel
var recv <-chan int = ch

// åªå†™channel
var send chan<- int = ch

// æ–¹å‘è½¬æ¢ï¼ˆè‡ªåŠ¨ï¼‰
func producer(ch chan<- int) {  // åªèƒ½å‘é€
    ch <- 42
}

func consumer(ch <-chan int) {  // åªèƒ½æ¥æ”¶
    v := <-ch
}

ch := make(chan int)
go producer(ch)  // chan int â†’ chan<- int (OK)
consumer(ch)     // chan int â†’ <-chan int (OK)
```

### 3.2 æ— ç¼“å†² vs ç¼“å†²Channel

**æ— ç¼“å†²Channelï¼ˆåŒæ­¥ï¼‰**:

```go
ch := make(chan int)  // æ— ç¼“å†²

// å‘é€é˜»å¡ï¼Œç›´åˆ°æœ‰æ¥æ”¶è€…
go func() {
    fmt.Println("å‘é€å‰")
    ch <- 42  // é˜»å¡ï¼Œç›´åˆ°è¢«æ¥æ”¶
    fmt.Println("å‘é€å")
}()

time.Sleep(1 * time.Second)
v := <-ch  // æ¥æ”¶ï¼Œè§£é™¤é˜»å¡
fmt.Println("æ¥æ”¶:", v)

// è¾“å‡º:
// å‘é€å‰
// (1ç§’å)
// å‘é€å
// æ¥æ”¶: 42
```

**ç¼“å†²Channelï¼ˆå¼‚æ­¥ï¼‰**:

```go
ch := make(chan int, 3)  // ç¼“å†²å®¹é‡3

// å‘é€ä¸é˜»å¡ï¼ˆç¼“å†²æœªæ»¡ï¼‰
ch <- 1  // âœ… OK
ch <- 2  // âœ… OK
ch <- 3  // âœ… OK
// ch <- 4  // âŒ é˜»å¡ï¼ç¼“å†²æ»¡

// æ¥æ”¶ä¸é˜»å¡ï¼ˆç¼“å†²éç©ºï¼‰
v1 := <-ch  // âœ… OK (1)
v2 := <-ch  // âœ… OK (2)
v3 := <-ch  // âœ… OK (3)
// v4 := <-ch  // âŒ é˜»å¡ï¼ç¼“å†²ç©º
```

**é€‰æ‹©å»ºè®®**:

```text
æ— ç¼“å†²Channelé€‚ç”¨äº:
âœ… éœ€è¦ä¸¥æ ¼åŒæ­¥
âœ… äº‹ä»¶é€šçŸ¥
âœ… ä¿è¯é€è¾¾

ç¼“å†²Channelé€‚ç”¨äº:
âœ… å‰Šå³°å¡«è°·
âœ… å¼‚æ­¥å¤„ç†
âœ… æé«˜ååé‡

å®¹é‡é€‰æ‹©:
â€¢ cap=1: ä¿¡å·é‡è¯­ä¹‰
â€¢ cap=N: å›ºå®šå¤§å°é˜Ÿåˆ—
â€¢ cap=0: åŒæ­¥ç‚¹
```

### 3.3 Channelæ“ä½œè¯­ä¹‰

**å‘é€ï¼ˆsendï¼‰**:

```go
ch := make(chan int, 1)

// æˆåŠŸå‘é€
ch <- 42  // âœ…

// å‘é€åˆ°nil channelï¼ˆæ°¸ä¹…é˜»å¡ï¼‰
var ch2 chan int
// ch2 <- 42  // âŒ æ°¸ä¹…é˜»å¡

// å‘é€åˆ°å·²å…³é—­channelï¼ˆpanicï¼‰
close(ch)
// ch <- 42  // âŒ panic: send on closed channel
```

**æ¥æ”¶ï¼ˆreceiveï¼‰**:

```go
ch := make(chan int, 1)
ch <- 42

// åŸºæœ¬æ¥æ”¶
v := <-ch  // 42

// æ£€æŸ¥channelæ˜¯å¦å…³é—­
v, ok := <-ch
if ok {
    fmt.Println("æ¥æ”¶:", v)
} else {
    fmt.Println("Channelå·²å…³é—­")
}

// ä»nil channelæ¥æ”¶ï¼ˆæ°¸ä¹…é˜»å¡ï¼‰
var ch2 chan int
// v := <-ch2  // âŒ æ°¸ä¹…é˜»å¡

// ä»å·²å…³é—­channelæ¥æ”¶ï¼ˆè¿”å›é›¶å€¼ï¼‰
close(ch)
v := <-ch  // 0 (é›¶å€¼)
```

**å…³é—­ï¼ˆcloseï¼‰**:

```go
ch := make(chan int, 2)

// å‘é€æ•°æ®
ch <- 1
ch <- 2

// å…³é—­channel
close(ch)

// âœ… å¯ä»¥ç»§ç»­æ¥æ”¶ï¼ˆç¼“å†²æ•°æ®ï¼‰
v1 := <-ch  // 1
v2 := <-ch  // 2
v3 := <-ch  // 0 (channelå·²å…³é—­ï¼Œè¿”å›é›¶å€¼)

// âŒ ä¸èƒ½å†å‘é€
// ch <- 3  // panic: send on closed channel

// âŒ ä¸èƒ½é‡å¤å…³é—­
// close(ch)  // panic: close of closed channel

// âŒ ä¸èƒ½å…³é—­nil channel
var ch2 chan int
// close(ch2)  // panic: close of nil channel
```

### 3.4 Channelå†…éƒ¨å®ç°

**Channelç»“æ„ï¼ˆç®€åŒ–ï¼‰**:

```go
// src/runtime/chan.go
type hchan struct {
    qcount   uint           // é˜Ÿåˆ—ä¸­çš„æ•°æ®ä¸ªæ•°
    dataqsiz uint           // ç¯å½¢é˜Ÿåˆ—å¤§å°
    buf      unsafe.Pointer // ç¯å½¢é˜Ÿåˆ—æŒ‡é’ˆ
    elemsize uint16         // å…ƒç´ å¤§å°
    closed   uint32         // å…³é—­æ ‡å¿—
    elemtype *_type         // å…ƒç´ ç±»å‹
    sendx    uint           // å‘é€ç´¢å¼•
    recvx    uint           // æ¥æ”¶ç´¢å¼•
    recvq    waitq          // æ¥æ”¶ç­‰å¾…é˜Ÿåˆ—
    sendq    waitq          // å‘é€ç­‰å¾…é˜Ÿåˆ—
    lock     mutex          // ä¿æŠ¤æ‰€æœ‰å­—æ®µ
}
```

**å‘é€è¿‡ç¨‹**:

```text
ch <- value çš„æ‰§è¡Œæµç¨‹:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. åŠ é” ch.lock                          â”‚
â”‚ 2. æ£€æŸ¥æ˜¯å¦æœ‰ç­‰å¾…æ¥æ”¶çš„goroutine          â”‚
â”‚    â€¢ æœ‰ â†’ ç›´æ¥ä¼ é€’ç»™æ¥æ”¶è€…                â”‚
â”‚    â€¢ æ—  â†’ ç»§ç»­                            â”‚
â”‚ 3. æ£€æŸ¥ç¼“å†²åŒºæ˜¯å¦æœ‰ç©ºé—´                    â”‚
â”‚    â€¢ æœ‰ â†’ å†™å…¥ç¼“å†²åŒº                      â”‚
â”‚    â€¢ æ—  â†’ ç»§ç»­                            â”‚
â”‚ 4. å°†å½“å‰goroutineåŠ å…¥sendq               â”‚
â”‚ 5. è§£é”å¹¶parkå½“å‰goroutine                â”‚
â”‚ 6. è¢«å”¤é†’åï¼Œè§£é”å¹¶è¿”å›                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ¥æ”¶è¿‡ç¨‹**:

```text
value := <-ch çš„æ‰§è¡Œæµç¨‹:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. åŠ é” ch.lock                          â”‚
â”‚ 2. æ£€æŸ¥æ˜¯å¦æœ‰ç­‰å¾…å‘é€çš„goroutine          â”‚
â”‚    â€¢ æœ‰ â†’ ä»å‘é€è€…æ¥æ”¶                    â”‚
â”‚    â€¢ æ—  â†’ ç»§ç»­                            â”‚
â”‚ 3. æ£€æŸ¥ç¼“å†²åŒºæ˜¯å¦æœ‰æ•°æ®                    â”‚
â”‚    â€¢ æœ‰ â†’ ä»ç¼“å†²åŒºè¯»å–                    â”‚
â”‚    â€¢ æ—  â†’ ç»§ç»­                            â”‚
â”‚ 4. å°†å½“å‰goroutineåŠ å…¥recvq               â”‚
â”‚ 5. è§£é”å¹¶parkå½“å‰goroutine                â”‚
â”‚ 6. è¢«å”¤é†’åï¼Œè§£é”å¹¶è¿”å›                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.5 Channelæ¨¡å¼

**1. å•å‘Channelï¼ˆç±»å‹å®‰å…¨ï¼‰**:

```go
func producer(ch chan<- int) {  // åªèƒ½å‘é€
    for i := 0; i < 10; i++ {
        ch <- i
    }
    close(ch)
}

func consumer(ch <-chan int) {  // åªèƒ½æ¥æ”¶
    for v := range ch {
        fmt.Println(v)
    }
}

ch := make(chan int)
go producer(ch)
consumer(ch)
```

**2. Channelä½œä¸ºä¿¡å·é‡**:

```go
// é™åˆ¶å¹¶å‘æ•°é‡
semaphore := make(chan struct{}, 3)  // æœ€å¤š3ä¸ªå¹¶å‘

for i := 0; i < 100; i++ {
    semaphore <- struct{}{}  // è·å–ä¿¡å·é‡
    go func(id int) {
        defer func() { <-semaphore }()  // é‡Šæ”¾ä¿¡å·é‡
        doWork(id)
    }(i)
}
```

**3. Channelä½œä¸ºé€šçŸ¥**:

```go
// é€šçŸ¥goroutineé€€å‡º
done := make(chan struct{})

go func() {
    for {
        select {
        case <-done:
            fmt.Println("é€€å‡º")
            return
        default:
            doWork()
        }
    }
}()

// é€šçŸ¥é€€å‡º
close(done)
```

**4. Channelè¶…æ—¶**:

```go
func withTimeout(ch <-chan int) (int, error) {
    select {
    case v := <-ch:
        return v, nil
    case <-time.After(5 * time.Second):
        return 0, errors.New("timeout")
    }
}
```

---

## 4. åŒæ­¥åŸè¯­åˆ†æ

### 4.1 Mutexï¼ˆäº’æ–¥é”ï¼‰

**åŸºæœ¬ç”¨æ³•**:

```go
var (
    counter int
    mu      sync.Mutex
)

func increment() {
    mu.Lock()
    counter++
    mu.Unlock()
}

// ä½¿ç”¨deferç¡®ä¿è§£é”
func safeIncrement() {
    mu.Lock()
    defer mu.Unlock()

    counter++
    // å¤æ‚é€»è¾‘
}
```

**Mutexå®ç°åŸç†**:

```text
MutexçŠ¶æ€æœºï¼ˆGo 1.25.3ï¼‰:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ çŠ¶æ€å­—æ®µï¼ˆ32ä½ï¼‰:                     â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚Lockedâ”‚Woken â”‚Starv â”‚WaiterNum â”‚   â”‚
â”‚ â”‚ (1)  â”‚ (1)  â”‚ (1)  â”‚  (29)    â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                      â”‚
â”‚ æ¨¡å¼:                                â”‚
â”‚ â€¢ æ­£å¸¸æ¨¡å¼: è‡ªæ—‹å°è¯•è·å–              â”‚
â”‚ â€¢ é¥¥é¥¿æ¨¡å¼: ç›´æ¥äº¤ç»™ç­‰å¾…è€…            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ€§èƒ½è€ƒè™‘**:

```go
// âŒ é”ç²’åº¦å¤ªå¤§
func badExample() {
    mu.Lock()
    defer mu.Unlock()

    data := loadData()    // IOæ“ä½œ
    result := process(data)  // è®¡ç®—å¯†é›†
    saveResult(result)    // IOæ“ä½œ
}

// âœ… ç¼©å°é”ç²’åº¦
func goodExample() {
    data := loadData()    // IOæ“ä½œï¼Œæ— éœ€é”

    mu.Lock()
    result := process(data)  // åªé”ä½å¿…è¦éƒ¨åˆ†
    mu.Unlock()

    saveResult(result)    // IOæ“ä½œï¼Œæ— éœ€é”
}
```

### 4.2 RWMutexï¼ˆè¯»å†™é”ï¼‰

**åŸºæœ¬ç”¨æ³•**:

```go
var (
    data   map[string]int
    rwmu   sync.RWMutex
)

// è¯»æ“ä½œï¼ˆå¯å¹¶å‘ï¼‰
func read(key string) int {
    rwmu.RLock()
    defer rwmu.RUnlock()
    return data[key]
}

// å†™æ“ä½œï¼ˆäº’æ–¥ï¼‰
func write(key string, value int) {
    rwmu.Lock()
    defer rwmu.Unlock()
    data[key] = value
}
```

**é€‰æ‹©å»ºè®®**:

```text
ä½¿ç”¨RWMutexçš„åœºæ™¯:
âœ… è¯»å¤šå†™å°‘ï¼ˆè¯»:å†™ > 10:1ï¼‰
âœ… ä¸´ç•ŒåŒºè¾ƒå¤§
âœ… è¯»æ“ä½œè€—æ—¶

ä½¿ç”¨Mutexçš„åœºæ™¯:
âœ… è¯»å†™æ¯”ä¾‹æ¥è¿‘
âœ… ä¸´ç•ŒåŒºè¾ƒå°
âœ… å†™æ“ä½œé¢‘ç¹

åŸå› : RWMutexæœ‰é¢å¤–å¼€é”€
```

### 4.3 WaitGroup

**åŸºæœ¬ç”¨æ³•**:

```go
var wg sync.WaitGroup

// å¯åŠ¨å¤šä¸ªgoroutine
for i := 0; i < 10; i++ {
    wg.Add(1)
    go func(id int) {
        defer wg.Done()
        doWork(id)
    }(i)
}

// ç­‰å¾…æ‰€æœ‰å®Œæˆ
wg.Wait()
fmt.Println("æ‰€æœ‰ä»»åŠ¡å®Œæˆ")
```

**å¸¸è§é”™è¯¯**:

```go
// âŒ é”™è¯¯ï¼šåœ¨goroutineå†…Add
for i := 0; i < 10; i++ {
    go func(id int) {
        wg.Add(1)  // âŒ å¯èƒ½åœ¨Waitä¹‹åæ‰§è¡Œ
        defer wg.Done()
        doWork(id)
    }(i)
}
wg.Wait()

// âœ… æ­£ç¡®ï¼šåœ¨å¯åŠ¨å‰Add
for i := 0; i < 10; i++ {
    wg.Add(1)  // âœ… åœ¨goroutineå¤–Add
    go func(id int) {
        defer wg.Done()
        doWork(id)
    }(i)
}
wg.Wait()

// âŒ é”™è¯¯ï¼šDoneæ¬¡æ•°ä¸åŒ¹é…
wg.Add(1)
go func() {
    defer wg.Done()
    defer wg.Done()  // âŒ Doneä¸¤æ¬¡ï¼Œpanic!
}()
```

### 4.4 Once

**åŸºæœ¬ç”¨æ³•**:

```go
var (
    instance *Singleton
    once     sync.Once
)

func GetInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{}  // åªæ‰§è¡Œä¸€æ¬¡
    })
    return instance
}

// å¤šæ¬¡è°ƒç”¨ï¼Œåªåˆå§‹åŒ–ä¸€æ¬¡
s1 := GetInstance()
s2 := GetInstance()
// s1 == s2
```

**ä½¿ç”¨åœºæ™¯**:

```go
// 1. å•ä¾‹æ¨¡å¼
var (
    db   *Database
    once sync.Once
)

func GetDB() *Database {
    once.Do(func() {
        db = openDatabase()
    })
    return db
}

// 2. å»¶è¿Ÿåˆå§‹åŒ–
var (
    config *Config
    once   sync.Once
)

func GetConfig() *Config {
    once.Do(func() {
        config = loadConfig()
    })
    return config
}

// 3. ä¸€æ¬¡æ€§è®¾ç½®
var (
    initialized bool
    once        sync.Once
)

func Initialize() {
    once.Do(func() {
        setupResources()
        initialized = true
    })
}
```

### 4.5 Condï¼ˆæ¡ä»¶å˜é‡ï¼‰

**åŸºæœ¬ç”¨æ³•**:

```go
var (
    queue []int
    mu    sync.Mutex
    cond  = sync.NewCond(&mu)
)

// ç”Ÿäº§è€…
func producer() {
    for i := 0; i < 10; i++ {
        mu.Lock()
        queue = append(queue, i)
        cond.Signal()  // é€šçŸ¥ä¸€ä¸ªç­‰å¾…è€…
        mu.Unlock()
    }
}

// æ¶ˆè´¹è€…
func consumer() {
    mu.Lock()
    defer mu.Unlock()

    for len(queue) == 0 {
        cond.Wait()  // ç­‰å¾…é€šçŸ¥
    }

    item := queue[0]
    queue = queue[1:]
    fmt.Println("æ¶ˆè´¹:", item)
}
```

### 4.6 atomicåŒ…

**åŸå­æ“ä½œ**:

```go
import "sync/atomic"

var counter int64

// åŸå­é€’å¢
atomic.AddInt64(&counter, 1)

// åŸå­åŠ è½½
value := atomic.LoadInt64(&counter)

// åŸå­å­˜å‚¨
atomic.StoreInt64(&counter, 100)

// åŸå­äº¤æ¢
old := atomic.SwapInt64(&counter, 200)

// CASï¼ˆCompare-And-Swapï¼‰
success := atomic.CompareAndSwapInt64(&counter, 200, 300)
```

**æ€§èƒ½å¯¹æ¯”**:

```go
// Mutexç‰ˆæœ¬
var (
    counter int
    mu      sync.Mutex
)

func incrementMutex() {
    mu.Lock()
    counter++
    mu.Unlock()
}

// Atomicç‰ˆæœ¬
var counter int64

func incrementAtomic() {
    atomic.AddInt64(&counter, 1)
}

// Atomicé€šå¸¸å¿«5-10å€
```

---

## 5. GMPè°ƒåº¦æ¨¡å‹

### 5.1 GMPæ¨¡å‹æ¦‚è¿°

**ä¸‰å…ƒç»„**:

```text
G (Goroutine)
â”œâ”€â”€ ç”¨æˆ·çº§è½»é‡çº¿ç¨‹
â”œâ”€â”€ åŒ…å«æ ˆã€ä¸Šä¸‹æ–‡ç­‰
â””â”€â”€ æ•°é‡: ç™¾ä¸‡çº§

M (Machine)
â”œâ”€â”€ æ“ä½œç³»ç»Ÿçº¿ç¨‹
â”œâ”€â”€ æ‰§è¡ŒGçš„è½½ä½“
â””â”€â”€ æ•°é‡: GOMAXPROCS

P (Processor)
â”œâ”€â”€ é€»è¾‘å¤„ç†å™¨
â”œâ”€â”€ æŒæœ‰Gçš„è¿è¡Œé˜Ÿåˆ—
â””â”€â”€ æ•°é‡: GOMAXPROCS
```

**å…³ç³»å›¾**:

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        å…¨å±€Gé˜Ÿåˆ—                         â”‚
â”‚    [G] [G] [G] [G] [G] ...              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â†“ â†‘
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   P1     â”‚   P2     â”‚   P3     â”‚
â”‚  [G][G]  â”‚  [G][G]  â”‚  [G][G]  â”‚ (æœ¬åœ°Gé˜Ÿåˆ—)
â”‚    â†“     â”‚    â†“     â”‚    â†“     â”‚
â”‚   M1     â”‚   M2     â”‚   M3     â”‚ (æ“ä½œç³»ç»Ÿçº¿ç¨‹)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 è°ƒåº¦ç­–ç•¥

**1. Work Stealingï¼ˆå·¥ä½œçªƒå–ï¼‰**:

```text
P1çš„é˜Ÿåˆ—: [G1] [G2] [G3]
P2çš„é˜Ÿåˆ—: [G4]
P3çš„é˜Ÿåˆ—: [] â† ç©ºé—²

P3ä»P1å·å–: [G3]
P3çš„é˜Ÿåˆ—: [G3]
P1çš„é˜Ÿåˆ—: [G1] [G2]
```

**2. Hand Offï¼ˆç§»äº¤ï¼‰**:

```text
å½“M1æ‰§è¡Œçš„Gå‘ç”Ÿç³»ç»Ÿè°ƒç”¨é˜»å¡:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ M1 é˜»å¡åœ¨ç³»ç»Ÿè°ƒç”¨            â”‚
â”‚ P1 è¢«ç§»äº¤ç»™ç©ºé—²çš„M2          â”‚
â”‚ P1ç»§ç»­è°ƒåº¦å…¶ä»–G              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**3. æŠ¢å å¼è°ƒåº¦ï¼ˆGo 1.14+ï¼‰**:

```go
// Go 1.14ä¹‹å‰ï¼šåä½œå¼æŠ¢å 
// åªåœ¨å‡½æ•°è°ƒç”¨æ—¶æ£€æŸ¥

// Go 1.14+ï¼šåŸºäºä¿¡å·çš„æŠ¢å 
// å¯ä»¥ä¸­æ–­ä»»ä½•æ‰§è¡Œä¸­çš„goroutine

func infiniteLoop() {
    for {
        // åœ¨Go 1.14+ä¸­ï¼Œå³ä½¿æ²¡æœ‰å‡½æ•°è°ƒç”¨
        // ä¹Ÿä¼šè¢«æŠ¢å 
    }
}
```

### 5.3 GOMAXPROCS

**è®¾ç½®ä¸å½±å“**:

```go
import "runtime"

// è·å–å½“å‰å€¼
n := runtime.GOMAXPROCS(0)

// è®¾ç½®ä¸ºCPUæ ¸å¿ƒæ•°
runtime.GOMAXPROCS(runtime.NumCPU())

// è®¾ç½®ä¸ºå›ºå®šå€¼
runtime.GOMAXPROCS(4)

// ç¯å¢ƒå˜é‡è®¾ç½®
// export GOMAXPROCS=8
```

**é€‰æ‹©å»ºè®®**:

```text
CPUå¯†é›†å‹:
â””â”€â”€ GOMAXPROCS = NumCPU()

IOå¯†é›†å‹:
â””â”€â”€ GOMAXPROCS > NumCPU()

æ··åˆå‹:
â””â”€â”€ æµ‹è¯•è°ƒä¼˜
```

---

## 6. å†…å­˜æ¨¡å‹ä¸åŒæ­¥

### 6.1 Happens-Beforeå…³ç³»

**å®šä¹‰**:

- å¦‚æœäº‹ä»¶A happens-before äº‹ä»¶B
- é‚£ä¹ˆAçš„æ•ˆæœå¯¹Bå¯è§

**è§„åˆ™**:

```go
// 1. å•goroutineå†…ï¼ŒæŒ‰ç¨‹åºé¡ºåº
a := 1    // happens-before
b := 2    // happens-before
c := a + b

// 2. Channelå‘é€ happens-before å¯¹åº”æ¥æ”¶
go func() {
    m = 1
    ch <- 1  // å‘é€
}()
<-ch  // æ¥æ”¶ï¼ˆm=1å¯è§ï¼‰

// 3. Close happens-before é›¶å€¼æ¥æ”¶
go func() {
    m = 1
    close(ch)
}()
<-ch  // m=1å¯è§

// 4. æ— ç¼“å†²channelæ¥æ”¶ happens-before å‘é€å®Œæˆ
ch := make(chan int)
go func() {
    ch <- 1  // é˜»å¡
    m = 1    // åœ¨æ¥æ”¶åæ‰§è¡Œ
}()
<-ch  // æ¥æ”¶
// m=1å¯èƒ½è¿˜æœªæ‰§è¡Œ

// 5. Mutex: Unlock happens-before Lock
mu.Lock()
m = 1
mu.Unlock()  // happens-before ä¸‹ä¸€ä¸ªLock

mu.Lock()  // m=1å¯è§
```

### 6.2 æ•°æ®ç«äº‰

**å®šä¹‰**:
ä¸¤ä¸ªgoroutineå¹¶å‘è®¿é—®åŒä¸€å˜é‡ï¼Œè‡³å°‘ä¸€ä¸ªæ˜¯å†™æ“ä½œï¼Œä¸”æ²¡æœ‰åŒæ­¥

```go
// âŒ æ•°æ®ç«äº‰
var counter int

go func() {
    counter++  // å†™
}()

fmt.Println(counter)  // è¯»ï¼ˆç«äº‰ï¼ï¼‰

// âœ… ä½¿ç”¨é”
var (
    counter int
    mu      sync.Mutex
)

go func() {
    mu.Lock()
    counter++
    mu.Unlock()
}()

mu.Lock()
fmt.Println(counter)
mu.Unlock()

// âœ… ä½¿ç”¨channel
ch := make(chan int, 1)
ch <- 0

go func() {
    v := <-ch
    ch <- v + 1
}()

v := <-ch
fmt.Println(v)
```

**æ£€æµ‹å·¥å…·**:

```bash
# ä½¿ç”¨-raceæ ‡å¿—
go run -race main.go
go test -race ./...
go build -race

# ç¤ºä¾‹è¾“å‡º
WARNING: DATA RACE
Write at 0x00c000014098 by goroutine 6:
  main.increment()
      /path/to/file.go:10 +0x38

Previous read at 0x00c000014098 by main goroutine:
  main.main()
      /path/to/file.go:20 +0x88
```

---

## 7. å¹¶å‘æ¨¡å¼å®è·µ

### 7.1 Worker Pool

```go
func workerPool(tasks <-chan Task, results chan<- Result) {
    const numWorkers = 10
    var wg sync.WaitGroup

    // å¯åŠ¨workers
    for i := 0; i < numWorkers; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for task := range tasks {
                result := process(task)
                results <- result
            }
        }(i)
    }

    // ç­‰å¾…å®Œæˆå¹¶å…³é—­ç»“æœchannel
    go func() {
        wg.Wait()
        close(results)
    }()
}
```

### 7.2 Pipeline

```go
func pipeline() {
    // é˜¶æ®µ1: ç”Ÿæˆæ•°æ®
    gen := func(nums ...int) <-chan int {
        out := make(chan int)
        go func() {
            defer close(out)
            for _, n := range nums {
                out <- n
            }
        }()
        return out
    }

    // é˜¶æ®µ2: å¹³æ–¹
    square := func(in <-chan int) <-chan int {
        out := make(chan int)
        go func() {
            defer close(out)
            for n := range in {
                out <- n * n
            }
        }()
        return out
    }

    // é˜¶æ®µ3: è¿‡æ»¤å¶æ•°
    filterEven := func(in <-chan int) <-chan int {
        out := make(chan int)
        go func() {
            defer close(out)
            for n := range in {
                if n%2 == 0 {
                    out <- n
                }
            }
        }()
        return out
    }

    // ç»„è£…pipeline
    nums := gen(1, 2, 3, 4, 5)
    squares := square(nums)
    evens := filterEven(squares)

    for v := range evens {
        fmt.Println(v)  // 4, 16
    }
}
```

### 7.3 Fan-Out/Fan-In

```go
func fanOutFanIn() {
    input := make(chan int, 100)

    // Fan-Out: å¯åŠ¨å¤šä¸ªworker
    const numWorkers = 5
    workers := make([]<-chan int, numWorkers)
    for i := 0; i < numWorkers; i++ {
        workers[i] = worker(input)
    }

    // Fan-In: åˆå¹¶ç»“æœ
    output := merge(workers...)

    // ä½¿ç”¨
    go func() {
        for i := 0; i < 100; i++ {
            input <- i
        }
        close(input)
    }()

    for result := range output {
        fmt.Println(result)
    }
}

func worker(input <-chan int) <-chan int {
    output := make(chan int)
    go func() {
        defer close(output)
        for v := range input {
            output <- process(v)
        }
    }()
    return output
}

func merge(channels ...<-chan int) <-chan int {
    var wg sync.WaitGroup
    output := make(chan int)

    wg.Add(len(channels))
    for _, ch := range channels {
        go func(c <-chan int) {
            defer wg.Done()
            for v := range c {
                output <- v
            }
        }(ch)
    }

    go func() {
        wg.Wait()
        close(output)
    }()

    return output
}
```

### 7.4 Contextä¼ æ’­

```go
func withContext() {
    ctx, cancel := context.WithTimeout(
        context.Background(),
        5*time.Second,
    )
    defer cancel()

    result, err := doWorkWithContext(ctx)
    if err != nil {
        if errors.Is(err, context.DeadlineExceeded) {
            fmt.Println("è¶…æ—¶")
        } else if errors.Is(err, context.Canceled) {
            fmt.Println("å–æ¶ˆ")
        }
    }
}

func doWorkWithContext(ctx context.Context) (Result, error) {
    // ä¼ é€’contextç»™å­ä»»åŠ¡
    go subTask(ctx)

    select {
    case <-ctx.Done():
        return Result{}, ctx.Err()
    case result := <-computeResult():
        return result, nil
    }
}

func subTask(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            fmt.Println("å­ä»»åŠ¡é€€å‡º")
            return
        default:
            // æ‰§è¡Œå·¥ä½œ
        }
    }
}
```

---

## 8. å¹¶å‘æ€§èƒ½ä¼˜åŒ–

### 8.1 å‡å°‘é”ç«äº‰

```go
// âŒ é«˜ç«äº‰
var (
    globalCounter int
    mu            sync.Mutex
)

func increment() {
    mu.Lock()
    globalCounter++
    mu.Unlock()
}

// âœ… åˆ†ç‰‡é”
type ShardedCounter struct {
    shards [16]struct {
        mu    sync.Mutex
        count int
    }
}

func (sc *ShardedCounter) Increment() {
    shard := &sc.shards[hash()%16]
    shard.mu.Lock()
    shard.count++
    shard.mu.Unlock()
}

func (sc *ShardedCounter) Total() int {
    total := 0
    for i := range sc.shards {
        sc.shards[i].mu.Lock()
        total += sc.shards[i].count
        sc.shards[i].mu.Unlock()
    }
    return total
}
```

### 8.2 é¿å…goroutineæ³„éœ²

```go
// âœ… ä½¿ç”¨contextæ§åˆ¶ç”Ÿå‘½å‘¨æœŸ
func startWorkers(ctx context.Context, n int) {
    for i := 0; i < n; i++ {
        go func(id int) {
            for {
                select {
                case <-ctx.Done():
                    return  // é€€å‡º
                default:
                    doWork(id)
                }
            }
        }(i)
    }
}

// ä½¿ç”¨
ctx, cancel := context.WithCancel(context.Background())
startWorkers(ctx, 100)

// åœæ­¢æ‰€æœ‰workers
cancel()
```

### 8.3 åˆç†ä½¿ç”¨ç¼“å†²

```go
// âŒ æ— ç¼“å†²ï¼ˆåŒæ­¥å¼€é”€å¤§ï¼‰
ch := make(chan int)

// âœ… é€‚å½“ç¼“å†²
ch := make(chan int, 100)

// é€‰æ‹©ç¼“å†²å¤§å°
// â€¢ ç”Ÿäº§è€…æ•°é‡
// â€¢ æ¶ˆè´¹è€…æ•°é‡
// â€¢ å¤„ç†å»¶è¿Ÿ
```

---

## 9. å½¢å¼åŒ–è¯æ˜

### 9.1 å¹¶å‘æ­£ç¡®æ€§

```text
å¹¶å‘ç¨‹åºæ€§è´¨:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å®‰å…¨æ€§ï¼ˆSafetyï¼‰:                    â”‚
â”‚ â€¢ åäº‹ä¸ä¼šå‘ç”Ÿ                       â”‚
â”‚ â€¢ ä¾‹: æ— æ•°æ®ç«äº‰                     â”‚
â”‚                                      â”‚
â”‚ æ´»æ€§ï¼ˆLivenessï¼‰:                    â”‚
â”‚ â€¢ å¥½äº‹æœ€ç»ˆä¼šå‘ç”Ÿ                     â”‚
â”‚ â€¢ ä¾‹: æ— æ­»é”ï¼Œæœ€ç»ˆå®Œæˆ                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å½¢å¼åŒ–:
Safety: â–¡Â¬Bad (æ°¸è¿œä¸å‘ç”Ÿåäº‹)
Liveness: â—ŠGood (æœ€ç»ˆå‘ç”Ÿå¥½äº‹)
```

---

## 10. æœ€ä½³å®è·µ

### 10.1 å¹¶å‘è®¾è®¡åŸåˆ™

```text
1. ä¼˜å…ˆä½¿ç”¨Channel
2. æœ€å°åŒ–é”çš„ä½œç”¨åŸŸ
3. é¿å…goroutineæ³„éœ²
4. ä½¿ç”¨Contextæ§åˆ¶ç”Ÿå‘½å‘¨æœŸ
5. é€‚å½“ä½¿ç”¨sync.Once
6. æ³¨æ„æ•°æ®ç«äº‰
7. æ€§èƒ½æµ‹è¯•å’Œraceæ£€æµ‹
```

---

## ğŸ“š æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **Goroutine**: è½»é‡çº§ã€åŠ¨æ€æ ˆã€GMPè°ƒåº¦
2. **Channel**: ç±»å‹å®‰å…¨ã€åŒæ­¥é€šä¿¡ã€CSPæ¨¡å‹
3. **åŒæ­¥åŸè¯­**: Mutexã€RWMutexã€WaitGroupã€Once
4. **GMPæ¨¡å‹**: é«˜æ•ˆè°ƒåº¦ã€å·¥ä½œçªƒå–ã€æŠ¢å å¼
5. **å¹¶å‘æ¨¡å¼**: Worker Poolã€Pipelineã€Fan-Out/Fan-In

---

- [ç±»å‹ç³»ç»Ÿå®Œæ•´è§£æ](./01-Go-1.25.3ç±»å‹ç³»ç»Ÿå®Œæ•´è§£æ.md)
- [æ§åˆ¶æµæœºåˆ¶æ·±åº¦åˆ†æ](./02-Go-1.25.3æ§åˆ¶æµæœºåˆ¶æ·±åº¦åˆ†æ.md)
- [CSPæ¨¡å‹ä¸‰ç»´åˆ†æ](./04-CSPæ¨¡å‹ä¸‰ç»´å®Œæ•´åˆ†æ-2025.md)

---

**æ›´æ–°æ—¥æœŸ**: 2025-10-29
