# Go 1.25.3 并发机制完整论证

**版本**: v1.0
**更新日期**: 2025-10-29
**适用于**: Go 1.25.3

---

## 📋 目录

- [Go 1.25.3 并发机制完整论证](#go-1253-并发机制完整论证)
  - [📋 目录](#-目录)
  - [1. 并发概述](#1-并发概述)
    - [1.1 并发 vs 并行](#11-并发-vs-并行)
    - [1.2 Go并发哲学](#12-go并发哲学)
    - [1.3 并发原语总览](#13-并发原语总览)
  - [2. Goroutine深度解析](#2-goroutine深度解析)
    - [2.1 Goroutine基础](#21-goroutine基础)
    - [2.2 Goroutine生命周期](#22-goroutine生命周期)
    - [2.3 Goroutine栈管理](#23-goroutine栈管理)
    - [2.4 Goroutine泄露](#24-goroutine泄露)
  - [3. Channel机制论证](#3-channel机制论证)
    - [3.1 Channel类型与语义](#31-channel类型与语义)
    - [3.2 无缓冲 vs 缓冲Channel](#32-无缓冲-vs-缓冲channel)
    - [3.3 Channel操作语义](#33-channel操作语义)
    - [3.4 Channel内部实现](#34-channel内部实现)
    - [3.5 Channel模式](#35-channel模式)
  - [4. 同步原语分析](#4-同步原语分析)
    - [4.1 Mutex（互斥锁）](#41-mutex互斥锁)
    - [4.2 RWMutex（读写锁）](#42-rwmutex读写锁)
    - [4.3 WaitGroup](#43-waitgroup)
    - [4.4 Once](#44-once)
    - [4.5 Cond（条件变量）](#45-cond条件变量)
    - [4.6 atomic包](#46-atomic包)
  - [5. GMP调度模型](#5-gmp调度模型)
    - [5.1 GMP模型概述](#51-gmp模型概述)
    - [5.2 调度策略](#52-调度策略)
    - [5.3 GOMAXPROCS](#53-gomaxprocs)
  - [6. 内存模型与同步](#6-内存模型与同步)
    - [6.1 Happens-Before关系](#61-happens-before关系)
    - [6.2 数据竞争](#62-数据竞争)
  - [7. 并发模式实践](#7-并发模式实践)
    - [7.1 Worker Pool](#71-worker-pool)
    - [7.2 Pipeline](#72-pipeline)
    - [7.3 Fan-Out/Fan-In](#73-fan-outfan-in)
    - [7.4 Context传播](#74-context传播)
  - [8. 并发性能优化](#8-并发性能优化)
    - [8.1 减少锁竞争](#81-减少锁竞争)
    - [8.2 避免goroutine泄露](#82-避免goroutine泄露)
    - [8.3 合理使用缓冲](#83-合理使用缓冲)
  - [9. 形式化证明](#9-形式化证明)
    - [9.1 并发正确性](#91-并发正确性)
  - [10. 最佳实践](#10-最佳实践)
    - [10.1 并发设计原则](#101-并发设计原则)
  - [📚 总结](#-总结)
    - [核心要点](#核心要点)

## 1. 并发概述

### 1.1 并发 vs 并行

**概念定义**:

```text
并发 (Concurrency)
├── 定义: 程序结构，处理多个任务的能力
├── 关键: 任务可以交替执行
└── 目标: 提高程序响应性和资源利用率

并行 (Parallelism)
├── 定义: 程序执行，同时执行多个任务
├── 关键: 任务真正同时执行
└── 目标: 提高程序执行速度

关系: 并发是并行的必要条件
```

**图示**:

```text
并发（单核）:
时间 →
CPU: [Task1][Task2][Task1][Task3][Task2][Task1]

并行（多核）:
时间 →
CPU1: [Task1][Task1][Task1][Task1]
CPU2: [Task2][Task2][Task2][Task2]
CPU3: [Task3][Task3][Task3][Task3]
```

**Go的并发模型**:

```go
// 并发 - 结构化程序
func concurrentExample() {
    go task1()  // Goroutine 1
    go task2()  // Goroutine 2
    go task3()  // Goroutine 3
    // 三个任务可以交替执行（并发）
    // 如果有多个CPU核心，可以同时执行（并行）
}

// 对比：顺序执行
func sequentialExample() {
    task1()
    task2()
    task3()
    // 必须按顺序完成
}
```

### 1.2 Go并发哲学

**"不要通过共享内存来通信，而应通过通信来共享内存"**-

```go
// ❌ 传统方式：共享内存
var counter int
var mu sync.Mutex

func increment() {
    mu.Lock()
    counter++
    mu.Unlock()
}

// ✅ Go方式：通信
func increment(ch chan int) {
    ch <- 1  // 通过channel通信
}

// 收集结果
total := 0
for i := 0; i < n; i++ {
    total += <-ch
}
```

### 1.3 并发原语总览

```text
Go并发原语
├── Goroutine
│   ├── 创建: go f()
│   ├── 调度: GMP模型
│   └── 生命周期: 创建→运行→退出
│
├── Channel
│   ├── 无缓冲: make(chan T)
│   ├── 缓冲: make(chan T, cap)
│   ├── 操作: send, receive, close
│   └── 方向: chan T, <-chan T, chan<- T
│
├── Select
│   ├── 多路复用
│   ├── 随机选择
│   └── default分支
│
└── Sync包
    ├── Mutex/RWMutex
    ├── WaitGroup
    ├── Once
    ├── Cond
    ├── Pool
    └── Map
```

---

## 2. Goroutine深度解析

### 2.1 Goroutine基础

**定义**:

- Goroutine是Go运行时管理的轻量级线程
- 由Go运行时调度，而非操作系统
- 栈空间初始仅2KB，可动态增长

**创建Goroutine**:

```go
// 1. 启动匿名函数
go func() {
    fmt.Println("Hello from goroutine")
}()

// 2. 启动命名函数
go myFunction()

// 3. 启动方法
go obj.method()

// 4. 传递参数
for i := 0; i < 5; i++ {
    go func(id int) {  // 参数按值传递
        fmt.Println("Worker", id)
    }(i)
}

// ❌ 错误示例：闭包陷阱
for i := 0; i < 5; i++ {
    go func() {
        fmt.Println("Worker", i)  // i是共享的！
    }()
}
// 可能输出: Worker 5 Worker 5 Worker 5 ...
```

### 2.2 Goroutine生命周期

```text
Goroutine生命周期
┌──────────────────────────────────────────┐
│                                          │
│  创建 → 可运行 → 运行中 → 退出            │
│   ↓       ↓        ↓                    │
│  New   Runnable  Running   Dead          │
│                    ↓                     │
│                  阻塞                     │
│                    ↓                     │
│               Waiting                    │
│                    ↓                     │
│              可运行 (唤醒)                 │
└──────────────────────────────────────────┘
```

**状态详解**:

```go
// 1. 创建 (New)
go func() {
    // Goroutine被创建
}()

// 2. 可运行 (Runnable)
// Goroutine在运行队列中等待被调度

// 3. 运行中 (Running)
// Goroutine正在CPU上执行

// 4. 阻塞 (Waiting)
ch := make(chan int)
go func() {
    v := <-ch  // 阻塞，等待数据
    fmt.Println(v)
}()

// 5. 退出 (Dead)
go func() {
    fmt.Println("Done")
    return  // Goroutine退出
}()
```

### 2.3 Goroutine栈管理

**栈的动态增长**:

```go
// 初始栈：2KB
func recursiveFunction(n int) {
    if n == 0 {
        return
    }
    var buf [1024]byte  // 分配栈空间
    recursiveFunction(n - 1)
}

// Go运行时会自动扩展栈
// 2KB → 4KB → 8KB → 16KB ...
```

**栈分裂与栈收缩**:

```text
栈增长策略（Go 1.25.3）:
┌────────────────────────────────┐
│ 初始大小: 2KB                   │
│ 增长: 2x倍增                    │
│ 上限: 1GB (64位系统)            │
│ 检查: 函数序言检查栈空间         │
│ 收缩: GC时回收过大的栈           │
└────────────────────────────────┘
```

### 2.4 Goroutine泄露

**泄露原因**:

```go
// 1. Channel永不关闭
func leak1() {
    ch := make(chan int)
    go func() {
        for v := range ch {  // 永远等待
            process(v)
        }
    }()
    // ch从未close，goroutine泄露
}

// 2. Channel永不接收
func leak2() {
    ch := make(chan int)
    go func() {
        ch <- 42  // 永远阻塞
    }()
    // 没有人接收，goroutine泄露
}

// 3. 永不结束的循环
func leak3() {
    go func() {
        for {
            // 没有退出条件
            doWork()
        }
    }()
}

// 4. WaitGroup永不完成
func leak4() {
    var wg sync.WaitGroup
    wg.Add(1)
    go func() {
        defer wg.Done()
        <-make(chan struct{})  // 永远阻塞
    }()
    wg.Wait()  // 主goroutine永远等待
}
```

**检测与预防**:

```go
// 1. 使用timeout
func withTimeout() {
    ch := make(chan int)
    go func() {
        ch <- compute()
    }()

    select {
    case result := <-ch:
        fmt.Println("Result:", result)
    case <-time.After(5 * time.Second):
        fmt.Println("Timeout")
        return
    }
}

// 2. 使用context
func withContext(ctx context.Context) {
    go func() {
        for {
            select {
            case <-ctx.Done():
                fmt.Println("Goroutine退出")
                return
            default:
                doWork()
            }
        }
    }()
}

// 3. 使用done channel
func withDone() {
    done := make(chan struct{})
    go func() {
        defer close(done)
        doWork()
    }()

    <-done  // 等待完成
}

// 4. 运行时检测
import _ "net/http/pprof"

// 访问 http://localhost:6060/debug/pprof/goroutine
// 查看所有goroutine的状态
```

---

## 3. Channel机制论证

### 3.1 Channel类型与语义

**Channel定义**:

```go
// 双向channel
var ch chan int = make(chan int)

// 只读channel
var recv <-chan int = ch

// 只写channel
var send chan<- int = ch

// 方向转换（自动）
func producer(ch chan<- int) {  // 只能发送
    ch <- 42
}

func consumer(ch <-chan int) {  // 只能接收
    v := <-ch
}

ch := make(chan int)
go producer(ch)  // chan int → chan<- int (OK)
consumer(ch)     // chan int → <-chan int (OK)
```

### 3.2 无缓冲 vs 缓冲Channel

**无缓冲Channel（同步）**:

```go
ch := make(chan int)  // 无缓冲

// 发送阻塞，直到有接收者
go func() {
    fmt.Println("发送前")
    ch <- 42  // 阻塞，直到被接收
    fmt.Println("发送后")
}()

time.Sleep(1 * time.Second)
v := <-ch  // 接收，解除阻塞
fmt.Println("接收:", v)

// 输出:
// 发送前
// (1秒后)
// 发送后
// 接收: 42
```

**缓冲Channel（异步）**:

```go
ch := make(chan int, 3)  // 缓冲容量3

// 发送不阻塞（缓冲未满）
ch <- 1  // ✅ OK
ch <- 2  // ✅ OK
ch <- 3  // ✅ OK
// ch <- 4  // ❌ 阻塞！缓冲满

// 接收不阻塞（缓冲非空）
v1 := <-ch  // ✅ OK (1)
v2 := <-ch  // ✅ OK (2)
v3 := <-ch  // ✅ OK (3)
// v4 := <-ch  // ❌ 阻塞！缓冲空
```

**选择建议**:

```text
无缓冲Channel适用于:
✅ 需要严格同步
✅ 事件通知
✅ 保证送达

缓冲Channel适用于:
✅ 削峰填谷
✅ 异步处理
✅ 提高吞吐量

容量选择:
• cap=1: 信号量语义
• cap=N: 固定大小队列
• cap=0: 同步点
```

### 3.3 Channel操作语义

**发送（send）**:

```go
ch := make(chan int, 1)

// 成功发送
ch <- 42  // ✅

// 发送到nil channel（永久阻塞）
var ch2 chan int
// ch2 <- 42  // ❌ 永久阻塞

// 发送到已关闭channel（panic）
close(ch)
// ch <- 42  // ❌ panic: send on closed channel
```

**接收（receive）**:

```go
ch := make(chan int, 1)
ch <- 42

// 基本接收
v := <-ch  // 42

// 检查channel是否关闭
v, ok := <-ch
if ok {
    fmt.Println("接收:", v)
} else {
    fmt.Println("Channel已关闭")
}

// 从nil channel接收（永久阻塞）
var ch2 chan int
// v := <-ch2  // ❌ 永久阻塞

// 从已关闭channel接收（返回零值）
close(ch)
v := <-ch  // 0 (零值)
```

**关闭（close）**:

```go
ch := make(chan int, 2)

// 发送数据
ch <- 1
ch <- 2

// 关闭channel
close(ch)

// ✅ 可以继续接收（缓冲数据）
v1 := <-ch  // 1
v2 := <-ch  // 2
v3 := <-ch  // 0 (channel已关闭，返回零值)

// ❌ 不能再发送
// ch <- 3  // panic: send on closed channel

// ❌ 不能重复关闭
// close(ch)  // panic: close of closed channel

// ❌ 不能关闭nil channel
var ch2 chan int
// close(ch2)  // panic: close of nil channel
```

### 3.4 Channel内部实现

**Channel结构（简化）**:

```go
// src/runtime/chan.go
type hchan struct {
    qcount   uint           // 队列中的数据个数
    dataqsiz uint           // 环形队列大小
    buf      unsafe.Pointer // 环形队列指针
    elemsize uint16         // 元素大小
    closed   uint32         // 关闭标志
    elemtype *_type         // 元素类型
    sendx    uint           // 发送索引
    recvx    uint           // 接收索引
    recvq    waitq          // 接收等待队列
    sendq    waitq          // 发送等待队列
    lock     mutex          // 保护所有字段
}
```

**发送过程**:

```text
ch <- value 的执行流程:
┌─────────────────────────────────────────┐
│ 1. 加锁 ch.lock                          │
│ 2. 检查是否有等待接收的goroutine          │
│    • 有 → 直接传递给接收者                │
│    • 无 → 继续                            │
│ 3. 检查缓冲区是否有空间                    │
│    • 有 → 写入缓冲区                      │
│    • 无 → 继续                            │
│ 4. 将当前goroutine加入sendq               │
│ 5. 解锁并park当前goroutine                │
│ 6. 被唤醒后，解锁并返回                    │
└─────────────────────────────────────────┘
```

**接收过程**:

```text
value := <-ch 的执行流程:
┌─────────────────────────────────────────┐
│ 1. 加锁 ch.lock                          │
│ 2. 检查是否有等待发送的goroutine          │
│    • 有 → 从发送者接收                    │
│    • 无 → 继续                            │
│ 3. 检查缓冲区是否有数据                    │
│    • 有 → 从缓冲区读取                    │
│    • 无 → 继续                            │
│ 4. 将当前goroutine加入recvq               │
│ 5. 解锁并park当前goroutine                │
│ 6. 被唤醒后，解锁并返回                    │
└─────────────────────────────────────────┘
```

### 3.5 Channel模式

**1. 单向Channel（类型安全）**:

```go
func producer(ch chan<- int) {  // 只能发送
    for i := 0; i < 10; i++ {
        ch <- i
    }
    close(ch)
}

func consumer(ch <-chan int) {  // 只能接收
    for v := range ch {
        fmt.Println(v)
    }
}

ch := make(chan int)
go producer(ch)
consumer(ch)
```

**2. Channel作为信号量**:

```go
// 限制并发数量
semaphore := make(chan struct{}, 3)  // 最多3个并发

for i := 0; i < 100; i++ {
    semaphore <- struct{}{}  // 获取信号量
    go func(id int) {
        defer func() { <-semaphore }()  // 释放信号量
        doWork(id)
    }(i)
}
```

**3. Channel作为通知**:

```go
// 通知goroutine退出
done := make(chan struct{})

go func() {
    for {
        select {
        case <-done:
            fmt.Println("退出")
            return
        default:
            doWork()
        }
    }
}()

// 通知退出
close(done)
```

**4. Channel超时**:

```go
func withTimeout(ch <-chan int) (int, error) {
    select {
    case v := <-ch:
        return v, nil
    case <-time.After(5 * time.Second):
        return 0, errors.New("timeout")
    }
}
```

---

## 4. 同步原语分析

### 4.1 Mutex（互斥锁）

**基本用法**:

```go
var (
    counter int
    mu      sync.Mutex
)

func increment() {
    mu.Lock()
    counter++
    mu.Unlock()
}

// 使用defer确保解锁
func safeIncrement() {
    mu.Lock()
    defer mu.Unlock()

    counter++
    // 复杂逻辑
}
```

**Mutex实现原理**:

```text
Mutex状态机（Go 1.25.3）:
┌─────────────────────────────────────┐
│ 状态字段（32位）:                     │
│ ┌──────┬──────┬──────┬──────────┐   │
│ │Locked│Woken │Starv │WaiterNum │   │
│ │ (1)  │ (1)  │ (1)  │  (29)    │   │
│ └──────┴──────┴──────┴──────────┘   │
│                                      │
│ 模式:                                │
│ • 正常模式: 自旋尝试获取              │
│ • 饥饿模式: 直接交给等待者            │
└─────────────────────────────────────┘
```

**性能考虑**:

```go
// ❌ 锁粒度太大
func badExample() {
    mu.Lock()
    defer mu.Unlock()

    data := loadData()    // IO操作
    result := process(data)  // 计算密集
    saveResult(result)    // IO操作
}

// ✅ 缩小锁粒度
func goodExample() {
    data := loadData()    // IO操作，无需锁

    mu.Lock()
    result := process(data)  // 只锁住必要部分
    mu.Unlock()

    saveResult(result)    // IO操作，无需锁
}
```

### 4.2 RWMutex（读写锁）

**基本用法**:

```go
var (
    data   map[string]int
    rwmu   sync.RWMutex
)

// 读操作（可并发）
func read(key string) int {
    rwmu.RLock()
    defer rwmu.RUnlock()
    return data[key]
}

// 写操作（互斥）
func write(key string, value int) {
    rwmu.Lock()
    defer rwmu.Unlock()
    data[key] = value
}
```

**选择建议**:

```text
使用RWMutex的场景:
✅ 读多写少（读:写 > 10:1）
✅ 临界区较大
✅ 读操作耗时

使用Mutex的场景:
✅ 读写比例接近
✅ 临界区较小
✅ 写操作频繁

原因: RWMutex有额外开销
```

### 4.3 WaitGroup

**基本用法**:

```go
var wg sync.WaitGroup

// 启动多个goroutine
for i := 0; i < 10; i++ {
    wg.Add(1)
    go func(id int) {
        defer wg.Done()
        doWork(id)
    }(i)
}

// 等待所有完成
wg.Wait()
fmt.Println("所有任务完成")
```

**常见错误**:

```go
// ❌ 错误：在goroutine内Add
for i := 0; i < 10; i++ {
    go func(id int) {
        wg.Add(1)  // ❌ 可能在Wait之后执行
        defer wg.Done()
        doWork(id)
    }(i)
}
wg.Wait()

// ✅ 正确：在启动前Add
for i := 0; i < 10; i++ {
    wg.Add(1)  // ✅ 在goroutine外Add
    go func(id int) {
        defer wg.Done()
        doWork(id)
    }(i)
}
wg.Wait()

// ❌ 错误：Done次数不匹配
wg.Add(1)
go func() {
    defer wg.Done()
    defer wg.Done()  // ❌ Done两次，panic!
}()
```

### 4.4 Once

**基本用法**:

```go
var (
    instance *Singleton
    once     sync.Once
)

func GetInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{}  // 只执行一次
    })
    return instance
}

// 多次调用，只初始化一次
s1 := GetInstance()
s2 := GetInstance()
// s1 == s2
```

**使用场景**:

```go
// 1. 单例模式
var (
    db   *Database
    once sync.Once
)

func GetDB() *Database {
    once.Do(func() {
        db = openDatabase()
    })
    return db
}

// 2. 延迟初始化
var (
    config *Config
    once   sync.Once
)

func GetConfig() *Config {
    once.Do(func() {
        config = loadConfig()
    })
    return config
}

// 3. 一次性设置
var (
    initialized bool
    once        sync.Once
)

func Initialize() {
    once.Do(func() {
        setupResources()
        initialized = true
    })
}
```

### 4.5 Cond（条件变量）

**基本用法**:

```go
var (
    queue []int
    mu    sync.Mutex
    cond  = sync.NewCond(&mu)
)

// 生产者
func producer() {
    for i := 0; i < 10; i++ {
        mu.Lock()
        queue = append(queue, i)
        cond.Signal()  // 通知一个等待者
        mu.Unlock()
    }
}

// 消费者
func consumer() {
    mu.Lock()
    defer mu.Unlock()

    for len(queue) == 0 {
        cond.Wait()  // 等待通知
    }

    item := queue[0]
    queue = queue[1:]
    fmt.Println("消费:", item)
}
```

### 4.6 atomic包

**原子操作**:

```go
import "sync/atomic"

var counter int64

// 原子递增
atomic.AddInt64(&counter, 1)

// 原子加载
value := atomic.LoadInt64(&counter)

// 原子存储
atomic.StoreInt64(&counter, 100)

// 原子交换
old := atomic.SwapInt64(&counter, 200)

// CAS（Compare-And-Swap）
success := atomic.CompareAndSwapInt64(&counter, 200, 300)
```

**性能对比**:

```go
// Mutex版本
var (
    counter int
    mu      sync.Mutex
)

func incrementMutex() {
    mu.Lock()
    counter++
    mu.Unlock()
}

// Atomic版本
var counter int64

func incrementAtomic() {
    atomic.AddInt64(&counter, 1)
}

// Atomic通常快5-10倍
```

---

## 5. GMP调度模型

### 5.1 GMP模型概述

**三元组**:

```text
G (Goroutine)
├── 用户级轻量线程
├── 包含栈、上下文等
└── 数量: 百万级

M (Machine)
├── 操作系统线程
├── 执行G的载体
└── 数量: GOMAXPROCS

P (Processor)
├── 逻辑处理器
├── 持有G的运行队列
└── 数量: GOMAXPROCS
```

**关系图**:

```text
┌─────────────────────────────────────────┐
│        全局G队列                         │
│    [G] [G] [G] [G] [G] ...              │
└─────────────────────────────────────────┘
             ↓ ↑
┌──────────┬──────────┬──────────┐
│   P1     │   P2     │   P3     │
│  [G][G]  │  [G][G]  │  [G][G]  │ (本地G队列)
│    ↓     │    ↓     │    ↓     │
│   M1     │   M2     │   M3     │ (操作系统线程)
└──────────┴──────────┴──────────┘
```

### 5.2 调度策略

**1. Work Stealing（工作窃取）**:

```text
P1的队列: [G1] [G2] [G3]
P2的队列: [G4]
P3的队列: [] ← 空闲

P3从P1偷取: [G3]
P3的队列: [G3]
P1的队列: [G1] [G2]
```

**2. Hand Off（移交）**:

```text
当M1执行的G发生系统调用阻塞:
┌────────────────────────────┐
│ M1 阻塞在系统调用            │
│ P1 被移交给空闲的M2          │
│ P1继续调度其他G              │
└────────────────────────────┘
```

**3. 抢占式调度（Go 1.14+）**:

```go
// Go 1.14之前：协作式抢占
// 只在函数调用时检查

// Go 1.14+：基于信号的抢占
// 可以中断任何执行中的goroutine

func infiniteLoop() {
    for {
        // 在Go 1.14+中，即使没有函数调用
        // 也会被抢占
    }
}
```

### 5.3 GOMAXPROCS

**设置与影响**:

```go
import "runtime"

// 获取当前值
n := runtime.GOMAXPROCS(0)

// 设置为CPU核心数
runtime.GOMAXPROCS(runtime.NumCPU())

// 设置为固定值
runtime.GOMAXPROCS(4)

// 环境变量设置
// export GOMAXPROCS=8
```

**选择建议**:

```text
CPU密集型:
└── GOMAXPROCS = NumCPU()

IO密集型:
└── GOMAXPROCS > NumCPU()

混合型:
└── 测试调优
```

---

## 6. 内存模型与同步

### 6.1 Happens-Before关系

**定义**:

- 如果事件A happens-before 事件B
- 那么A的效果对B可见

**规则**:

```go
// 1. 单goroutine内，按程序顺序
a := 1    // happens-before
b := 2    // happens-before
c := a + b

// 2. Channel发送 happens-before 对应接收
go func() {
    m = 1
    ch <- 1  // 发送
}()
<-ch  // 接收（m=1可见）

// 3. Close happens-before 零值接收
go func() {
    m = 1
    close(ch)
}()
<-ch  // m=1可见

// 4. 无缓冲channel接收 happens-before 发送完成
ch := make(chan int)
go func() {
    ch <- 1  // 阻塞
    m = 1    // 在接收后执行
}()
<-ch  // 接收
// m=1可能还未执行

// 5. Mutex: Unlock happens-before Lock
mu.Lock()
m = 1
mu.Unlock()  // happens-before 下一个Lock

mu.Lock()  // m=1可见
```

### 6.2 数据竞争

**定义**:
两个goroutine并发访问同一变量，至少一个是写操作，且没有同步

```go
// ❌ 数据竞争
var counter int

go func() {
    counter++  // 写
}()

fmt.Println(counter)  // 读（竞争！）

// ✅ 使用锁
var (
    counter int
    mu      sync.Mutex
)

go func() {
    mu.Lock()
    counter++
    mu.Unlock()
}()

mu.Lock()
fmt.Println(counter)
mu.Unlock()

// ✅ 使用channel
ch := make(chan int, 1)
ch <- 0

go func() {
    v := <-ch
    ch <- v + 1
}()

v := <-ch
fmt.Println(v)
```

**检测工具**:

```bash
# 使用-race标志
go run -race main.go
go test -race ./...
go build -race

# 示例输出
WARNING: DATA RACE
Write at 0x00c000014098 by goroutine 6:
  main.increment()
      /path/to/file.go:10 +0x38

Previous read at 0x00c000014098 by main goroutine:
  main.main()
      /path/to/file.go:20 +0x88
```

---

## 7. 并发模式实践

### 7.1 Worker Pool

```go
func workerPool(tasks <-chan Task, results chan<- Result) {
    const numWorkers = 10
    var wg sync.WaitGroup

    // 启动workers
    for i := 0; i < numWorkers; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for task := range tasks {
                result := process(task)
                results <- result
            }
        }(i)
    }

    // 等待完成并关闭结果channel
    go func() {
        wg.Wait()
        close(results)
    }()
}
```

### 7.2 Pipeline

```go
func pipeline() {
    // 阶段1: 生成数据
    gen := func(nums ...int) <-chan int {
        out := make(chan int)
        go func() {
            defer close(out)
            for _, n := range nums {
                out <- n
            }
        }()
        return out
    }

    // 阶段2: 平方
    square := func(in <-chan int) <-chan int {
        out := make(chan int)
        go func() {
            defer close(out)
            for n := range in {
                out <- n * n
            }
        }()
        return out
    }

    // 阶段3: 过滤偶数
    filterEven := func(in <-chan int) <-chan int {
        out := make(chan int)
        go func() {
            defer close(out)
            for n := range in {
                if n%2 == 0 {
                    out <- n
                }
            }
        }()
        return out
    }

    // 组装pipeline
    nums := gen(1, 2, 3, 4, 5)
    squares := square(nums)
    evens := filterEven(squares)

    for v := range evens {
        fmt.Println(v)  // 4, 16
    }
}
```

### 7.3 Fan-Out/Fan-In

```go
func fanOutFanIn() {
    input := make(chan int, 100)

    // Fan-Out: 启动多个worker
    const numWorkers = 5
    workers := make([]<-chan int, numWorkers)
    for i := 0; i < numWorkers; i++ {
        workers[i] = worker(input)
    }

    // Fan-In: 合并结果
    output := merge(workers...)

    // 使用
    go func() {
        for i := 0; i < 100; i++ {
            input <- i
        }
        close(input)
    }()

    for result := range output {
        fmt.Println(result)
    }
}

func worker(input <-chan int) <-chan int {
    output := make(chan int)
    go func() {
        defer close(output)
        for v := range input {
            output <- process(v)
        }
    }()
    return output
}

func merge(channels ...<-chan int) <-chan int {
    var wg sync.WaitGroup
    output := make(chan int)

    wg.Add(len(channels))
    for _, ch := range channels {
        go func(c <-chan int) {
            defer wg.Done()
            for v := range c {
                output <- v
            }
        }(ch)
    }

    go func() {
        wg.Wait()
        close(output)
    }()

    return output
}
```

### 7.4 Context传播

```go
func withContext() {
    ctx, cancel := context.WithTimeout(
        context.Background(),
        5*time.Second,
    )
    defer cancel()

    result, err := doWorkWithContext(ctx)
    if err != nil {
        if errors.Is(err, context.DeadlineExceeded) {
            fmt.Println("超时")
        } else if errors.Is(err, context.Canceled) {
            fmt.Println("取消")
        }
    }
}

func doWorkWithContext(ctx context.Context) (Result, error) {
    // 传递context给子任务
    go subTask(ctx)

    select {
    case <-ctx.Done():
        return Result{}, ctx.Err()
    case result := <-computeResult():
        return result, nil
    }
}

func subTask(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            fmt.Println("子任务退出")
            return
        default:
            // 执行工作
        }
    }
}
```

---

## 8. 并发性能优化

### 8.1 减少锁竞争

```go
// ❌ 高竞争
var (
    globalCounter int
    mu            sync.Mutex
)

func increment() {
    mu.Lock()
    globalCounter++
    mu.Unlock()
}

// ✅ 分片锁
type ShardedCounter struct {
    shards [16]struct {
        mu    sync.Mutex
        count int
    }
}

func (sc *ShardedCounter) Increment() {
    shard := &sc.shards[hash()%16]
    shard.mu.Lock()
    shard.count++
    shard.mu.Unlock()
}

func (sc *ShardedCounter) Total() int {
    total := 0
    for i := range sc.shards {
        sc.shards[i].mu.Lock()
        total += sc.shards[i].count
        sc.shards[i].mu.Unlock()
    }
    return total
}
```

### 8.2 避免goroutine泄露

```go
// ✅ 使用context控制生命周期
func startWorkers(ctx context.Context, n int) {
    for i := 0; i < n; i++ {
        go func(id int) {
            for {
                select {
                case <-ctx.Done():
                    return  // 退出
                default:
                    doWork(id)
                }
            }
        }(i)
    }
}

// 使用
ctx, cancel := context.WithCancel(context.Background())
startWorkers(ctx, 100)

// 停止所有workers
cancel()
```

### 8.3 合理使用缓冲

```go
// ❌ 无缓冲（同步开销大）
ch := make(chan int)

// ✅ 适当缓冲
ch := make(chan int, 100)

// 选择缓冲大小
// • 生产者数量
// • 消费者数量
// • 处理延迟
```

---

## 9. 形式化证明

### 9.1 并发正确性

```text
并发程序性质:
┌─────────────────────────────────────┐
│ 安全性（Safety）:                    │
│ • 坏事不会发生                       │
│ • 例: 无数据竞争                     │
│                                      │
│ 活性（Liveness）:                    │
│ • 好事最终会发生                     │
│ • 例: 无死锁，最终完成                │
└─────────────────────────────────────┘

形式化:
Safety: □¬Bad (永远不发生坏事)
Liveness: ◊Good (最终发生好事)
```

---

## 10. 最佳实践

### 10.1 并发设计原则

```text
1. 优先使用Channel
2. 最小化锁的作用域
3. 避免goroutine泄露
4. 使用Context控制生命周期
5. 适当使用sync.Once
6. 注意数据竞争
7. 性能测试和race检测
```

---

## 📚 总结

### 核心要点

1. **Goroutine**: 轻量级、动态栈、GMP调度
2. **Channel**: 类型安全、同步通信、CSP模型
3. **同步原语**: Mutex、RWMutex、WaitGroup、Once
4. **GMP模型**: 高效调度、工作窃取、抢占式
5. **并发模式**: Worker Pool、Pipeline、Fan-Out/Fan-In

---

- [类型系统完整解析](./01-Go-1.25.3类型系统完整解析.md)
- [控制流机制深度分析](./02-Go-1.25.3控制流机制深度分析.md)
- [CSP模型三维分析](./04-CSP模型三维完整分析-2025.md)

---

**更新日期**: 2025-10-29
