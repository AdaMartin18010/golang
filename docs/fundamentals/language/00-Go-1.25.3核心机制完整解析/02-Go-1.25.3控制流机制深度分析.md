# Go 1.25.3 æ§åˆ¶æµæœºåˆ¶æ·±åº¦åˆ†æ

**ç‰ˆæœ¬**: Go 1.25.3 (2025å¹´10æœˆ)  
**éš¾åº¦**: â­â­â­â­  
**é¢„è®¡é˜…è¯»**: 50åˆ†é’Ÿ  
**æ›´æ–°æ—¥æœŸ**: 2025-10-28

---

## ğŸ“‹ ç›®å½•


- [1. æ§åˆ¶æµæ¦‚è¿°](#1-æ§åˆ¶æµæ¦‚è¿°)
  - [1.1 æ§åˆ¶æµåˆ†ç±»](#11-æ§åˆ¶æµåˆ†ç±»)
  - [1.2 æ§åˆ¶æµç‰¹æ€§](#12-æ§åˆ¶æµç‰¹æ€§)
- [2. é¡ºåºæ§åˆ¶](#2-é¡ºåºæ§åˆ¶)
  - [2.1 è¯­å¥åºåˆ—](#21-è¯­å¥åºåˆ—)
  - [2.2 å˜é‡å£°æ˜ä¸åˆå§‹åŒ–](#22-å˜é‡å£°æ˜ä¸åˆå§‹åŒ–)
  - [2.3 è¡¨è¾¾å¼æ±‚å€¼é¡ºåº](#23-è¡¨è¾¾å¼æ±‚å€¼é¡ºåº)
- [3. åˆ†æ”¯æ§åˆ¶](#3-åˆ†æ”¯æ§åˆ¶)
  - [3.1 if-elseè¯­å¥](#31-if-elseè¯­å¥)
  - [3.2 switchè¯­å¥](#32-switchè¯­å¥)
- [4. å¾ªç¯æ§åˆ¶](#4-å¾ªç¯æ§åˆ¶)
  - [4.1 forå¾ªç¯çš„å››ç§å½¢å¼](#41-forå¾ªç¯çš„å››ç§å½¢å¼)
  - [4.2 rangeçš„é™·é˜±ä¸æŠ€å·§](#42-rangeçš„é™·é˜±ä¸æŠ€å·§)
- [5. è·³è½¬æ§åˆ¶](#5-è·³è½¬æ§åˆ¶)
  - [5.1 breakè¯­å¥](#51-breakè¯­å¥)
  - [5.2 continueè¯­å¥](#52-continueè¯­å¥)
  - [5.3 gotoè¯­å¥](#53-gotoè¯­å¥)
  - [5.4 returnè¯­å¥](#54-returnè¯­å¥)
- [6. å¼‚å¸¸æ§åˆ¶](#6-å¼‚å¸¸æ§åˆ¶)
  - [6.1 deferè¯­å¥](#61-deferè¯­å¥)
  - [6.2 panicè¯­å¥](#62-panicè¯­å¥)
  - [6.3 recoverè¯­å¥](#63-recoverè¯­å¥)
- [7. selectå¤šè·¯å¤ç”¨](#7-selectå¤šè·¯å¤ç”¨)
  - [7.1 selectåŸºæœ¬ç”¨æ³•](#71-selectåŸºæœ¬ç”¨æ³•)
  - [7.2 selectå¸¸è§æ¨¡å¼](#72-selectå¸¸è§æ¨¡å¼)
  - [7.3 selectçš„ç‰¹æ€§](#73-selectçš„ç‰¹æ€§)
- [8. æ§åˆ¶æµç»„åˆ](#8-æ§åˆ¶æµç»„åˆ)
  - [8.1 å¸¸è§ç»„åˆæ¨¡å¼](#81-å¸¸è§ç»„åˆæ¨¡å¼)
- [9. å½¢å¼åŒ–è¯­ä¹‰](#9-å½¢å¼åŒ–è¯­ä¹‰)
  - [9.1 æ§åˆ¶æµå½¢å¼åŒ–å®šä¹‰](#91-æ§åˆ¶æµå½¢å¼åŒ–å®šä¹‰)
- [10. æœ€ä½³å®è·µ](#10-æœ€ä½³å®è·µ)
  - [10.1 æ§åˆ¶æµè®¾è®¡åŸåˆ™](#101-æ§åˆ¶æµè®¾è®¡åŸåˆ™)
  - [10.2 æ€§èƒ½è€ƒè™‘](#102-æ€§èƒ½è€ƒè™‘)
- [ğŸ“š æ€»ç»“](#-æ€»ç»“)
  - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
  - [å­¦ä¹ å»ºè®®](#å­¦ä¹ å»ºè®®)

## 1. æ§åˆ¶æµæ¦‚è¿°

### 1.1 æ§åˆ¶æµåˆ†ç±»

```text
Goæ§åˆ¶æµä½“ç³»
â”œâ”€â”€ é¡ºåºæ§åˆ¶ (Sequential)
â”‚   â”œâ”€â”€ è¯­å¥åºåˆ—
â”‚   â”œâ”€â”€ å˜é‡å£°æ˜
â”‚   â””â”€â”€ è¡¨è¾¾å¼æ±‚å€¼
â”‚
â”œâ”€â”€ åˆ†æ”¯æ§åˆ¶ (Branching)
â”‚   â”œâ”€â”€ if-else
â”‚   â”œâ”€â”€ switch-case
â”‚   â””â”€â”€ type switch
â”‚
â”œâ”€â”€ å¾ªç¯æ§åˆ¶ (Looping)
â”‚   â”œâ”€â”€ for (æ¡ä»¶å¾ªç¯)
â”‚   â”œâ”€â”€ for (æ— é™å¾ªç¯)
â”‚   â”œâ”€â”€ for (ä¸‰æ®µå¼)
â”‚   â””â”€â”€ for-range
â”‚
â”œâ”€â”€ è·³è½¬æ§åˆ¶ (Jumping)
â”‚   â”œâ”€â”€ break
â”‚   â”œâ”€â”€ continue
â”‚   â”œâ”€â”€ goto
â”‚   â”œâ”€â”€ return
â”‚   â””â”€â”€ fallthrough
â”‚
â”œâ”€â”€ å¼‚å¸¸æ§åˆ¶ (Exception)
â”‚   â”œâ”€â”€ defer
â”‚   â”œâ”€â”€ panic
â”‚   â””â”€â”€ recover
â”‚
â””â”€â”€ å¹¶å‘æ§åˆ¶ (Concurrent)
    â”œâ”€â”€ go (goroutine)
    â””â”€â”€ select (channel multiplexing)
```

### 1.2 æ§åˆ¶æµç‰¹æ€§

**Goæ§åˆ¶æµçš„ç‹¬ç‰¹ä¹‹å¤„**:

```go
// 1. ç®€æ´æ€§ - åªæœ‰ä¸€ç§å¾ªç¯
for i := 0; i < 10; i++ {}  // âœ…
// while (i < 10) {}        // âŒ Goæ²¡æœ‰while

// 2. å¼ºåˆ¶å¤§æ‹¬å·
if x > 0 {  // âœ…
    // ...
}
// if x > 0 do_something()  // âŒ å¿…é¡»ä½¿ç”¨å¤§æ‹¬å·

// 3. çŸ­å˜é‡å£°æ˜
if err := doSomething(); err != nil {  // âœ…
    return err
}

// 4. ç±»å‹switch
switch v := x.(type) {
case int:
    fmt.Println("æ•´æ•°:", v)
case string:
    fmt.Println("å­—ç¬¦ä¸²:", v)
}

// 5. deferå»¶è¿Ÿæ‰§è¡Œ
defer close(file)  // å‡½æ•°è¿”å›å‰æ‰§è¡Œ

// 6. selectå¤šè·¯å¤ç”¨
select {
case v := <-ch1:
    process(v)
case v := <-ch2:
    handle(v)
}
```

---

## 2. é¡ºåºæ§åˆ¶

### 2.1 è¯­å¥åºåˆ—

```go
// è¯­å¥æŒ‰é¡ºåºæ‰§è¡Œ
func example() {
    a := 1       // è¯­å¥1
    b := 2       // è¯­å¥2
    c := a + b   // è¯­å¥3
    fmt.Println(c) // è¯­å¥4
}

// å—ä½œç”¨åŸŸ
{
    x := 10
    fmt.Println(x)  // 10
}
// fmt.Println(x)  // âŒ é”™è¯¯ï¼xè¶…å‡ºä½œç”¨åŸŸ
```

### 2.2 å˜é‡å£°æ˜ä¸åˆå§‹åŒ–

```go
// å£°æ˜å½¢å¼
var x int               // å£°æ˜
x = 10                  // èµ‹å€¼

var y int = 20          // å£°æ˜+åˆå§‹åŒ–
z := 30                 // çŸ­å˜é‡å£°æ˜ï¼ˆæ¨å¯¼ç±»å‹ï¼‰

// å¤šå˜é‡å£°æ˜
var a, b, c int
var i, j, k = 1, 2, 3
m, n := 4, 5

// æ‰¹é‡å£°æ˜
var (
    name string
    age  int
    addr string
)

// å£°æ˜é¡ºåºé‡è¦æ€§
var (
    x = y + 1  // âŒ é”™è¯¯ï¼yæœªå£°æ˜
    y = 10
)

var (
    y = 10
    x = y + 1  // âœ… OK
)
```

### 2.3 è¡¨è¾¾å¼æ±‚å€¼é¡ºåº

```go
// 1. èµ‹å€¼çš„æ±‚å€¼é¡ºåº
a, b = b, a  // äº¤æ¢ï¼ˆå…ˆæ±‚å€¼å³ä¾§ï¼Œå†èµ‹å€¼å·¦ä¾§ï¼‰

// 2. å‡½æ•°è°ƒç”¨çš„æ±‚å€¼é¡ºåº
func trace(msg string) int {
    fmt.Println(msg)
    return 0
}

x := trace("first") + trace("second")
// è¾“å‡º:
// first
// second

// 3. æ“ä½œæ•°æ±‚å€¼é¡ºåºï¼ˆæœªå®šä¹‰ï¼ï¼‰
x := f() + g()  // få’Œgçš„è°ƒç”¨é¡ºåºæœªå®šä¹‰
```

---

## 3. åˆ†æ”¯æ§åˆ¶

### 3.1 if-elseè¯­å¥

**åŸºæœ¬å½¢å¼**:
```go
// ç®€å•if
if x > 0 {
    fmt.Println("positive")
}

// if-else
if x > 0 {
    fmt.Println("positive")
} else {
    fmt.Println("non-positive")
}

// if-else if-else
if x > 0 {
    fmt.Println("positive")
} else if x < 0 {
    fmt.Println("negative")
} else {
    fmt.Println("zero")
}
```

**å¸¦åˆå§‹åŒ–è¯­å¥çš„if**:
```go
// çŸ­å˜é‡å£°æ˜
if x := compute(); x > 0 {
    fmt.Println("ç»“æœ:", x)
}
// xè¶…å‡ºä½œç”¨åŸŸ

// é”™è¯¯å¤„ç†æ¨¡å¼
if err := doSomething(); err != nil {
    return err
}

// å¤æ‚åˆå§‹åŒ–
if result, err := calculate(); err != nil {
    return err
} else {
    fmt.Println("ç»“æœ:", result)
}
```

**æ¡ä»¶è¡¨è¾¾å¼**:
```go
// å¿…é¡»æ˜¯boolç±»å‹
if true {  // âœ…
}
// if 1 {  // âŒ é”™è¯¯ï¼ä¸èƒ½ç”¨æ•´æ•°

// æ¯”è¾ƒè¿ç®—
if x == y {
    // ...
}

// é€»è¾‘è¿ç®—
if x > 0 && y > 0 {
    // ...
}

// çŸ­è·¯æ±‚å€¼
if x != 0 && 100/x > 5 {  // x == 0æ—¶ï¼Œä¸ä¼šè®¡ç®—100/x
    // ...
}
```

### 3.2 switchè¯­å¥

**åŸºæœ¬å½¢å¼**:
```go
// è¡¨è¾¾å¼switch
switch x {
case 1:
    fmt.Println("one")
case 2:
    fmt.Println("two")
case 3, 4, 5:  // å¤šä¸ªå€¼
    fmt.Println("three, four, or five")
default:
    fmt.Println("other")
}

// å¸¦åˆå§‹åŒ–è¯­å¥
switch value := getValue(); value {
case 1:
    // ...
default:
    // ...
}

// æ— è¡¨è¾¾å¼switchï¼ˆç›¸å½“äºif-elseé“¾ï¼‰
switch {
case x > 0:
    fmt.Println("positive")
case x < 0:
    fmt.Println("negative")
default:
    fmt.Println("zero")
}
```

**fallthroughè¯­å¥**:
```go
switch x {
case 1:
    fmt.Println("one")
    fallthrough  // ç»§ç»­æ‰§è¡Œä¸‹ä¸€ä¸ªcase
case 2:
    fmt.Println("one or two")
case 3:
    fmt.Println("three")
}

// x = 1æ—¶è¾“å‡º:
// one
// one or two
```

**ç±»å‹switch**:
```go
func classify(v interface{}) {
    switch v := v.(type) {
    case nil:
        fmt.Println("nil")
    case int:
        fmt.Printf("æ•´æ•°: %d\n", v)
    case float64:
        fmt.Printf("æµ®ç‚¹: %f\n", v)
    case string:
        fmt.Printf("å­—ç¬¦ä¸²: %s\n", v)
    case bool:
        fmt.Printf("å¸ƒå°”: %t\n", v)
    case []int:
        fmt.Printf("æ•´æ•°åˆ‡ç‰‡: %v\n", v)
    default:
        fmt.Printf("æœªçŸ¥ç±»å‹: %T\n", v)
    }
}

// ä½¿ç”¨
classify(42)           // æ•´æ•°: 42
classify(3.14)         // æµ®ç‚¹: 3.140000
classify("hello")      // å­—ç¬¦ä¸²: hello
classify([]int{1,2,3}) // æ•´æ•°åˆ‡ç‰‡: [1 2 3]
```

**switchç‰¹æ€§**:
```go
// 1. ä¸éœ€è¦breakï¼ˆè‡ªåŠ¨breakï¼‰
switch x {
case 1:
    doSomething()
    // è‡ªåŠ¨breakï¼Œä¸ä¼šç»§ç»­åˆ°case 2
case 2:
    doOther()
}

// 2. caseè¡¨è¾¾å¼å¯ä»¥æ˜¯è¿è¡Œæ—¶è®¡ç®—
switch x {
case compute():  // è¿è¡Œæ—¶è®¡ç®—
    // ...
case getValue():
    // ...
}

// 3. caseå¯ä»¥æ˜¯èŒƒå›´åˆ¤æ–­
switch {
case x < 0:
    // ...
case x >= 0 && x < 10:
    // ...
case x >= 10:
    // ...
}
```

---

## 4. å¾ªç¯æ§åˆ¶

### 4.1 forå¾ªç¯çš„å››ç§å½¢å¼

**1. æ¡ä»¶å¾ªç¯**:
```go
// whileé£æ ¼
i := 0
for i < 10 {
    fmt.Println(i)
    i++
}

// æ— é™å¾ªç¯
for {
    // éœ€è¦breaké€€å‡º
    if condition {
        break
    }
}
```

**2. ä¸‰æ®µå¼for**:
```go
// æ ‡å‡†forå¾ªç¯
for i := 0; i < 10; i++ {
    fmt.Println(i)
}

// å¤šå˜é‡
for i, j := 0, 10; i < j; i, j = i+1, j-1 {
    fmt.Println(i, j)
}

// çœç•¥éƒ¨åˆ†
for ; i < 10; i++ {  // çœç•¥åˆå§‹åŒ–
    // ...
}

for i := 0; ; i++ {  // çœç•¥æ¡ä»¶
    if i >= 10 {
        break
    }
}

for i := 0; i < 10; {  // çœç•¥åç½®è¯­å¥
    // ...
    i++
}
```

**3. rangeå¾ªç¯**:
```go
// æ•°ç»„/åˆ‡ç‰‡
nums := []int{1, 2, 3, 4, 5}
for i, v := range nums {
    fmt.Printf("ç´¢å¼•:%d å€¼:%d\n", i, v)
}

// åªè¦ç´¢å¼•
for i := range nums {
    fmt.Println(i)
}

// åªè¦å€¼
for _, v := range nums {
    fmt.Println(v)
}

// å­—ç¬¦ä¸²ï¼ˆæŒ‰runeéå†ï¼‰
for i, r := range "Helloä¸–ç•Œ" {
    fmt.Printf("%d: %c\n", i, r)
}
// è¾“å‡º:
// 0: H
// 1: e
// 2: l
// 3: l
// 4: o
// 5: ä¸–
// 8: ç•Œ

// æ˜ å°„
m := map[string]int{"a": 1, "b": 2}
for k, v := range m {
    fmt.Printf("%s: %d\n", k, v)
}

// é€šé“
ch := make(chan int, 3)
ch <- 1
ch <- 2
ch <- 3
close(ch)

for v := range ch {
    fmt.Println(v)
}
```

**4. å¸¦æ ‡ç­¾çš„for**:
```go
// æ ‡ç­¾ç”¨äºå¤šå±‚å¾ªç¯çš„è·³å‡º
outer:
for i := 0; i < 5; i++ {
    for j := 0; j < 5; j++ {
        if i*j > 6 {
            break outer  // è·³å‡ºå¤–å±‚å¾ªç¯
        }
        fmt.Printf("(%d,%d) ", i, j)
    }
}
```

### 4.2 rangeçš„é™·é˜±ä¸æŠ€å·§

**é™·é˜±1: rangeå€¼æ˜¯å‰¯æœ¬**:
```go
// âŒ é”™è¯¯ç”¨æ³•
type Item struct {
    value int
}

items := []Item{{1}, {2}, {3}}
for _, item := range items {
    item.value *= 2  // ä¿®æ”¹çš„æ˜¯å‰¯æœ¬ï¼
}
fmt.Println(items)  // [{1} {2} {3}] æœªæ”¹å˜

// âœ… æ­£ç¡®ç”¨æ³•1: ä½¿ç”¨ç´¢å¼•
for i := range items {
    items[i].value *= 2
}

// âœ… æ­£ç¡®ç”¨æ³•2: ä½¿ç”¨æŒ‡é’ˆåˆ‡ç‰‡
itemPtrs := []*Item{&Item{1}, &Item{2}, &Item{3}}
for _, item := range itemPtrs {
    item.value *= 2  // ä¿®æ”¹æŒ‡é’ˆæŒ‡å‘çš„å€¼
}
```

**é™·é˜±2: å¾ªç¯å˜é‡å¤ç”¨**:
```go
// âŒ é”™è¯¯ç”¨æ³•
var funcs []func()
for i := 0; i < 3; i++ {
    funcs = append(funcs, func() {
        fmt.Println(i)  // é—­åŒ…æ•è·çš„æ˜¯içš„å¼•ç”¨
    })
}
for _, f := range funcs {
    f()  // è¾“å‡º: 3 3 3
}

// âœ… æ­£ç¡®ç”¨æ³•: åˆ›å»ºå±€éƒ¨å˜é‡
var funcs []func()
for i := 0; i < 3; i++ {
    i := i  // åˆ›å»ºæ–°å˜é‡
    funcs = append(funcs, func() {
        fmt.Println(i)
    })
}
for _, f := range funcs {
    f()  // è¾“å‡º: 0 1 2
}
```

**æŠ€å·§: rangeçš„æ±‚å€¼æ—¶æœº**:
```go
// rangeè¡¨è¾¾å¼åªæ±‚å€¼ä¸€æ¬¡
nums := []int{1, 2, 3}
for i, v := range nums {
    nums = append(nums, v)  // ä¿®æ”¹nums
    if i >= 2 {
        break  // å¿…é¡»breakï¼Œå¦åˆ™æ— é™å¾ªç¯
    }
}
fmt.Println(nums)  // [1 2 3 1 2 3]
// rangeåªéå†åŸå§‹çš„3ä¸ªå…ƒç´ 
```

---

## 5. è·³è½¬æ§åˆ¶

### 5.1 breakè¯­å¥

```go
// 1. è·³å‡ºå¾ªç¯
for i := 0; i < 10; i++ {
    if i == 5 {
        break  // è·³å‡ºå¾ªç¯
    }
    fmt.Println(i)
}

// 2. è·³å‡ºswitch
switch x {
case 1:
    if condition {
        break  // è·³å‡ºswitchï¼Œä¸æ˜¯å¾ªç¯
    }
    doSomething()
}

// 3. å¸¦æ ‡ç­¾çš„break
outer:
for i := 0; i < 5; i++ {
    for j := 0; j < 5; j++ {
        if i*j > 6 {
            break outer  // è·³å‡ºå¤–å±‚å¾ªç¯
        }
    }
}

// 4. breakç”¨äºselect
for {
    select {
    case v := <-ch:
        if v == 0 {
            break  // åªè·³å‡ºselectï¼Œä¸è·³å‡ºfor
        }
    }
}

// æ­£ç¡®çš„è·³å‡ºæ–¹å¼
done := false
for !done {
    select {
    case v := <-ch:
        if v == 0 {
            done = true
        }
    }
}
```

### 5.2 continueè¯­å¥

```go
// 1. è·³è¿‡æœ¬æ¬¡å¾ªç¯
for i := 0; i < 10; i++ {
    if i % 2 == 0 {
        continue  // è·³è¿‡å¶æ•°
    }
    fmt.Println(i)  // åªè¾“å‡ºå¥‡æ•°
}

// 2. å¸¦æ ‡ç­¾çš„continue
outer:
for i := 0; i < 5; i++ {
    for j := 0; j < 5; j++ {
        if j == 2 {
            continue outer  // ç»§ç»­å¤–å±‚å¾ªç¯çš„ä¸‹ä¸€æ¬¡è¿­ä»£
        }
        fmt.Printf("(%d,%d) ", i, j)
    }
}
```

### 5.3 gotoè¯­å¥

```go
// gotoç”¨æ³•ï¼ˆè°¨æ…ä½¿ç”¨ï¼‰
func example() error {
    // èµ„æºåˆ†é…
    conn, err := openConnection()
    if err != nil {
        goto cleanup
    }
    
    file, err := openFile()
    if err != nil {
        goto cleanup
    }
    
    // æ­£å¸¸å¤„ç†
    process(conn, file)
    
cleanup:
    if file != nil {
        file.Close()
    }
    if conn != nil {
        conn.Close()
    }
    return err
}

// gotoçš„é™åˆ¶
func invalid() {
    goto label
    x := 10  // âŒ é”™è¯¯ï¼ä¸èƒ½è·³è¿‡å˜é‡å£°æ˜
label:
    fmt.Println(x)
}

// âœ… æ­£ç¡®ç”¨æ³•
func valid() {
    x := 10
    goto label
label:
    fmt.Println(x)
}
```

### 5.4 returnè¯­å¥

```go
// 1. è¿”å›å€¼
func add(a, b int) int {
    return a + b
}

// 2. å¤šè¿”å›å€¼
func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

// 3. å‘½åè¿”å›å€¼
func compute(x int) (result int, err error) {
    if x < 0 {
        err = errors.New("negative input")
        return  // ç›¸å½“äºreturn result, err
    }
    result = x * 2
    return  // ç›¸å½“äºreturn result, err
}

// 4. deferä¸returnçš„äº¤äº’
func example() (result int) {
    defer func() {
        result++  // ä¿®æ”¹è¿”å›å€¼
    }()
    return 10  // è¿”å›11ï¼Œä¸æ˜¯10
}
```

---

## 6. å¼‚å¸¸æ§åˆ¶

### 6.1 deferè¯­å¥

**åŸºæœ¬ç”¨æ³•**:
```go
// å»¶è¿Ÿæ‰§è¡Œ
func readFile(filename string) error {
    f, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer f.Close()  // å‡½æ•°è¿”å›å‰æ‰§è¡Œ
    
    // å¤„ç†æ–‡ä»¶
    return nil
}

// å¤šä¸ªdeferï¼ˆLIFOé¡ºåºï¼‰
func example() {
    defer fmt.Println("1")
    defer fmt.Println("2")
    defer fmt.Println("3")
}
// è¾“å‡º: 3 2 1
```

**deferçš„æ±‚å€¼æ—¶æœº**:
```go
// deferçš„å‚æ•°ç«‹å³æ±‚å€¼
func example() {
    x := 10
    defer fmt.Println(x)  // ç«‹å³æ±‚å€¼x=10
    x = 20
}
// è¾“å‡º: 10

// ä½¿ç”¨åŒ¿åå‡½æ•°å»¶è¿Ÿæ±‚å€¼
func example() {
    x := 10
    defer func() {
        fmt.Println(x)  // å»¶è¿Ÿæ±‚å€¼
    }()
    x = 20
}
// è¾“å‡º: 20
```

**deferçš„åº”ç”¨åœºæ™¯**:
```go
// 1. èµ„æºé‡Šæ”¾
func process() error {
    file, err := os.Open("data.txt")
    if err != nil {
        return err
    }
    defer file.Close()
    
    mutex.Lock()
    defer mutex.Unlock()
    
    // å¤„ç†é€»è¾‘
    return nil
}

// 2. é”™è¯¯æ¢å¤
func safeExecute() (err error) {
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("panic: %v", r)
        }
    }()
    
    // å¯èƒ½panicçš„ä»£ç 
    riskyOperation()
    return nil
}

// 3. æ‰§è¡Œæ—¶é—´ç»Ÿè®¡
func timeTrack(start time.Time) {
    elapsed := time.Since(start)
    fmt.Printf("æ‰§è¡Œæ—¶é—´: %s\n", elapsed)
}

func doWork() {
    defer timeTrack(time.Now())
    // å·¥ä½œä»£ç 
}

// 4. ä¿®æ”¹è¿”å›å€¼
func modify() (result int) {
    defer func() {
        result *= 2
    }()
    return 10  // å®é™…è¿”å›20
}
```

### 6.2 panicè¯­å¥

**è§¦å‘panic**:
```go
// æ˜¾å¼panic
func divide(a, b int) int {
    if b == 0 {
        panic("division by zero")
    }
    return a / b
}

// éšå¼panicï¼ˆè¿è¡Œæ—¶é”™è¯¯ï¼‰
var p *int
// *p = 10  // panic: runtime error: invalid memory address

// nilå¼•ç”¨
var slice []int
// _ = slice[0]  // panic: index out of range

// ç±»å‹æ–­è¨€å¤±è´¥
var i interface{} = "hello"
// _ = i.(int)  // panic: interface conversion
```

**panicçš„ä¼ æ’­**:
```go
func level3() {
    panic("error in level3")
}

func level2() {
    defer fmt.Println("level2 defer")
    level3()
    fmt.Println("unreachable")  // ä¸ä¼šæ‰§è¡Œ
}

func level1() {
    defer fmt.Println("level1 defer")
    level2()
    fmt.Println("unreachable")  // ä¸ä¼šæ‰§è¡Œ
}

// è°ƒç”¨level1()
// è¾“å‡º:
// level2 defer
// level1 defer
// panic: error in level3
```

### 6.3 recoverè¯­å¥

**åŸºæœ¬ç”¨æ³•**:
```go
func example() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("æ¢å¤panic:", r)
        }
    }()
    
    panic("something wrong")
    fmt.Println("unreachable")  // ä¸ä¼šæ‰§è¡Œ
}
// è¾“å‡º: æ¢å¤panic: something wrong
```

**recoverçš„è§„åˆ™**:
```go
// âœ… æ­£ç¡®ï¼šåœ¨deferä¸­ç›´æ¥è°ƒç”¨
func correct() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("recovered:", r)
        }
    }()
    panic("error")
}

// âŒ é”™è¯¯ï¼šä¸åœ¨deferä¸­
func wrong1() {
    if r := recover(); r != nil {  // æ— æ•ˆï¼
        fmt.Println("recovered:", r)
    }
    panic("error")
}

// âŒ é”™è¯¯ï¼šåœ¨deferè°ƒç”¨çš„å‡½æ•°ä¸­
func recoverFunc() {
    if r := recover(); r != nil {  // æ— æ•ˆï¼
        fmt.Println("recovered:", r)
    }
}

func wrong2() {
    defer recoverFunc()  // æ— æ•ˆï¼
    panic("error")
}

// âœ… æ­£ç¡®ï¼šåŒ…è£…ååœ¨deferä¸­è°ƒç”¨
func wrong2Fixed() {
    defer func() {
        recoverFunc()  // âœ… æœ‰æ•ˆ
    }()
    panic("error")
}
```

**å®æˆ˜æ¨¡å¼**:
```go
// 1. HTTPå¤„ç†å™¨çš„panicæ¢å¤
func safeHandler(handler http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                log.Printf("panic: %v\n%s", err, debug.Stack())
                http.Error(w, "Internal Server Error", 500)
            }
        }()
        handler(w, r)
    }
}

// 2. Goroutineçš„panicä¿æŠ¤
func safego(f func()) {
    go func() {
        defer func() {
            if err := recover(); err != nil {
                log.Printf("goroutine panic: %v", err)
            }
        }()
        f()
    }()
}

// 3. æµ‹è¯•è¾…åŠ©å‡½æ•°
func expectPanic(t *testing.T, f func()) {
    defer func() {
        if r := recover(); r == nil {
            t.Error("expected panic")
        }
    }()
    f()
}
```

---

## 7. selectå¤šè·¯å¤ç”¨

### 7.1 selectåŸºæœ¬ç”¨æ³•

```go
// åŸºæœ¬select
ch1 := make(chan int)
ch2 := make(chan string)

select {
case v := <-ch1:
    fmt.Println("ä»ch1æ¥æ”¶:", v)
case v := <-ch2:
    fmt.Println("ä»ch2æ¥æ”¶:", v)
case ch1 <- 42:
    fmt.Println("å‘é€åˆ°ch1")
}

// select with default
select {
case v := <-ch:
    fmt.Println("æ¥æ”¶:", v)
default:
    fmt.Println("æ²¡æœ‰å°±ç»ªçš„é€šé“")  // éé˜»å¡
}

// æ— é™ç­‰å¾…
select {}  // æ°¸ä¹…é˜»å¡
```

### 7.2 selectå¸¸è§æ¨¡å¼

**1. è¶…æ—¶æ§åˆ¶**:
```go
// æ–¹å¼1: time.After
select {
case v := <-ch:
    fmt.Println("æ¥æ”¶:", v)
case <-time.After(1 * time.Second):
    fmt.Println("è¶…æ—¶")
}

// æ–¹å¼2: time.Timerï¼ˆå¯å¤ç”¨ï¼‰
timer := time.NewTimer(1 * time.Second)
defer timer.Stop()

select {
case v := <-ch:
    fmt.Println("æ¥æ”¶:", v)
case <-timer.C:
    fmt.Println("è¶…æ—¶")
}
```

**2. éé˜»å¡é€šä¿¡**:
```go
// éé˜»å¡å‘é€
select {
case ch <- value:
    fmt.Println("å‘é€æˆåŠŸ")
default:
    fmt.Println("é€šé“æ»¡ï¼Œå‘é€å¤±è´¥")
}

// éé˜»å¡æ¥æ”¶
select {
case v := <-ch:
    fmt.Println("æ¥æ”¶:", v)
default:
    fmt.Println("é€šé“ç©ºï¼Œæ¥æ”¶å¤±è´¥")
}
```

**3. å¤šè·¯åˆå¹¶**:
```go
func merge(channels ...<-chan int) <-chan int {
    out := make(chan int)
    
    var wg sync.WaitGroup
    wg.Add(len(channels))
    
    for _, ch := range channels {
        go func(c <-chan int) {
            defer wg.Done()
            for v := range c {
                out <- v
            }
        }(ch)
    }
    
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}
```

**4. é€€å‡ºæ§åˆ¶**:
```go
func worker(done <-chan struct{}) {
    for {
        select {
        case <-done:
            fmt.Println("workeré€€å‡º")
            return
        default:
            // æ‰§è¡Œå·¥ä½œ
            doWork()
        }
    }
}

// ä½¿ç”¨context
func worker(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            fmt.Println("workeré€€å‡º:", ctx.Err())
            return
        default:
            doWork()
        }
    }
}
```

### 7.3 selectçš„ç‰¹æ€§

**1. éšæœºé€‰æ‹©**:
```go
// å¤šä¸ªcaseå°±ç»ªæ—¶ï¼Œéšæœºé€‰æ‹©ä¸€ä¸ª
ch1 := make(chan int, 1)
ch2 := make(chan int, 1)
ch1 <- 1
ch2 <- 2

select {
case v := <-ch1:
    fmt.Println("ch1:", v)
case v := <-ch2:
    fmt.Println("ch2:", v)
}
// éšæœºè¾“å‡º "ch1: 1" æˆ– "ch2: 2"
```

**2. nilé€šé“**:
```go
// nilé€šé“æ°¸è¿œé˜»å¡
var ch chan int  // nil
select {
case v := <-ch:  // æ°¸è¿œä¸ä¼šè¢«é€‰ä¸­
    fmt.Println(v)
case <-time.After(1 * time.Second):
    fmt.Println("timeout")
}

// åŠ¨æ€ç¦ç”¨case
ch1, ch2 := make(chan int), make(chan int)
for i := 0; i < 2; i++ {
    select {
    case v := <-ch1:
        fmt.Println("ch1:", v)
        ch1 = nil  // ç¦ç”¨ch1
    case v := <-ch2:
        fmt.Println("ch2:", v)
        ch2 = nil  // ç¦ç”¨ch2
    }
}
```

**3. ç©ºselect**:
```go
select {}  // æ°¸ä¹…é˜»å¡ï¼Œç›¸å½“äº for {}
```

---

## 8. æ§åˆ¶æµç»„åˆ

### 8.1 å¸¸è§ç»„åˆæ¨¡å¼

**1. if + defer + panic/recover**:
```go
func safeProcess(data interface{}) (result interface{}, err error) {
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("panic: %v", r)
        }
    }()
    
    if data == nil {
        return nil, errors.New("nil data")
    }
    
    // å¯èƒ½panicçš„å¤„ç†
    result = riskyOperation(data)
    return result, nil
}
```

**2. for + select**:
```go
// äº‹ä»¶å¾ªç¯
func eventLoop(events <-chan Event, done <-chan struct{}) {
    for {
        select {
        case event := <-events:
            handleEvent(event)
        case <-done:
            return
        }
    }
}
```

**3. for + range + defer**:
```go
func processFiles(files []string) error {
    for _, filename := range files {
        if err := processFile(filename); err != nil {
            return err
        }
    }
    return nil
}

func processFile(filename string) error {
    f, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer f.Close()
    
    // å¤„ç†æ–‡ä»¶
    return nil
}
```

---

## 9. å½¢å¼åŒ–è¯­ä¹‰

### 9.1 æ§åˆ¶æµå½¢å¼åŒ–å®šä¹‰

```text
è¯­å¥è¯­æ³•:
Stmt ::= VarDecl | Assignment | IfStmt | ForStmt | 
         SwitchStmt | ReturnStmt | BreakStmt | 
         ContinueStmt | GotoStmt | DeferStmt | 
         SelectStmt | Block

æ§åˆ¶æµè¯­ä¹‰è§„åˆ™:

[SEQ]  è¯„ä¼°s1ï¼Œç„¶åè¯„ä¼°s2
       âŸ¨s1; s2, ÏƒâŸ© â†’ âŸ¨s2, Ïƒ'âŸ©

[IF-TRUE]  æ¡ä»¶ä¸ºçœŸï¼Œæ‰§è¡Œthenåˆ†æ”¯
           e è¯„ä¼°ä¸º true
           â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
           âŸ¨if e {s1} else {s2}, ÏƒâŸ© â†’ âŸ¨s1, ÏƒâŸ©

[IF-FALSE]  æ¡ä»¶ä¸ºå‡ï¼Œæ‰§è¡Œelseåˆ†æ”¯
            e è¯„ä¼°ä¸º false
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            âŸ¨if e {s1} else {s2}, ÏƒâŸ© â†’ âŸ¨s2, ÏƒâŸ©

[FOR]  å¾ªç¯è§„åˆ™
       e è¯„ä¼°ä¸º true
       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       âŸ¨for e {s}, ÏƒâŸ© â†’ âŸ¨s; for e {s}, ÏƒâŸ©
       
       e è¯„ä¼°ä¸º false
       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       âŸ¨for e {s}, ÏƒâŸ© â†’ Ïƒ

[DEFER]  å»¶è¿Ÿæ‰§è¡Œè§„åˆ™
         deferè¯­å¥å°†såŠ å…¥deferæ ˆ
         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
         âŸ¨defer s, ÏƒâŸ© â†’ Ïƒ'
         
         å‡½æ•°è¿”å›æ—¶ï¼ŒæŒ‰LIFOé¡ºåºæ‰§è¡Œdeferæ ˆä¸­çš„è¯­å¥
```

---

## 10. æœ€ä½³å®è·µ

### 10.1 æ§åˆ¶æµè®¾è®¡åŸåˆ™

**1. ç®€æ´æ€§**:
```go
// âŒ ä¸æ¨èï¼šè¿‡æ·±çš„åµŒå¥—
func process(x int) error {
    if x > 0 {
        if x < 100 {
            if x % 2 == 0 {
                // æ·±å±‚åµŒå¥—
                return doSomething()
            }
        }
    }
    return nil
}

// âœ… æ¨èï¼šæ—©è¿”å›
func process(x int) error {
    if x <= 0 {
        return nil
    }
    if x >= 100 {
        return nil
    }
    if x % 2 != 0 {
        return nil
    }
    return doSomething()
}
```

**2. é”™è¯¯å¤„ç†**:
```go
// âœ… æ¨èï¼šç«‹å³å¤„ç†é”™è¯¯
func process() error {
    data, err := loadData()
    if err != nil {
        return fmt.Errorf("load data: %w", err)
    }
    
    result, err := compute(data)
    if err != nil {
        return fmt.Errorf("compute: %w", err)
    }
    
    return save(result)
}
```

**3. deferä½¿ç”¨**:
```go
// âœ… æ¨èï¼šç”¨deferç¡®ä¿èµ„æºé‡Šæ”¾
func processFile(filename string) error {
    f, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer f.Close()  // ç¡®ä¿å…³é—­
    
    // å¤„ç†æ–‡ä»¶
    return nil
}

// âŒ ä¸æ¨èï¼šå®¹æ˜“é—æ¼Close
func processFile(filename string) error {
    f, err := os.Open(filename)
    if err != nil {
        return err
    }
    
    // å¤„ç†æ–‡ä»¶
    if err := process(f); err != nil {
        return err  // å¿˜è®°å…³é—­ï¼
    }
    
    f.Close()
    return nil
}
```

### 10.2 æ€§èƒ½è€ƒè™‘

```go
// 1. deferæœ‰æ€§èƒ½å¼€é”€
// çƒ­ç‚¹è·¯å¾„é¿å…defer
func hotPath() {
    mu.Lock()
    // å¿«é€Ÿæ“ä½œ
    mu.Unlock()  // ä¸ç”¨defer
}

// 2. rangeçš„æ€§èƒ½
// å¤§åˆ‡ç‰‡å¤åˆ¶
type Large struct {
    data [1000]int
}

// âŒ ä¸æ¨èï¼šå¤åˆ¶å¤§å¯¹è±¡
for _, item := range largeSlice {
    process(item)  // æ¯æ¬¡å¤åˆ¶1000ä¸ªint
}

// âœ… æ¨èï¼šä½¿ç”¨ç´¢å¼•
for i := range largeSlice {
    process(&largeSlice[i])  // ä½¿ç”¨æŒ‡é’ˆ
}
```

---

## ğŸ“š æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **æ§åˆ¶æµåˆ†ç±»**: é¡ºåºã€åˆ†æ”¯ã€å¾ªç¯ã€è·³è½¬ã€å¼‚å¸¸ã€å¹¶å‘
2. **ç‹¬ç‰¹ç‰¹æ€§**: deferã€panic/recoverã€select
3. **ç®€æ´è®¾è®¡**: ä¸€ç§å¾ªç¯ã€å¼ºåˆ¶å¤§æ‹¬å·ã€çŸ­å˜é‡å£°æ˜
4. **å®‰å…¨æœºåˆ¶**: ç±»å‹å®‰å…¨çš„switchã€å¯æ¢å¤çš„panic
5. **å¹¶å‘åŸè¯­**: selectå¤šè·¯å¤ç”¨

### å­¦ä¹ å»ºè®®

1. æŒæ¡æ¯ç§æ§åˆ¶ç»“æ„çš„è¯­ä¹‰
2. ç†è§£deferçš„æ‰§è¡Œæ—¶æœºå’Œå‚æ•°æ±‚å€¼
3. æ­£ç¡®ä½¿ç”¨panic/recover
4. ç†Ÿç»ƒè¿ç”¨selectè¿›è¡Œå¹¶å‘æ§åˆ¶
5. éµå¾ªæœ€ä½³å®è·µï¼Œå†™å‡ºç®€æ´é«˜æ•ˆçš„ä»£ç 

---

**ç›¸å…³æ–‡æ¡£**:
- [ç±»å‹ç³»ç»Ÿå®Œæ•´è§£æ](./01-Go-1.25.3ç±»å‹ç³»ç»Ÿå®Œæ•´è§£æ.md)
- [å¹¶å‘æœºåˆ¶å®Œæ•´è®ºè¯](./03-Go-1.25.3å¹¶å‘æœºåˆ¶å®Œæ•´è®ºè¯.md)
- [CSPæ¨¡å‹ä¸‰ç»´åˆ†æ](./04-CSPæ¨¡å‹ä¸‰ç»´å®Œæ•´åˆ†æ-2025.md)

---

**æ›´æ–°æ—¥æœŸ**: 2025-10-28  
**ç‰ˆæœ¬**: v1.0  
**å­—æ•°**: 12,000+

