# Go 1.23 è¯­è¨€å½¢å¼åŒ–åˆ†æ - æ€ç»´å¯¼å›¾ä¸çŸ¥è¯†çŸ©é˜µ

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**åˆ›å»ºæ—¥æœŸ**: 2025å¹´10æœˆ24æ—¥  
**Goç‰ˆæœ¬**: Go 1.23  
**ç†è®ºåŸºç¡€**: å½¢å¼è¯­è¨€ç†è®º + æ“ä½œè¯­ä¹‰ + ç±»å‹ç†è®º + CSPå¹¶å‘æ¨¡å‹  
**æ–‡æ¡£ç±»å‹**: å¯è§†åŒ–åˆ†æ + çŸ¥è¯†ä½“ç³» + å±æ€§å…³ç³»

---

## ğŸ“‹ ç›®å½•

- [1. Goè¯­è¨€ä½“ç³»æ€ç»´å¯¼å›¾](#1-goè¯­è¨€ä½“ç³»æ€ç»´å¯¼å›¾)
  - [1.1 é¡¶å±‚æ¶æ„æ€ç»´å¯¼å›¾](#11-é¡¶å±‚æ¶æ„æ€ç»´å¯¼å›¾)
  - [1.2 è¯­æ³•ç»“æ„è¯¦ç»†æ€ç»´å¯¼å›¾](#12-è¯­æ³•ç»“æ„è¯¦ç»†æ€ç»´å¯¼å›¾)
- [2. è¯­æ³•è¯­ä¹‰çŸ¥è¯†çŸ©é˜µ](#2-è¯­æ³•è¯­ä¹‰çŸ¥è¯†çŸ©é˜µ)
  - [2.1 è¯­æ³•-è¯­ä¹‰æ˜ å°„çŸ©é˜µ](#21-è¯­æ³•-è¯­ä¹‰æ˜ å°„çŸ©é˜µ)
  - [2.2 ç±»å‹-æ“ä½œçŸ©é˜µ](#22-ç±»å‹-æ“ä½œçŸ©é˜µ)
  - [2.3 å¹¶å‘åŸè¯­è¯­ä¹‰çŸ©é˜µ](#23-å¹¶å‘åŸè¯­è¯­ä¹‰çŸ©é˜µ)
- [3. ç±»å‹ç³»ç»Ÿå±‚æ¬¡ç»“æ„](#3-ç±»å‹ç³»ç»Ÿå±‚æ¬¡ç»“æ„)
  - [3.1 ç±»å‹å±‚æ¬¡æ ‘](#31-ç±»å‹å±‚æ¬¡æ ‘)
  - [3.2 å­ç±»å‹å…³ç³»å›¾](#32-å­ç±»å‹å…³ç³»å›¾)
  - [3.3 ç±»å‹åˆ¤æ–­è§„åˆ™æ ‘](#33-ç±»å‹åˆ¤æ–­è§„åˆ™æ ‘)
- [4. å±æ€§å…³ç³»åˆ†æ](#4-å±æ€§å…³ç³»åˆ†æ)
  - [4.1 ç±»å‹å±æ€§å…³ç³»å›¾](#41-ç±»å‹å±æ€§å…³ç³»å›¾)
  - [4.2 å¹¶å‘å®‰å…¨å±æ€§çŸ©é˜µ](#42-å¹¶å‘å®‰å…¨å±æ€§çŸ©é˜µ)
  - [4.3 å†…å­˜è¯­ä¹‰å…³ç³»å›¾](#43-å†…å­˜è¯­ä¹‰å…³ç³»å›¾)
  - [4.4 ç±»å‹è½¬æ¢å…³ç³»å›¾](#44-ç±»å‹è½¬æ¢å…³ç³»å›¾)
- [5. å¹¶å‘æ¨¡å‹å½¢å¼åŒ–](#5-å¹¶å‘æ¨¡å‹å½¢å¼åŒ–)
  - [5.1 CSPè¿›ç¨‹ä»£æ•°](#51-cspè¿›ç¨‹ä»£æ•°)
  - [5.2 Goroutineç”Ÿå‘½å‘¨æœŸçŠ¶æ€æœº](#52-goroutineç”Ÿå‘½å‘¨æœŸçŠ¶æ€æœº)
  - [5.3 ChannelåŒæ­¥è¯­ä¹‰](#53-channelåŒæ­¥è¯­ä¹‰)
  - [5.4 Selectè¯­å¥è¯­ä¹‰](#54-selectè¯­å¥è¯­ä¹‰)
- [6. å†…å­˜æ¨¡å‹å½¢å¼åŒ–](#6-å†…å­˜æ¨¡å‹å½¢å¼åŒ–)
  - [6.1 å†…å­˜æ“ä½œåˆ†ç±»](#61-å†…å­˜æ“ä½œåˆ†ç±»)
  - [6.2 Happens-Beforeè§„åˆ™](#62-happens-beforeè§„åˆ™)
  - [6.3 æ•°æ®ç«äº‰å½¢å¼åŒ–å®šä¹‰](#63-æ•°æ®ç«äº‰å½¢å¼åŒ–å®šä¹‰)
  - [6.4 å†…å­˜ä¸€è‡´æ€§æ¨¡å‹](#64-å†…å­˜ä¸€è‡´æ€§æ¨¡å‹)
  - [6.5 GCä¸å†…å­˜ç®¡ç†](#65-gcä¸å†…å­˜ç®¡ç†)
  - [6.6 é€ƒé€¸åˆ†æå½¢å¼åŒ–](#66-é€ƒé€¸åˆ†æå½¢å¼åŒ–)
- [7. å½¢å¼åŒ–è¯æ˜ç¤ºä¾‹](#7-å½¢å¼åŒ–è¯æ˜ç¤ºä¾‹)
  - [7.1 ç±»å‹å®‰å…¨æ€§è¯æ˜](#71-ç±»å‹å®‰å…¨æ€§è¯æ˜)
    - [7.1.1 Progresså®šç†](#711-progresså®šç†)
    - [7.1.2 Preservationå®šç†](#712-preservationå®šç†)
    - [7.1.3 ç±»å‹å®‰å…¨å®šç†](#713-ç±»å‹å®‰å…¨å®šç†)
  - [7.2 CSPå¹¶å‘æ­£ç¡®æ€§è¯æ˜ç¤ºä¾‹](#72-cspå¹¶å‘æ­£ç¡®æ€§è¯æ˜ç¤ºä¾‹)
    - [7.2.1 æ— æ­»é”è¯æ˜](#721-æ— æ­»é”è¯æ˜)
    - [7.2.2 æ•°æ®ç«äº‰è‡ªç”±æ€§è¯æ˜](#722-æ•°æ®ç«äº‰è‡ªç”±æ€§è¯æ˜)
  - [7.3 æ³›å‹ç±»å‹å®‰å…¨æ€§è¯æ˜](#73-æ³›å‹ç±»å‹å®‰å…¨æ€§è¯æ˜)
- [8. çŸ¥è¯†çŸ©é˜µæ€»è§ˆ](#8-çŸ¥è¯†çŸ©é˜µæ€»è§ˆ)
  - [8.1 å®Œæ•´ç‰¹æ€§çŸ©é˜µ](#81-å®Œæ•´ç‰¹æ€§çŸ©é˜µ)
  - [8.2 è¯­ä¹‰ä¸€è‡´æ€§çŸ©é˜µ](#82-è¯­ä¹‰ä¸€è‡´æ€§çŸ©é˜µ)
- [9. æ€»ç»“ä¸å±•æœ›](#9-æ€»ç»“ä¸å±•æœ›)
  - [9.1 Goè¯­è¨€å½¢å¼åŒ–ä½“ç³»æ€»ç»“](#91-goè¯­è¨€å½¢å¼åŒ–ä½“ç³»æ€»ç»“)
  - [9.2 å½¢å¼åŒ–æ–¹æ³•çš„ä»·å€¼](#92-å½¢å¼åŒ–æ–¹æ³•çš„ä»·å€¼)
  - [9.3 æœªæ¥å·¥ä½œæ–¹å‘](#93-æœªæ¥å·¥ä½œæ–¹å‘)
- [10. å‚è€ƒèµ„æº](#10-å‚è€ƒèµ„æº)
  - [10.1 Goè¯­è¨€è§„èŒƒ](#101-goè¯­è¨€è§„èŒƒ)
  - [10.2 å½¢å¼åŒ–ç†è®º](#102-å½¢å¼åŒ–ç†è®º)
  - [10.3 ç›¸å…³å·¥å…·](#103-ç›¸å…³å·¥å…·)

## 1. Goè¯­è¨€ä½“ç³»æ€ç»´å¯¼å›¾

### 1.1 é¡¶å±‚æ¶æ„æ€ç»´å¯¼å›¾

```
Go 1.23 è¯­è¨€å½¢å¼åŒ–ä½“ç³»
â”œâ”€â”€ è¯­æ³•å±‚ (Syntax Layer)
â”‚   â”œâ”€â”€ è¯æ³•å…ƒç´  (Lexical Elements)
â”‚   â”‚   â”œâ”€â”€ æ ‡è¯†ç¬¦ (Identifiers)
â”‚   â”‚   â”œâ”€â”€ å…³é”®å­— (Keywords): 25ä¸ª
â”‚   â”‚   â”œâ”€â”€ è¿ç®—ç¬¦ (Operators): 47ä¸ª
â”‚   â”‚   â”œâ”€â”€ å­—é¢é‡ (Literals)
â”‚   â”‚   â”‚   â”œâ”€â”€ æ•´æ•°å­—é¢é‡ (Integer)
â”‚   â”‚   â”‚   â”œâ”€â”€ æµ®ç‚¹å­—é¢é‡ (Float)
â”‚   â”‚   â”‚   â”œâ”€â”€ å­—ç¬¦ä¸²å­—é¢é‡ (String)
â”‚   â”‚   â”‚   â”œâ”€â”€ ç¬¦æ–‡å­—é¢é‡ (Rune)
â”‚   â”‚   â”‚   â””â”€â”€ å¸ƒå°”å­—é¢é‡ (Boolean)
â”‚   â”‚   â””â”€â”€ åˆ†éš”ç¬¦ (Delimiters)
â”‚   â”‚
â”‚   â”œâ”€â”€ ç±»å‹ç³»ç»Ÿ (Type System)
â”‚   â”‚   â”œâ”€â”€ åŸºæœ¬ç±»å‹ (Basic Types)
â”‚   â”‚   â”‚   â”œâ”€â”€ bool
â”‚   â”‚   â”‚   â”œâ”€â”€ æ•°å€¼ç±»å‹ (Numeric): int, int8, int16, int32, int64, uint, uint8, ...
â”‚   â”‚   â”‚   â”œâ”€â”€ string
â”‚   â”‚   â”‚   â””â”€â”€ byte, rune
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ å¤åˆç±»å‹ (Composite Types)
â”‚   â”‚   â”‚   â”œâ”€â”€ æ•°ç»„ (Array): [n]T
â”‚   â”‚   â”‚   â”œâ”€â”€ åˆ‡ç‰‡ (Slice): []T
â”‚   â”‚   â”‚   â”œâ”€â”€ æ˜ å°„ (Map): map[K]V
â”‚   â”‚   â”‚   â”œâ”€â”€ ç»“æ„ä½“ (Struct): struct{...}
â”‚   â”‚   â”‚   â”œâ”€â”€ æŒ‡é’ˆ (Pointer): *T
â”‚   â”‚   â”‚   â””â”€â”€ å‡½æ•° (Function): func(...) ...
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ æ¥å£ç±»å‹ (Interface Types)
â”‚   â”‚   â”‚   â”œâ”€â”€ åŸºæœ¬æ¥å£ (Basic Interface)
â”‚   â”‚   â”‚   â”œâ”€â”€ åµŒå…¥æ¥å£ (Embedded Interface)
â”‚   â”‚   â”‚   â””â”€â”€ ç±»å‹çº¦æŸ (Type Constraints, Go 1.18+)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ é€šé“ç±»å‹ (Channel Types)
â”‚   â”‚   â”‚   â”œâ”€â”€ åŒå‘é€šé“ (chan T)
â”‚   â”‚   â”‚   â”œâ”€â”€ åªå‘é€é€šé“ (chan<- T)
â”‚   â”‚   â”‚   â””â”€â”€ åªæ¥æ”¶é€šé“ (<-chan T)
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ æ³›å‹ç±»å‹ (Generic Types, Go 1.18+)
â”‚   â”‚       â”œâ”€â”€ ç±»å‹å‚æ•° (Type Parameters): [T any]
â”‚   â”‚       â”œâ”€â”€ ç±»å‹çº¦æŸ (Type Constraints)
â”‚   â”‚       â””â”€â”€ ç±»å‹å®ä¾‹åŒ– (Type Instantiation)
â”‚   â”‚
â”‚   â”œâ”€â”€ è¡¨è¾¾å¼ (Expressions)
â”‚   â”‚   â”œâ”€â”€ å­—é¢é‡è¡¨è¾¾å¼ (Literal Expressions)
â”‚   â”‚   â”œâ”€â”€ æ ‡è¯†ç¬¦è¡¨è¾¾å¼ (Identifier Expressions)
â”‚   â”‚   â”œâ”€â”€ å¤åˆè¡¨è¾¾å¼ (Composite Expressions)
â”‚   â”‚   â”œâ”€â”€ å‡½æ•°è°ƒç”¨ (Function Calls)
â”‚   â”‚   â”œâ”€â”€ æ–¹æ³•è°ƒç”¨ (Method Calls)
â”‚   â”‚   â”œâ”€â”€ ç´¢å¼•è¡¨è¾¾å¼ (Index Expressions)
â”‚   â”‚   â”œâ”€â”€ åˆ‡ç‰‡è¡¨è¾¾å¼ (Slice Expressions)
â”‚   â”‚   â”œâ”€â”€ ç±»å‹æ–­è¨€ (Type Assertions)
â”‚   â”‚   â”œâ”€â”€ ç±»å‹è½¬æ¢ (Type Conversions)
â”‚   â”‚   â”œâ”€â”€ ä¸€å…ƒè¿ç®— (Unary Operations)
â”‚   â”‚   â””â”€â”€ äºŒå…ƒè¿ç®— (Binary Operations)
â”‚   â”‚
â”‚   â”œâ”€â”€ è¯­å¥ (Statements)
â”‚   â”‚   â”œâ”€â”€ å£°æ˜è¯­å¥ (Declaration Statements)
â”‚   â”‚   â”œâ”€â”€ èµ‹å€¼è¯­å¥ (Assignment Statements)
â”‚   â”‚   â”œâ”€â”€ æ¡ä»¶è¯­å¥ (Conditional Statements): if, switch
â”‚   â”‚   â”œâ”€â”€ å¾ªç¯è¯­å¥ (Loop Statements): for
â”‚   â”‚   â”œâ”€â”€ è·³è½¬è¯­å¥ (Jump Statements): break, continue, goto, return
â”‚   â”‚   â”œâ”€â”€ å¹¶å‘è¯­å¥ (Concurrency Statements): go, select
â”‚   â”‚   â””â”€â”€ æ§åˆ¶æµè¯­å¥ (Control Flow): defer, panic, recover
â”‚   â”‚
â”‚   â””â”€â”€ å£°æ˜ (Declarations)
â”‚       â”œâ”€â”€ å¸¸é‡å£°æ˜ (Const Declarations)
â”‚       â”œâ”€â”€ ç±»å‹å£°æ˜ (Type Declarations)
â”‚       â”œâ”€â”€ å˜é‡å£°æ˜ (Var Declarations)
â”‚       â””â”€â”€ å‡½æ•°å£°æ˜ (Function Declarations)
â”‚
â”œâ”€â”€ è¯­ä¹‰å±‚ (Semantics Layer)
â”‚   â”œâ”€â”€ æ“ä½œè¯­ä¹‰ (Operational Semantics)
â”‚   â”‚   â”œâ”€â”€ å°æ­¥è¯­ä¹‰ (Small-Step Semantics)
â”‚   â”‚   â”‚   â””â”€â”€ é…ç½®è½¬æ¢: âŸ¨e, ÏƒâŸ© â†’ âŸ¨e', Ïƒ'âŸ©
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ å¤§æ­¥è¯­ä¹‰ (Big-Step Semantics)
â”‚   â”‚   â”‚   â””â”€â”€ æ±‚å€¼å…³ç³»: e â‡“ v
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ ç­‰ä»·æ€§è¯æ˜
â”‚   â”‚       â””â”€â”€ Small-Step â‰¡ Big-Step
â”‚   â”‚
â”‚   â”œâ”€â”€ æŒ‡ç§°è¯­ä¹‰ (Denotational Semantics)
â”‚   â”‚   â”œâ”€â”€ è¯­ä¹‰åŸŸ (Semantic Domains)
â”‚   â”‚   â”‚   â”œâ”€â”€ å€¼åŸŸ (Value Domain): V
â”‚   â”‚   â”‚   â”œâ”€â”€ ç¯å¢ƒåŸŸ (Environment Domain): Env = Var â†’ V
â”‚   â”‚   â”‚   â”œâ”€â”€ å­˜å‚¨åŸŸ (Store Domain): Store = Loc â†’ V
â”‚   â”‚   â”‚   â””â”€â”€ å‡½æ•°åŸŸ (Function Domain): V â†’ V
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ è¡¨è¾¾å¼è¯­ä¹‰å‡½æ•°
â”‚   â”‚   â”‚   â””â”€â”€ âŸ¦Â·âŸ§â‚‘ : Expr â†’ Env â†’ V
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ è¯­å¥è¯­ä¹‰å‡½æ•°
â”‚   â”‚       â””â”€â”€ âŸ¦Â·âŸ§â‚› : Stmt â†’ Env â†’ Env
â”‚   â”‚
â”‚   â”œâ”€â”€ å…¬ç†è¯­ä¹‰ (Axiomatic Semantics)
â”‚   â”‚   â”œâ”€â”€ Hoareé€»è¾‘
â”‚   â”‚   â”‚   â””â”€â”€ {P} S {Q}
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ å¼±åŒ–è§„åˆ™ (Weakening)
â”‚   â”‚   â”œâ”€â”€ é¡ºåºè§„åˆ™ (Sequencing)
â”‚   â”‚   â”œâ”€â”€ æ¡ä»¶è§„åˆ™ (Conditional)
â”‚   â”‚   â””â”€â”€ å¾ªç¯ä¸å˜å¼ (Loop Invariant)
â”‚   â”‚
â”‚   â””â”€â”€ å¹¶å‘è¯­ä¹‰ (Concurrent Semantics)
â”‚       â”œâ”€â”€ CSPè¿›ç¨‹ä»£æ•°
â”‚       â”‚   â”œâ”€â”€ é¡ºåº: P ; Q
â”‚       â”‚   â”œâ”€â”€ é€‰æ‹©: P â–¡ Q
â”‚       â”‚   â”œâ”€â”€ å¹¶è¡Œ: P ||| Q
â”‚       â”‚   â””â”€â”€ åŒæ­¥: P || Q
â”‚       â”‚
â”‚       â””â”€â”€ Happens-Beforeå…³ç³»
â”‚           â””â”€â”€ HB âŠ† Event Ã— Event
â”‚
â”œâ”€â”€ ç±»å‹å±‚ (Type Layer)
â”‚   â”œâ”€â”€ ç±»å‹åˆ¤æ–­ (Type Judgment)
â”‚   â”‚   â””â”€â”€ Î“ âŠ¢ e : T
â”‚   â”‚
â”‚   â”œâ”€â”€ ç±»å‹æ¨å¯¼ (Type Inference)
â”‚   â”‚   â”œâ”€â”€ ç»Ÿä¸€ç®—æ³• (Unification)
â”‚   â”‚   â””â”€â”€ çº¦æŸæ±‚è§£ (Constraint Solving)
â”‚   â”‚
â”‚   â”œâ”€â”€ å­ç±»å‹å…³ç³» (Subtyping)
â”‚   â”‚   â””â”€â”€ Tâ‚ <: Tâ‚‚
â”‚   â”‚
â”‚   â”œâ”€â”€ ç±»å‹å®‰å…¨æ€§ (Type Safety)
â”‚   â”‚   â”œâ”€â”€ è¿›å±•å®šç† (Progress)
â”‚   â”‚   â”‚   â””â”€â”€ âŠ¢ e : T â‡’ (e is value âˆ¨ âˆƒe'. e â†’ e')
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ ä¿æŒå®šç† (Preservation)
â”‚   â”‚       â””â”€â”€ âŠ¢ e : T âˆ§ e â†’ e' â‡’ âŠ¢ e' : T
â”‚   â”‚
â”‚   â””â”€â”€ æ³›å‹ç³»ç»Ÿ (Generic System)
â”‚       â”œâ”€â”€ ç±»å‹å‚æ•°åŒ– (Type Parameterization)
â”‚       â”œâ”€â”€ çº¦æŸæ¨å¯¼ (Constraint Inference)
â”‚       â””â”€â”€ å®ä¾‹åŒ–éªŒè¯ (Instantiation Verification)
â”‚
â”œâ”€â”€ å¹¶å‘å±‚ (Concurrency Layer)
â”‚   â”œâ”€â”€ Goroutineæ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ åˆ›å»ºè¯­ä¹‰: go f() â‰¡ f() ||| P
â”‚   â”‚   â”œâ”€â”€ è°ƒåº¦æ¨¡å‹: GMP
â”‚   â”‚   â””â”€â”€ ç”Ÿå‘½å‘¨æœŸç®¡ç†
â”‚   â”‚
â”‚   â”œâ”€â”€ Channelæ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ å‘é€è¯­ä¹‰: ch <- v
â”‚   â”‚   â”œâ”€â”€ æ¥æ”¶è¯­ä¹‰: v := <-ch
â”‚   â”‚   â”œâ”€â”€ ç¼“å†²è¯­ä¹‰: make(chan T, n)
â”‚   â”‚   â””â”€â”€ å…³é—­è¯­ä¹‰: close(ch)
â”‚   â”‚
â”‚   â”œâ”€â”€ Selectè¯­å¥
â”‚   â”‚   â”œâ”€â”€ éç¡®å®šæ€§é€‰æ‹©
â”‚   â”‚   â”œâ”€â”€ é»˜è®¤åˆ†æ”¯
â”‚   â”‚   â””â”€â”€ å…¬å¹³æ€§ä¿è¯
â”‚   â”‚
â”‚   â””â”€â”€ åŒæ­¥åŸè¯­
â”‚       â”œâ”€â”€ Mutex
â”‚       â”œâ”€â”€ RWMutex
â”‚       â”œâ”€â”€ WaitGroup
â”‚       â””â”€â”€ Cond
â”‚
â”œâ”€â”€ å†…å­˜å±‚ (Memory Layer)
â”‚   â”œâ”€â”€ å†…å­˜æ¨¡å‹ (Memory Model)
â”‚   â”‚   â”œâ”€â”€ Sequential Consistency
â”‚   â”‚   â”œâ”€â”€ Happens-Beforeè§„åˆ™
â”‚   â”‚   â””â”€â”€ æ•°æ®ç«äº‰æ£€æµ‹
â”‚   â”‚
â”‚   â”œâ”€â”€ åƒåœ¾å›æ”¶ (GC)
â”‚   â”‚   â”œâ”€â”€ ä¸‰è‰²æ ‡è®°ç®—æ³•
â”‚   â”‚   â”œâ”€â”€ å¹¶å‘æ¸…æ‰«
â”‚   â”‚   â””â”€â”€ å†™å±éšœ
â”‚   â”‚
â”‚   â””â”€â”€ é€ƒé€¸åˆ†æ (Escape Analysis)
â”‚       â”œâ”€â”€ æ ˆåˆ†é… vs å †åˆ†é…
â”‚       â””â”€â”€ ä¼˜åŒ–å†³ç­–
â”‚
â””â”€â”€ è¿è¡Œæ—¶å±‚ (Runtime Layer)
    â”œâ”€â”€ GMPè°ƒåº¦å™¨
    â”‚   â”œâ”€â”€ G (Goroutine)
    â”‚   â”œâ”€â”€ M (Machine/OS Thread)
    â”‚   â””â”€â”€ P (Processor/Logical CPU)
    â”‚
    â”œâ”€â”€ ç³»ç»Ÿè°ƒç”¨
    â”‚   â”œâ”€â”€ é˜»å¡è°ƒç”¨å¤„ç†
    â”‚   â””â”€â”€ éé˜»å¡è°ƒç”¨å¤„ç†
    â”‚
    â””â”€â”€ æ€§èƒ½ç›‘æ§
        â”œâ”€â”€ Profiling
        â””â”€â”€ Tracing
```

### 1.2 è¯­æ³•ç»“æ„è¯¦ç»†æ€ç»´å¯¼å›¾

```
Goè¯­æ³•ç»“æ„ (EBNFå½¢å¼åŒ–)
â”œâ”€â”€ Program ::= PackageClause ImportDecls TopLevelDecls
â”‚
â”œâ”€â”€ PackageClause ::= "package" Identifier
â”‚
â”œâ”€â”€ ImportDecls ::= ImportDecl*
â”‚   â””â”€â”€ ImportDecl ::= "import" (ImportSpec | "(" ImportSpec* ")")
â”‚       â””â”€â”€ ImportSpec ::= (Identifier | ".")? ImportPath
â”‚
â”œâ”€â”€ TopLevelDecls ::= TopLevelDecl*
â”‚   â”œâ”€â”€ FuncDecl ::= "func" Identifier [TypeParams] Signature Block
â”‚   â”œâ”€â”€ TypeDecl ::= "type" (TypeSpec | "(" TypeSpec* ")")
â”‚   â”‚   â””â”€â”€ TypeSpec ::= Identifier [TypeParams] Type
â”‚   â”œâ”€â”€ VarDecl ::= "var" (VarSpec | "(" VarSpec* ")")
â”‚   â””â”€â”€ ConstDecl ::= "const" (ConstSpec | "(" ConstSpec* ")")
â”‚
â”œâ”€â”€ Type ::=
â”‚   â”œâ”€â”€ BasicType ::= "bool" | "int" | "float64" | "string" | ...
â”‚   â”œâ”€â”€ ArrayType ::= "[" Expression "]" Type
â”‚   â”œâ”€â”€ SliceType ::= "[" "]" Type
â”‚   â”œâ”€â”€ MapType ::= "map" "[" Type "]" Type
â”‚   â”œâ”€â”€ StructType ::= "struct" "{" FieldDecl* "}"
â”‚   â”œâ”€â”€ PointerType ::= "*" Type
â”‚   â”œâ”€â”€ FunctionType ::= "func" Signature
â”‚   â”œâ”€â”€ InterfaceType ::= "interface" "{" (MethodSpec | TypeElement)* "}"
â”‚   â”œâ”€â”€ ChannelType ::= ("chan" | "chan" "<-" | "<-" "chan") Type
â”‚   â””â”€â”€ GenericType ::= Identifier "[" TypeArgs "]"
â”‚
â”œâ”€â”€ Expression ::=
â”‚   â”œâ”€â”€ Literal ::= IntLit | FloatLit | StringLit | RuneLit | BoolLit
â”‚   â”œâ”€â”€ Identifier
â”‚   â”œâ”€â”€ CompositeLit ::= Type "{" ElementList? "}"
â”‚   â”œâ”€â”€ FunctionLit ::= "func" Signature Block
â”‚   â”œâ”€â”€ PrimaryExpr ::=
â”‚   â”‚   â”œâ”€â”€ Operand
â”‚   â”‚   â”œâ”€â”€ PrimaryExpr Selector
â”‚   â”‚   â”œâ”€â”€ PrimaryExpr Index
â”‚   â”‚   â”œâ”€â”€ PrimaryExpr Slice
â”‚   â”‚   â”œâ”€â”€ PrimaryExpr TypeAssertion
â”‚   â”‚   â”œâ”€â”€ PrimaryExpr Arguments
â”‚   â”‚   â””â”€â”€ PrimaryExpr "(" Type ")"
â”‚   â”œâ”€â”€ UnaryExpr ::= UnaryOp Expression
â”‚   â”‚   â””â”€â”€ UnaryOp ::= "+" | "-" | "!" | "^" | "*" | "&" | "<-"
â”‚   â””â”€â”€ BinaryExpr ::= Expression BinaryOp Expression
â”‚       â””â”€â”€ BinaryOp ::= "||" | "&&" | "==" | "!=" | "<" | "<=" | ">" | ">=" |
â”‚                        "+" | "-" | "|" | "^" | "*" | "/" | "%" | "<<" | ">>" | "&" | "&^"
â”‚
â””â”€â”€ Statement ::=
    â”œâ”€â”€ DeclarationStmt ::= VarDecl | TypeDecl | ConstDecl
    â”œâ”€â”€ SimpleStmt ::=
    â”‚   â”œâ”€â”€ EmptyStmt
    â”‚   â”œâ”€â”€ ExpressionStmt
    â”‚   â”œâ”€â”€ SendStmt ::= Channel "<-" Expression
    â”‚   â”œâ”€â”€ IncDecStmt ::= Expression ("++" | "--")
    â”‚   â”œâ”€â”€ Assignment ::= ExpressionList AssignOp ExpressionList
    â”‚   â””â”€â”€ ShortVarDecl ::= IdentifierList ":=" ExpressionList
    â”œâ”€â”€ CompoundStmt ::=
    â”‚   â”œâ”€â”€ IfStmt ::= "if" [SimpleStmt ";"] Expression Block ["else" (IfStmt | Block)]
    â”‚   â”œâ”€â”€ SwitchStmt ::=
    â”‚   â”‚   â”œâ”€â”€ ExprSwitchStmt ::= "switch" [SimpleStmt ";"] [Expression] "{" ExprCaseClause* "}"
    â”‚   â”‚   â””â”€â”€ TypeSwitchStmt ::= "switch" [SimpleStmt ";"] TypeSwitchGuard "{" TypeCaseClause* "}"
    â”‚   â”œâ”€â”€ ForStmt ::=
    â”‚   â”‚   â”œâ”€â”€ "for" [Condition | ForClause | RangeClause] Block
    â”‚   â”‚   â”œâ”€â”€ ForClause ::= [InitStmt] ";" [Condition] ";" [PostStmt]
    â”‚   â”‚   â””â”€â”€ RangeClause ::= [ExpressionList "=" | IdentifierList ":="] "range" Expression
    â”‚   â””â”€â”€ SelectStmt ::= "select" "{" CommClause* "}"
    â”œâ”€â”€ JumpStmt ::=
    â”‚   â”œâ”€â”€ BreakStmt ::= "break" [Label]
    â”‚   â”œâ”€â”€ ContinueStmt ::= "continue" [Label]
    â”‚   â”œâ”€â”€ GotoStmt ::= "goto" Label
    â”‚   â”œâ”€â”€ ReturnStmt ::= "return" [ExpressionList]
    â”‚   â””â”€â”€ FallthroughStmt ::= "fallthrough"
    â”œâ”€â”€ DeferStmt ::= "defer" Expression
    â”œâ”€â”€ GoStmt ::= "go" Expression
    â””â”€â”€ LabeledStmt ::= Label ":" Statement
```

---

## 2. è¯­æ³•è¯­ä¹‰çŸ¥è¯†çŸ©é˜µ

### 2.1 è¯­æ³•-è¯­ä¹‰æ˜ å°„çŸ©é˜µ

| è¯­æ³•æ„é€  | æŠ½è±¡è¯­æ³• | å°æ­¥è¯­ä¹‰ | å¤§æ­¥è¯­ä¹‰ | æŒ‡ç§°è¯­ä¹‰ | ç±»å‹è§„åˆ™ |
|---------|---------|---------|---------|---------|---------|
| **å­—é¢é‡** | | | | | |
| æ•´æ•°å­—é¢é‡ `42` | `IntLit(42)` | `âŸ¨42, ÏƒâŸ© â†’ Ïƒ` | `42 â‡“ 42` | `âŸ¦42âŸ§ = 42` | `âŠ¢ 42 : int` |
| å­—ç¬¦ä¸²å­—é¢é‡ `"hello"` | `StrLit("hello")` | `âŸ¨"hello", ÏƒâŸ© â†’ Ïƒ` | `"hello" â‡“ "hello"` | `âŸ¦"hello"âŸ§ = "hello"` | `âŠ¢ "hello" : string` |
| å¸ƒå°”å­—é¢é‡ `true` | `BoolLit(true)` | `âŸ¨true, ÏƒâŸ© â†’ Ïƒ` | `true â‡“ true` | `âŸ¦trueâŸ§ = true` | `âŠ¢ true : bool` |
| **å˜é‡** | | | | | |
| æ ‡è¯†ç¬¦ `x` | `Ident("x")` | `âŸ¨x, ÏƒâŸ© â†’ âŸ¨Ïƒ(x), ÏƒâŸ©` | `x â‡“ Ïƒ(x)` | `âŸ¦xâŸ§Ïƒ = Ïƒ(x)` | `Î“(x) = T â‡’ Î“ âŠ¢ x : T` |
| **è¿ç®—** | | | | | |
| åŠ æ³• `x + y` | `Add(x, y)` | `âŸ¨x+y, ÏƒâŸ© â†’ âŸ¨vâ‚+vâ‚‚, ÏƒâŸ©`<br>å…¶ä¸­ `x â‡“ vâ‚, y â‡“ vâ‚‚` | `x â‡“ vâ‚, y â‡“ vâ‚‚`<br>`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`<br>`x+y â‡“ vâ‚+vâ‚‚` | `âŸ¦x+yâŸ§Ïƒ = âŸ¦xâŸ§Ïƒ + âŸ¦yâŸ§Ïƒ` | `Î“ âŠ¢ x : int, Î“ âŠ¢ y : int`<br>`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`<br>`Î“ âŠ¢ x+y : int` |
| å‡æ³• `x - y` | `Sub(x, y)` | `âŸ¨x-y, ÏƒâŸ© â†’ âŸ¨vâ‚-vâ‚‚, ÏƒâŸ©` | `x â‡“ vâ‚, y â‡“ vâ‚‚`<br>`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`<br>`x-y â‡“ vâ‚-vâ‚‚` | `âŸ¦x-yâŸ§Ïƒ = âŸ¦xâŸ§Ïƒ - âŸ¦yâŸ§Ïƒ` | `Î“ âŠ¢ x : T, Î“ âŠ¢ y : T`<br>`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`<br>`Î“ âŠ¢ x-y : T` |
| é€»è¾‘ä¸ `x && y` | `And(x, y)` | `âŸ¨x&&y, ÏƒâŸ© â†’ âŸ¨x', Ïƒ'âŸ©`<br>ï¼ˆçŸ­è·¯æ±‚å€¼ï¼‰| `x â‡“ false`<br>`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`<br>`x&&y â‡“ false`<br><br>`x â‡“ true, y â‡“ v`<br>`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`<br>`x&&y â‡“ v` | `âŸ¦x&&yâŸ§Ïƒ = âŸ¦xâŸ§Ïƒ âˆ§ âŸ¦yâŸ§Ïƒ` | `Î“ âŠ¢ x : bool, Î“ âŠ¢ y : bool`<br>`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`<br>`Î“ âŠ¢ x&&y : bool` |
| **èµ‹å€¼** | | | | | |
| èµ‹å€¼ `x = e` | `Assign(x, e)` | `âŸ¨x=e, ÏƒâŸ© â†’ âŸ¨skip, Ïƒ[xâ†¦v]âŸ©`<br>å…¶ä¸­ `e â‡“ v` | `e â‡“ v`<br>`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`<br>`x=e â‡“ Ïƒ[xâ†¦v]` | `âŸ¦x=eâŸ§Ïƒ = Ïƒ[x â†¦ âŸ¦eâŸ§Ïƒ]` | `Î“ âŠ¢ e : T, Î“(x) = T`<br>`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`<br>`Î“ âŠ¢ x=e : ()` |
| **æ§åˆ¶æµ** | | | | | |
| Ifè¯­å¥<br>`if b { sâ‚ } else { sâ‚‚ }` | `If(b, sâ‚, sâ‚‚)` | `âŸ¨if b sâ‚ else sâ‚‚, ÏƒâŸ© â†’`<br>`âŸ¨sâ‚, ÏƒâŸ©` if b=true<br>`âŸ¨sâ‚‚, ÏƒâŸ©` if b=false | `b â‡“ true, sâ‚ â‡“ Ïƒ'`<br>`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`<br>`if b sâ‚ else sâ‚‚ â‡“ Ïƒ'`<br><br>`b â‡“ false, sâ‚‚ â‡“ Ïƒ'`<br>`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`<br>`if b sâ‚ else sâ‚‚ â‡“ Ïƒ'` | `âŸ¦if b sâ‚ else sâ‚‚âŸ§Ïƒ =`<br>`if âŸ¦bâŸ§Ïƒ then âŸ¦sâ‚âŸ§Ïƒ`<br>`else âŸ¦sâ‚‚âŸ§Ïƒ` | `Î“ âŠ¢ b : bool,`<br>`Î“ âŠ¢ sâ‚ : (), Î“ âŠ¢ sâ‚‚ : ()`<br>`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`<br>`Î“ âŠ¢ if b sâ‚ else sâ‚‚ : ()` |
| Forå¾ªç¯<br>`for b { s }` | `For(b, s)` | `âŸ¨for b s, ÏƒâŸ© â†’`<br>`âŸ¨s; for b s, ÏƒâŸ©` if b=true<br>`âŸ¨skip, ÏƒâŸ©` if b=false | é€’å½’å®šä¹‰ | `âŸ¦for b sâŸ§ = fix(Î»f.Î»Ïƒ.`<br>`if âŸ¦bâŸ§Ïƒ then f(âŸ¦sâŸ§Ïƒ)`<br>`else Ïƒ)` | `Î“ âŠ¢ b : bool, Î“ âŠ¢ s : ()`<br>`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`<br>`Î“ âŠ¢ for b s : ()` |
| **å‡½æ•°** | | | | | |
| å‡½æ•°å®šä¹‰<br>`func f(x T) T { return e }` | `FuncDef(f, x, T, e)` | é—­åŒ…åˆ›å»º | é—­åŒ…åˆ›å»º | `âŸ¦func f(x T) T { return e }âŸ§Ïƒ =`<br>`âŸ¨Î»x.e, ÏƒâŸ©` | `Î“, x:T âŠ¢ e : T`<br>`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`<br>`Î“ âŠ¢ func f(x T) T {...} : Tâ†’T` |
| å‡½æ•°è°ƒç”¨<br>`f(a)` | `Call(f, a)` | `âŸ¨f(a), ÏƒâŸ© â†’ âŸ¨e[xâ†¦v], ÏƒâŸ©`<br>å…¶ä¸­ `f=Î»x.e, aâ‡“v` | `f â‡“ âŸ¨Î»x.e, Ïƒ'âŸ©, a â‡“ v, e[xâ†¦v] â‡“ v'`<br>`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`<br>`f(a) â‡“ v'` | `âŸ¦f(a)âŸ§Ïƒ = (âŸ¦fâŸ§Ïƒ)(âŸ¦aâŸ§Ïƒ)` | `Î“ âŠ¢ f : Tâ‚â†’Tâ‚‚, Î“ âŠ¢ a : Tâ‚`<br>`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`<br>`Î“ âŠ¢ f(a) : Tâ‚‚` |
| **å¹¶å‘** | | | | | |
| Goroutine<br>`go f()` | `Go(f())` | `âŸ¨go f(), ÏƒâŸ© â†’ âŸ¨skip, ÏƒâŸ©`<br>ï¼ˆå¹¶å‘æ‰§è¡Œf()ï¼‰| `go f() â‡“ spawn(f())` | CSP: `f() ||| P` | `Î“ âŠ¢ f() : ()`<br>`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`<br>`Î“ âŠ¢ go f() : ()` |
| Channelå‘é€<br>`ch <- v` | `Send(ch, v)` | `âŸ¨ch <- v, ÏƒâŸ© â†’`<br>`âŸ¨skip, ÏƒâŸ©`<br>ï¼ˆåŒæ­¥ï¼‰| é˜»å¡ç›´åˆ°æ¥æ”¶ | CSP: `ch!v â†’ P` | `Î“ âŠ¢ ch : chan T, Î“ âŠ¢ v : T`<br>`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`<br>`Î“ âŠ¢ ch <- v : ()` |
| Channelæ¥æ”¶<br>`v := <-ch` | `Recv(ch)` | `âŸ¨v := <-ch, ÏƒâŸ© â†’`<br>`âŸ¨skip, Ïƒ[vâ†¦val]âŸ©`<br>ï¼ˆåŒæ­¥ï¼‰| é˜»å¡ç›´åˆ°å‘é€ | CSP: `ch?v â†’ P` | `Î“ âŠ¢ ch : chan T`<br>`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`<br>`Î“ âŠ¢ v := <-ch : T` |

### 2.2 ç±»å‹-æ“ä½œçŸ©é˜µ

| ç±»å‹ | é›¶å€¼ | å¯æ¯”è¾ƒ | å¯èµ‹å€¼ | æ”¯æŒçš„æ“ä½œ | å†…å­˜å¸ƒå±€ |
|------|------|--------|--------|-----------|---------|
| `bool` | `false` | âœ… | âœ… | `&&, ||, !` | 1 byte |
| `int` | `0` | âœ… | âœ… | `+, -, *, /, %, <, >, ==, !=, ...` | 4/8 bytes (å¹³å°ç›¸å…³) |
| `int8` | `0` | âœ… | âœ… | åŒä¸Š | 1 byte |
| `int16` | `0` | âœ… | âœ… | åŒä¸Š | 2 bytes |
| `int32` | `0` | âœ… | âœ… | åŒä¸Š | 4 bytes |
| `int64` | `0` | âœ… | âœ… | åŒä¸Š | 8 bytes |
| `uint` | `0` | âœ… | âœ… | åŒä¸Š | 4/8 bytes |
| `float32` | `0.0` | âœ… | âœ… | `+, -, *, /, <, >, ==, !=` | 4 bytes |
| `float64` | `0.0` | âœ… | âœ… | åŒä¸Š | 8 bytes |
| `string` | `""` | âœ… | âœ… | `+, <, >, ==, !=, []` (ç´¢å¼•), `[:]` (åˆ‡ç‰‡) | 16 bytes (æŒ‡é’ˆ+é•¿åº¦) |
| `*T` | `nil` | âœ… | âœ… | `*` (è§£å¼•ç”¨), `&` (å–åœ°å€), `==, !=` | 8 bytes (æŒ‡é’ˆ) |
| `[]T` | `nil` | âŒ | âœ… | `[]` (ç´¢å¼•), `[:]` (åˆ‡ç‰‡), `len`, `cap`, `append` | 24 bytes (æŒ‡é’ˆ+é•¿åº¦+å®¹é‡) |
| `[n]T` | é›¶å€¼æ•°ç»„ | âœ…<br>(å…ƒç´ å¯æ¯”è¾ƒ) | âœ… | `[]` (ç´¢å¼•), `[:]` (åˆ‡ç‰‡), `len` | `n * sizeof(T)` |
| `map[K]V` | `nil` | âŒ | âœ… | `[]` (ç´¢å¼•), `delete`, `len` | 8 bytes (æŒ‡é’ˆ) |
| `struct{...}` | é›¶å€¼ç»“æ„ | âœ…<br>(æ‰€æœ‰å­—æ®µå¯æ¯”è¾ƒ) | âœ… | `.` (å­—æ®µè®¿é—®) | å­—æ®µæ€»å’Œï¼ˆè€ƒè™‘å¯¹é½ï¼‰ |
| `interface{}` | `nil` | âœ… | âœ… | ç±»å‹æ–­è¨€, ç±»å‹åˆ‡æ¢ | 16 bytes (ç±»å‹+æ•°æ®) |
| `func(...)` | `nil` | âœ…<br>(ä»…ä¸nilæ¯”è¾ƒ) | âœ… | `()` (è°ƒç”¨) | 8 bytes (æŒ‡é’ˆ) |
| `chan T` | `nil` | âœ… | âœ… | `<-` (å‘é€/æ¥æ”¶), `close`, `len`, `cap` | 8 bytes (æŒ‡é’ˆ) |

### 2.3 å¹¶å‘åŸè¯­è¯­ä¹‰çŸ©é˜µ

| åŸè¯­ | è¯­æ³• | CSPè¡¨ç¤º | è¯­ä¹‰ | é˜»å¡è¡Œä¸º | åŒæ­¥ä¿è¯ |
|------|------|---------|------|---------|---------|
| **Goroutine** | `go f()` | `f() ||| P` | å¹¶å‘æ‰§è¡Œf() | éé˜»å¡ | æ— åŒæ­¥ |
| **Channelå‘é€** | `ch <- v` | `ch!v â†’ P` | å‘é€šé“å‘é€å€¼ | é˜»å¡ï¼ˆæ— ç¼“å†²ï¼‰<br>æˆ–éé˜»å¡ï¼ˆæœ‰ç¼“å†²ï¼‰ | Happens-Before |
| **Channelæ¥æ”¶** | `v := <-ch` | `ch?v â†’ P` | ä»é€šé“æ¥æ”¶å€¼ | é˜»å¡ï¼ˆç›´åˆ°æ¥æ”¶ï¼‰ | Happens-Before |
| **Select** | `select { case ... }` | `(câ‚ â†’ Pâ‚) â–¡ (câ‚‚ â†’ Pâ‚‚)` | éç¡®å®šæ€§é€‰æ‹© | é˜»å¡ï¼ˆç›´åˆ°æŸä¸ªcaseå°±ç»ªï¼‰ | Happens-Before |
| **Mutex.Lock** | `mu.Lock()` | ä¸´ç•ŒåŒºè¿›å…¥ | è·å–äº’æ–¥é” | é˜»å¡ï¼ˆç›´åˆ°è·å–é”ï¼‰ | Happens-Before (unlock) |
| **Mutex.Unlock** | `mu.Unlock()` | ä¸´ç•ŒåŒºé€€å‡º | é‡Šæ”¾äº’æ–¥é” | éé˜»å¡ | Happens-Before (åç»­lock) |
| **WaitGroup.Add** | `wg.Add(n)` | è®¡æ•°å™¨å¢åŠ  | å¢åŠ ç­‰å¾…è®¡æ•° | éé˜»å¡ | æ— åŒæ­¥ |
| **WaitGroup.Done** | `wg.Done()` | è®¡æ•°å™¨å‡å°‘ | å‡å°‘ç­‰å¾…è®¡æ•° | éé˜»å¡ | Happens-Before (Wait) |
| **WaitGroup.Wait** | `wg.Wait()` | ç­‰å¾…å®Œæˆ | ç­‰å¾…è®¡æ•°å½’é›¶ | é˜»å¡ï¼ˆç›´åˆ°è®¡æ•°=0ï¼‰ | Happens-Before (åç»­æ“ä½œ) |
| **Once.Do** | `once.Do(f)` | å•æ¬¡æ‰§è¡Œ | ç¡®ä¿fä»…æ‰§è¡Œä¸€æ¬¡ | ç¬¬ä¸€æ¬¡è°ƒç”¨é˜»å¡<br>åç»­è°ƒç”¨éé˜»å¡ | Happens-Before (åç»­è°ƒç”¨) |

---

## 3. ç±»å‹ç³»ç»Ÿå±‚æ¬¡ç»“æ„

### 3.1 ç±»å‹å±‚æ¬¡æ ‘

```
Type
â”œâ”€â”€ åŸºæœ¬ç±»å‹ (Basic Types)
â”‚   â”œâ”€â”€ æ•°å€¼ç±»å‹ (Numeric Types)
â”‚   â”‚   â”œâ”€â”€ æ•´æ•°ç±»å‹ (Integer Types)
â”‚   â”‚   â”‚   â”œâ”€â”€ æœ‰ç¬¦å·æ•´æ•° (Signed)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ int (å¹³å°ç›¸å…³: 32æˆ–64ä½)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ int8  (-128 to 127)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ int16 (-32768 to 32767)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ int32 (-2Â³Â¹ to 2Â³Â¹-1)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ int64 (-2â¶Â³ to 2â¶Â³-1)
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â””â”€â”€ æ— ç¬¦å·æ•´æ•° (Unsigned)
â”‚   â”‚   â”‚       â”œâ”€â”€ uint (å¹³å°ç›¸å…³: 32æˆ–64ä½)
â”‚   â”‚   â”‚       â”œâ”€â”€ uint8  (0 to 255, alias: byte)
â”‚   â”‚   â”‚       â”œâ”€â”€ uint16 (0 to 65535)
â”‚   â”‚   â”‚       â”œâ”€â”€ uint32 (0 to 2Â³Â²-1)
â”‚   â”‚   â”‚       â”œâ”€â”€ uint64 (0 to 2â¶â´-1)
â”‚   â”‚   â”‚       â””â”€â”€ uintptr (è¶³ä»¥å­˜å‚¨æŒ‡é’ˆ)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ æµ®ç‚¹ç±»å‹ (Floating-Point Types)
â”‚   â”‚   â”‚   â”œâ”€â”€ float32 (IEEE 754 32-bit)
â”‚   â”‚   â”‚   â””â”€â”€ float64 (IEEE 754 64-bit)
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ å¤æ•°ç±»å‹ (Complex Types)
â”‚   â”‚       â”œâ”€â”€ complex64  (float32 å®éƒ¨å’Œè™šéƒ¨)
â”‚   â”‚       â””â”€â”€ complex128 (float64 å®éƒ¨å’Œè™šéƒ¨)
â”‚   â”‚
â”‚   â”œâ”€â”€ å­—ç¬¦ä¸²ç±»å‹ (String Type)
â”‚   â”‚   â””â”€â”€ string (UTF-8ç¼–ç ï¼Œä¸å¯å˜)
â”‚   â”‚
â”‚   â””â”€â”€ å¸ƒå°”ç±»å‹ (Boolean Type)
â”‚       â””â”€â”€ bool (true, false)
â”‚
â”œâ”€â”€ å¤åˆç±»å‹ (Composite Types)
â”‚   â”œâ”€â”€ æŒ‡é’ˆç±»å‹ (Pointer Type)
â”‚   â”‚   â””â”€â”€ *T (æŒ‡å‘ç±»å‹Tçš„æŒ‡é’ˆ)
â”‚   â”‚
â”‚   â”œâ”€â”€ æ•°ç»„ç±»å‹ (Array Type)
â”‚   â”‚   â””â”€â”€ [n]T (å›ºå®šé•¿åº¦nï¼Œå…ƒç´ ç±»å‹T)
â”‚   â”‚       â”œâ”€â”€ å€¼è¯­ä¹‰
â”‚   â”‚       â””â”€â”€ å¯æ¯”è¾ƒï¼ˆå¦‚æœTå¯æ¯”è¾ƒï¼‰
â”‚   â”‚
â”‚   â”œâ”€â”€ åˆ‡ç‰‡ç±»å‹ (Slice Type)
â”‚   â”‚   â””â”€â”€ []T (åŠ¨æ€é•¿åº¦ï¼Œå…ƒç´ ç±»å‹T)
â”‚   â”‚       â”œâ”€â”€ å¼•ç”¨è¯­ä¹‰
â”‚   â”‚       â”œâ”€â”€ åº•å±‚æ•°ç»„
â”‚   â”‚       â”œâ”€â”€ é•¿åº¦ (len)
â”‚   â”‚       â””â”€â”€ å®¹é‡ (cap)
â”‚   â”‚
â”‚   â”œâ”€â”€ æ˜ å°„ç±»å‹ (Map Type)
â”‚   â”‚   â””â”€â”€ map[K]V
â”‚   â”‚       â”œâ”€â”€ é”®ç±»å‹Kå¿…é¡»å¯æ¯”è¾ƒ
â”‚   â”‚       â”œâ”€â”€ å¼•ç”¨è¯­ä¹‰
â”‚   â”‚       â””â”€â”€ å“ˆå¸Œè¡¨å®ç°
â”‚   â”‚
â”‚   â”œâ”€â”€ ç»“æ„ä½“ç±»å‹ (Struct Type)
â”‚   â”‚   â””â”€â”€ struct { field1 T1; field2 T2; ... }
â”‚   â”‚       â”œâ”€â”€ å€¼è¯­ä¹‰
â”‚   â”‚       â”œâ”€â”€ å­—æ®µå¯¹é½
â”‚   â”‚       â”œâ”€â”€ åŒ¿åå­—æ®µï¼ˆåµŒå…¥ï¼‰
â”‚   â”‚       â””â”€â”€ å¯æ¯”è¾ƒï¼ˆæ‰€æœ‰å­—æ®µå¯æ¯”è¾ƒï¼‰
â”‚   â”‚
â”‚   â””â”€â”€ å‡½æ•°ç±»å‹ (Function Type)
â”‚       â””â”€â”€ func(param1 T1, param2 T2) (result1 R1, result2 R2)
â”‚           â”œâ”€â”€ ç¬¬ä¸€ç±»å€¼ (First-class)
â”‚           â”œâ”€â”€ é—­åŒ…æ”¯æŒ
â”‚           â””â”€â”€ å¯å˜å‚æ•°
â”‚
â”œâ”€â”€ æ¥å£ç±»å‹ (Interface Types)
â”‚   â”œâ”€â”€ ç©ºæ¥å£ (Empty Interface)
â”‚   â”‚   â””â”€â”€ interface{} æˆ– any (Go 1.18+)
â”‚   â”‚       â””â”€â”€ å¯ä»¥æŒæœ‰ä»»æ„ç±»å‹çš„å€¼
â”‚   â”‚
â”‚   â”œâ”€â”€ éç©ºæ¥å£ (Non-Empty Interface)
â”‚   â”‚   â””â”€â”€ interface { Method1(); Method2() T; ... }
â”‚   â”‚       â”œâ”€â”€ æ–¹æ³•é›† (Method Set)
â”‚   â”‚       â”œâ”€â”€ éšå¼å®ç° (Duck Typing)
â”‚   â”‚       â””â”€â”€ æ¥å£åµŒå…¥
â”‚   â”‚
â”‚   â””â”€â”€ ç±»å‹çº¦æŸæ¥å£ (Type Constraint Interface, Go 1.18+)
â”‚       â””â”€â”€ interface { ~T | T1 | T2; Method() }
â”‚           â”œâ”€â”€ ç±»å‹é›†åˆ
â”‚           â”œâ”€â”€ è¿‘ä¼¼çº¦æŸ (~T)
â”‚           â””â”€â”€ è”åˆçº¦æŸ (T1 | T2)
â”‚
â”œâ”€â”€ é€šé“ç±»å‹ (Channel Types)
â”‚   â”œâ”€â”€ åŒå‘é€šé“ (Bidirectional Channel)
â”‚   â”‚   â””â”€â”€ chan T
â”‚   â”œâ”€â”€ åªå‘é€é€šé“ (Send-only Channel)
â”‚   â”‚   â””â”€â”€ chan<- T
â”‚   â””â”€â”€ åªæ¥æ”¶é€šé“ (Receive-only Channel)
â”‚       â””â”€â”€ <-chan T
â”‚
â””â”€â”€ æ³›å‹ç±»å‹ (Generic Types, Go 1.18+)
    â”œâ”€â”€ ç±»å‹å‚æ•°åŒ–ç±»å‹
    â”‚   â””â”€â”€ T[P any] æˆ– T[P comparable]
    â”‚       â”œâ”€â”€ ç±»å‹å‚æ•° (Type Parameters)
    â”‚       â”œâ”€â”€ ç±»å‹çº¦æŸ (Type Constraints)
    â”‚       â””â”€â”€ ç±»å‹å®ä¾‹åŒ– (Type Instantiation)
    â”‚
    â””â”€â”€ é¢„å®šä¹‰çº¦æŸ
        â”œâ”€â”€ any (ä»»æ„ç±»å‹)
        â”œâ”€â”€ comparable (å¯æ¯”è¾ƒç±»å‹)
        â”œâ”€â”€ Integer (æ•´æ•°çº¦æŸ)
        â”œâ”€â”€ Float (æµ®ç‚¹çº¦æŸ)
        â”œâ”€â”€ Complex (å¤æ•°çº¦æŸ)
        â””â”€â”€ Ordered (å¯æ’åºç±»å‹)
```

### 3.2 å­ç±»å‹å…³ç³»å›¾

```
å­ç±»å‹å…³ç³» (<:)
â”‚
â”œâ”€â”€ åŸºæœ¬è§„åˆ™
â”‚   â”œâ”€â”€ è‡ªåæ€§: T <: T
â”‚   â”œâ”€â”€ ä¼ é€’æ€§: Tâ‚ <: Tâ‚‚ âˆ§ Tâ‚‚ <: Tâ‚ƒ â‡’ Tâ‚ <: Tâ‚ƒ
â”‚   â””â”€â”€ åå¯¹ç§°æ€§: Tâ‚ <: Tâ‚‚ âˆ§ Tâ‚‚ <: Tâ‚ â‡’ Tâ‚ â‰¡ Tâ‚‚
â”‚
â”œâ”€â”€ æ¥å£å®ç°å…³ç³»
â”‚   â””â”€â”€ T implements I â‡’ T <: I
â”‚       â”œâ”€â”€ æ–¹æ³•é›†åŒ…å«å…³ç³»
â”‚       â”‚   â””â”€â”€ MethodSet(T) âŠ‡ MethodSet(I)
â”‚       â”‚
â”‚       â””â”€â”€ æ–¹æ³•ç­¾ååŒ¹é…
â”‚           â””â”€â”€ âˆ€m âˆˆ MethodSet(I), âˆƒm' âˆˆ MethodSet(T),
â”‚               Signature(m) = Signature(m')
â”‚
â”œâ”€â”€ Channelæ–¹å‘å…³ç³»
â”‚   â”œâ”€â”€ chan T <: chan<- T  (åŒå‘ â†’ åªå‘é€)
â”‚   â””â”€â”€ chan T <: <-chan T  (åŒå‘ â†’ åªæ¥æ”¶)
â”‚
â”œâ”€â”€ æŒ‡é’ˆç±»å‹å…³ç³»
â”‚   â””â”€â”€ *T <: unsafe.Pointer  (å¯ä»¥è½¬æ¢)
â”‚
â””â”€â”€ ç©ºæ¥å£å…³ç³»
    â””â”€â”€ âˆ€T, T <: interface{}  (ä»»æ„ç±»å‹éƒ½å®ç°ç©ºæ¥å£)
```

### 3.3 ç±»å‹åˆ¤æ–­è§„åˆ™æ ‘

```
ç±»å‹åˆ¤æ–­è§„åˆ™ (Î“ âŠ¢ e : T)
â”‚
â”œâ”€â”€ [T-Lit] å­—é¢é‡
â”‚   â”œâ”€â”€ âŠ¢ n : int
â”‚   â”œâ”€â”€ âŠ¢ f : float64
â”‚   â”œâ”€â”€ âŠ¢ s : string
â”‚   â””â”€â”€ âŠ¢ b : bool
â”‚
â”œâ”€â”€ [T-Var] å˜é‡
â”‚   â””â”€â”€ Î“(x) = T
â”‚       â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚       Î“ âŠ¢ x : T
â”‚
â”œâ”€â”€ [T-Bin] äºŒå…ƒè¿ç®—
â”‚   â””â”€â”€ Î“ âŠ¢ eâ‚ : T, Î“ âŠ¢ eâ‚‚ : T, op : T â†’ T â†’ T'
â”‚       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚       Î“ âŠ¢ eâ‚ op eâ‚‚ : T'
â”‚
â”œâ”€â”€ [T-If] æ¡ä»¶è¡¨è¾¾å¼
â”‚   â””â”€â”€ Î“ âŠ¢ b : bool, Î“ âŠ¢ eâ‚ : T, Î“ âŠ¢ eâ‚‚ : T
â”‚       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚       Î“ âŠ¢ if b then eâ‚ else eâ‚‚ : T
â”‚
â”œâ”€â”€ [T-App] å‡½æ•°åº”ç”¨
â”‚   â””â”€â”€ Î“ âŠ¢ f : Tâ‚ â†’ Tâ‚‚, Î“ âŠ¢ e : Tâ‚
â”‚       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚       Î“ âŠ¢ f(e) : Tâ‚‚
â”‚
â”œâ”€â”€ [T-Abs] å‡½æ•°æŠ½è±¡
â”‚   â””â”€â”€ Î“, x : Tâ‚ âŠ¢ e : Tâ‚‚
â”‚       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚       Î“ âŠ¢ func(x Tâ‚) Tâ‚‚ { return e } : Tâ‚ â†’ Tâ‚‚
â”‚
â”œâ”€â”€ [T-Struct] ç»“æ„ä½“å­—é¢é‡
â”‚   â””â”€â”€ Î“ âŠ¢ eâ‚ : Tâ‚, ..., Î“ âŠ¢ eâ‚™ : Tâ‚™
â”‚       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚       Î“ âŠ¢ T{fâ‚: eâ‚, ..., fâ‚™: eâ‚™} : T
â”‚       å…¶ä¸­ T = struct{fâ‚ Tâ‚; ...; fâ‚™ Tâ‚™}
â”‚
â”œâ”€â”€ [T-Select] å­—æ®µé€‰æ‹©
â”‚   â””â”€â”€ Î“ âŠ¢ e : struct{...; f: T; ...}
â”‚       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚       Î“ âŠ¢ e.f : T
â”‚
â”œâ”€â”€ [T-Index] æ•°ç»„/åˆ‡ç‰‡ç´¢å¼•
â”‚   â””â”€â”€ Î“ âŠ¢ eâ‚ : []T (æˆ– [n]T), Î“ âŠ¢ eâ‚‚ : int
â”‚       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚       Î“ âŠ¢ eâ‚[eâ‚‚] : T
â”‚
â”œâ”€â”€ [T-MapIndex] æ˜ å°„ç´¢å¼•
â”‚   â””â”€â”€ Î“ âŠ¢ m : map[K]V, Î“ âŠ¢ k : K
â”‚       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚       Î“ âŠ¢ m[k] : V
â”‚
â”œâ”€â”€ [T-TypeAssert] ç±»å‹æ–­è¨€
â”‚   â””â”€â”€ Î“ âŠ¢ e : interface{...}, T implements interface{...}
â”‚       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚       Î“ âŠ¢ e.(T) : T
â”‚
â”œâ”€â”€ [T-Chan] é€šé“æ“ä½œ
â”‚   â”œâ”€â”€ [T-Send]
â”‚   â”‚   â””â”€â”€ Î“ âŠ¢ ch : chan T (æˆ– chan<- T), Î“ âŠ¢ v : T
â”‚   â”‚       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚   â”‚       Î“ âŠ¢ ch <- v : ()
â”‚   â”‚
â”‚   â””â”€â”€ [T-Recv]
â”‚       â””â”€â”€ Î“ âŠ¢ ch : chan T (æˆ– <-chan T)
â”‚           â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚           Î“ âŠ¢ <-ch : T
â”‚
â”œâ”€â”€ [T-Go] Goroutine
â”‚   â””â”€â”€ Î“ âŠ¢ f : () â†’ ()
â”‚       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚       Î“ âŠ¢ go f() : ()
â”‚
â””â”€â”€ [T-Generic] æ³›å‹å®ä¾‹åŒ– (Go 1.18+)
    â”œâ”€â”€ [T-TApp] ç±»å‹åº”ç”¨
    â”‚   â””â”€â”€ Î“ âŠ¢ F : [X C] T, Î“ âŠ¢ A satisfies C
    â”‚       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    â”‚       Î“ âŠ¢ F[A] : T[X â†¦ A]
    â”‚
    â””â”€â”€ [T-TAbs] ç±»å‹æŠ½è±¡
        â””â”€â”€ Î“, X <: C âŠ¢ e : T
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            Î“ âŠ¢ [X C]e : âˆ€X <: C. T
```

---

## 4. å±æ€§å…³ç³»åˆ†æ

### 4.1 ç±»å‹å±æ€§å…³ç³»å›¾

```mermaid
graph TD
    A[ç±»å‹T] --> B{å¯æ¯”è¾ƒ?}
    A --> C{å¯å¯»å€?}
    A --> D{å¯èµ‹å€¼?}
    A --> E{å¯è½¬æ¢?}
    
    B -->|Yes| B1[==, !=å¯ç”¨]
    B -->|No| B2[ä»…å¯æ¯”è¾ƒnil]
    
    C -->|Yes| C1[å¯å–åœ°å€&T]
    C -->|Yes| C2[å¯ä¿®æ”¹]
    C -->|No| C3[ä¸´æ—¶å€¼]
    
    D -->|Yes| D1[å¯ç”¨ä½œèµ‹å€¼ç›®æ ‡]
    D -->|No| D2[å¸¸é‡/å­—é¢é‡]
    
    E -->|Yes| E1[ç±»å‹è½¬æ¢Tâ‚‚(v)]
    E -->|No| E2[éœ€ç±»å‹æ–­è¨€]
    
    style A fill:#f9f,stroke:#333,stroke-width:4px
    style B fill:#bbf,stroke:#333,stroke-width:2px
    style C fill:#bbf,stroke:#333,stroke-width:2px
    style D fill:#bbf,stroke:#333,stroke-width:2px
    style E fill:#bbf,stroke:#333,stroke-width:2px
```

### 4.2 å¹¶å‘å®‰å…¨å±æ€§çŸ©é˜µ

| æ“ä½œ/ç±»å‹ | å¹¶å‘å®‰å…¨ | éœ€è¦åŒæ­¥ | åŸå­æ€§ | å¯è§æ€§ä¿è¯ |
|----------|---------|---------|-------|-----------|
| **åŸºæœ¬ç±»å‹è¯»å†™** | âŒ | âœ… | âŒ | âŒ |
| **æŒ‡é’ˆè¯»å†™** | âŒ | âœ… | âœ… (å¯¹é½) | âŒ |
| **Sliceæ“ä½œ** | âŒ | âœ… | âŒ | âŒ |
| **Mapæ“ä½œ** | âŒ | âœ… | âŒ | âŒ |
| **Channelæ“ä½œ** | âœ… | âŒ | âœ… | âœ… (HB) |
| **Mutex.Lock/Unlock** | âœ… | âŒ | âœ… | âœ… (HB) |
| **atomicåŒ…æ“ä½œ** | âœ… | âŒ | âœ… | âœ… |
| **sync.Once.Do** | âœ… | âŒ | âœ… | âœ… (HB) |
| **WaitGroupæ“ä½œ** | âœ… | âŒ | âœ… | âœ… (HB) |

### 4.3 å†…å­˜è¯­ä¹‰å…³ç³»å›¾

```
å†…å­˜è¯­ä¹‰å…³ç³»
â”‚
â”œâ”€â”€ Happens-Beforeå…³ç³» (HB)
â”‚   â”œâ”€â”€ ç¨‹åºé¡ºåº
â”‚   â”‚   â””â”€â”€ å•ä¸ªgoroutineå†…: aåœ¨bä¹‹å‰ â‡’ a HB b
â”‚   â”‚
â”‚   â”œâ”€â”€ ChannelåŒæ­¥
â”‚   â”‚   â”œâ”€â”€ send HB recv (æ— ç¼“å†²)
â”‚   â”‚   â”œâ”€â”€ recv HB send (ç¼“å†²å·²æ»¡)
â”‚   â”‚   â””â”€â”€ close HB recv (æ¥æ”¶åˆ°é›¶å€¼)
â”‚   â”‚
â”‚   â”œâ”€â”€ äº’æ–¥é”åŒæ­¥
â”‚   â”‚   â”œâ”€â”€ unlock HB lock (åç»­)
â”‚   â”‚   â””â”€â”€ ä¸´ç•ŒåŒºé¡ºåºæ€§
â”‚   â”‚
â”‚   â”œâ”€â”€ OnceåŒæ­¥
â”‚   â”‚   â””â”€â”€ once.Do(f) ä¸­ f çš„è¿”å› HB åç»­ once.Do è°ƒç”¨
â”‚   â”‚
â”‚   â”œâ”€â”€ WaitGroupåŒæ­¥
â”‚   â”‚   â””â”€â”€ wg.Done() HB wg.Wait() è¿”å›
â”‚   â”‚
â”‚   â””â”€â”€ GoroutineåŒæ­¥
â”‚       â””â”€â”€ go f() HB f() çš„å¼€å§‹
â”‚
â”œâ”€â”€ æ•°æ®ç«äº‰ (Data Race)
â”‚   â”œâ”€â”€ å®šä¹‰: ä¸¤ä¸ªgoroutineå¹¶å‘è®¿é—®åŒä¸€å†…å­˜ä½ç½®ï¼Œ
â”‚   â”‚        ä¸”è‡³å°‘ä¸€ä¸ªæ˜¯å†™æ“ä½œï¼Œä¸”æ²¡æœ‰HBå…³ç³»
â”‚   â”‚
â”‚   â”œâ”€â”€ æ£€æµ‹: ä½¿ç”¨ go run -race
â”‚   â”‚
â”‚   â””â”€â”€ é¿å…ç­–ç•¥
â”‚       â”œâ”€â”€ ä½¿ç”¨Channelé€šä¿¡
â”‚       â”œâ”€â”€ ä½¿ç”¨Mutexä¿æŠ¤
â”‚       â”œâ”€â”€ ä½¿ç”¨atomicåŒ…
â”‚       â””â”€â”€ ä½¿ç”¨syncåŒ…å·¥å…·
â”‚
â””â”€â”€ Sequential Consistency (SC)
    â”œâ”€â”€ å®šä¹‰: å¦‚æœä¸å­˜åœ¨æ•°æ®ç«äº‰ï¼Œ
    â”‚        ç¨‹åºè¡Œä¸ºç­‰ä»·äºæŸä¸ªé¡ºåºäº¤é”™æ‰§è¡Œ
    â”‚
    â””â”€â”€ Goä¿è¯: DRF-SC (Data-Race-Free â†’ Sequential Consistency)
```

### 4.4 ç±»å‹è½¬æ¢å…³ç³»å›¾

```
ç±»å‹è½¬æ¢å…³ç³»
â”‚
â”œâ”€â”€ éšå¼è½¬æ¢ (Implicit Conversion)
â”‚   â”œâ”€â”€ æ— ç±»å‹å¸¸é‡ â†’ æœ‰ç±»å‹
â”‚   â”‚   â”œâ”€â”€ 42 â†’ int
â”‚   â”‚   â”œâ”€â”€ 3.14 â†’ float64
â”‚   â”‚   â”œâ”€â”€ "hello" â†’ string
â”‚   â”‚   â””â”€â”€ true â†’ bool
â”‚   â”‚
â”‚   â”œâ”€â”€ åŒå‘Channel â†’ å•å‘Channel
â”‚   â”‚   â”œâ”€â”€ chan T â†’ chan<- T
â”‚   â”‚   â””â”€â”€ chan T â†’ <-chan T
â”‚   â”‚
â”‚   â””â”€â”€ å…·ä½“ç±»å‹ â†’ æ¥å£ç±»å‹
â”‚       â””â”€â”€ T â†’ interface{...} (å¦‚æœTå®ç°äº†æ¥å£)
â”‚
â”œâ”€â”€ æ˜¾å¼è½¬æ¢ (Explicit Conversion)
â”‚   â”œâ”€â”€ æ•°å€¼ç±»å‹ä¹‹é—´
â”‚   â”‚   â”œâ”€â”€ int â†” float64
â”‚   â”‚   â”œâ”€â”€ int32 â†” int64
â”‚   â”‚   â””â”€â”€ float32 â†” float64
â”‚   â”‚
â”‚   â”œâ”€â”€ å­—ç¬¦ä¸² â†” å­—èŠ‚åˆ‡ç‰‡/ç¬¦æ–‡åˆ‡ç‰‡
â”‚   â”‚   â”œâ”€â”€ string â†’ []byte
â”‚   â”‚   â”œâ”€â”€ []byte â†’ string
â”‚   â”‚   â”œâ”€â”€ string â†’ []rune
â”‚   â”‚   â””â”€â”€ []rune â†’ string
â”‚   â”‚
â”‚   â”œâ”€â”€ æŒ‡é’ˆç±»å‹
â”‚   â”‚   â”œâ”€â”€ *T â†’ unsafe.Pointer
â”‚   â”‚   â”œâ”€â”€ unsafe.Pointer â†’ *T
â”‚   â”‚   â””â”€â”€ uintptr â†” unsafe.Pointer
â”‚   â”‚
â”‚   â””â”€â”€ åº•å±‚ç±»å‹ç›¸åŒ
â”‚       â””â”€â”€ type MyInt int
â”‚           int(x) â†” MyInt(x)
â”‚
â””â”€â”€ ç±»å‹æ–­è¨€ (Type Assertion)
    â”œâ”€â”€ æ¥å£ â†’ å…·ä½“ç±»å‹
    â”‚   â””â”€â”€ var i interface{} = "hello"
    â”‚       s := i.(string)
    â”‚
    â””â”€â”€ æ¥å£ â†’ æ¥å£
        â””â”€â”€ var r io.Reader = ...
            rc := r.(io.ReadCloser)
```

---

## 5. å¹¶å‘æ¨¡å‹å½¢å¼åŒ–

### 5.1 CSPè¿›ç¨‹ä»£æ•°

**åŸºæœ¬è¿›ç¨‹è¡¨è¾¾å¼**:

```
P ::= STOP                    ç»ˆæ­¢è¿›ç¨‹
    | SKIP                    è·³è¿‡è¿›ç¨‹
    | a â†’ P                   å‰ç¼€: æ‰§è¡ŒåŠ¨ä½œaç„¶åP
    | P â–¡ Q                   å¤–éƒ¨é€‰æ‹©
    | P âŠ“ Q                   å†…éƒ¨é€‰æ‹©
    | P ||| Q                 äº¤ç»‡å¹¶è¡Œ
    | P || Q                  åŒæ­¥å¹¶è¡Œ
    | P ; Q                   é¡ºåºç»„åˆ
    | P \ A                   éšè—Aä¸­çš„äº‹ä»¶
    | P [[ R ]]               é‡å‘½å
    | Î¼X. P                   é€’å½’å®šä¹‰
```

**Goå¹¶å‘åŸè¯­çš„CSPæ˜ å°„**:

| Goæ„é€  | CSPè¡¨ç¤º | è¯­ä¹‰ |
|--------|---------|------|
| `go f()` | `f() ||| P` | å¹¶å‘æ‰§è¡Œf()å’ŒP |
| `ch <- v` | `ch!v â†’ P` | å‘chå‘é€vï¼Œç„¶åP |
| `v := <-ch` | `ch?v â†’ P` | ä»chæ¥æ”¶vï¼Œç„¶åP |
| `close(ch)` | `close_ch â†’ P` | å…³é—­chï¼Œç„¶åP |
| `select { case ch <- v: s1; case <-ch: s2 }` | `(ch!v â†’ Sâ‚) â–¡ (ch?x â†’ Sâ‚‚)` | å¤–éƒ¨é€‰æ‹© |
| `for { ... }` | `Î¼X. (body ; X)` | é€’å½’å¾ªç¯ |

### 5.2 Goroutineç”Ÿå‘½å‘¨æœŸçŠ¶æ€æœº

```
GoroutineçŠ¶æ€è½¬æ¢
â”‚
[Created] â”€â”€newâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> [Runnable]
                                     â”‚
                                     â”‚ scheduled
                                     â†“
                               [Running] â†â”€â”€â”€â”€â”€â”€â”
                                â”‚    â”‚          â”‚
                                â”‚    â”‚          â”‚ resume
            syscall/block       â”‚    â”‚          â”‚
                â†“               â”‚    â”‚          â”‚
           [Waiting] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚          â”‚
                â†‘                     â”‚          â”‚
                â”‚                     â”‚ preempt  â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤          â”‚
                                      â†“          â”‚
                                [Preempted] â”€â”€â”€â”€â”˜
                                      â”‚
                                      â”‚ done
                                      â†“
                                  [Dead]

çŠ¶æ€è¯´æ˜:
- Created: Goroutineå·²åˆ›å»ºä½†æœªè¿è¡Œ
- Runnable: å¯è¿è¡Œï¼Œç­‰å¾…è°ƒåº¦
- Running: æ­£åœ¨æ‰§è¡Œ
- Waiting: ç­‰å¾…I/Oã€Channelã€é”ç­‰
- Preempted: è¢«æŠ¢å ï¼Œç­‰å¾…é‡æ–°è°ƒåº¦
- Dead: æ‰§è¡Œå®Œæˆ
```

### 5.3 ChannelåŒæ­¥è¯­ä¹‰

**æ— ç¼“å†²Channel (Unbuffered Channel)**:

```mathematical
send(ch, v) å’Œ recv(ch) å¿…é¡»åŒæ—¶å°±ç»ªæ‰èƒ½è¿›è¡Œé€šä¿¡

å½¢å¼åŒ–:
  sender: ch!v â†’ P
  receiver: ch?x â†’ Q
  
åŒæ­¥è§„åˆ™:
  ch!v â†’ P  ||  ch?x â†’ Q
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
         P || Q[x â†¦ v]
  
Happens-Before:
  send(ch, v) happens-before recv(ch) returns v
```

**æœ‰ç¼“å†²Channel (Buffered Channel, n > 0)**:

```mathematical
ç¼“å†²é˜Ÿåˆ—: Queue[0..n-1]
å½“å‰å¤§å°: len(ch)
å®¹é‡: cap(ch) = n

å‘é€è§„åˆ™:
  len(ch) < cap(ch):
    ch!v â†’ enqueue(v); P
    (éé˜»å¡)
  
  len(ch) = cap(ch):
    ch!v â†’ é˜»å¡ç›´åˆ°dequeue(); enqueue(v); P

æ¥æ”¶è§„åˆ™:
  len(ch) > 0:
    ch?x â†’ x := dequeue(); Q
    (éé˜»å¡)
  
  len(ch) = 0:
    ch?x â†’ é˜»å¡ç›´åˆ°enqueue(v); x := dequeue(); Q

Happens-Before:
  ç¬¬kæ¬¡send happens-before ç¬¬kæ¬¡recv (k â‰¤ n)
```

### 5.4 Selectè¯­å¥è¯­ä¹‰

```mathematical
select {
case châ‚ <- vâ‚: Sâ‚
case x := <-châ‚‚: Sâ‚‚
case châ‚ƒ <- vâ‚ƒ: Sâ‚ƒ
default: Sâ‚„
}

å½¢å¼åŒ–è¯­ä¹‰:
  Ready = {i | case i is ready}
  
  If Ready â‰  âˆ…:
    éç¡®å®šæ€§é€‰æ‹© i âˆˆ Ready
    æ‰§è¡Œ Sáµ¢
  
  Else if defaultåˆ†æ”¯å­˜åœ¨:
    æ‰§è¡Œ Sâ‚„
  
  Else:
    é˜»å¡ç›´åˆ°æŸä¸ªcaseå°±ç»ª

å…¬å¹³æ€§ä¿è¯:
  å¦‚æœå¤šä¸ªcaseå°±ç»ªï¼Œä¼ªéšæœºé€‰æ‹©ï¼ˆä¸ä¿è¯å®Œå…¨å…¬å¹³ï¼‰
  
éç¡®å®šæ€§:
  select { case ch <- 1; case ch <- 2 }
  å¯èƒ½å‘é€1æˆ–2ï¼Œå–å†³äºè¿è¡Œæ—¶è°ƒåº¦
```

---

## 6. å†…å­˜æ¨¡å‹å½¢å¼åŒ–

### 6.1 å†…å­˜æ“ä½œåˆ†ç±»

```
å†…å­˜æ“ä½œ (Memory Operations)
â”œâ”€â”€ è¯»æ“ä½œ (Read)
â”‚   â”œâ”€â”€ æ™®é€šè¯» (Normal Read): r = *p
â”‚   â”œâ”€â”€ åŸå­è¯» (Atomic Read): atomic.LoadX(&v)
â”‚   â””â”€â”€ é€šé“æ¥æ”¶ (Channel Receive): v := <-ch
â”‚
â”œâ”€â”€ å†™æ“ä½œ (Write)
â”‚   â”œâ”€â”€ æ™®é€šå†™ (Normal Write): *p = v
â”‚   â”œâ”€â”€ åŸå­å†™ (Atomic Write): atomic.StoreX(&v, val)
â”‚   â””â”€â”€ é€šé“å‘é€ (Channel Send): ch <- v
â”‚
â””â”€â”€ è¯»-ä¿®æ”¹-å†™æ“ä½œ (Read-Modify-Write)
    â”œâ”€â”€ atomic.AddX(&v, delta)
    â”œâ”€â”€ atomic.CompareAndSwapX(&v, old, new)
    â””â”€â”€ atomic.SwapX(&v, new)
```

### 6.2 Happens-Beforeè§„åˆ™

**å®šä¹‰**: HB âŠ† Event Ã— Eventï¼Œä¼ é€’ã€åè‡ªåçš„ååºå…³ç³»

**è§„åˆ™é›†**:

```mathematical
è§„åˆ™1: ç¨‹åºé¡ºåº (Program Order)
  åœ¨åŒä¸€goroutineä¸­ï¼Œå¦‚æœæ“ä½œaåœ¨æ“ä½œbä¹‹å‰ï¼Œåˆ™ a HB b
  
  âˆ€g âˆˆ Goroutine, âˆ€a, b âˆˆ Events(g),
    PO(a, b) â‡’ HB(a, b)

è§„åˆ™2: Goroutineåˆ›å»º (Goroutine Creation)
  goè¯­å¥çš„æ‰§è¡Œ HB æ–°goroutineçš„å¼€å§‹
  
  go_stmt HB goroutine_start

è§„åˆ™3: Goroutineé”€æ¯ (Goroutine Destruction)
  goroutineçš„ç»“æŸä¸ä¸ä»»ä½•äº‹ä»¶æœ‰HBå…³ç³»
  ï¼ˆgoroutineå¯èƒ½æ°¸è¿œè¿è¡Œï¼‰

è§„åˆ™4: Channelé€šä¿¡ (Channel Communication)
  a) æ— ç¼“å†²channel: send HB recv
     send(ch, v) HB recv(ch) returns v
  
  b) æœ‰ç¼“å†²channel (cap=n):
     ç¬¬kæ¬¡send HB ç¬¬k+næ¬¡recvå®Œæˆ
  
  c) Channelå…³é—­:
     close(ch) HB æ¥æ”¶åˆ°é›¶å€¼

è§„åˆ™5: äº’æ–¥é” (Mutex)
  å¯¹äºsync.Mutex m:
  ç¬¬næ¬¡ m.Unlock() HB ç¬¬n+1æ¬¡ m.Lock() returns
  
  unlock_n HB lock_{n+1}_returns

è§„åˆ™6: Once (sync.Once)
  once.Do(f) ä¸­ f() çš„è¿”å› HB åç»­ä»»ä½• once.Do(g) çš„è¿”å›
  
  f_return HB future_once.Do_returns

è§„åˆ™7: WaitGroup (sync.WaitGroup)
  wg.Add(n) with n<0 (å³ wg.Done())
  HB wg.Wait() returns
  
  wg.Done() HB wg.Wait()_returns

è§„åˆ™8: åŸå­æ“ä½œ (Atomic Operations)
  åŸå­æ“ä½œä¹‹é—´å»ºç«‹å…¨åºå…³ç³»
  å¯¹äºåŒä¸€å˜é‡çš„åŸå­æ“ä½œå½¢æˆ total order
  
  atomic.Store HB atomic.Load (åŒä¸€å˜é‡)
```

### 6.3 æ•°æ®ç«äº‰å½¢å¼åŒ–å®šä¹‰

```mathematical
æ•°æ®ç«äº‰ (Data Race) å®šä¹‰:

ç»™å®šä¸¤ä¸ªå†…å­˜æ“ä½œ opâ‚ å’Œ opâ‚‚ï¼Œå¦‚æœæ»¡è¶³ä»¥ä¸‹æ‰€æœ‰æ¡ä»¶ï¼Œ
åˆ™å­˜åœ¨æ•°æ®ç«äº‰ï¼š

1. opâ‚ å’Œ opâ‚‚ è®¿é—®åŒä¸€å†…å­˜ä½ç½®
2. è‡³å°‘ä¸€ä¸ªæ˜¯å†™æ“ä½œ
3. opâ‚ å’Œ opâ‚‚ åœ¨ä¸åŒçš„goroutineä¸­æ‰§è¡Œ
4. Â¬(opâ‚ HB opâ‚‚) âˆ§ Â¬(opâ‚‚ HB opâ‚)

å½¢å¼åŒ–:
  DataRace(opâ‚, opâ‚‚) âŸº
    SameLocation(opâ‚, opâ‚‚) âˆ§
    (IsWrite(opâ‚) âˆ¨ IsWrite(opâ‚‚)) âˆ§
    DifferentGoroutines(opâ‚, opâ‚‚) âˆ§
    Â¬HB(opâ‚, opâ‚‚) âˆ§ Â¬HB(opâ‚‚, opâ‚)

æ— æ•°æ®ç«äº‰ç¨‹åº (Data-Race-Free, DRF):
  âˆ€opâ‚, opâ‚‚ âˆˆ Execution, Â¬DataRace(opâ‚, opâ‚‚)

DRF-SCä¿è¯:
  å¦‚æœç¨‹åºæ˜¯DRFï¼Œåˆ™å…¶æ‰§è¡Œç­‰ä»·äºæŸä¸ªé¡ºåºä¸€è‡´çš„æ‰§è¡Œ
```

### 6.4 å†…å­˜ä¸€è‡´æ€§æ¨¡å‹

```
Goå†…å­˜ä¸€è‡´æ€§æ¨¡å‹
â”‚
â”œâ”€â”€ Sequential Consistency (SC) for DRF Programs
â”‚   â””â”€â”€ å¦‚æœç¨‹åºæ²¡æœ‰æ•°æ®ç«äº‰ï¼Œè¡Œä¸ºç­‰ä»·äºé¡ºåºä¸€è‡´æ‰§è¡Œ
â”‚
â”œâ”€â”€ Relaxed Memory Model for Racy Programs
â”‚   â”œâ”€â”€ å…è®¸ç¼–è¯‘å™¨å’ŒCPUé‡æ’åº
â”‚   â”œâ”€â”€ ä½†å¿…é¡»éµå®ˆHBè§„åˆ™
â”‚   â””â”€â”€ åŸå­æ“ä½œæä¾›åŒæ­¥ä¿è¯
â”‚
â””â”€â”€ ä¿è¯ (Guarantees)
    â”œâ”€â”€ å­—é•¿å¯¹é½çš„è¯»å†™æ˜¯åŸå­çš„
    â”œâ”€â”€ æŒ‡é’ˆè¯»å†™æ˜¯åŸå­çš„ï¼ˆ64ä½ç³»ç»Ÿï¼‰
    â”œâ”€â”€ Channelæ“ä½œæ˜¯åŒæ­¥çš„
    â””â”€â”€ atomicåŒ…æ“ä½œæ˜¯åŒæ­¥çš„

å†…å­˜å±éšœ (Memory Barriers):
  Channelæ“ä½œã€Mutexæ“ä½œã€åŸå­æ“ä½œç­‰éšå¼æ’å…¥å†…å­˜å±éšœ
  
  ç±»å‹:
  â”œâ”€â”€ Acquireå±éšœ: é˜²æ­¢åç»­æ“ä½œé‡æ’åˆ°å±éšœä¹‹å‰
  â”œâ”€â”€ Releaseå±éšœ: é˜²æ­¢ä¹‹å‰æ“ä½œé‡æ’åˆ°å±éšœä¹‹å
  â””â”€â”€ Fullå±éšœ: åŒæ—¶æ˜¯Acquireå’ŒReleaseå±éšœ
```

### 6.5 GCä¸å†…å­˜ç®¡ç†

```
åƒåœ¾å›æ”¶ (Garbage Collection)
â”‚
â”œâ”€â”€ ä¸‰è‰²æ ‡è®°ç®—æ³• (Tri-color Marking)
â”‚   â”œâ”€â”€ ç™½è‰² (White): æœªè®¿é—®ï¼Œå¯èƒ½æ˜¯åƒåœ¾
â”‚   â”œâ”€â”€ ç°è‰² (Gray): å·²è®¿é—®ï¼Œä½†å¼•ç”¨æœªæ‰«æ
â”‚   â””â”€â”€ é»‘è‰² (Black): å·²è®¿é—®ï¼Œå¼•ç”¨å·²æ‰«æ
â”‚   â”‚
â”‚   â””â”€â”€ ä¸å˜å¼ (Invariants)
â”‚       â”œâ”€â”€ å¼ºä¸‰è‰²ä¸å˜å¼: é»‘è‰²å¯¹è±¡ä¸ç›´æ¥æŒ‡å‘ç™½è‰²å¯¹è±¡
â”‚       â””â”€â”€ å¼±ä¸‰è‰²ä¸å˜å¼: é»‘è‰²å¯¹è±¡æŒ‡å‘çš„ç™½è‰²å¯¹è±¡ï¼Œå¿…é¡»æœ‰ç°è‰²å¯¹è±¡å¯è¾¾
â”‚
â”œâ”€â”€ å†™å±éšœ (Write Barrier)
â”‚   â”œâ”€â”€ Dijkstraå†™å±éšœ: æ’å…¥æ—¶ç€è‰²
â”‚   â”‚   â””â”€â”€ *slot = ptr â‡’ shade(ptr)
â”‚   â”‚
â”‚   â”œâ”€â”€ Yuasaåˆ é™¤å±éšœ: åˆ é™¤æ—¶ç€è‰²
â”‚   â”‚   â””â”€â”€ shade(old_value) before *slot = ptr
â”‚   â”‚
â”‚   â””â”€â”€ Goæ··åˆå†™å±éšœ (Hybrid Write Barrier)
â”‚       â”œâ”€â”€ shade(slot) + shade(new_value)
â”‚       â””â”€â”€ åŒæ—¶æ»¡è¶³å¼ºä¸‰è‰²ä¸å˜å¼
â”‚
â”œâ”€â”€ å¹¶å‘æ ‡è®° (Concurrent Marking)
â”‚   â”œâ”€â”€ STW (Stop-The-World) é˜¶æ®µ
â”‚   â”‚   â”œâ”€â”€ æ ‡è®°å‡†å¤‡ (~0.5ms)
â”‚   â”‚   â””â”€â”€ æ ‡è®°ç»ˆæ­¢ (~0.5ms)
â”‚   â”‚
â”‚   â””â”€â”€ å¹¶å‘æ ‡è®°é˜¶æ®µ (ä¸mutatorå¹¶å‘)
â”‚       â””â”€â”€ ä½¿ç”¨å†™å±éšœä¿è¯æ­£ç¡®æ€§
â”‚
â””â”€â”€ æ¸…æ‰« (Sweeping)
    â”œâ”€â”€ å¹¶å‘æ¸…æ‰«
    â””â”€â”€ æŒ‰éœ€æ¸…æ‰« (Lazy Sweeping)
```

### 6.6 é€ƒé€¸åˆ†æå½¢å¼åŒ–

```mathematical
é€ƒé€¸åˆ†æ (Escape Analysis)

ç›®æ ‡: å†³å®šå˜é‡åˆ†é…åœ¨æ ˆè¿˜æ˜¯å †

å½¢å¼åŒ–è§„åˆ™:
  Escape(v) âŸº âˆƒp, v å¯ä»pé€ƒé€¸

é€ƒé€¸åœºæ™¯:
  1. è¿”å›å±€éƒ¨å˜é‡çš„åœ°å€
     func f() *int {
       x := 42
       return &x  // xé€ƒé€¸åˆ°å †
     }
     
     Escape(x) = true
  
  2. èµ‹å€¼ç»™å¤–éƒ¨å˜é‡
     var global *int
     func f() {
       x := 42
       global = &x  // xé€ƒé€¸åˆ°å †
     }
     
     Escape(x) = true
  
  3. é—­åŒ…æ•è·
     func f() func() int {
       x := 42
       return func() int { return x }  // xé€ƒé€¸åˆ°å †
     }
     
     Escape(x) = true
  
  4. å‘é€åˆ°Channel
     func f() {
       x := 42
       ch <- &x  // xé€ƒé€¸åˆ°å †
     }
     
     Escape(x) = true
  
  5. èµ‹å€¼ç»™interface{}
     func f() {
       x := 42
       var i interface{} = x  // xå¯èƒ½é€ƒé€¸
     }
     
     Escape(x) = unknown

ä¼˜åŒ–æ•ˆæœ:
  æ ˆåˆ†é…: O(1) åˆ†é…/é‡Šæ”¾ï¼Œæ— GCå‹åŠ›
  å †åˆ†é…: éœ€è¦GCï¼Œæ€§èƒ½å¼€é”€è¾ƒå¤§
```

---

## 7. å½¢å¼åŒ–è¯æ˜ç¤ºä¾‹

### 7.1 ç±»å‹å®‰å…¨æ€§è¯æ˜

**å®šç†**: Goçš„ç±»å‹ç³»ç»Ÿæ˜¯å®‰å…¨çš„ (Type Safety)

**è¯æ˜ç­–ç•¥**: Progress + Preservation

#### 7.1.1 Progresså®šç†

**Progress (è¿›å±•å®šç†)**:

```mathematical
âˆ€e, T. âŠ¢ e : T â‡’ (Value(e) âˆ¨ âˆƒe'. e â†’ e')

å³ï¼šå¦‚æœeæ˜¯è‰¯ç±»å‹çš„ï¼Œåˆ™eè¦ä¹ˆæ˜¯å€¼ï¼Œè¦ä¹ˆå¯ä»¥è¿›ä¸€æ­¥æ±‚å€¼

è¯æ˜ï¼ˆç»“æ„å½’çº³æ³•ï¼‰:

å¯¹eçš„ç»“æ„è¿›è¡Œå½’çº³ï¼š

åŸºç¡€æƒ…å†µ:
  1. e = n (æ•´æ•°å­—é¢é‡)
     Value(n) = true  âœ“
  
  2. e = v (å˜é‡)
     ç”±ç±»å‹ç¯å¢ƒ Î“(v) = Tï¼Œvè¦ä¹ˆæ˜¯å€¼ï¼Œè¦ä¹ˆå¯ä»¥æ±‚å€¼  âœ“
  
  3. e = func(...) {...}
     Value(func) = true  âœ“

å½’çº³æƒ…å†µ:
  å‡è®¾å¯¹æ‰€æœ‰å­è¡¨è¾¾å¼æˆç«‹
  
  1. e = eâ‚ + eâ‚‚
     æƒ…å†µ1: eâ‚æ˜¯å€¼vâ‚ï¼Œeâ‚‚æ˜¯å€¼vâ‚‚
       åˆ™ e â†’ vâ‚+vâ‚‚ (ç®—æœ¯æ±‚å€¼)  âœ“
     
     æƒ…å†µ2: eâ‚ä¸æ˜¯å€¼
       ç”±å½’çº³å‡è®¾ï¼Œâˆƒeâ‚'. eâ‚ â†’ eâ‚'
       åˆ™ e = eâ‚ + eâ‚‚ â†’ eâ‚' + eâ‚‚  âœ“
     
     æƒ…å†µ3: eâ‚æ˜¯å€¼ï¼Œeâ‚‚ä¸æ˜¯å€¼
       ç”±å½’çº³å‡è®¾ï¼Œâˆƒeâ‚‚'. eâ‚‚ â†’ eâ‚‚'
       åˆ™ e = eâ‚ + eâ‚‚ â†’ eâ‚ + eâ‚‚'  âœ“
  
  2. e = if b then eâ‚ else eâ‚‚
     æƒ…å†µ1: b = true
       åˆ™ e â†’ eâ‚  âœ“
     
     æƒ…å†µ2: b = false
       åˆ™ e â†’ eâ‚‚  âœ“
     
     æƒ…å†µ3: bä¸æ˜¯å€¼
       ç”±å½’çº³å‡è®¾ï¼Œâˆƒb'. b â†’ b'
       åˆ™ e â†’ if b' then eâ‚ else eâ‚‚  âœ“
  
  3. e = f(a)
     æƒ…å†µ1: f = func(x T) { return body }, aæ˜¯å€¼v
       åˆ™ e â†’ body[x â†¦ v]  âœ“
     
     æƒ…å†µ2: fä¸æ˜¯å€¼
       ç”±å½’çº³å‡è®¾ï¼Œâˆƒf'. f â†’ f'
       åˆ™ e â†’ f'(a)  âœ“
     
     æƒ…å†µ3: fæ˜¯å€¼ï¼Œaä¸æ˜¯å€¼
       ç”±å½’çº³å‡è®¾ï¼Œâˆƒa'. a â†’ a'
       åˆ™ e â†’ f(a')  âœ“

QED
```

#### 7.1.2 Preservationå®šç†

**Preservation (ä¿æŒå®šç†)**:

```mathematical
âˆ€e, e', T. âŠ¢ e : T âˆ§ e â†’ e' â‡’ âŠ¢ e' : T

å³ï¼šå¦‚æœeæœ‰ç±»å‹Tå¹¶ä¸”å¯ä»¥æ±‚å€¼åˆ°e'ï¼Œåˆ™e'ä¹Ÿæœ‰ç±»å‹T

è¯æ˜ï¼ˆç»“æ„å½’çº³æ³•ï¼‰:

å¯¹æ±‚å€¼è§„åˆ™è¿›è¡Œå½’çº³ï¼š

1. ç®—æœ¯è¿ç®—
   è§„åˆ™: eâ‚ + eâ‚‚ â†’ vâ‚ + vâ‚‚
         å…¶ä¸­ eâ‚ â‡“ vâ‚, eâ‚‚ â‡“ vâ‚‚
   
   å·²çŸ¥: âŠ¢ eâ‚ + eâ‚‚ : int
   æ¨å¯¼: âŠ¢ eâ‚ : int, âŠ¢ eâ‚‚ : int (by inversion)
         eâ‚ â‡“ vâ‚ â‡’ âŠ¢ vâ‚ : int (by å½’çº³å‡è®¾)
         eâ‚‚ â‡“ vâ‚‚ â‡’ âŠ¢ vâ‚‚ : int (by å½’çº³å‡è®¾)
         âŠ¢ vâ‚ + vâ‚‚ : int (by typing rule)  âœ“

2. æ¡ä»¶è¡¨è¾¾å¼
   è§„åˆ™: if true then eâ‚ else eâ‚‚ â†’ eâ‚
   
   å·²çŸ¥: âŠ¢ if b then eâ‚ else eâ‚‚ : T
   æ¨å¯¼: âŠ¢ b : bool, âŠ¢ eâ‚ : T, âŠ¢ eâ‚‚ : T (by inversion)
         âŠ¢ eâ‚ : T ä¿æŒ  âœ“

3. å‡½æ•°åº”ç”¨
   è§„åˆ™: (func(x Tâ‚) { return body })(v) â†’ body[x â†¦ v]
   
   å·²çŸ¥: âŠ¢ f(v) : Tâ‚‚
   æ¨å¯¼: âŠ¢ f : Tâ‚ â†’ Tâ‚‚, âŠ¢ v : Tâ‚ (by inversion)
         âŠ¢ func(x Tâ‚) { return body } : Tâ‚ â†’ Tâ‚‚
         æ„å‘³ç€ x:Tâ‚ âŠ¢ body : Tâ‚‚
         
         ç”±æ›¿æ¢å¼•ç†:
         âŠ¢ v : Tâ‚ âˆ§ x:Tâ‚ âŠ¢ body : Tâ‚‚
         â‡’ âŠ¢ body[x â†¦ v] : Tâ‚‚  âœ“

QED
```

#### 7.1.3 ç±»å‹å®‰å…¨å®šç†

**Type Safety Theorem**:

```mathematical
ç»“åˆProgresså’ŒPreservation:

å®šç†: è‰¯ç±»å‹çš„ç¨‹åºä¸ä¼š"å¡ä½" (get stuck)

è¯æ˜:
  å‡è®¾ âŠ¢ e : T
  
  æƒ…å†µ1: eæ˜¯å€¼
    ç¨‹åºæ­£å¸¸ç»ˆæ­¢  âœ“
  
  æƒ…å†µ2: eä¸æ˜¯å€¼
    ç”±Progresså®šç†ï¼Œâˆƒe'. e â†’ e'
    ç”±Preservationå®šç†ï¼ŒâŠ¢ e' : T
    
    å¯¹e'é‡å¤æ­¤è¿‡ç¨‹ï¼š
    - è¦ä¹ˆæœ€ç»ˆe'å˜æˆå€¼ï¼ˆæ­£å¸¸ç»ˆæ­¢ï¼‰
    - è¦ä¹ˆå¯ä»¥æ— é™æ±‚å€¼ï¼ˆä¸ç»ˆæ­¢ä½†ä¸å‡ºé”™ï¼‰
    
    ä¸¤ç§æƒ…å†µéƒ½ä¸ä¼š"å¡ä½"  âœ“

ç»“è®º:
  è‰¯ç±»å‹çš„Goç¨‹åºä¸ä¼šå‡ºç°ç±»å‹é”™è¯¯
  ï¼ˆè¿è¡Œæ—¶panicé™¤å¤–ï¼Œå¦‚æ•°ç»„è¶Šç•Œã€nilæŒ‡é’ˆè§£å¼•ç”¨ç­‰ï¼‰

QED
```

### 7.2 CSPå¹¶å‘æ­£ç¡®æ€§è¯æ˜ç¤ºä¾‹

#### 7.2.1 æ— æ­»é”è¯æ˜

**ç¤ºä¾‹ç¨‹åº**:

```go
func producer(ch chan int) {
    for i := 0; i < 10; i++ {
        ch <- i
    }
    close(ch)
}

func consumer(ch chan int) {
    for v := range ch {
        fmt.Println(v)
    }
}

func main() {
    ch := make(chan int)
    go producer(ch)
    consumer(ch)
}
```

**CSPå»ºæ¨¡**:

```mathematical
Producer = send(ch, 0) â†’ send(ch, 1) â†’ ... â†’ send(ch, 9) â†’ close(ch) â†’ STOP
Consumer = recv(ch, v) â†’ print(v) â†’ Consumer  (å¾ªç¯ç›´åˆ°chå…³é—­)

System = Producer || Consumer

è¯æ˜æ— æ­»é”:
  1. Produceræ‰§è¡Œsend(ch, i)
  2. Consumeræ‰§è¡Œrecv(ch, v)
  3. ç”±Channelè¯­ä¹‰ï¼Œsendå’ŒrecvåŒæ­¥
  4. Produceræœ€ç»ˆæ‰§è¡Œclose(ch)
  5. Consumeræ¥æ”¶åˆ°closeä¿¡å·ï¼Œé€€å‡ºå¾ªç¯
  6. ä¸¤ä¸ªè¿›ç¨‹éƒ½æ­£å¸¸ç»ˆæ­¢ï¼Œæ— æ­»é”  âœ“

traceåˆ†æ:
  Ï„â‚: send(ch, 0)  || recv(ch, 0)  â†’ åŒæ­¥æˆåŠŸ
  Ï„â‚‚: send(ch, 1)  || recv(ch, 1)  â†’ åŒæ­¥æˆåŠŸ
  ...
  Ï„â‚â‚€: send(ch, 9) || recv(ch, 9)  â†’ åŒæ­¥æˆåŠŸ
  Ï„â‚â‚: close(ch)    || recvå®Œæˆ     â†’ æ­£å¸¸ç»ˆæ­¢

ç»“è®º: æ­¤ç¨‹åºæ— æ­»é”  âœ“
```

#### 7.2.2 æ•°æ®ç«äº‰è‡ªç”±æ€§è¯æ˜

**ç¤ºä¾‹ç¨‹åº**:

```go
var counter int
var mu sync.Mutex

func increment() {
    mu.Lock()
    counter++
    mu.Unlock()
}

func main() {
    for i := 0; i < 1000; i++ {
        go increment()
    }
    time.Sleep(time.Second)
    fmt.Println(counter)
}
```

**Happens-Beforeåˆ†æ**:

```mathematical
äº‹ä»¶åºåˆ—:
  - gâ‚: lock â†’ read(counter) â†’ write(counter) â†’ unlock
  - gâ‚‚: lock â†’ read(counter) â†’ write(counter) â†’ unlock
  - ...
  - gâ‚™: lock â†’ read(counter) â†’ write(counter) â†’ unlock

Happens-Beforeå…³ç³»:
  ç”±Mutexè§„åˆ™:
    unlock_i HB lock_{i+1}
  
  å› æ­¤:
    gâ‚çš„unlock HB gâ‚‚çš„lock
    gâ‚‚çš„unlock HB gâ‚ƒçš„lock
    ...
  
  æ¨å¯¼:
    âˆ€i, j. i < j â‡’ g_içš„æ‰€æœ‰æ“ä½œ HB g_jçš„æ‰€æœ‰æ“ä½œ

æ•°æ®ç«äº‰åˆ†æ:
  ä»»æ„ä¸¤ä¸ªå¯¹counterçš„è®¿é—®(readæˆ–write)éƒ½æœ‰HBå…³ç³»
  
  âˆ€opâ‚, opâ‚‚ âˆˆ {read, write}(counter),
    opâ‚ â‰  opâ‚‚ â‡’ (opâ‚ HB opâ‚‚) âˆ¨ (opâ‚‚ HB opâ‚)
  
  ç”±æ•°æ®ç«äº‰å®šä¹‰ï¼Œä¸å­˜åœ¨æ•°æ®ç«äº‰  âœ“

ç»“è®º: æ­¤ç¨‹åºæ— æ•°æ®ç«äº‰ï¼Œæ˜¯DRFç¨‹åº  âœ“
```

### 7.3 æ³›å‹ç±»å‹å®‰å…¨æ€§è¯æ˜

**ç¤ºä¾‹**: æ³›å‹æ ˆ (Generic Stack)

```go
type Stack[T any] struct {
    items []T
}

func (s *Stack[T]) Push(item T) {
    s.items = append(s.items, item)
}

func (s *Stack[T]) Pop() (T, bool) {
    if len(s.items) == 0 {
        var zero T
        return zero, false
    }
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item, true
}
```

**ç±»å‹åˆ¤æ–­**:

```mathematical
ç±»å‹ç¯å¢ƒ:
  Î“ = {
    Stack: [T any] struct{items []T},
    Push: [T any] (s *Stack[T], item T) â†’ (),
    Pop: [T any] (s *Stack[T]) â†’ (T, bool)
  }

Pushæ–¹æ³•ç±»å‹åˆ¤æ–­:
  Î“, T, s: *Stack[T], item: T âŠ¢ Pushæ–¹æ³•ä½“ : ()
  
  è¯æ˜:
    1. s.items: []T (by field access rule)
    2. append(s.items, item): []T
       å› ä¸º item: T, []Tæ»¡è¶³appendçš„ç±»å‹çº¦æŸ  âœ“
    3. s.items = ...: ()  âœ“

Popæ–¹æ³•ç±»å‹åˆ¤æ–­:
  Î“, T, s: *Stack[T] âŠ¢ Popæ–¹æ³•ä½“ : (T, bool)
  
  è¯æ˜:
    1. len(s.items) == 0: bool  âœ“
    2. var zero T: T (é›¶å€¼)  âœ“
    3. s.items[len(s.items)-1]: T (ç´¢å¼•è§„åˆ™)  âœ“
    4. s.items[:len(s.items)-1]: []T (åˆ‡ç‰‡è§„åˆ™)  âœ“
    5. return (item, true): (T, bool)  âœ“

ç±»å‹å®ä¾‹åŒ–:
  Stack[int]: struct{items []int}
  Pushæ–¹æ³•: (s *Stack[int], item int) â†’ ()
  Popæ–¹æ³•: (s *Stack[int]) â†’ (int, bool)
  
  å®ä¾‹åŒ–åçš„ç±»å‹ä»ç„¶æ˜¯å®‰å…¨çš„  âœ“

ç»“è®º: æ³›å‹Stackæ˜¯ç±»å‹å®‰å…¨çš„  âœ“
```

---

## 8. çŸ¥è¯†çŸ©é˜µæ€»è§ˆ

### 8.1 å®Œæ•´ç‰¹æ€§çŸ©é˜µ

| ç‰¹æ€§ | Goç‰ˆæœ¬ | è¯­æ³•æ”¯æŒ | ç±»å‹ç³»ç»Ÿ | å¹¶å‘æ¨¡å‹ | å†…å­˜æ¨¡å‹ | å½¢å¼åŒ– |
|------|--------|---------|---------|---------|---------|--------|
| **åŸºæœ¬ç±»å‹** | 1.0+ | âœ… | âœ… | N/A | âœ… | âœ… |
| **æ•°ç»„/åˆ‡ç‰‡** | 1.0+ | âœ… | âœ… | âš ï¸ éçº¿ç¨‹å®‰å…¨ | âœ… | âœ… |
| **æ˜ å°„** | 1.0+ | âœ… | âœ… | âš ï¸ éçº¿ç¨‹å®‰å…¨ | âœ… | âœ… |
| **ç»“æ„ä½“** | 1.0+ | âœ… | âœ… | âš ï¸ å­—æ®µéœ€ä¿æŠ¤ | âœ… | âœ… |
| **æ¥å£** | 1.0+ | âœ… | âœ… | âœ… | âœ… | âœ… |
| **æŒ‡é’ˆ** | 1.0+ | âœ… | âœ… | âš ï¸ éœ€åŒæ­¥ | âœ… | âœ… |
| **å‡½æ•°** | 1.0+ | âœ… | âœ… | âœ… ä¸å¯å˜ | âœ… | âœ… |
| **Goroutine** | 1.0+ | âœ… `go` | âœ… | âœ… CSPæ¨¡å‹ | âœ… | âœ… |
| **Channel** | 1.0+ | âœ… `chan` | âœ… | âœ… åŒæ­¥åŸè¯­ | âœ… HB | âœ… |
| **Select** | 1.0+ | âœ… | âœ… | âœ… å¤šè·¯å¤ç”¨ | âœ… | âœ… |
| **Defer** | 1.0+ | âœ… | âœ… | âš ï¸ æ‰§è¡Œé¡ºåº | âœ… | âœ… |
| **Panic/Recover** | 1.0+ | âœ… | âœ… | âš ï¸ goroutineéš”ç¦» | âœ… | âš ï¸ |
| **æ³›å‹** | 1.18+ | âœ… `[T any]` | âœ… çº¦æŸ | âœ… | âœ… | âœ… |
| **ç±»å‹å‚æ•°** | 1.18+ | âœ… | âœ… | N/A | âœ… | âœ… |
| **ç±»å‹çº¦æŸ** | 1.18+ | âœ… `interface` | âœ… å­ç±»å‹ | N/A | âœ… | âœ… |
| **fuzzing** | 1.18+ | âœ… | âœ… | âœ… | âœ… | âš ï¸ |
| **å·¥ä½œåŒºæ¨¡å¼** | 1.18+ | âœ… `go.work` | N/A | N/A | N/A | âœ… |
| **PGOä¼˜åŒ–** | 1.20+ | N/A | N/A | âœ… | âœ… | âœ… |
| **for-range over integers** | 1.22+ | âœ… | âœ… | N/A | âœ… | âœ… |
| **range over func** | 1.23+ | âœ… | âœ… | âš ï¸ è¿­ä»£å™¨ | âœ… | âš ï¸ |

### 8.2 è¯­ä¹‰ä¸€è‡´æ€§çŸ©é˜µ

| è¯­ä¹‰ç±»å‹ | å®Œå¤‡æ€§ | ä¸€è‡´æ€§ | å®ç°éš¾åº¦ | è¯æ˜éš¾åº¦ | åº”ç”¨åœºæ™¯ |
|---------|-------|-------|---------|---------|---------|
| **æ“ä½œè¯­ä¹‰** (å°æ­¥) | â­â­â­â­â­ | â­â­â­â­â­ | ä¸­ç­‰ | ä¸­ç­‰ | ç¨‹åºæ‰§è¡Œæ¨¡æ‹Ÿã€è°ƒè¯•å™¨ |
| **æ“ä½œè¯­ä¹‰** (å¤§æ­¥) | â­â­â­â­ | â­â­â­â­â­ | ç®€å• | ç®€å• | æ±‚å€¼å™¨ã€è§£é‡Šå™¨ |
| **æŒ‡ç§°è¯­ä¹‰** | â­â­â­â­â­ | â­â­â­â­ | å›°éš¾ | å›°éš¾ | ç¼–è¯‘å™¨ä¼˜åŒ–ã€ç¨‹åºåˆ†æ |
| **å…¬ç†è¯­ä¹‰** | â­â­â­ | â­â­â­â­â­ | ä¸­ç­‰ | ä¸­ç­‰ | ç¨‹åºéªŒè¯ã€å½¢å¼åŒ–è¯æ˜ |
| **CSPå¹¶å‘è¯­ä¹‰** | â­â­â­â­ | â­â­â­â­ | å›°éš¾ | å›°éš¾ | å¹¶å‘æ­£ç¡®æ€§éªŒè¯ |

---

## 9. æ€»ç»“ä¸å±•æœ›

### 9.1 Goè¯­è¨€å½¢å¼åŒ–ä½“ç³»æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†Go 1.23è¯­è¨€çš„å®Œæ•´å½¢å¼åŒ–åˆ†æï¼ŒåŒ…æ‹¬ï¼š

1. **è¯­æ³•å±‚é¢**
   - å®Œæ•´çš„EBNFè¯­æ³•è§„èŒƒ
   - æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰å®šä¹‰
   - è¯­æ³•åˆ°è¯­ä¹‰çš„æ˜ å°„

2. **è¯­ä¹‰å±‚é¢**
   - æ“ä½œè¯­ä¹‰ï¼ˆå°æ­¥ã€å¤§æ­¥ï¼‰
   - æŒ‡ç§°è¯­ä¹‰
   - å…¬ç†è¯­ä¹‰ï¼ˆHoareé€»è¾‘ï¼‰

3. **ç±»å‹ç³»ç»Ÿ**
   - ç±»å‹åˆ¤æ–­è§„åˆ™
   - ç±»å‹å®‰å…¨æ€§è¯æ˜ï¼ˆProgress + Preservationï¼‰
   - æ³›å‹ç³»ç»Ÿå½¢å¼åŒ–

4. **å¹¶å‘æ¨¡å‹**
   - CSPè¿›ç¨‹ä»£æ•°
   - Goroutineå’ŒChannelè¯­ä¹‰
   - å¹¶å‘æ­£ç¡®æ€§è¯æ˜

5. **å†…å­˜æ¨¡å‹**
   - Happens-Beforeå…³ç³»
   - æ•°æ®ç«äº‰å½¢å¼åŒ–å®šä¹‰
   - DRF-SCä¿è¯

6. **å¯è§†åŒ–ä½“ç³»**
   - æ€ç»´å¯¼å›¾ï¼šç›´è§‚å±•ç¤ºè¯­è¨€ç»“æ„
   - çŸ¥è¯†çŸ©é˜µï¼šç³»ç»ŸåŒ–æ¢³ç†ç‰¹æ€§
   - å…³ç³»å›¾ï¼šæ¸…æ™°è¡¨è¾¾å±æ€§å…³ç³»

### 9.2 å½¢å¼åŒ–æ–¹æ³•çš„ä»·å€¼

**ç†è®ºä»·å€¼**:

- ç²¾ç¡®å®šä¹‰è¯­è¨€è¯­ä¹‰
- è¯æ˜è¯­è¨€æ€§è´¨ï¼ˆç±»å‹å®‰å…¨ã€å¹¶å‘æ­£ç¡®æ€§ï¼‰
- ä¸ºç¼–è¯‘å™¨ä¼˜åŒ–æä¾›ç†è®ºåŸºç¡€

**å®è·µä»·å€¼**:

- ç¼–è¯‘å™¨å¼€å‘ï¼ˆç±»å‹æ£€æŸ¥ã€ä¼˜åŒ–ï¼‰
- ç¨‹åºéªŒè¯å·¥å…·
- é™æ€åˆ†æå·¥å…·
- å¹¶å‘bugæ£€æµ‹

**æ•™è‚²ä»·å€¼**:

- æ·±å…¥ç†è§£Goè¯­è¨€
- å­¦ä¹ å½¢å¼åŒ–æ–¹æ³•
- åŸ¹å…»ä¸¥è°¨çš„ç¼–ç¨‹æ€ç»´

### 9.3 æœªæ¥å·¥ä½œæ–¹å‘

**ç†è®ºæ‰©å±•**:

- å®Œå–„panic/recoverçš„å½¢å¼åŒ–è¯­ä¹‰
- range over funcè¿­ä»£å™¨çš„å½¢å¼åŒ–
- contextåŒ…çš„å½¢å¼åŒ–å»ºæ¨¡
- reflectåŒ…çš„ç±»å‹ç³»ç»Ÿæ‰©å±•

**å·¥å…·å¼€å‘**:

- åŸºäºå½¢å¼åŒ–è¯­ä¹‰çš„éªŒè¯å™¨
- è‡ªåŠ¨åŒ–å®šç†è¯æ˜å·¥å…·
- å¹¶å‘ç¨‹åºæ¨¡å‹æ£€æŸ¥å™¨
- ç±»å‹æ¨å¯¼å¼•æ“

**åº”ç”¨æ‹“å±•**:

- å½¢å¼åŒ–æ–¹æ³•åœ¨å¤§å‹é¡¹ç›®ä¸­çš„åº”ç”¨
- ä¸å·¥ä¸šç•Œå·¥å…·çš„é›†æˆ
- æ€§èƒ½åˆ†æä¸ä¼˜åŒ–
- å®‰å…¨æ€§åˆ†æ

---

## 10. å‚è€ƒèµ„æº

### 10.1 Goè¯­è¨€è§„èŒƒ

- [The Go Programming Language Specification](https://go.dev/ref/spec)
- [Go Memory Model](https://go.dev/ref/mem)
- [Go Data Race Detector](https://go.dev/doc/articles/race_detector)

### 10.2 å½¢å¼åŒ–ç†è®º

**ä¹¦ç±**:

- *Types and Programming Languages* - Benjamin C. Pierce
- *Practical Foundations for Programming Languages* - Robert Harper
- *Communicating Sequential Processes* - C.A.R. Hoare
- *Principles of Program Analysis* - Flemming Nielson et al.

**è®ºæ–‡**:

- "The Go Memory Model" - Russ Cox (2021)
- "Featherweight Go" - Griesemer et al. (2020)
- "Type Parameters Proposal" - Go Team (2021)

### 10.3 ç›¸å…³å·¥å…·

- **go/types**: Goç±»å‹æ£€æŸ¥å™¨
- **go/ast**: GoæŠ½è±¡è¯­æ³•æ ‘
- **go/parser**: Goè¯­æ³•è§£æå™¨
- **go vet**: é™æ€åˆ†æå·¥å…·
- **race detector**: æ•°æ®ç«äº‰æ£€æµ‹å™¨

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**åˆ›å»ºæ—¥æœŸ**: 2025å¹´10æœˆ24æ—¥  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ24æ—¥  
**æ–‡æ¡£çŠ¶æ€**: å®Œæˆ âœ…  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.23+  
**æ–‡æ¡£è¡Œæ•°**: 2,800+è¡Œ  
**åŒ…å«å†…å®¹**:

- 10ä¸ªä¸»è¦ç« èŠ‚
- 8ä¸ªè¯¦ç»†æ€ç»´å¯¼å›¾
- 12ä¸ªçŸ¥è¯†çŸ©é˜µè¡¨æ ¼
- 3ä¸ªå®Œæ•´å½¢å¼åŒ–è¯æ˜
- 100+ä¸ªå½¢å¼åŒ–è§„åˆ™
- 50+ä¸ªä»£ç ç¤ºä¾‹
