# Goè¯­è¨€æŽ¥å£

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äºŽ**: Go 1.25.3+

---

## ðŸ“‹ ç›®å½•

- [Goè¯­è¨€æŽ¥å£](#goè¯­è¨€æŽ¥å£)
  - [ðŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ðŸ“š ç†è®ºåˆ†æž](#-ç†è®ºåˆ†æž)
    - [æŽ¥å£çš„å½¢å¼åŒ–å®šä¹‰](#æŽ¥å£çš„å½¢å¼åŒ–å®šä¹‰)
    - [æŽ¥å£çš„æœ¬è´¨](#æŽ¥å£çš„æœ¬è´¨)
    - [é¸­å­ç±»åž‹ä¸Žç»“æž„åŒ–ç±»åž‹](#é¸­å­ç±»åž‹ä¸Žç»“æž„åŒ–ç±»åž‹)
  - [ðŸ’» ä»£ç å®žçŽ°](#-ä»£ç å®žçŽ°)
    - [æŽ¥å£å®šä¹‰ä¸Žå®žçŽ°](#æŽ¥å£å®šä¹‰ä¸Žå®žçŽ°)
    - [ç©ºæŽ¥å£](#ç©ºæŽ¥å£)
    - [ç±»åž‹æ–­è¨€](#ç±»åž‹æ–­è¨€)
    - [ç±»åž‹é€‰æ‹©](#ç±»åž‹é€‰æ‹©)
    - [æŽ¥å£ç»„åˆ](#æŽ¥å£ç»„åˆ)
    - [æŽ¥å£å€¼](#æŽ¥å£å€¼)
  - [ðŸ“Š æ€§èƒ½åˆ†æž](#-æ€§èƒ½åˆ†æž)
  - [ðŸ§ª æµ‹è¯•ä»£ç ](#-æµ‹è¯•ä»£ç )
  - [ðŸŽ¯ æœ€ä½³å®žè·µ](#-æœ€ä½³å®žè·µ)
    - [1. æŽ¥å£è®¾è®¡åŽŸåˆ™](#1-æŽ¥å£è®¾è®¡åŽŸåˆ™)
    - [2. æŽ¥å—æŽ¥å£ï¼Œè¿”å›žç»“æž„](#2-æŽ¥å—æŽ¥å£è¿”å›žç»“æž„)
    - [3. æŽ¥å£å‘½åçº¦å®š](#3-æŽ¥å£å‘½åçº¦å®š)
    - [4. é›¶å€¼æŽ¥å£æ£€æŸ¥](#4-é›¶å€¼æŽ¥å£æ£€æŸ¥)
    - [5. ä½¿ç”¨ç±»åž‹æ–­è¨€è¿›è¡ŒåŠŸèƒ½æŽ¢æµ‹](#5-ä½¿ç”¨ç±»åž‹æ–­è¨€è¿›è¡ŒåŠŸèƒ½æŽ¢æµ‹)
  - [ðŸ” å¸¸è§é—®é¢˜](#-å¸¸è§é—®é¢˜)
    - [Q1: å¦‚ä½•åˆ¤æ–­ä¸€ä¸ªç±»åž‹å®žçŽ°äº†æŸä¸ªæŽ¥å£ï¼Ÿ](#q1-å¦‚ä½•åˆ¤æ–­ä¸€ä¸ªç±»åž‹å®žçŽ°äº†æŸä¸ªæŽ¥å£)
    - [Q2: æŽ¥å£çš„nilå€¼æ˜¯ä»€ä¹ˆï¼Ÿ](#q2-æŽ¥å£çš„nilå€¼æ˜¯ä»€ä¹ˆ)
    - [Q3: ç©ºæŽ¥å£æœ‰ä»€ä¹ˆç”¨é€”ï¼Ÿ](#q3-ç©ºæŽ¥å£æœ‰ä»€ä¹ˆç”¨é€”)
    - [Q4: æŽ¥å£çš„æ€§èƒ½å¼€é”€æœ‰å¤šå¤§ï¼Ÿ](#q4-æŽ¥å£çš„æ€§èƒ½å¼€é”€æœ‰å¤šå¤§)
    - [Q5: å€¼ç±»åž‹å’ŒæŒ‡é’ˆç±»åž‹å“ªä¸ªåº”è¯¥å®žçŽ°æŽ¥å£ï¼Ÿ](#q5-å€¼ç±»åž‹å’ŒæŒ‡é’ˆç±»åž‹å“ªä¸ªåº”è¯¥å®žçŽ°æŽ¥å£)
  - [ðŸ“š æ‰©å±•é˜…è¯»](#-æ‰©å±•é˜…è¯»)
    - [ç›¸å…³æ¦‚å¿µ](#ç›¸å…³æ¦‚å¿µ)
    - [è¿›é˜¶ä¸»é¢˜](#è¿›é˜¶ä¸»é¢˜)

## ðŸ“š ç†è®ºåˆ†æž

### æŽ¥å£çš„å½¢å¼åŒ–å®šä¹‰

Goè¯­è¨€ä¸­æŽ¥å£çš„å½¢å¼åŒ–å®šä¹‰ï¼š

```text
InterfaceType ::= "interface" "{" MethodSpec* "}"
MethodSpec ::= MethodName Signature
```

æŽ¥å£å®šä¹‰äº†ä¸€ç»„æ–¹æ³•ç­¾åçš„é›†åˆï¼Œä»»ä½•å®žçŽ°äº†è¿™äº›æ–¹æ³•çš„ç±»åž‹éƒ½éšå¼åœ°å®žçŽ°äº†è¯¥æŽ¥å£ã€‚

### æŽ¥å£çš„æœ¬è´¨

æŽ¥å£åœ¨è¿è¡Œæ—¶çš„è¡¨ç¤ºï¼š

```go
// æŽ¥å£çš„å†…éƒ¨ç»“æž„ï¼ˆç®€åŒ–ï¼‰
type iface struct {
    tab  *itab          // ç±»åž‹ä¿¡æ¯å’Œæ–¹æ³•è¡¨
    data unsafe.Pointer // æŒ‡å‘å®žé™…æ•°æ®
}

type itab struct {
    inter *interfacetype // æŽ¥å£ç±»åž‹
    _type *_type         // å®žé™…ç±»åž‹
    fun   [1]uintptr     // æ–¹æ³•è¡¨
}
```

### é¸­å­ç±»åž‹ä¸Žç»“æž„åŒ–ç±»åž‹

Goçš„æŽ¥å£é‡‡ç”¨**ç»“æž„åŒ–ç±»åž‹ç³»ç»Ÿ**ï¼ˆStructural Typingï¼‰

- "å¦‚æžœä¸€ä¸ªä¸œè¥¿èµ°èµ·æ¥åƒé¸­å­ï¼Œå«èµ·æ¥åƒé¸­å­ï¼Œé‚£å®ƒå°±æ˜¯é¸­å­"
- æ— éœ€æ˜¾å¼å£°æ˜Žå®žçŽ°å…³ç³»
- ç¼–è¯‘æ—¶å’Œè¿è¡Œæ—¶éƒ½ä¼šæ£€æŸ¥ç±»åž‹å…¼å®¹æ€§

## ðŸ’» ä»£ç å®žçŽ°

### æŽ¥å£å®šä¹‰ä¸Žå®žçŽ°

```go
package main

import (
    "fmt"
    "math"
)

// Shape å‡ ä½•å½¢çŠ¶æŽ¥å£
type Shape interface {
    Area() float64
    Perimeter() float64
}

// Circle åœ†å½¢
type Circle struct {
    Radius float64
}

// Area å®žçŽ°ShapeæŽ¥å£çš„Areaæ–¹æ³•
func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

// Perimeter å®žçŽ°ShapeæŽ¥å£çš„Perimeteræ–¹æ³•
func (c Circle) Perimeter() float64 {
    return 2 * math.Pi * c.Radius
}

// Rectangle çŸ©å½¢
type Rectangle struct {
    Width, Height float64
}

// Area å®žçŽ°ShapeæŽ¥å£çš„Areaæ–¹æ³•
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

// Perimeter å®žçŽ°ShapeæŽ¥å£çš„Perimeteræ–¹æ³•
func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

// PrintShapeInfo æ‰“å°å›¾å½¢ä¿¡æ¯ï¼ˆæŽ¥å—ShapeæŽ¥å£ï¼‰
func PrintShapeInfo(s Shape) {
    fmt.Printf("Area: %.2f, Perimeter: %.2f\n", s.Area(), s.Perimeter())
}

func main() {
    circle := Circle{Radius: 5}
    rectangle := Rectangle{Width: 4, Height: 6}

    // æŽ¥å£å¤šæ€æ€§
    PrintShapeInfo(circle)
    PrintShapeInfo(rectangle)

    // æŽ¥å£åˆ‡ç‰‡
    shapes := []Shape{
        Circle{Radius: 3},
        Rectangle{Width: 2, Height: 4},
        Circle{Radius: 7},
    }

    totalArea := 0.0
    for _, shape := range shapes {
        totalArea += shape.Area()
    }
    fmt.Printf("Total Area: %.2f\n", totalArea)
}
```

### ç©ºæŽ¥å£

```go
package main

import "fmt"

// ç©ºæŽ¥å£å¯ä»¥æŒæœ‰ä»»ä½•ç±»åž‹çš„å€¼
func printAnything(v interface{}) {
    fmt.Printf("Value: %v, Type: %T\n", v, v)
}

// ä½¿ç”¨ç©ºæŽ¥å£å®žçŽ°é€šç”¨å®¹å™¨
type Container struct {
    items []interface{}
}

func (c *Container) Add(item interface{}) {
    c.items = append(c.items, item)
}

func (c *Container) Get(index int) interface{} {
    if index >= 0 && index < len(c.items) {
        return c.items[index]
    }
    return nil
}

func (c *Container) Size() int {
    return len(c.items)
}

func main() {
    // ç©ºæŽ¥å£å¯ä»¥æŽ¥å—ä»»ä½•ç±»åž‹
    printAnything(42)
    printAnything("Hello")
    printAnything(3.14)
    printAnything(true)
    printAnything([]int{1, 2, 3})

    // ä½¿ç”¨é€šç”¨å®¹å™¨
    container := &Container{}
    container.Add(100)
    container.Add("Go")
    container.Add(2.718)

    for i := 0; i < container.Size(); i++ {
        item := container.Get(i)
        fmt.Printf("Item %d: %v (type: %T)\n", i, item, item)
    }
}
```

### ç±»åž‹æ–­è¨€

```go
package main

import (
    "fmt"
    "math"
)

// Shape æŽ¥å£
type Shape interface {
    Area() float64
}

// Circle åœ†å½¢
type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

// Rectangle çŸ©å½¢
type Rectangle struct {
    Width, Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

// ç±»åž‹æ–­è¨€ç¤ºä¾‹
func describeShape(s Shape) {
    fmt.Printf("Area: %.2f\n", s.Area())

    // å•å€¼ç±»åž‹æ–­è¨€ï¼ˆpanic if failsï¼‰
    // circle := s.(Circle)

    // åŒå€¼ç±»åž‹æ–­è¨€ï¼ˆå®‰å…¨ï¼‰
    if circle, ok := s.(Circle); ok {
        fmt.Printf("Circle with radius: %.2f\n", circle.Radius)
    } else if rectangle, ok := s.(Rectangle); ok {
        fmt.Printf("Rectangle with width: %.2f, height: %.2f\n",
            rectangle.Width, rectangle.Height)
    } else {
        fmt.Println("Unknown shape")
    }
}

// ä»Žç©ºæŽ¥å£æ¢å¤ç±»åž‹
func processValue(v interface{}) {
    // å®‰å…¨çš„ç±»åž‹æ–­è¨€
    if str, ok := v.(string); ok {
        fmt.Printf("String value: %s\n", str)
        return
    }

    if num, ok := v.(int); ok {
        fmt.Printf("Integer value: %d\n", num)
        return
    }

    if f, ok := v.(float64); ok {
        fmt.Printf("Float value: %.2f\n", f)
        return
    }

    fmt.Printf("Unknown type: %T\n", v)
}

func main() {
    circle := Circle{Radius: 5}
    rectangle := Rectangle{Width: 4, Height: 6}

    describeShape(circle)
    describeShape(rectangle)

    fmt.Println("\nProcessing values:")
    processValue("Hello")
    processValue(42)
    processValue(3.14)
    processValue(true)
}
```

### ç±»åž‹é€‰æ‹©

```go
package main

import "fmt"

// ä½¿ç”¨type switchè¿›è¡Œç±»åž‹é€‰æ‹©
func processValue(v interface{}) {
    switch value := v.(type) {
    case string:
        fmt.Printf("String: %s (length: %d)\n", value, len(value))
    case int:
        fmt.Printf("Integer: %d (double: %d)\n", value, value*2)
    case float64:
        fmt.Printf("Float: %.2f (squared: %.2f)\n", value, value*value)
    case bool:
        fmt.Printf("Boolean: %t (negated: %t)\n", value, !value)
    case []int:
        fmt.Printf("Integer slice: %v (length: %d)\n", value, len(value))
    case nil:
        fmt.Println("Nil value")
    default:
        fmt.Printf("Unknown type: %T with value: %v\n", value, value)
    }
}

// æ›´å¤æ‚çš„ç±»åž‹é€‰æ‹©
func handleValue(v interface{}) string {
    switch v := v.(type) {
    case string:
        return "text: " + v
    case int, int64, int32:
        return fmt.Sprintf("integer: %v", v)
    case float32, float64:
        return fmt.Sprintf("float: %v", v)
    case []interface{}:
        return fmt.Sprintf("array with %d elements", len(v))
    case map[string]interface{}:
        return fmt.Sprintf("object with %d keys", len(v))
    default:
        return fmt.Sprintf("unknown: %T", v)
    }
}

func main() {
    values := []interface{}{
        "Hello, Go!",
        42,
        3.14159,
        true,
        []int{1, 2, 3, 4, 5},
        nil,
        struct{ Name string }{"Alice"},
    }

    for i, v := range values {
        fmt.Printf("%d. ", i+1)
        processValue(v)
    }

    fmt.Println("\nHandling values:")
    fmt.Println(handleValue("test"))
    fmt.Println(handleValue(123))
    fmt.Println(handleValue(3.14))
}
```

### æŽ¥å£ç»„åˆ

```go
package main

import "fmt"

// Reader è¯»å–æŽ¥å£
type Reader interface {
    Read() string
}

// Writer å†™å…¥æŽ¥å£
type Writer interface {
    Write(data string) error
}

// Closer å…³é—­æŽ¥å£
type Closer interface {
    Close() error
}

// ReadWriter ç»„åˆæŽ¥å£
type ReadWriter interface {
    Reader
    Writer
}

// ReadWriteCloser å¤šé‡ç»„åˆæŽ¥å£
type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}

// File å®žçŽ°ReadWriteCloseræŽ¥å£
type File struct {
    name   string
    buffer string
    closed bool
}

func (f *File) Read() string {
    if f.closed {
        return ""
    }
    return f.buffer
}

func (f *File) Write(data string) error {
    if f.closed {
        return fmt.Errorf("file is closed")
    }
    f.buffer += data
    return nil
}

func (f *File) Close() error {
    if f.closed {
        return fmt.Errorf("file already closed")
    }
    f.closed = true
    return nil
}

// ä½¿ç”¨ç»„åˆæŽ¥å£
func processReadWriter(rw ReadWriter) {
    fmt.Println("Reading:", rw.Read())
    rw.Write("new data")
    fmt.Println("After writing:", rw.Read())
}

func processReadWriteCloser(rwc ReadWriteCloser) {
    fmt.Println("Reading:", rwc.Read())
    rwc.Write("additional data")
    fmt.Println("After writing:", rwc.Read())
    rwc.Close()
}

func main() {
    file := &File{name: "test.txt", buffer: "initial content"}

    // Fileå®žçŽ°äº†æ‰€æœ‰ç»„åˆæŽ¥å£
    processReadWriter(file)

    file2 := &File{name: "test2.txt", buffer: "content"}
    processReadWriteCloser(file2)
}
```

### æŽ¥å£å€¼

```go
package main

import "fmt"

type Stringer interface {
    String() string
}

type Person struct {
    Name string
    Age  int
}

func (p Person) String() string {
    return fmt.Sprintf("%s (%d years old)", p.Name, p.Age)
}

// æŽ¥å£å€¼çš„nilæ£€æŸ¥
func describe(s Stringer) {
    fmt.Printf("Interface value: (%v, %T)\n", s, s)

    if s == nil {
        fmt.Println("Interface is nil")
        return
    }

    fmt.Printf("String: %s\n", s.String())
}

// æŽ¥å£å€¼ä¸Žnil
func interfaceNilExample() {
    var s Stringer
    fmt.Println("Uninitialized interface:")
    describe(s)

    var p *Person
    s = p
    fmt.Println("\nInterface with nil pointer:")
    describe(s) // æŽ¥å£ä¸æ˜¯nilï¼Œä½†åŒ…å«nilæŒ‡é’ˆ

    // å®‰å…¨çš„è°ƒç”¨
    if s != nil {
        // éœ€è¦æ£€æŸ¥å†…éƒ¨å€¼
        if p, ok := s.(*Person); ok && p != nil {
            fmt.Println(p.String())
        } else {
            fmt.Println("Person pointer is nil")
        }
    }

    s = Person{Name: "Alice", Age: 25}
    fmt.Println("\nInterface with concrete value:")
    describe(s)
}

func main() {
    interfaceNilExample()
}
```

## ðŸ“Š æ€§èƒ½åˆ†æž

```go
package main

import (
    "testing"
)

type Adder interface {
    Add(a, b int) int
}

type Calculator struct{}

func (c Calculator) Add(a, b int) int {
    return a + b
}

func directCall(a, b int) int {
    calc := Calculator{}
    return calc.Add(a, b)
}

func interfaceCall(a, b int) int {
    var adder Adder = Calculator{}
    return adder.Add(a, b)
}

// åŸºå‡†æµ‹è¯•ï¼šç›´æŽ¥è°ƒç”¨
func BenchmarkDirectCall(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = directCall(1, 2)
    }
}

// åŸºå‡†æµ‹è¯•ï¼šé€šè¿‡æŽ¥å£è°ƒç”¨
func BenchmarkInterfaceCall(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = interfaceCall(1, 2)
    }
}

// ç©ºæŽ¥å£æ€§èƒ½æµ‹è¯•
func BenchmarkEmptyInterface(b *testing.B) {
    var v interface{} = 42
    for i := 0; i < b.N; i++ {
        _, _ = v.(int)
    }
}

// ç±»åž‹æ–­è¨€æ€§èƒ½æµ‹è¯•
func BenchmarkTypeAssertion(b *testing.B) {
    var v interface{} = "hello"
    for i := 0; i < b.N; i++ {
        if _, ok := v.(string); ok {
            _ = ok
        }
    }
}
```

## ðŸ§ª æµ‹è¯•ä»£ç 

```go
package main

import (
    "testing"
)

func TestShapeArea(t *testing.T) {
    tests := []struct {
        name  string
        shape Shape
        want  float64
    }{
        {"circle", Circle{Radius: 1}, 3.14159},
        {"rectangle", Rectangle{Width: 2, Height: 3}, 6.0},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := tt.shape.Area()
            if diff := got - tt.want; diff > 0.0001 || diff < -0.0001 {
                t.Errorf("Area() = %v, want %v", got, tt.want)
            }
        })
    }
}

func TestTypeAssertion(t *testing.T) {
    var s Shape = Circle{Radius: 5}

    circle, ok := s.(Circle)
    if !ok {
        t.Error("Type assertion to Circle failed")
    }

    if circle.Radius != 5 {
        t.Errorf("Radius = %v, want 5", circle.Radius)
    }

    _, ok = s.(Rectangle)
    if ok {
        t.Error("Type assertion to Rectangle should fail")
    }
}
```

## ðŸŽ¯ æœ€ä½³å®žè·µ

### 1. æŽ¥å£è®¾è®¡åŽŸåˆ™

```go
// âœ… å°è€Œä¸“æ³¨çš„æŽ¥å£
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

// âœ… é€šè¿‡ç»„åˆæž„å»ºå¤æ‚æŽ¥å£
type ReadWriter interface {
    Reader
    Writer
}

// âŒ é¿å…åºžå¤§çš„æŽ¥å£
// type BigInterface interface {
//     Method1()
//     Method2()
//     Method3()
//     ...
//     Method20()
// }
```

### 2. æŽ¥å—æŽ¥å£ï¼Œè¿”å›žç»“æž„

```go
// âœ… å¥½çš„è®¾è®¡
func ProcessData(r io.Reader) (*Result, error) {
    // ...
}

// âŒ ä¸å¥½çš„è®¾è®¡
func ProcessData(r *os.File) (*Result, error) {
    // é™åˆ¶äº†è¾“å…¥ç±»åž‹
}
```

### 3. æŽ¥å£å‘½åçº¦å®š

```go
// âœ… å•æ–¹æ³•æŽ¥å£ç”¨-eråŽç¼€
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Stringer interface {
    String() string
}

// âœ… å¤šæ–¹æ³•æŽ¥å£ç”¨åè¯
type File interface {
    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
    Close() error
}
```

### 4. é›¶å€¼æŽ¥å£æ£€æŸ¥

```go
func safeCall(s Stringer) {
    // æ£€æŸ¥æŽ¥å£æ˜¯å¦ä¸ºnil
    if s == nil {
        fmt.Println("Stringer is nil")
        return
    }

    // æ£€æŸ¥æŽ¥å£åŒ…å«çš„å€¼æ˜¯å¦ä¸ºnil
    // è¿™éœ€è¦æ ¹æ®å…·ä½“ç±»åž‹è¿›è¡Œ
    fmt.Println(s.String())
}
```

### 5. ä½¿ç”¨ç±»åž‹æ–­è¨€è¿›è¡ŒåŠŸèƒ½æŽ¢æµ‹

```go
func writeData(w io.Writer, data []byte) error {
    // æ£€æŸ¥æ˜¯å¦æ”¯æŒæ›´é«˜æ•ˆçš„æ–¹æ³•
    if wt, ok := w.(io.WriterTo); ok {
        _, err := wt.WriteTo(w)
        return err
    }

    // å›žé€€åˆ°æ ‡å‡†æ–¹æ³•
    _, err := w.Write(data)
    return err
}
```

## ðŸ” å¸¸è§é—®é¢˜

### Q1: å¦‚ä½•åˆ¤æ–­ä¸€ä¸ªç±»åž‹å®žçŽ°äº†æŸä¸ªæŽ¥å£ï¼Ÿ

A: ç¼–è¯‘æ—¶ç”±ç¼–è¯‘å™¨è‡ªåŠ¨æ£€æŸ¥ã€‚è¿è¡Œæ—¶å¯ä»¥ä½¿ç”¨ç±»åž‹æ–­è¨€ï¼š

```go
var _ Shape = (*Circle)(nil) // ç¼–è¯‘æ—¶æ£€æŸ¥
_, ok := someValue.(Shape)   // è¿è¡Œæ—¶æ£€æŸ¥
```

### Q2: æŽ¥å£çš„nilå€¼æ˜¯ä»€ä¹ˆï¼Ÿ

A: æŽ¥å£çš„é›¶å€¼æ˜¯nilï¼Œè¡¨ç¤ºæ—¢æ²¡æœ‰ç±»åž‹ä¹Ÿæ²¡æœ‰å€¼ã€‚ä½†æŽ¥å£å¯ä»¥åŒ…å«nilå€¼ï¼Œæ­¤æ—¶æŽ¥å£ä¸æ˜¯nilï¼š

```go
var i interface{} = (*int)(nil)
fmt.Println(i == nil) // false! æŽ¥å£æœ‰ç±»åž‹(*int)ä½†å€¼ä¸ºnil
```

### Q3: ç©ºæŽ¥å£æœ‰ä»€ä¹ˆç”¨é€”ï¼Ÿ

A: ç©ºæŽ¥å£`interface{}`å¯ä»¥æŒæœ‰ä»»ä½•ç±»åž‹çš„å€¼ï¼Œå¸¸ç”¨äºŽï¼š

- é€šç”¨å®¹å™¨ï¼ˆå¦‚`fmt.Println`æŽ¥å—ä»»æ„ç±»åž‹ï¼‰
- JSONè§£æžçš„åŠ¨æ€æ•°æ®
- åå°„æ“ä½œ

### Q4: æŽ¥å£çš„æ€§èƒ½å¼€é”€æœ‰å¤šå¤§ï¼Ÿ

A: æŽ¥å£è°ƒç”¨æ¯”ç›´æŽ¥è°ƒç”¨ç•¥æ…¢ï¼ˆçº¦1-2nsï¼‰ï¼Œå› ä¸ºéœ€è¦é€šè¿‡æ–¹æ³•è¡¨æŸ¥æ‰¾ã€‚ä½†è¿™é€šå¸¸ä¸æ˜¯æ€§èƒ½ç“¶é¢ˆã€‚

### Q5: å€¼ç±»åž‹å’ŒæŒ‡é’ˆç±»åž‹å“ªä¸ªåº”è¯¥å®žçŽ°æŽ¥å£ï¼Ÿ

A:

- å¦‚æžœæ–¹æ³•éœ€è¦ä¿®æ”¹æŽ¥æ”¶è€…ï¼Œä½¿ç”¨æŒ‡é’ˆç±»åž‹
- å¦‚æžœæŽ¥æ”¶è€…å¾ˆå¤§ï¼Œä½¿ç”¨æŒ‡é’ˆç±»åž‹ï¼ˆé¿å…æ‹·è´ï¼‰
- ä¿æŒä¸€è‡´æ€§ï¼šå¦‚æžœæŸä¸ªæ–¹æ³•ä½¿ç”¨æŒ‡é’ˆï¼Œå…¶ä»–æ–¹æ³•ä¹Ÿåº”è¯¥ä½¿ç”¨æŒ‡é’ˆ

## ðŸ“š æ‰©å±•é˜…è¯»

### ç›¸å…³æ¦‚å¿µ

- [æ–¹æ³•](./06-æ–¹æ³•.md)
- [ç»“æž„ä½“](./08-ç»“æž„ä½“.md)
- [é”™è¯¯å¤„ç†](./11-é”™è¯¯å¤„ç†.md)

### è¿›é˜¶ä¸»é¢˜

- æŽ¥å£çš„å†…éƒ¨å®žçŽ°
- æŽ¥å£ä¸Žåå°„
- æŽ¥å£æœ€ä½³å®žè·µæ¨¡å¼
- Goæ ‡å‡†åº“ä¸­çš„æŽ¥å£è®¾è®¡

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team
**æœ€åŽæ›´æ–°**: 2025-10-29
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
