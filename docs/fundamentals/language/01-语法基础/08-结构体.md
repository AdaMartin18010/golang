# Goè¯­è¨€ç»“æ„ä½“

> **ç®€ä»‹**: æ·±å…¥è®²è§£Goè¯­è¨€çš„ç»“æ„ä½“å®šä¹‰ã€åˆå§‹åŒ–ã€åµŒå¥—ã€æ ‡ç­¾å’Œæ–¹æ³•
> **ç‰ˆæœ¬**: Go 1.25.3+  
> **éš¾åº¦**: â­â­  
> **æ ‡ç­¾**: #åŸºç¡€ #ç»“æ„ä½“ #ç»„åˆ #åµŒå…¥

<!-- TOC START -->
- [Goè¯­è¨€ç»“æ„ä½“](#goè¯­è¨€ç»“æ„ä½“)
  - [ğŸ“š ç†è®ºåˆ†æ](#-ç†è®ºåˆ†æ)
    - [ç»“æ„ä½“çš„å½¢å¼åŒ–å®šä¹‰](#ç»“æ„ä½“çš„å½¢å¼åŒ–å®šä¹‰)
    - [å†…å­˜å¸ƒå±€](#å†…å­˜å¸ƒå±€)
  - [ğŸ’» ä»£ç å®ç°](#-ä»£ç å®ç°)
    - [ç»“æ„ä½“å®šä¹‰ä¸åˆå§‹åŒ–](#ç»“æ„ä½“å®šä¹‰ä¸åˆå§‹åŒ–)
    - [åŒ¿åå­—æ®µä¸åµŒå…¥](#åŒ¿åå­—æ®µä¸åµŒå…¥)
    - [ç»“æ„ä½“æ ‡ç­¾](#ç»“æ„ä½“æ ‡ç­¾)
    - [ç»“æ„ä½“æ¯”è¾ƒ](#ç»“æ„ä½“æ¯”è¾ƒ)
    - [ç»“æ„ä½“ä½œä¸ºæ˜ å°„é”®](#ç»“æ„ä½“ä½œä¸ºæ˜ å°„é”®)
  - [ğŸ“Š æ€§èƒ½åˆ†æ](#-æ€§èƒ½åˆ†æ)
  - [ğŸ§ª æµ‹è¯•ä»£ç ](#-æµ‹è¯•ä»£ç )
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [1. å­—æ®µæ’åºä¼˜åŒ–å†…å­˜](#1-å­—æ®µæ’åºä¼˜åŒ–å†…å­˜)
    - [2. ä½¿ç”¨æ„é€ å‡½æ•°](#2-ä½¿ç”¨æ„é€ å‡½æ•°)
    - [3. ä½¿ç”¨æŒ‡é’ˆæ¥æ”¶è€…](#3-ä½¿ç”¨æŒ‡é’ˆæ¥æ”¶è€…)
    - [4. æ ‡ç­¾ä½¿ç”¨è§„èŒƒ](#4-æ ‡ç­¾ä½¿ç”¨è§„èŒƒ)
  - [ğŸ” å¸¸è§é—®é¢˜](#-å¸¸è§é—®é¢˜)
    - [Q1: ä»€ä¹ˆæ—¶å€™ä½¿ç”¨ç»“æ„ä½“æŒ‡é’ˆï¼Ÿ](#q1-ä»€ä¹ˆæ—¶å€™ä½¿ç”¨ç»“æ„ä½“æŒ‡é’ˆ)
    - [Q2: åŒ¿åå­—æ®µå’Œå‘½åå­—æ®µæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ](#q2-åŒ¿åå­—æ®µå’Œå‘½åå­—æ®µæœ‰ä»€ä¹ˆåŒºåˆ«)
    - [Q3: å¦‚ä½•æ¯”è¾ƒåŒ…å«åˆ‡ç‰‡çš„ç»“æ„ä½“ï¼Ÿ](#q3-å¦‚ä½•æ¯”è¾ƒåŒ…å«åˆ‡ç‰‡çš„ç»“æ„ä½“)
    - [Q4: ç»“æ„ä½“æ ‡ç­¾æœ‰ä»€ä¹ˆç”¨ï¼Ÿ](#q4-ç»“æ„ä½“æ ‡ç­¾æœ‰ä»€ä¹ˆç”¨)
  - [ğŸ“š æ‰©å±•é˜…è¯»](#-æ‰©å±•é˜…è¯»)
    - [ç›¸å…³æ¦‚å¿µ](#ç›¸å…³æ¦‚å¿µ)
    - [è¿›é˜¶ä¸»é¢˜](#è¿›é˜¶ä¸»é¢˜)
<!-- TOC END -->

## ğŸ“‹ ç›®å½•

- [ğŸ“š ç†è®ºåˆ†æ](#-ç†è®ºåˆ†æ)
  - [ç»“æ„ä½“çš„å½¢å¼åŒ–å®šä¹‰](#ç»“æ„ä½“çš„å½¢å¼åŒ–å®šä¹‰)
  - [å†…å­˜å¸ƒå±€](#å†…å­˜å¸ƒå±€)
- [ğŸ’» ä»£ç å®ç°](#-ä»£ç å®ç°)
  - [ç»“æ„ä½“å®šä¹‰ä¸åˆå§‹åŒ–](#ç»“æ„ä½“å®šä¹‰ä¸åˆå§‹åŒ–)
  - [åŒ¿åå­—æ®µä¸åµŒå…¥](#åŒ¿åå­—æ®µä¸åµŒå…¥)
  - [ç»“æ„ä½“æ ‡ç­¾](#ç»“æ„ä½“æ ‡ç­¾)
  - [ç»“æ„ä½“æ¯”è¾ƒ](#ç»“æ„ä½“æ¯”è¾ƒ)
  - [ç»“æ„ä½“ä½œä¸ºæ˜ å°„é”®](#ç»“æ„ä½“ä½œä¸ºæ˜ å°„é”®)
- [ğŸ“Š æ€§èƒ½åˆ†æ](#-æ€§èƒ½åˆ†æ)
- [ğŸ§ª æµ‹è¯•ä»£ç ](#-æµ‹è¯•ä»£ç )
- [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
  - [1. å­—æ®µæ’åºä¼˜åŒ–å†…å­˜](#1-å­—æ®µæ’åºä¼˜åŒ–å†…å­˜)
  - [2. ä½¿ç”¨æ„é€ å‡½æ•°](#2-ä½¿ç”¨æ„é€ å‡½æ•°)
  - [3. ä½¿ç”¨æŒ‡é’ˆæ¥æ”¶è€…](#3-ä½¿ç”¨æŒ‡é’ˆæ¥æ”¶è€…)
  - [4. æ ‡ç­¾ä½¿ç”¨è§„èŒƒ](#4-æ ‡ç­¾ä½¿ç”¨è§„èŒƒ)
- [ğŸ” å¸¸è§é—®é¢˜](#-å¸¸è§é—®é¢˜)
  - [Q1: ä»€ä¹ˆæ—¶å€™ä½¿ç”¨ç»“æ„ä½“æŒ‡é’ˆï¼Ÿ](#q1-ä»€ä¹ˆæ—¶å€™ä½¿ç”¨ç»“æ„ä½“æŒ‡é’ˆ)
  - [Q2: åŒ¿åå­—æ®µå’Œå‘½åå­—æ®µæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ](#q2-åŒ¿åå­—æ®µå’Œå‘½åå­—æ®µæœ‰ä»€ä¹ˆåŒºåˆ«)
  - [Q3: å¦‚ä½•æ¯”è¾ƒåŒ…å«åˆ‡ç‰‡çš„ç»“æ„ä½“ï¼Ÿ](#q3-å¦‚ä½•æ¯”è¾ƒåŒ…å«åˆ‡ç‰‡çš„ç»“æ„ä½“)
  - [Q4: ç»“æ„ä½“æ ‡ç­¾æœ‰ä»€ä¹ˆç”¨ï¼Ÿ](#q4-ç»“æ„ä½“æ ‡ç­¾æœ‰ä»€ä¹ˆç”¨)
- [ğŸ“š æ‰©å±•é˜…è¯»](#-æ‰©å±•é˜…è¯»)
  - [ç›¸å…³æ¦‚å¿µ](#ç›¸å…³æ¦‚å¿µ)
  - [è¿›é˜¶ä¸»é¢˜](#è¿›é˜¶ä¸»é¢˜)

## ğŸ“š ç†è®ºåˆ†æ

### ç»“æ„ä½“çš„å½¢å¼åŒ–å®šä¹‰

```text
StructType ::= "struct" "{" FieldDecl* "}"
FieldDecl ::= (IdentifierList Type | EmbeddedField) [Tag]
EmbeddedField ::= "*"? TypeName
Tag ::= string_lit
```

### å†…å­˜å¸ƒå±€

ç»“æ„ä½“å­—æ®µåœ¨å†…å­˜ä¸­é¡ºåºæ’åˆ—ï¼Œä½†ä¼šè¿›è¡Œå†…å­˜å¯¹é½ä»¥æé«˜è®¿é—®æ•ˆç‡ã€‚

```go
type Example struct {
    a bool   // 1 byte + 7 bytes padding
    b int64  // 8 bytes
    c bool   // 1 byte + 7 bytes padding
}
// æ€»å¤§å°: 24 bytes (ç”±äºå¯¹é½)

type Optimized struct {
    b int64  // 8 bytes
    a bool   // 1 byte
    c bool   // 1 byte + 6 bytes padding
}
// æ€»å¤§å°: 16 bytes (ä¼˜åŒ–å)
```

## ğŸ’» ä»£ç å®ç°

### ç»“æ„ä½“å®šä¹‰ä¸åˆå§‹åŒ–

```go
package main

import "fmt"

// Person äººå‘˜ç»“æ„ä½“
type Person struct {
    Name    string
    Age     int
    Email   string
    Address string
}

// Point åæ ‡ç‚¹
type Point struct {
    X, Y float64
}

// Rectangle çŸ©å½¢
type Rectangle struct {
    TopLeft     Point
    BottomRight Point
}

func main() {
    // 1. å­—é¢é‡åˆå§‹åŒ–ï¼ˆå­—æ®µåï¼‰
    p1 := Person{
        Name:    "Alice",
        Age:     25,
        Email:   "alice@example.com",
        Address: "Beijing",
    }
    fmt.Printf("Person 1: %+v\n", p1)
    
    // 2. å­—é¢é‡åˆå§‹åŒ–ï¼ˆæŒ‰é¡ºåºï¼Œä¸æ¨èï¼‰
    p2 := Person{"Bob", 30, "bob@example.com", "Shanghai"}
    fmt.Printf("Person 2: %+v\n", p2)
    
    // 3. é›¶å€¼åˆå§‹åŒ–
    var p3 Person
    fmt.Printf("Person 3 (zero value): %+v\n", p3)
    
    // 4. éƒ¨åˆ†å­—æ®µåˆå§‹åŒ–
    p4 := Person{Name: "Charlie", Age: 35}
    fmt.Printf("Person 4 (partial): %+v\n", p4)
    
    // 5. ä½¿ç”¨newåˆ›å»ºï¼ˆè¿”å›æŒ‡é’ˆï¼‰
    p5 := new(Person)
    p5.Name = "David"
    p5.Age = 40
    fmt.Printf("Person 5 (new): %+v\n", *p5)
    
    // 6. åµŒå¥—ç»“æ„ä½“
    rect := Rectangle{
        TopLeft:     Point{X: 0, Y: 10},
        BottomRight: Point{X: 10, Y: 0},
    }
    fmt.Printf("Rectangle: %+v\n", rect)
    
    // 7. åŒ¿åç»“æ„ä½“
    point := struct {
        X, Y int
        Name string
    }{
        X:    10,
        Y:    20,
        Name: "P1",
    }
    fmt.Printf("Anonymous struct: %+v\n", point)
}
```

### åŒ¿åå­—æ®µä¸åµŒå…¥

```go
package main

import "fmt"

// Address åœ°å€
type Address struct {
    City    string
    Street  string
    ZipCode string
}

// Person åŸºç¡€äººå‘˜ä¿¡æ¯
type Person struct {
    Name string
    Age  int
}

func (p Person) Introduce() string {
    return fmt.Sprintf("Hi, I'm %s, %d years old", p.Name, p.Age)
}

// Employee å‘˜å·¥ï¼ˆåµŒå…¥Personï¼‰
type Employee struct {
    Person          // åŒ¿åå­—æ®µï¼ˆåµŒå…¥ï¼‰
    Address         // åµŒå…¥Address
    EmployeeID string
    Department string
}

// Manager ç»ç†ï¼ˆåµŒå…¥Employeeï¼‰
type Manager struct {
    Employee       // åµŒå…¥Employee
    TeamSize   int
}

func main() {
    // åˆ›å»ºå‘˜å·¥
    emp := Employee{
        Person: Person{
            Name: "Alice",
            Age:  28,
        },
        Address: Address{
            City:    "Beijing",
            Street:  "Main St",
            ZipCode: "100000",
        },
        EmployeeID: "E001",
        Department: "Engineering",
    }
    
    // è®¿é—®åµŒå…¥å­—æ®µï¼ˆå­—æ®µæå‡ï¼‰
    fmt.Printf("Name: %s\n", emp.Name)           // ç›´æ¥è®¿é—®Person.Name
    fmt.Printf("Age: %d\n", emp.Age)             // ç›´æ¥è®¿é—®Person.Age
    fmt.Printf("City: %s\n", emp.City)           // ç›´æ¥è®¿é—®Address.City
    fmt.Printf("Employee ID: %s\n", emp.EmployeeID)
    
    // è°ƒç”¨åµŒå…¥ç±»å‹çš„æ–¹æ³•
    fmt.Println(emp.Introduce())
    
    // æ˜¾å¼è®¿é—®åµŒå…¥å­—æ®µ
    fmt.Printf("Person: %+v\n", emp.Person)
    fmt.Printf("Address: %+v\n", emp.Address)
    
    // åˆ›å»ºç»ç†
    mgr := Manager{
        Employee: Employee{
            Person: Person{Name: "Bob", Age: 35},
            Address: Address{City: "Shanghai"},
            EmployeeID: "M001",
            Department: "Management",
        },
        TeamSize: 10,
    }
    
    // å¤šå±‚åµŒå…¥çš„å­—æ®µæå‡
    fmt.Printf("\nManager Name: %s\n", mgr.Name)  // è®¿é—®Person.Name
    fmt.Printf("Manager City: %s\n", mgr.City)    // è®¿é—®Address.City
    fmt.Printf("Team Size: %d\n", mgr.TeamSize)
    fmt.Println(mgr.Introduce())                   // è°ƒç”¨Person.Introduce()
}
```

### ç»“æ„ä½“æ ‡ç­¾

```go
package main

import (
    "encoding/json"
    "fmt"
    "reflect"
)

// User ç”¨æˆ·ä¿¡æ¯ï¼ˆå¸¦æ ‡ç­¾ï¼‰
type User struct {
    ID        int    `json:"id" db:"user_id" validate:"required"`
    Username  string `json:"username" db:"username" validate:"required,min=3"`
    Email     string `json:"email" db:"email" validate:"required,email"`
    Password  string `json:"-" db:"password_hash"`  // jsonåºåˆ—åŒ–æ—¶å¿½ç•¥
    Age       int    `json:"age,omitempty" db:"age"` // é›¶å€¼æ—¶omitempty
    IsActive  bool   `json:"is_active" db:"is_active"`
    CreatedAt string `json:"created_at,omitempty" db:"created_at"`
}

// printStructTags æ‰“å°ç»“æ„ä½“æ ‡ç­¾
func printStructTags(v interface{}) {
    t := reflect.TypeOf(v)
    
    for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        fmt.Printf("Field: %s\n", field.Name)
        fmt.Printf("  json: %s\n", field.Tag.Get("json"))
        fmt.Printf("  db: %s\n", field.Tag.Get("db"))
        fmt.Printf("  validate: %s\n\n", field.Tag.Get("validate"))
    }
}

func main() {
    user := User{
        ID:       1,
        Username: "alice",
        Email:    "alice@example.com",
        Password: "secret123",
        Age:      25,
        IsActive: true,
    }
    
    // JSONåºåˆ—åŒ–
    jsonData, err := json.MarshalIndent(user, "", "  ")
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Println("JSON output:")
    fmt.Println(string(jsonData))
    
    // JSONååºåˆ—åŒ–
    jsonStr := `{
        "id": 2,
        "username": "bob",
        "email": "bob@example.com",
        "age": 30,
        "is_active": true
    }`
    
    var user2 User
    err = json.Unmarshal([]byte(jsonStr), &user2)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("\nUnmarshaled user: %+v\n", user2)
    
    // æ‰“å°ç»“æ„ä½“æ ‡ç­¾
    fmt.Println("\nStruct tags:")
    printStructTags(User{})
}
```

### ç»“æ„ä½“æ¯”è¾ƒ

```go
package main

import "fmt"

// Point å¯æ¯”è¾ƒçš„ç»“æ„ä½“
type Point struct {
    X, Y int
}

// Person åŒ…å«ä¸å¯æ¯”è¾ƒå­—æ®µçš„ç»“æ„ä½“
type Person struct {
    Name    string
    Age     int
    Hobbies []string // åˆ‡ç‰‡ä¸å¯æ¯”è¾ƒ
}

// ComparablePerson å¯æ¯”è¾ƒçš„ç‰ˆæœ¬
type ComparablePerson struct {
    Name string
    Age  int
}

func main() {
    // å¯æ¯”è¾ƒçš„ç»“æ„ä½“
    p1 := Point{X: 1, Y: 2}
    p2 := Point{X: 1, Y: 2}
    p3 := Point{X: 2, Y: 3}
    
    fmt.Printf("p1 == p2: %t\n", p1 == p2) // true
    fmt.Printf("p1 == p3: %t\n", p1 == p3) // false
    
    // å¯æ¯”è¾ƒç»“æ„ä½“å¯ä»¥ç”¨ä½œmapçš„é”®
    points := map[Point]string{
        {X: 0, Y: 0}: "origin",
        {X: 1, Y: 1}: "diagonal",
    }
    fmt.Printf("Points map: %v\n", points)
    
    // åŒ…å«ä¸å¯æ¯”è¾ƒå­—æ®µçš„ç»“æ„ä½“
    // person1 := Person{Name: "Alice", Age: 25, Hobbies: []string{"reading"}}
    // person2 := Person{Name: "Alice", Age: 25, Hobbies: []string{"reading"}}
    // fmt.Println(person1 == person2) // ç¼–è¯‘é”™è¯¯ï¼
    
    // æ‰‹åŠ¨æ¯”è¾ƒ
    person1 := Person{Name: "Alice", Age: 25, Hobbies: []string{"reading", "coding"}}
    person2 := Person{Name: "Alice", Age: 25, Hobbies: []string{"reading", "coding"}}
    fmt.Printf("Persons equal: %t\n", personsEqual(person1, person2))
}

// æ‰‹åŠ¨æ¯”è¾ƒå‡½æ•°
func personsEqual(p1, p2 Person) bool {
    if p1.Name != p2.Name || p1.Age != p2.Age {
        return false
    }
    
    if len(p1.Hobbies) != len(p2.Hobbies) {
        return false
    }
    
    for i := range p1.Hobbies {
        if p1.Hobbies[i] != p2.Hobbies[i] {
            return false
        }
    }
    
    return true
}
```

### ç»“æ„ä½“ä½œä¸ºæ˜ å°„é”®

```go
package main

import "fmt"

// Coordinate åæ ‡ï¼ˆå¯æ¯”è¾ƒï¼‰
type Coordinate struct {
    Latitude  float64
    Longitude float64
}

// Location ä½ç½®ä¿¡æ¯
type Location struct {
    Name    string
    Country string
}

func main() {
    // ä½¿ç”¨ç»“æ„ä½“ä½œä¸ºmapçš„é”®
    locations := map[Coordinate]Location{
        {Latitude: 39.9042, Longitude: 116.4074}: {
            Name:    "Beijing",
            Country: "China",
        },
        {Latitude: 40.7128, Longitude: -74.0060}: {
            Name:    "New York",
            Country: "USA",
        },
        {Latitude: 51.5074, Longitude: -0.1278}: {
            Name:    "London",
            Country: "UK",
        },
    }
    
    // æŸ¥è¯¢ä½ç½®
    coord := Coordinate{Latitude: 39.9042, Longitude: 116.4074}
    if loc, ok := locations[coord]; ok {
        fmt.Printf("Location: %s, %s\n", loc.Name, loc.Country)
    }
    
    // éå†
    fmt.Println("\nAll locations:")
    for coord, loc := range locations {
        fmt.Printf("%.4f, %.4f -> %s, %s\n",
            coord.Latitude, coord.Longitude, loc.Name, loc.Country)
    }
}
```

## ğŸ“Š æ€§èƒ½åˆ†æ

```go
package main

import (
    "testing"
    "unsafe"
)

// æœªä¼˜åŒ–çš„ç»“æ„ä½“
type Unoptimized struct {
    a bool   // 1 byte + 7 bytes padding
    b int64  // 8 bytes
    c bool   // 1 byte + 7 bytes padding
    d int64  // 8 bytes
}

// ä¼˜åŒ–åçš„ç»“æ„ä½“
type Optimized struct {
    b int64  // 8 bytes
    d int64  // 8 bytes
    a bool   // 1 byte
    c bool   // 1 byte + 6 bytes padding
}

func TestStructSize(t *testing.T) {
    unopt := Unoptimized{}
    opt := Optimized{}
    
    t.Logf("Unoptimized size: %d bytes", unsafe.Sizeof(unopt))
    t.Logf("Optimized size: %d bytes", unsafe.Sizeof(opt))
}

// åŸºå‡†æµ‹è¯•ï¼šç»“æ„ä½“åˆ›å»º
func BenchmarkStructCreation(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = Person{Name: "Alice", Age: 25}
    }
}

// åŸºå‡†æµ‹è¯•ï¼šç»“æ„ä½“æŒ‡é’ˆåˆ›å»º
func BenchmarkStructPointerCreation(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = &Person{Name: "Alice", Age: 25}
    }
}
```

## ğŸ§ª æµ‹è¯•ä»£ç 

```go
package main

import (
    "testing"
)

func TestPersonCreation(t *testing.T) {
    p := Person{Name: "Alice", Age: 25}
    
    if p.Name != "Alice" {
        t.Errorf("Name = %s, want Alice", p.Name)
    }
    
    if p.Age != 25 {
        t.Errorf("Age = %d, want 25", p.Age)
    }
}

func TestEmployeeEmbedding(t *testing.T) {
    emp := Employee{
        Person: Person{Name: "Bob", Age: 30},
        EmployeeID: "E001",
    }
    
    // æµ‹è¯•å­—æ®µæå‡
    if emp.Name != "Bob" {
        t.Errorf("Name = %s, want Bob", emp.Name)
    }
    
    if emp.Age != 30 {
        t.Errorf("Age = %d, want 30", emp.Age)
    }
}
```

## ğŸ¯ æœ€ä½³å®è·µ

### 1. å­—æ®µæ’åºä¼˜åŒ–å†…å­˜

```go
// âŒ æœªä¼˜åŒ– (32 bytes)
type Bad struct {
    a bool   // 1 + 7 padding
    b int64  // 8
    c bool   // 1 + 7 padding
    d int64  // 8
}

// âœ… ä¼˜åŒ–å (24 bytes)
type Good struct {
    b int64  // 8
    d int64  // 8
    a bool   // 1
    c bool   // 1
    // 6 bytes padding at end
}
```

### 2. ä½¿ç”¨æ„é€ å‡½æ•°

```go
// âœ… æä¾›æ„é€ å‡½æ•°
func NewPerson(name string, age int) *Person {
    return &Person{
        Name: name,
        Age:  age,
    }
}

// éªŒè¯å’Œé»˜è®¤å€¼
func NewEmployee(name string, age int, id string) (*Employee, error) {
    if name == "" {
        return nil, errors.New("name cannot be empty")
    }
    
    return &Employee{
        Person:     Person{Name: name, Age: age},
        EmployeeID: id,
        Department: "Unknown", // é»˜è®¤å€¼
    }, nil
}
```

### 3. ä½¿ç”¨æŒ‡é’ˆæ¥æ”¶è€…

```go
// âœ… å¤§ç»“æ„ä½“ä½¿ç”¨æŒ‡é’ˆæ¥æ”¶è€…
type LargeStruct struct {
    data [1000]int
}

func (ls *LargeStruct) Process() {
    // é¿å…å¤åˆ¶å¤§ç»“æ„ä½“
}
```

### 4. æ ‡ç­¾ä½¿ç”¨è§„èŒƒ

```go
// âœ… æ¸…æ™°çš„æ ‡ç­¾
type User struct {
    ID    int    `json:"id" db:"user_id"`
    Name  string `json:"name" db:"name" validate:"required"`
    Email string `json:"email" db:"email" validate:"email"`
}
```

## ğŸ” å¸¸è§é—®é¢˜

### Q1: ä»€ä¹ˆæ—¶å€™ä½¿ç”¨ç»“æ„ä½“æŒ‡é’ˆï¼Ÿ

A:

- éœ€è¦ä¿®æ”¹ç»“æ„ä½“å†…å®¹
- ç»“æ„ä½“å¾ˆå¤§ï¼ˆé¿å…å¤åˆ¶ï¼‰
- éœ€è¦è¡¨ç¤º"ä¸å­˜åœ¨"ï¼ˆnilï¼‰
- å®ç°æ¥å£æ—¶ä½¿ç”¨æŒ‡é’ˆæ¥æ”¶è€…

### Q2: åŒ¿åå­—æ®µå’Œå‘½åå­—æ®µæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

A: åŒ¿åå­—æ®µï¼ˆåµŒå…¥ï¼‰ä¼šå‘ç”Ÿå­—æ®µæå‡ï¼Œå¯ä»¥ç›´æ¥è®¿é—®åµŒå…¥ç±»å‹çš„å­—æ®µå’Œæ–¹æ³•ã€‚å‘½åå­—æ®µéœ€è¦é€šè¿‡å­—æ®µåè®¿é—®ã€‚

### Q3: å¦‚ä½•æ¯”è¾ƒåŒ…å«åˆ‡ç‰‡çš„ç»“æ„ä½“ï¼Ÿ

A: ä¸èƒ½ç›´æ¥ä½¿ç”¨==ï¼Œéœ€è¦ä½¿ç”¨reflect.DeepEqualæˆ–è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°ã€‚

### Q4: ç»“æ„ä½“æ ‡ç­¾æœ‰ä»€ä¹ˆç”¨ï¼Ÿ

A: æ ‡ç­¾ç”¨äºå…ƒæ•°æ®æ ‡æ³¨ï¼Œå¸¸ç”¨äºï¼š

- JSON/XMLåºåˆ—åŒ–é…ç½®
- æ•°æ®åº“æ˜ å°„
- éªŒè¯è§„åˆ™
- ORMæ¡†æ¶é…ç½®

## ğŸ“š æ‰©å±•é˜…è¯»

### ç›¸å…³æ¦‚å¿µ

- [æ–¹æ³•](./06-æ–¹æ³•.md)
- [æ¥å£](./07-æ¥å£.md)
- [æŒ‡é’ˆ](./02-å˜é‡å’Œå¸¸é‡.md#æŒ‡é’ˆå˜é‡)

### è¿›é˜¶ä¸»é¢˜

- å†…å­˜å¯¹é½ä¼˜åŒ–
- ç»“æ„ä½“æ ‡ç­¾ä¸åå°„
- åµŒå…¥ä¸ç»„åˆæ¨¡å¼
- ç»“æ„ä½“çš„JSONå¤„ç†

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ24æ—¥  
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
