# Goé”™è¯¯å¤„ç†

> **ç®€ä»‹**: Goé”™è¯¯å¤„ç†å®Œæ•´æŒ‡å—ï¼ŒåŒ…æ‹¬erroræ¥å£ã€é”™è¯¯åˆ›å»ºã€é”™è¯¯åŒ…è£…å’Œæœ€ä½³å®è·µ

> **ç‰ˆæœ¬**: Go 1.25.3  
> **éš¾åº¦**: â­â­â­  
> **æ ‡ç­¾**: #é”™è¯¯å¤„ç† #error #panic #recover

---

## ğŸ“‹ ç›®å½•

- [1. erroræ¥å£](#1-erroræ¥å£)
  - [erroræ¥å£å®šä¹‰](#erroræ¥å£å®šä¹‰)
  - [åŸºæœ¬é”™è¯¯å¤„ç†](#åŸºæœ¬é”™è¯¯å¤„ç†)
- [2. åˆ›å»ºé”™è¯¯](#2-åˆ›å»ºé”™è¯¯)
  - [errors.New](#errorsnew)
  - [fmt.Errorf](#fmterrorf)
  - [é¢„å®šä¹‰é”™è¯¯](#é¢„å®šä¹‰é”™è¯¯)
- [3. é”™è¯¯åŒ…è£…](#3-é”™è¯¯åŒ…è£…)
  - [fmt.Errorf with %w](#fmterrorf-with-w)
  - [errors.Is](#errorsis)
  - [errors.As](#errorsas)
  - [errors.Unwrap](#errorsunwrap)
- [4. panicå’Œrecover](#4-panicå’Œrecover)
  - [panicåŸºç¡€](#panicåŸºç¡€)
  - [recoveræ•è·panic](#recoveræ•è·panic)
  - [HTTP Handlerä¸­çš„recover](#http-handlerä¸­çš„recover)
- [5. è‡ªå®šä¹‰é”™è¯¯](#5-è‡ªå®šä¹‰é”™è¯¯)
  - [å®ç°erroræ¥å£](#å®ç°erroræ¥å£)
  - [å¸¦ä¸Šä¸‹æ–‡çš„é”™è¯¯](#å¸¦ä¸Šä¸‹æ–‡çš„é”™è¯¯)
  - [é”™è¯¯ç±»å‹åˆ¤æ–­](#é”™è¯¯ç±»å‹åˆ¤æ–­)
- [6. æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)
  - [1. é”™è¯¯è¦ä¼ æ’­ï¼Œä¸è¦å¿½ç•¥](#1-é”™è¯¯è¦ä¼ æ’­ä¸è¦å¿½ç•¥)
  - [2. æ·»åŠ ä¸Šä¸‹æ–‡ä¿¡æ¯](#2-æ·»åŠ ä¸Šä¸‹æ–‡ä¿¡æ¯)
  - [3. ä½¿ç”¨å“¨å…µé”™è¯¯ï¼ˆSentinel Errorsï¼‰](#3-ä½¿ç”¨å“¨å…µé”™è¯¯sentinel-errors)
  - [4. ä¸è¦è¿‡åº¦ä½¿ç”¨panic](#4-ä¸è¦è¿‡åº¦ä½¿ç”¨panic)
  - [5. æ£€æŸ¥é”™è¯¯ç±»å‹](#5-æ£€æŸ¥é”™è¯¯ç±»å‹)
  - [6. å»¶è¿Ÿé”™è¯¯å¤„ç†](#6-å»¶è¿Ÿé”™è¯¯å¤„ç†)
  - [7. é”™è¯¯æ—¥å¿—è®°å½•](#7-é”™è¯¯æ—¥å¿—è®°å½•)
- [ğŸ¯ å¸¸è§æ¨¡å¼](#-å¸¸è§æ¨¡å¼)
  - [æ¨¡å¼1: å¤šè¿”å›å€¼](#æ¨¡å¼1-å¤šè¿”å›å€¼)
  - [æ¨¡å¼2: é”™è¯¯å˜é‡](#æ¨¡å¼2-é”™è¯¯å˜é‡)
  - [æ¨¡å¼3: é“¾å¼é”™è¯¯å¤„ç†](#æ¨¡å¼3-é“¾å¼é”™è¯¯å¤„ç†)
- [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

## 1. erroræ¥å£

### erroræ¥å£å®šä¹‰

```go
type error interface {
    Error() string
}
```

---

### åŸºæœ¬é”™è¯¯å¤„ç†

```go
func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Println("Result:", result)
}
```

---

## 2. åˆ›å»ºé”™è¯¯

### errors.New

```go
import "errors"

func validateAge(age int) error {
    if age < 0 {
        return errors.New("age cannot be negative")
    }
    if age > 150 {
        return errors.New("age is too large")
    }
    return nil
}
```

---

### fmt.Errorf

```go
import "fmt"

func processUser(id int) error {
    user, err := fetchUser(id)
    if err != nil {
        return fmt.Errorf("failed to fetch user %d: %v", id, err)
    }
    
    if user == nil {
        return fmt.Errorf("user %d not found", id)
    }
    
    return nil
}
```

---

### é¢„å®šä¹‰é”™è¯¯

```go
var (
    ErrNotFound      = errors.New("not found")
    ErrInvalidInput  = errors.New("invalid input")
    ErrUnauthorized  = errors.New("unauthorized")
)

func getUser(id int) (*User, error) {
    if id < 0 {
        return nil, ErrInvalidInput
    }
    
    user := findUser(id)
    if user == nil {
        return nil, ErrNotFound
    }
    
    return user, nil
}

// ä½¿ç”¨
func main() {
    user, err := getUser(-1)
    if err == ErrInvalidInput {
        fmt.Println("Invalid ID")
        return
    }
    if err == ErrNotFound {
        fmt.Println("User not found")
        return
    }
}
```

---

## 3. é”™è¯¯åŒ…è£…

### fmt.Errorf with %w

```go
func processData(filename string) error {
    data, err := os.ReadFile(filename)
    if err != nil {
        // åŒ…è£…é”™è¯¯ï¼Œä¿ç•™åŸå§‹é”™è¯¯
        return fmt.Errorf("failed to read file %s: %w", filename, err)
    }
    
    if err := validate(data); err != nil {
        return fmt.Errorf("validation failed: %w", err)
    }
    
    return nil
}
```

---

### errors.Is

```go
func main() {
    err := processData("config.json")
    
    // æ£€æŸ¥é”™è¯¯é“¾ä¸­æ˜¯å¦åŒ…å«ç‰¹å®šé”™è¯¯
    if errors.Is(err, os.ErrNotExist) {
        fmt.Println("File does not exist")
        return
    }
    
    if err != nil {
        fmt.Println("Error:", err)
    }
}
```

---

### errors.As

```go
type ValidationError struct {
    Field string
    Value interface{}
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation failed for field %s: %v", e.Field, e.Value)
}

func processData(data string) error {
    if data == "" {
        return &ValidationError{
            Field: "data",
            Value: data,
        }
    }
    return nil
}

func main() {
    err := processData("")
    
    // æå–ç‰¹å®šç±»å‹çš„é”™è¯¯
    var validationErr *ValidationError
    if errors.As(err, &validationErr) {
        fmt.Printf("Validation error: %s = %v\n", 
            validationErr.Field, 
            validationErr.Value)
        return
    }
    
    if err != nil {
        fmt.Println("Error:", err)
    }
}
```

---

### errors.Unwrap

```go
func main() {
    err := fmt.Errorf("outer: %w", 
           fmt.Errorf("middle: %w", 
           errors.New("inner")))
    
    // è§£åŒ…é”™è¯¯
    fmt.Println(err)                    // outer: middle: inner
    fmt.Println(errors.Unwrap(err))     // middle: inner
    fmt.Println(errors.Unwrap(
                errors.Unwrap(err)))    // inner
}
```

---

## 4. panicå’Œrecover

### panicåŸºç¡€

```go
func mustConnect(url string) *sql.DB {
    db, err := sql.Open("postgres", url)
    if err != nil {
        panic(err)  // è‡´å‘½é”™è¯¯ï¼Œç¨‹åºæ— æ³•ç»§ç»­
    }
    return db
}
```

---

### recoveræ•è·panic

```go
func safeExecute(fn func()) {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered from panic:", r)
        }
    }()
    
    fn()
}

func main() {
    safeExecute(func() {
        panic("something went wrong")
    })
    
    fmt.Println("Program continues...")
}
```

---

### HTTP Handlerä¸­çš„recover

```go
func recoverMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if r := recover(); r != nil {
                log.Printf("Panic recovered: %v", r)
                http.Error(w, "Internal Server Error", 500)
            }
        }()
        
        next.ServeHTTP(w, r)
    })
}

func main() {
    mux := http.NewServeMux()
    mux.HandleFunc("/", handler)
    
    http.ListenAndServe(":8080", recoverMiddleware(mux))
}
```

---

## 5. è‡ªå®šä¹‰é”™è¯¯

### å®ç°erroræ¥å£

```go
type DatabaseError struct {
    Query string
    Err   error
}

func (e *DatabaseError) Error() string {
    return fmt.Sprintf("database error executing query '%s': %v", e.Query, e.Err)
}

func (e *DatabaseError) Unwrap() error {
    return e.Err
}

// ä½¿ç”¨
func queryUsers(query string) error {
    _, err := db.Query(query)
    if err != nil {
        return &DatabaseError{
            Query: query,
            Err:   err,
        }
    }
    return nil
}
```

---

### å¸¦ä¸Šä¸‹æ–‡çš„é”™è¯¯

```go
type HTTPError struct {
    StatusCode int
    Message    string
    Err        error
}

func (e *HTTPError) Error() string {
    if e.Err != nil {
        return fmt.Sprintf("%d %s: %v", e.StatusCode, e.Message, e.Err)
    }
    return fmt.Sprintf("%d %s", e.StatusCode, e.Message)
}

func (e *HTTPError) Unwrap() error {
    return e.Err
}

// ä½¿ç”¨
func fetchAPI(url string) error {
    resp, err := http.Get(url)
    if err != nil {
        return &HTTPError{
            StatusCode: 0,
            Message:    "failed to fetch",
            Err:        err,
        }
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != 200 {
        return &HTTPError{
            StatusCode: resp.StatusCode,
            Message:    "unexpected status",
        }
    }
    
    return nil
}
```

---

### é”™è¯¯ç±»å‹åˆ¤æ–­

```go
func handleError(err error) {
    var httpErr *HTTPError
    if errors.As(err, &httpErr) {
        switch httpErr.StatusCode {
        case 404:
            fmt.Println("Not found")
        case 500:
            fmt.Println("Server error")
        default:
            fmt.Printf("HTTP error: %d\n", httpErr.StatusCode)
        }
        return
    }
    
    if errors.Is(err, context.DeadlineExceeded) {
        fmt.Println("Request timeout")
        return
    }
    
    fmt.Println("Unknown error:", err)
}
```

---

## 6. æœ€ä½³å®è·µ

### 1. é”™è¯¯è¦ä¼ æ’­ï¼Œä¸è¦å¿½ç•¥

```go
// âœ… æ¨è
func processFile(filename string) error {
    data, err := os.ReadFile(filename)
    if err != nil {
        return fmt.Errorf("failed to read file: %w", err)
    }
    // å¤„ç†data
    return nil
}

// âŒ ä¸æ¨èï¼šå¿½ç•¥é”™è¯¯
func processFile(filename string) error {
    data, _ := os.ReadFile(filename)  // å¿½ç•¥é”™è¯¯
    // å¤„ç†data
    return nil
}
```

---

### 2. æ·»åŠ ä¸Šä¸‹æ–‡ä¿¡æ¯

```go
// âœ… æ¨èï¼šæ·»åŠ ä¸Šä¸‹æ–‡
func updateUser(id int, data map[string]interface{}) error {
    user, err := fetchUser(id)
    if err != nil {
        return fmt.Errorf("failed to fetch user %d: %w", id, err)
    }
    
    if err := validateData(data); err != nil {
        return fmt.Errorf("invalid data for user %d: %w", id, err)
    }
    
    return nil
}

// âŒ ä¸æ¨èï¼šç›´æ¥è¿”å›åŸå§‹é”™è¯¯
func updateUser(id int, data map[string]interface{}) error {
    user, err := fetchUser(id)
    if err != nil {
        return err  // ä¸¢å¤±äº†ä¸Šä¸‹æ–‡ä¿¡æ¯
    }
    return nil
}
```

---

### 3. ä½¿ç”¨å“¨å…µé”™è¯¯ï¼ˆSentinel Errorsï¼‰

```go
// âœ… æ¨èï¼šå®šä¹‰å“¨å…µé”™è¯¯
var (
    ErrNotFound     = errors.New("not found")
    ErrUnauthorized = errors.New("unauthorized")
    ErrBadRequest   = errors.New("bad request")
)

func getUser(id int) (*User, error) {
    if id < 0 {
        return nil, ErrBadRequest
    }
    
    user := db.FindUser(id)
    if user == nil {
        return nil, ErrNotFound
    }
    
    return user, nil
}

// ä½¿ç”¨
user, err := getUser(id)
if err == ErrNotFound {
    // å¤„ç†æœªæ‰¾åˆ°çš„æƒ…å†µ
}
```

---

### 4. ä¸è¦è¿‡åº¦ä½¿ç”¨panic

```go
// âœ… æ¨èï¼šè¿”å›error
func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

// âŒ ä¸æ¨èï¼šä½¿ç”¨panicï¼ˆé™¤éæ˜¯çœŸæ­£çš„è‡´å‘½é”™è¯¯ï¼‰
func divide(a, b int) int {
    if b == 0 {
        panic("division by zero")
    }
    return a / b
}

// âœ… å¯ä»¥ä½¿ç”¨panicçš„åœºæ™¯
func mustLoadConfig(path string) *Config {
    config, err := loadConfig(path)
    if err != nil {
        panic(fmt.Sprintf("failed to load config: %v", err))
    }
    return config
}
```

---

### 5. æ£€æŸ¥é”™è¯¯ç±»å‹

```go
// âœ… æ¨èï¼šä½¿ç”¨errors.As
func handleError(err error) {
    var netErr *net.OpError
    if errors.As(err, &netErr) {
        if netErr.Timeout() {
            fmt.Println("Network timeout")
            return
        }
    }
    
    if errors.Is(err, io.EOF) {
        fmt.Println("End of file")
        return
    }
}

// âŒ ä¸æ¨èï¼šç±»å‹æ–­è¨€
func handleError(err error) {
    if netErr, ok := err.(*net.OpError); ok {
        // æ— æ³•å¤„ç†åŒ…è£…çš„é”™è¯¯
    }
}
```

---

### 6. å»¶è¿Ÿé”™è¯¯å¤„ç†

```go
// âœ… æ¨èï¼šä½¿ç”¨å‘½åè¿”å›å€¼
func processFile(filename string) (err error) {
    f, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer func() {
        if closeErr := f.Close(); closeErr != nil && err == nil {
            err = fmt.Errorf("failed to close file: %w", closeErr)
        }
    }()
    
    // å¤„ç†æ–‡ä»¶
    return nil
}
```

---

### 7. é”™è¯¯æ—¥å¿—è®°å½•

```go
func processRequest(r *http.Request) error {
    data, err := parseRequest(r)
    if err != nil {
        // è®°å½•é”™è¯¯ä½†ç»§ç»­ä¼ æ’­
        log.Printf("Failed to parse request: %v", err)
        return fmt.Errorf("parse error: %w", err)
    }
    
    return nil
}
```

---

## ğŸ¯ å¸¸è§æ¨¡å¼

### æ¨¡å¼1: å¤šè¿”å›å€¼

```go
func operation() (result string, err error) {
    // æ“ä½œ
    if someError {
        return "", errors.New("operation failed")
    }
    return "success", nil
}
```

---

### æ¨¡å¼2: é”™è¯¯å˜é‡

```go
var err error
data, err = readData()
if err != nil {
    return err
}

processedData, err = process(data)
if err != nil {
    return err
}
```

---

### æ¨¡å¼3: é“¾å¼é”™è¯¯å¤„ç†

```go
func processAll() error {
    if err := step1(); err != nil {
        return fmt.Errorf("step1 failed: %w", err)
    }
    
    if err := step2(); err != nil {
        return fmt.Errorf("step2 failed: %w", err)
    }
    
    if err := step3(); err != nil {
        return fmt.Errorf("step3 failed: %w", err)
    }
    
    return nil
}
```

---

## ğŸ”— ç›¸å…³èµ„æº

- [åŸºæœ¬è¯­æ³•](./01-åŸºæœ¬è¯­æ³•.md)
- [å‡½æ•°](./05-å‡½æ•°.md)
- [æœ€ä½³å®è·µ](../../practices/engineering/README.md)

---

**æœ€åæ›´æ–°**: 2025-10-28  
**Goç‰ˆæœ¬**: 1.25.3

