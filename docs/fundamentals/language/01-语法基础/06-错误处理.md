# Go错误处理

> **简介**: Go错误处理完整指南，包括error接口、错误创建、错误包装和最佳实践

> **版本**: Go 1.25.3  
> **难度**: ⭐⭐⭐  
> **标签**: #错误处理 #error #panic #recover

---

## 📋 目录
- [1. error接口](#error接口)
- [2. 创建错误](#创建错误)
- [3. 错误包装](#错误包装)
- [4. panic和recover](#panic和recover)
- [5. 自定义错误](#自定义错误)
- [6. 最佳实践](#最佳实践)

---

## 1. error接口

### error接口定义

```go
type error interface {
    Error() string
}
```

---

### 基本错误处理

```go
func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Println("Result:", result)
}
```

---

## 2. 创建错误

### errors.New

```go
import "errors"

func validateAge(age int) error {
    if age < 0 {
        return errors.New("age cannot be negative")
    }
    if age > 150 {
        return errors.New("age is too large")
    }
    return nil
}
```

---

### fmt.Errorf

```go
import "fmt"

func processUser(id int) error {
    user, err := fetchUser(id)
    if err != nil {
        return fmt.Errorf("failed to fetch user %d: %v", id, err)
    }
    
    if user == nil {
        return fmt.Errorf("user %d not found", id)
    }
    
    return nil
}
```

---

### 预定义错误

```go
var (
    ErrNotFound      = errors.New("not found")
    ErrInvalidInput  = errors.New("invalid input")
    ErrUnauthorized  = errors.New("unauthorized")
)

func getUser(id int) (*User, error) {
    if id < 0 {
        return nil, ErrInvalidInput
    }
    
    user := findUser(id)
    if user == nil {
        return nil, ErrNotFound
    }
    
    return user, nil
}

// 使用
func main() {
    user, err := getUser(-1)
    if err == ErrInvalidInput {
        fmt.Println("Invalid ID")
        return
    }
    if err == ErrNotFound {
        fmt.Println("User not found")
        return
    }
}
```

---

## 3. 错误包装

### fmt.Errorf with %w

```go
func processData(filename string) error {
    data, err := os.ReadFile(filename)
    if err != nil {
        // 包装错误，保留原始错误
        return fmt.Errorf("failed to read file %s: %w", filename, err)
    }
    
    if err := validate(data); err != nil {
        return fmt.Errorf("validation failed: %w", err)
    }
    
    return nil
}
```

---

### errors.Is

```go
func main() {
    err := processData("config.json")
    
    // 检查错误链中是否包含特定错误
    if errors.Is(err, os.ErrNotExist) {
        fmt.Println("File does not exist")
        return
    }
    
    if err != nil {
        fmt.Println("Error:", err)
    }
}
```

---

### errors.As

```go
type ValidationError struct {
    Field string
    Value interface{}
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation failed for field %s: %v", e.Field, e.Value)
}

func processData(data string) error {
    if data == "" {
        return &ValidationError{
            Field: "data",
            Value: data,
        }
    }
    return nil
}

func main() {
    err := processData("")
    
    // 提取特定类型的错误
    var validationErr *ValidationError
    if errors.As(err, &validationErr) {
        fmt.Printf("Validation error: %s = %v\n", 
            validationErr.Field, 
            validationErr.Value)
        return
    }
    
    if err != nil {
        fmt.Println("Error:", err)
    }
}
```

---

### errors.Unwrap

```go
func main() {
    err := fmt.Errorf("outer: %w", 
           fmt.Errorf("middle: %w", 
           errors.New("inner")))
    
    // 解包错误
    fmt.Println(err)                    // outer: middle: inner
    fmt.Println(errors.Unwrap(err))     // middle: inner
    fmt.Println(errors.Unwrap(
                errors.Unwrap(err)))    // inner
}
```

---

## 4. panic和recover

### panic基础

```go
func mustConnect(url string) *sql.DB {
    db, err := sql.Open("postgres", url)
    if err != nil {
        panic(err)  // 致命错误，程序无法继续
    }
    return db
}
```

---

### recover捕获panic

```go
func safeExecute(fn func()) {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered from panic:", r)
        }
    }()
    
    fn()
}

func main() {
    safeExecute(func() {
        panic("something went wrong")
    })
    
    fmt.Println("Program continues...")
}
```

---

### HTTP Handler中的recover

```go
func recoverMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if r := recover(); r != nil {
                log.Printf("Panic recovered: %v", r)
                http.Error(w, "Internal Server Error", 500)
            }
        }()
        
        next.ServeHTTP(w, r)
    })
}

func main() {
    mux := http.NewServeMux()
    mux.HandleFunc("/", handler)
    
    http.ListenAndServe(":8080", recoverMiddleware(mux))
}
```

---

## 5. 自定义错误

### 实现error接口

```go
type DatabaseError struct {
    Query string
    Err   error
}

func (e *DatabaseError) Error() string {
    return fmt.Sprintf("database error executing query '%s': %v", e.Query, e.Err)
}

func (e *DatabaseError) Unwrap() error {
    return e.Err
}

// 使用
func queryUsers(query string) error {
    _, err := db.Query(query)
    if err != nil {
        return &DatabaseError{
            Query: query,
            Err:   err,
        }
    }
    return nil
}
```

---

### 带上下文的错误

```go
type HTTPError struct {
    StatusCode int
    Message    string
    Err        error
}

func (e *HTTPError) Error() string {
    if e.Err != nil {
        return fmt.Sprintf("%d %s: %v", e.StatusCode, e.Message, e.Err)
    }
    return fmt.Sprintf("%d %s", e.StatusCode, e.Message)
}

func (e *HTTPError) Unwrap() error {
    return e.Err
}

// 使用
func fetchAPI(url string) error {
    resp, err := http.Get(url)
    if err != nil {
        return &HTTPError{
            StatusCode: 0,
            Message:    "failed to fetch",
            Err:        err,
        }
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != 200 {
        return &HTTPError{
            StatusCode: resp.StatusCode,
            Message:    "unexpected status",
        }
    }
    
    return nil
}
```

---

### 错误类型判断

```go
func handleError(err error) {
    var httpErr *HTTPError
    if errors.As(err, &httpErr) {
        switch httpErr.StatusCode {
        case 404:
            fmt.Println("Not found")
        case 500:
            fmt.Println("Server error")
        default:
            fmt.Printf("HTTP error: %d\n", httpErr.StatusCode)
        }
        return
    }
    
    if errors.Is(err, context.DeadlineExceeded) {
        fmt.Println("Request timeout")
        return
    }
    
    fmt.Println("Unknown error:", err)
}
```

---

## 6. 最佳实践

### 1. 错误要传播，不要忽略

```go
// ✅ 推荐
func processFile(filename string) error {
    data, err := os.ReadFile(filename)
    if err != nil {
        return fmt.Errorf("failed to read file: %w", err)
    }
    // 处理data
    return nil
}

// ❌ 不推荐：忽略错误
func processFile(filename string) error {
    data, _ := os.ReadFile(filename)  // 忽略错误
    // 处理data
    return nil
}
```

---

### 2. 添加上下文信息

```go
// ✅ 推荐：添加上下文
func updateUser(id int, data map[string]interface{}) error {
    user, err := fetchUser(id)
    if err != nil {
        return fmt.Errorf("failed to fetch user %d: %w", id, err)
    }
    
    if err := validateData(data); err != nil {
        return fmt.Errorf("invalid data for user %d: %w", id, err)
    }
    
    return nil
}

// ❌ 不推荐：直接返回原始错误
func updateUser(id int, data map[string]interface{}) error {
    user, err := fetchUser(id)
    if err != nil {
        return err  // 丢失了上下文信息
    }
    return nil
}
```

---

### 3. 使用哨兵错误（Sentinel Errors）

```go
// ✅ 推荐：定义哨兵错误
var (
    ErrNotFound     = errors.New("not found")
    ErrUnauthorized = errors.New("unauthorized")
    ErrBadRequest   = errors.New("bad request")
)

func getUser(id int) (*User, error) {
    if id < 0 {
        return nil, ErrBadRequest
    }
    
    user := db.FindUser(id)
    if user == nil {
        return nil, ErrNotFound
    }
    
    return user, nil
}

// 使用
user, err := getUser(id)
if err == ErrNotFound {
    // 处理未找到的情况
}
```

---

### 4. 不要过度使用panic

```go
// ✅ 推荐：返回error
func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

// ❌ 不推荐：使用panic（除非是真正的致命错误）
func divide(a, b int) int {
    if b == 0 {
        panic("division by zero")
    }
    return a / b
}

// ✅ 可以使用panic的场景
func mustLoadConfig(path string) *Config {
    config, err := loadConfig(path)
    if err != nil {
        panic(fmt.Sprintf("failed to load config: %v", err))
    }
    return config
}
```

---

### 5. 检查错误类型

```go
// ✅ 推荐：使用errors.As
func handleError(err error) {
    var netErr *net.OpError
    if errors.As(err, &netErr) {
        if netErr.Timeout() {
            fmt.Println("Network timeout")
            return
        }
    }
    
    if errors.Is(err, io.EOF) {
        fmt.Println("End of file")
        return
    }
}

// ❌ 不推荐：类型断言
func handleError(err error) {
    if netErr, ok := err.(*net.OpError); ok {
        // 无法处理包装的错误
    }
}
```

---

### 6. 延迟错误处理

```go
// ✅ 推荐：使用命名返回值
func processFile(filename string) (err error) {
    f, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer func() {
        if closeErr := f.Close(); closeErr != nil && err == nil {
            err = fmt.Errorf("failed to close file: %w", closeErr)
        }
    }()
    
    // 处理文件
    return nil
}
```

---

### 7. 错误日志记录

```go
func processRequest(r *http.Request) error {
    data, err := parseRequest(r)
    if err != nil {
        // 记录错误但继续传播
        log.Printf("Failed to parse request: %v", err)
        return fmt.Errorf("parse error: %w", err)
    }
    
    return nil
}
```

---

## 🎯 常见模式

### 模式1: 多返回值

```go
func operation() (result string, err error) {
    // 操作
    if someError {
        return "", errors.New("operation failed")
    }
    return "success", nil
}
```

---

### 模式2: 错误变量

```go
var err error
data, err = readData()
if err != nil {
    return err
}

processedData, err = process(data)
if err != nil {
    return err
}
```

---

### 模式3: 链式错误处理

```go
func processAll() error {
    if err := step1(); err != nil {
        return fmt.Errorf("step1 failed: %w", err)
    }
    
    if err := step2(); err != nil {
        return fmt.Errorf("step2 failed: %w", err)
    }
    
    if err := step3(); err != nil {
        return fmt.Errorf("step3 failed: %w", err)
    }
    
    return nil
}
```

---

## 🔗 相关资源

- [基本语法](./01-基本语法.md)
- [函数](./05-函数.md)
- [最佳实践](../../practices/engineering/README.md)

---

**最后更新**: 2025-10-28  
**Go版本**: 1.25.3

