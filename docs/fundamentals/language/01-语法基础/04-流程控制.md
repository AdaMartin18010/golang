# Go流程控制

> **简介**: 全面讲解Go语言的流程控制结构，包括if、switch、for循环和range遍历
> **版本**: Go 1.23+  
> **难度**: ⭐⭐  
> **标签**: #基础 #流程控制 #循环 #分支

<!-- TOC START -->
- [Go流程控制](#go流程控制)
  - [理论基础与形式化描述](#理论基础与形式化描述)
  - [典型代码示例](#典型代码示例)
    - [1. if分支详解](#1-if分支详解)
    - [2. switch分支详解](#2-switch分支详解)
    - [3. for循环详解](#3-for循环详解)
    - [4. for-range遍历详解](#4-for-range遍历详解)
  - [高级特性与技巧](#高级特性与技巧)
  - [工程分析与最佳实践](#工程分析与最佳实践)
  - [常见错误与陷阱](#常见错误与陷阱)
  - [性能考量](#性能考量)
  - [单元测试建议](#单元测试建议)
  - [参考文献](#参考文献)
<!-- TOC END -->


## 📋 目录


- [理论基础与形式化描述](#理论基础与形式化描述)
  - [三大结构](#三大结构)
  - [形式化描述](#形式化描述)
  - [Go的设计哲学](#go的设计哲学)
- [典型代码示例](#典型代码示例)
  - [1. if分支详解](#1-if分支详解)
  - [2. switch分支详解](#2-switch分支详解)
  - [3. for循环详解](#3-for循环详解)
  - [4. for-range遍历详解](#4-for-range遍历详解)
- [高级特性与技巧](#高级特性与技巧)
  - [1. defer与循环](#1-defer与循环)
  - [2. range的值复制问题](#2-range的值复制问题)
  - [3. 闭包与循环变量](#3-闭包与循环变量)
- [工程分析与最佳实践](#工程分析与最佳实践)
  - [1. 代码可读性](#1-代码可读性)
  - [2. 性能优化](#2-性能优化)
  - [3. 安全性](#3-安全性)
- [常见错误与陷阱](#常见错误与陷阱)
  - [1. 悬空的range变量](#1-悬空的range变量)
  - [2. switch中的fallthrough陷阱](#2-switch中的fallthrough陷阱)
  - [3. for循环中的defer](#3-for循环中的defer)
- [性能考量](#性能考量)
  - [1. range vs 传统for](#1-range-vs-传统for)
  - [2. switch vs if-else链](#2-switch-vs-if-else链)
- [单元测试建议](#单元测试建议)
  - [Table-Driven测试](#table-driven测试)
  - [分支覆盖率](#分支覆盖率)
- [参考文献](#参考文献)

## 理论基础与形式化描述

流程控制是程序设计的核心，决定了代码的执行顺序。Go语言支持三大类流程控制：顺序、分支、循环。

### 三大结构

- **顺序结构**：代码自上而下依次执行。
- **分支结构**：根据条件选择不同路径（如`if`、`switch`）。
- **循环结构**：重复执行某段代码（如`for`）。

### 形式化描述

使用伪代码/数学表示法：

- **顺序**：$S_1; S_2; \ldots; S_n$
- **分支**：
  \[
    \text{if } C \text{ then } S_1 \text{ else } S_2
  \]
- **循环**：
  \[
    \text{while } C \text{ do } S
  \]

Go语言以`if`、`switch`、`for`为核心，简洁高效。

### Go的设计哲学

- **简洁性**：只有`for`一种循环，统一while、do-while等语义
- **可读性**：强制使用花括号`{}`，避免悬空else
- **安全性**：没有三元运算符，减少复杂表达式
- **明确性**：break/continue默认只影响最内层循环

---

## 典型代码示例

### 1. if分支详解

**基本用法：**

```go
x := 10
if x > 5 {
    fmt.Println("x大于5")
} else {
    fmt.Println("x不大于5")
}
```

**带初始化语句（推荐）：**

```go
// 变量err仅在if块内可见
if err := doSomething(); err != nil {
    return err
}
// err在这里不可见，作用域收敛
```

**多分支：**

```go
score := 85
if score >= 90 {
    fmt.Println("优秀")
} else if score >= 80 {
    fmt.Println("良好")
} else if score >= 60 {
    fmt.Println("及格")
} else {
    fmt.Println("不及格")
}
```

**Early Return模式（最佳实践）：**

```go
// ❌ 嵌套过深
func process(data string) error {
    if data != "" {
        if len(data) > 10 {
            if isValid(data) {
                return save(data)
            } else {
                return errors.New("invalid")
            }
        } else {
            return errors.New("too short")
        }
    } else {
        return errors.New("empty")
    }
}

// ✅ Early Return，扁平化
func process(data string) error {
    if data == "" {
        return errors.New("empty")
    }
    if len(data) <= 10 {
        return errors.New("too short")
    }
    if !isValid(data) {
        return errors.New("invalid")
    }
    return save(data)
}
```

### 2. switch分支详解

**基本用法：**

```go
switch day := time.Now().Weekday(); day {
case time.Saturday, time.Sunday:
    fmt.Println("周末")
default:
    fmt.Println("工作日")
}
```

**类型switch：**

```go
func describe(i interface{}) {
    switch v := i.(type) {
    case int:
        fmt.Printf("整数: %d\n", v)
    case string:
        fmt.Printf("字符串: %s\n", v)
    case bool:
        fmt.Printf("布尔: %t\n", v)
    default:
        fmt.Printf("未知类型: %T\n", v)
    }
}
```

**无条件switch（替代多个if-else）：**

```go
t := time.Now()
switch {
case t.Hour() < 12:
    fmt.Println("上午好")
case t.Hour() < 18:
    fmt.Println("下午好")
default:
    fmt.Println("晚上好")
}
```

**fallthrough关键字：**

```go
switch num := 2; num {
case 1:
    fmt.Println("一")
case 2:
    fmt.Println("二")
    fallthrough  // 继续执行下一个case
case 3:
    fmt.Println("三")  // 会执行
}
// 输出：二 三
```

### 3. for循环详解

**传统三段式：**

```go
sum := 0
for i := 0; i < 10; i++ {
    sum += i
}
fmt.Println(sum)  // 45
```

**while风格：**

```go
i := 0
for i < 10 {
    fmt.Println(i)
    i++
}
```

**无限循环：**

```go
for {
    // 无限循环
    if someCondition {
        break  // 退出循环
    }
    if anotherCondition {
        continue  // 跳过本次迭代
    }
}
```

**标签与跳转：**

```go
OuterLoop:
for i := 0; i < 3; i++ {
    for j := 0; j < 3; j++ {
        if i == 1 && j == 1 {
            break OuterLoop  // 跳出外层循环
        }
        fmt.Printf("(%d,%d) ", i, j)
    }
}
// 输出：(0,0) (0,1) (0,2) (1,0)
```

### 4. for-range遍历详解

**遍历切片：**

```go
arr := []int{1, 2, 3, 4, 5}

// 索引和值
for idx, val := range arr {
    fmt.Printf("arr[%d] = %d\n", idx, val)
}

// 只要值
for _, val := range arr {
    fmt.Println(val)
}

// 只要索引
for idx := range arr {
    fmt.Println(idx)
}
```

**遍历map：**

```go
m := map[string]int{"a": 1, "b": 2, "c": 3}

for key, value := range m {
    fmt.Printf("%s: %d\n", key, value)
}

// 注意：map遍历顺序是随机的！
```

**遍历字符串（按rune）：**

```go
s := "Hello世界"

// 按字节索引和rune值
for i, r := range s {
    fmt.Printf("%d: %c\n", i, r)
}

// 输出：
// 0: H
// 1: e
// 2: l
// 3: l
// 4: o
// 5: 世
// 8: 界
```

**遍历channel：**

```go
ch := make(chan int, 3)
ch <- 1
ch <- 2
ch <- 3
close(ch)

for val := range ch {
    fmt.Println(val)
}
```

---

## 高级特性与技巧

### 1. defer与循环

```go
// ❌ 错误：defer会堆积
func processFiles(files []string) error {
    for _, filename := range files {
        f, err := os.Open(filename)
        if err != nil {
            return err
        }
        defer f.Close()  // 在函数返回时才执行，可能泄漏
        process(f)
    }
    return nil
}

// ✅ 正确：使用闭包立即执行defer
func processFiles(files []string) error {
    for _, filename := range files {
        if err := func() error {
            f, err := os.Open(filename)
            if err != nil {
                return err
            }
            defer f.Close()  // 每次迭代结束时关闭
            return process(f)
        }(); err != nil {
            return err
        }
    }
    return nil
}
```

### 2. range的值复制问题

```go
type Point struct {
    X, Y int
}

points := []Point{{1, 2}, {3, 4}, {5, 6}}

// ❌ 错误：修改val不会影响原数组
for _, val := range points {
    val.X = 0  // 无效！
}

// ✅ 正确：使用索引
for i := range points {
    points[i].X = 0
}

// ✅ 或使用指针
for _, p := range []*Point{&points[0], &points[1], &points[2]} {
    p.X = 0
}
```

### 3. 闭包与循环变量

```go
// ❌ 错误：goroutine捕获同一变量
for i := 0; i < 5; i++ {
    go func() {
        fmt.Println(i)  // 可能全部输出5
    }()
}

// ✅ 正确：传递副本
for i := 0; i < 5; i++ {
    i := i  // 创建副本（Go 1.22+不再需要）
    go func() {
        fmt.Println(i)
    }()
}

// ✅ 或作为参数传递
for i := 0; i < 5; i++ {
    go func(n int) {
        fmt.Println(n)
    }(i)
}
```

---

## 工程分析与最佳实践

### 1. 代码可读性

- `if`、`switch`支持变量声明，推荐用于作用域收敛
- `for`是Go唯一的循环关键字，统一了while、do-while等语义
- 推荐使用`for-range`遍历集合，避免下标越界
- 分支和循环应避免嵌套过深，提升可读性
- 复杂条件可提前return，减少嵌套（early return）

### 2. 性能优化

- 循环内避免重复计算，提前计算不变量
- range遍历map/slice是值拷贝，大对象考虑使用索引
- 避免在循环中分配大量内存

### 3. 安全性

- 使用range遍历可以避免数组越界
- switch默认不fallthrough，避免遗漏break
- 循环变量在闭包中需注意作用域

---

## 常见错误与陷阱

### 1. 悬空的range变量

```go
// ❌ 错误
var results []*Result
for _, item := range items {
    result := &item  // item变量被复用
    results = append(results, result)
}
// 所有指针指向同一个item

// ✅ 正确
var results []*Result
for i := range items {
    result := &items[i]  // 使用索引
    results = append(results, result)
}
```

### 2. switch中的fallthrough陷阱

```go
// 容易出错
switch x {
case 1:
    doSomething()
    fallthrough  // 无条件执行下一个case
case 2:
    doOtherThing()  // 即使x=1也会执行
}
```

### 3. for循环中的defer

前面已经展示过，避免在循环中直接使用defer。

---

## 性能考量

### 1. range vs 传统for

```go
// Benchmark对比
func BenchmarkForLoop(b *testing.B) {
    arr := make([]int, 1000)
    for i := 0; i < b.N; i++ {
        sum := 0
        for j := 0; j < len(arr); j++ {
            sum += arr[j]
        }
    }
}

func BenchmarkForRange(b *testing.B) {
    arr := make([]int, 1000)
    for i := 0; i < b.N; i++ {
        sum := 0
        for _, v := range arr {
            sum += v
        }
    }
}

// 结果：性能基本相同，range更简洁安全
```

### 2. switch vs if-else链

对于多分支，switch通常比if-else链更高效（编译器可能生成跳转表）。

---

## 单元测试建议

### Table-Driven测试

```go
func TestMaxNumber(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"both positive", 5, 3, 5},
        {"first negative", -1, 2, 2},
        {"both negative", -5, -3, -3},
        {"equal", 4, 4, 4},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := max(tt.a, tt.b)
            if got != tt.want {
                t.Errorf("max(%d, %d) = %d, want %d", 
                    tt.a, tt.b, got, tt.want)
            }
        })
    }
}
```

### 分支覆盖率

```bash
# 运行测试并生成覆盖率报告
go test -cover
go test -coverprofile=coverage.out
go tool cover -html=coverage.out
```

---

## 参考文献

- [Go官方文档 - Effective Go](https://golang.org/doc/effective_go.html)
- [Go语言规范 - For statements](https://golang.org/ref/spec#For_statements)
- [Go语言规范 - Switch statements](https://golang.org/ref/spec#Switch_statements)
- [《Go语言圣经》](https://gopl.io/)
- [Go by Example - Control Flow](https://gobyexample.com/)

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025年10月27日  
**文档状态**: 已优化  
**适用版本**: Go 1.25.3+
