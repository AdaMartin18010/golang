# Goæµç¨‹æ§åˆ¶

> **ç®€ä»‹**: å…¨é¢è®²è§£Goè¯­è¨€çš„æµç¨‹æ§åˆ¶ç»“æ„ï¼ŒåŒ…æ‹¬ifã€switchã€forå¾ªç¯å’Œrangeéå†
> **ç‰ˆæœ¬**: Go 1.23+  
> **éš¾åº¦**: â­â­  
> **æ ‡ç­¾**: #åŸºç¡€ #æµç¨‹æ§åˆ¶ #å¾ªç¯ #åˆ†æ”¯

<!-- TOC START -->
- [Goæµç¨‹æ§åˆ¶](#goæµç¨‹æ§åˆ¶)
  - [ç†è®ºåŸºç¡€ä¸å½¢å¼åŒ–æè¿°](#ç†è®ºåŸºç¡€ä¸å½¢å¼åŒ–æè¿°)
  - [å…¸å‹ä»£ç ç¤ºä¾‹](#å…¸å‹ä»£ç ç¤ºä¾‹)
    - [1. ifåˆ†æ”¯è¯¦è§£](#1-ifåˆ†æ”¯è¯¦è§£)
    - [2. switchåˆ†æ”¯è¯¦è§£](#2-switchåˆ†æ”¯è¯¦è§£)
    - [3. forå¾ªç¯è¯¦è§£](#3-forå¾ªç¯è¯¦è§£)
    - [4. for-rangeéå†è¯¦è§£](#4-for-rangeéå†è¯¦è§£)
  - [é«˜çº§ç‰¹æ€§ä¸æŠ€å·§](#é«˜çº§ç‰¹æ€§ä¸æŠ€å·§)
  - [å·¥ç¨‹åˆ†æä¸æœ€ä½³å®è·µ](#å·¥ç¨‹åˆ†æä¸æœ€ä½³å®è·µ)
  - [å¸¸è§é”™è¯¯ä¸é™·é˜±](#å¸¸è§é”™è¯¯ä¸é™·é˜±)
  - [æ€§èƒ½è€ƒé‡](#æ€§èƒ½è€ƒé‡)
  - [å•å…ƒæµ‹è¯•å»ºè®®](#å•å…ƒæµ‹è¯•å»ºè®®)
  - [å‚è€ƒæ–‡çŒ®](#å‚è€ƒæ–‡çŒ®)
<!-- TOC END -->


## ğŸ“‹ ç›®å½•


- [ç†è®ºåŸºç¡€ä¸å½¢å¼åŒ–æè¿°](#ç†è®ºåŸºç¡€ä¸å½¢å¼åŒ–æè¿°)
  - [ä¸‰å¤§ç»“æ„](#ä¸‰å¤§ç»“æ„)
  - [å½¢å¼åŒ–æè¿°](#å½¢å¼åŒ–æè¿°)
  - [Goçš„è®¾è®¡å“²å­¦](#goçš„è®¾è®¡å“²å­¦)
- [å…¸å‹ä»£ç ç¤ºä¾‹](#å…¸å‹ä»£ç ç¤ºä¾‹)
  - [1. ifåˆ†æ”¯è¯¦è§£](#1-ifåˆ†æ”¯è¯¦è§£)
  - [2. switchåˆ†æ”¯è¯¦è§£](#2-switchåˆ†æ”¯è¯¦è§£)
  - [3. forå¾ªç¯è¯¦è§£](#3-forå¾ªç¯è¯¦è§£)
  - [4. for-rangeéå†è¯¦è§£](#4-for-rangeéå†è¯¦è§£)
- [é«˜çº§ç‰¹æ€§ä¸æŠ€å·§](#é«˜çº§ç‰¹æ€§ä¸æŠ€å·§)
  - [1. deferä¸å¾ªç¯](#1-deferä¸å¾ªç¯)
  - [2. rangeçš„å€¼å¤åˆ¶é—®é¢˜](#2-rangeçš„å€¼å¤åˆ¶é—®é¢˜)
  - [3. é—­åŒ…ä¸å¾ªç¯å˜é‡](#3-é—­åŒ…ä¸å¾ªç¯å˜é‡)
- [å·¥ç¨‹åˆ†æä¸æœ€ä½³å®è·µ](#å·¥ç¨‹åˆ†æä¸æœ€ä½³å®è·µ)
  - [1. ä»£ç å¯è¯»æ€§](#1-ä»£ç å¯è¯»æ€§)
  - [2. æ€§èƒ½ä¼˜åŒ–](#2-æ€§èƒ½ä¼˜åŒ–)
  - [3. å®‰å…¨æ€§](#3-å®‰å…¨æ€§)
- [å¸¸è§é”™è¯¯ä¸é™·é˜±](#å¸¸è§é”™è¯¯ä¸é™·é˜±)
  - [1. æ‚¬ç©ºçš„rangeå˜é‡](#1-æ‚¬ç©ºçš„rangeå˜é‡)
  - [2. switchä¸­çš„fallthroughé™·é˜±](#2-switchä¸­çš„fallthroughé™·é˜±)
  - [3. forå¾ªç¯ä¸­çš„defer](#3-forå¾ªç¯ä¸­çš„defer)
- [æ€§èƒ½è€ƒé‡](#æ€§èƒ½è€ƒé‡)
  - [1. range vs ä¼ ç»Ÿfor](#1-range-vs-ä¼ ç»Ÿfor)
  - [2. switch vs if-elseé“¾](#2-switch-vs-if-elseé“¾)
- [å•å…ƒæµ‹è¯•å»ºè®®](#å•å…ƒæµ‹è¯•å»ºè®®)
  - [Table-Drivenæµ‹è¯•](#table-drivenæµ‹è¯•)
  - [åˆ†æ”¯è¦†ç›–ç‡](#åˆ†æ”¯è¦†ç›–ç‡)
- [å‚è€ƒæ–‡çŒ®](#å‚è€ƒæ–‡çŒ®)

## ç†è®ºåŸºç¡€ä¸å½¢å¼åŒ–æè¿°

æµç¨‹æ§åˆ¶æ˜¯ç¨‹åºè®¾è®¡çš„æ ¸å¿ƒï¼Œå†³å®šäº†ä»£ç çš„æ‰§è¡Œé¡ºåºã€‚Goè¯­è¨€æ”¯æŒä¸‰å¤§ç±»æµç¨‹æ§åˆ¶ï¼šé¡ºåºã€åˆ†æ”¯ã€å¾ªç¯ã€‚

### ä¸‰å¤§ç»“æ„

- **é¡ºåºç»“æ„**ï¼šä»£ç è‡ªä¸Šè€Œä¸‹ä¾æ¬¡æ‰§è¡Œã€‚
- **åˆ†æ”¯ç»“æ„**ï¼šæ ¹æ®æ¡ä»¶é€‰æ‹©ä¸åŒè·¯å¾„ï¼ˆå¦‚`if`ã€`switch`ï¼‰ã€‚
- **å¾ªç¯ç»“æ„**ï¼šé‡å¤æ‰§è¡ŒæŸæ®µä»£ç ï¼ˆå¦‚`for`ï¼‰ã€‚

### å½¢å¼åŒ–æè¿°

ä½¿ç”¨ä¼ªä»£ç /æ•°å­¦è¡¨ç¤ºæ³•ï¼š

- **é¡ºåº**ï¼š$S_1; S_2; \ldots; S_n$
- **åˆ†æ”¯**ï¼š
  \[
    \text{if } C \text{ then } S_1 \text{ else } S_2
  \]
- **å¾ªç¯**ï¼š
  \[
    \text{while } C \text{ do } S
  \]

Goè¯­è¨€ä»¥`if`ã€`switch`ã€`for`ä¸ºæ ¸å¿ƒï¼Œç®€æ´é«˜æ•ˆã€‚

### Goçš„è®¾è®¡å“²å­¦

- **ç®€æ´æ€§**ï¼šåªæœ‰`for`ä¸€ç§å¾ªç¯ï¼Œç»Ÿä¸€whileã€do-whileç­‰è¯­ä¹‰
- **å¯è¯»æ€§**ï¼šå¼ºåˆ¶ä½¿ç”¨èŠ±æ‹¬å·`{}`ï¼Œé¿å…æ‚¬ç©ºelse
- **å®‰å…¨æ€§**ï¼šæ²¡æœ‰ä¸‰å…ƒè¿ç®—ç¬¦ï¼Œå‡å°‘å¤æ‚è¡¨è¾¾å¼
- **æ˜ç¡®æ€§**ï¼šbreak/continueé»˜è®¤åªå½±å“æœ€å†…å±‚å¾ªç¯

---

## å…¸å‹ä»£ç ç¤ºä¾‹

### 1. ifåˆ†æ”¯è¯¦è§£

**åŸºæœ¬ç”¨æ³•ï¼š**

```go
x := 10
if x > 5 {
    fmt.Println("xå¤§äº5")
} else {
    fmt.Println("xä¸å¤§äº5")
}
```

**å¸¦åˆå§‹åŒ–è¯­å¥ï¼ˆæ¨èï¼‰ï¼š**

```go
// å˜é‡errä»…åœ¨ifå—å†…å¯è§
if err := doSomething(); err != nil {
    return err
}
// erråœ¨è¿™é‡Œä¸å¯è§ï¼Œä½œç”¨åŸŸæ”¶æ•›
```

**å¤šåˆ†æ”¯ï¼š**

```go
score := 85
if score >= 90 {
    fmt.Println("ä¼˜ç§€")
} else if score >= 80 {
    fmt.Println("è‰¯å¥½")
} else if score >= 60 {
    fmt.Println("åŠæ ¼")
} else {
    fmt.Println("ä¸åŠæ ¼")
}
```

**Early Returnæ¨¡å¼ï¼ˆæœ€ä½³å®è·µï¼‰ï¼š**

```go
// âŒ åµŒå¥—è¿‡æ·±
func process(data string) error {
    if data != "" {
        if len(data) > 10 {
            if isValid(data) {
                return save(data)
            } else {
                return errors.New("invalid")
            }
        } else {
            return errors.New("too short")
        }
    } else {
        return errors.New("empty")
    }
}

// âœ… Early Returnï¼Œæ‰å¹³åŒ–
func process(data string) error {
    if data == "" {
        return errors.New("empty")
    }
    if len(data) <= 10 {
        return errors.New("too short")
    }
    if !isValid(data) {
        return errors.New("invalid")
    }
    return save(data)
}
```

### 2. switchåˆ†æ”¯è¯¦è§£

**åŸºæœ¬ç”¨æ³•ï¼š**

```go
switch day := time.Now().Weekday(); day {
case time.Saturday, time.Sunday:
    fmt.Println("å‘¨æœ«")
default:
    fmt.Println("å·¥ä½œæ—¥")
}
```

**ç±»å‹switchï¼š**

```go
func describe(i interface{}) {
    switch v := i.(type) {
    case int:
        fmt.Printf("æ•´æ•°: %d\n", v)
    case string:
        fmt.Printf("å­—ç¬¦ä¸²: %s\n", v)
    case bool:
        fmt.Printf("å¸ƒå°”: %t\n", v)
    default:
        fmt.Printf("æœªçŸ¥ç±»å‹: %T\n", v)
    }
}
```

**æ— æ¡ä»¶switchï¼ˆæ›¿ä»£å¤šä¸ªif-elseï¼‰ï¼š**

```go
t := time.Now()
switch {
case t.Hour() < 12:
    fmt.Println("ä¸Šåˆå¥½")
case t.Hour() < 18:
    fmt.Println("ä¸‹åˆå¥½")
default:
    fmt.Println("æ™šä¸Šå¥½")
}
```

**fallthroughå…³é”®å­—ï¼š**

```go
switch num := 2; num {
case 1:
    fmt.Println("ä¸€")
case 2:
    fmt.Println("äºŒ")
    fallthrough  // ç»§ç»­æ‰§è¡Œä¸‹ä¸€ä¸ªcase
case 3:
    fmt.Println("ä¸‰")  // ä¼šæ‰§è¡Œ
}
// è¾“å‡ºï¼šäºŒ ä¸‰
```

### 3. forå¾ªç¯è¯¦è§£

**ä¼ ç»Ÿä¸‰æ®µå¼ï¼š**

```go
sum := 0
for i := 0; i < 10; i++ {
    sum += i
}
fmt.Println(sum)  // 45
```

**whileé£æ ¼ï¼š**

```go
i := 0
for i < 10 {
    fmt.Println(i)
    i++
}
```

**æ— é™å¾ªç¯ï¼š**

```go
for {
    // æ— é™å¾ªç¯
    if someCondition {
        break  // é€€å‡ºå¾ªç¯
    }
    if anotherCondition {
        continue  // è·³è¿‡æœ¬æ¬¡è¿­ä»£
    }
}
```

**æ ‡ç­¾ä¸è·³è½¬ï¼š**

```go
OuterLoop:
for i := 0; i < 3; i++ {
    for j := 0; j < 3; j++ {
        if i == 1 && j == 1 {
            break OuterLoop  // è·³å‡ºå¤–å±‚å¾ªç¯
        }
        fmt.Printf("(%d,%d) ", i, j)
    }
}
// è¾“å‡ºï¼š(0,0) (0,1) (0,2) (1,0)
```

### 4. for-rangeéå†è¯¦è§£

**éå†åˆ‡ç‰‡ï¼š**

```go
arr := []int{1, 2, 3, 4, 5}

// ç´¢å¼•å’Œå€¼
for idx, val := range arr {
    fmt.Printf("arr[%d] = %d\n", idx, val)
}

// åªè¦å€¼
for _, val := range arr {
    fmt.Println(val)
}

// åªè¦ç´¢å¼•
for idx := range arr {
    fmt.Println(idx)
}
```

**éå†mapï¼š**

```go
m := map[string]int{"a": 1, "b": 2, "c": 3}

for key, value := range m {
    fmt.Printf("%s: %d\n", key, value)
}

// æ³¨æ„ï¼šmapéå†é¡ºåºæ˜¯éšæœºçš„ï¼
```

**éå†å­—ç¬¦ä¸²ï¼ˆæŒ‰runeï¼‰ï¼š**

```go
s := "Helloä¸–ç•Œ"

// æŒ‰å­—èŠ‚ç´¢å¼•å’Œruneå€¼
for i, r := range s {
    fmt.Printf("%d: %c\n", i, r)
}

// è¾“å‡ºï¼š
// 0: H
// 1: e
// 2: l
// 3: l
// 4: o
// 5: ä¸–
// 8: ç•Œ
```

**éå†channelï¼š**

```go
ch := make(chan int, 3)
ch <- 1
ch <- 2
ch <- 3
close(ch)

for val := range ch {
    fmt.Println(val)
}
```

---

## é«˜çº§ç‰¹æ€§ä¸æŠ€å·§

### 1. deferä¸å¾ªç¯

```go
// âŒ é”™è¯¯ï¼šdeferä¼šå †ç§¯
func processFiles(files []string) error {
    for _, filename := range files {
        f, err := os.Open(filename)
        if err != nil {
            return err
        }
        defer f.Close()  // åœ¨å‡½æ•°è¿”å›æ—¶æ‰æ‰§è¡Œï¼Œå¯èƒ½æ³„æ¼
        process(f)
    }
    return nil
}

// âœ… æ­£ç¡®ï¼šä½¿ç”¨é—­åŒ…ç«‹å³æ‰§è¡Œdefer
func processFiles(files []string) error {
    for _, filename := range files {
        if err := func() error {
            f, err := os.Open(filename)
            if err != nil {
                return err
            }
            defer f.Close()  // æ¯æ¬¡è¿­ä»£ç»“æŸæ—¶å…³é—­
            return process(f)
        }(); err != nil {
            return err
        }
    }
    return nil
}
```

### 2. rangeçš„å€¼å¤åˆ¶é—®é¢˜

```go
type Point struct {
    X, Y int
}

points := []Point{{1, 2}, {3, 4}, {5, 6}}

// âŒ é”™è¯¯ï¼šä¿®æ”¹valä¸ä¼šå½±å“åŸæ•°ç»„
for _, val := range points {
    val.X = 0  // æ— æ•ˆï¼
}

// âœ… æ­£ç¡®ï¼šä½¿ç”¨ç´¢å¼•
for i := range points {
    points[i].X = 0
}

// âœ… æˆ–ä½¿ç”¨æŒ‡é’ˆ
for _, p := range []*Point{&points[0], &points[1], &points[2]} {
    p.X = 0
}
```

### 3. é—­åŒ…ä¸å¾ªç¯å˜é‡

```go
// âŒ é”™è¯¯ï¼šgoroutineæ•è·åŒä¸€å˜é‡
for i := 0; i < 5; i++ {
    go func() {
        fmt.Println(i)  // å¯èƒ½å…¨éƒ¨è¾“å‡º5
    }()
}

// âœ… æ­£ç¡®ï¼šä¼ é€’å‰¯æœ¬
for i := 0; i < 5; i++ {
    i := i  // åˆ›å»ºå‰¯æœ¬ï¼ˆGo 1.22+ä¸å†éœ€è¦ï¼‰
    go func() {
        fmt.Println(i)
    }()
}

// âœ… æˆ–ä½œä¸ºå‚æ•°ä¼ é€’
for i := 0; i < 5; i++ {
    go func(n int) {
        fmt.Println(n)
    }(i)
}
```

---

## å·¥ç¨‹åˆ†æä¸æœ€ä½³å®è·µ

### 1. ä»£ç å¯è¯»æ€§

- `if`ã€`switch`æ”¯æŒå˜é‡å£°æ˜ï¼Œæ¨èç”¨äºä½œç”¨åŸŸæ”¶æ•›
- `for`æ˜¯Goå”¯ä¸€çš„å¾ªç¯å…³é”®å­—ï¼Œç»Ÿä¸€äº†whileã€do-whileç­‰è¯­ä¹‰
- æ¨èä½¿ç”¨`for-range`éå†é›†åˆï¼Œé¿å…ä¸‹æ ‡è¶Šç•Œ
- åˆ†æ”¯å’Œå¾ªç¯åº”é¿å…åµŒå¥—è¿‡æ·±ï¼Œæå‡å¯è¯»æ€§
- å¤æ‚æ¡ä»¶å¯æå‰returnï¼Œå‡å°‘åµŒå¥—ï¼ˆearly returnï¼‰

### 2. æ€§èƒ½ä¼˜åŒ–

- å¾ªç¯å†…é¿å…é‡å¤è®¡ç®—ï¼Œæå‰è®¡ç®—ä¸å˜é‡
- rangeéå†map/sliceæ˜¯å€¼æ‹·è´ï¼Œå¤§å¯¹è±¡è€ƒè™‘ä½¿ç”¨ç´¢å¼•
- é¿å…åœ¨å¾ªç¯ä¸­åˆ†é…å¤§é‡å†…å­˜

### 3. å®‰å…¨æ€§

- ä½¿ç”¨rangeéå†å¯ä»¥é¿å…æ•°ç»„è¶Šç•Œ
- switché»˜è®¤ä¸fallthroughï¼Œé¿å…é—æ¼break
- å¾ªç¯å˜é‡åœ¨é—­åŒ…ä¸­éœ€æ³¨æ„ä½œç”¨åŸŸ

---

## å¸¸è§é”™è¯¯ä¸é™·é˜±

### 1. æ‚¬ç©ºçš„rangeå˜é‡

```go
// âŒ é”™è¯¯
var results []*Result
for _, item := range items {
    result := &item  // itemå˜é‡è¢«å¤ç”¨
    results = append(results, result)
}
// æ‰€æœ‰æŒ‡é’ˆæŒ‡å‘åŒä¸€ä¸ªitem

// âœ… æ­£ç¡®
var results []*Result
for i := range items {
    result := &items[i]  // ä½¿ç”¨ç´¢å¼•
    results = append(results, result)
}
```

### 2. switchä¸­çš„fallthroughé™·é˜±

```go
// å®¹æ˜“å‡ºé”™
switch x {
case 1:
    doSomething()
    fallthrough  // æ— æ¡ä»¶æ‰§è¡Œä¸‹ä¸€ä¸ªcase
case 2:
    doOtherThing()  // å³ä½¿x=1ä¹Ÿä¼šæ‰§è¡Œ
}
```

### 3. forå¾ªç¯ä¸­çš„defer

å‰é¢å·²ç»å±•ç¤ºè¿‡ï¼Œé¿å…åœ¨å¾ªç¯ä¸­ç›´æ¥ä½¿ç”¨deferã€‚

---

## æ€§èƒ½è€ƒé‡

### 1. range vs ä¼ ç»Ÿfor

```go
// Benchmarkå¯¹æ¯”
func BenchmarkForLoop(b *testing.B) {
    arr := make([]int, 1000)
    for i := 0; i < b.N; i++ {
        sum := 0
        for j := 0; j < len(arr); j++ {
            sum += arr[j]
        }
    }
}

func BenchmarkForRange(b *testing.B) {
    arr := make([]int, 1000)
    for i := 0; i < b.N; i++ {
        sum := 0
        for _, v := range arr {
            sum += v
        }
    }
}

// ç»“æœï¼šæ€§èƒ½åŸºæœ¬ç›¸åŒï¼Œrangeæ›´ç®€æ´å®‰å…¨
```

### 2. switch vs if-elseé“¾

å¯¹äºå¤šåˆ†æ”¯ï¼Œswitché€šå¸¸æ¯”if-elseé“¾æ›´é«˜æ•ˆï¼ˆç¼–è¯‘å™¨å¯èƒ½ç”Ÿæˆè·³è½¬è¡¨ï¼‰ã€‚

---

## å•å…ƒæµ‹è¯•å»ºè®®

### Table-Drivenæµ‹è¯•

```go
func TestMaxNumber(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"both positive", 5, 3, 5},
        {"first negative", -1, 2, 2},
        {"both negative", -5, -3, -3},
        {"equal", 4, 4, 4},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := max(tt.a, tt.b)
            if got != tt.want {
                t.Errorf("max(%d, %d) = %d, want %d", 
                    tt.a, tt.b, got, tt.want)
            }
        })
    }
}
```

### åˆ†æ”¯è¦†ç›–ç‡

```bash
# è¿è¡Œæµ‹è¯•å¹¶ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
go test -cover
go test -coverprofile=coverage.out
go tool cover -html=coverage.out
```

---

## å‚è€ƒæ–‡çŒ®

- [Goå®˜æ–¹æ–‡æ¡£ - Effective Go](https://golang.org/doc/effective_go.html)
- [Goè¯­è¨€è§„èŒƒ - For statements](https://golang.org/ref/spec#For_statements)
- [Goè¯­è¨€è§„èŒƒ - Switch statements](https://golang.org/ref/spec#Switch_statements)
- [ã€ŠGoè¯­è¨€åœ£ç»ã€‹](https://gopl.io/)
- [Go by Example - Control Flow](https://gobyexample.com/)

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ27æ—¥  
**æ–‡æ¡£çŠ¶æ€**: å·²ä¼˜åŒ–  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
