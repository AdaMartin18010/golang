# Go语言数组与切片

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3+

---

## 📋 目录

- [📚 理论分析](#理论分析)
  - [数组的本质](#数组的本质)
  - [切片的内部结构](#切片的内部结构)
- [💻 代码实现](#代码实现)
  - [数组基础](#数组基础)
  - [切片基础](#切片基础)
  - [切片操作](#切片操作)
  - [切片扩容](#切片扩容)
  - [多维数组和切片](#多维数组和切片)
- [📊 性能分析](#性能分析)
- [🧪 测试代码](#测试代码)
- [🎯 最佳实践](#最佳实践)
  - [1. 预分配容量](#1.-预分配容量)
  - [2. 避免切片陷阱](#2.-避免切片陷阱)
  - [3. 安全删除](#3.-安全删除)
  - [4. nil切片vs空切片](#4.-nil切片vs空切片)
- [🔍 常见问题](#常见问题)
  - [Q1: 数组和切片有什么区别？](#q1-数组和切片有什么区别)
  - [Q2: 切片扩容规则是什么？](#q2-切片扩容规则是什么)
  - [Q3: 如何安全地修改切片？](#q3-如何安全地修改切片)
  - [Q4: 为什么推荐预分配容量？](#q4-为什么推荐预分配容量)
  - [Q5: 如何判断切片为空？](#q5-如何判断切片为空)
- [📚 扩展阅读](#扩展阅读)
  - [相关概念](#相关概念)
  - [进阶主题](#进阶主题)

## 📚 理论分析

### 数组的本质

数组是**值类型**，具有固定长度：

```text
ArrayType ::= "[" ArrayLength "]" ElementType
ArrayLength ::= Expression
```

特点：

- 长度是类型的一部分：`[3]int`和`[4]int`是不同类型
- 在内存中连续存储
- 赋值和传参会复制整个数组

### 切片的内部结构

切片是**引用类型**，其内部结构为：

```go
type slice struct {
    array unsafe.Pointer // 指向底层数组的指针
    len   int            // 长度
    cap   int            // 容量
}
```

特点：

- 动态长度
- 共享底层数组
- 三个属性：指针、长度、容量

## 💻 代码实现

### 数组基础

```go
package main

import "fmt"

func main() {
    // 1. 数组声明和初始化
    var arr1 [5]int
    fmt.Printf("Zero value array: %v\n", arr1) // [0 0 0 0 0]
    
    // 2. 数组字面量初始化
    arr2 := [5]int{1, 2, 3, 4, 5}
    fmt.Printf("Initialized array: %v\n", arr2)
    
    // 3. 部分初始化
    arr3 := [5]int{1, 2}  // 其余元素为零值
    fmt.Printf("Partial init: %v\n", arr3)
    
    // 4. 自动推断长度
    arr4 := [...]int{1, 2, 3, 4, 5, 6}
    fmt.Printf("Auto length: %v, len=%d\n", arr4, len(arr4))
    
    // 5. 指定索引初始化
    arr5 := [10]int{1: 10, 5: 50, 9: 90}
    fmt.Printf("Index init: %v\n", arr5)
    
    // 6. 数组遍历
    fmt.Println("Traversal:")
    for i := 0; i < len(arr2); i++ {
        fmt.Printf("  arr2[%d] = %d\n", i, arr2[i])
    }
    
    // 7. for-range遍历
    fmt.Println("For-range:")
    for index, value := range arr2 {
        fmt.Printf("  Index %d: %d\n", index, value)
    }
    
    // 8. 数组比较
    arr6 := [3]int{1, 2, 3}
    arr7 := [3]int{1, 2, 3}
    arr8 := [3]int{1, 2, 4}
    fmt.Printf("arr6 == arr7: %t\n", arr6 == arr7) // true
    fmt.Printf("arr6 == arr8: %t\n", arr6 == arr8) // false
    
    // 9. 数组是值类型（赋值复制）
    arr9 := [3]int{1, 2, 3}
    arr10 := arr9      // 复制整个数组
    arr10[0] = 100
    fmt.Printf("Original arr9: %v\n", arr9)   // [1 2 3]
    fmt.Printf("Modified arr10: %v\n", arr10) // [100 2 3]
}
```

### 切片基础

```go
package main

import "fmt"

func main() {
    // 1. 切片声明（nil切片）
    var slice1 []int
    fmt.Printf("Nil slice: %v, len=%d, cap=%d, nil=%t\n", 
        slice1, len(slice1), cap(slice1), slice1 == nil)
    
    // 2. 使用make创建切片
    slice2 := make([]int, 5)      // 长度5，容量5
    slice3 := make([]int, 5, 10)  // 长度5，容量10
    fmt.Printf("slice2: %v, len=%d, cap=%d\n", slice2, len(slice2), cap(slice2))
    fmt.Printf("slice3: %v, len=%d, cap=%d\n", slice3, len(slice3), cap(slice3))
    
    // 3. 切片字面量
    slice4 := []int{1, 2, 3, 4, 5}
    fmt.Printf("Literal slice: %v, len=%d, cap=%d\n", 
        slice4, len(slice4), cap(slice4))
    
    // 4. 从数组创建切片
    arr := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    slice5 := arr[2:7]   // [2 3 4 5 6]
    slice6 := arr[:5]    // [0 1 2 3 4]
    slice7 := arr[5:]    // [5 6 7 8 9]
    slice8 := arr[:]     // [0 1 2 3 4 5 6 7 8 9]
    
    fmt.Printf("slice5: %v\n", slice5)
    fmt.Printf("slice6: %v\n", slice6)
    fmt.Printf("slice7: %v\n", slice7)
    fmt.Printf("slice8: %v\n", slice8)
    
    // 5. 切片共享底层数组
    slice9 := []int{1, 2, 3, 4, 5}
    slice10 := slice9[1:4]  // [2 3 4]
    slice10[0] = 100
    fmt.Printf("slice9: %v\n", slice9)   // [1 100 3 4 5] - 被修改！
    fmt.Printf("slice10: %v\n", slice10) // [100 3 4]
}
```

### 切片操作

```go
package main

import "fmt"

func main() {
    // 1. append追加元素
    slice := []int{1, 2, 3}
    fmt.Printf("Original: %v, len=%d, cap=%d\n", slice, len(slice), cap(slice))
    
    slice = append(slice, 4)
    fmt.Printf("After append(4): %v, len=%d, cap=%d\n", slice, len(slice), cap(slice))
    
    slice = append(slice, 5, 6, 7)
    fmt.Printf("After append(5,6,7): %v, len=%d, cap=%d\n", slice, len(slice), cap(slice))
    
    // 2. append另一个切片
    slice2 := []int{8, 9, 10}
    slice = append(slice, slice2...)
    fmt.Printf("After append slice: %v, len=%d, cap=%d\n", slice, len(slice), cap(slice))
    
    // 3. copy切片
    src := []int{1, 2, 3, 4, 5}
    dst := make([]int, len(src))
    n := copy(dst, src)
    fmt.Printf("Copied %d elements: %v\n", n, dst)
    
    // 部分copy
    dst2 := make([]int, 3)
    copy(dst2, src)
    fmt.Printf("Partial copy: %v\n", dst2) // [1 2 3]
    
    // 4. 删除元素
    slice3 := []int{1, 2, 3, 4, 5}
    
    // 删除索引2的元素
    index := 2
    slice3 = append(slice3[:index], slice3[index+1:]...)
    fmt.Printf("After delete: %v\n", slice3) // [1 2 4 5]
    
    // 5. 插入元素
    slice4 := []int{1, 2, 4, 5}
    index = 2
    value := 3
    
    // 在索引2插入3
    slice4 = append(slice4[:index], append([]int{value}, slice4[index:]...)...)
    fmt.Printf("After insert: %v\n", slice4) // [1 2 3 4 5]
    
    // 6. 切片反转
    slice5 := []int{1, 2, 3, 4, 5}
    for i, j := 0, len(slice5)-1; i < j; i, j = i+1, j-1 {
        slice5[i], slice5[j] = slice5[j], slice5[i]
    }
    fmt.Printf("Reversed: %v\n", slice5) // [5 4 3 2 1]
}
```

### 切片扩容

```go
package main

import "fmt"

func main() {
    // 观察切片扩容
    slice := make([]int, 0, 1)
    
    for i := 0; i < 20; i++ {
        prevLen := len(slice)
        prevCap := cap(slice)
        
        slice = append(slice, i)
        
        if cap(slice) != prevCap {
            fmt.Printf("Len: %d -> %d, Cap: %d -> %d (growth: %.2fx)\n",
                prevLen, len(slice), prevCap, cap(slice),
                float64(cap(slice))/float64(prevCap))
        }
    }
    
    // 扩容规则（Go 1.18+）：
    // - cap < 256: 2倍增长
    // - cap >= 256: 1.25倍增长（平滑过渡）
}
```

### 多维数组和切片

```go
package main

import "fmt"

func main() {
    // 1. 二维数组
    var matrix1 [3][4]int
    fmt.Printf("2D array: %v\n", matrix1)
    
    // 2. 二维数组初始化
    matrix2 := [3][4]int{
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12},
    }
    fmt.Printf("Initialized 2D array:\n")
    for i := 0; i < len(matrix2); i++ {
        for j := 0; j < len(matrix2[i]); j++ {
            fmt.Printf("%3d ", matrix2[i][j])
        }
        fmt.Println()
    }
    
    // 3. 二维切片（切片的切片）
    rows, cols := 3, 4
    matrix3 := make([][]int, rows)
    for i := range matrix3 {
        matrix3[i] = make([]int, cols)
    }
    
    // 填充数据
    value := 1
    for i := 0; i < rows; i++ {
        for j := 0; j < cols; j++ {
            matrix3[i][j] = value
            value++
        }
    }
    
    fmt.Printf("\n2D slice:\n")
    for _, row := range matrix3 {
        fmt.Printf("%v\n", row)
    }
}
```

## 📊 性能分析

```go
package main

import "testing"

// 基准测试：数组vs切片
func BenchmarkArray(b *testing.B) {
    var arr [1000]int
    for i := 0; i < b.N; i++ {
        for j := 0; j < len(arr); j++ {
            arr[j] = j
        }
    }
}

func BenchmarkSlice(b *testing.B) {
    slice := make([]int, 1000)
    for i := 0; i < b.N; i++ {
        for j := 0; j < len(slice); j++ {
            slice[j] = j
        }
    }
}

// 基准测试：append性能
func BenchmarkAppend(b *testing.B) {
    for i := 0; i < b.N; i++ {
        var slice []int
        for j := 0; j < 1000; j++ {
            slice = append(slice, j)
        }
    }
}

func BenchmarkAppendPrealloc(b *testing.B) {
    for i := 0; i < b.N; i++ {
        slice := make([]int, 0, 1000)
        for j := 0; j < 1000; j++ {
            slice = append(slice, j)
        }
    }
}

// 基准测试：copy性能
func BenchmarkCopy(b *testing.B) {
    src := make([]int, 1000)
    dst := make([]int, 1000)
    
    for i := 0; i < b.N; i++ {
        copy(dst, src)
    }
}
```

## 🧪 测试代码

```go
package main

import (
    "reflect"
    "testing"
)

func TestSliceAppend(t *testing.T) {
    slice := []int{1, 2, 3}
    slice = append(slice, 4)
    
    expected := []int{1, 2, 3, 4}
    if !reflect.DeepEqual(slice, expected) {
        t.Errorf("Got %v, want %v", slice, expected)
    }
}

func TestSliceCopy(t *testing.T) {
    src := []int{1, 2, 3, 4, 5}
    dst := make([]int, len(src))
    
    n := copy(dst, src)
    
    if n != len(src) {
        t.Errorf("Copied %d elements, want %d", n, len(src))
    }
    
    if !reflect.DeepEqual(src, dst) {
        t.Errorf("Got %v, want %v", dst, src)
    }
}
```

## 🎯 最佳实践

### 1. 预分配容量

```go
// ❌ 不好 - 多次扩容
slice := []int{}
for i := 0; i < 1000; i++ {
    slice = append(slice, i)
}

// ✅ 好 - 预分配容量
slice := make([]int, 0, 1000)
for i := 0; i < 1000; i++ {
    slice = append(slice, i)
}
```

### 2. 避免切片陷阱

```go
// ❌ 潜在的内存泄漏
func getSlice() []int {
    large := make([]int, 1000000)
    return large[:10] // 仍然引用整个大数组
}

// ✅ 正确做法 - 复制需要的部分
func getSlice() []int {
    large := make([]int, 1000000)
    result := make([]int, 10)
    copy(result, large[:10])
    return result
}
```

### 3. 安全删除

```go
// ✅ 删除元素（保持顺序）
func remove(slice []int, index int) []int {
    return append(slice[:index], slice[index+1:]...)
}

// ✅ 删除元素（不保持顺序，更快）
func removeUnordered(slice []int, index int) []int {
    slice[index] = slice[len(slice)-1]
    return slice[:len(slice)-1]
}
```

### 4. nil切片vs空切片

```go
var nil切片 []int         // nil, len=0, cap=0
空切片 := []int{}          // not nil, len=0, cap=0
空切片2 := make([]int, 0)  // not nil, len=0, cap=0

// 大多数情况下行为相同，但JSON序列化不同
// nil切片 -> null
// 空切片 -> []
```

## 🔍 常见问题

### Q1: 数组和切片有什么区别？

A:

- 数组：固定长度，值类型，长度是类型的一部分
- 切片：动态长度，引用类型，更灵活

### Q2: 切片扩容规则是什么？

A: Go 1.18+的扩容策略：

- cap < 256: 容量翻倍
- cap >= 256: 容量增长约1.25倍（平滑增长）

### Q3: 如何安全地修改切片？

A: 确保不会影响其他共享同一底层数组的切片，或者使用copy创建独立副本。

### Q4: 为什么推荐预分配容量？

A: 减少扩容次数，避免重复分配内存和复制数据，提高性能。

### Q5: 如何判断切片为空？

A: 使用`len(slice) == 0`而不是`slice == nil`，因为空切片和nil切片都是有效的空切片。

## 📚 扩展阅读

### 相关概念

- [基本数据类型](./03-基本数据类型.md)
- [映射](./10-映射.md)
- [for循环](./04-流程控制.md)

### 进阶主题

- 切片内部实现
- 内存优化技巧
- slice包（Go 1.21+）
- 切片的并发安全

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025-10-29  
**文档状态**: ✅ 已完成  
**适用版本**: Go 1.25.3+
