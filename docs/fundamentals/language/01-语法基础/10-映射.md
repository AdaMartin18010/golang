# Goè¯­è¨€æ˜ å°„(Map)

> **ç®€ä»‹**: æ·±å…¥è®²è§£Goè¯­è¨€çš„æ˜ å°„ç±»å‹ï¼ŒåŒ…æ‹¬åˆ›å»ºã€æ“ä½œã€å¹¶å‘å®‰å…¨å’Œæ€§èƒ½ä¼˜åŒ–
> **ç‰ˆæœ¬**: Go 1.25.3+  
> **éš¾åº¦**: â­â­  
> **æ ‡ç­¾**: #åŸºç¡€ #æ˜ å°„ #å“ˆå¸Œè¡¨ #é›†åˆ

<!-- TOC START -->
- [Goè¯­è¨€æ˜ å°„(Map)](#goè¯­è¨€æ˜ å°„map)
  - [ğŸ“š ç†è®ºåˆ†æ](#-ç†è®ºåˆ†æ)
    - [æ˜ å°„çš„å†…éƒ¨ç»“æ„](#æ˜ å°„çš„å†…éƒ¨ç»“æ„)
  - [ğŸ’» ä»£ç å®ç°](#-ä»£ç å®ç°)
    - [æ˜ å°„åˆ›å»ºä¸åˆå§‹åŒ–](#æ˜ å°„åˆ›å»ºä¸åˆå§‹åŒ–)
    - [æ˜ å°„æ“ä½œ](#æ˜ å°„æ“ä½œ)
    - [æ˜ å°„éå†](#æ˜ å°„éå†)
    - [æ˜ å°„ä½œä¸ºé›†åˆ](#æ˜ å°„ä½œä¸ºé›†åˆ)
    - [æ˜ å°„çš„å€¼ä¸ºå¤æ‚ç±»å‹](#æ˜ å°„çš„å€¼ä¸ºå¤æ‚ç±»å‹)
  - [ğŸ“Š æ€§èƒ½åˆ†æ](#-æ€§èƒ½åˆ†æ)
  - [ğŸ§ª æµ‹è¯•ä»£ç ](#-æµ‹è¯•ä»£ç )
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [1. é¢„åˆ†é…å®¹é‡](#1-é¢„åˆ†é…å®¹é‡)
    - [2. æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨](#2-æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨)
    - [3. å¹¶å‘å®‰å…¨](#3-å¹¶å‘å®‰å…¨)
    - [4. åˆ é™¤æ˜ å°„å…ƒç´ ](#4-åˆ é™¤æ˜ å°„å…ƒç´ )
    - [5. nilæ˜ å°„æ£€æŸ¥](#5-nilæ˜ å°„æ£€æŸ¥)
  - [ğŸ” å¸¸è§é—®é¢˜](#-å¸¸è§é—®é¢˜)
    - [Q1: æ˜ å°„æ˜¯å¹¶å‘å®‰å…¨çš„å—ï¼Ÿ](#q1-æ˜ å°„æ˜¯å¹¶å‘å®‰å…¨çš„å—)
    - [Q2: æ˜ å°„çš„éå†é¡ºåºæ˜¯ä»€ä¹ˆï¼Ÿ](#q2-æ˜ å°„çš„éå†é¡ºåºæ˜¯ä»€ä¹ˆ)
    - [Q3: å¯ä»¥ä½¿ç”¨åˆ‡ç‰‡ä½œä¸ºæ˜ å°„çš„é”®å—ï¼Ÿ](#q3-å¯ä»¥ä½¿ç”¨åˆ‡ç‰‡ä½œä¸ºæ˜ å°„çš„é”®å—)
    - [Q4: å¦‚ä½•å¤åˆ¶ä¸€ä¸ªæ˜ å°„ï¼Ÿ](#q4-å¦‚ä½•å¤åˆ¶ä¸€ä¸ªæ˜ å°„)
    - [Q5: æ˜ å°„çš„é›¶å€¼æ˜¯ä»€ä¹ˆï¼Ÿ](#q5-æ˜ å°„çš„é›¶å€¼æ˜¯ä»€ä¹ˆ)
  - [ğŸ“š æ‰©å±•é˜…è¯»](#-æ‰©å±•é˜…è¯»)
    - [ç›¸å…³æ¦‚å¿µ](#ç›¸å…³æ¦‚å¿µ)
    - [è¿›é˜¶ä¸»é¢˜](#è¿›é˜¶ä¸»é¢˜)
<!-- TOC END -->

## ğŸ“‹ ç›®å½•

- [ğŸ“š ç†è®ºåˆ†æ](#-ç†è®ºåˆ†æ)
  - [æ˜ å°„çš„å†…éƒ¨ç»“æ„](#æ˜ å°„çš„å†…éƒ¨ç»“æ„)
- [ğŸ’» ä»£ç å®ç°](#-ä»£ç å®ç°)
  - [æ˜ å°„åˆ›å»ºä¸åˆå§‹åŒ–](#æ˜ å°„åˆ›å»ºä¸åˆå§‹åŒ–)
  - [æ˜ å°„æ“ä½œ](#æ˜ å°„æ“ä½œ)
  - [æ˜ å°„éå†](#æ˜ å°„éå†)
  - [æ˜ å°„ä½œä¸ºé›†åˆ](#æ˜ å°„ä½œä¸ºé›†åˆ)
  - [æ˜ å°„çš„å€¼ä¸ºå¤æ‚ç±»å‹](#æ˜ å°„çš„å€¼ä¸ºå¤æ‚ç±»å‹)
- [ğŸ“Š æ€§èƒ½åˆ†æ](#-æ€§èƒ½åˆ†æ)
- [ğŸ§ª æµ‹è¯•ä»£ç ](#-æµ‹è¯•ä»£ç )
- [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
  - [1. é¢„åˆ†é…å®¹é‡](#1-é¢„åˆ†é…å®¹é‡)
  - [2. æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨](#2-æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨)
  - [3. å¹¶å‘å®‰å…¨](#3-å¹¶å‘å®‰å…¨)
  - [4. åˆ é™¤æ˜ å°„å…ƒç´ ](#4-åˆ é™¤æ˜ å°„å…ƒç´ )
  - [5. nilæ˜ å°„æ£€æŸ¥](#5-nilæ˜ å°„æ£€æŸ¥)
- [ğŸ” å¸¸è§é—®é¢˜](#-å¸¸è§é—®é¢˜)
  - [Q1: æ˜ å°„æ˜¯å¹¶å‘å®‰å…¨çš„å—ï¼Ÿ](#q1-æ˜ å°„æ˜¯å¹¶å‘å®‰å…¨çš„å—)
  - [Q2: æ˜ å°„çš„éå†é¡ºåºæ˜¯ä»€ä¹ˆï¼Ÿ](#q2-æ˜ å°„çš„éå†é¡ºåºæ˜¯ä»€ä¹ˆ)
  - [Q3: å¯ä»¥ä½¿ç”¨åˆ‡ç‰‡ä½œä¸ºæ˜ å°„çš„é”®å—ï¼Ÿ](#q3-å¯ä»¥ä½¿ç”¨åˆ‡ç‰‡ä½œä¸ºæ˜ å°„çš„é”®å—)
  - [Q4: å¦‚ä½•å¤åˆ¶ä¸€ä¸ªæ˜ å°„ï¼Ÿ](#q4-å¦‚ä½•å¤åˆ¶ä¸€ä¸ªæ˜ å°„)
  - [Q5: æ˜ å°„çš„é›¶å€¼æ˜¯ä»€ä¹ˆï¼Ÿ](#q5-æ˜ å°„çš„é›¶å€¼æ˜¯ä»€ä¹ˆ)
- [ğŸ“š æ‰©å±•é˜…è¯»](#-æ‰©å±•é˜…è¯»)
  - [ç›¸å…³æ¦‚å¿µ](#ç›¸å…³æ¦‚å¿µ)
  - [è¿›é˜¶ä¸»é¢˜](#è¿›é˜¶ä¸»é¢˜)

## ğŸ“š ç†è®ºåˆ†æ

### æ˜ å°„çš„å†…éƒ¨ç»“æ„

æ˜ å°„åœ¨Goä¸­æ˜¯åŸºäºå“ˆå¸Œè¡¨å®ç°çš„å¼•ç”¨ç±»å‹ï¼š

```go
// ç®€åŒ–çš„å†…éƒ¨ç»“æ„
type hmap struct {
    count     int    // å…ƒç´ ä¸ªæ•°
    flags     uint8
    B         uint8  // æ¡¶çš„æ•°é‡ = 2^B
    hash0     uint32 // å“ˆå¸Œç§å­
    buckets   unsafe.Pointer // æ¡¶æ•°ç»„
    oldbuckets unsafe.Pointer // æ—§æ¡¶ï¼ˆæ‰©å®¹æ—¶ï¼‰
}
```

ç‰¹ç‚¹ï¼š

- æ— åºé›†åˆ
- é”®å¿…é¡»å¯æ¯”è¾ƒ
- é›¶å€¼ä¸ºnil
- éå¹¶å‘å®‰å…¨

## ğŸ’» ä»£ç å®ç°

### æ˜ å°„åˆ›å»ºä¸åˆå§‹åŒ–

```go
package main

import "fmt"

func main() {
    // 1. å£°æ˜nilæ˜ å°„ï¼ˆä¸èƒ½ç›´æ¥ä½¿ç”¨ï¼‰
    var m1 map[string]int
    fmt.Printf("Nil map: %v, len=%d, nil=%t\n", m1, len(m1), m1 == nil)
    // m1["key"] = 1 // panic: assignment to entry in nil map
    
    // 2. ä½¿ç”¨makeåˆ›å»ºç©ºæ˜ å°„
    m2 := make(map[string]int)
    fmt.Printf("Empty map: %v, len=%d\n", m2, len(m2))
    
    // 3. ä½¿ç”¨makeåˆ›å»ºæŒ‡å®šå®¹é‡çš„æ˜ å°„
    m3 := make(map[string]int, 100) // é¢„åˆ†é…100ä¸ªå…ƒç´ çš„ç©ºé—´
    fmt.Printf("Preallocated map: %v, len=%d\n", m3, len(m3))
    
    // 4. æ˜ å°„å­—é¢é‡åˆå§‹åŒ–
    m4 := map[string]int{
        "one":   1,
        "two":   2,
        "three": 3,
    }
    fmt.Printf("Literal map: %v, len=%d\n", m4, len(m4))
    
    // 5. ç©ºæ˜ å°„å­—é¢é‡
    m5 := map[string]int{}
    fmt.Printf("Empty literal map: %v, len=%d, nil=%t\n", m5, len(m5), m5 == nil)
    
    // 6. å¤æ‚é”®å€¼ç±»å‹
    type Person struct {
        Name string
        Age  int
    }
    
    m6 := map[string]Person{
        "alice": {Name: "Alice", Age: 25},
        "bob":   {Name: "Bob", Age: 30},
    }
    fmt.Printf("Complex value map: %v\n", m6)
    
    // 7. ç»“æ„ä½“ä½œä¸ºé”®ï¼ˆå¿…é¡»å¯æ¯”è¾ƒï¼‰
    type Point struct {
        X, Y int
    }
    
    m7 := map[Point]string{
        {0, 0}: "origin",
        {1, 1}: "diagonal",
    }
    fmt.Printf("Struct key map: %v\n", m7)
}
```

### æ˜ å°„æ“ä½œ

```go
package main

import "fmt"

func main() {
    scores := make(map[string]int)
    
    // 1. æ·»åŠ /æ›´æ–°å…ƒç´ 
    scores["Alice"] = 95
    scores["Bob"] = 87
    scores["Charlie"] = 92
    fmt.Printf("Scores: %v\n", scores)
    
    // æ›´æ–°å…ƒç´ 
    scores["Alice"] = 98
    fmt.Printf("After update: %v\n", scores)
    
    // 2. è¯»å–å…ƒç´ 
    aliceScore := scores["Alice"]
    fmt.Printf("Alice's score: %d\n", aliceScore)
    
    // 3. è¯»å–ä¸å­˜åœ¨çš„é”®ï¼ˆè¿”å›é›¶å€¼ï¼‰
    davidScore := scores["David"]
    fmt.Printf("David's score: %d (zero value)\n", davidScore)
    
    // 4. æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨ï¼ˆcomma ok idiomï¼‰
    score, exists := scores["Alice"]
    if exists {
        fmt.Printf("Alice exists with score: %d\n", score)
    }
    
    score, exists = scores["David"]
    if !exists {
        fmt.Println("David does not exist")
    }
    
    // 5. åˆ é™¤å…ƒç´ 
    delete(scores, "Bob")
    fmt.Printf("After delete: %v\n", scores)
    
    // åˆ é™¤ä¸å­˜åœ¨çš„é”®ï¼ˆå®‰å…¨ï¼Œä¸ä¼španicï¼‰
    delete(scores, "NonExistent")
    
    // 6. è·å–æ˜ å°„é•¿åº¦
    fmt.Printf("Number of students: %d\n", len(scores))
    
    // 7. æ¸…ç©ºæ˜ å°„
    scores = make(map[string]int) // åˆ›å»ºæ–°çš„ç©ºæ˜ å°„
    fmt.Printf("After clear: %v, len=%d\n", scores, len(scores))
}
```

### æ˜ å°„éå†

```go
package main

import "fmt"

func main() {
    ages := map[string]int{
        "Alice":   25,
        "Bob":     30,
        "Charlie": 35,
        "David":   28,
    }
    
    // 1. éå†é”®å’Œå€¼
    fmt.Println("Keys and values:")
    for name, age := range ages {
        fmt.Printf("  %s: %d\n", name, age)
    }
    
    // 2. åªéå†é”®
    fmt.Println("\nOnly keys:")
    for name := range ages {
        fmt.Printf("  %s\n", name)
    }
    
    // 3. åªéå†å€¼ï¼ˆä½¿ç”¨_å¿½ç•¥é”®ï¼‰
    fmt.Println("\nOnly values:")
    for _, age := range ages {
        fmt.Printf("  %d\n", age)
    }
    
    // 4. éå†é¡ºåºæ˜¯éšæœºçš„
    fmt.Println("\nMultiple iterations (random order):")
    for i := 0; i < 3; i++ {
        fmt.Printf("  Iteration %d: ", i+1)
        for name := range ages {
            fmt.Printf("%s ", name)
        }
        fmt.Println()
    }
    
    // 5. æœ‰åºéå†ï¼ˆéœ€è¦å…ˆæ’åºé”®ï¼‰
    fmt.Println("\nSorted iteration:")
    keys := make([]string, 0, len(ages))
    for k := range ages {
        keys = append(keys, k)
    }
    
    // ç®€å•æ’åºï¼ˆä½¿ç”¨å†’æ³¡æ’åºç¤ºä¾‹ï¼‰
    for i := 0; i < len(keys); i++ {
        for j := i + 1; j < len(keys); j++ {
            if keys[i] > keys[j] {
                keys[i], keys[j] = keys[j], keys[i]
            }
        }
    }
    
    for _, k := range keys {
        fmt.Printf("  %s: %d\n", k, ages[k])
    }
}
```

### æ˜ å°„ä½œä¸ºé›†åˆ

```go
package main

import "fmt"

// Set ä½¿ç”¨mapå®ç°é›†åˆ
type Set map[string]bool

// NewSet åˆ›å»ºé›†åˆ
func NewSet() Set {
    return make(Set)
}

// Add æ·»åŠ å…ƒç´ 
func (s Set) Add(item string) {
    s[item] = true
}

// Remove åˆ é™¤å…ƒç´ 
func (s Set) Remove(item string) {
    delete(s, item)
}

// Contains æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨
func (s Set) Contains(item string) bool {
    return s[item]
}

// Size é›†åˆå¤§å°
func (s Set) Size() int {
    return len(s)
}

// Items è¿”å›æ‰€æœ‰å…ƒç´ 
func (s Set) Items() []string {
    items := make([]string, 0, len(s))
    for item := range s {
        items = append(items, item)
    }
    return items
}

// Union å¹¶é›†
func (s Set) Union(other Set) Set {
    result := NewSet()
    for item := range s {
        result.Add(item)
    }
    for item := range other {
        result.Add(item)
    }
    return result
}

// Intersection äº¤é›†
func (s Set) Intersection(other Set) Set {
    result := NewSet()
    for item := range s {
        if other.Contains(item) {
            result.Add(item)
        }
    }
    return result
}

// Difference å·®é›†
func (s Set) Difference(other Set) Set {
    result := NewSet()
    for item := range s {
        if !other.Contains(item) {
            result.Add(item)
        }
    }
    return result
}

func main() {
    // ä½¿ç”¨Set
    set1 := NewSet()
    set1.Add("apple")
    set1.Add("banana")
    set1.Add("orange")
    
    set2 := NewSet()
    set2.Add("banana")
    set2.Add("grape")
    set2.Add("orange")
    
    fmt.Printf("Set1: %v\n", set1.Items())
    fmt.Printf("Set2: %v\n", set2.Items())
    fmt.Printf("Contains 'apple': %t\n", set1.Contains("apple"))
    
    union := set1.Union(set2)
    fmt.Printf("Union: %v\n", union.Items())
    
    intersection := set1.Intersection(set2)
    fmt.Printf("Intersection: %v\n", intersection.Items())
    
    difference := set1.Difference(set2)
    fmt.Printf("Difference: %v\n", difference.Items())
}
```

### æ˜ å°„çš„å€¼ä¸ºå¤æ‚ç±»å‹

```go
package main

import "fmt"

func main() {
    // 1. å€¼ä¸ºåˆ‡ç‰‡
    groups := map[string][]string{
        "fruits":     {"apple", "banana", "orange"},
        "vegetables": {"carrot", "potato", "tomato"},
    }
    
    // æ·»åŠ å…ƒç´ åˆ°åˆ‡ç‰‡
    groups["fruits"] = append(groups["fruits"], "grape")
    fmt.Printf("Groups: %v\n", groups)
    
    // 2. å€¼ä¸ºæ˜ å°„ï¼ˆåµŒå¥—æ˜ å°„ï¼‰
    students := map[string]map[string]int{
        "Alice": {
            "math":    95,
            "english": 87,
            "science": 92,
        },
        "Bob": {
            "math":    87,
            "english": 92,
            "science": 88,
        },
    }
    
    fmt.Printf("Alice's math score: %d\n", students["Alice"]["math"])
    
    // æ·»åŠ æ–°å­¦ç”Ÿ
    students["Charlie"] = make(map[string]int)
    students["Charlie"]["math"] = 90
    students["Charlie"]["english"] = 85
    
    // 3. å€¼ä¸ºç»“æ„ä½“æŒ‡é’ˆ
    type User struct {
        Name  string
        Email string
        Age   int
    }
    
    users := make(map[int]*User)
    users[1] = &User{Name: "Alice", Email: "alice@example.com", Age: 25}
    users[2] = &User{Name: "Bob", Email: "bob@example.com", Age: 30}
    
    // ä¿®æ”¹ç»“æ„ä½“å­—æ®µ
    users[1].Age = 26
    fmt.Printf("User 1: %+v\n", users[1])
    
    // 4. å€¼ä¸ºå‡½æ•°
    operations := map[string]func(int, int) int{
        "add": func(a, b int) int { return a + b },
        "sub": func(a, b int) int { return a - b },
        "mul": func(a, b int) int { return a * b },
        "div": func(a, b int) int {
            if b != 0 {
                return a / b
            }
            return 0
        },
    }
    
    result := operations["add"](10, 5)
    fmt.Printf("10 + 5 = %d\n", result)
}
```

## ğŸ“Š æ€§èƒ½åˆ†æ

```go
package main

import (
    "testing"
)

// åŸºå‡†æµ‹è¯•ï¼šæ˜ å°„åˆ›å»º
func BenchmarkMapCreation(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = make(map[string]int)
    }
}

func BenchmarkMapCreationWithCapacity(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = make(map[string]int, 1000)
    }
}

// åŸºå‡†æµ‹è¯•ï¼šæ˜ å°„æ’å…¥
func BenchmarkMapInsert(b *testing.B) {
    m := make(map[int]int)
    for i := 0; i < b.N; i++ {
        m[i] = i
    }
}

// åŸºå‡†æµ‹è¯•ï¼šæ˜ å°„æŸ¥æ‰¾
func BenchmarkMapLookup(b *testing.B) {
    m := make(map[int]int, 1000)
    for i := 0; i < 1000; i++ {
        m[i] = i
    }
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = m[i%1000]
    }
}

// åŸºå‡†æµ‹è¯•ï¼šæ˜ å°„åˆ é™¤
func BenchmarkMapDelete(b *testing.B) {
    for i := 0; i < b.N; i++ {
        b.StopTimer()
        m := make(map[int]int, 1000)
        for j := 0; j < 1000; j++ {
            m[j] = j
        }
        b.StartTimer()
        
        for j := 0; j < 1000; j++ {
            delete(m, j)
        }
    }
}
```

## ğŸ§ª æµ‹è¯•ä»£ç 

```go
package main

import (
    "testing"
)

func TestMapOperations(t *testing.T) {
    m := make(map[string]int)
    
    // æµ‹è¯•æ’å…¥
    m["one"] = 1
    if m["one"] != 1 {
        t.Errorf("Expected 1, got %d", m["one"])
    }
    
    // æµ‹è¯•æ›´æ–°
    m["one"] = 11
    if m["one"] != 11 {
        t.Errorf("Expected 11, got %d", m["one"])
    }
    
    // æµ‹è¯•åˆ é™¤
    delete(m, "one")
    if _, exists := m["one"]; exists {
        t.Error("Key should not exist after delete")
    }
}

func TestMapZeroValue(t *testing.T) {
    m := make(map[string]int)
    
    // è®¿é—®ä¸å­˜åœ¨çš„é”®åº”è¿”å›é›¶å€¼
    value := m["nonexistent"]
    if value != 0 {
        t.Errorf("Expected 0, got %d", value)
    }
}
```

## ğŸ¯ æœ€ä½³å®è·µ

### 1. é¢„åˆ†é…å®¹é‡

```go
// âŒ ä¸å¥½ - å¯èƒ½å¤šæ¬¡æ‰©å®¹
m := make(map[string]int)
for i := 0; i < 1000; i++ {
    m[fmt.Sprintf("key%d", i)] = i
}

// âœ… å¥½ - é¢„åˆ†é…å®¹é‡
m := make(map[string]int, 1000)
for i := 0; i < 1000; i++ {
    m[fmt.Sprintf("key%d", i)] = i
}
```

### 2. æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨

```go
// âŒ ä¸å¥½ - æ— æ³•åŒºåˆ†é›¶å€¼å’Œä¸å­˜åœ¨
value := m["key"]

// âœ… å¥½ - ä½¿ç”¨comma ok idiom
value, exists := m["key"]
if exists {
    // keyå­˜åœ¨
}
```

### 3. å¹¶å‘å®‰å…¨

```go
// âŒ ä¸å®‰å…¨ - å¹¶å‘è¯»å†™ä¼španic
m := make(map[string]int)
go func() { m["key"] = 1 }()
go func() { _ = m["key"] }()

// âœ… ä½¿ç”¨sync.Mapæˆ–åŠ é”
import "sync"

var mu sync.RWMutex
m := make(map[string]int)

// å†™å…¥
mu.Lock()
m["key"] = 1
mu.Unlock()

// è¯»å–
mu.RLock()
value := m["key"]
mu.RUnlock()

// âœ… æˆ–ä½¿ç”¨sync.Map
var sm sync.Map
sm.Store("key", 1)
value, _ := sm.Load("key")
```

### 4. åˆ é™¤æ˜ å°„å…ƒç´ 

```go
// âœ… å®‰å…¨åˆ é™¤
delete(m, "key") // å³ä½¿keyä¸å­˜åœ¨ä¹Ÿä¸ä¼španic

// âœ… éå†æ—¶åˆ é™¤
for k := range m {
    if shouldDelete(k) {
        delete(m, k)
    }
}
```

### 5. nilæ˜ å°„æ£€æŸ¥

```go
var m map[string]int

// âŒ ä¸èƒ½ç›´æ¥èµ‹å€¼
// m["key"] = 1 // panic!

// âœ… å…ˆæ£€æŸ¥æˆ–åˆå§‹åŒ–
if m == nil {
    m = make(map[string]int)
}
m["key"] = 1

// âœ… ä½†å¯ä»¥å®‰å…¨è¯»å–
value := m["key"] // è¿”å›é›¶å€¼ï¼Œä¸ä¼španic
_, exists := m["key"] // existsä¸ºfalse
```

## ğŸ” å¸¸è§é—®é¢˜

### Q1: æ˜ å°„æ˜¯å¹¶å‘å®‰å…¨çš„å—ï¼Ÿ

A: å¦ã€‚å¤šä¸ªgoroutineåŒæ—¶è¯»å†™åŒä¸€ä¸ªæ˜ å°„ä¼šå¯¼è‡´panicã€‚ä½¿ç”¨`sync.Map`æˆ–åŠ é”ä¿æŠ¤ã€‚

### Q2: æ˜ å°„çš„éå†é¡ºåºæ˜¯ä»€ä¹ˆï¼Ÿ

A: **éšæœº**ã€‚æ¯æ¬¡éå†çš„é¡ºåºå¯èƒ½ä¸åŒã€‚å¦‚éœ€æœ‰åºéå†ï¼Œéœ€è¦å…ˆæ’åºé”®ã€‚

### Q3: å¯ä»¥ä½¿ç”¨åˆ‡ç‰‡ä½œä¸ºæ˜ å°„çš„é”®å—ï¼Ÿ

A: ä¸å¯ä»¥ã€‚é”®å¿…é¡»æ˜¯å¯æ¯”è¾ƒç±»å‹ã€‚åˆ‡ç‰‡ã€æ˜ å°„ã€å‡½æ•°éƒ½ä¸èƒ½ä½œä¸ºé”®ã€‚

### Q4: å¦‚ä½•å¤åˆ¶ä¸€ä¸ªæ˜ å°„ï¼Ÿ

A: æ˜ å°„æ²¡æœ‰å†…ç½®çš„å¤åˆ¶æ–¹æ³•ï¼Œéœ€è¦æ‰‹åŠ¨éå†å¤åˆ¶ï¼š

```go
func copyMap(m map[string]int) map[string]int {
    result := make(map[string]int, len(m))
    for k, v := range m {
        result[k] = v
    }
    return result
}
```

### Q5: æ˜ å°„çš„é›¶å€¼æ˜¯ä»€ä¹ˆï¼Ÿ

A: nilã€‚nilæ˜ å°„å¯ä»¥å®‰å…¨è¯»å–ï¼ˆè¿”å›é›¶å€¼ï¼‰ï¼Œä½†ä¸èƒ½å†™å…¥ï¼ˆä¼španicï¼‰ã€‚

## ğŸ“š æ‰©å±•é˜…è¯»

### ç›¸å…³æ¦‚å¿µ

- [æ•°ç»„ä¸åˆ‡ç‰‡](./09-æ•°ç»„ä¸åˆ‡ç‰‡.md)
- [ç»“æ„ä½“](./08-ç»“æ„ä½“.md)
- [å¹¶å‘ç¼–ç¨‹](../02-å¹¶å‘ç¼–ç¨‹/README.md)

### è¿›é˜¶ä¸»é¢˜

- æ˜ å°„å†…éƒ¨å®ç°
- sync.Mapè¯¦è§£
- æ˜ å°„æ€§èƒ½ä¼˜åŒ–
- mapsåŒ…ï¼ˆGo 1.21+ï¼‰

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ24æ—¥  
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
