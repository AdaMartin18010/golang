# Go语言映射(Map)

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3+

---

## 📋 目录

- [📚 理论分析](#理论分析)
  - [映射的内部结构](#映射的内部结构)
- [💻 代码实现](#代码实现)
  - [映射创建与初始化](#映射创建与初始化)
  - [映射操作](#映射操作)
  - [映射遍历](#映射遍历)
  - [映射作为集合](#映射作为集合)
  - [映射的值为复杂类型](#映射的值为复杂类型)
- [📊 性能分析](#性能分析)
- [🧪 测试代码](#测试代码)
- [🎯 最佳实践](#最佳实践)
  - [1. 预分配容量](#1.-预分配容量)
  - [2. 检查键是否存在](#2.-检查键是否存在)
  - [3. 并发安全](#3.-并发安全)
  - [4. 删除映射元素](#4.-删除映射元素)
  - [5. nil映射检查](#5.-nil映射检查)
- [🔍 常见问题](#常见问题)
  - [Q1: 映射是并发安全的吗？](#q1-映射是并发安全的吗)
  - [Q2: 映射的遍历顺序是什么？](#q2-映射的遍历顺序是什么)
  - [Q3: 可以使用切片作为映射的键吗？](#q3-可以使用切片作为映射的键吗)
  - [Q4: 如何复制一个映射？](#q4-如何复制一个映射)
  - [Q5: 映射的零值是什么？](#q5-映射的零值是什么)
- [📚 扩展阅读](#扩展阅读)
  - [相关概念](#相关概念)
  - [进阶主题](#进阶主题)

## 📚 理论分析

### 映射的内部结构

映射在Go中是基于哈希表实现的引用类型：

```go
// 简化的内部结构
type hmap struct {
    count     int    // 元素个数
    flags     uint8
    B         uint8  // 桶的数量 = 2^B
    hash0     uint32 // 哈希种子
    buckets   unsafe.Pointer // 桶数组
    oldbuckets unsafe.Pointer // 旧桶（扩容时）
}
```

特点：

- 无序集合
- 键必须可比较
- 零值为nil
- 非并发安全

## 💻 代码实现

### 映射创建与初始化

```go
package main

import "fmt"

func main() {
    // 1. 声明nil映射（不能直接使用）
    var m1 map[string]int
    fmt.Printf("Nil map: %v, len=%d, nil=%t\n", m1, len(m1), m1 == nil)
    // m1["key"] = 1 // panic: assignment to entry in nil map
    
    // 2. 使用make创建空映射
    m2 := make(map[string]int)
    fmt.Printf("Empty map: %v, len=%d\n", m2, len(m2))
    
    // 3. 使用make创建指定容量的映射
    m3 := make(map[string]int, 100) // 预分配100个元素的空间
    fmt.Printf("Preallocated map: %v, len=%d\n", m3, len(m3))
    
    // 4. 映射字面量初始化
    m4 := map[string]int{
        "one":   1,
        "two":   2,
        "three": 3,
    }
    fmt.Printf("Literal map: %v, len=%d\n", m4, len(m4))
    
    // 5. 空映射字面量
    m5 := map[string]int{}
    fmt.Printf("Empty literal map: %v, len=%d, nil=%t\n", m5, len(m5), m5 == nil)
    
    // 6. 复杂键值类型
    type Person struct {
        Name string
        Age  int
    }
    
    m6 := map[string]Person{
        "alice": {Name: "Alice", Age: 25},
        "bob":   {Name: "Bob", Age: 30},
    }
    fmt.Printf("Complex value map: %v\n", m6)
    
    // 7. 结构体作为键（必须可比较）
    type Point struct {
        X, Y int
    }
    
    m7 := map[Point]string{
        {0, 0}: "origin",
        {1, 1}: "diagonal",
    }
    fmt.Printf("Struct key map: %v\n", m7)
}
```

### 映射操作

```go
package main

import "fmt"

func main() {
    scores := make(map[string]int)
    
    // 1. 添加/更新元素
    scores["Alice"] = 95
    scores["Bob"] = 87
    scores["Charlie"] = 92
    fmt.Printf("Scores: %v\n", scores)
    
    // 更新元素
    scores["Alice"] = 98
    fmt.Printf("After update: %v\n", scores)
    
    // 2. 读取元素
    aliceScore := scores["Alice"]
    fmt.Printf("Alice's score: %d\n", aliceScore)
    
    // 3. 读取不存在的键（返回零值）
    davidScore := scores["David"]
    fmt.Printf("David's score: %d (zero value)\n", davidScore)
    
    // 4. 检查键是否存在（comma ok idiom）
    score, exists := scores["Alice"]
    if exists {
        fmt.Printf("Alice exists with score: %d\n", score)
    }
    
    score, exists = scores["David"]
    if !exists {
        fmt.Println("David does not exist")
    }
    
    // 5. 删除元素
    delete(scores, "Bob")
    fmt.Printf("After delete: %v\n", scores)
    
    // 删除不存在的键（安全，不会panic）
    delete(scores, "NonExistent")
    
    // 6. 获取映射长度
    fmt.Printf("Number of students: %d\n", len(scores))
    
    // 7. 清空映射
    scores = make(map[string]int) // 创建新的空映射
    fmt.Printf("After clear: %v, len=%d\n", scores, len(scores))
}
```

### 映射遍历

```go
package main

import "fmt"

func main() {
    ages := map[string]int{
        "Alice":   25,
        "Bob":     30,
        "Charlie": 35,
        "David":   28,
    }
    
    // 1. 遍历键和值
    fmt.Println("Keys and values:")
    for name, age := range ages {
        fmt.Printf("  %s: %d\n", name, age)
    }
    
    // 2. 只遍历键
    fmt.Println("\nOnly keys:")
    for name := range ages {
        fmt.Printf("  %s\n", name)
    }
    
    // 3. 只遍历值（使用_忽略键）
    fmt.Println("\nOnly values:")
    for _, age := range ages {
        fmt.Printf("  %d\n", age)
    }
    
    // 4. 遍历顺序是随机的
    fmt.Println("\nMultiple iterations (random order):")
    for i := 0; i < 3; i++ {
        fmt.Printf("  Iteration %d: ", i+1)
        for name := range ages {
            fmt.Printf("%s ", name)
        }
        fmt.Println()
    }
    
    // 5. 有序遍历（需要先排序键）
    fmt.Println("\nSorted iteration:")
    keys := make([]string, 0, len(ages))
    for k := range ages {
        keys = append(keys, k)
    }
    
    // 简单排序（使用冒泡排序示例）
    for i := 0; i < len(keys); i++ {
        for j := i + 1; j < len(keys); j++ {
            if keys[i] > keys[j] {
                keys[i], keys[j] = keys[j], keys[i]
            }
        }
    }
    
    for _, k := range keys {
        fmt.Printf("  %s: %d\n", k, ages[k])
    }
}
```

### 映射作为集合

```go
package main

import "fmt"

// Set 使用map实现集合
type Set map[string]bool

// NewSet 创建集合
func NewSet() Set {
    return make(Set)
}

// Add 添加元素
func (s Set) Add(item string) {
    s[item] = true
}

// Remove 删除元素
func (s Set) Remove(item string) {
    delete(s, item)
}

// Contains 检查元素是否存在
func (s Set) Contains(item string) bool {
    return s[item]
}

// Size 集合大小
func (s Set) Size() int {
    return len(s)
}

// Items 返回所有元素
func (s Set) Items() []string {
    items := make([]string, 0, len(s))
    for item := range s {
        items = append(items, item)
    }
    return items
}

// Union 并集
func (s Set) Union(other Set) Set {
    result := NewSet()
    for item := range s {
        result.Add(item)
    }
    for item := range other {
        result.Add(item)
    }
    return result
}

// Intersection 交集
func (s Set) Intersection(other Set) Set {
    result := NewSet()
    for item := range s {
        if other.Contains(item) {
            result.Add(item)
        }
    }
    return result
}

// Difference 差集
func (s Set) Difference(other Set) Set {
    result := NewSet()
    for item := range s {
        if !other.Contains(item) {
            result.Add(item)
        }
    }
    return result
}

func main() {
    // 使用Set
    set1 := NewSet()
    set1.Add("apple")
    set1.Add("banana")
    set1.Add("orange")
    
    set2 := NewSet()
    set2.Add("banana")
    set2.Add("grape")
    set2.Add("orange")
    
    fmt.Printf("Set1: %v\n", set1.Items())
    fmt.Printf("Set2: %v\n", set2.Items())
    fmt.Printf("Contains 'apple': %t\n", set1.Contains("apple"))
    
    union := set1.Union(set2)
    fmt.Printf("Union: %v\n", union.Items())
    
    intersection := set1.Intersection(set2)
    fmt.Printf("Intersection: %v\n", intersection.Items())
    
    difference := set1.Difference(set2)
    fmt.Printf("Difference: %v\n", difference.Items())
}
```

### 映射的值为复杂类型

```go
package main

import "fmt"

func main() {
    // 1. 值为切片
    groups := map[string][]string{
        "fruits":     {"apple", "banana", "orange"},
        "vegetables": {"carrot", "potato", "tomato"},
    }
    
    // 添加元素到切片
    groups["fruits"] = append(groups["fruits"], "grape")
    fmt.Printf("Groups: %v\n", groups)
    
    // 2. 值为映射（嵌套映射）
    students := map[string]map[string]int{
        "Alice": {
            "math":    95,
            "english": 87,
            "science": 92,
        },
        "Bob": {
            "math":    87,
            "english": 92,
            "science": 88,
        },
    }
    
    fmt.Printf("Alice's math score: %d\n", students["Alice"]["math"])
    
    // 添加新学生
    students["Charlie"] = make(map[string]int)
    students["Charlie"]["math"] = 90
    students["Charlie"]["english"] = 85
    
    // 3. 值为结构体指针
    type User struct {
        Name  string
        Email string
        Age   int
    }
    
    users := make(map[int]*User)
    users[1] = &User{Name: "Alice", Email: "alice@example.com", Age: 25}
    users[2] = &User{Name: "Bob", Email: "bob@example.com", Age: 30}
    
    // 修改结构体字段
    users[1].Age = 26
    fmt.Printf("User 1: %+v\n", users[1])
    
    // 4. 值为函数
    operations := map[string]func(int, int) int{
        "add": func(a, b int) int { return a + b },
        "sub": func(a, b int) int { return a - b },
        "mul": func(a, b int) int { return a * b },
        "div": func(a, b int) int {
            if b != 0 {
                return a / b
            }
            return 0
        },
    }
    
    result := operations["add"](10, 5)
    fmt.Printf("10 + 5 = %d\n", result)
}
```

## 📊 性能分析

```go
package main

import (
    "testing"
)

// 基准测试：映射创建
func BenchmarkMapCreation(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = make(map[string]int)
    }
}

func BenchmarkMapCreationWithCapacity(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = make(map[string]int, 1000)
    }
}

// 基准测试：映射插入
func BenchmarkMapInsert(b *testing.B) {
    m := make(map[int]int)
    for i := 0; i < b.N; i++ {
        m[i] = i
    }
}

// 基准测试：映射查找
func BenchmarkMapLookup(b *testing.B) {
    m := make(map[int]int, 1000)
    for i := 0; i < 1000; i++ {
        m[i] = i
    }
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = m[i%1000]
    }
}

// 基准测试：映射删除
func BenchmarkMapDelete(b *testing.B) {
    for i := 0; i < b.N; i++ {
        b.StopTimer()
        m := make(map[int]int, 1000)
        for j := 0; j < 1000; j++ {
            m[j] = j
        }
        b.StartTimer()
        
        for j := 0; j < 1000; j++ {
            delete(m, j)
        }
    }
}
```

## 🧪 测试代码

```go
package main

import (
    "testing"
)

func TestMapOperations(t *testing.T) {
    m := make(map[string]int)
    
    // 测试插入
    m["one"] = 1
    if m["one"] != 1 {
        t.Errorf("Expected 1, got %d", m["one"])
    }
    
    // 测试更新
    m["one"] = 11
    if m["one"] != 11 {
        t.Errorf("Expected 11, got %d", m["one"])
    }
    
    // 测试删除
    delete(m, "one")
    if _, exists := m["one"]; exists {
        t.Error("Key should not exist after delete")
    }
}

func TestMapZeroValue(t *testing.T) {
    m := make(map[string]int)
    
    // 访问不存在的键应返回零值
    value := m["nonexistent"]
    if value != 0 {
        t.Errorf("Expected 0, got %d", value)
    }
}
```

## 🎯 最佳实践

### 1. 预分配容量

```go
// ❌ 不好 - 可能多次扩容
m := make(map[string]int)
for i := 0; i < 1000; i++ {
    m[fmt.Sprintf("key%d", i)] = i
}

// ✅ 好 - 预分配容量
m := make(map[string]int, 1000)
for i := 0; i < 1000; i++ {
    m[fmt.Sprintf("key%d", i)] = i
}
```

### 2. 检查键是否存在

```go
// ❌ 不好 - 无法区分零值和不存在
value := m["key"]

// ✅ 好 - 使用comma ok idiom
value, exists := m["key"]
if exists {
    // key存在
}
```

### 3. 并发安全

```go
// ❌ 不安全 - 并发读写会panic
m := make(map[string]int)
go func() { m["key"] = 1 }()
go func() { _ = m["key"] }()

// ✅ 使用sync.Map或加锁
import "sync"

var mu sync.RWMutex
m := make(map[string]int)

// 写入
mu.Lock()
m["key"] = 1
mu.Unlock()

// 读取
mu.RLock()
value := m["key"]
mu.RUnlock()

// ✅ 或使用sync.Map
var sm sync.Map
sm.Store("key", 1)
value, _ := sm.Load("key")
```

### 4. 删除映射元素

```go
// ✅ 安全删除
delete(m, "key") // 即使key不存在也不会panic

// ✅ 遍历时删除
for k := range m {
    if shouldDelete(k) {
        delete(m, k)
    }
}
```

### 5. nil映射检查

```go
var m map[string]int

// ❌ 不能直接赋值
// m["key"] = 1 // panic!

// ✅ 先检查或初始化
if m == nil {
    m = make(map[string]int)
}
m["key"] = 1

// ✅ 但可以安全读取
value := m["key"] // 返回零值，不会panic
_, exists := m["key"] // exists为false
```

## 🔍 常见问题

### Q1: 映射是并发安全的吗？

A: 否。多个goroutine同时读写同一个映射会导致panic。使用`sync.Map`或加锁保护。

### Q2: 映射的遍历顺序是什么？

A: **随机**。每次遍历的顺序可能不同。如需有序遍历，需要先排序键。

### Q3: 可以使用切片作为映射的键吗？

A: 不可以。键必须是可比较类型。切片、映射、函数都不能作为键。

### Q4: 如何复制一个映射？

A: 映射没有内置的复制方法，需要手动遍历复制：

```go
func copyMap(m map[string]int) map[string]int {
    result := make(map[string]int, len(m))
    for k, v := range m {
        result[k] = v
    }
    return result
}
```

### Q5: 映射的零值是什么？

A: nil。nil映射可以安全读取（返回零值），但不能写入（会panic）。

## 📚 扩展阅读

### 相关概念

- [数组与切片](./09-数组与切片.md)
- [结构体](./08-结构体.md)
- [并发编程](../02-并发编程/README.md)

### 进阶主题

- 映射内部实现
- sync.Map详解
- 映射性能优化
- maps包（Go 1.21+）

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025-10-29  
**文档状态**: ✅ 已完成  
**适用版本**: Go 1.25.3+
