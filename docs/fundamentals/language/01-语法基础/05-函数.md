# Go语言函数

**版本**: v1.0
**更新日期**: 2025-10-29
**适用于**: Go 1.25.3+

---

## 📋 目录

- [Go语言函数](#go语言函数)
  - [📋 目录](#-目录)
  - [📚 理论分析](#-理论分析)
    - [函数的形式化定义](#函数的形式化定义)
    - [函数作为一等公民](#函数作为一等公民)
    - [调用约定与栈帧](#调用约定与栈帧)
  - [💻 代码实现](#-代码实现)
    - [基本函数定义](#基本函数定义)
    - [多返回值](#多返回值)
    - [命名返回值](#命名返回值)
    - [可变参数](#可变参数)
    - [函数作为参数](#函数作为参数)
    - [匿名函数与闭包](#匿名函数与闭包)
    - [延迟执行 defer](#延迟执行-defer)
  - [📊 性能分析](#-性能分析)
    - [内联优化](#内联优化)
    - [逃逸分析](#逃逸分析)
  - [🧪 测试代码](#-测试代码)
  - [🎯 最佳实践](#-最佳实践)
  - [🔍 常见问题](#-常见问题)
    - [Q1: 函数参数是值传递还是引用传递？](#q1-函数参数是值传递还是引用传递)
    - [Q2: 何时使用命名返回值？](#q2-何时使用命名返回值)
    - [Q3: defer的执行顺序是什么？](#q3-defer的执行顺序是什么)
    - [Q4: 闭包会导致内存泄漏吗？](#q4-闭包会导致内存泄漏吗)
  - [📚 扩展阅读](#-扩展阅读)
    - [相关概念](#相关概念)
    - [进阶主题](#进阶主题)

## 📚 理论分析

### 函数的形式化定义

Go语言中函数的形式化定义为：

```text
FunctionDeclaration ::= "func" FunctionName Signature FunctionBody
Signature ::= Parameters [Result]
Parameters ::= "(" [ParameterList ["," ...]] ")"
Result ::= Type | "(" TypeList ")"
```

其中：

- **FunctionName**: 函数标识符
- **Parameters**: 参数列表
- **Result**: 返回值类型
- **FunctionBody**: 函数体（语句块）

### 函数作为一等公民

Go语言中函数是一等公民（First-class Function），意味着：

1. **可赋值给变量**: `var f func(int) int`
2. **可作为参数**: `func process(f func(int) int, x int)`
3. **可作为返回值**: `func getFunc() func(int) int`
4. **可存储在数据结构**: `map[string]func() error`

### 调用约定与栈帧

Go函数调用遵循以下规则：

- **参数传递**: 值传递（复制）
- **栈增长**: 动态栈，按需增长
- **调用约定**: 参数和返回值通过栈传递
- **寄存器**: Go 1.17+使用寄存器传递部分参数

## 💻 代码实现

### 基本函数定义

```go
package main

import "fmt"

// 无参数无返回值
func hello() {
    fmt.Println("Hello, Go!")
}

// 有参数无返回值
func greet(name string) {
    fmt.Printf("Hello, %s!\n", name)
}

// 有参数有返回值
func add(a, b int) int {
    return a + b
}

// 相同类型参数简写
func multiply(x, y, z int) int {
    return x * y * z
}

func main() {
    hello()
    greet("Alice")
    sum := add(10, 20)
    fmt.Printf("Sum: %d\n", sum)
    product := multiply(2, 3, 4)
    fmt.Printf("Product: %d\n", product)
}
```

### 多返回值

```go
package main

import (
    "errors"
    "fmt"
    "math"
)

// 返回两个值
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

// 返回多个值
func rectangleInfo(width, height float64) (float64, float64) {
    area := width * height
    perimeter := 2 * (width + height)
    return area, perimeter
}

// 返回值和布尔标志
func sqrt(x float64) (float64, bool) {
    if x < 0 {
        return 0, false
    }
    return math.Sqrt(x), true
}

func main() {
    // 使用多返回值
    result, err := divide(10, 2)
    if err != nil {
        fmt.Printf("Error: %v\n", err)
        return
    }
    fmt.Printf("Result: %.2f\n", result)

    // 忽略某个返回值
    _, err = divide(10, 0)
    if err != nil {
        fmt.Printf("Expected error: %v\n", err)
    }

    // 接收多个返回值
    area, perimeter := rectangleInfo(5, 3)
    fmt.Printf("Area: %.2f, Perimeter: %.2f\n", area, perimeter)

    // 使用布尔标志
    if result, ok := sqrt(16); ok {
        fmt.Printf("Square root: %.2f\n", result)
    }
}
```

### 命名返回值

```go
package main

import "fmt"

// 命名返回值
func calculate(x, y int) (sum int, product int) {
    sum = x + y
    product = x * y
    return // 裸返回
}

// 命名返回值便于文档化
func divMod(dividend, divisor int) (quotient, remainder int) {
    quotient = dividend / divisor
    remainder = dividend % divisor
    return
}

// 命名返回值在defer中可以修改
func processWithDefer() (result string) {
    result = "initial"
    defer func() {
        result = "modified by defer"
    }()
    return result
}

func main() {
    sum, product := calculate(5, 3)
    fmt.Printf("Sum: %d, Product: %d\n", sum, product)

    q, r := divMod(17, 5)
    fmt.Printf("Quotient: %d, Remainder: %d\n", q, r)

    result := processWithDefer()
    fmt.Printf("Result: %s\n", result) // 输出: modified by defer
}
```

### 可变参数

```go
package main

import "fmt"

// 可变参数函数
func sum(numbers ...int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}

// 混合固定参数和可变参数
func printf(format string, args ...interface{}) {
    fmt.Printf(format, args...)
}

// 可变参数的类型断言
func concat(separator string, elements ...interface{}) string {
    result := ""
    for i, elem := range elements {
        if i > 0 {
            result += separator
        }
        result += fmt.Sprintf("%v", elem)
    }
    return result
}

func main() {
    // 调用可变参数函数
    fmt.Printf("Sum: %d\n", sum(1, 2, 3, 4, 5))

    // 展开切片
    numbers := []int{10, 20, 30}
    fmt.Printf("Sum of slice: %d\n", sum(numbers...))

    // 使用混合参数
    printf("Name: %s, Age: %d\n", "Alice", 25)

    // 拼接不同类型
    result := concat(", ", "Alice", 25, true, 3.14)
    fmt.Printf("Concatenated: %s\n", result)
}
```

### 函数作为参数

```go
package main

import "fmt"

// 函数类型定义
type Operation func(int, int) int

// 接受函数作为参数
func apply(op Operation, a, b int) int {
    return op(a, b)
}

// 高阶函数：返回函数
func makeAdder(base int) func(int) int {
    return func(x int) int {
        return base + x
    }
}

// 函数组合
func compose(f, g func(int) int) func(int) int {
    return func(x int) int {
        return f(g(x))
    }
}

func main() {
    // 定义操作函数
    add := func(a, b int) int { return a + b }
    multiply := func(a, b int) int { return a * b }

    // 使用函数作为参数
    fmt.Printf("Add: %d\n", apply(add, 5, 3))
    fmt.Printf("Multiply: %d\n", apply(multiply, 5, 3))

    // 使用高阶函数
    addTen := makeAdder(10)
    fmt.Printf("Add 10 to 5: %d\n", addTen(5))

    // 函数组合
    double := func(x int) int { return x * 2 }
    addOne := func(x int) int { return x + 1 }
    doubleAndAddOne := compose(addOne, double)
    fmt.Printf("Double 5 and add 1: %d\n", doubleAndAddOne(5)) // (5*2)+1 = 11
}
```

### 匿名函数与闭包

```go
package main

import "fmt"

// 闭包示例：计数器
func makeCounter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

// 闭包示例：生成器
func fibonacci() func() int {
    a, b := 0, 1
    return func() int {
        result := a
        a, b = b, a+b
        return result
    }
}

// 闭包捕获外部变量
func multiplier(factor int) func(int) int {
    return func(x int) int {
        return x * factor
    }
}

func main() {
    // 立即执行的匿名函数
    func() {
        fmt.Println("Anonymous function executed immediately")
    }()

    // 闭包：计数器
    counter := makeCounter()
    fmt.Printf("Counter: %d\n", counter()) // 1
    fmt.Printf("Counter: %d\n", counter()) // 2
    fmt.Printf("Counter: %d\n", counter()) // 3

    // 闭包：斐波那契生成器
    fib := fibonacci()
    for i := 0; i < 10; i++ {
        fmt.Printf("%d ", fib())
    }
    fmt.Println()

    // 闭包：乘法器
    double := multiplier(2)
    triple := multiplier(3)
    fmt.Printf("Double 5: %d\n", double(5))
    fmt.Printf("Triple 5: %d\n", triple(5))
}
```

### 延迟执行 defer

```go
package main

import (
    "fmt"
    "os"
)

// defer基本用法
func deferExample() {
    fmt.Println("Start")
    defer fmt.Println("Deferred 1")
    defer fmt.Println("Deferred 2")
    defer fmt.Println("Deferred 3")
    fmt.Println("End")
    // 输出顺序: Start, End, Deferred 3, Deferred 2, Deferred 1
}

// defer用于资源清理
func readFile(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer file.Close() // 确保文件被关闭

    // 处理文件...
    return nil
}

// defer在函数返回前修改返回值
func deferModifyReturn() (result int) {
    defer func() {
        result++
    }()
    return 10 // 实际返回11
}

// defer处理panic
func safeExecute(f func()) (err error) {
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("panic recovered: %v", r)
        }
    }()

    f()
    return nil
}

func main() {
    deferExample()

    result := deferModifyReturn()
    fmt.Printf("Modified result: %d\n", result)

    // 安全执行可能panic的函数
    err := safeExecute(func() {
        panic("something went wrong")
    })
    if err != nil {
        fmt.Printf("Error: %v\n", err)
    }
}
```

## 📊 性能分析

### 内联优化

```go
package main

import "testing"

// 小函数会被编译器内联
func add(a, b int) int {
    return a + b
}

// 使用go:noinline指令禁止内联
//go:noinline
func addNoInline(a, b int) int {
    return a + b
}

func BenchmarkInline(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = add(1, 2)
    }
}

func BenchmarkNoInline(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = addNoInline(1, 2)
    }
}
```

### 逃逸分析

```go
package main

// 返回局部变量的指针会导致逃逸到堆
func escapeToHeap() *int {
    x := 42
    return &x // x逃逸到堆
}

// 局部变量不逃逸
func noEscape() int {
    x := 42
    return x // x在栈上
}

// 使用 go build -gcflags="-m" 查看逃逸分析
```

## 🧪 测试代码

```go
package main

import "testing"

func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"positive", 1, 2, 3},
        {"negative", -1, -2, -3},
        {"mixed", -1, 2, 1},
        {"zero", 0, 0, 0},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if got := add(tt.a, tt.b); got != tt.want {
                t.Errorf("add(%d, %d) = %d, want %d", tt.a, tt.b, got, tt.want)
            }
        })
    }
}

func TestDivide(t *testing.T) {
    // 正常情况
    result, err := divide(10, 2)
    if err != nil {
        t.Errorf("unexpected error: %v", err)
    }
    if result != 5.0 {
        t.Errorf("divide(10, 2) = %f, want 5.0", result)
    }

    // 除以零
    _, err = divide(10, 0)
    if err == nil {
        t.Error("expected error for division by zero")
    }
}
```

## 🎯 最佳实践

1. **函数命名**
   - 使用动词或动词短语
   - 导出函数首字母大写
   - 私有函数首字母小写

2. **参数设计**
   - 参数不超过3-4个
   - 使用结构体封装多个参数
   - 指针参数用于大对象或需要修改

3. **返回值**
   - 使用多返回值处理错误
   - error作为最后一个返回值
   - 使用命名返回值增强可读性

4. **defer使用**
   - 资源清理（文件、锁、连接）
   - 确保配对操作（Open/Close）
   - 注意defer的性能开销

5. **闭包注意事项**
   - 避免在循环中创建闭包捕获循环变量
   - 注意闭包的内存开销
   - 使用闭包实现工厂模式

## 🔍 常见问题

### Q1: 函数参数是值传递还是引用传递？

A: Go语言中**所有参数都是值传递**。对于切片、映射、通道等引用类型，传递的是描述符的副本，但它们指向相同的底层数据。

### Q2: 何时使用命名返回值？

A: 当返回值的含义不明显，或需要在defer中修改返回值时使用命名返回值。

### Q3: defer的执行顺序是什么？

A: defer遵循**后进先出（LIFO）**原则，最后声明的defer最先执行。

### Q4: 闭包会导致内存泄漏吗？

A: 闭包会持有外部变量的引用，如果闭包生命周期很长，可能导致外部变量无法被GC回收。

## 📚 扩展阅读

### 相关概念

- [方法](./06-方法.md)
- [接口](./07-接口.md)
- [错误处理](./11-错误处理.md)

### 进阶主题

- 函数式编程模式
- 泛型函数（Go 1.18+）
- 性能优化与内联
- 逃逸分析详解

---

**文档维护者**: Go Documentation Team
**最后更新**: 2025-10-29
**文档状态**: ✅ 已完成
**适用版本**: Go 1.25.3+
