# Go语言并发模型

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.23+

---

## 📋 目录

- [📚 理论分析](#理论分析)
  - [CSP理论基础](#csp理论基础)
    - [核心思想](#核心思想)
    - [形式化描述](#形式化描述)
    - [CSP vs 传统并发](#csp-vs-传统并发)
  - [Go运行时调度模型](#go运行时调度模型)
    - [G-P-M模型](#g-p-m模型)
    - [Work Stealing（工作窃取）](#work-stealing工作窃取)
    - [抢占式调度](#抢占式调度)
  - [内存模型与同步](#内存模型与同步)
    - [Happens-Before关系](#happens-before关系)
- [💻 代码示例](#代码示例)
  - [Goroutine基础](#goroutine基础)
  - [Channel通信](#channel通信)
  - [Select多路复用](#select多路复用)
- [🏗️ 并发模式](#并发模式)
  - [Worker Pool](#worker-pool)
  - [Pipeline](#pipeline)
  - [Fan-Out/Fan-In](#fan-outfan-in)
- [📊 性能分析](#性能分析)
  - [Goroutine vs Thread](#goroutine-vs-thread)
  - [Channel vs 锁](#channel-vs-锁)
- [🧪 测试代码](#测试代码)
- [🎯 最佳实践](#最佳实践)
  - [1. 优先使用Channel通信](#1-优先使用channel通信)
  - [2. 保证Goroutine退出](#2-保证goroutine退出)
  - [3. 避免Goroutine泄漏](#3-避免goroutine泄漏)
  - [4. 合理设置GOMAXPROCS](#4-合理设置gomaxprocs)
  - [5. 使用sync.WaitGroup管理](#5-使用sync-waitgroup管理)
- [🔍 常见问题](#常见问题)
- [📚 扩展阅读](#扩展阅读)

## 📚 理论分析

### CSP理论基础

Go语言并发模型基于**CSP（Communicating Sequential Processes）**理论，由Tony Hoare在1978年提出。

#### 核心思想

**"不要通过共享内存来通信，而应通过通信来共享内存"**  
*"Do not communicate by sharing memory; instead, share memory by communicating."*

```text
传统并发（共享内存）：
Thread1 -----> [Shared Memory] <----- Thread2
           锁保护

CSP模型（消息传递）：
Process1 -----> [Channel] -----> Process2
           消息传递
```

#### 形式化描述

```text
Process ::= goroutine
Channel ::= make(chan T [, capacity])
Send    ::= ch <- value
Receive ::= value := <-ch
Select  ::= select { case ... }
```

**CSP的三大要素：**

1. **进程（Process）**：Go中的goroutine，独立执行单元
2. **通道（Channel）**：进程间通信媒介，类型安全
3. **同步通信**：发送与接收操作配对，实现同步

#### CSP vs 传统并发

| 特性 | 传统并发（锁） | CSP（Go） |
|------|---------------|-----------|
| 通信方式 | 共享内存 | 消息传递 |
| 同步机制 | 互斥锁、信号量 | Channel |
| 死锁检测 | 困难 | 编译器/运行时辅助 |
| 组合性 | 低（锁难以组合） | 高（channel可组合） |
| 可读性 | 低（隐式依赖） | 高（显式通信） |

### Go运行时调度模型

#### G-P-M模型

Go使用高效的**M:N调度模型**（多个goroutine映射到多个OS线程）：

```text
┌─────────────────────────────────────┐
│         Go Runtime Scheduler        │
├─────────────────────────────────────┤
│                                     │
│  G (Goroutine) - 用户态线程          │
│  ├─ 栈（初始2KB，可扩展到1GB）        │
│  ├─ 程序计数器                       │
│  └─ 状态（运行/阻塞/死亡）            │
│                                     │
│  P (Processor) - 逻辑处理器          │
│  ├─ 本地G队列（LIFO）                │
│  ├─ 缓存（mcache）                  │
│  └─ 数量 = GOMAXPROCS               │
│                                     │
│  M (Machine) - OS线程               │
│  ├─ 执行G                           │
│  └─ 数量动态调整                     │
│                                     │
└─────────────────────────────────────┘
```

**调度流程：**

```text
1. 创建G：go func() { ... }
2. G加入P的本地队列
3. M从P获取G执行
4. G阻塞时：
   - I/O阻塞：M休眠，P绑定新M
   - Channel阻塞：G挂起，M继续执行其他G
5. G完成：回收栈，M获取新G
```

#### Work Stealing（工作窃取）

```go
// P1的队列满，P2的队列空
P1: [G1, G2, G3, G4, G5]
P2: []

// P2从P1的队列末尾窃取一半任务
P1: [G1, G2, G3]
P2: [G4, G5]  ← 窃取
```

**优点：**

- 负载均衡
- 减少全局锁竞争
- 提高CPU利用率

#### 抢占式调度

**协作式 → 抢占式演进：**

| 版本 | 调度方式 | 问题 |
|------|---------|------|
| Go 1.0-1.13 | 协作式 | 长时间运行的goroutine可能饿死其他goroutine |
| Go 1.14+ | 基于信号的抢占式 | 解决饿死问题，更公平 |

### 内存模型与同步

#### Happens-Before关系

Go保证以下happens-before顺序：

1. **单个goroutine内**：按程序顺序执行
2. **Channel发送 happens-before 接收完成**
3. **Channel关闭 happens-before 接收返回零值**
4. **无缓冲channel接收 happens-before 发送完成**

```go
// 示例：保证顺序
var c = make(chan int)
var a string

func f() {
    a = "hello, world"  // (1)
    c <- 0              // (2) happens-after (1)
}

func main() {
    go f()
    <-c                 // (3) happens-after (2)
    print(a)            // (4) happens-after (3)，保证能看到"hello, world"
}
```

---

## 💻 代码示例

### Goroutine基础

**创建Goroutine：**

```go
package main

import (
    "fmt"
    "time"
)

func say(s string) {
    for i := 0; i < 3; i++ {
        time.Sleep(100 * time.Millisecond)
        fmt.Println(s)
    }
}

func main() {
    go say("world")  // 并发执行
    say("hello")     // 主goroutine执行
}
```

**Goroutine生命周期管理：**

```go
import "sync"

func main() {
    var wg sync.WaitGroup
    
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            fmt.Printf("Worker %d done\n", id)
        }(i)  // 传参，避免闭包陷阱
    }
    
    wg.Wait()  // 等待所有goroutine完成
    fmt.Println("All workers done")
}
```

### Channel通信

**无缓冲Channel（同步）：**

```go
func main() {
    ch := make(chan int)
    
    go func() {
        ch <- 42  // 发送阻塞，直到被接收
    }()
    
    val := <-ch  // 接收阻塞，直到有数据
    fmt.Println(val)  // 42
}
```

**有缓冲Channel（异步）：**

```go
func main() {
    ch := make(chan int, 2)  // 容量为2
    
    ch <- 1  // 不阻塞
    ch <- 2  // 不阻塞
    // ch <- 3  // 会阻塞，缓冲区满
    
    fmt.Println(<-ch)  // 1
    fmt.Println(<-ch)  // 2
}
```

**单向Channel（类型安全）：**

```go
// 只发送channel
func producer(ch chan<- int) {
    for i := 0; i < 5; i++ {
        ch <- i
    }
    close(ch)
}

// 只接收channel
func consumer(ch <-chan int) {
    for val := range ch {
        fmt.Println(val)
    }
}

func main() {
    ch := make(chan int, 5)
    go producer(ch)
    consumer(ch)
}
```

**关闭Channel：**

```go
func main() {
    ch := make(chan int, 3)
    ch <- 1
    ch <- 2
    ch <- 3
    close(ch)  // 关闭channel
    
    // 遍历直到channel关闭
    for val := range ch {
        fmt.Println(val)
    }
    
    // 检测channel是否关闭
    val, ok := <-ch
    fmt.Println(val, ok)  // 0 false
}
```

### Select多路复用

**基本用法：**

```go
func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    
    go func() {
        time.Sleep(1 * time.Second)
        ch1 <- "one"
    }()
    
    go func() {
        time.Sleep(2 * time.Second)
        ch2 <- "two"
    }()
    
    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-ch1:
            fmt.Println("Received", msg1)
        case msg2 := <-ch2:
            fmt.Println("Received", msg2)
        }
    }
}
```

**超时处理：**

```go
func main() {
    ch := make(chan string)
    
    go func() {
        time.Sleep(2 * time.Second)
        ch <- "result"
    }()
    
    select {
    case res := <-ch:
        fmt.Println(res)
    case <-time.After(1 * time.Second):
        fmt.Println("Timeout!")
    }
}
```

**非阻塞操作：**

```go
func main() {
    ch := make(chan int, 1)
    
    select {
    case ch <- 42:
        fmt.Println("Sent")
    default:
        fmt.Println("Channel full")
    }
    
    select {
    case val := <-ch:
        fmt.Println("Received", val)
    default:
        fmt.Println("Channel empty")
    }
}
```

---

## 🏗️ 并发模式

### Worker Pool

```go
func workerPool(tasks <-chan Task, results chan<- Result, numWorkers int) {
    var wg sync.WaitGroup
    
    for i := 0; i < numWorkers; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for task := range tasks {
                result := task.Process()
                results <- result
            }
        }(i)
    }
    
    wg.Wait()
    close(results)
}

// 使用
func main() {
    tasks := make(chan Task, 100)
    results := make(chan Result, 100)
    
    go workerPool(tasks, results, 5)  // 5个worker
    
    // 生产任务
    go func() {
        for i := 0; i < 10; i++ {
            tasks <- Task{ID: i}
        }
        close(tasks)
    }()
    
    // 消费结果
    for result := range results {
        fmt.Println(result)
    }
}
```

### Pipeline

```go
// 阶段1：生成数据
func generate(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out <- n
        }
        close(out)
    }()
    return out
}

// 阶段2：平方
func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * n
        }
        close(out)
    }()
    return out
}

// 阶段3：过滤
func filter(in <-chan int, f func(int) bool) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            if f(n) {
                out <- n
            }
        }
        close(out)
    }()
    return out
}

// 组装Pipeline
func main() {
    // 生成 -> 平方 -> 过滤
    c := generate(1, 2, 3, 4, 5)
    c = square(c)
    c = filter(c, func(n int) bool { return n > 10 })
    
    for result := range c {
        fmt.Println(result)  // 16, 25
    }
}
```

### Fan-Out/Fan-In

```go
// Fan-Out: 一个输入，多个worker处理
func fanOut(in <-chan int, workers int) []<-chan int {
    channels := make([]<-chan int, workers)
    for i := 0; i < workers; i++ {
        channels[i] = worker(in)
    }
    return channels
}

func worker(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * n  // 处理
            time.Sleep(time.Millisecond)
        }
        close(out)
    }()
    return out
}

// Fan-In: 多个输入合并为一个输出
func fanIn(channels ...<-chan int) <-chan int {
    out := make(chan int)
    var wg sync.WaitGroup
    
    for _, ch := range channels {
        wg.Add(1)
        go func(c <-chan int) {
            defer wg.Done()
            for n := range c {
                out <- n
            }
        }(ch)
    }
    
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}

// 使用
func main() {
    in := generate(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    
    // Fan-Out: 3个worker并发处理
    workers := fanOut(in, 3)
    
    // Fan-In: 合并结果
    results := fanIn(workers...)
    
    for result := range results {
        fmt.Println(result)
    }
}
```

---

## 📊 性能分析

### Goroutine vs Thread

| 指标 | Goroutine | OS Thread |
|------|-----------|-----------|
| 创建开销 | ~2KB栈 | ~1-2MB栈 |
| 切换开销 | 纳秒级 | 微秒级 |
| 数量上限 | 百万级 | 数千个 |
| 调度器 | Go运行时 | OS内核 |
| 栈增长 | 动态扩展 | 固定大小 |

### Channel vs 锁

```go
// Benchmark对比
func BenchmarkChannel(b *testing.B) {
    ch := make(chan int, 1)
    go func() {
        for range ch {
        }
    }()
    
    for i := 0; i < b.N; i++ {
        ch <- i
    }
}

func BenchmarkMutex(b *testing.B) {
    var mu sync.Mutex
    var val int
    
    for i := 0; i < b.N; i++ {
        mu.Lock()
        val = i
        mu.Unlock()
    }
}

// 结果：
// BenchmarkChannel-8    20000000    75.2 ns/op
// BenchmarkMutex-8      50000000    28.5 ns/op
```

**选择建议：**

- **Channel**：高层次抽象，数据流传递，易于组合
- **Mutex**：低层次保护，简单共享状态，性能更高

---

## 🧪 测试代码

```go
package main

import (
    "testing"
    "time"
)

func TestChannelCommunication(t *testing.T) {
    ch := make(chan int)
    go func() {
        ch <- 42
    }()
    
    v := <-ch
    if v != 42 {
        t.Errorf("expected 42, got %d", v)
    }
}

func TestSelectTimeout(t *testing.T) {
    ch := make(chan int)
    
    select {
    case <-ch:
        t.Error("Should timeout")
    case <-time.After(100 * time.Millisecond):
        // Success
    }
}

func TestWorkerPool(t *testing.T) {
    tasks := make(chan int, 10)
    results := make(chan int, 10)
    
    // 启动3个worker
    for i := 0; i < 3; i++ {
        go func() {
            for task := range tasks {
                results <- task * 2
            }
        }()
    }
    
    // 发送任务
    for i := 0; i < 5; i++ {
        tasks <- i
    }
    close(tasks)
    
    // 收集结果
    sum := 0
    for i := 0; i < 5; i++ {
        sum += <-results
    }
    
    expected := 0 + 2 + 4 + 6 + 8  // 0*2 + 1*2 + 2*2 + 3*2 + 4*2
    if sum != expected {
        t.Errorf("expected %d, got %d", expected, sum)
    }
}
```

---

## 🎯 最佳实践

### 1. 优先使用Channel通信

```go
// ❌ 共享内存
var counter int
var mu sync.Mutex

go func() {
    mu.Lock()
    counter++
    mu.Unlock()
}()

// ✅ Channel通信
ch := make(chan int, 1)
go func() {
    ch <- 1
}()
```

### 2. 保证Goroutine退出

```go
// ✅ 使用context控制
func worker(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            return  // 确保退出
        default:
            // 工作
        }
    }
}
```

### 3. 避免Goroutine泄漏

```go
// ❌ 泄漏：channel永远阻塞
func leak() {
    ch := make(chan int)
    go func() {
        ch <- 42  // 永远阻塞，无接收者
    }()
}

// ✅ 确保有接收者或使用缓冲
func noLeak() {
    ch := make(chan int, 1)
    go func() {
        ch <- 42
    }()
}
```

### 4. 合理设置GOMAXPROCS

```go
import "runtime"

func init() {
    // CPU密集型：设为CPU核数
    runtime.GOMAXPROCS(runtime.NumCPU())
    
    // I/O密集型：可以更多
    // runtime.GOMAXPROCS(runtime.NumCPU() * 2)
}
```

### 5. 使用sync.WaitGroup管理

```go
var wg sync.WaitGroup

for i := 0; i < 10; i++ {
    wg.Add(1)
    go func(id int) {
        defer wg.Done()
        // 工作
    }(i)
}

wg.Wait()  // 等待所有完成
```

---

## 🔍 常见问题

**Q: Goroutine数量有限制吗？**
A: 理论上可达百万级，受内存限制。但实际应用建议使用Worker Pool控制数量。

**Q: Channel一定要关闭吗？**
A:

- 只需生产者关闭
- 消费者通过`val, ok := <-ch`检测
- 不关闭channel也会被GC回收

**Q: 如何避免Goroutine泄漏？**
A:

- 使用context控制生命周期
- 确保每个goroutine都有退出路径
- 使用pprof检测泄漏

**Q: select随机选择吗？**
A: 当多个case同时就绪时，select随机选择一个执行。

**Q: Channel vs Mutex如何选择？**
A:

- Channel：数据流传递、高层次抽象
- Mutex：简单共享状态保护、性能要求高

---

## 📚 扩展阅读

- [Go官方文档-并发](https://golang.org/doc/effective_go.html#concurrency)
- [Go Concurrency Patterns (Rob Pike)](https://www.youtube.com/watch?v=f6kdp27TYZs)
- [Go by Example: Goroutines](https://gobyexample.com/goroutines)
- [Go by Example: Channels](https://gobyexample.com/channels)
- [The Go Memory Model](https://golang.org/ref/mem)
- [Concurrency is not Parallelism](https://go.dev/blog/waza-talk)

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025-10-29  
**文档状态**: 已优化  
**适用版本**: Go 1.25.3+
