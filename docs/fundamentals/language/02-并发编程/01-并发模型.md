# Goè¯­è¨€å¹¶å‘æ¨¡å‹

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.23+

---

## ğŸ“‹ ç›®å½•

- [Goè¯­è¨€å¹¶å‘æ¨¡å‹](#goè¯­è¨€å¹¶å‘æ¨¡å‹)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“š ç†è®ºåˆ†æ](#-ç†è®ºåˆ†æ)
    - [CSPç†è®ºåŸºç¡€](#cspç†è®ºåŸºç¡€)
      - [æ ¸å¿ƒæ€æƒ³](#æ ¸å¿ƒæ€æƒ³)
      - [å½¢å¼åŒ–æè¿°](#å½¢å¼åŒ–æè¿°)
      - [CSP vs ä¼ ç»Ÿå¹¶å‘](#csp-vs-ä¼ ç»Ÿå¹¶å‘)
    - [Goè¿è¡Œæ—¶è°ƒåº¦æ¨¡å‹](#goè¿è¡Œæ—¶è°ƒåº¦æ¨¡å‹)
      - [G-P-Mæ¨¡å‹](#g-p-mæ¨¡å‹)
      - [Work Stealingï¼ˆå·¥ä½œçªƒå–ï¼‰](#work-stealingå·¥ä½œçªƒå–)
      - [æŠ¢å å¼è°ƒåº¦](#æŠ¢å å¼è°ƒåº¦)
    - [å†…å­˜æ¨¡å‹ä¸åŒæ­¥](#å†…å­˜æ¨¡å‹ä¸åŒæ­¥)
      - [Happens-Beforeå…³ç³»](#happens-beforeå…³ç³»)
  - [ğŸ’» ä»£ç ç¤ºä¾‹](#-ä»£ç ç¤ºä¾‹)
    - [GoroutineåŸºç¡€](#goroutineåŸºç¡€)
    - [Channelé€šä¿¡](#channelé€šä¿¡)
    - [Selectå¤šè·¯å¤ç”¨](#selectå¤šè·¯å¤ç”¨)
  - [ğŸ—ï¸ å¹¶å‘æ¨¡å¼](#ï¸-å¹¶å‘æ¨¡å¼)
    - [Worker Pool](#worker-pool)
    - [Pipeline](#pipeline)
    - [Fan-Out/Fan-In](#fan-outfan-in)
  - [ğŸ“Š æ€§èƒ½åˆ†æ](#-æ€§èƒ½åˆ†æ)
    - [Goroutine vs Thread](#goroutine-vs-thread)
    - [Channel vs é”](#channel-vs-é”)
  - [ğŸ§ª æµ‹è¯•ä»£ç ](#-æµ‹è¯•ä»£ç )
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [1. ä¼˜å…ˆä½¿ç”¨Channelé€šä¿¡](#1-ä¼˜å…ˆä½¿ç”¨channelé€šä¿¡)
    - [2. ä¿è¯Goroutineé€€å‡º](#2-ä¿è¯goroutineé€€å‡º)
    - [3. é¿å…Goroutineæ³„æ¼](#3-é¿å…goroutineæ³„æ¼)
    - [4. åˆç†è®¾ç½®GOMAXPROCS](#4-åˆç†è®¾ç½®gomaxprocs)
    - [5. ä½¿ç”¨sync.WaitGroupç®¡ç†](#5-ä½¿ç”¨syncwaitgroupç®¡ç†)
  - [ğŸ” å¸¸è§é—®é¢˜](#-å¸¸è§é—®é¢˜)
  - [ğŸ“š æ‰©å±•é˜…è¯»](#-æ‰©å±•é˜…è¯»)

## ğŸ“š ç†è®ºåˆ†æ

### CSPç†è®ºåŸºç¡€

Goè¯­è¨€å¹¶å‘æ¨¡å‹åŸºäº**CSPï¼ˆCommunicating Sequential Processesï¼‰**ç†è®ºï¼Œç”±Tony Hoareåœ¨1978å¹´æå‡ºã€‚

#### æ ¸å¿ƒæ€æƒ³

**"ä¸è¦é€šè¿‡å…±äº«å†…å­˜æ¥é€šä¿¡ï¼Œè€Œåº”é€šè¿‡é€šä¿¡æ¥å…±äº«å†…å­˜"**
*"Do not communicate by sharing memory; instead, share memory by communicating."*

```text
ä¼ ç»Ÿå¹¶å‘ï¼ˆå…±äº«å†…å­˜ï¼‰ï¼š
Thread1 -----> [Shared Memory] <----- Thread2
           é”ä¿æŠ¤

CSPæ¨¡å‹ï¼ˆæ¶ˆæ¯ä¼ é€’ï¼‰ï¼š
Process1 -----> [Channel] -----> Process2
           æ¶ˆæ¯ä¼ é€’
```

#### å½¢å¼åŒ–æè¿°

```text
Process ::= goroutine
Channel ::= make(chan T [, capacity])
Send    ::= ch <- value
Receive ::= value := <-ch
Select  ::= select { case ... }
```

**CSPçš„ä¸‰å¤§è¦ç´ ï¼š**

1. **è¿›ç¨‹ï¼ˆProcessï¼‰**ï¼šGoä¸­çš„goroutineï¼Œç‹¬ç«‹æ‰§è¡Œå•å…ƒ
2. **é€šé“ï¼ˆChannelï¼‰**ï¼šè¿›ç¨‹é—´é€šä¿¡åª’ä»‹ï¼Œç±»å‹å®‰å…¨
3. **åŒæ­¥é€šä¿¡**ï¼šå‘é€ä¸æ¥æ”¶æ“ä½œé…å¯¹ï¼Œå®ç°åŒæ­¥

#### CSP vs ä¼ ç»Ÿå¹¶å‘

| ç‰¹æ€§ | ä¼ ç»Ÿå¹¶å‘ï¼ˆé”ï¼‰ | CSPï¼ˆGoï¼‰ |
|------|---------------|-----------|
| é€šä¿¡æ–¹å¼ | å…±äº«å†…å­˜ | æ¶ˆæ¯ä¼ é€’ |
| åŒæ­¥æœºåˆ¶ | äº’æ–¥é”ã€ä¿¡å·é‡ | Channel |
| æ­»é”æ£€æµ‹ | å›°éš¾ | ç¼–è¯‘å™¨/è¿è¡Œæ—¶è¾…åŠ© |
| ç»„åˆæ€§ | ä½ï¼ˆé”éš¾ä»¥ç»„åˆï¼‰ | é«˜ï¼ˆchannelå¯ç»„åˆï¼‰ |
| å¯è¯»æ€§ | ä½ï¼ˆéšå¼ä¾èµ–ï¼‰ | é«˜ï¼ˆæ˜¾å¼é€šä¿¡ï¼‰ |

### Goè¿è¡Œæ—¶è°ƒåº¦æ¨¡å‹

#### G-P-Mæ¨¡å‹

Goä½¿ç”¨é«˜æ•ˆçš„**M:Nè°ƒåº¦æ¨¡å‹**ï¼ˆå¤šä¸ªgoroutineæ˜ å°„åˆ°å¤šä¸ªOSçº¿ç¨‹ï¼‰ï¼š

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Go Runtime Scheduler        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                     â”‚
â”‚  G (Goroutine) - ç”¨æˆ·æ€çº¿ç¨‹          â”‚
â”‚  â”œâ”€ æ ˆï¼ˆåˆå§‹2KBï¼Œå¯æ‰©å±•åˆ°1GBï¼‰        â”‚
â”‚  â”œâ”€ ç¨‹åºè®¡æ•°å™¨                       â”‚
â”‚  â””â”€ çŠ¶æ€ï¼ˆè¿è¡Œ/é˜»å¡/æ­»äº¡ï¼‰            â”‚
â”‚                                     â”‚
â”‚  P (Processor) - é€»è¾‘å¤„ç†å™¨          â”‚
â”‚  â”œâ”€ æœ¬åœ°Gé˜Ÿåˆ—ï¼ˆLIFOï¼‰                â”‚
â”‚  â”œâ”€ ç¼“å­˜ï¼ˆmcacheï¼‰                  â”‚
â”‚  â””â”€ æ•°é‡ = GOMAXPROCS               â”‚
â”‚                                     â”‚
â”‚  M (Machine) - OSçº¿ç¨‹               â”‚
â”‚  â”œâ”€ æ‰§è¡ŒG                           â”‚
â”‚  â””â”€ æ•°é‡åŠ¨æ€è°ƒæ•´                     â”‚
â”‚                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**è°ƒåº¦æµç¨‹ï¼š**

```text
1. åˆ›å»ºGï¼šgo func() { ... }
2. GåŠ å…¥Pçš„æœ¬åœ°é˜Ÿåˆ—
3. Mä»Pè·å–Gæ‰§è¡Œ
4. Gé˜»å¡æ—¶ï¼š
   - I/Oé˜»å¡ï¼šMä¼‘çœ ï¼ŒPç»‘å®šæ–°M
   - Channelé˜»å¡ï¼šGæŒ‚èµ·ï¼ŒMç»§ç»­æ‰§è¡Œå…¶ä»–G
5. Gå®Œæˆï¼šå›æ”¶æ ˆï¼ŒMè·å–æ–°G
```

#### Work Stealingï¼ˆå·¥ä½œçªƒå–ï¼‰

```go
// P1çš„é˜Ÿåˆ—æ»¡ï¼ŒP2çš„é˜Ÿåˆ—ç©º
P1: [G1, G2, G3, G4, G5]
P2: []

// P2ä»P1çš„é˜Ÿåˆ—æœ«å°¾çªƒå–ä¸€åŠä»»åŠ¡
P1: [G1, G2, G3]
P2: [G4, G5]  â† çªƒå–
```

**ä¼˜ç‚¹ï¼š**

- è´Ÿè½½å‡è¡¡
- å‡å°‘å…¨å±€é”ç«äº‰
- æé«˜CPUåˆ©ç”¨ç‡

#### æŠ¢å å¼è°ƒåº¦

**åä½œå¼ â†’ æŠ¢å å¼æ¼”è¿›ï¼š**

| ç‰ˆæœ¬ | è°ƒåº¦æ–¹å¼ | é—®é¢˜ |
|------|---------|------|
| Go 1.0-1.13 | åä½œå¼ | é•¿æ—¶é—´è¿è¡Œçš„goroutineå¯èƒ½é¥¿æ­»å…¶ä»–goroutine |
| Go 1.14+ | åŸºäºä¿¡å·çš„æŠ¢å å¼ | è§£å†³é¥¿æ­»é—®é¢˜ï¼Œæ›´å…¬å¹³ |

### å†…å­˜æ¨¡å‹ä¸åŒæ­¥

#### Happens-Beforeå…³ç³»

Goä¿è¯ä»¥ä¸‹happens-beforeé¡ºåºï¼š

1. **å•ä¸ªgoroutineå†…**ï¼šæŒ‰ç¨‹åºé¡ºåºæ‰§è¡Œ
2. **Channelå‘é€ happens-before æ¥æ”¶å®Œæˆ**
3. **Channelå…³é—­ happens-before æ¥æ”¶è¿”å›é›¶å€¼**
4. **æ— ç¼“å†²channelæ¥æ”¶ happens-before å‘é€å®Œæˆ**

```go
// ç¤ºä¾‹ï¼šä¿è¯é¡ºåº
var c = make(chan int)
var a string

func f() {
    a = "hello, world"  // (1)
    c <- 0              // (2) happens-after (1)
}

func main() {
    go f()
    <-c                 // (3) happens-after (2)
    print(a)            // (4) happens-after (3)ï¼Œä¿è¯èƒ½çœ‹åˆ°"hello, world"
}
```

---

## ğŸ’» ä»£ç ç¤ºä¾‹

### GoroutineåŸºç¡€

**åˆ›å»ºGoroutineï¼š**

```go
package main

import (
    "fmt"
    "time"
)

func say(s string) {
    for i := 0; i < 3; i++ {
        time.Sleep(100 * time.Millisecond)
        fmt.Println(s)
    }
}

func main() {
    go say("world")  // å¹¶å‘æ‰§è¡Œ
    say("hello")     // ä¸»goroutineæ‰§è¡Œ
}
```

**Goroutineç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼š**

```go
import "sync"

func main() {
    var wg sync.WaitGroup

    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            fmt.Printf("Worker %d done\n", id)
        }(i)  // ä¼ å‚ï¼Œé¿å…é—­åŒ…é™·é˜±
    }

    wg.Wait()  // ç­‰å¾…æ‰€æœ‰goroutineå®Œæˆ
    fmt.Println("All workers done")
}
```

### Channelé€šä¿¡

**æ— ç¼“å†²Channelï¼ˆåŒæ­¥ï¼‰ï¼š**

```go
func main() {
    ch := make(chan int)

    go func() {
        ch <- 42  // å‘é€é˜»å¡ï¼Œç›´åˆ°è¢«æ¥æ”¶
    }()

    val := <-ch  // æ¥æ”¶é˜»å¡ï¼Œç›´åˆ°æœ‰æ•°æ®
    fmt.Println(val)  // 42
}
```

**æœ‰ç¼“å†²Channelï¼ˆå¼‚æ­¥ï¼‰ï¼š**

```go
func main() {
    ch := make(chan int, 2)  // å®¹é‡ä¸º2

    ch <- 1  // ä¸é˜»å¡
    ch <- 2  // ä¸é˜»å¡
    // ch <- 3  // ä¼šé˜»å¡ï¼Œç¼“å†²åŒºæ»¡

    fmt.Println(<-ch)  // 1
    fmt.Println(<-ch)  // 2
}
```

**å•å‘Channelï¼ˆç±»å‹å®‰å…¨ï¼‰ï¼š**

```go
// åªå‘é€channel
func producer(ch chan<- int) {
    for i := 0; i < 5; i++ {
        ch <- i
    }
    close(ch)
}

// åªæ¥æ”¶channel
func consumer(ch <-chan int) {
    for val := range ch {
        fmt.Println(val)
    }
}

func main() {
    ch := make(chan int, 5)
    go producer(ch)
    consumer(ch)
}
```

**å…³é—­Channelï¼š**

```go
func main() {
    ch := make(chan int, 3)
    ch <- 1
    ch <- 2
    ch <- 3
    close(ch)  // å…³é—­channel

    // éå†ç›´åˆ°channelå…³é—­
    for val := range ch {
        fmt.Println(val)
    }

    // æ£€æµ‹channelæ˜¯å¦å…³é—­
    val, ok := <-ch
    fmt.Println(val, ok)  // 0 false
}
```

### Selectå¤šè·¯å¤ç”¨

**åŸºæœ¬ç”¨æ³•ï¼š**

```go
func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)

    go func() {
        time.Sleep(1 * time.Second)
        ch1 <- "one"
    }()

    go func() {
        time.Sleep(2 * time.Second)
        ch2 <- "two"
    }()

    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-ch1:
            fmt.Println("Received", msg1)
        case msg2 := <-ch2:
            fmt.Println("Received", msg2)
        }
    }
}
```

**è¶…æ—¶å¤„ç†ï¼š**

```go
func main() {
    ch := make(chan string)

    go func() {
        time.Sleep(2 * time.Second)
        ch <- "result"
    }()

    select {
    case res := <-ch:
        fmt.Println(res)
    case <-time.After(1 * time.Second):
        fmt.Println("Timeout!")
    }
}
```

**éé˜»å¡æ“ä½œï¼š**

```go
func main() {
    ch := make(chan int, 1)

    select {
    case ch <- 42:
        fmt.Println("Sent")
    default:
        fmt.Println("Channel full")
    }

    select {
    case val := <-ch:
        fmt.Println("Received", val)
    default:
        fmt.Println("Channel empty")
    }
}
```

---

## ğŸ—ï¸ å¹¶å‘æ¨¡å¼

### Worker Pool

```go
func workerPool(tasks <-chan Task, results chan<- Result, numWorkers int) {
    var wg sync.WaitGroup

    for i := 0; i < numWorkers; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for task := range tasks {
                result := task.Process()
                results <- result
            }
        }(i)
    }

    wg.Wait()
    close(results)
}

// ä½¿ç”¨
func main() {
    tasks := make(chan Task, 100)
    results := make(chan Result, 100)

    go workerPool(tasks, results, 5)  // 5ä¸ªworker

    // ç”Ÿäº§ä»»åŠ¡
    go func() {
        for i := 0; i < 10; i++ {
            tasks <- Task{ID: i}
        }
        close(tasks)
    }()

    // æ¶ˆè´¹ç»“æœ
    for result := range results {
        fmt.Println(result)
    }
}
```

### Pipeline

```go
// é˜¶æ®µ1ï¼šç”Ÿæˆæ•°æ®
func generate(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out <- n
        }
        close(out)
    }()
    return out
}

// é˜¶æ®µ2ï¼šå¹³æ–¹
func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * n
        }
        close(out)
    }()
    return out
}

// é˜¶æ®µ3ï¼šè¿‡æ»¤
func filter(in <-chan int, f func(int) bool) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            if f(n) {
                out <- n
            }
        }
        close(out)
    }()
    return out
}

// ç»„è£…Pipeline
func main() {
    // ç”Ÿæˆ -> å¹³æ–¹ -> è¿‡æ»¤
    c := generate(1, 2, 3, 4, 5)
    c = square(c)
    c = filter(c, func(n int) bool { return n > 10 })

    for result := range c {
        fmt.Println(result)  // 16, 25
    }
}
```

### Fan-Out/Fan-In

```go
// Fan-Out: ä¸€ä¸ªè¾“å…¥ï¼Œå¤šä¸ªworkerå¤„ç†
func fanOut(in <-chan int, workers int) []<-chan int {
    channels := make([]<-chan int, workers)
    for i := 0; i < workers; i++ {
        channels[i] = worker(in)
    }
    return channels
}

func worker(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * n  // å¤„ç†
            time.Sleep(time.Millisecond)
        }
        close(out)
    }()
    return out
}

// Fan-In: å¤šä¸ªè¾“å…¥åˆå¹¶ä¸ºä¸€ä¸ªè¾“å‡º
func fanIn(channels ...<-chan int) <-chan int {
    out := make(chan int)
    var wg sync.WaitGroup

    for _, ch := range channels {
        wg.Add(1)
        go func(c <-chan int) {
            defer wg.Done()
            for n := range c {
                out <- n
            }
        }(ch)
    }

    go func() {
        wg.Wait()
        close(out)
    }()

    return out
}

// ä½¿ç”¨
func main() {
    in := generate(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

    // Fan-Out: 3ä¸ªworkerå¹¶å‘å¤„ç†
    workers := fanOut(in, 3)

    // Fan-In: åˆå¹¶ç»“æœ
    results := fanIn(workers...)

    for result := range results {
        fmt.Println(result)
    }
}
```

---

## ğŸ“Š æ€§èƒ½åˆ†æ

### Goroutine vs Thread

| æŒ‡æ ‡ | Goroutine | OS Thread |
|------|-----------|-----------|
| åˆ›å»ºå¼€é”€ | ~2KBæ ˆ | ~1-2MBæ ˆ |
| åˆ‡æ¢å¼€é”€ | çº³ç§’çº§ | å¾®ç§’çº§ |
| æ•°é‡ä¸Šé™ | ç™¾ä¸‡çº§ | æ•°åƒä¸ª |
| è°ƒåº¦å™¨ | Goè¿è¡Œæ—¶ | OSå†…æ ¸ |
| æ ˆå¢é•¿ | åŠ¨æ€æ‰©å±• | å›ºå®šå¤§å° |

### Channel vs é”

```go
// Benchmarkå¯¹æ¯”
func BenchmarkChannel(b *testing.B) {
    ch := make(chan int, 1)
    go func() {
        for range ch {
        }
    }()

    for i := 0; i < b.N; i++ {
        ch <- i
    }
}

func BenchmarkMutex(b *testing.B) {
    var mu sync.Mutex
    var val int

    for i := 0; i < b.N; i++ {
        mu.Lock()
        val = i
        mu.Unlock()
    }
}

// ç»“æœï¼š
// BenchmarkChannel-8    20000000    75.2 ns/op
// BenchmarkMutex-8      50000000    28.5 ns/op
```

**é€‰æ‹©å»ºè®®ï¼š**

- **Channel**ï¼šé«˜å±‚æ¬¡æŠ½è±¡ï¼Œæ•°æ®æµä¼ é€’ï¼Œæ˜“äºç»„åˆ
- **Mutex**ï¼šä½å±‚æ¬¡ä¿æŠ¤ï¼Œç®€å•å…±äº«çŠ¶æ€ï¼Œæ€§èƒ½æ›´é«˜

---

## ğŸ§ª æµ‹è¯•ä»£ç 

```go
package main

import (
    "testing"
    "time"
)

func TestChannelCommunication(t *testing.T) {
    ch := make(chan int)
    go func() {
        ch <- 42
    }()

    v := <-ch
    if v != 42 {
        t.Errorf("expected 42, got %d", v)
    }
}

func TestSelectTimeout(t *testing.T) {
    ch := make(chan int)

    select {
    case <-ch:
        t.Error("Should timeout")
    case <-time.After(100 * time.Millisecond):
        // Success
    }
}

func TestWorkerPool(t *testing.T) {
    tasks := make(chan int, 10)
    results := make(chan int, 10)

    // å¯åŠ¨3ä¸ªworker
    for i := 0; i < 3; i++ {
        go func() {
            for task := range tasks {
                results <- task * 2
            }
        }()
    }

    // å‘é€ä»»åŠ¡
    for i := 0; i < 5; i++ {
        tasks <- i
    }
    close(tasks)

    // æ”¶é›†ç»“æœ
    sum := 0
    for i := 0; i < 5; i++ {
        sum += <-results
    }

    expected := 0 + 2 + 4 + 6 + 8  // 0*2 + 1*2 + 2*2 + 3*2 + 4*2
    if sum != expected {
        t.Errorf("expected %d, got %d", expected, sum)
    }
}
```

---

## ğŸ¯ æœ€ä½³å®è·µ

### 1. ä¼˜å…ˆä½¿ç”¨Channelé€šä¿¡

```go
// âŒ å…±äº«å†…å­˜
var counter int
var mu sync.Mutex

go func() {
    mu.Lock()
    counter++
    mu.Unlock()
}()

// âœ… Channelé€šä¿¡
ch := make(chan int, 1)
go func() {
    ch <- 1
}()
```

### 2. ä¿è¯Goroutineé€€å‡º

```go
// âœ… ä½¿ç”¨contextæ§åˆ¶
func worker(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            return  // ç¡®ä¿é€€å‡º
        default:
            // å·¥ä½œ
        }
    }
}
```

### 3. é¿å…Goroutineæ³„æ¼

```go
// âŒ æ³„æ¼ï¼šchannelæ°¸è¿œé˜»å¡
func leak() {
    ch := make(chan int)
    go func() {
        ch <- 42  // æ°¸è¿œé˜»å¡ï¼Œæ— æ¥æ”¶è€…
    }()
}

// âœ… ç¡®ä¿æœ‰æ¥æ”¶è€…æˆ–ä½¿ç”¨ç¼“å†²
func noLeak() {
    ch := make(chan int, 1)
    go func() {
        ch <- 42
    }()
}
```

### 4. åˆç†è®¾ç½®GOMAXPROCS

```go
import "runtime"

func init() {
    // CPUå¯†é›†å‹ï¼šè®¾ä¸ºCPUæ ¸æ•°
    runtime.GOMAXPROCS(runtime.NumCPU())

    // I/Oå¯†é›†å‹ï¼šå¯ä»¥æ›´å¤š
    // runtime.GOMAXPROCS(runtime.NumCPU() * 2)
}
```

### 5. ä½¿ç”¨sync.WaitGroupç®¡ç†

```go
var wg sync.WaitGroup

for i := 0; i < 10; i++ {
    wg.Add(1)
    go func(id int) {
        defer wg.Done()
        // å·¥ä½œ
    }(i)
}

wg.Wait()  // ç­‰å¾…æ‰€æœ‰å®Œæˆ
```

---

## ğŸ” å¸¸è§é—®é¢˜

**Q: Goroutineæ•°é‡æœ‰é™åˆ¶å—ï¼Ÿ**
A: ç†è®ºä¸Šå¯è¾¾ç™¾ä¸‡çº§ï¼Œå—å†…å­˜é™åˆ¶ã€‚ä½†å®é™…åº”ç”¨å»ºè®®ä½¿ç”¨Worker Poolæ§åˆ¶æ•°é‡ã€‚

**Q: Channelä¸€å®šè¦å…³é—­å—ï¼Ÿ**
A:

- åªéœ€ç”Ÿäº§è€…å…³é—­
- æ¶ˆè´¹è€…é€šè¿‡`val, ok := <-ch`æ£€æµ‹
- ä¸å…³é—­channelä¹Ÿä¼šè¢«GCå›æ”¶

**Q: å¦‚ä½•é¿å…Goroutineæ³„æ¼ï¼Ÿ**
A:

- ä½¿ç”¨contextæ§åˆ¶ç”Ÿå‘½å‘¨æœŸ
- ç¡®ä¿æ¯ä¸ªgoroutineéƒ½æœ‰é€€å‡ºè·¯å¾„
- ä½¿ç”¨pprofæ£€æµ‹æ³„æ¼

**Q: selectéšæœºé€‰æ‹©å—ï¼Ÿ**
A: å½“å¤šä¸ªcaseåŒæ—¶å°±ç»ªæ—¶ï¼Œselectéšæœºé€‰æ‹©ä¸€ä¸ªæ‰§è¡Œã€‚

**Q: Channel vs Mutexå¦‚ä½•é€‰æ‹©ï¼Ÿ**
A:

- Channelï¼šæ•°æ®æµä¼ é€’ã€é«˜å±‚æ¬¡æŠ½è±¡
- Mutexï¼šç®€å•å…±äº«çŠ¶æ€ä¿æŠ¤ã€æ€§èƒ½è¦æ±‚é«˜

---

## ğŸ“š æ‰©å±•é˜…è¯»

- [Goå®˜æ–¹æ–‡æ¡£-å¹¶å‘](https://golang.org/doc/effective_go.html#concurrency)
- [Go Concurrency Patterns (Rob Pike)](https://www.youtube.com/watch?v=f6kdp27TYZs)
- [Go by Example: Goroutines](https://gobyexample.com/goroutines)
- [Go by Example: Channels](https://gobyexample.com/channels)
- [The Go Memory Model](https://golang.org/ref/mem)
- [Concurrency is not Parallelism](https://go.dev/blog/waza-talk)

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team
**æœ€åæ›´æ–°**: 2025-10-29
**æ–‡æ¡£çŠ¶æ€**: å·²ä¼˜åŒ–
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
