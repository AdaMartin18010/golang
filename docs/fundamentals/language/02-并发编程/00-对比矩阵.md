# 对比矩阵

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3  
**文件夹**: fundamentals/language/02-并发编程

---

## 📋 目录

- [1. 并发单元对比](#1.-并发单元对比)
  - [1.1 Goroutine vs Thread vs Process](#1.1-goroutine-vs-thread-vs-process)
  - [1.2 协作式调度 vs 抢占式调度](#1.2-协作式调度-vs-抢占式调度)
- [2. 通信机制对比](#2.-通信机制对比)
  - [2.1 Channel vs Mutex (通信 vs 共享内存)](#2.1-channel-vs-mutex-通信-vs-共享内存)
  - [2.2 缓冲Channel vs 无缓冲Channel](#2.2-缓冲channel-vs-无缓冲channel)
- [3. 同步原语对比](#3.-同步原语对比)
  - [3.1 sync.Mutex vs sync.RWMutex](#3.1-sync.mutex-vs-sync.rwmutex)
  - [3.2 sync.WaitGroup vs Context](#3.2-sync.waitgroup-vs-context)
  - [3.3 sync.Once vs init函数](#3.3-sync.once-vs-init函数)
  - [3.4 atomic vs Mutex](#3.4-atomic-vs-mutex)
- [4. 控制机制对比](#4.-控制机制对比)
  - [4.1 Select vs Switch](#4.1-select-vs-switch)
  - [4.2 Context.WithCancel vs Context.WithTimeout](#4.2-context.withcancel-vs-context.withtimeout)
- [5. 并发模式对比](#5.-并发模式对比)
  - [5.1 Pipeline vs Worker Pool](#5.1-pipeline-vs-worker-pool)
  - [5.2 Fan-out vs Fan-in](#5.2-fan-out-vs-fan-in)
- [6. 与其他语言对比](#6.-与其他语言对比)
  - [6.1 Go vs Java 并发模型](#6.1-go-vs-java-并发模型)
  - [6.2 Go vs Python 并发模型](#6.2-go-vs-python-并发模型)
  - [6.3 Go vs Rust 并发模型](#6.3-go-vs-rust-并发模型)
- [📊 总结对比表](#总结对比表)
  - [核心机制选择指南](#核心机制选择指南)
- [🔗 相关文档](#相关文档)

## 1. 并发单元对比

### 1.1 Goroutine vs Thread vs Process

| 维度 | Goroutine | Thread | Process |
|------|-----------|--------|---------|
| **定义** | Go运行时管理的轻量级线程 | OS级别的线程 | 独立的执行单元 |
| **创建成本** | 极低（~2KB栈） | 中等（~1-2MB栈） | 高（完整地址空间） |
| **切换成本** | 极低（用户态） | 中等（内核态） | 高（内核态+上下文） |
| **数量限制** | 百万级 | 千级 | 百级 |
| **调度方式** | 协作式（Go调度器） | 抢占式（OS调度器） | 抢占式（OS调度器） |
| **内存共享** | 共享（同进程内） | 共享（同进程内） | 隔离（需IPC） |
| **通信方式** | Channel/共享内存 | 共享内存/条件变量 | IPC（管道/消息队列） |
| **启动语法** | `go func()` | `pthread_create` | `fork`/`exec` |
| **管理复杂度** | 低 | 中 | 高 |
| **使用场景** | 大规模并发任务 | 中等并发，需OS级特性 | 进程隔离，独立服务 |

**关键区别示例**:

```go
// Goroutine - 轻量级，易用
go func() {
    fmt.Println("Goroutine running")
}()

// 可以轻松创建数十万个
for i := 0; i < 100000; i++ {
    go doWork(i)
}
```

```c
// Thread (C) - 重量级
pthread_t thread;
pthread_create(&thread, NULL, worker, NULL);

// 创建数千个线程会导致资源耗尽
```

### 1.2 协作式调度 vs 抢占式调度

| 维度 | 协作式调度 (Goroutine) | 抢占式调度 (Thread) |
|------|------------------------|---------------------|
| **调度时机** | 函数调用、channel操作、系统调用 | 时间片耗尽 |
| **调度器** | Go运行时（用户态） | OS内核（内核态） |
| **上下文切换** | 快（只保存Go栈） | 慢（完整上下文） |
| **公平性** | 需要主动让出 | 强制公平 |
| **死锁风险** | 较高（如果不主动让出） | 较低 |
| **可预测性** | 高（明确让出点） | 低（随时可能被抢占） |
| **CPU利用率** | 高（少切换） | 中（频繁切换） |

**Go 1.14+**: 引入异步抢占，提高了公平性。

---

## 2. 通信机制对比

### 2.1 Channel vs Mutex (通信 vs 共享内存)

| 维度 | Channel | Mutex |
|------|---------|-------|
| **设计理念** | "通过通信来共享内存" | "通过共享内存来通信" |
| **数据传递** | 值传递/移交所有权 | 共享访问 |
| **同步保证** | 天然同步（阻塞/等待） | 需手动加锁/解锁 |
| **死锁风险** | 中等（channel死锁） | 高（忘记解锁、顺序错误） |
| **错误倾向** | channel泄漏 | 竞态条件、死锁 |
| **性能** | 稍慢（涉及调度） | 快（无调度） |
| **可读性** | 高（明确的数据流） | 中（需理解临界区） |
| **适用场景** | goroutine间通信、数据流 | 保护共享状态、短临界区 |

**使用建议** (Go谚语):
> "Don't communicate by sharing memory; share memory by communicating."

**示例对比**:

```go
// Channel方式 - 推荐
func worker(jobs <-chan int, results chan<- int) {
    for j := range jobs {
        results <- process(j)
    }
}

// Mutex方式 - 必要时使用
var (
    counter int
    mu      sync.Mutex
)

func increment() {
    mu.Lock()
    counter++
    mu.Unlock()
}
```

### 2.2 缓冲Channel vs 无缓冲Channel

| 维度 | 无缓冲Channel | 缓冲Channel |
|------|--------------|-------------|
| **定义** | `make(chan T)` | `make(chan T, n)` |
| **容量** | 0 | n |
| **发送阻塞** | 立即阻塞（直到接收） | 缓冲区满时阻塞 |
| **接收阻塞** | 立即阻塞（直到发送） | 缓冲区空时阻塞 |
| **同步性** | 强同步（确保交付） | 异步（缓冲区内） |
| **性能** | 较慢（每次都同步） | 较快（批量处理） |
| **语义** | 握手（rendezvous） | 邮箱（mailbox） |
| **使用场景** | 需要强同步、确保交付 | 解耦、缓冲、性能优化 |

**选择建议**:

```go
// 无缓冲 - 强同步场景
done := make(chan struct{})  // 信号量
result := make(chan Result)  // 确保结果已处理

// 缓冲 - 异步场景
jobs := make(chan Job, 100)      // 任务队列
errors := make(chan error, 10)   // 错误收集
```

---

## 3. 同步原语对比

### 3.1 sync.Mutex vs sync.RWMutex

| 维度 | Mutex | RWMutex |
|------|-------|---------|
| **读锁** | 不区分读写 | 支持多读 |
| **写锁** | 独占 | 独占（排斥所有读写） |
| **并发读** | 串行 | 并行 |
| **性能（读多）** | 低 | 高 |
| **性能（写多）** | 中 | 低（写锁更重） |
| **复杂度** | 低 | 中（需选择锁类型） |
| **锁饥饿** | 较少 | 可能（写锁饥饿） |
| **使用场景** | 读写均衡、简单场景 | 读多写少场景 |

**性能对比**:

```go
// 读多写少 - RWMutex性能更好
var (
    data   map[string]string
    rwMu   sync.RWMutex
)

// 读操作（可并行）
func read(key string) string {
    rwMu.RLock()
    defer rwMu.RUnlock()
    return data[key]
}

// 写操作（独占）
func write(key, value string) {
    rwMu.Lock()
    defer rwMu.Unlock()
    data[key] = value
}
```

### 3.2 sync.WaitGroup vs Context

| 维度 | WaitGroup | Context |
|------|-----------|---------|
| **用途** | 等待goroutine完成 | 取消、超时、传值 |
| **方向** | 子→父（通知完成） | 父→子（传播取消） |
| **操作** | Add/Done/Wait | WithCancel/WithTimeout |
| **信号类型** | 完成信号 | 取消信号 |
| **超时支持** | 无 | 有 |
| **值传递** | 无 | 有（WithValue） |
| **链式传播** | 无 | 有（context树） |
| **使用场景** | 等待所有任务完成 | 主动取消、超时控制 |

**组合使用**:

```go
func processWithTimeout(items []Item) error {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    var wg sync.WaitGroup
    errCh := make(chan error, len(items))
    
    for _, item := range items {
        wg.Add(1)
        go func(it Item) {
            defer wg.Done()
            if err := process(ctx, it); err != nil {
                errCh <- err
            }
        }(item)
    }
    
    wg.Wait()
    close(errCh)
    
    // 检查错误
    for err := range errCh {
        return err
    }
    return nil
}
```

### 3.3 sync.Once vs init函数

| 维度 | sync.Once | init函数 |
|------|-----------|---------|
| **执行时机** | 首次调用Do时 | 包导入时 |
| **执行次数** | 只执行一次 | 只执行一次 |
| **并发安全** | 是（内置同步） | 是（串行执行） |
| **条件控制** | 可运行时控制 | 无法控制 |
| **多个初始化** | 支持（多个Once） | 支持（多个init） |
| **测试友好** | 好（可重置） | 差（无法重置） |
| **使用场景** | 延迟初始化、单例 | 包级别初始化 |

**示例**:

```go
// sync.Once - 运行时控制
var (
    instance *Singleton
    once     sync.Once
)

func GetInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{}
    })
    return instance
}

// init - 包加载时
func init() {
    // 包级别初始化
    setupLogging()
}
```

### 3.4 atomic vs Mutex

| 维度 | atomic | Mutex |
|------|--------|-------|
| **操作粒度** | 单个变量 | 任意代码块 |
| **支持类型** | int32/64, uint32/64, uintptr, pointer | 任意 |
| **性能** | 极快（CPU指令） | 快（需调度） |
| **复杂度** | 只支持简单操作 | 支持复杂操作 |
| **可组合性** | 低 | 高 |
| **内存顺序** | 提供保证 | 提供保证 |
| **使用场景** | 计数器、标志位 | 复杂临界区 |

**性能对比**:

```go
// atomic - 简单计数
var counter int64
atomic.AddInt64(&counter, 1)

// Mutex - 复杂操作
var (
    data map[string]int
    mu   sync.Mutex
)

mu.Lock()
data["key"]++
mu.Unlock()
```

---

## 4. 控制机制对比

### 4.1 Select vs Switch

| 维度 | Select | Switch |
|------|--------|--------|
| **用途** | Channel多路复用 | 值/类型多分支 |
| **操作对象** | Channel操作 | 表达式求值 |
| **阻塞** | 可以阻塞 | 不阻塞 |
| **default** | 非阻塞分支 | 默认分支 |
| **fallthrough** | 不支持 | 支持 |
| **随机性** | 多个case就绪时随机 | 按顺序匹配 |
| **使用场景** | 并发通信控制 | 条件分支 |

**Select特性**:

```go
select {
case msg := <-ch1:
    fmt.Println("Received from ch1:", msg)
case msg := <-ch2:
    fmt.Println("Received from ch2:", msg)
case <-time.After(time.Second):
    fmt.Println("Timeout")
default:
    fmt.Println("No message")
}
```

### 4.2 Context.WithCancel vs Context.WithTimeout

| 维度 | WithCancel | WithTimeout |
|------|------------|-------------|
| **触发方式** | 手动调用cancel() | 超时自动触发 |
| **取消时机** | 任意时刻 | 超时后 |
| **资源回收** | 需手动调用cancel | 超时后自动 |
| **使用场景** | 主动取消控制 | 超时控制 |
| **常见用法** | 用户取消、错误取消 | API调用超时、操作超时 |

**组合使用**:

```go
// 手动取消
ctx, cancel := context.WithCancel(context.Background())
defer cancel()
go doWork(ctx)
// ...主动取消
cancel()

// 超时取消
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
result, err := callAPI(ctx)
```

---

## 5. 并发模式对比

### 5.1 Pipeline vs Worker Pool

| 维度 | Pipeline | Worker Pool |
|------|----------|-------------|
| **结构** | 多阶段串行 | 任务并行处理 |
| **数据流** | 单向流动 | 任务分发 |
| **并发点** | 每个阶段并发 | 多个worker并发 |
| **适用场景** | 数据转换、处理流程 | 任务处理、请求处理 |
| **复杂度** | 中（多stage） | 低（单stage） |
| **扩展性** | 每stage独立扩展 | worker数量扩展 |

**Pipeline示例**:

```go
func pipeline() {
    // Stage 1: Generate
    gen := func() <-chan int {
        out := make(chan int)
        go func() {
            for i := 0; i < 10; i++ {
                out <- i
            }
            close(out)
        }()
        return out
    }
    
    // Stage 2: Square
    sq := func(in <-chan int) <-chan int {
        out := make(chan int)
        go func() {
            for n := range in {
                out <- n * n
            }
            close(out)
        }()
        return out
    }
    
    // Connect stages
    for n := range sq(gen()) {
        fmt.Println(n)
    }
}
```

**Worker Pool示例**:

```go
func workerPool(jobs <-chan Job, results chan<- Result) {
    var wg sync.WaitGroup
    
    // 创建workers
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for job := range jobs {
                results <- process(job)
            }
        }()
    }
    
    wg.Wait()
    close(results)
}
```

### 5.2 Fan-out vs Fan-in

| 维度 | Fan-out | Fan-in |
|------|---------|--------|
| **定义** | 一个输入，多个输出 | 多个输入，一个输出 |
| **数据流** | 1 → N | N → 1 |
| **目的** | 并行处理 | 结果汇总 |
| **Channel数** | 多个输出channel | 多个输入channel |
| **使用场景** | 任务分发 | 结果收集 |

**示例**:

```go
// Fan-out: 分发到多个worker
func fanOut(in <-chan int, workers int) []<-chan int {
    outs := make([]<-chan int, workers)
    for i := 0; i < workers; i++ {
        outs[i] = worker(in)
    }
    return outs
}

// Fan-in: 多个channel合并为一个
func fanIn(channels ...<-chan int) <-chan int {
    out := make(chan int)
    var wg sync.WaitGroup
    
    for _, ch := range channels {
        wg.Add(1)
        go func(c <-chan int) {
            defer wg.Done()
            for n := range c {
                out <- n
            }
        }(ch)
    }
    
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}
```

---

## 6. 与其他语言对比

### 6.1 Go vs Java 并发模型

| 维度 | Go | Java |
|------|----|----|
| **并发单元** | Goroutine（轻量级） | Thread（重量级） |
| **通信机制** | Channel（CSP） | 共享内存+锁 |
| **同步原语** | sync包、Channel | synchronized、Lock、Semaphore |
| **并发工具** | select、context | Executor、Future、CompletableFuture |
| **内存模型** | Happens-Before | Java Memory Model |
| **并发库** | 标准库内置 | java.util.concurrent |
| **学习曲线** | 平缓（简单原语） | 陡峭（复杂工具） |

### 6.2 Go vs Python 并发模型

| 维度 | Go | Python |
|------|----|----|
| **并发单元** | Goroutine | Thread/asyncio |
| **GIL** | 无GIL | 有GIL（限制并行） |
| **真并行** | 是 | 否（线程受GIL限制） |
| **异步模型** | 同步语法（goroutine） | async/await |
| **性能** | 高（真并行） | 低（GIL限制） |
| **使用复杂度** | 低（统一模型） | 中（多种模型） |

### 6.3 Go vs Rust 并发模型

| 维度 | Go | Rust |
|------|----|----|
| **安全保证** | 运行时检测 | 编译时保证 |
| **并发单元** | Goroutine | Thread/async tasks |
| **所有权** | GC管理 | 所有权系统 |
| **数据竞争** | 运行时检测（-race） | 编译时防止 |
| **易用性** | 高（简单） | 中（需理解所有权） |
| **性能** | 高 | 极高 |
| **学习曲线** | 平缓 | 陡峭 |

---

## 📊 总结对比表

### 核心机制选择指南

| 场景 | 推荐机制 | 备选机制 | 理由 |
|------|---------|---------|------|
| 大规模并发任务 | Goroutine | - | 轻量级，百万级 |
| goroutine间通信 | Channel | Mutex | 符合CSP，清晰 |
| 共享状态保护 | Mutex | Channel | 简单，性能好 |
| 读多写少 | RWMutex | atomic | 并发读 |
| 计数器/标志位 | atomic | Mutex | 性能最优 |
| 等待完成 | WaitGroup | Channel | 简单直接 |
| 主动取消 | Context | Channel | 标准做法 |
| 单次初始化 | sync.Once | init | 运行时控制 |
| 任务队列 | Channel | - | 天然队列 |
| 多路监听 | Select | - | Channel专用 |

---

## 🔗 相关文档

- [00-知识图谱.md](./00-知识图谱.md) - 知识结构
- [00-概念定义体系.md](./00-概念定义体系.md) - 形式化定义
- [README.md](./README.md) - 目录总览

---

**最后更新**: 2025-10-29  
**维护者**: Go形式化理论体系项目组

---

> **对比中理解并发机制，选择中掌握最佳实践** 📊  
> **Channel vs Mutex，通信vs共享** 💡
