# 概念定义体系

**版本**: v1.0
**更新日期**: 2025-11-11
**适用于**: Go 1.25.3
**文件夹**: fundamentals/language/02-并发编程
**类型**: 形式化概念定义

---

## 📋 目录

- [概念定义体系](#概念定义体系)
  - [📋 目录](#-目录)
  - [1. 核心概念清单](#1-核心概念清单)
    - [1.1 概念分类统计](#11-概念分类统计)
    - [1.2 概念清单](#12-概念清单)
  - [2. 概念形式化定义](#2-概念形式化定义)
    - [2.1 并发单元](#21-并发单元)
      - [概念C01: Goroutine](#概念c01-goroutine)
    - [2.2 通信机制](#22-通信机制)
      - [概念C03: Channel](#概念c03-channel)
      - [概念C04: Select](#概念c04-select)
    - [2.3 同步原语](#23-同步原语)
      - [概念C06: Mutex](#概念c06-mutex)
      - [概念C08: WaitGroup](#概念c08-waitgroup)
    - [2.4 控制机制](#24-控制机制)
      - [概念C05: Context](#概念c05-context)
    - [2.5 调度模型](#25-调度模型)
      - [概念C15: GMP模型](#概念c15-gmp模型)
  - [3. 概念关系图谱](#3-概念关系图谱)
    - [3.1 概念依赖图](#31-概念依赖图)
    - [3.2 概念分类图](#32-概念分类图)
  - [4. 概念层次结构](#4-概念层次结构)
    - [4.1 抽象层次](#41-抽象层次)
    - [4.2 学习层次建议](#42-学习层次建议)
  - [📊 使用指南](#-使用指南)
    - [如何使用本文档](#如何使用本文档)
  - [🔗 相关文档](#-相关文档)

---

## 1. 核心概念清单

### 1.1 概念分类统计

```text
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Go并发编程核心概念体系
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
第一层：并发单元     2个概念
第二层：通信机制     3个概念
第三层：同步原语     6个概念
第四层：控制机制     3个概念
第五层：调度模型     2个概念
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
总计: 16个核心概念
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

### 1.2 概念清单

| ID | 概念名称 | 英文 | 类别 | 重要度 |
|----|---------|------|------|--------|
| C01 | Goroutine | Goroutine | 并发单元 | ⭐⭐⭐⭐⭐ |
| C02 | 线程 | Thread | 并发单元 | ⭐⭐⭐⭐ |
| C03 | Channel | Channel | 通信机制 | ⭐⭐⭐⭐⭐ |
| C04 | Select | Select | 通信机制 | ⭐⭐⭐⭐⭐ |
| C05 | Context | Context | 通信机制 | ⭐⭐⭐⭐⭐ |
| C06 | Mutex | Mutex | 同步原语 | ⭐⭐⭐⭐⭐ |
| C07 | RWMutex | Read-Write Mutex | 同步原语 | ⭐⭐⭐⭐ |
| C08 | WaitGroup | WaitGroup | 同步原语 | ⭐⭐⭐⭐⭐ |
| C09 | Once | Once | 同步原语 | ⭐⭐⭐ |
| C10 | Cond | Condition Variable | 同步原语 | ⭐⭐⭐ |
| C11 | atomic | Atomic Operations | 同步原语 | ⭐⭐⭐⭐ |
| C12 | CSP模型 | CSP Model | 控制机制 | ⭐⭐⭐⭐⭐ |
| C13 | 并发模式 | Concurrency Patterns | 控制机制 | ⭐⭐⭐⭐ |
| C14 | 内存模型 | Memory Model | 控制机制 | ⭐⭐⭐⭐⭐ |
| C15 | GMP模型 | GMP Scheduler | 调度模型 | ⭐⭐⭐⭐⭐ |
| C16 | 抢占调度 | Preemption | 调度模型 | ⭐⭐⭐⭐ |

---

## 2. 概念形式化定义

### 2.1 并发单元

#### 概念C01: Goroutine

**形式化定义**:

```text
Goroutine ::= LightweightThread {
    Stack:      DynamicStack(2KB → 1GB),
    Scheduler:  GoScheduler,
    Cost:       O(2KB),
    Number:     O(10^6)
}

创建语法:
  go Expression

性质:
  • Lightweight: Stack << Thread.Stack
  • Cooperative: Yield at function calls
  • Managed: By Go runtime, not OS
```

**内涵（本质属性）**:

- Go运行时管理的轻量级执行单元
- 协作式调度，在特定点让出CPU
- 动态栈，按需增长（2KB起始）
- 独立的程序计数器和栈

**外延（范围边界）**:

- 包含：函数执行、栈空间、程序计数器
- 不包含：OS线程、独立地址空间

**关系（与其他概念）**:

- **对比关系**: Goroutine vs Thread（轻量级 vs 重量级）
- **依赖关系**: Goroutine → GMP调度器
- **通信关系**: Goroutine ←Channel→ Goroutine

**属性（特征描述）**:

- **创建成本**: `CreationCost = O(2KB)`
- **切换成本**: `SwitchCost = O(100ns)` (用户态)
- **数量上限**: `MaxCount = O(10^6)`
- **调度方式**: `Scheduling = Cooperative`
- **栈大小**: `Stack = Dynamic(2KB → 1GB)`

**形式化性质**:

```text
1. 轻量级特性:
   ∀g:Goroutine, Memory(g) << Memory(Thread)
   典型：2KB vs 1-2MB

2. 并发数量:
   可同时存在的goroutine数 >> 可同时存在的thread数
   实践中：goroutines ~ 10^6, threads ~ 10^3

3. 创建语义:
   go f(args) ⇒
     1. 创建新goroutine g
     2. 调度g执行f(args)
     3. 当前goroutine继续执行

4. 生命周期:
   Created → Running → Blocked/Waiting → Running → Dead
```

**示例**:

```go
// 创建goroutine
go func() {
    fmt.Println("Running in Goroutine")
}()

// 大量goroutine
for i := 0; i < 1000000; i++ {
    go process(i)  // 可创建百万级
}
```

---

### 2.2 通信机制

#### 概念C03: Channel

**形式化定义**:

```text
Channel ::= TypedQueue {
    Type:       T,
    Direction:  BiDir | SendOnly | RecvOnly,
    Buffer:     size ∈ [0, +∞),
    State:      Open | Closed
}

语法:
  Declaration:  Channel T | Channel<- T | <-Channel T
  Creation:     make(Channel T [, bufferSize])
  Send:         ch <- value
  Receive:      value := <-ch | <-ch
  Close:        close(ch)

CSP语义:
  Channel = Rendezvous(sender, receiver)
  Buffered = Mailbox(capacity)
```

**内涵（本质属性）**:

- 类型化的通信管道
- 实现goroutine间的同步通信
- 符合CSP模型的通信原语
- 先进先出（FIFO）队列语义

**外延（范围边界）**:

- 包含：数据队列、阻塞/唤醒机制、类型信息
- 不包含：数据转换、持久化存储

**关系（与其他概念）**:

- **对比关系**: Channel（通信）vs Mutex（共享）
- **依赖关系**: Channel → Goroutine（通信双方）
- **组合关系**: Select → Channel（多路复用）

**属性（特征描述）**:

- **类型**: `Type = T` (强类型)
- **方向**: `Direction = {BiDir, SendOnly, RecvOnly}`
- **缓冲**: `BufferSize ∈ [0, ∞)`
- **状态**: `State = {Open, Closed}`
- **语义**: `Semantics = FIFO Queue`

**形式化性质**:

```text
1. 类型安全:
   ∀ch:Channel T, ∀v, send(ch, v) ⇒ v:T
   receive(ch) : T

2. 缓冲语义:
   - 无缓冲 (size=0):
     send(ch, v) blocks until receive(ch)
     receive(ch) blocks until send(ch, v)

   - 缓冲 (size>0):
     send(ch, v) blocks if len(ch) = cap(ch)
     receive(ch) blocks if len(ch) = 0

3. 关闭语义:
   close(ch) ⇒
     1. 禁止再send (panic)
     2. receive返回零值和false
     3. range遍历终止

4. Happens-Before:
   send(ch, v) happens-before receive(ch) returns v
```

**示例**:

```go
// 无缓冲channel - 同步
ch := make(Channel int)
go func() {
    ch <- 42  // 阻塞直到被接收
}()
v := <-ch     // 接收

// 缓冲channel - 异步
ch := make(Channel int, 10)
ch <- 1       // 不阻塞（缓冲区未满）

// 单向channel
func send(ch Channel<- int) {
    ch <- 42
}

func receive(ch <-Channel int) {
    v := <-ch
}
```

---

#### 概念C04: Select

**形式化定义**:

```text
Select ::= MultiWayChoice {
    Cases:   []CaseClause,
    Default: Optional(DefaultClause)
}

CaseClause ::= case Communication : Statement

语法:
  select {
  case x := <-ch1:
      // handle ch1
  case ch2 <- y:
      // send to ch2
  default:
      // non-blocking
  }

语义:
  • 等待多个channel操作
  • 随机选择就绪的case
  • default实现非阻塞
```

**内涵（本质属性）**:

- Channel操作的多路复用器
- 同时等待多个channel操作
- 随机公平选择就绪操作
- 支持非阻塞操作（default）

**外延（范围边界）**:

- 包含：多个case、channel操作、default分支
- 不包含：值判断（那是switch）、循环

**关系（与其他概念）**:

- **对比关系**: Select（Channel）vs Switch（值）
- **依赖关系**: Select → Channel
- **组合关系**: Select + Context（取消控制）

**属性（特征描述）**:

- **操作对象**: `Operands = Channels`
- **选择策略**: `Strategy = Random (Fair)`
- **阻塞行为**: `Blocking = Until any case ready | has default`
- **执行保证**: `Execution = Exactly one case`

**形式化性质**:

```text
1. 多路选择:
   select {cases} ⇒
     Wait until ∃ case ready
     Execute one ready case (random if multiple)

2. 随机性（公平）:
   如果多个case同时就绪，随机选择一个
   避免饥饿

3. 非阻塞:
   select {cases + default} ⇒
     if no case ready: execute default immediately
     else: execute one ready case

4. 与channel交互:
   select可等待：
     - receive: case v := <-ch
     - send: case ch <- v
     - nil Channel: 永远阻塞
```

**示例**:

```go
// 基本select
select {
case msg := <-ch1:
    fmt.Println("ch1:", msg)
case msg := <-ch2:
    fmt.Println("ch2:", msg)
}

// 带超时
select {
case result := <-ch:
    return result
case <-time.After(time.Second):
    return errors.New("timeout")
}

// 非阻塞
select {
case msg := <-ch:
    fmt.Println(msg)
default:
    fmt.Println("no message")
}
```

---

### 2.3 同步原语

#### 概念C06: Mutex

**形式化定义**:

```text
Mutex ::= BinaryLock {
    State:   Unlocked | Locked,
    Waiter:  Queue<Goroutine>,
    Owner:   Optional<Goroutine>
}

操作:
  Lock():   Acquire exclusive access
  Unlock(): Release exclusive access

性质:
  • Mutual Exclusion: ∀t, ∃≤1 Goroutine in critical section
  • No Deadlock: Guaranteed progress (with proper usage)
```

**内涵（本质属性）**:

- Mutex，保证临界区互斥访问
- 二元状态：锁定/未锁定
- 阻塞等待：锁定时其他goroutine等待

**外延（范围边界）**:

- 包含：锁状态、等待队列、所有权信息
- 不包含：重入支持（Go mutex不可重入）

**关系（与其他概念）**:

- **对比关系**: Mutex vs RWMutex（不区分读写 vs 区分）
- **对比关系**: Mutex vs Channel（共享内存 vs 通信）
- **依赖关系**: Mutex → Goroutine（锁的持有者）

**属性（特征描述）**:

- **状态**: `State = {Unlocked, Locked}`
- **重入性**: `Reentrant = false`
- **公平性**: `Fairness = Unfair → Fair (Go 1.9+)`
- **阻塞**: `Blocking = true`

**形式化性质**:

```text
1. 互斥性:
   ∀t, |{g : g holds Mutex}| ≤ 1

2. 锁语义:
   Lock() ⇒
     if State = Unlocked: State := Locked, Owner := current
     else: Block until Unlocked

   Unlock() ⇒
     if Owner ≠ current: panic
     else: State := Unlocked, Wakeup one waiter

3. 临界区保护:
   mu.Lock()
   // Critical Section: Exclusive access guaranteed
   mu.Unlock()

4. Happens-Before:
   Unlock(mu) happens-before Lock(mu) returns
   (在同一个mutex的不同goroutine间)
```

**示例**:

```go
var (
    counter int
    mu      sync.Mutex
)

func increment() {
    mu.Lock()
    defer mu.Unlock()
    counter++  // 临界区
}

// ❌ 错误：重入死锁
func bad() {
    mu.Lock()
    defer mu.Unlock()
    increment()  // 死锁！
}
```

---

#### 概念C08: WaitGroup

**形式化定义**:

```text
WaitGroup ::= Counter {
    counter:  int,
    waiters:  []Goroutine,
    state:    Running | Waiting
}

操作:
  Add(delta):  counter += delta
  Done():      counter -= 1  (Add(-1))
  Wait():      block until counter = 0

约束:
  counter ≥ 0 (否则panic)
```

**内涵（本质属性）**:

- 等待一组goroutine完成的同步原语
- 计数器语义，完成时递减
- Wait阻塞直到计数器归零

**外延（范围边界）**:

- 包含：计数器、等待队列
- 不包含：取消机制（用Context）

**关系（与其他概念）**:

- **对比关系**: WaitGroup vs Context（等待完成 vs 主动取消）
- **组合关系**: WaitGroup + Context（完成等待 + 取消控制）

**属性（特征描述）**:

- **计数器**: `Counter ≥ 0`
- **操作**: `{Add, Done, Wait}`
- **阻塞**: `Wait() blocks until Counter = 0`
- **语义**: `Barrier for Goroutine completion`

**形式化性质**:

```text
1. 计数器不变式:
   counter ≥ 0 (否则panic)

2. Add语义:
   Add(delta) ⇒ counter := counter + delta
   要求：Add must happen-before Goroutine starts

3. Done语义:
   Done() ≡ Add(-1)

4. Wait语义:
   Wait() ⇒ block until counter = 0

5. 使用模式:
   wg.Add(n)           // before starting goroutines
   for i := 0; i < n; i++ {
       go func() {
           defer wg.Done()
           // work
       }()
   }
   wg.Wait()           // wait for all to complete
```

**示例**:

```go
var wg sync.WaitGroup

// 启动多个goroutine
for i := 0; i < 10; i++ {
    wg.Add(1)
    go func(id int) {
        defer wg.Done()
        process(id)
    }(i)
}

// 等待所有完成
wg.Wait()
fmt.Println("All done")
```

---

### 2.4 控制机制

#### 概念C05: Context

**形式化定义**:

```text
Context ::= ControlFlow {
    Done:       <-Channel struct{},
    Err:        error | nil,
    Deadline:   time.Time | nil,
    Value:      key -> value
}

类型:
  WithCancel:   (ctx, cancel) - 手动取消
  WithTimeout:  (ctx, cancel) - 超时取消
  WithDeadline: (ctx, cancel) - 截止时间取消
  WithValue:    ctx - 传递值

传播:
  Parent → Child (树形结构)
  取消信号向下传播
```

**内涵（本质属性）**:

- goroutine生命周期控制机制
- 树形传播的取消信号
- 携带截止时间和请求范围值
- 跨API边界传递

**外延（范围边界）**:

- 包含：取消信号、截止时间、键值对
- 不包含：数据传输（用Channel）、状态共享（用sync）

**关系（与其他概念）**:

- **组合关系**: Context + Goroutine（生命周期管理）
- **组合关系**: Context + Select（取消监听）
- **对比关系**: Context vs WaitGroup（主动取消 vs 被动等待）

**属性（特征描述）**:

- **结构**: `Structure = Tree`
- **传播**: `Propagation = Top-Down`
- **不可变**: `Immutable = true`
- **线程安全**: `ThreadSafe = true`

**形式化性质**:

```text
1. 树形结构:
   Context形成父子树
   Parent cancel ⇒ All children canceled

2. 取消传播:
   cancel(parent) ⇒ ∀child, child.Done() is closed

3. 不可变性:
   Context值不可修改
   WithValue创建新context

4. 使用模式:
   func operation(ctx Context.Context) error {
       select {
       case <-ctx.Done():
           return ctx.Err()  // Canceled or DeadlineExceeded
       case result := <-work():
           return nil
       }
   }

5. Happens-Before:
   cancel() happens-before <-ctx.Done() returns
```

**示例**:

```go
// WithCancel - 手动取消
ctx, cancel := context.WithCancel(context.Background())
defer cancel()

go func() {
    <-ctx.Done()
    fmt.Println("Canceled:", ctx.Err())
}()

cancel()  // 触发取消

// WithTimeout - 超时取消
ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
defer cancel()

select {
case <-time.After(3 * time.Second):
    fmt.Println("Work done")
case <-ctx.Done():
    fmt.Println("Timeout:", ctx.Err())
}

// WithValue - 传递值
ctx := context.WithValue(context.Background(), "userID", 42)
userID := ctx.Value("userID").(int)
```

---

### 2.5 调度模型

#### 概念C15: GMP模型

**形式化定义**:

```text
GMP ::= SchedulerModel {
    G: Goroutine,
    M: Machine (OS Thread),
    P: Processor (Scheduling Context)
}

关系:
  G: Logical Thread (millions)
  M: Physical Thread (~ GOMAXPROCS)
  P: Scheduling Context (= GOMAXPROCS)

调度:
  M ← P ← G
  M执行G，P提供调度上下文
  Work Stealing: P从其他P窃取G

结构:
  全局队列: Global Queue<G>
  本地队列: 每个P有 Local Queue<G>
  M队列:   等待G的M队列
```

**内涵（本质属性）**:

- Go运行时的三层调度模型
- G（Goroutine）被P（processor）调度到M（machine thread）上执行
- 工作窃取（work stealing）实现负载均衡
- 两级队列：全局队列+本地队列

**外延（范围边界）**:

- 包含：G/M/P三层、队列、调度算法
- 不包含：OS级别调度

**关系（与其他概念）**:

- **依赖关系**: Goroutine → GMP（调度基础）
- **关系**: G:M:P = N:M:M (N>>M)

**属性（特征描述）**:

- **G数量**: `NumG ~ 10^6`
- **M数量**: `NumM ~ GOMAXPROCS + blocking calls`
- **P数量**: `NumP = GOMAXPROCS`
- **调度策略**: `Strategy = {WorkStealing, Preemption}`

**形式化性质**:

```text
1. 三层模型:
   G: Goroutine (lightweight thread)
   M: Machine (OS thread)
   P: Processor (scheduling Context)

2. 绑定关系:
   M必须绑定P才能执行G
   M ← P ← G

3. 队列结构:
   GlobalQueue<G>: 全局队列
   LocalQueue<G>[P]: 每个P的本地队列
   优先本地队列，本地空时从全局或窃取

4. Work Stealing:
   if LocalQueue(P) is empty:
       1. Check GlobalQueue
       2. Steal from other P's LocalQueue
       3. Block (no work)

5. 调度时机:
   - 函数调用（协作式）
   - 系统调用
   - Channel操作
   - 抢占（Go 1.14+ async preemption）

6. GOMAXPROCS:
   设置P的数量，控制并行度
   默认 = CPU核心数
```

**示例**:

```go
// 设置GOMAXPROCS
import "runtime"

// 设置为CPU核心数
runtime.GOMAXPROCS(runtime.NumCPU())

// 获取当前设置
fmt.Println("GOMAXPROCS:", runtime.GOMAXPROCS(0))

// 查看goroutine数量
fmt.Println("NumGoroutine:", runtime.NumGoroutine())
```

---

## 3. 概念关系图谱

### 3.1 概念依赖图

```text
                 CSP模型 (理论基础)
                     │
          ┌──────────┼──────────┐
          │          │          │
     Goroutine   Channel    调度器(GMP)
          │          │          │
          │          │          │
      并发执行     通信机制    调度执行
          │          │          │
          └────┬─────┴────┬─────┘
               │          │
            Select    Context
               │          │
          多路复用   生命周期控制
               │          │
               └────┬─────┘
                    │
              并发模式（实战）
```

### 3.2 概念分类图

```text
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
            Go并发编程概念体系
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

理论层 (Theory)
├── CSP模型          [C12]
├── 内存模型        [C14]
└── GMP调度         [C15]

基础层 (Primitives)
├── Goroutine       [C01]
├── Channel         [C03]
└── Select          [C04]

同步层 (Synchronization)
├── Mutex           [C06]
├── RWMutex         [C07]
├── WaitGroup       [C08]
├── Once            [C09]
├── Cond            [C10]
└── atomic          [C11]

控制层 (Control)
├── Context         [C05]
└── 抢占调度        [C16]

应用层 (Patterns)
└── 并发模式        [C13]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

## 4. 概念层次结构

### 4.1 抽象层次

```text
层次 5: 并发模式        (Concurrency Patterns)
  ↑
层次 4: 控制机制        Context、Select、并发控制
  ↑
层次 3: 同步原语        Mutex、WaitGroup、atomic
  ↑
层次 2: 通信机制        Channel、Select
  ↑
层次 1: 并发单元        Goroutine
  ↑
层次 0: 理论基础        CSP、GMP、内存模型
```

### 4.2 学习层次建议

**第一阶段: 基础理论（层次0-1）**-

```text
掌握: CSP模型、Goroutine创建、基本概念
目标: 理解并发基础
时间: 1-2天
```

**第二阶段: 通信机制（层次2）**-

```text
掌握: Channel、Select、通信模式
目标: 掌握goroutine通信
时间: 3-5天
```

**第三阶段: 同步控制（层次3）**-

```text
掌握: Mutex、WaitGroup、sync包
目标: 掌握同步原语
时间: 3-5天
```

**第四阶段: 高级控制（层次4）**-

```text
掌握: Context、调度器、内存模型
目标: 深入理解并发机制
时间: 1周
```

**第五阶段: 实战模式（层次5）**-

```text
掌握: 并发模式、性能优化
目标: 编写高质量并发代码
时间: 2周+
```

---

## 📊 使用指南

### 如何使用本文档

**1. 理解概念**:

- 阅读形式化定义
- 理解内涵（本质是什么）
- 理解外延（范围边界）

**2. 建立联系**:

- 查看概念关系图谱
- 理解概念间的依赖和关联
- 构建完整的知识网络

**3. 实践应用**:

- 结合代码示例
- 理解形式化性质的实际含义
- 在实践中验证概念

**4. 系统学习**:

- 按照层次结构学习
- 先掌握基础层，再进阶
- 循序渐进，稳扎稳打

---

## 🔗 相关文档

### 核心文档

- [对比矩阵](./00-对比矩阵.md) - 并发编程系统对比
- [知识图谱](./00-知识图谱.md) - 并发编程知识体系
- [README](./README.md) - 并发编程总入口

### 相关主题

- [并发专题](../../../concurrency/) - 并发主题深入讲解
- [性能优化](../../../../advanced/performance/) - 并发性能优化

---

**上次更新**: 2025-12-03
**维护者**: Go Framework Team
