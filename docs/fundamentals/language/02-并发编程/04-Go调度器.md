# Goè°ƒåº¦å™¨ä¸G-P-Mæ¨¡å‹

> **ç®€ä»‹**: æ·±åº¦å‰–æGoè¿è¡Œæ—¶è°ƒåº¦å™¨çš„G-P-Mæ¨¡å‹ï¼Œç†è§£Goroutineè°ƒåº¦åŸç†å’Œæ€§èƒ½ä¼˜åŒ–
> **ç‰ˆæœ¬**: Go 1.23+  
> **éš¾åº¦**: â­â­â­â­  
> **æ ‡ç­¾**: #è°ƒåº¦å™¨ #GPMæ¨¡å‹ #è¿è¡Œæ—¶ #æ€§èƒ½ä¼˜åŒ–

<!-- TOC START -->
- [Goè°ƒåº¦å™¨ä¸G-P-Mæ¨¡å‹](#goè°ƒåº¦å™¨ä¸g-p-mæ¨¡å‹)
  - [1. ç†è®ºåŸºç¡€](#1-ç†è®ºåŸºç¡€)
    - [å½¢å¼åŒ–æè¿°](#å½¢å¼åŒ–æè¿°)
  - [2. æºç åˆ†æï¼ˆç®€è¦ï¼‰](#2-æºç åˆ†æç®€è¦)
  - [3. å·¥ç¨‹æ„ä¹‰ä¸æœ€ä½³å®è·µ](#3-å·¥ç¨‹æ„ä¹‰ä¸æœ€ä½³å®è·µ)
  - [4. å›¾ç¤º](#4-å›¾ç¤º)
  - [5. å‚è€ƒæ–‡çŒ®](#5-å‚è€ƒæ–‡çŒ®)
<!-- TOC END -->


## ğŸ“‹ ç›®å½•


- [1. ç†è®ºåŸºç¡€](#1-ç†è®ºåŸºç¡€)
  - [å½¢å¼åŒ–æè¿°](#å½¢å¼åŒ–æè¿°)
- [2. æºç åˆ†æï¼ˆç®€è¦ï¼‰](#2-æºç åˆ†æç®€è¦)
  - [è°ƒåº¦æ ¸å¿ƒæµç¨‹](#è°ƒåº¦æ ¸å¿ƒæµç¨‹)
  - [è°ƒåº¦å™¨å…³é”®æœºåˆ¶](#è°ƒåº¦å™¨å…³é”®æœºåˆ¶)
- [3. å·¥ç¨‹æ„ä¹‰ä¸æœ€ä½³å®è·µ](#3-å·¥ç¨‹æ„ä¹‰ä¸æœ€ä½³å®è·µ)
  - [GOMAXPROCSè°ƒä¼˜](#gomaxprocsè°ƒä¼˜)
  - [ç›‘æ§GoroutineçŠ¶æ€](#ç›‘æ§goroutineçŠ¶æ€)
  - [é¿å…Goroutineæ³„æ¼](#é¿å…goroutineæ³„æ¼)
  - [è°ƒåº¦å™¨æ€§èƒ½åˆ†æ](#è°ƒåº¦å™¨æ€§èƒ½åˆ†æ)
  - [æœ€ä½³å®è·µæ€»ç»“](#æœ€ä½³å®è·µæ€»ç»“)
- [4. å›¾ç¤º](#4-å›¾ç¤º)
- [5. å‚è€ƒæ–‡çŒ®](#5-å‚è€ƒæ–‡çŒ®)

## 1. ç†è®ºåŸºç¡€

Goè¿è¡Œæ—¶é‡‡ç”¨åä½œå¼è°ƒåº¦ï¼Œæ ¸å¿ƒæ˜¯Gï¼ˆGoroutineï¼‰ã€Pï¼ˆProcessorï¼‰ã€Mï¼ˆMachine/Threadï¼‰ä¸‰å…ƒç»„æ¨¡å‹ã€‚

- **Gï¼ˆGoroutineï¼‰**ï¼šç”¨æˆ·çº§è½»é‡çº¿ç¨‹ï¼ŒåŒ…å«æ ˆã€ä¸Šä¸‹æ–‡ç­‰ã€‚
- **Mï¼ˆMachineï¼‰**ï¼šæ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼Œè´Ÿè´£å®é™…æ‰§è¡Œã€‚
- **Pï¼ˆProcessorï¼‰**ï¼šè°ƒåº¦å™¨çš„æŠ½è±¡ï¼Œç®¡ç†å¯è¿è¡ŒGé˜Ÿåˆ—ï¼Œåˆ†é…ç»™Mã€‚

è°ƒåº¦æµç¨‹ï¼šGè¢«Pè°ƒåº¦ï¼ŒPç»‘å®šMï¼ŒMè´Ÿè´£æ‰§è¡ŒGã€‚Pçš„æ•°é‡ç”±GOMAXPROCSæ§åˆ¶ã€‚

### å½¢å¼åŒ–æè¿°

- $G = \{g_1, g_2, \ldots, g_n\}$
- $M = \{m_1, m_2, \ldots, m_k\}$
- $P = \{p_1, p_2, \ldots, p_p\}$
- $\text{è°ƒåº¦}: P_i \to M_j, G_x \in P_i.\text{runq}$

---

## 2. æºç åˆ†æï¼ˆç®€è¦ï¼‰

Goæºç ï¼ˆruntime/proc.goï¼‰æ ¸å¿ƒç»“æ„ä½“ï¼š

```go
// G - Goroutineç»“æ„ä½“ï¼ˆç®€åŒ–ç‰ˆï¼‰
type G struct {
    stack       stack   // æ ˆç©ºé—´
    stackguard0 uintptr // æ ˆä¿æŠ¤
    m           *M      // å½“å‰è¿è¡Œçš„M
    sched       gobuf   // è°ƒåº¦ä¸Šä¸‹æ–‡ï¼ˆå¯„å­˜å™¨ã€PCç­‰ï¼‰
    atomicstatus uint32 // GçŠ¶æ€ï¼š_Gidle/_Grunnable/_Grunning/_Gsyscall/_Gwaiting/_Gdead
}

// M - Machineï¼ˆOSçº¿ç¨‹ï¼‰ç»“æ„ä½“ï¼ˆç®€åŒ–ç‰ˆï¼‰
type M struct {
    g0      *G     // ç³»ç»Ÿæ ˆGoroutine
    curg    *G     // å½“å‰è¿è¡Œçš„G
    p       puintptr // ç»‘å®šçš„P
    nextp   puintptr // å³å°†ç»‘å®šçš„P
    spinning bool   // æ˜¯å¦å¤„äºè‡ªæ—‹çŠ¶æ€
}

// P - Processorï¼ˆé€»è¾‘å¤„ç†å™¨ï¼‰ç»“æ„ä½“ï¼ˆç®€åŒ–ç‰ˆï¼‰
type P struct {
    status  uint32  // PçŠ¶æ€ï¼š_Pidle/_Prunning/_Psyscall/_Pgcstop/_Pdead
    link    puintptr // ç©ºé—²Pé“¾è¡¨
    m       muintptr // ç»‘å®šçš„M
    runqhead uint32  // æœ¬åœ°runqå¤´
    runqtail uint32  // æœ¬åœ°runqå°¾
    runq     [256]guintptr // æœ¬åœ°å¯è¿è¡ŒGé˜Ÿåˆ—
    runnext  guintptr // ä¸‹ä¸€ä¸ªè¦è¿è¡Œçš„Gï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
}
```

### è°ƒåº¦æ ¸å¿ƒæµç¨‹

```go
// è°ƒåº¦ä¸»å¾ªç¯ï¼ˆç®€åŒ–ç‰ˆï¼‰
func schedule() {
top:
    // 1. æ¯è°ƒåº¦61æ¬¡ï¼Œä»å…¨å±€é˜Ÿåˆ—å–Gï¼Œä¿è¯å…¬å¹³æ€§
    if gp == nil && _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {
        lock(&sched.lock)
        gp = globrunqget(_g_.m.p.ptr(), 1)
        unlock(&sched.lock)
    }
    
    // 2. ä»Pæœ¬åœ°é˜Ÿåˆ—å–G
    if gp == nil {
        gp = runqget(_g_.m.p.ptr())
    }
    
    // 3. ä»å…¨å±€é˜Ÿåˆ—ã€netpollerã€å…¶ä»–På·å–G
    if gp == nil {
        gp, inheritTime = findrunnable() // é˜»å¡
    }
    
    // 4. æ‰§è¡ŒG
    execute(gp, inheritTime)
    goto top
}

// å·¥ä½œçªƒå–ï¼ˆWork Stealingï¼‰
func findrunnable() (gp *G, inheritTime bool) {
    // ... å°è¯•ä»å…¨å±€é˜Ÿåˆ—è·å– ...
    // ... å°è¯•ä»netpollerè·å–å°±ç»ªçš„ç½‘ç»œG ...
    
    // ä»å…¶ä»–På·å–Gï¼ˆéšæœºé€‰æ‹©Pï¼‰
    for i := 0; i < 4; i++ {
        for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {
            p2 := allp[enum.position()]
            if gp := runqsteal(_g_.m.p.ptr(), p2, stealRunNextG); gp != nil {
                return gp, false
            }
        }
    }
    // ... å…¶ä»–é€»è¾‘ ...
}
```

### è°ƒåº¦å™¨å…³é”®æœºåˆ¶

1. **æŠ¢å å¼è°ƒåº¦**ï¼ˆGo 1.14+ï¼‰ï¼š
   - åŸºäºä¿¡å·çš„å¼‚æ­¥æŠ¢å 
   - è§£å†³é•¿æ—¶é—´è¿è¡Œçš„Goroutineéœ¸å Pçš„é—®é¢˜

```go
// æŠ¢å æ£€æŸ¥ï¼ˆç¼–è¯‘å™¨åœ¨å‡½æ•°è°ƒç”¨æ—¶æ’å…¥ï¼‰
if stackguard0 == stackPreempt {
    // è§¦å‘æŠ¢å 
    gopreempt_m(gp)
}
```

2. **Sysmonç›‘æ§çº¿ç¨‹**ï¼š
   - ç‹¬ç«‹äºP-Mè¿è¡Œï¼Œè´Ÿè´£ï¼š
     - é‡Šæ”¾ç³»ç»Ÿè°ƒç”¨é˜»å¡è¶…è¿‡10msçš„P
     - æŠ¢å è¿è¡Œè¶…è¿‡10msçš„G
     - è§¦å‘å®šæ—¶GC

3. **ç½‘ç»œè½®è¯¢å™¨é›†æˆ**ï¼š
   - netpollerå°†ç½‘ç»œI/Oå°±ç»ªçš„Gæ”¾å…¥å¯è¿è¡Œé˜Ÿåˆ—
   - é¿å…é˜»å¡ç³»ç»Ÿçº¿ç¨‹

---

## 3. å·¥ç¨‹æ„ä¹‰ä¸æœ€ä½³å®è·µ

### GOMAXPROCSè°ƒä¼˜

```go
import (
    "fmt"
    "runtime"
)

func main() {
    // é»˜è®¤å€¼ä¸ºruntime.NumCPU()
    fmt.Println("Default GOMAXPROCS:", runtime.GOMAXPROCS(-1))
    
    // CPUå¯†é›†å‹ï¼šè®¾ç½®ä¸ºNumCPU()
    runtime.GOMAXPROCS(runtime.NumCPU())
    
    // I/Oå¯†é›†å‹ï¼šå¯é€‚å½“å¢åŠ ï¼ˆå®éªŒæ€§ï¼‰
    // runtime.GOMAXPROCS(runtime.NumCPU() * 2)
}
```

### ç›‘æ§GoroutineçŠ¶æ€

```go
import (
    "fmt"
    "runtime"
    "time"
)

func monitorGoroutines() {
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        fmt.Printf("Goroutines: %d\n", runtime.NumGoroutine())
        
        // æ£€æµ‹Goroutineæ³„æ¼
        if runtime.NumGoroutine() > 10000 {
            buf := make([]byte, 1<<16)
            stackSize := runtime.Stack(buf, true)
            fmt.Printf("Stack Trace:\n%s\n", buf[:stackSize])
        }
    }
}
```

### é¿å…Goroutineæ³„æ¼

```go
// é”™è¯¯ç¤ºä¾‹ï¼šchannelæœªå…³é—­å¯¼è‡´æ³„æ¼
func badExample() {
    ch := make(chan int)
    go func() {
        for v := range ch { // æ°¸è¿œé˜»å¡
            fmt.Println(v)
        }
    }()
    // å¿˜è®°close(ch)ï¼Œgoroutineæ³„æ¼
}

// æ­£ç¡®ç¤ºä¾‹ï¼šä½¿ç”¨contextæ§åˆ¶ç”Ÿå‘½å‘¨æœŸ
func goodExample(ctx context.Context) {
    ch := make(chan int)
    go func() {
        defer close(ch)
        for {
            select {
            case <-ctx.Done():
                return // åŠæ—¶é€€å‡º
            case v := <-ch:
                fmt.Println(v)
            }
        }
    }()
}
```

### è°ƒåº¦å™¨æ€§èƒ½åˆ†æ

```go
import (
    "runtime/trace"
    "os"
)

func main() {
    // å¼€å¯traceåˆ†æ
    f, _ := os.Create("trace.out")
    defer f.Close()
    trace.Start(f)
    defer trace.Stop()
    
    // ä¸šåŠ¡é€»è¾‘...
    
    // ä½¿ç”¨ go tool trace trace.out åˆ†æè°ƒåº¦è¡Œä¸º
}
```

### æœ€ä½³å®è·µæ€»ç»“

1. **åˆç†æ§åˆ¶Goroutineæ•°é‡**ï¼šä½¿ç”¨Worker Poolæ¨¡å¼
2. **é¿å…æ— ç¼“å†²channelæ­»é”**ï¼šä¼˜å…ˆä½¿ç”¨å¸¦ç¼“å†²channelæˆ–context
3. **CPUå¯†é›†å‹ä»»åŠ¡**ï¼šGOMAXPROCS=NumCPU()ï¼Œé¿å…è¿‡å¤šä¸Šä¸‹æ–‡åˆ‡æ¢
4. **I/Oå¯†é›†å‹ä»»åŠ¡**ï¼šGoroutineæ•°é‡å¯è¶…è¿‡æ ¸å¿ƒæ•°
5. **ç›‘æ§è°ƒåº¦å™¨çŠ¶æ€**ï¼šå®šæœŸæ£€æŸ¥NumGoroutine()ã€pprofã€trace

---

## 4. å›¾ç¤º

```mermaid
    G1["Goroutine"] -->|å…¥é˜Ÿ| P["Processor"]
    P -->|åˆ†é…| M["Machine(Thread)"]
    M -->|æ‰§è¡Œ| G1
```

---

## 5. å‚è€ƒæ–‡çŒ®

- Go runtimeæºç ï¼š<https://github.com/golang/go/tree/master/src/runtime>
- Goå®˜æ–¹åšå®¢ï¼šGo Scheduler: <https://blog.golang.org/scheduler>
- ã€ŠGoè¯­è¨€é«˜çº§ç¼–ç¨‹ã€‹

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ20æ—¥  
**æ–‡æ¡£çŠ¶æ€**: å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
