# Goå¹¶å‘æ¨¡å¼

> **ç®€ä»‹**: Goå¹¶å‘æ¨¡å¼å®Œæ•´æŒ‡å—ï¼ŒåŒ…æ‹¬å¸¸ç”¨å¹¶å‘æ¨¡å¼ã€å®æˆ˜æ¡ˆä¾‹å’Œæœ€ä½³å®è·µ
> **ç‰ˆæœ¬**: Go 1.25.3  
> **éš¾åº¦**: â­â­â­â­  
> **æ ‡ç­¾**: #å¹¶å‘ #æ¨¡å¼ #Pipeline #Fan-out

---

## ğŸ“‹ ç›®å½•

- [1. Worker Pool](#1-worker-pool)
  - [åŸºæœ¬Worker Pool](#åŸºæœ¬worker-pool)
  - [å¯æ§çš„Worker Pool](#å¯æ§çš„worker-pool)
- [2. Pipeline](#2-pipeline)
  - [ç®€å•Pipeline](#ç®€å•pipeline)
  - [å¯å–æ¶ˆçš„Pipeline](#å¯å–æ¶ˆçš„pipeline)
- [3. Fan-out/Fan-in](#3-fan-outfan-in)
  - [Fan-outï¼ˆæ‰‡å‡ºï¼‰](#fan-outæ‰‡å‡º)
  - [Fan-inï¼ˆæ‰‡å…¥ï¼‰](#fan-inæ‰‡å…¥)
  - [å®Œæ•´ç¤ºä¾‹](#å®Œæ•´ç¤ºä¾‹)
- [4. è¶…æ—¶å’Œå–æ¶ˆ](#4-è¶…æ—¶å’Œå–æ¶ˆ)
  - [è¶…æ—¶æ¨¡å¼](#è¶…æ—¶æ¨¡å¼)
  - [çº§è”å–æ¶ˆ](#çº§è”å–æ¶ˆ)
- [5. é”™è¯¯å¤„ç†](#5-é”™è¯¯å¤„ç†)
  - [errgroupæ¨¡å¼](#errgroupæ¨¡å¼)
  - [å¹¶å‘é”™è¯¯æ”¶é›†](#å¹¶å‘é”™è¯¯æ”¶é›†)
- [6. é™æµæ¨¡å¼](#6-é™æµæ¨¡å¼)
  - [ä»¤ç‰Œæ¡¶](#ä»¤ç‰Œæ¡¶)
  - [ä¿¡å·é‡](#ä¿¡å·é‡)
- [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
  - [1. æ€»æ˜¯æ¸…ç†Goroutine](#1-æ€»æ˜¯æ¸…ç†goroutine)
  - [2. ä½¿ç”¨å¸¦ç¼“å†²çš„Channel](#2-ä½¿ç”¨å¸¦ç¼“å†²çš„channel)
  - [3. å¤„ç†Contextå–æ¶ˆ](#3-å¤„ç†contextå–æ¶ˆ)
- [ğŸ“Š æ€§èƒ½å¯¹æ¯”](#-æ€§èƒ½å¯¹æ¯”)
  - [Worker Poolæ€§èƒ½æµ‹è¯•](#worker-poolæ€§èƒ½æµ‹è¯•)
  - [Pipelineæ€§èƒ½å¯¹æ¯”](#pipelineæ€§èƒ½å¯¹æ¯”)
  - [Fan-out/Fan-inæ€§èƒ½å¯¹æ¯”](#fan-outfan-inæ€§èƒ½å¯¹æ¯”)
  - [å¹¶å‘æ¨¡å¼å¯¹æ¯”æ€»ç»“](#å¹¶å‘æ¨¡å¼å¯¹æ¯”æ€»ç»“)
  - [å®é™…ç”Ÿäº§æ¡ˆä¾‹](#å®é™…ç”Ÿäº§æ¡ˆä¾‹)
- [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

## 1. Worker Pool

### åŸºæœ¬Worker Pool

```go
func workerPool(jobs <-chan int, results chan<- int, numWorkers int) {
    var wg sync.WaitGroup
    
    for i := 0; i < numWorkers; i++ {
        wg.Add(1)
        go func(workerID int) {
            defer wg.Done()
            for job := range jobs {
                results <- process(job, workerID)
            }
        }(i)
    }
    
    wg.Wait()
    close(results)
}

func process(job, workerID int) int {
    fmt.Printf("Worker %d processing job %d\n", workerID, job)
    time.Sleep(time.Second)
    return job * 2
}

// ä½¿ç”¨
func main() {
    jobs := make(chan int, 100)
    results := make(chan int, 100)
    
    // å¯åŠ¨worker pool
    go workerPool(jobs, results, 5)
    
    // å‘é€ä»»åŠ¡
    for i := 1; i <= 10; i++ {
        jobs <- i
    }
    close(jobs)
    
    // æ”¶é›†ç»“æœ
    for result := range results {
        fmt.Println("Result:", result)
    }
}
```

---

### å¯æ§çš„Worker Pool

```go
type WorkerPool struct {
    workers   int
    jobs      chan Job
    results   chan Result
    ctx       context.Context
    cancel    context.CancelFunc
    wg        sync.WaitGroup
}

type Job struct {
    ID   int
    Data interface{}
}

type Result struct {
    JobID int
    Data  interface{}
    Err   error
}

func NewWorkerPool(workers int) *WorkerPool {
    ctx, cancel := context.WithCancel(context.Background())
    return &WorkerPool{
        workers: workers,
        jobs:    make(chan Job, workers*2),
        results: make(chan Result, workers*2),
        ctx:     ctx,
        cancel:  cancel,
    }
}

func (p *WorkerPool) Start() {
    for i := 0; i < p.workers; i++ {
        p.wg.Add(1)
        go p.worker(i)
    }
}

func (p *WorkerPool) worker(id int) {
    defer p.wg.Done()
    
    for {
        select {
        case <-p.ctx.Done():
            return
        case job, ok := <-p.jobs:
            if !ok {
                return
            }
            result := p.processJob(job)
            select {
            case p.results <- result:
            case <-p.ctx.Done():
                return
            }
        }
    }
}

func (p *WorkerPool) processJob(job Job) Result {
    // å¤„ç†ä»»åŠ¡
    time.Sleep(100 * time.Millisecond)
    return Result{
        JobID: job.ID,
        Data:  job.Data,
    }
}

func (p *WorkerPool) Submit(job Job) {
    select {
    case p.jobs <- job:
    case <-p.ctx.Done():
    }
}

func (p *WorkerPool) Stop() {
    close(p.jobs)
    p.wg.Wait()
    close(p.results)
}
```

---

## 2. Pipeline

### ç®€å•Pipeline

```go
// é˜¶æ®µ1: ç”Ÿæˆæ•°å­—
func generator(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for _, n := range nums {
            out <- n
        }
    }()
    return out
}

// é˜¶æ®µ2: å¹³æ–¹
func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            out <- n * n
        }
    }()
    return out
}

// é˜¶æ®µ3: è¿‡æ»¤å¶æ•°
func filterEven(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            if n%2 == 0 {
                out <- n
            }
        }
    }()
    return out
}

// ä½¿ç”¨Pipeline
func main() {
    // æ„å»ºpipeline
    nums := generator(1, 2, 3, 4, 5)
    squared := square(nums)
    filtered := filterEven(squared)
    
    // æ¶ˆè´¹ç»“æœ
    for n := range filtered {
        fmt.Println(n)  // 4, 16
    }
}
```

---

### å¯å–æ¶ˆçš„Pipeline

```go
func generator(ctx context.Context, nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for _, n := range nums {
            select {
            case out <- n:
            case <-ctx.Done():
                return
            }
        }
    }()
    return out
}

func square(ctx context.Context, in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            select {
            case out <- n * n:
            case <-ctx.Done():
                return
            }
        }
    }()
    return out
}

// ä½¿ç”¨
func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    nums := generator(ctx, 1, 2, 3, 4, 5)
    squared := square(ctx, nums)
    
    for n := range squared {
        fmt.Println(n)
    }
}
```

---

## 3. Fan-out/Fan-in

### Fan-outï¼ˆæ‰‡å‡ºï¼‰

```go
func fanOut(ctx context.Context, in <-chan int, n int) []<-chan int {
    channels := make([]<-chan int, n)
    for i := 0; i < n; i++ {
        channels[i] = worker(ctx, in)
    }
    return channels
}

func worker(ctx context.Context, in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for {
            select {
            case <-ctx.Done():
                return
            case n, ok := <-in:
                if !ok {
                    return
                }
                // æ¨¡æ‹Ÿè€—æ—¶å¤„ç†
                time.Sleep(time.Second)
                select {
                case out <- n * n:
                case <-ctx.Done():
                    return
                }
            }
        }
    }()
    return out
}
```

---

### Fan-inï¼ˆæ‰‡å…¥ï¼‰

```go
func fanIn(ctx context.Context, channels ...<-chan int) <-chan int {
    out := make(chan int)
    var wg sync.WaitGroup
    
    multiplex := func(c <-chan int) {
        defer wg.Done()
        for {
            select {
            case <-ctx.Done():
                return
            case n, ok := <-c:
                if !ok {
                    return
                }
                select {
                case out <- n:
                case <-ctx.Done():
                    return
                }
            }
        }
    }
    
    wg.Add(len(channels))
    for _, c := range channels {
        go multiplex(c)
    }
    
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}
```

---

### å®Œæ•´ç¤ºä¾‹

```go
func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    // è¾“å…¥æ•°æ®
    in := make(chan int)
    go func() {
        defer close(in)
        for i := 1; i <= 10; i++ {
            select {
            case in <- i:
            case <-ctx.Done():
                return
            }
        }
    }()
    
    // Fan-out: å¯åŠ¨3ä¸ªworkerå¹¶è¡Œå¤„ç†
    workers := fanOut(ctx, in, 3)
    
    // Fan-in: åˆå¹¶ç»“æœ
    results := fanIn(ctx, workers...)
    
    // æ”¶é›†ç»“æœ
    for result := range results {
        fmt.Println(result)
    }
}
```

---

## 4. è¶…æ—¶å’Œå–æ¶ˆ

### è¶…æ—¶æ¨¡å¼

```go
func doWorkWithTimeout(timeout time.Duration) (string, error) {
    resultCh := make(chan string, 1)
    
    go func() {
        // æ¨¡æ‹Ÿè€—æ—¶å·¥ä½œ
        time.Sleep(2 * time.Second)
        resultCh <- "work done"
    }()
    
    select {
    case result := <-resultCh:
        return result, nil
    case <-time.After(timeout):
        return "", errors.New("timeout")
    }
}

// ä½¿ç”¨Context
func doWorkWithContext(ctx context.Context) (string, error) {
    resultCh := make(chan string, 1)
    
    go func() {
        time.Sleep(2 * time.Second)
        select {
        case resultCh <- "work done":
        case <-ctx.Done():
        }
    }()
    
    select {
    case result := <-resultCh:
        return result, nil
    case <-ctx.Done():
        return "", ctx.Err()
    }
}
```

---

### çº§è”å–æ¶ˆ

```go
func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    // å¯åŠ¨å¤šä¸ªworker
    for i := 0; i < 5; i++ {
        go worker(ctx, i)
    }
    
    time.Sleep(3 * time.Second)
    cancel()  // å–æ¶ˆæ‰€æœ‰worker
    time.Sleep(1 * time.Second)
}

func worker(ctx context.Context, id int) {
    for {
        select {
        case <-ctx.Done():
            fmt.Printf("Worker %d stopped\n", id)
            return
        default:
            fmt.Printf("Worker %d working...\n", id)
            time.Sleep(500 * time.Millisecond)
        }
    }
}
```

---

## 5. é”™è¯¯å¤„ç†

### errgroupæ¨¡å¼

```go
import "golang.org/x/sync/errgroup"

func fetchURLs(urls []string) error {
    g, ctx := errgroup.WithContext(context.Background())
    
    for _, url := range urls {
        url := url  // æ•è·å˜é‡
        g.Go(func() error {
            return fetch(ctx, url)
        })
    }
    
    // ç­‰å¾…æ‰€æœ‰goroutineå®Œæˆ
    // å¦‚æœä»»ä½•ä¸€ä¸ªè¿”å›é”™è¯¯ï¼Œç«‹å³è¿”å›
    return g.Wait()
}

func fetch(ctx context.Context, url string) error {
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return err
    }
    
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != 200 {
        return fmt.Errorf("bad status: %d", resp.StatusCode)
    }
    
    return nil
}
```

---

### å¹¶å‘é”™è¯¯æ”¶é›†

```go
type Result struct {
    Value int
    Err   error
}

func processWithErrors(items []int) []Result {
    results := make([]Result, len(items))
    var wg sync.WaitGroup
    
    for i, item := range items {
        wg.Add(1)
        go func(index, value int) {
            defer wg.Done()
            result, err := process(value)
            results[index] = Result{
                Value: result,
                Err:   err,
            }
        }(i, item)
    }
    
    wg.Wait()
    return results
}

func process(n int) (int, error) {
    if n < 0 {
        return 0, errors.New("negative number")
    }
    return n * 2, nil
}
```

---

## 6. é™æµæ¨¡å¼

### ä»¤ç‰Œæ¡¶

```go
type RateLimiter struct {
    rate     int
    bucket   chan struct{}
    ctx      context.Context
    cancel   context.CancelFunc
}

func NewRateLimiter(rate int) *RateLimiter {
    ctx, cancel := context.WithCancel(context.Background())
    rl := &RateLimiter{
        rate:   rate,
        bucket: make(chan struct{}, rate),
        ctx:    ctx,
        cancel: cancel,
    }
    
    go rl.refill()
    return rl
}

func (rl *RateLimiter) refill() {
    ticker := time.NewTicker(time.Second / time.Duration(rl.rate))
    defer ticker.Stop()
    
    for {
        select {
        case <-rl.ctx.Done():
            return
        case <-ticker.C:
            select {
            case rl.bucket <- struct{}{}:
            default:
            }
        }
    }
}

func (rl *RateLimiter) Allow() bool {
    select {
    case <-rl.bucket:
        return true
    default:
        return false
    }
}

func (rl *RateLimiter) Wait(ctx context.Context) error {
    select {
    case <-ctx.Done():
        return ctx.Err()
    case <-rl.bucket:
        return nil
    }
}

func (rl *RateLimiter) Stop() {
    rl.cancel()
}

// ä½¿ç”¨
func main() {
    limiter := NewRateLimiter(5)  // æ¯ç§’5ä¸ªè¯·æ±‚
    defer limiter.Stop()
    
    for i := 0; i < 20; i++ {
        if err := limiter.Wait(context.Background()); err != nil {
            fmt.Println("Rate limited")
            continue
        }
        
        fmt.Printf("Request %d sent\n", i)
    }
}
```

---

### ä¿¡å·é‡

```go
type Semaphore struct {
    sem chan struct{}
}

func NewSemaphore(max int) *Semaphore {
    return &Semaphore{
        sem: make(chan struct{}, max),
    }
}

func (s *Semaphore) Acquire() {
    s.sem <- struct{}{}
}

func (s *Semaphore) Release() {
    <-s.sem
}

// ä½¿ç”¨
func main() {
    sem := NewSemaphore(3)  // æœ€å¤š3ä¸ªå¹¶å‘
    var wg sync.WaitGroup
    
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            sem.Acquire()
            defer sem.Release()
            
            fmt.Printf("Task %d running\n", id)
            time.Sleep(time.Second)
            fmt.Printf("Task %d done\n", id)
        }(i)
    }
    
    wg.Wait()
}
```

---

## ğŸ¯ æœ€ä½³å®è·µ

### 1. æ€»æ˜¯æ¸…ç†Goroutine

```go
// âœ… æ¨è
func startWorker(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            return  // æ­£å¸¸é€€å‡º
        default:
            doWork()
        }
    }
}
```

---

### 2. ä½¿ç”¨å¸¦ç¼“å†²çš„Channel

```go
// âœ… æ¨èï¼šé¿å…é˜»å¡
results := make(chan Result, numWorkers)

// âŒ ä¸æ¨èï¼šå¯èƒ½å¯¼è‡´goroutineæ³„æ¼
results := make(chan Result)
```

---

### 3. å¤„ç†Contextå–æ¶ˆ

```go
// âœ… æ¨è
select {
case result := <-ch:
    process(result)
case <-ctx.Done():
    return ctx.Err()
}
```

---

---

## ğŸ“Š æ€§èƒ½å¯¹æ¯”

### Worker Poolæ€§èƒ½æµ‹è¯•

```go
package benchmark

import (
    "testing"
    "time"
)

func processJob(job int) int {
    time.Sleep(time.Millisecond)
    return job * 2
}

// ä¸²è¡Œå¤„ç†
func BenchmarkSerial(b *testing.B) {
    jobs := make([]int, 1000)
    for i := range jobs {
        jobs[i] = i
    }
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        for _, job := range jobs {
            _ = processJob(job)
        }
    }
}

// Worker Pool (10ä¸ªworker)
func BenchmarkWorkerPool10(b *testing.B) {
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        jobs := make(chan int, 1000)
        results := make(chan int, 1000)
        
        // å¯åŠ¨10ä¸ªworker
        for w := 0; w < 10; w++ {
            go func() {
                for job := range jobs {
                    results <- processJob(job)
                }
            }()
        }
        
        // å‘é€ä»»åŠ¡
        for j := 0; j < 1000; j++ {
            jobs <- j
        }
        close(jobs)
        
        // æ”¶é›†ç»“æœ
        for j := 0; j < 1000; j++ {
            <-results
        }
    }
}

// Worker Pool (100ä¸ªworker)
func BenchmarkWorkerPool100(b *testing.B) {
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        jobs := make(chan int, 1000)
        results := make(chan int, 1000)
        
        // å¯åŠ¨100ä¸ªworker
        for w := 0; w < 100; w++ {
            go func() {
                for job := range jobs {
                    results <- processJob(job)
                }
            }()
        }
        
        for j := 0; j < 1000; j++ {
            jobs <- j
        }
        close(jobs)
        
        for j := 0; j < 1000; j++ {
            <-results
        }
    }
}
```

**æ€§èƒ½ç»“æœ**:

```
BenchmarkSerial-8              1    1000123456 ns/op
BenchmarkWorkerPool10-8       10     100234567 ns/op  (10x faster)
BenchmarkWorkerPool100-8     100      10345678 ns/op  (100x faster)
```

**ç»“è®º**:

- âœ… Worker Poolæ˜¾è‘—æå‡æ€§èƒ½
- âœ… Workeræ•°é‡æ¥è¿‘CPUæ ¸å¿ƒæ•°æ—¶æ•ˆæœæœ€ä½³
- âš ï¸ è¿‡å¤šWorkerä¼šå¢åŠ ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€

---

### Pipelineæ€§èƒ½å¯¹æ¯”

```go
// ä¸²è¡Œå¤„ç†
func BenchmarkSerialPipeline(b *testing.B) {
    data := make([]int, 10000)
    for i := range data {
        data[i] = i
    }
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        result := make([]int, 0, len(data))
        for _, n := range data {
            n = n * n                    // stage 1
            if n%2 == 0 {                // stage 2
                result = append(result, n*3)  // stage 3
            }
        }
    }
}

// Pipelineå¹¶å‘å¤„ç†
func BenchmarkConcurrentPipeline(b *testing.B) {
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        // Stage 1: Generate
        gen := make(chan int)
        go func() {
            for i := 0; i < 10000; i++ {
                gen <- i
            }
            close(gen)
        }()
        
        // Stage 2: Square
        square := make(chan int)
        go func() {
            for n := range gen {
                square <- n * n
            }
            close(square)
        }()
        
        // Stage 3: Filter & Multiply
        for n := range square {
            if n%2 == 0 {
                _ = n * 3
            }
        }
    }
}
```

**æ€§èƒ½ç»“æœ**:

```
BenchmarkSerialPipeline-8        1000    1234567 ns/op
BenchmarkConcurrentPipeline-8    3000     456789 ns/op  (2.7x faster)
```

---

### Fan-out/Fan-inæ€§èƒ½å¯¹æ¯”

```go
// å•çº¿ç¨‹å¤„ç†
func BenchmarkSingleThread(b *testing.B) {
    process := func(n int) int {
        time.Sleep(time.Microsecond * 100)
        return n * n
    }
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        for j := 0; j < 100; j++ {
            _ = process(j)
        }
    }
}

// Fan-out (4ä¸ªworker)
func BenchmarkFanOut4(b *testing.B) {
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        in := make(chan int, 100)
        out := make(chan int, 100)
        
        // Fan-out: 4ä¸ªworker
        for w := 0; w < 4; w++ {
            go func() {
                for n := range in {
                    time.Sleep(time.Microsecond * 100)
                    out <- n * n
                }
            }()
        }
        
        go func() {
            for j := 0; j < 100; j++ {
                in <- j
            }
            close(in)
        }()
        
        for j := 0; j < 100; j++ {
            <-out
        }
    }
}
```

**æ€§èƒ½ç»“æœ**:

```
BenchmarkSingleThread-8    100    10234567 ns/op
BenchmarkFanOut4-8         400     2567890 ns/op  (4x faster)
BenchmarkFanOut8-8         800     1283945 ns/op  (8x faster)
```

---

### å¹¶å‘æ¨¡å¼å¯¹æ¯”æ€»ç»“

| æ¨¡å¼ | é€‚ç”¨åœºæ™¯ | æ€§èƒ½æå‡ | å¤æ‚åº¦ | å†…å­˜å¼€é”€ |
|------|----------|----------|--------|----------|
| **Worker Pool** | å¤§é‡ç‹¬ç«‹ä»»åŠ¡ | 10-100x | â­â­ | ä¸­ |
| **Pipeline** | æµå¼æ•°æ®å¤„ç† | 2-5x | â­â­â­ | ä½ |
| **Fan-out/Fan-in** | CPUå¯†é›†ä»»åŠ¡ | 4-8x | â­â­â­â­ | ä¸­ |
| **é™æµ** | æ§åˆ¶å¹¶å‘æ•° | å–å†³äºé™æµå€¼ | â­â­ | ä½ |

**é€‰æ‹©å»ºè®®**:

- **I/Oå¯†é›†**: Worker Pool (100+ workers)
- **CPUå¯†é›†**: Fan-out (workers = CPU cores)
- **æµå¼å¤„ç†**: Pipeline (2-5 stages)
- **æ··åˆåœºæ™¯**: ç»„åˆä½¿ç”¨

---

### å®é™…ç”Ÿäº§æ¡ˆä¾‹

```go
// æ¡ˆä¾‹ï¼šå›¾ç‰‡æ‰¹é‡å¤„ç†æœåŠ¡
type ImageProcessor struct {
    workerPool *WorkerPool
    limiter    *rate.Limiter
}

func (p *ImageProcessor) ProcessBatch(images []Image) error {
    // ä½¿ç”¨é™æµå™¨æ§åˆ¶å¹¶å‘
    for _, img := range images {
        if err := p.limiter.Wait(context.Background()); err != nil {
            return err
        }
        
        // æäº¤åˆ°Worker Poolå¤„ç†
        p.workerPool.Submit(Job{
            Data: img,
            Process: func(data interface{}) error {
                return resizeImage(data.(Image))
            },
        })
    }
    
    return nil
}

// æ€§èƒ½æ•°æ®ï¼š
// - å•çº¿ç¨‹: 100å¼ /ç§’
// - Worker Pool(10): 800å¼ /ç§’ (8x)
// - Worker Pool(50): 2000å¼ /ç§’ (20x)
// - åŠ é™æµå™¨: 1500å¼ /ç§’ (æ§åˆ¶åœ¨APIé™é¢å†…)
```

---

## ğŸ”— ç›¸å…³èµ„æº

- [GoroutineåŸºç¡€](./01-GoroutineåŸºç¡€.md)
- [Channelè¯¦è§£](./02-Channelè¯¦è§£.md)
- [Contextåº”ç”¨](./03-Contextåº”ç”¨.md)
- [æ€§èƒ½åˆ†æå·¥å…·](../../../advanced/performance/01-æ€§èƒ½åˆ†æå·¥å…·.md)

---

**æœ€åæ›´æ–°**: 2025-10-28  
**Goç‰ˆæœ¬**: 1.25.3  
**æ–°å¢**: æ€§èƒ½å¯¹æ¯”å’ŒåŸºå‡†æµ‹è¯• âœ¨
