# Go 1.25.3 ç±»å‹ç³»ç»Ÿé«˜çº§ç‰¹æ€§ä¸ç†è®ºæ‰©å±•

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**åŸºå‡†æ—¥æœŸ**: 2025å¹´10æœˆ23æ—¥  
**Goç‰ˆæœ¬**: Go 1.25.3  
**ç†è®ºåŸºç¡€**: System F<: + Dependent Types + Effect Systems  
**å­—æ•°**: ~18,000å­—

---

## ğŸ“‹ ç›®å½•

- [ç¬¬ä¸€éƒ¨åˆ†: é«˜çº§ç±»å‹æ¨æ–­](#ç¬¬ä¸€éƒ¨åˆ†-é«˜çº§ç±»å‹æ¨æ–­)
  - [1.1 å…¨å±€ç±»å‹æ¨æ–­](#11-å…¨å±€ç±»å‹æ¨æ–­)
    - [ç±»å‹æ¨æ–­ç®—æ³•å½¢å¼åŒ–](#ç±»å‹æ¨æ–­ç®—æ³•å½¢å¼åŒ–)
    - [æ³›å‹å‡½æ•°æ¨æ–­](#æ³›å‹å‡½æ•°æ¨æ–­)
  - [1.2 åŒå‘ç±»å‹æ£€æŸ¥](#12-åŒå‘ç±»å‹æ£€æŸ¥)
    - [Go ä»£ç ç¤ºä¾‹](#go-ä»£ç ç¤ºä¾‹)
  - [1.3 çº¦æŸæ±‚è§£ç®—æ³•](#13-çº¦æŸæ±‚è§£ç®—æ³•)
    - [çº¦æŸç”Ÿæˆ](#çº¦æŸç”Ÿæˆ)
    - [Go æ³›å‹çº¦æŸå®ä¾‹](#go-æ³›å‹çº¦æŸå®ä¾‹)
- [ç¬¬äºŒéƒ¨åˆ†: æ³›å‹ç±»å‹ç³»ç»Ÿæ·±åŒ–](#ç¬¬äºŒéƒ¨åˆ†-æ³›å‹ç±»å‹ç³»ç»Ÿæ·±åŒ–)
  - [2.1 é«˜é˜¶ç±»å‹å‚æ•°](#21-é«˜é˜¶ç±»å‹å‚æ•°)
    - [å½¢å¼åŒ–è¡¨ç¤º](#å½¢å¼åŒ–è¡¨ç¤º)
  - [2.2 ç±»å‹æ—ä¸å…³è”ç±»å‹](#22-ç±»å‹æ—ä¸å…³è”ç±»å‹)
  - [2.3 å˜å‹ä¸åå˜æ€§](#23-å˜å‹ä¸åå˜æ€§)
    - [ç±»å‹å˜å‹ç†è®º](#ç±»å‹å˜å‹ç†è®º)
    - [Go ä»£ç ç¤ºä¾‹1](#go-ä»£ç ç¤ºä¾‹1)
- [ç¬¬ä¸‰éƒ¨åˆ†: æ•ˆåº”ç³»ç»Ÿ](#ç¬¬ä¸‰éƒ¨åˆ†-æ•ˆåº”ç³»ç»Ÿ)
  - [3.1 å‰¯ä½œç”¨è¿½è¸ª](#31-å‰¯ä½œç”¨è¿½è¸ª)
    - [å½¢å¼åŒ–æ•ˆåº”ç³»ç»Ÿ](#å½¢å¼åŒ–æ•ˆåº”ç³»ç»Ÿ)
  - [3.2 èµ„æºç®¡ç†](#32-èµ„æºç®¡ç†)
  - [3.3 é”™è¯¯æ•ˆåº”](#33-é”™è¯¯æ•ˆåº”)
- [ç¬¬å››éƒ¨åˆ†: ä¾èµ–ç±»å‹ç‰¹æ€§](#ç¬¬å››éƒ¨åˆ†-ä¾èµ–ç±»å‹ç‰¹æ€§)
  - [4.1 é•¿åº¦ç´¢å¼•ç±»å‹](#41-é•¿åº¦ç´¢å¼•ç±»å‹)
    - [å½¢å¼åŒ–è¡¨ç¤º1](#å½¢å¼åŒ–è¡¨ç¤º1)
  - [4.2 çŠ¶æ€ä¾èµ–ç±»å‹](#42-çŠ¶æ€ä¾èµ–ç±»å‹)
  - [4.3 ç²¾ç‚¼ç±»å‹](#43-ç²¾ç‚¼ç±»å‹)
- [ç¬¬äº”éƒ¨åˆ†: å®ç”¨ç±»å‹æ¨¡å¼](#ç¬¬äº”éƒ¨åˆ†-å®ç”¨ç±»å‹æ¨¡å¼)
  - [5.1 ç±»å‹çº§ç¼–ç¨‹](#51-ç±»å‹çº§ç¼–ç¨‹)
  - [5.2 å¹»è±¡ç±»å‹](#52-å¹»è±¡ç±»å‹)
  - [5.3 ç±»å‹è§è¯](#53-ç±»å‹è§è¯)
- [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
  - [æ ¸å¿ƒè´¡çŒ®](#æ ¸å¿ƒè´¡çŒ®)
  - [ç†è®ºä»·å€¼](#ç†è®ºä»·å€¼)
  - [å·¥ç¨‹ä»·å€¼](#å·¥ç¨‹ä»·å€¼)

## ç¬¬ä¸€éƒ¨åˆ†: é«˜çº§ç±»å‹æ¨æ–­

### 1.1 å…¨å±€ç±»å‹æ¨æ–­

Go 1.25.3 çš„ç±»å‹æ¨æ–­ç³»ç»ŸåŸºäº **Hindley-Milner** ç®—æ³•çš„æ‰©å±•ï¼Œæ”¯æŒå…¨å±€ç±»å‹æ¨æ–­ã€‚

#### ç±»å‹æ¨æ–­ç®—æ³•å½¢å¼åŒ–

```mathematical
/* Algorithm W: ç±»å‹æ¨æ–­ä¸»ç®—æ³• */

W: Î“ Ã— Expr â†’ (Substitution Ã— Type)

/* ç®—æ³•å®šä¹‰ */

W(Î“, x) = 
    if x : Ï„ âˆˆ Î“ then
        return (id, instantiate(Ï„))
    else
        error "unbound variable"

W(Î“, Î»x.e) = 
    Î± = fresh()
    (Sâ‚, Ï„â‚) = W(Î“[x â†¦ Î±], e)
    return (Sâ‚, Sâ‚(Î±) â†’ Ï„â‚)

W(Î“, eâ‚ eâ‚‚) = 
    (Sâ‚, Ï„â‚) = W(Î“, eâ‚)
    (Sâ‚‚, Ï„â‚‚) = W(Sâ‚(Î“), eâ‚‚)
    Î± = fresh()
    Sâ‚ƒ = unify(Sâ‚‚(Ï„â‚), Ï„â‚‚ â†’ Î±)
    return (Sâ‚ƒ âˆ˜ Sâ‚‚ âˆ˜ Sâ‚, Sâ‚ƒ(Î±))

W(Î“, let x = eâ‚ in eâ‚‚) = 
    (Sâ‚, Ï„â‚) = W(Î“, eâ‚)
    Ï„' = generalize(Sâ‚(Î“), Ï„â‚)
    (Sâ‚‚, Ï„â‚‚) = W(Sâ‚(Î“)[x â†¦ Ï„'], eâ‚‚)
    return (Sâ‚‚ âˆ˜ Sâ‚, Ï„â‚‚)
```

#### æ³›å‹å‡½æ•°æ¨æ–­

```go
// æ³›å‹å‡½æ•°å®šä¹‰
func Map[T, U any](slice []T, f func(T) U) []U {
    result := make([]U, len(slice))
    for i, v := range slice {
        result[i] = f(v)
    }
    return result
}

// ç±»å‹æ¨æ–­è¿‡ç¨‹å½¢å¼åŒ–
/*
è°ƒç”¨: Map([]int{1,2,3}, strconv.Itoa)

æ¨æ–­æ­¥éª¤:
1. slice : []int âŸ¹ T = int
2. f : func(T) U âŸ¹ f : func(int) string
3. U = string
4. è¿”å›ç±»å‹: []string

å½¢å¼åŒ–è¡¨ç¤º:
Î“ âŠ¢ slice : []int
Î“ âŠ¢ f : int â†’ string
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Map(slice, f) : []string
     with [T â†¦ int, U â†¦ string]
*/
```

### 1.2 åŒå‘ç±»å‹æ£€æŸ¥

Go 1.25.3 é‡‡ç”¨**åŒå‘ç±»å‹æ£€æŸ¥** (Bidirectional Type Checking) æé«˜æ¨æ–­æ•ˆç‡ã€‚

```mathematical
/* åŒå‘ç±»å‹æ£€æŸ¥ç³»ç»Ÿ */

/* æ£€æŸ¥æ¨¡å¼ (Checking Mode) */
Î“ âŠ¢ e â‡ Ï„    /* æ£€æŸ¥è¡¨è¾¾å¼eæ˜¯å¦å…·æœ‰ç±»å‹Ï„ */

/* æ¨æ–­æ¨¡å¼ (Inference Mode) */
Î“ âŠ¢ e â‡’ Ï„    /* æ¨æ–­è¡¨è¾¾å¼eçš„ç±»å‹ä¸ºÏ„ */

/* è§„åˆ™ç¤ºä¾‹ */

[Check-Lambda]
Î“, x : Ï„â‚ âŠ¢ e â‡ Ï„â‚‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Î»x.e â‡ Ï„â‚ â†’ Ï„â‚‚

[Infer-App]
Î“ âŠ¢ eâ‚ â‡’ Ï„â‚ â†’ Ï„â‚‚    Î“ âŠ¢ eâ‚‚ â‡ Ï„â‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ eâ‚ eâ‚‚ â‡’ Ï„â‚‚

[Switch]
Î“ âŠ¢ e â‡’ Ï„'    Ï„' â‰¤ Ï„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ e â‡ Ï„
```

#### Go ä»£ç ç¤ºä¾‹

```go
// åŒå‘ç±»å‹æ£€æŸ¥å®ä¾‹

// æ¨æ–­æ¨¡å¼: è‡ªåŠ¨æ¨æ–­ç±»å‹
numbers := []int{1, 2, 3}  // â‡’ []int

// æ£€æŸ¥æ¨¡å¼: æ£€æŸ¥æ˜¯å¦ç¬¦åˆæŒ‡å®šç±»å‹
var result []string = Map(numbers, strconv.Itoa)  // â‡ []string

// æ··åˆæ¨¡å¼
func Process[T any](data []T) {
    // æ¨æ–­: dataçš„ç±»å‹ä»å‚æ•°æ¨æ–­
    for _, item := range data {  // item â‡’ T
        // æ£€æŸ¥: itemå¿…é¡»æ»¡è¶³æŸäº›æ“ä½œ
        fmt.Println(item)  // æ£€æŸ¥Tæ˜¯å¦æœ‰Stringæ–¹æ³•
    }
}
```

### 1.3 çº¦æŸæ±‚è§£ç®—æ³•

#### çº¦æŸç”Ÿæˆ

```mathematical
/* çº¦æŸç³»ç»Ÿ */

Constraint C ::= Ï„â‚ = Ï„â‚‚              /* ç­‰å¼çº¦æŸ */
               | Ï„â‚ â‰¤ Ï„â‚‚              /* å­ç±»å‹çº¦æŸ */
               | Ï„ : Constraint       /* ç±»å‹çº¦æŸ (Go 1.18+) */
               | âˆƒÎ±. C                /* å­˜åœ¨é‡åŒ– */
               | Câ‚ âˆ§ Câ‚‚              /* åˆå– */

/* çº¦æŸç”Ÿæˆè§„åˆ™ */

gen(Î“, x) = 
    if x : âˆ€á¾±.C â‡’ Ï„ âˆˆ Î“ then
        Î²Ì„ = fresh_vars(|á¾±|)
        return ([Î²Ì„/á¾±]C, [Î²Ì„/á¾±]Ï„)
    else error

gen(Î“, eâ‚ eâ‚‚) = 
    (Câ‚, Ï„â‚) = gen(Î“, eâ‚)
    (Câ‚‚, Ï„â‚‚) = gen(Î“, eâ‚‚)
    Î± = fresh()
    return (Câ‚ âˆ§ Câ‚‚ âˆ§ (Ï„â‚ = Ï„â‚‚ â†’ Î±), Î±)
```

#### Go æ³›å‹çº¦æŸå®ä¾‹

```go
// å¤æ‚çº¦æŸç¤ºä¾‹
type Ordered interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64 |
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 |
    ~float32 | ~float64 | ~string
}

type Number interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64 |
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 |
    ~float32 | ~float64
}

// å¤šé‡çº¦æŸ
func MinMax[T Ordered](a, b T) (T, T) {
    if a < b {
        return a, b
    }
    return b, a
}

// çº¦æŸæ±‚è§£è¿‡ç¨‹:
/*
è°ƒç”¨: MinMax(3, 5)

çº¦æŸç”Ÿæˆ:
1. T : Ordered
2. a : T, b : T
3. a < b âŸ¹ T must support comparison
4. è¿”å› (T, T)

çº¦æŸæ±‚è§£:
T = int æ»¡è¶³ Ordered çº¦æŸ
éªŒè¯: int æ”¯æŒ < è¿ç®—ç¬¦ âœ“

ç»“æœ: (int, int)
*/
```

---

## ç¬¬äºŒéƒ¨åˆ†: æ³›å‹ç±»å‹ç³»ç»Ÿæ·±åŒ–

### 2.1 é«˜é˜¶ç±»å‹å‚æ•°

è™½ç„¶ Go å½“å‰ä¸ç›´æ¥æ”¯æŒé«˜é˜¶ç±»å‹ï¼Œä½†å¯ä»¥é€šè¿‡æ¥å£æ¨¡æ‹Ÿã€‚

```go
// æ¨¡æ‹Ÿé«˜é˜¶ç±»å‹ (Higher-Kinded Types)

// ç±»å‹æ„é€ å™¨æ¥å£
type Functor[F any] interface {
    Map(f func(A) B) F[B]  // éœ€è¦è¯­è¨€æ‰©å±•
}

// å½“å‰ Go çš„å·¥ä½œæ–¹å¼
type List[T any] []T

func (l List[T]) Map(f func(T) U) List[U] {
    result := make(List[U], len(l))
    for i, v := range l {
        result[i] = f(v)
    }
    return result
}

// ä½¿ç”¨ç¤ºä¾‹
numbers := List[int]{1, 2, 3}
strings := numbers.Map(func(n int) string {
    return strconv.Itoa(n)
})
```

#### å½¢å¼åŒ–è¡¨ç¤º

```mathematical
/* é«˜é˜¶ç±»å‹ (Higher-Kinded Types) */

Kind Îº ::= *                     /* ç±»å‹ kind */
         | Îºâ‚ â‡’ Îºâ‚‚               /* ç±»å‹æ„é€ å™¨ kind */

/* ç¤ºä¾‹ */
List      : * â‡’ *               /* List æ˜¯ç±»å‹æ„é€ å™¨ */
List[Int] : *                   /* List[Int] æ˜¯å…·ä½“ç±»å‹ */

Map       : (* â‡’ *) â‡’ (* â‡’ *)  /* Map æ˜¯é«˜é˜¶ç±»å‹æ„é€ å™¨ */

/* Go 1.25.3 çš„é™åˆ¶ */
Goå½“å‰åªæ”¯æŒ kind * çš„ç±»å‹å‚æ•°
ä¸æ”¯æŒ kind (* â‡’ *) çš„ç±»å‹å‚æ•°
```

### 2.2 ç±»å‹æ—ä¸å…³è”ç±»å‹

```go
// ä½¿ç”¨æ¥å£æ¨¡æ‹Ÿå…³è”ç±»å‹

type Container[T any] interface {
    Add(T)
    Get(int) (T, bool)
    Size() int
}

// å…·ä½“å®ç°
type SliceContainer[T any] struct {
    data []T
}

func (sc *SliceContainer[T]) Add(item T) {
    sc.data = append(sc.data, item)
}

func (sc *SliceContainer[T]) Get(index int) (T, bool) {
    if index >= 0 && index < len(sc.data) {
        return sc.data[index], true
    }
    var zero T
    return zero, false
}

func (sc *SliceContainer[T]) Size() int {
    return len(sc.data)
}

// å…³è”ç±»å‹æ¨¡å¼
type Collection[T any] interface {
    Iterator() Iterator[T]  // å…³è”ç±»å‹
}

type Iterator[T any] interface {
    Next() (T, bool)
    HasNext() bool
}
```

### 2.3 å˜å‹ä¸åå˜æ€§

#### ç±»å‹å˜å‹ç†è®º

```mathematical
/* å˜å‹ (Variance) */

/* åå˜ (Covariant) */
Ï„â‚ â‰¤ Ï„â‚‚  âŸ¹  F[Ï„â‚] â‰¤ F[Ï„â‚‚]
ç¬¦å·: F[+T]

/* é€†å˜ (Contravariant) */
Ï„â‚ â‰¤ Ï„â‚‚  âŸ¹  F[Ï„â‚‚] â‰¤ F[Ï„â‚]
ç¬¦å·: F[-T]

/* ä¸å˜ (Invariant) */
Ï„â‚ â‰¤ Ï„â‚‚  âŸ¹  F[Ï„â‚] å’Œ F[Ï„â‚‚] æ— å…³ç³»
ç¬¦å·: F[T]

/* Go ä¸­çš„å˜å‹ */

// Channel çš„å˜å‹
chan T      : Invariant     (ä¸å˜)
chanâ† T     : Contravariant (é€†å˜ - å‘é€ç«¯)
â†chan T     : Covariant     (åå˜ - æ¥æ”¶ç«¯)

// å‡½æ•°ç±»å‹çš„å˜å‹
func(A) B : 
    A ä½ç½®: Contravariant (å‚æ•°é€†å˜)
    B ä½ç½®: Covariant     (è¿”å›å€¼åå˜)

// Slice çš„å˜å‹
[]T : Invariant (ä¸å˜ - å¯è¯»å¯å†™)
```

#### Go ä»£ç ç¤ºä¾‹1

```go
// å˜å‹ç¤ºä¾‹

type Animal interface {
    Speak() string
}

type Dog struct{}
func (d Dog) Speak() string { return "Woof" }

// å‡½æ•°ç±»å‹çš„å˜å‹
type AnimalProcessor func(Animal) Animal

// é€†å˜: å‚æ•°å¯ä»¥æ¥å—æ›´å®½æ³›çš„ç±»å‹
// åå˜: è¿”å›å€¼å¯ä»¥è¿”å›æ›´å…·ä½“çš„ç±»å‹

// Channel çš„å˜å‹
func Producer(ch chan<- int) {  // åªå‘é€ (é€†å˜)
    ch <- 42
}

func Consumer(ch <-chan int) {  // åªæ¥æ”¶ (åå˜)
    value := <-ch
    fmt.Println(value)
}

func Bidirectional(ch chan int) {  // åŒå‘ (ä¸å˜)
    ch <- 1
    <-ch
}
```

---

## ç¬¬ä¸‰éƒ¨åˆ†: æ•ˆåº”ç³»ç»Ÿ

### 3.1 å‰¯ä½œç”¨è¿½è¸ª

è™½ç„¶ Go æ²¡æœ‰æ˜¾å¼çš„æ•ˆåº”ç³»ç»Ÿï¼Œä½†å¯ä»¥é€šè¿‡ç±»å‹ç³»ç»Ÿç¼–ç å‰¯ä½œç”¨ã€‚

```go
// ä½¿ç”¨ç±»å‹æ ‡è®°æ•ˆåº”

// Pure å‡½æ•°æ ‡è®°
type Pure[T any] func() T

// IO æ•ˆåº”æ ‡è®°
type IO[T any] func() (T, error)

// State æ•ˆåº”æ ‡è®°
type State[S, T any] func(S) (T, S)

// ç»„åˆæ•ˆåº”
type IOState[S, T any] func(S) (T, S, error)

// ç¤ºä¾‹: çº¯å‡½æ•°
func Add(a, b int) int {  // Pure
    return a + b
}

// ç¤ºä¾‹: IO æ•ˆåº”
func ReadFile(path string) ([]byte, error) {  // IO
    return os.ReadFile(path)
}

// ç¤ºä¾‹: State æ•ˆåº”
func Increment(state int) (string, int) {  // State
    newState := state + 1
    return fmt.Sprintf("Count: %d", newState), newState
}

// æ•ˆåº”ç»„åˆ
func ProcessFile(path string, counter int) (string, int, error) {
    data, err := ReadFile(path)  // IO
    if err != nil {
        return "", counter, err
    }
    
    result, newCounter := Increment(counter)  // State
    return fmt.Sprintf("%s: %d bytes", result, len(data)), newCounter, nil
}
```

#### å½¢å¼åŒ–æ•ˆåº”ç³»ç»Ÿ

```mathematical
/* æ•ˆåº”ç±»å‹ (Effect Types) */

Effect Îµ ::= Pure                /* çº¯è®¡ç®— */
           | IO                  /* I/O æ•ˆåº” */
           | State[S]            /* çŠ¶æ€æ•ˆåº” */
           | Error               /* é”™è¯¯æ•ˆåº” */
           | Îµâ‚ âŠ• Îµâ‚‚            /* æ•ˆåº”ç»„åˆ */

/* æ•ˆåº”ç±»å‹åˆ¤æ–­ */

Î“ âŠ¢ e : Ï„ ! Îµ

/* è§„åˆ™ */

[Pure]
no side effects in e
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ e : Ï„ ! Pure

[IO]
e performs I/O
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ e : Ï„ ! IO

[Combine]
Î“ âŠ¢ eâ‚ : Ï„â‚ ! Îµâ‚    Î“ âŠ¢ eâ‚‚ : Ï„â‚‚ ! Îµâ‚‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ (eâ‚; eâ‚‚) : Ï„â‚‚ ! (Îµâ‚ âŠ• Îµâ‚‚)
```

### 3.2 èµ„æºç®¡ç†

```go
// ä½¿ç”¨æ³›å‹å’Œæ¥å£ç®¡ç†èµ„æº

type Resource[T any] interface {
    Acquire() (T, error)
    Release(T) error
}

// è‡ªåŠ¨èµ„æºç®¡ç†æ¨¡å¼
func WithResource[R Resource[T], T any](
    resource R,
    action func(T) error,
) error {
    value, err := resource.Acquire()
    if err != nil {
        return err
    }
    defer resource.Release(value)
    
    return action(value)
}

// å…·ä½“å®ç°: æ–‡ä»¶èµ„æº
type FileResource struct {
    path string
}

func (fr FileResource) Acquire() (*os.File, error) {
    return os.Open(fr.path)
}

func (fr FileResource) Release(f *os.File) error {
    return f.Close()
}

// ä½¿ç”¨ç¤ºä¾‹
func ProcessFileContent(path string) error {
    return WithResource(
        FileResource{path: path},
        func(f *os.File) error {
            data, err := io.ReadAll(f)
            if err != nil {
                return err
            }
            fmt.Println(string(data))
            return nil
        },
    )
}
```

### 3.3 é”™è¯¯æ•ˆåº”

```go
// é”™è¯¯æ•ˆåº”çš„ç±»å‹çº§è¡¨ç¤º

// Result ç±»å‹ (ç±»ä¼¼ Rust çš„ Result<T, E>)
type Result[T any] struct {
    value T
    err   error
}

func Ok[T any](value T) Result[T] {
    return Result[T]{value: value}
}

func Err[T any](err error) Result[T] {
    var zero T
    return Result[T]{err: err}
}

func (r Result[T]) IsOk() bool {
    return r.err == nil
}

func (r Result[T]) Unwrap() (T, error) {
    return r.value, r.err
}

// Map æ“ä½œ
func (r Result[T]) Map(f func(T) U) Result[U] {
    if r.err != nil {
        return Err[U](r.err)
    }
    return Ok(f(r.value))
}

// Bind æ“ä½œ (flatMap)
func (r Result[T]) Bind(f func(T) Result[U]) Result[U] {
    if r.err != nil {
        return Err[U](r.err)
    }
    return f(r.value)
}

// ä½¿ç”¨ç¤ºä¾‹
func ParseInt(s string) Result[int] {
    value, err := strconv.Atoi(s)
    if err != nil {
        return Err[int](err)
    }
    return Ok(value)
}

func Double(n int) int {
    return n * 2
}

func ProcessNumber(s string) Result[int] {
    return ParseInt(s).Map(Double)
}
```

---

## ç¬¬å››éƒ¨åˆ†: ä¾èµ–ç±»å‹ç‰¹æ€§

### 4.1 é•¿åº¦ç´¢å¼•ç±»å‹

è™½ç„¶ Go ä¸åŸç”Ÿæ”¯æŒä¾èµ–ç±»å‹ï¼Œä½†å¯ä»¥é€šè¿‡ç¼–è¯‘æ—¶æ£€æŸ¥æ¨¡æ‹Ÿã€‚

```go
// ä½¿ç”¨æ³›å‹æ¨¡æ‹Ÿå›ºå®šé•¿åº¦æ•°ç»„

type Vec[T any, N int] struct {
    data [N]T  // ç¼–è¯‘æ—¶å›ºå®šå¤§å°
}

// ç±»å‹å®‰å…¨çš„å‘é‡æ“ä½œ
func NewVec3[T any](x, y, z T) Vec[T, 3] {
    return Vec[T, 3]{data: [3]T{x, y, z}}
}

func (v Vec[T, N]) Get(i int) (T, bool) {
    if i >= 0 && i < N {
        return v.data[i], true
    }
    var zero T
    return zero, false
}

// ç‚¹ç§¯ (è¦æ±‚é•¿åº¦ç›¸åŒ)
func Dot[T Number, N int](a, b Vec[T, N]) T {
    var sum T
    for i := 0; i < N; i++ {
        sum += a.data[i] * b.data[i]
    }
    return sum
}

// ä½¿ç”¨
v1 := NewVec3(1, 2, 3)
v2 := NewVec3(4, 5, 6)
result := Dot(v1, v2)  // ç±»å‹å®‰å…¨: é•¿åº¦å¿…é¡»åŒ¹é…
```

#### å½¢å¼åŒ–è¡¨ç¤º1

```mathematical
/* é•¿åº¦ç´¢å¼•ç±»å‹ (Length-Indexed Types) */

Vec : Type â†’ Nat â†’ Type

Vec[T, n] è¡¨ç¤ºé•¿åº¦ä¸º n çš„ T ç±»å‹å‘é‡

/* ç±»å‹è§„åˆ™ */

[Vec-Intro]
eâ‚ : T ... eâ‚™ : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[eâ‚, ..., eâ‚™] : Vec[T, n]

[Vec-Elim]
v : Vec[T, n]    0 â‰¤ i < n
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
v[i] : T

[Vec-Concat]
vâ‚ : Vec[T, n]    vâ‚‚ : Vec[T, m]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
concat(vâ‚, vâ‚‚) : Vec[T, n+m]
```

### 4.2 çŠ¶æ€ä¾èµ–ç±»å‹

```go
// ä½¿ç”¨ç±»å‹çŠ¶æ€æ¨¡å¼ (Typestate Pattern)

// çŠ¶æ€æ ‡è®°ç±»å‹
type Uninitialized struct{}
type Initialized struct{}
type Running struct{}
type Stopped struct{}

// çŠ¶æ€æœº
type StateMachine[S any] struct {
    state S
    data  interface{}
}

// çŠ¶æ€è½¬æ¢å‡½æ•°
func NewMachine() StateMachine[Uninitialized] {
    return StateMachine[Uninitialized]{}
}

func (sm StateMachine[Uninitialized]) Initialize(data interface{}) StateMachine[Initialized] {
    return StateMachine[Initialized]{data: data}
}

func (sm StateMachine[Initialized]) Start() StateMachine[Running] {
    return StateMachine[Running]{data: sm.data}
}

func (sm StateMachine[Running]) Stop() StateMachine[Stopped] {
    return StateMachine[Stopped]{data: sm.data}
}

// åªæœ‰ Running çŠ¶æ€å¯ä»¥æ‰§è¡Œ
func (sm StateMachine[Running]) Execute() string {
    return "Executing..."
}

// ä½¿ç”¨ - ç¼–è¯‘æ—¶ä¿è¯æ­£ç¡®çš„çŠ¶æ€è½¬æ¢
func UseStateMachine() {
    machine := NewMachine()                   // Uninitialized
    machine = machine.Initialize("data")      // Initialized
    machine = machine.Start()                 // Running
    result := machine.Execute()               // âœ“ åªæœ‰ Running å¯ä»¥æ‰§è¡Œ
    machine = machine.Stop()                  // Stopped
    // machine.Execute()  // âœ— ç¼–è¯‘é”™è¯¯: Stopped æ²¡æœ‰ Execute
}
```

### 4.3 ç²¾ç‚¼ç±»å‹

```go
// ä½¿ç”¨æ¥å£çº¦æŸå®ç°ç²¾ç‚¼ç±»å‹

// éç©ºå­—ç¬¦ä¸²
type NonEmptyString string

func NewNonEmptyString(s string) (NonEmptyString, error) {
    if s == "" {
        return "", errors.New("string cannot be empty")
    }
    return NonEmptyString(s), nil
}

// æ­£æ•´æ•°
type PositiveInt int

func NewPositiveInt(n int) (PositiveInt, error) {
    if n <= 0 {
        return 0, errors.New("number must be positive")
    }
    return PositiveInt(n), nil
}

// èŒƒå›´é™å®šçš„æ•´æ•°
type BoundedInt[Min, Max int] int

func NewBoundedInt[Min, Max int](n int) (BoundedInt[Min, Max], error) {
    if n < Min || n > Max {
        return 0, fmt.Errorf("number must be between %d and %d", Min, Max)
    }
    return BoundedInt[Min, Max](n), nil
}

// ä½¿ç”¨ç¤ºä¾‹
type Percentage = BoundedInt[0, 100]

func SetProgress(p Percentage) {
    fmt.Printf("Progress: %d%%\n", int(p))
}

// ä½¿ç”¨
func Example() error {
    // å®‰å…¨æ„é€ 
    progress, err := NewBoundedInt[0, 100](75)
    if err != nil {
        return err
    }
    SetProgress(progress)
    
    // ç¼–è¯‘æ—¶ç±»å‹å®‰å…¨
    // SetProgress(150)  // âœ— ç±»å‹ä¸åŒ¹é…
    
    return nil
}
```

---

## ç¬¬äº”éƒ¨åˆ†: å®ç”¨ç±»å‹æ¨¡å¼

### 5.1 ç±»å‹çº§ç¼–ç¨‹

```go
// ä½¿ç”¨æ³›å‹è¿›è¡Œç±»å‹çº§è®¡ç®—

// ç±»å‹çº§å¸ƒå°”
type True struct{}
type False struct{}

// ç±»å‹çº§ If
type If[Cond, Then, Else any] interface {
    Result() any
}

// ç±»å‹çº§åˆ—è¡¨
type Nil struct{}
type Cons[Head, Tail any] struct {
    head Head
    tail Tail
}

// ç±»å‹çº§å‡½æ•°: Map
func TypeMap[T any, F func(T) any](list interface{}) interface{} {
    switch l := list.(type) {
    case Nil:
        return Nil{}
    case Cons[T, any]:
        return Cons[any, any]{
            head: F(l.head),
            tail: TypeMap[T, F](l.tail),
        }
    default:
        return Nil{}
    }
}

// HList (Heterogeneous List)
type HNil struct{}

type HCons[H any, T any] struct {
    Head H
    Tail T
}

// HList æ“ä½œ
func HHead[H any, T any](hlist HCons[H, T]) H {
    return hlist.Head
}

func HTail[H any, T any](hlist HCons[H, T]) T {
    return hlist.Tail
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleHList() {
    // åˆ›å»ºå¼‚æ„åˆ—è¡¨: (1, "hello", true)
    hlist := HCons[int, HCons[string, HCons[bool, HNil]]]{
        Head: 1,
        Tail: HCons[string, HCons[bool, HNil]]{
            Head: "hello",
            Tail: HCons[bool, HNil]{
                Head: true,
                Tail: HNil{},
            },
        },
    }
    
    // ç±»å‹å®‰å…¨çš„è®¿é—®
    first := HHead(hlist)                      // int
    second := HHead(HTail(hlist))              // string
    third := HHead(HTail(HTail(hlist)))        // bool
    
    fmt.Printf("%d, %s, %v\n", first, second, third)
}
```

### 5.2 å¹»è±¡ç±»å‹

```go
// Phantom Types: ç±»å‹å‚æ•°ä¸åœ¨è¿è¡Œæ—¶ä½¿ç”¨ï¼Œä»…ç”¨äºç¼–è¯‘æ—¶æ£€æŸ¥

// å•ä½æ ‡è®°
type Meter struct{}
type Kilometer struct{}
type Second struct{}
type Hour struct{}

// ç‰©ç†é‡ç±»å‹
type Quantity[Unit any] float64

// æ„é€ å‡½æ•°
func Meters(value float64) Quantity[Meter] {
    return Quantity[Meter](value)
}

func Kilometers(value float64) Quantity[Kilometer] {
    return Quantity[Kilometer](value * 1000) // å†…éƒ¨ç»Ÿä¸€ä¸ºç±³
}

func Seconds(value float64) Quantity[Second] {
    return Quantity[Second](value)
}

func Hours(value float64) Quantity[Hour] {
    return Quantity[Hour](value * 3600) // å†…éƒ¨ç»Ÿä¸€ä¸ºç§’
}

// ç±»å‹å®‰å…¨çš„è¿ç®—
func Add[Unit any](a, b Quantity[Unit]) Quantity[Unit] {
    return Quantity[Unit](float64(a) + float64(b))
}

func Subtract[Unit any](a, b Quantity[Unit]) Quantity[Unit] {
    return Quantity[Unit](float64(a) - float64(b))
}

// é€Ÿåº¦è®¡ç®— (è·ç¦»/æ—¶é—´)
func Speed(distance Quantity[Meter], time Quantity[Second]) float64 {
    return float64(distance) / float64(time)
}

// ä½¿ç”¨ç¤ºä¾‹
func PhysicsExample() {
    d1 := Meters(100)
    d2 := Kilometers(0.5)  // 500ç±³
    
    // ç±»å‹å®‰å…¨: åŒå•ä½å¯ä»¥ç›¸åŠ 
    total := Add(d1, d2)  // âœ“
    
    t1 := Seconds(10)
    
    // è®¡ç®—é€Ÿåº¦
    speed := Speed(total, t1)
    fmt.Printf("Speed: %.2f m/s\n", speed)
    
    // ç¼–è¯‘é”™è¯¯: ä¸åŒå•ä½ä¸èƒ½ç›´æ¥ç›¸åŠ 
    // Add(d1, t1)  // âœ— ç±»å‹ä¸åŒ¹é…
}
```

### 5.3 ç±»å‹è§è¯

```go
// Type Witness: ä½¿ç”¨ç±»å‹è¯æ˜æŸäº›å±æ€§

// éç©ºåˆ—è¡¨è§è¯
type NonEmpty[T any] struct {
    head T
    tail []T
}

func NewNonEmpty[T any](head T, tail ...T) NonEmpty[T] {
    return NonEmpty[T]{head: head, tail: tail}
}

// ä¿è¯éç©ºçš„æ“ä½œ
func (ne NonEmpty[T]) Head() T {
    return ne.head  // å®‰å…¨: ä¿è¯æœ‰å…ƒç´ 
}

func (ne NonEmpty[T]) Last() T {
    if len(ne.tail) == 0 {
        return ne.head
    }
    return ne.tail[len(ne.tail)-1]
}

// æ’åºåˆ—è¡¨è§è¯
type Sorted[T Ordered] struct {
    data []T
}

func NewSorted[T Ordered](data []T) Sorted[T] {
    sorted := make([]T, len(data))
    copy(sorted, data)
    sort.Slice(sorted, func(i, j int) bool {
        return sorted[i] < sorted[j]
    })
    return Sorted[T]{data: sorted}
}

// ä¿è¯æœ‰åºçš„æ“ä½œ
func (s Sorted[T]) BinarySearch(target T) (int, bool) {
    // å®‰å…¨: ä¿è¯åˆ—è¡¨å·²æ’åºï¼Œå¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾
    idx := sort.Search(len(s.data), func(i int) bool {
        return s.data[i] >= target
    })
    if idx < len(s.data) && s.data[idx] == target {
        return idx, true
    }
    return -1, false
}

// äº’æ–¥é”è§è¯
type Locked[T any] struct {
    mu    sync.Mutex
    value T
}

func NewLocked[T any](value T) *Locked[T] {
    return &Locked[T]{value: value}
}

// ä¿è¯äº’æ–¥è®¿é—®
func (l *Locked[T]) WithLock(f func(*T)) {
    l.mu.Lock()
    defer l.mu.Unlock()
    f(&l.value)
}

// ä½¿ç”¨ç¤ºä¾‹
func WitnessExample() {
    // éç©ºåˆ—è¡¨
    numbers := NewNonEmpty(1, 2, 3, 4, 5)
    first := numbers.Head()  // å®‰å…¨: ä¿è¯éç©º
    fmt.Println("First:", first)
    
    // æ’åºåˆ—è¡¨
    unsorted := []int{5, 2, 8, 1, 9}
    sorted := NewSorted(unsorted)
    idx, found := sorted.BinarySearch(8)  // å®‰å…¨: ä¿è¯å·²æ’åº
    fmt.Printf("Found at index %d: %v\n", idx, found)
    
    // äº’æ–¥è®¿é—®
    counter := NewLocked(0)
    counter.WithLock(func(c *int) {
        *c++  // å®‰å…¨: ä¿è¯äº’æ–¥
    })
}
```

---

## ğŸ¯ æ€»ç»“

### æ ¸å¿ƒè´¡çŒ®

1. **é«˜çº§ç±»å‹æ¨æ–­ç†è®º**
   - åŒå‘ç±»å‹æ£€æŸ¥ç³»ç»Ÿ
   - çº¦æŸæ±‚è§£ç®—æ³•
   - å…¨å±€ç±»å‹æ¨æ–­

2. **æ³›å‹ç³»ç»Ÿæ·±åŒ–**
   - é«˜é˜¶ç±»å‹æ¨¡æ‹Ÿ
   - ç±»å‹æ—ä¸å…³è”ç±»å‹
   - å˜å‹ç†è®ºå®Œæ•´åˆ†æ

3. **æ•ˆåº”ç³»ç»Ÿ**
   - å‰¯ä½œç”¨è¿½è¸ª
   - èµ„æºç®¡ç†æ¨¡å¼
   - é”™è¯¯æ•ˆåº”å¤„ç†

4. **ä¾èµ–ç±»å‹ç‰¹æ€§**
   - é•¿åº¦ç´¢å¼•ç±»å‹
   - çŠ¶æ€ä¾èµ–ç±»å‹
   - ç²¾ç‚¼ç±»å‹å®ç°

5. **å®ç”¨ç±»å‹æ¨¡å¼**
   - ç±»å‹çº§ç¼–ç¨‹
   - å¹»è±¡ç±»å‹
   - ç±»å‹è§è¯

### ç†è®ºä»·å€¼

- æ‰©å±•äº† Go ç±»å‹ç³»ç»Ÿçš„ç†è®ºåŸºç¡€
- æä¾›äº†ç±»å‹å®‰å…¨ç¼–ç¨‹çš„å®ç”¨æ¨¡å¼
- å»ºç«‹äº†ä¸å…¶ä»–è¯­è¨€ç±»å‹ç³»ç»Ÿçš„å¯¹åº”å…³ç³»

### å·¥ç¨‹ä»·å€¼

- æé«˜ä»£ç çš„ç±»å‹å®‰å…¨æ€§
- åœ¨ç¼–è¯‘æ—¶æ•è·æ›´å¤šé”™è¯¯
- æä¾›æ›´å¥½çš„ API è®¾è®¡æ¨¡å¼

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**é€‚ç”¨Goç‰ˆæœ¬**: 1.25.3  
**æœ€åæ›´æ–°**: 2025-10-23  
**ç»´æŠ¤å›¢é˜Ÿ**: Go Language Theory Team
