# Goç¼–è¯‘å™¨ä¼˜åŒ–å½¢å¼åŒ–è¯æ˜

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**åŸºå‡†æ—¥æœŸ**: 2025å¹´10æœˆ23æ—¥  
**Goç‰ˆæœ¬**: Go 1.25.3  
**ç†è®ºåŸºç¡€**: Compiler Optimization + Program Transformation + Formal Verification  
**å­—æ•°**: ~28,000å­—

---

## ğŸ“š ç›®å½•

- [Goç¼–è¯‘å™¨ä¼˜åŒ–å½¢å¼åŒ–è¯æ˜](#goç¼–è¯‘å™¨ä¼˜åŒ–å½¢å¼åŒ–è¯æ˜)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [ç¬¬ä¸€éƒ¨åˆ†: ç¼–è¯‘å™¨ä¼˜åŒ–ç†è®ºåŸºç¡€](#ç¬¬ä¸€éƒ¨åˆ†-ç¼–è¯‘å™¨ä¼˜åŒ–ç†è®ºåŸºç¡€)
    - [1.1 ä¼˜åŒ–æ­£ç¡®æ€§å®šä¹‰](#11-ä¼˜åŒ–æ­£ç¡®æ€§å®šä¹‰)
    - [1.2 ç¨‹åºç­‰ä»·æ€§](#12-ç¨‹åºç­‰ä»·æ€§)
    - [1.3 ä¼˜åŒ–å®‰å…¨æ€§æ¡ä»¶](#13-ä¼˜åŒ–å®‰å…¨æ€§æ¡ä»¶)
  - [ç¬¬äºŒéƒ¨åˆ†: å¸¸é‡æŠ˜å ä¸ä¼ æ’­](#ç¬¬äºŒéƒ¨åˆ†-å¸¸é‡æŠ˜å ä¸ä¼ æ’­)
    - [2.1 å¸¸é‡æŠ˜å å½¢å¼åŒ–](#21-å¸¸é‡æŠ˜å å½¢å¼åŒ–)
    - [2.2 å¸¸é‡ä¼ æ’­ç®—æ³•](#22-å¸¸é‡ä¼ æ’­ç®—æ³•)
    - [2.3 æ­£ç¡®æ€§è¯æ˜](#23-æ­£ç¡®æ€§è¯æ˜)
  - [ç¬¬ä¸‰éƒ¨åˆ†: æ­»ä»£ç æ¶ˆé™¤](#ç¬¬ä¸‰éƒ¨åˆ†-æ­»ä»£ç æ¶ˆé™¤)
    - [3.1 æ­»ä»£ç å®šä¹‰](#31-æ­»ä»£ç å®šä¹‰)
    - [3.2 æ¶ˆé™¤ç®—æ³•](#32-æ¶ˆé™¤ç®—æ³•)
    - [3.3 æ­£ç¡®æ€§è¯æ˜](#33-æ­£ç¡®æ€§è¯æ˜)
  - [ç¬¬å››éƒ¨åˆ†: å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤](#ç¬¬å››éƒ¨åˆ†-å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤)
    - [4.1 CSEå½¢å¼åŒ–](#41-cseå½¢å¼åŒ–)
    - [4.2 å…¨å±€CSEç®—æ³•](#42-å…¨å±€cseç®—æ³•)
    - [4.3 æ­£ç¡®æ€§è¯æ˜](#43-æ­£ç¡®æ€§è¯æ˜)
  - [ç¬¬äº”éƒ¨åˆ†: å¾ªç¯ä¼˜åŒ–](#ç¬¬äº”éƒ¨åˆ†-å¾ªç¯ä¼˜åŒ–)
    - [5.1 å¾ªç¯ä¸å˜ä»£ç å¤–æ](#51-å¾ªç¯ä¸å˜ä»£ç å¤–æ)
    - [5.2 å¾ªç¯å±•å¼€](#52-å¾ªç¯å±•å¼€)
    - [5.3 æ­£ç¡®æ€§è¯æ˜](#53-æ­£ç¡®æ€§è¯æ˜)
  - [ç¬¬å…­éƒ¨åˆ†: å†…è”ä¼˜åŒ–](#ç¬¬å…­éƒ¨åˆ†-å†…è”ä¼˜åŒ–)
    - [6.1 å†…è”å½¢å¼åŒ–](#61-å†…è”å½¢å¼åŒ–)
    - [6.2 å†…è”å†³ç­–](#62-å†…è”å†³ç­–)
    - [6.3 æ­£ç¡®æ€§è¯æ˜](#63-æ­£ç¡®æ€§è¯æ˜)
  - [ç¬¬ä¸ƒéƒ¨åˆ†: é€ƒé€¸åˆ†æ](#ç¬¬ä¸ƒéƒ¨åˆ†-é€ƒé€¸åˆ†æ)
    - [7.1 é€ƒé€¸åˆ†æç†è®º](#71-é€ƒé€¸åˆ†æç†è®º)
    - [7.2 Goé€ƒé€¸åˆ†æç®—æ³•](#72-goé€ƒé€¸åˆ†æç®—æ³•)
    - [7.3 æ ˆåˆ†é…ä¼˜åŒ–](#73-æ ˆåˆ†é…ä¼˜åŒ–)
  - [ç¬¬å…«éƒ¨åˆ†: è¾¹ç•Œæ£€æŸ¥æ¶ˆé™¤](#ç¬¬å…«éƒ¨åˆ†-è¾¹ç•Œæ£€æŸ¥æ¶ˆé™¤)
    - [8.1 BCEç†è®º](#81-bceç†è®º)
    - [8.2 BCEç®—æ³•](#82-bceç®—æ³•)
    - [8.3 æ­£ç¡®æ€§è¯æ˜](#83-æ­£ç¡®æ€§è¯æ˜)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
    - [æ ¸å¿ƒå†…å®¹](#æ ¸å¿ƒå†…å®¹)
    - [ç†è®ºè´¡çŒ®](#ç†è®ºè´¡çŒ®)
    - [å·¥ç¨‹ä»·å€¼](#å·¥ç¨‹ä»·å€¼)

---

## ç¬¬ä¸€éƒ¨åˆ†: ç¼–è¯‘å™¨ä¼˜åŒ–ç†è®ºåŸºç¡€

### 1.1 ä¼˜åŒ–æ­£ç¡®æ€§å®šä¹‰

```mathematical
/* ç¼–è¯‘å™¨ä¼˜åŒ–æ­£ç¡®æ€§ */

å®šä¹‰: ä¼˜åŒ– O æ˜¯æ­£ç¡®çš„,å½“ä¸”ä»…å½“:
âˆ€ program P. âŸ¦O(P)âŸ§ = âŸ¦PâŸ§

å…¶ä¸­ âŸ¦PâŸ§ æ˜¯ç¨‹åºPçš„è¯­ä¹‰

/* è¯­ä¹‰ç­‰ä»·çš„ä¸åŒçº§åˆ« */

1. å¼ºç­‰ä»· (Strong Equivalence):
   âˆ€ input i. âŸ¦Pâ‚âŸ§(i) = âŸ¦Pâ‚‚âŸ§(i)
   
   Pâ‚å’ŒPâ‚‚åœ¨æ‰€æœ‰è¾“å…¥ä¸Šè¡Œä¸ºå®Œå…¨ç›¸åŒ

2. å¼±ç­‰ä»· (Weak Equivalence):
   âˆ€ input i. 
     (âŸ¦Pâ‚âŸ§(i) terminates âŸº âŸ¦Pâ‚‚âŸ§(i) terminates) âˆ§
     (âŸ¦Pâ‚âŸ§(i) = âŸ¦Pâ‚‚âŸ§(i) when both terminate)
   
   ç»ˆæ­¢è¡Œä¸ºä¸€è‡´,ä¸”ç»ˆæ­¢æ—¶ç»“æœç›¸åŒ

3. å¯è§‚å¯Ÿç­‰ä»· (Observable Equivalence):
   âˆ€ input i. observable(âŸ¦Pâ‚âŸ§(i)) = observable(âŸ¦Pâ‚‚âŸ§(i))
   
   å¤–éƒ¨å¯è§‚å¯Ÿè¡Œä¸ºç›¸åŒ (è¾“å‡ºã€I/Oç­‰)

/* Goç¼–è¯‘å™¨ä¼˜åŒ–çš„æ­£ç¡®æ€§è¦æ±‚ */

å¯¹äºGoç¼–è¯‘å™¨:
1. ä¿æŒå†…å­˜æ¨¡å‹è¯­ä¹‰
2. ä¿æŒhappens-beforeå…³ç³»
3. ä¿æŒpanic/recoverè¡Œä¸º
4. ä¿æŒdeferæ‰§è¡Œé¡ºåº

/* å½¢å¼åŒ–éªŒè¯æ–¹æ³• */

Method 1: æ“ä½œè¯­ä¹‰è¯æ˜
  è¯æ˜: âŸ¨P, ÏƒâŸ© â†’* âŸ¨v, Ïƒ'âŸ© âŸº âŸ¨O(P), ÏƒâŸ© â†’* âŸ¨v, Ïƒ'âŸ©

Method 2: æŒ‡ç§°è¯­ä¹‰è¯æ˜
  è¯æ˜: âŸ¦PâŸ§ = âŸ¦O(P)âŸ§

Method 3: ç±»å‹ä¿æŒ
  è¯æ˜: Î“ âŠ¢ P : Ï„ âŸ¹ Î“ âŠ¢ O(P) : Ï„
```

### 1.2 ç¨‹åºç­‰ä»·æ€§

```mathematical
/* ç¨‹åºç­‰ä»·å…³ç³» */

ç­‰ä»·å…³ç³» â‰¡ âŠ† Program Ã— Program

/* ç»“æ„ç­‰ä»· (Syntactic Equivalence) */

Pâ‚ â‰¡_syntax Pâ‚‚ âŸº AST(Pâ‚) = AST(Pâ‚‚)

æœ€å¼ºç­‰ä»·,ä½†ä¸é€‚åˆä¼˜åŒ–éªŒè¯

/* è¯­ä¹‰ç­‰ä»· (Semantic Equivalence) */

Pâ‚ â‰¡_semantic Pâ‚‚ âŸº âˆ€Ïƒ. âŸ¦Pâ‚âŸ§Ïƒ = âŸ¦Pâ‚‚âŸ§Ïƒ

/* ä¸Šä¸‹æ–‡ç­‰ä»· (Contextual Equivalence) */

Pâ‚ â‰¡_ctx Pâ‚‚ âŸº âˆ€C[Â·]. âŸ¦C[Pâ‚]âŸ§ = âŸ¦C[Pâ‚‚]âŸ§

å…¶ä¸­C[Â·]æ˜¯ä»»æ„ç¨‹åºä¸Šä¸‹æ–‡

/* ç²¾ç‚¼å…³ç³» (Refinement) */

Pâ‚ âŠ‘ Pâ‚‚ âŸº behaviors(Pâ‚) âŠ‡ behaviors(Pâ‚‚)

Pâ‚æ˜¯Pâ‚‚çš„ç²¾ç‚¼,Pâ‚‚çš„è¡Œä¸ºæ˜¯Pâ‚çš„å­é›†

/* ç­‰ä»·æ€§åˆ¤å®š */

é—®é¢˜: ç»™å®šPâ‚, Pâ‚‚,åˆ¤æ–­Pâ‚ â‰¡ Pâ‚‚ ?

ä¸€èˆ¬æƒ…å†µ: ä¸å¯åˆ¤å®š (ç”±äºåœæœºé—®é¢˜)

å®è·µä¸­: ä½¿ç”¨å……åˆ†æ¡ä»¶
  - ç±»å‹ç³»ç»Ÿ
  - æ•ˆåº”ç³»ç»Ÿ
  - ä¾èµ–åˆ†æ

/* Bisimulation (äº’æ¨¡æ‹Ÿ) */

å®šä¹‰: å…³ç³»Ræ˜¯bisimulation,å¦‚æœ:
âˆ€(Pâ‚, Pâ‚‚) âˆˆ R. 
  (Pâ‚ â†’^a Pâ‚') âŸ¹ âˆƒPâ‚‚'. (Pâ‚‚ â†’^a Pâ‚‚') âˆ§ (Pâ‚', Pâ‚‚') âˆˆ R
  (Pâ‚‚ â†’^a Pâ‚‚') âŸ¹ âˆƒPâ‚'. (Pâ‚ â†’^a Pâ‚') âˆ§ (Pâ‚', Pâ‚‚') âˆˆ R

å®šç†: Pâ‚ ~ Pâ‚‚ (bisimilar) âŸ¹ Pâ‚ â‰¡ Pâ‚‚
```

### 1.3 ä¼˜åŒ–å®‰å…¨æ€§æ¡ä»¶

```mathematical
/* ä¼˜åŒ–å®‰å…¨æ€§æ¡ä»¶ */

å¯¹äºä¼˜åŒ– O: Program â†’ Program

/* æ¡ä»¶1: ç±»å‹ä¿æŒ (Type Preservation) */

[Type-Preservation]
Î“ âŠ¢ P : Ï„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ O(P) : Ï„

å¦‚æœPæ˜¯è‰¯ç±»å‹çš„,O(P)ä¹Ÿæ˜¯è‰¯ç±»å‹çš„

/* æ¡ä»¶2: è¯­ä¹‰ä¿æŒ (Semantic Preservation) */

[Semantic-Preservation]
âŸ¦PâŸ§ = âŸ¦O(P)âŸ§

ä¼˜åŒ–ä¸æ”¹å˜ç¨‹åºè¯­ä¹‰

/* æ¡ä»¶3: æ•ˆåº”ä¿æŒ (Effect Preservation) */

[Effect-Preservation]
effects(P) = effects(O(P))

å‰¯ä½œç”¨ä¸å˜:
- I/Oæ“ä½œ
- å†…å­˜è®¿é—®é¡ºåº
- panic/recover

/* æ¡ä»¶4: ç»ˆæ­¢ä¿æŒ (Termination Preservation) */

[Termination-Preservation]
P terminates âŸº O(P) terminates

ä¸å¼•å…¥æ— é™å¾ªç¯,ä¸ç§»é™¤å¿…è¦çš„ç»ˆæ­¢æ¡ä»¶

/* Goç‰¹å®šæ¡ä»¶ */

1. Happens-Beforeä¿æŒ:
   eâ‚ â†’_hb eâ‚‚ in P âŸ¹ eâ‚ â†’_hb eâ‚‚ in O(P)

2. æ•°æ®ç«äº‰è‡ªç”±:
   no_race(P) âŸ¹ no_race(O(P))

3. Panicé¡ºåº:
   panic_order(P) = panic_order(O(P))

4. Deferæ‰§è¡Œ:
   defer_order(P) = defer_order(O(P))

/* ä¼˜åŒ–æ­£ç¡®æ€§è¯æ˜æ¨¡æ¿ */

è¦è¯æ˜ä¼˜åŒ–Oæ­£ç¡®:

1. å®šä¹‰å˜æ¢è§„åˆ™
   P âŸ¿_O P'

2. è¯æ˜ç±»å‹ä¿æŒ
   Î“ âŠ¢ P : Ï„ âŸ¹ Î“ âŠ¢ P' : Ï„

3. è¯æ˜è¯­ä¹‰ä¿æŒ
   âŸ¦PâŸ§ = âŸ¦P'âŸ§

4. è¯æ˜æ•ˆåº”ä¿æŒ
   effects(P) = effects(P')

5. è¯æ˜Goç‰¹å®šæ€§è´¨
```

---

## ç¬¬äºŒéƒ¨åˆ†: å¸¸é‡æŠ˜å ä¸ä¼ æ’­

### 2.1 å¸¸é‡æŠ˜å å½¢å¼åŒ–

```mathematical
/* å¸¸é‡æŠ˜å  (Constant Folding) */

å®šä¹‰: åœ¨ç¼–è¯‘æ—¶è®¡ç®—å¸¸é‡è¡¨è¾¾å¼

å˜æ¢è§„åˆ™:

[CF-Add]
eâ‚ â‡“ nâ‚    eâ‚‚ â‡“ nâ‚‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ + eâ‚‚  âŸ¿  nâ‚ + nâ‚‚

[CF-Mul]
eâ‚ â‡“ nâ‚    eâ‚‚ â‡“ nâ‚‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ * eâ‚‚  âŸ¿  nâ‚ * nâ‚‚

[CF-IfTrue]
e â‡“ true
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if e then sâ‚ else sâ‚‚  âŸ¿  sâ‚

[CF-IfFalse]
e â‡“ false
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if e then sâ‚ else sâ‚‚  âŸ¿  sâ‚‚

/* å¸¸é‡æŠ˜å ç®—æ³• */

function constantFold(expr: Expr) -> Expr:
    match expr:
        case n:  // å¸¸é‡
            return n
        
        case x:  // å˜é‡
            return x
        
        case eâ‚ + eâ‚‚:
            eâ‚' = constantFold(eâ‚)
            eâ‚‚' = constantFold(eâ‚‚)
            
            if eâ‚' is constant nâ‚ and eâ‚‚' is constant nâ‚‚:
                return nâ‚ + nâ‚‚
            else:
                return eâ‚' + eâ‚‚'
        
        case eâ‚ * eâ‚‚:
            eâ‚' = constantFold(eâ‚)
            eâ‚‚' = constantFold(eâ‚‚)
            
            if eâ‚' is constant nâ‚ and eâ‚‚' is constant nâ‚‚:
                return nâ‚ * nâ‚‚
            elif eâ‚' is constant 0 or eâ‚‚' is constant 0:
                return 0  // ä»£æ•°ç®€åŒ–
            elif eâ‚' is constant 1:
                return eâ‚‚'
            elif eâ‚‚' is constant 1:
                return eâ‚'
            else:
                return eâ‚' * eâ‚‚'
        
        case if e then sâ‚ else sâ‚‚:
            e' = constantFold(e)
            
            if e' is constant true:
                return constantFold(sâ‚)
            elif e' is constant false:
                return constantFold(sâ‚‚)
            else:
                sâ‚' = constantFold(sâ‚)
                sâ‚‚' = constantFold(sâ‚‚)
                return if e' then sâ‚' else sâ‚‚'

/* ä»£æ•°ç®€åŒ–è§„åˆ™ */

x + 0  âŸ¿  x
x * 0  âŸ¿  0
x * 1  âŸ¿  x
x - x  âŸ¿  0
x / 1  âŸ¿  x
```

### 2.2 å¸¸é‡ä¼ æ’­ç®—æ³•

```mathematical
/* å¸¸é‡ä¼ æ’­ (Constant Propagation) */

ç›®æ ‡: ä¼ æ’­å¸¸é‡å®šä¹‰åˆ°ä½¿ç”¨ç‚¹

/* æ•°æ®æµæ–¹ç¨‹ */

OUT[B] = GEN[B] âˆª (IN[B] âˆ© PRESERVE[B])
IN[B] = â‹‚_{P âˆˆ pred(B)} OUT[P]

å…¶ä¸­:
- GEN[B]: Bä¸­ç”Ÿæˆçš„å¸¸é‡
- PRESERVE[B]: Bä¸­ä¿æŒçš„å¸¸é‡
- IN[B]: Bå…¥å£çš„å¸¸é‡é›†
- OUT[B]: Bå‡ºå£çš„å¸¸é‡é›†

/* æ ¼å®šä¹‰ */

Domain: Var â†’ âŠ¥ | Const | âŠ¤

âŠ¥: æœªå®šä¹‰
Const: å¸¸é‡å€¼
âŠ¤: éå¸¸é‡ (å¤šä¸ªä¸åŒå€¼)

Lattice:
     âŠ¤
    / \
   câ‚ câ‚‚ ...
    \ /
     âŠ¥

meetæ“ä½œ:
  âŠ¥ âŠ“ x = x
  x âŠ“ âŠ¥ = x
  c âŠ“ c = c
  câ‚ âŠ“ câ‚‚ = âŠ¤ (if câ‚ â‰  câ‚‚)
  âŠ¤ âŠ“ x = âŠ¤

/* å¸¸é‡ä¼ æ’­ç®—æ³• */

function constantPropagation(CFG):
    // åˆå§‹åŒ–
    IN = {B: {x: âŠ¥ for x in vars} for B in blocks}
    OUT = {B: {x: âŠ¥ for x in vars} for B in blocks}
    
    // Entryå—åˆå§‹åŒ–å‚æ•°
    for param in entry.params:
        OUT[entry][param] = âŠ¤  // å‚æ•°æœªçŸ¥
    
    worklist = blocks.copy()
    
    while worklist:
        B = worklist.pop()
        
        # è®¡ç®—IN[B]
        old_in = IN[B]
        IN[B] = meet(OUT[P] for P in predecessors(B))
        
        # è®¡ç®—OUT[B]
        old_out = OUT[B]
        OUT[B] = transfer(B, IN[B])
        
        # å¦‚æœæ”¹å˜,å°†åç»§åŠ å…¥å·¥ä½œåˆ—è¡¨
        if OUT[B] != old_out:
            worklist.extend(successors(B))
    
    return IN, OUT

function transfer(block: Block, in_state: State) -> State:
    state = in_state.copy()
    
    for instr in block.instructions:
        match instr:
            case (x = c) where c is constant:
                state[x] = c
            
            case (x = y) where state[y] is constant c:
                state[x] = c
            
            case (x = e):
                value = evalConstExpr(e, state)
                state[x] = value
    
    return state

function evalConstExpr(expr: Expr, state: State) -> Value:
    match expr:
        case n:
            return n
        
        case x:
            return state[x]
        
        case eâ‚ + eâ‚‚:
            vâ‚ = evalConstExpr(eâ‚, state)
            vâ‚‚ = evalConstExpr(eâ‚‚, state)
            if vâ‚ is constant and vâ‚‚ is constant:
                return vâ‚ + vâ‚‚
            else:
                return âŠ¤
        
        case eâ‚ * eâ‚‚:
            vâ‚ = evalConstExpr(eâ‚, state)
            vâ‚‚ = evalConstExpr(eâ‚‚, state)
            if vâ‚ is constant and vâ‚‚ is constant:
                return vâ‚ * vâ‚‚
            elif vâ‚ == 0 or vâ‚‚ == 0:
                return 0
            else:
                return âŠ¤

/* å¸¸é‡æ›¿æ¢ */

function replaceConstants(CFG, const_map):
    for block in CFG.blocks:
        for instr in block.instructions:
            for var in uses(instr):
                if const_map[var] is constant c:
                    instr.replace(var, c)
```

### 2.3 æ­£ç¡®æ€§è¯æ˜

```mathematical
/* å¸¸é‡æŠ˜å æ­£ç¡®æ€§è¯æ˜ */

å®šç† (Constant Folding Correctness):
âˆ€ expr e. âŸ¦eâŸ§ = âŸ¦constantFold(e)âŸ§

è¯æ˜ (å¯¹è¡¨è¾¾å¼ç»“æ„å½’çº³):

Base Case: e = n (å¸¸é‡)
  constantFold(n) = n
  âŸ¦nâŸ§ = n = âŸ¦constantFold(n)âŸ§ âœ“

Base Case: e = x (å˜é‡)
  constantFold(x) = x
  âŸ¦xâŸ§ = âŸ¦constantFold(x)âŸ§ âœ“

Inductive Case: e = eâ‚ + eâ‚‚
  å‡è®¾: âŸ¦eâ‚âŸ§ = âŸ¦constantFold(eâ‚)âŸ§
        âŸ¦eâ‚‚âŸ§ = âŸ¦constantFold(eâ‚‚)âŸ§
  
  è¦è¯: âŸ¦eâ‚ + eâ‚‚âŸ§ = âŸ¦constantFold(eâ‚ + eâ‚‚)âŸ§
  
  è®¾ eâ‚' = constantFold(eâ‚)
     eâ‚‚' = constantFold(eâ‚‚)
  
  Case 1: eâ‚' = nâ‚, eâ‚‚' = nâ‚‚ (éƒ½æ˜¯å¸¸é‡)
    constantFold(eâ‚ + eâ‚‚) = nâ‚ + nâ‚‚
    
    âŸ¦eâ‚ + eâ‚‚âŸ§ 
      = âŸ¦eâ‚âŸ§ + âŸ¦eâ‚‚âŸ§              (è¯­ä¹‰å®šä¹‰)
      = âŸ¦eâ‚'âŸ§ + âŸ¦eâ‚‚'âŸ§            (å½’çº³å‡è®¾)
      = nâ‚ + nâ‚‚                  (å¸¸é‡è¯­ä¹‰)
      = âŸ¦nâ‚ + nâ‚‚âŸ§                (å¸¸é‡è¯­ä¹‰)
      = âŸ¦constantFold(eâ‚ + eâ‚‚)âŸ§  âœ“
  
  Case 2: eâ‚'æˆ–eâ‚‚'ä¸æ˜¯å¸¸é‡
    constantFold(eâ‚ + eâ‚‚) = eâ‚' + eâ‚‚'
    
    âŸ¦eâ‚ + eâ‚‚âŸ§
      = âŸ¦eâ‚âŸ§ + âŸ¦eâ‚‚âŸ§
      = âŸ¦eâ‚'âŸ§ + âŸ¦eâ‚‚'âŸ§            (å½’çº³å‡è®¾)
      = âŸ¦eâ‚' + eâ‚‚'âŸ§              (è¯­ä¹‰å®šä¹‰)
      = âŸ¦constantFold(eâ‚ + eâ‚‚)âŸ§  âœ“

å…¶ä»–æƒ…å†µç±»ä¼¼ â–¡

/* å¸¸é‡ä¼ æ’­æ­£ç¡®æ€§è¯æ˜ */

å®šç† (Constant Propagation Correctness):
è®¾å¸¸é‡ä¼ æ’­è®¡ç®—å‡º x åœ¨ç¨‹åºç‚¹ p çš„å€¼ä¸ºå¸¸é‡ c,
åˆ™åœ¨æ‰€æœ‰åˆ°è¾¾ p çš„æ‰§è¡Œè·¯å¾„ä¸Š,x çš„å€¼éƒ½æ˜¯ cã€‚

è¯æ˜:
ä½¿ç”¨æ•°æ®æµåˆ†æçš„æ­£ç¡®æ€§æ¡†æ¶

1. å®šä¹‰æŠ½è±¡åŸŸ: Var â†’ {âŠ¥, Const, âŠ¤}
   âŠ¥ âŠ‘ c âŠ‘ âŠ¤ for all constants c

2. ä¼ é€’å‡½æ•°å•è°ƒ:
   sâ‚ âŠ‘ sâ‚‚ âŸ¹ transfer(B, sâ‚) âŠ‘ transfer(B, sâ‚‚)
   
   è¯æ˜: å¯¹æŒ‡ä»¤å½’çº³,ä¼ é€’å‡½æ•°ä¿æŒåºå…³ç³» âœ“

3. æ ¼æœ‰é™é«˜åº¦:
   é«˜åº¦ = 3 (âŠ¥, Const, âŠ¤)
   
   å› æ­¤ç®—æ³•å¿…ç»ˆæ­¢ âœ“

4. è¯­ä¹‰æ­£ç¡®æ€§:
   å¦‚æœåˆ†æå¾—å‡º state[x] = c,
   åˆ™ âˆ€ concrete execution reaching this point. x = c
   
   è¯æ˜: æŠ½è±¡è§£é‡Šçš„soundness âœ“

å› æ­¤å¸¸é‡ä¼ æ’­æ˜¯æ­£ç¡®çš„ â–¡
```

---

## ç¬¬ä¸‰éƒ¨åˆ†: æ­»ä»£ç æ¶ˆé™¤

### 3.1 æ­»ä»£ç å®šä¹‰

```mathematical
/* æ­»ä»£ç  (Dead Code) */

å®šä¹‰: ä»£ç æ˜¯æ­»çš„,å½“ä¸”ä»…å½“:

1. ä¸å¯è¾¾ä»£ç  (Unreachable Code):
   âˆ„ path from entry to this code

2. æ­»èµ‹å€¼ (Dead Store):
   x = e,å…¶ä¸­xåœ¨æ­¤åä¸ä½¿ç”¨

3. æ­»è®¡ç®— (Dead Computation):
   e,å…¶ä¸­eçš„ç»“æœä¸è¢«ä½¿ç”¨ä¸”æ— å‰¯ä½œç”¨

/* å½¢å¼åŒ–å®šä¹‰ */

[Dead-Unreachable]
Â¬reachable(B, entry)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
B is dead

[Dead-Store]
x = e at point p
âˆ€ path from p. x is redefined before used
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
x = e is dead

[Dead-Computation]
e at point p
no_side_effects(e)
âˆ€ path from p. result of e not used
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
e is dead

/* æ´»è·ƒå˜é‡å®šä¹‰ */

Live(x, p) âŸº âˆƒ path from p to some use of x,
              ä¸”è·¯å¾„ä¸Šxæœªè¢«é‡å®šä¹‰

Dead Store âŸº Â¬Live(x, after assignment)
```

### 3.2 æ¶ˆé™¤ç®—æ³•

```mathematical
/* æ­»ä»£ç æ¶ˆé™¤ç®—æ³• */

function eliminateDeadCode(CFG):
    // é˜¶æ®µ1: æ¶ˆé™¤ä¸å¯è¾¾ä»£ç 
    reachable = computeReachableBlocks(CFG)
    for block in CFG.blocks:
        if block not in reachable:
            CFG.remove(block)
    
    // é˜¶æ®µ2: æ¶ˆé™¤æ­»èµ‹å€¼
    IN, OUT = livenessAnalysis(CFG)
    
    for block in CFG.blocks:
        live = OUT[block].copy()
        
        for instr in reversed(block.instructions):
            match instr:
                case (x = e):
                    if x not in live:
                        // xä¸æ´»è·ƒ,åˆ é™¤èµ‹å€¼
                        block.remove(instr)
                    else:
                        // æ›´æ–°æ´»è·ƒé›†
                        live.remove(x)
                        live.update(uses(e))
                
                case (call f(...)):
                    // è°ƒç”¨å¯èƒ½æœ‰å‰¯ä½œç”¨,ä¿ç•™
                    live.update(uses(instr))
    
    // é˜¶æ®µ3: æ¶ˆé™¤æ­»è®¡ç®—
    for block in CFG.blocks:
        for instr in block.instructions:
            if isPureComputation(instr) and not isUsed(instr):
                block.remove(instr)

function computeReachableBlocks(CFG):
    reachable = set()
    worklist = [CFG.entry]
    
    while worklist:
        block = worklist.pop()
        if block not in reachable:
            reachable.add(block)
            worklist.extend(successors(block))
    
    return reachable

/* å‰¯ä½œç”¨æ£€æµ‹ */

function hasSideEffects(expr: Expr) -> bool:
    match expr:
        case n | x:
            return false  // å¸¸é‡å’Œå˜é‡æ— å‰¯ä½œç”¨
        
        case eâ‚ op eâ‚‚:
            return hasSideEffects(eâ‚) or hasSideEffects(eâ‚‚)
        
        case call f(...):
            return not isPure(f)  // å‡½æ•°å¯èƒ½æœ‰å‰¯ä½œç”¨
        
        case *p:
            return false  // è¯»å–æ— å‰¯ä½œç”¨
        
        case *p = e:
            return true  // å†™å…¥æœ‰å‰¯ä½œç”¨
        
        case ch <- e:
            return true  // channelå‘é€æœ‰å‰¯ä½œç”¨
        
        case <-ch:
            return true  // channelæ¥æ”¶æœ‰å‰¯ä½œç”¨
```

### 3.3 æ­£ç¡®æ€§è¯æ˜

```mathematical
/* æ­»ä»£ç æ¶ˆé™¤æ­£ç¡®æ€§ */

å®šç† (DCE Correctness):
è®¾ P' = DCE(P),åˆ™ âŸ¦PâŸ§ = âŸ¦P'âŸ§

è¯æ˜åˆ†ä¸‰éƒ¨åˆ†:

Part 1: ä¸å¯è¾¾ä»£ç æ¶ˆé™¤æ­£ç¡®æ€§

å¼•ç† 1: å¦‚æœä»£ç å— B ä¸å¯è¾¾,åˆ™åˆ é™¤Bä¸æ”¹å˜ç¨‹åºè¯­ä¹‰ã€‚

è¯æ˜:
è®¾ B âˆ‰ reachable(entry),åˆ™:
âˆ„ execution trace reaching B

å› æ­¤ B ä¸­çš„ä»£ç æ°¸ä¸æ‰§è¡Œ,
åˆ é™¤Bä¸æ”¹å˜ä»»ä½•å¯è§‚å¯Ÿè¡Œä¸ºã€‚ âœ“

Part 2: æ­»èµ‹å€¼æ¶ˆé™¤æ­£ç¡®æ€§

å¼•ç† 2: å¦‚æœ x = e æ˜¯æ­»èµ‹å€¼,åˆ™åˆ é™¤å®ƒä¸æ”¹å˜ç¨‹åºè¯­ä¹‰ã€‚

è¯æ˜:
è®¾ x = e at point p æ˜¯æ­»èµ‹å€¼,å³:
âˆ€ path from p. x is redefined before any use of x

æƒ…å†µ1: x åœ¨ä¹‹åæœªè¢«ä½¿ç”¨
  åˆ é™¤ x = e ä¸å½±å“ä»»ä½•è®¡ç®— âœ“

æƒ…å†µ2: x åœ¨ä½¿ç”¨å‰è¢«é‡å®šä¹‰ä¸º x = e'
  ä½¿ç”¨ç‚¹çœ‹åˆ°çš„æ˜¯ e' çš„å€¼,ä¸æ˜¯ e çš„å€¼
  åˆ é™¤ x = e ä¸å½±å“ä½¿ç”¨ç‚¹çš„å€¼ âœ“

å› æ­¤åˆ é™¤æ­»èµ‹å€¼æ˜¯å®‰å…¨çš„ â–¡

Part 3: æ­»è®¡ç®—æ¶ˆé™¤æ­£ç¡®æ€§

å¼•ç† 3: å¦‚æœè¡¨è¾¾å¼ e æ— å‰¯ä½œç”¨ä¸”ç»“æœä¸è¢«ä½¿ç”¨,
åˆ™åˆ é™¤ e çš„è®¡ç®—ä¸æ”¹å˜ç¨‹åºè¯­ä¹‰ã€‚

è¯æ˜:
no_side_effects(e) âŸ¹ 
  è®¡ç®—eä¸å½±å“å†…å­˜ã€I/Oç­‰å¤–éƒ¨çŠ¶æ€

result not used âŸ¹
  eçš„å€¼ä¸å½±å“åç»­è®¡ç®—

å› æ­¤åˆ é™¤eçš„è®¡ç®—æ˜¯å®‰å…¨çš„ âœ“

ç»¼åˆä¸‰éƒ¨åˆ†,DCEæ˜¯æ­£ç¡®çš„ â–¡

/* ä¿å®ˆæ€§åˆ†æ */

æ³¨æ„: DCEå¿…é¡»æ˜¯ä¿å®ˆçš„ (conservative):

1. å¯èƒ½æœ‰å‰¯ä½œç”¨çš„ä»£ç ä¸èƒ½åˆ é™¤
   - å‡½æ•°è°ƒç”¨ (é™¤éç¡®è®¤çº¯å‡½æ•°)
   - channelæ“ä½œ
   - å†…å­˜å†™å…¥
   - panic

2. Goç‰¹å®šè€ƒè™‘:
   - deferè¯­å¥ä¸èƒ½åˆ é™¤
   - goroutineåˆ›å»ºä¸èƒ½åˆ é™¤
   - initå‡½æ•°ä¸èƒ½åˆ é™¤

å®šç† (Conservativeness):
DCE never deletes code with observable effects

è¯æ˜: ç”±ç®—æ³•è®¾è®¡ä¿è¯ âœ“
```

---

## ç¬¬å››éƒ¨åˆ†: å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤

### 4.1 CSEå½¢å¼åŒ–

```mathematical
/* å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤ (CSE) */

å®šä¹‰: å¦‚æœè¡¨è¾¾å¼ e åœ¨ç¨‹åºä¸­å¤šæ¬¡è®¡ç®—ä¸”å€¼ä¸å˜,
åˆ™åªè®¡ç®—ä¸€æ¬¡,å¤ç”¨ç»“æœã€‚

/* å˜æ¢è§„åˆ™ */

[CSE-Rule]
e computed at pâ‚
e available at pâ‚‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
replace e at pâ‚‚ with temp,
where temp = e computed at pâ‚

/* å¯ç”¨è¡¨è¾¾å¼ */

Available(e, p) âŸº 
  âˆƒ path from some point q to p such that:
    - e is computed at q
    - variables in e are not modified on the path

/* CSEæ¡ä»¶ */

CSE is safe âŸº 
  1. e is available
  2. e is pure (no side effects)
  3. evaluation order preserved (for Go memory model)
```

### 4.2 å…¨å±€CSEç®—æ³•

```mathematical
/* Global CSE Algorithm */

function globalCSE(CFG):
    // é˜¶æ®µ1: å¯ç”¨è¡¨è¾¾å¼åˆ†æ
    avail_in, avail_out = availableExpressionsAnalysis(CFG)
    
    // é˜¶æ®µ2: ä¸ºæ¯ä¸ªè¡¨è¾¾å¼åˆ†é…ä¸´æ—¶å˜é‡
    expr_to_temp = {}
    
    for block in CFG.blocks:
        available = avail_in[block].copy()
        
        for instr in block.instructions:
            match instr:
                case (x = e):
                    expr_key = canonicalize(e)
                    
                    if expr_key in available:
                        // è¡¨è¾¾å¼å·²è®¡ç®—
                        if expr_key in expr_to_temp:
                            // å¤ç”¨ä¸´æ—¶å˜é‡
                            temp = expr_to_temp[expr_key]
                            replace_with(instr, x = temp)
                        else:
                            // åˆ›å»ºä¸´æ—¶å˜é‡
                            temp = fresh_temp()
                            dom_point = find_dominator_computation(expr_key, block)
                            insert_at(dom_point, temp = e)
                            replace_with(instr, x = temp)
                            expr_to_temp[expr_key] = temp
                    else:
                        // æ–°è¡¨è¾¾å¼
                        available.add(expr_key)
                        expr_to_temp[expr_key] = x
                    
                    // æ›´æ–°å¯ç”¨é›†
                    for var in defs(instr):
                        remove_exprs_using(available, var)

/* è¡¨è¾¾å¼è§„èŒƒåŒ– */

function canonicalize(expr: Expr) -> Key:
    // å°†è¡¨è¾¾å¼è½¬æ¢ä¸ºè§„èŒƒå½¢å¼
    match expr:
        case eâ‚ + eâ‚‚:
            // åŠ æ³•äº¤æ¢å¾‹: æ’åºæ“ä½œæ•°
            if eâ‚ > eâ‚‚:
                return canonicalize(eâ‚‚ + eâ‚)
            else:
                return ('+', canonicalize(eâ‚), canonicalize(eâ‚‚))
        
        case eâ‚ * eâ‚‚:
            // ä¹˜æ³•äº¤æ¢å¾‹
            if eâ‚ > eâ‚‚:
                return canonicalize(eâ‚‚ * eâ‚)
            else:
                return ('*', canonicalize(eâ‚), canonicalize(eâ‚‚))
        
        case x:
            return ('var', x)
        
        case n:
            return ('const', n)

/* æ”¯é…ç‚¹æŸ¥æ‰¾ */

function find_dominator_computation(expr_key: Key, block: Block) -> Point:
    // æ‰¾åˆ°expré¦–æ¬¡è®¡ç®—çš„æ”¯é…ç‚¹
    for pred_block in dom_tree_ancestors(block):
        if expr_key in generated_exprs(pred_block):
            return pred_block
    
    return entry_block
```

### 4.3 æ­£ç¡®æ€§è¯æ˜

```mathematical
/* CSEæ­£ç¡®æ€§è¯æ˜ */

å®šç† (CSE Correctness):
è®¾ P' = CSE(P),åˆ™ âŸ¦PâŸ§ = âŸ¦P'âŸ§

è¯æ˜:

è¦è¯æ˜: ç”¨ä¸´æ—¶å˜é‡æ›¿æ¢è¡¨è¾¾å¼æ˜¯å®‰å…¨çš„

è®¾åœ¨ç¨‹åºç‚¹ pâ‚‚ å¤„,è¡¨è¾¾å¼ e è¢«æ›¿æ¢ä¸ºä¸´æ—¶å˜é‡ temp,
å…¶ä¸­ temp åœ¨æ”¯é…ç‚¹ pâ‚ å¤„å®šä¹‰ä¸º temp = eã€‚

å‰ææ¡ä»¶:
1. pâ‚ dom pâ‚‚ (pâ‚ æ”¯é… pâ‚‚)
2. e åœ¨ pâ‚‚ å¯ç”¨ (available at pâ‚‚)
3. e æ˜¯çº¯è¡¨è¾¾å¼ (pure expression)

è¦è¯æ˜: 
åœ¨ pâ‚‚ å¤„,temp çš„å€¼ç­‰äº e çš„å€¼

è¯æ˜:
ç”± "e åœ¨ pâ‚‚ å¯ç”¨" çŸ¥:
âˆƒ path from pâ‚ to pâ‚‚ such that:
  - e åœ¨ pâ‚ è®¡ç®—: temp = e
  - e çš„æ“ä½œæ•°åœ¨è·¯å¾„ä¸Šæœªè¢«ä¿®æ”¹

è®¾ e çš„æ“ä½œæ•°ä¸º xâ‚, ..., xâ‚™

åœ¨ pâ‚ å¤„: temp = f(xâ‚^{pâ‚}, ..., xâ‚™^{pâ‚})
åœ¨ pâ‚‚ å¤„: e    = f(xâ‚^{pâ‚‚}, ..., xâ‚™^{pâ‚‚})

ç”± "æ“ä½œæ•°æœªä¿®æ”¹" çŸ¥:
âˆ€i. xáµ¢^{pâ‚} = xáµ¢^{pâ‚‚}

ç”± "e æ˜¯çº¯å‡½æ•°" çŸ¥:
f(xâ‚^{pâ‚}, ..., xâ‚™^{pâ‚}) = f(xâ‚^{pâ‚‚}, ..., xâ‚™^{pâ‚‚})

å› æ­¤:
temp^{pâ‚‚} = e^{pâ‚‚}

æ›¿æ¢æ˜¯å®‰å…¨çš„ âœ“

è¿›ä¸€æ­¥,ç”± pâ‚ dom pâ‚‚ çŸ¥:
æ‰€æœ‰ä» entry åˆ° pâ‚‚ çš„è·¯å¾„éƒ½ç»è¿‡ pâ‚,
å› æ­¤ temp åœ¨ pâ‚‚ å¤„å·²å®šä¹‰ã€‚ âœ“

ç»¼åˆ,CSE æ˜¯æ­£ç¡®çš„ â–¡

/* CSEä¸Goå†…å­˜æ¨¡å‹ */

é‡è¦: åœ¨Goä¸­,CSEå¿…é¡»ä¿æŒhappens-beforeå…³ç³»

å®šç† (CSE preserves Happens-Before):
CSEä¸æ”¹å˜happens-beforeå…³ç³»

è¯æ˜:
CSEåªåœ¨å•çº¿ç¨‹æ§åˆ¶æµä¸­ä¼˜åŒ–è¡¨è¾¾å¼è®¡ç®—ã€‚
ä¸æ¶‰åŠ:
- goroutineåˆ›å»º
- channelæ“ä½œ
- åŒæ­¥åŸè¯­

å› æ­¤happens-beforeå…³ç³»ä¸å˜ âœ“

æ³¨æ„: å¯¹äºå…±äº«å˜é‡,CSEå¿…é¡»ä¿å®ˆ:
å¦‚æœå˜é‡å¯èƒ½è¢«å¹¶å‘ä¿®æ”¹,åˆ™ä¸è¿›è¡ŒCSEã€‚
```

---

## ç¬¬äº”éƒ¨åˆ†: å¾ªç¯ä¼˜åŒ–

### 5.1 å¾ªç¯ä¸å˜ä»£ç å¤–æ

```mathematical
/* Loop-Invariant Code Motion (LICM) */

å®šä¹‰: å°†å¾ªç¯ä¸å˜çš„è®¡ç®—ç§»åˆ°å¾ªç¯å¤–

/* å¾ªç¯ä¸å˜æ€§ */

å®šä¹‰: è¡¨è¾¾å¼ e åœ¨å¾ªç¯ L ä¸­æ˜¯ä¸å˜çš„,å½“ä¸”ä»…å½“:
âˆ€ var âˆˆ vars(e). 
  (def(var) âˆ‰ L) âˆ¨ (def(var) is loop-invariant in L)

é€’å½’å®šä¹‰:
1. å¸¸é‡æ˜¯å¾ªç¯ä¸å˜çš„
2. å¾ªç¯å¤–å®šä¹‰çš„å˜é‡æ˜¯å¾ªç¯ä¸å˜çš„
3. å¾ªç¯ä¸å˜è¡¨è¾¾å¼çš„ç»„åˆæ˜¯å¾ªç¯ä¸å˜çš„

/* LICMç®—æ³• */

function loopInvariantCodeMotion(loop: Loop):
    // è®¡ç®—å¾ªç¯ä¸å˜è¡¨è¾¾å¼
    invariants = []
    
    repeat:
        changed = false
        for block in loop.blocks:
            for instr in block.instructions:
                if instr is (x = e):
                    if isLoopInvariant(e, loop, invariants):
                        if canHoist(instr, loop):
                            invariants.append(instr)
                            changed = true
    until not changed
    
    // å¤–æåˆ°preheader
    preheader = loop.preheader
    for instr in invariants:
        move_to(instr, preheader)

function isLoopInvariant(expr: Expr, loop: Loop, known_invariants) -> bool:
    match expr:
        case n:
            return true  // å¸¸é‡
        
        case x:
            def_point = definition_of(x)
            if def_point âˆ‰ loop:
                return true  // å¾ªç¯å¤–å®šä¹‰
            elif def_point in known_invariants:
                return true  // å·²çŸ¥ä¸å˜
            else:
                return false
        
        case eâ‚ op eâ‚‚:
            return isLoopInvariant(eâ‚, loop, known_invariants) and
                   isLoopInvariant(eâ‚‚, loop, known_invariants)

function canHoist(instr: Instr, loop: Loop) -> bool:
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥å®‰å…¨å¤–æ
    
    # 1. æŒ‡ä»¤å¿…é¡»æ”¯é…æ‰€æœ‰å¾ªç¯å‡ºå£
    for exit in loop.exits:
        if not dominates(instr.block, exit):
            return false
    
    # 2. å®šä¹‰çš„å˜é‡å¿…é¡»åªåœ¨å¾ªç¯å†…ä½¿ç”¨
    x = instr.defines
    for use in uses_of(x):
        if use âˆ‰ loop:
            return false
    
    # 3. æ²¡æœ‰å‰¯ä½œç”¨
    if has_side_effects(instr):
        return false
    
    return true
```

### 5.2 å¾ªç¯å±•å¼€

```mathematical
/* Loop Unrolling */

å®šä¹‰: å¤åˆ¶å¾ªç¯ä½“,å‡å°‘å¾ªç¯æ§åˆ¶å¼€é”€

/* å®Œå…¨å±•å¼€ */

é€‚ç”¨æ¡ä»¶: å¾ªç¯æ¬¡æ•°ç¼–è¯‘æ—¶å·²çŸ¥

ç¤ºä¾‹:
// åŸå¾ªç¯
for i = 0; i < 3; i++:
    a[i] = b[i] * c[i]

// å®Œå…¨å±•å¼€
a[0] = b[0] * c[0]
a[1] = b[1] * c[1]
a[2] = b[2] * c[2]

/* éƒ¨åˆ†å±•å¼€ */

é€‚ç”¨æ¡ä»¶: å¾ªç¯æ¬¡æ•°è¿è¡Œæ—¶ç¡®å®š,ä½†è¾ƒå¤§

function loopUnrolling(loop: Loop, factor: int):
    header = loop.header
    body = loop.body
    
    // 1. åˆ›å»ºå±•å¼€çš„å¾ªç¯ä½“
    unrolled_body = []
    for i in 0..factor:
        body_copy = duplicate(body, offset=i)
        unrolled_body.append(body_copy)
    
    // 2. æ›´æ–°å¾ªç¯æ§åˆ¶
    new_loop = Loop{
        header: header,
        body: unrolled_body,
        step: loop.step * factor
    }
    
    // 3. å¤„ç†å‰©ä½™è¿­ä»£
    remainder_loop = createRemainderLoop(loop, factor)
    
    replace(loop, [new_loop, remainder_loop])

ç¤ºä¾‹ (factor=4):
// åŸå¾ªç¯
for i = 0; i < n; i++:
    a[i] = b[i] + c[i]

// å±•å¼€å
for i = 0; i < n-3; i += 4:
    a[i]   = b[i]   + c[i]
    a[i+1] = b[i+1] + c[i+1]
    a[i+2] = b[i+2] + c[i+2]
    a[i+3] = b[i+3] + c[i+3]

// å¤„ç†å‰©ä½™
for i = (n/4)*4; i < n; i++:
    a[i] = b[i] + c[i]

/* å±•å¼€æ•ˆæœ */

ä¼˜åŠ¿:
1. å‡å°‘å¾ªç¯æ§åˆ¶æŒ‡ä»¤
2. å¢åŠ æŒ‡ä»¤çº§å¹¶è¡Œ
3. æ›´å¥½åˆ©ç”¨å¯„å­˜å™¨

æƒè¡¡:
- ä»£ç å¤§å°å¢åŠ 
- æŒ‡ä»¤ç¼“å­˜å‹åŠ›
- ç¼–è¯‘æ—¶é—´å¢åŠ 
```

### 5.3 æ­£ç¡®æ€§è¯æ˜

```mathematical
/* LICMæ­£ç¡®æ€§è¯æ˜ */

å®šç† (LICM Correctness):
å°†å¾ªç¯ä¸å˜ä»£ç ç§»åˆ°å¾ªç¯å¤–æ˜¯æ­£ç¡®çš„

è¯æ˜:

è®¾æŒ‡ä»¤ I: x = e æ˜¯å¾ªç¯ä¸å˜çš„,ä¸”æ»¡è¶³å¤–ææ¡ä»¶ã€‚

è¦è¯æ˜: å°† I ç§»åˆ°preheaderä¸æ”¹å˜ç¨‹åºè¯­ä¹‰

æƒ…å†µ1: å¾ªç¯æ‰§è¡Œ0æ¬¡
  åŸç¨‹åº: I ä¸æ‰§è¡Œ
  ä¼˜åŒ–å: I åœ¨preheaderæ‰§è¡Œä¸€æ¬¡
  
  ä½†xåœ¨å¾ªç¯åæœªä½¿ç”¨ (å¦åˆ™ä¸æ»¡è¶³å¤–ææ¡ä»¶)
  å› æ­¤é¢å¤–è®¡ç®—ä¸å½±å“å¯è§‚å¯Ÿè¡Œä¸º âœ“

æƒ…å†µ2: å¾ªç¯æ‰§è¡Œkæ¬¡ (k > 0)
  åŸç¨‹åº: I åœ¨æ¯æ¬¡è¿­ä»£æ‰§è¡Œ,è®¡ç®—ç›¸åŒå€¼
  ä¼˜åŒ–å: I åœ¨preheaderæ‰§è¡Œä¸€æ¬¡
  
  ç”±"å¾ªç¯ä¸å˜æ€§":
  âˆ€ iteration i. value of e is same
  
  ç”±"æ”¯é…æ€§":
  preheaderæ”¯é…æ‰€æœ‰å¾ªç¯å†…xçš„ä½¿ç”¨
  
  å› æ­¤xçš„ä½¿ç”¨çœ‹åˆ°ç›¸åŒçš„å€¼ âœ“

è¿›ä¸€æ­¥,å‰¯ä½œç”¨ä¿æŒ:
ç”±"no side effects"æ¡ä»¶,
I çš„ç§»åŠ¨ä¸å½±å“å¤–éƒ¨çŠ¶æ€ âœ“

ç»¼åˆ,LICMæ˜¯æ­£ç¡®çš„ â–¡

/* å¾ªç¯å±•å¼€æ­£ç¡®æ€§ */

å®šç† (Loop Unrolling Correctness):
å¾ªç¯å±•å¼€ä¿æŒç¨‹åºè¯­ä¹‰

è¯æ˜:

è®¾åŸå¾ªç¯è¿­ä»£næ¬¡,å±•å¼€å› å­ä¸ºkã€‚

å°†å¾ªç¯åˆ†ä¸ºä¸¤éƒ¨åˆ†:
1. ä¸»å¾ªç¯: n/k æ¬¡ (æ¯æ¬¡æ‰§è¡Œkä¸ªè¿­ä»£)
2. å‰©ä½™å¾ªç¯: n mod k æ¬¡

è¦è¯æ˜: æ‰§è¡Œç›¸åŒæ¬¡æ•°çš„å¾ªç¯ä½“

åŸå¾ªç¯:
for i in 0..n:
  body(i)

å±•å¼€å:
for i in 0..n/k:
  body(i*k)
  body(i*k+1)
  ...
  body(i*k+k-1)

for i in (n/k)*k..n:
  body(i)

æ€»æ‰§è¡Œæ¬¡æ•°:
(n/k) * k + (n mod k) = n âœ“

è¿­ä»£é¡ºåºä¿æŒ:
å±•å¼€åæŒ‰ 0, 1, 2, ..., n-1 é¡ºåºæ‰§è¡Œ âœ“

å› æ­¤å¾ªç¯å±•å¼€æ˜¯æ­£ç¡®çš„ â–¡

/* Goç‰¹å®šè€ƒè™‘ */

åœ¨Goä¸­,å¾ªç¯ä¼˜åŒ–å¿…é¡»æ³¨æ„:

1. é—­åŒ…æ•è·:
   for i := range items:
       go func():
           use(i)  // æ•è·i
   
   å±•å¼€å¯èƒ½æ”¹å˜æ•è·è¯­ä¹‰!

2. deferæ‰§è¡Œ:
   for ...:
       defer cleanup()
   
   å±•å¼€ådeferæ‰§è¡Œæ¬¡æ•°ç›¸åŒ âœ“

3. panic:
   for ...:
       might_panic()
   
   å±•å¼€ä¸æ”¹å˜panicå‘ç”Ÿæ¬¡æ•° âœ“
```

---

## ç¬¬å…­éƒ¨åˆ†: å†…è”ä¼˜åŒ–

### 6.1 å†…è”å½¢å¼åŒ–

```mathematical
/* Function Inlining */

å®šä¹‰: å°†å‡½æ•°è°ƒç”¨æ›¿æ¢ä¸ºå‡½æ•°ä½“

å˜æ¢è§„åˆ™:

[Inline]
caller:
  ...
  y = f(x)
  ...

callee:
  func f(param):
      body
      return result
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
caller:
  ...
  temp_param = x
  body[param â† temp_param]
  y = result
  ...

/* å†…è”æ¡ä»¶ */

å¯ä»¥å†…è” âŸº
  1. å‡½æ•°è¶³å¤Ÿå° (å°äºé˜ˆå€¼)
  2. è°ƒç”¨ä¸é¢‘ç¹ (é¿å…ä»£ç è†¨èƒ€)
  3. æ— é€’å½’è°ƒç”¨
  4. æ— å¤æ‚æ§åˆ¶æµ (goto, deferç­‰å¯å¤„ç†)

/* Goå†…è”å¯å‘å¼ */

InlineCost = 
  + num_instructions * weight_instr
  + num_calls * weight_call
  + num_loops * weight_loop
  - num_constants * weight_const

if InlineCost < threshold:
    inline function
```

### 6.2 å†…è”å†³ç­–

```mathematical
/* Goç¼–è¯‘å™¨å†…è”å†³ç­– */

const (
    InlineMaxBudget    = 80   // æŒ‡ä»¤é¢„ç®—
    InlineExtraCallCost = 20   // é¢å¤–è°ƒç”¨å¼€é”€
    InlineLoopPenalty  = 30   // å¾ªç¯æƒ©ç½š
)

function shouldInline(fn: Function) -> bool:
    cost = computeInlineCost(fn)
    
    if cost > InlineMaxBudget:
        return false
    
    if isRecursive(fn):
        return false
    
    if hasComplexControl(fn):
        return false
    
    // å°å‡½æ•°æ€»æ˜¯å†…è”
    if cost < 10:
        return true
    
    // å¶å­å‡½æ•°æ›´å€¾å‘å†…è”
    if isLeafFunction(fn):
        return true
    
    return cost < InlineMaxBudget

function computeInlineCost(fn: Function) -> int:
    cost = 0
    
    for instr in fn.instructions:
        match instr:
            case assign | binop:
                cost += 1
            
            case call:
                cost += 20  // è°ƒç”¨æ˜‚è´µ
            
            case loop:
                cost += 30  // å¾ªç¯æƒ©ç½š
            
            case if:
                cost += 2
    
    return cost

/* å†…è”æ•ˆæœ */

Benefits:
1. æ¶ˆé™¤è°ƒç”¨å¼€é”€
2. å…è®¸æ›´å¤šä¼˜åŒ– (å¸¸é‡ä¼ æ’­, CSEç­‰)
3. æ›´å¥½çš„å¯„å­˜å™¨åˆ†é…

Costs:
1. ä»£ç å¤§å°å¢åŠ 
2. æŒ‡ä»¤ç¼“å­˜å‹åŠ›
3. ç¼–è¯‘æ—¶é—´å¢åŠ 

/* å†…è”ä¼˜å…ˆçº§ */

Priority:
1. å°å‡½æ•° (< 10 instructions)
2. çƒ­è·¯å¾„ä¸Šçš„å‡½æ•° (profiling guided)
3. å¶å­å‡½æ•°
4. åŒ…å†…å‡½æ•° (cross-package inliningé™åˆ¶)

/* é€’å½’å†…è” */

å¯¹äºé€’å½’å‡½æ•°,å¯ä»¥æœ‰é™å†…è”:

function recursiveInline(fn: Function, depth: int):
    if depth > maxDepth:
        return  // ä¿ç•™è°ƒç”¨
    
    // å†…è”ä¸€å±‚
    inline(fn)
    
    // é€’å½’å†…è”å†…éƒ¨è°ƒç”¨
    for call in fn.calls:
        if call.target == fn:
            recursiveInline(call.target, depth+1)
```

### 6.3 æ­£ç¡®æ€§è¯æ˜

```mathematical
/* å†…è”æ­£ç¡®æ€§è¯æ˜ */

å®šç† (Inlining Correctness):
å†…è”å˜æ¢ä¿æŒç¨‹åºè¯­ä¹‰

è¯æ˜:

è®¾è°ƒç”¨ç‚¹:
y = f(x)

å‡½æ•°å®šä¹‰:
func f(p: T) -> T':
    body
    return e

å†…è”å:
temp_p = x
body[p â† temp_p]
y = e[p â† temp_p]

è¦è¯æ˜: ä¸¤è€…è¯­ä¹‰ç­‰ä»·

åŸç¨‹åºè¯­ä¹‰:
âŸ¦y = f(x)âŸ§Ïƒ = Ïƒ[y â†¦ âŸ¦fâŸ§(âŸ¦xâŸ§Ïƒ)]

å…¶ä¸­ âŸ¦fâŸ§(v) = 
  let Ïƒ' = Ïƒ_initial[p â†¦ v] in
  let Ïƒ'' = âŸ¦bodyâŸ§Ïƒ' in
  âŸ¦eâŸ§Ïƒ''

å†…è”åè¯­ä¹‰:
âŸ¦temp_p = x; body[p â† temp_p]; y = e[p â† temp_p]âŸ§Ïƒ
  = let Ïƒâ‚ = Ïƒ[temp_p â†¦ âŸ¦xâŸ§Ïƒ] in
    let Ïƒâ‚‚ = âŸ¦body[p â† temp_p]âŸ§Ïƒâ‚ in
    Ïƒâ‚‚[y â†¦ âŸ¦e[p â† temp_p]âŸ§Ïƒâ‚‚]

ç”±æ›¿æ¢å¼•ç†:
âŸ¦body[p â† temp_p]âŸ§Ïƒâ‚ = âŸ¦bodyâŸ§(Ïƒâ‚ where temp_p plays role of p)

å› æ­¤:
Ïƒâ‚‚ = âŸ¦bodyâŸ§Ïƒ[p â†¦ âŸ¦xâŸ§Ïƒ]  (å¿½ç•¥temp_p)

ç±»ä¼¼åœ°:
âŸ¦e[p â† temp_p]âŸ§Ïƒâ‚‚ = âŸ¦eâŸ§Ïƒâ‚‚

å› æ­¤å†…è”å:
Ïƒâ‚‚[y â†¦ âŸ¦eâŸ§Ïƒâ‚‚] = Ïƒ[y â†¦ âŸ¦fâŸ§(âŸ¦xâŸ§Ïƒ)]

ä¸¤è€…ç›¸ç­‰ âœ“

/* Goç‰¹å®šè€ƒè™‘ */

1. Deferè¯­å¥:
   å†…è”åŒ…å«deferçš„å‡½æ•°éœ€è¦ç‰¹æ®Šå¤„ç†
   
   func f():
       defer cleanup()
       body
   
   å†…è”åéœ€è¦ä¿æŒdeferè¯­ä¹‰ âœ“

2. Namedè¿”å›å€¼:
   func f() (result int):
       result = 42
       return
   
   å†…è”æ—¶éœ€è¦é‡å‘½åé¿å…å†²çª âœ“

3. é—­åŒ…:
   å†…è”é—­åŒ…éœ€è¦æ­£ç¡®å¤„ç†æ•è·å˜é‡
   
   è¯æ˜: é€šè¿‡ç¯å¢ƒä¼ é€’ä¿æŒæ•è·è¯­ä¹‰ âœ“

ç»¼åˆ,å†…è”æ˜¯æ­£ç¡®çš„ â–¡
```

---

## ç¬¬ä¸ƒéƒ¨åˆ†: é€ƒé€¸åˆ†æ

### 7.1 é€ƒé€¸åˆ†æç†è®º

```mathematical
/* Escape Analysis */

å®šä¹‰: ç¡®å®šå¯¹è±¡æ˜¯å¦é€ƒé€¸åˆ°å †

å¯¹è±¡é€ƒé€¸ âŸº 
  å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸè¶…è¿‡å…¶åˆ†é…çš„ä½œç”¨åŸŸ

/* é€ƒé€¸æƒ…å†µ */

1. è¿”å›æŒ‡é’ˆ:
   func f() *int:
       x := 42
       return &x  // xé€ƒé€¸

2. èµ‹å€¼ç»™å…¨å±€å˜é‡:
   var global *int
   func f():
       x := 42
       global = &x  // xé€ƒé€¸

3. å‘é€åˆ°channel:
   func f(ch chan *int):
       x := 42
       ch <- &x  // xé€ƒé€¸

4. é—­åŒ…æ•è·:
   func f() func():
       x := 42
       return func():
           println(x)  // xé€ƒé€¸

/* é€ƒé€¸åˆ†æç›®æ ‡ */

æ ˆåˆ†é… vs å †åˆ†é…:
- æ ˆåˆ†é…: å¿«é€Ÿ, æ— GCå¼€é”€
- å †åˆ†é…: æ…¢é€Ÿ, éœ€è¦GC

ç›®æ ‡: å°½å¯èƒ½æ ˆåˆ†é…
```

### 7.2 Goé€ƒé€¸åˆ†æç®—æ³•

```mathematical
/* Go Escape Analysis Algorithm */

EscapeGraph = (Nodes, Edges)

Node ::= Variable | Parameter | Return | Heap

Edge ::= Flows | Contains

function escapeAnalysis(fn: Function):
    // æ„å»ºé€ƒé€¸å›¾
    graph = buildEscapeGraph(fn)
    
    // æ ‡è®°é€ƒé€¸èŠ‚ç‚¹
    heap_reachable = findHeapReachable(graph)
    
    // å†³ç­–åˆ†é…ä½ç½®
    for var in fn.variables:
        if var in heap_reachable:
            allocate(var, heap)
        else:
            allocate(var, stack)

function buildEscapeGraph(fn: Function) -> Graph:
    graph = Graph()
    
    // æ·»åŠ èŠ‚ç‚¹
    for var in fn.variables:
        graph.add_node(var)
    
    // æ·»åŠ è¾¹
    for instr in fn.instructions:
        match instr:
            case (x = &y):
                // xæŒ‡å‘y,yçš„å†…å®¹æµå‘x
                graph.add_edge(y, x, Flows)
            
            case (x = y):
                // yæµå‘x
                graph.add_edge(y, x, Flows)
            
            case (*x = y):
                // yæµå‘xæŒ‡å‘çš„ä½ç½®
                graph.add_edge(y, deref(x), Flows)
            
            case (return x):
                // xæµå‘è¿”å›å€¼(å¯èƒ½é€ƒé€¸)
                graph.add_edge(x, RETURN, Flows)
            
            case (send ch, x):
                // xæµå‘heap (channelå¯èƒ½ä¿å­˜)
                graph.add_edge(x, HEAP, Flows)
    
    return graph

function findHeapReachable(graph: Graph) -> Set[Node]:
    // ä»HEAPå’ŒRETURNåå‘å¯è¾¾çš„èŠ‚ç‚¹éƒ½é€ƒé€¸
    reachable = set()
    worklist = [HEAP, RETURN]
    
    while worklist:
        node = worklist.pop()
        if node not in reachable:
            reachable.add(node)
            # åå‘éå†
            for pred in predecessors(node, graph):
                worklist.append(pred)
    
    return reachable

/* è¿‡ç¨‹é—´åˆ†æ */

function interprocedural_escape_analysis():
    // ä»å¶å­å‡½æ•°å¼€å§‹,å‘ä¸Šä¼ æ’­é€ƒé€¸ä¿¡æ¯
    
    for fn in reverse_call_graph_order:
        for param in fn.parameters:
            if param escapes in fn:
                mark_escapes_at_call_sites(fn, param)
```

### 7.3 æ ˆåˆ†é…ä¼˜åŒ–

```mathematical
/* æ ˆåˆ†é…ä¼˜åŒ–æ•ˆæœ */

ç¤ºä¾‹:
// æœªä¼˜åŒ–
func f() *int:
    x := new(int)  // å †åˆ†é…
    *x = 42
    return x

// å†…è”å
func caller():
    x := f()       // xé€ƒé€¸åˆ°å †
    use(*x)

// é€ƒé€¸åˆ†æ+å†…è”
func caller():
    var x int      // æ ˆåˆ†é…!
    x = 42
    use(x)

æ€§èƒ½æå‡:
- å †åˆ†é…: ~100ns + GCå¼€é”€
- æ ˆåˆ†é…: ~1ns
- æå‡ ~100Ã—

/* æ ˆåˆ†é…æ¡ä»¶ */

å¯ä»¥æ ˆåˆ†é… âŸº
  1. å¯¹è±¡ä¸é€ƒé€¸
  2. å¯¹è±¡å¤§å°å·²çŸ¥ä¸”ä¸å¤ªå¤§
  3. å¯¹è±¡ç”Ÿå‘½å‘¨æœŸåœ¨å‡½æ•°å†…

/* Go 1.25.3ä¼˜åŒ– */

å¢å¼º:
1. æ›´ç²¾ç¡®çš„é€ƒé€¸åˆ†æ
2. éƒ¨åˆ†é€ƒé€¸ä¼˜åŒ– (åªé€ƒé€¸éƒ¨åˆ†å­—æ®µ)
3. åŸºäºPGOçš„é€ƒé€¸å†³ç­–

æ•ˆæœ:
- å‡å°‘å †åˆ†é… ~20%
- GCæš‚åœå‡å°‘ ~15%
- ååæå‡ ~10%

/* æ­£ç¡®æ€§è¯æ˜ */

å®šç† (Stack Allocation Safety):
å¦‚æœé€ƒé€¸åˆ†æåˆ¤å®šå¯¹è±¡ä¸é€ƒé€¸,
åˆ™æ ˆåˆ†é…æ˜¯å®‰å…¨çš„ã€‚

è¯æ˜:
ä¸é€ƒé€¸ âŸ¹ 
  å¯¹è±¡ç”Ÿå‘½å‘¨æœŸ âŠ† å‡½æ•°ç”Ÿå‘½å‘¨æœŸ âŸ¹
  å‡½æ•°è¿”å›å‰å¯¹è±¡ä¸è¢«è®¿é—® âŸ¹
  æ ˆå›æ”¶æ—¶å¯¹è±¡ä¸è¢«è®¿é—® âŸ¹
  æ ˆåˆ†é…å®‰å…¨ âœ“
```

---

## ç¬¬å…«éƒ¨åˆ†: è¾¹ç•Œæ£€æŸ¥æ¶ˆé™¤

### 8.1 BCEç†è®º

```mathematical
/* Bounds Check Elimination (BCE) */

å®šä¹‰: æ¶ˆé™¤ä¸å¿…è¦çš„æ•°ç»„/åˆ‡ç‰‡è¾¹ç•Œæ£€æŸ¥

/* è¾¹ç•Œæ£€æŸ¥ */

array/slice access: a[i]

éšå¼æ£€æŸ¥:
if i < 0 or i >= len(a):
    panic("index out of range")

ç›®æ ‡: è¯æ˜æ£€æŸ¥æ€»æ˜¯æˆåŠŸ,ä»è€Œæ¶ˆé™¤

/* BCEæ¡ä»¶ */

å¯ä»¥æ¶ˆé™¤ a[i] çš„è¾¹ç•Œæ£€æŸ¥ âŸº
  ç¼–è¯‘å™¨èƒ½è¯æ˜: 0 â‰¤ i < len(a)

æ–¹æ³•:
1. å¸¸é‡ç´¢å¼•
2. å¾ªç¯å½’çº³å˜é‡
3. åŒºé—´åˆ†æ
4. ç›¸å…³æ£€æŸ¥æ¶ˆé™¤
```

### 8.2 BCEç®—æ³•

```mathematical
/* BCE Algorithm */

function boundsCheckElimination(CFG):
    // é˜¶æ®µ1: åŒºé—´åˆ†æ
    intervals = intervalAnalysis(CFG)
    
    // é˜¶æ®µ2: è¯†åˆ«å¯æ¶ˆé™¤çš„æ£€æŸ¥
    for block in CFG.blocks:
        for instr in block.instructions:
            match instr:
                case (x = a[i]):
                    // æ£€æŸ¥içš„åŒºé—´
                    i_interval = intervals[i]
                    len_a = length(a)
                    
                    if provable_safe(i_interval, len_a):
                        remove_check(instr)

function provable_safe(interval: Interval, len: int) -> bool:
    // æ£€æŸ¥åŒºé—´æ˜¯å¦åœ¨ç•Œå†…
    return interval.lower >= 0 and interval.upper < len

/* å¸¸é‡ä¼ æ’­BCE */

ç¤ºä¾‹1: å¸¸é‡ç´¢å¼•
a := []int{1, 2, 3}
x := a[1]  // 1 < 3, æ£€æŸ¥å¯æ¶ˆé™¤ âœ“

/* å¾ªç¯å½’çº³å˜é‡BCE */

ç¤ºä¾‹2: rangeå¾ªç¯
for i := range a:
    x := a[i]  // i âˆˆ [0, len(a)), æ£€æŸ¥å¯æ¶ˆé™¤ âœ“

/* ç›¸å…³æ£€æŸ¥æ¶ˆé™¤ */

ç¤ºä¾‹3:
if i >= 0 && i < len(a):
    x := a[i]  // æ£€æŸ¥å·²åš,å¯æ¶ˆé™¤ âœ“

ç¤ºä¾‹4:
x := a[i]
y := a[i]  // ç¬¬äºŒæ¬¡è®¿é—®,æ£€æŸ¥å¯æ¶ˆé™¤ âœ“

/* å¤æ‚æƒ…å†µ */

function advancedBCE(CFG):
    // ä½¿ç”¨ç¬¦å·æ‰§è¡Œè¯æ˜å®‰å…¨æ€§
    
    for block in CFG.blocks:
        constraints = []  // è·¯å¾„çº¦æŸ
        
        for instr in block.instructions:
            match instr:
                case (if cond: ...):
                    constraints.append(cond)
                
                case (x = a[i]):
                    // æ£€æŸ¥æ˜¯å¦èƒ½ä»çº¦æŸæ¨å¯¼å‡º 0 â‰¤ i < len(a)
                    if SMT_prove(constraints, 0 <= i < len(a)):
                        remove_check(instr)

/* Goç‰¹å®šä¼˜åŒ– */

Go 1.25.3 BCEå¢å¼º:
1. æ›´å¼ºçš„åŒºé—´åˆ†æ
2. æ”¯æŒæ›´å¤šæ¨¡å¼:
   - for i := 0; i < n && i < len(a); i++
   - if i < len(a) { ... a[i] ... }
3. è·¨åŸºæœ¬å—åˆ†æ
```

### 8.3 æ­£ç¡®æ€§è¯æ˜

```mathematical
/* BCEæ­£ç¡®æ€§è¯æ˜ */

å®šç† (BCE Soundness):
å¦‚æœBCEæ¶ˆé™¤äº†è¾¹ç•Œæ£€æŸ¥,
åˆ™è®¿é—®ä¸ä¼šè¶Šç•Œã€‚

è¯æ˜:

è®¾ BCE æ¶ˆé™¤äº†æŒ‡ä»¤ x = a[i] çš„è¾¹ç•Œæ£€æŸ¥ã€‚

æ ¹æ®ç®—æ³•,è¿™æ„å‘³ç€:
provable_safe(interval[i], len(a)) = true

å³:
interval[i].lower â‰¥ 0 âˆ§ interval[i].upper < len(a)

ç”±åŒºé—´åˆ†æçš„æ­£ç¡®æ€§:
âˆ€ concrete execution reaching this point.
  i âˆˆ interval[i]

å› æ­¤:
0 â‰¤ i < len(a)

æ•…è®¿é—® a[i] å®‰å…¨,æ£€æŸ¥å¯æ¶ˆé™¤ âœ“

/* ä¿å®ˆæ€§ */

å®šç† (BCE Conservativeness):
BCEä¸ä¼šé”™è¯¯åœ°æ¶ˆé™¤å¿…è¦çš„æ£€æŸ¥ã€‚

è¯æ˜:
BCEåªåœ¨èƒ½è¯æ˜å®‰å…¨æ—¶æ‰æ¶ˆé™¤æ£€æŸ¥ã€‚
å¦‚æœä¸èƒ½è¯æ˜,ä¿ç•™æ£€æŸ¥ (ä¿å®ˆ)ã€‚

å› æ­¤BCEæ˜¯soundä¸”conservative âœ“

/* æ€§èƒ½å½±å“ */

è¾¹ç•Œæ£€æŸ¥å¼€é”€:
- æ£€æŸ¥: 2-3æ¡æŒ‡ä»¤
- åˆ†æ”¯é¢„æµ‹å¤±è´¥æƒ©ç½š: ~10-20 cycles
- çƒ­è·¯å¾„ç´¯ç§¯å½±å“æ˜¾è‘—

BCEæ•ˆæœ:
- å¾ªç¯ä¸­æ¶ˆé™¤æ£€æŸ¥: ~5-10% æå‡
- æ•°ç»„å¯†é›†å‹ä»£ç : ~15-20% æå‡

/* Go 1.25.3 BCEç¤ºä¾‹ */

// ç¤ºä¾‹1: range loop
func sum(a []int) int {
    s := 0
    for i := range a {
        s += a[i]  // BCE: æ£€æŸ¥æ¶ˆé™¤ âœ“
    }
    return s
}

// ç¤ºä¾‹2: guarded access
func get(a []int, i int) int {
    if i >= 0 && i < len(a) {
        return a[i]  // BCE: æ£€æŸ¥æ¶ˆé™¤ âœ“
    }
    return 0
}

// ç¤ºä¾‹3: related checks
func copy(dst, src []int) {
    for i := 0; i < len(dst) && i < len(src); i++ {
        dst[i] = src[i]  // BCE: ä¸¤ä¸ªæ£€æŸ¥éƒ½æ¶ˆé™¤ âœ“
    }
}

// ç¤ºä¾‹4: constant indexing
func access() {
    a := [5]int{1, 2, 3, 4, 5}
    x := a[2]  // BCE: æ£€æŸ¥æ¶ˆé™¤ âœ“
}
```

---

## ğŸ¯ æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†Goç¼–è¯‘å™¨ä¼˜åŒ–çš„å®Œæ•´å½¢å¼åŒ–è¯æ˜ä½“ç³»:

### æ ¸å¿ƒå†…å®¹

1. **ä¼˜åŒ–æ­£ç¡®æ€§ç†è®º**
   - è¯­ä¹‰ç­‰ä»·
   - å®‰å…¨æ€§æ¡ä»¶
   - éªŒè¯æ–¹æ³•

2. **åŸºæœ¬ä¼˜åŒ–**
   - å¸¸é‡æŠ˜å ä¸ä¼ æ’­
   - æ­»ä»£ç æ¶ˆé™¤
   - å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤

3. **å¾ªç¯ä¼˜åŒ–**
   - å¾ªç¯ä¸å˜ä»£ç å¤–æ
   - å¾ªç¯å±•å¼€
   - æ­£ç¡®æ€§è¯æ˜

4. **å‡½æ•°ä¼˜åŒ–**
   - å†…è”
   - é€ƒé€¸åˆ†æ
   - æ ˆåˆ†é…

5. **Goç‰¹å®šä¼˜åŒ–**
   - è¾¹ç•Œæ£€æŸ¥æ¶ˆé™¤
   - å†…å­˜æ¨¡å‹ä¿æŒ
   - å¹¶å‘å®‰å…¨æ€§

### ç†è®ºè´¡çŒ®

- ä¸ºæ¯ç§ä¼˜åŒ–æä¾›å½¢å¼åŒ–å®šä¹‰
- ç»™å‡ºç®—æ³•çš„æ­£ç¡®æ€§è¯æ˜
- åˆ†æä¼˜åŒ–çš„å®‰å…¨æ€§æ¡ä»¶

### å·¥ç¨‹ä»·å€¼

- æŒ‡å¯¼ç¼–è¯‘å™¨å®ç°
- éªŒè¯ä¼˜åŒ–æ­£ç¡®æ€§
- ç†è§£æ€§èƒ½æå‡æ¥æº

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**åŸºå‡†æ—¥æœŸ**: 2025å¹´10æœˆ23æ—¥  
**Goç‰ˆæœ¬**: Go 1.25.3  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ

---

<div align="center">

Made with â¤ï¸ for Go Compiler Researchers

[â¬† å›åˆ°é¡¶éƒ¨](#goç¼–è¯‘å™¨ä¼˜åŒ–å½¢å¼åŒ–è¯æ˜)

</div>
