# Goå¼€æºç”Ÿæ€ç³»ç»Ÿå½¢å¼åŒ–åˆ†æä¸æ¶æ„ç ”ç©¶

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0
**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.25.3

---

## ğŸ“‹ ç›®å½•

- [Goå¼€æºç”Ÿæ€ç³»ç»Ÿå½¢å¼åŒ–åˆ†æä¸æ¶æ„ç ”ç©¶](#goå¼€æºç”Ÿæ€ç³»ç»Ÿå½¢å¼åŒ–åˆ†æä¸æ¶æ„ç ”ç©¶)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ç¬¬ä¸€éƒ¨åˆ†: Webæ¡†æ¶ç”Ÿæ€](#ç¬¬ä¸€éƒ¨åˆ†-webæ¡†æ¶ç”Ÿæ€)
    - [1.1 Ginæ¡†æ¶å½¢å¼åŒ–åˆ†æ](#11-ginæ¡†æ¶å½¢å¼åŒ–åˆ†æ)
      - [Ginæ¡†æ¶æ ¸å¿ƒæ¶æ„](#ginæ¡†æ¶æ ¸å¿ƒæ¶æ„)
      - [è·¯ç”±åŒ¹é…ç®—æ³•](#è·¯ç”±åŒ¹é…ç®—æ³•)
      - [ä¸­é—´ä»¶æœºåˆ¶](#ä¸­é—´ä»¶æœºåˆ¶)
      - [æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯](#æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯)
      - [å®é™…åº”ç”¨ç¤ºä¾‹](#å®é™…åº”ç”¨ç¤ºä¾‹)
    - [1.2 Echoæ¡†æ¶æ¶æ„ç ”ç©¶](#12-echoæ¡†æ¶æ¶æ„ç ”ç©¶)
      - [Echoæ ¸å¿ƒè®¾è®¡](#echoæ ¸å¿ƒè®¾è®¡)
      - [ä¸­é—´ä»¶æ´‹è‘±æ¨¡å‹](#ä¸­é—´ä»¶æ´‹è‘±æ¨¡å‹)
      - [æ€§èƒ½ç‰¹æ€§](#æ€§èƒ½ç‰¹æ€§)
    - [1.3 Fiberæ¡†æ¶æ€§èƒ½åˆ†æ](#13-fiberæ¡†æ¶æ€§èƒ½åˆ†æ)
      - [Fiberé›¶åˆ†é…è®¾è®¡](#fiberé›¶åˆ†é…è®¾è®¡)
      - [Fiberæ¶æ„åˆ†æ](#fiberæ¶æ„åˆ†æ)
    - [1.4 æ¡†æ¶å¯¹æ¯”ä¸é€‰å‹](#14-æ¡†æ¶å¯¹æ¯”ä¸é€‰å‹)
      - [å…¨é¢å¯¹æ¯”](#å…¨é¢å¯¹æ¯”)
  - [ç¬¬äºŒéƒ¨åˆ†: å¾®æœåŠ¡æ¡†æ¶](#ç¬¬äºŒéƒ¨åˆ†-å¾®æœåŠ¡æ¡†æ¶)
    - [2.1 Go-Microæ¶æ„åˆ†æ](#21-go-microæ¶æ„åˆ†æ)
      - [Go-Microæ ¸å¿ƒæŠ½è±¡](#go-microæ ¸å¿ƒæŠ½è±¡)
      - [RPCé€šä¿¡æ¨¡å‹](#rpcé€šä¿¡æ¨¡å‹)
    - [2.2 Kratosæ¡†æ¶ç ”ç©¶](#22-kratosæ¡†æ¶ç ”ç©¶)
      - [Kratosæ¶æ„è®¾è®¡](#kratosæ¶æ„è®¾è®¡)
      - [Kratosä¸­é—´ä»¶è®¾è®¡](#kratosä¸­é—´ä»¶è®¾è®¡)
    - [2.3 Go-Zeroæ¶æ„](#23-go-zeroæ¶æ„)
      - [Go-Zeroè®¾è®¡å“²å­¦](#go-zeroè®¾è®¡å“²å­¦)
    - [2.4 Kitexé«˜æ€§èƒ½RPC](#24-kitexé«˜æ€§èƒ½rpc)
      - [Kitexæ¶æ„åˆ†æ](#kitexæ¶æ„åˆ†æ)
  - [ç¬¬ä¸‰éƒ¨åˆ†: ORMä¸æ•°æ®åº“](#ç¬¬ä¸‰éƒ¨åˆ†-ormä¸æ•°æ®åº“)
    - [3.1 GORMå½¢å¼åŒ–æ¨¡å‹](#31-gormå½¢å¼åŒ–æ¨¡å‹)
      - [GORMæ ¸å¿ƒæŠ½è±¡](#gormæ ¸å¿ƒæŠ½è±¡)
      - [å…³è”å…³ç³»](#å…³è”å…³ç³»)
      - [é’©å­æœºåˆ¶](#é’©å­æœºåˆ¶)
    - [3.2 sqlxæ¶æ„åˆ†æ](#32-sqlxæ¶æ„åˆ†æ)
      - [sqlxè½»é‡è®¾è®¡](#sqlxè½»é‡è®¾è®¡)
    - [3.3 Entä»£ç ç”Ÿæˆ](#33-entä»£ç ç”Ÿæˆ)
      - [Entæ¶æ„](#entæ¶æ„)
  - [ç¬¬å››éƒ¨åˆ†: æ¶ˆæ¯é˜Ÿåˆ—ä¸æµå¤„ç†](#ç¬¬å››éƒ¨åˆ†-æ¶ˆæ¯é˜Ÿåˆ—ä¸æµå¤„ç†)
    - [4.1 Sarama (Kafkaå®¢æˆ·ç«¯)](#41-sarama-kafkaå®¢æˆ·ç«¯)
      - [Saramaæ¶æ„](#saramaæ¶æ„)
      - [æ¶ˆè´¹è€…æ¨¡å‹](#æ¶ˆè´¹è€…æ¨¡å‹)
    - [4.2 NSQæ¶æ„åˆ†æ](#42-nsqæ¶æ„åˆ†æ)
      - [NSQè®¾è®¡å“²å­¦](#nsqè®¾è®¡å“²å­¦)
    - [4.3 NATSå½¢å¼åŒ–æ¨¡å‹](#43-natså½¢å¼åŒ–æ¨¡å‹)
      - [NATSæ ¸å¿ƒæŠ½è±¡](#natsæ ¸å¿ƒæŠ½è±¡)
  - [ç¬¬äº”éƒ¨åˆ†: äº‘åŸç”Ÿå·¥å…·é“¾](#ç¬¬äº”éƒ¨åˆ†-äº‘åŸç”Ÿå·¥å…·é“¾)
    - [5.1 Kubernetes Client-Go](#51-kubernetes-client-go)
      - [Client-Goæ¶æ„](#client-goæ¶æ„)
      - [Controlleræ¨¡å¼](#controlleræ¨¡å¼)
    - [5.2 Prometheusç›‘æ§](#52-prometheusç›‘æ§)
      - [Prometheus Goå®¢æˆ·ç«¯](#prometheus-goå®¢æˆ·ç«¯)
    - [5.3 etcdåˆ†å¸ƒå¼åè°ƒ](#53-etcdåˆ†å¸ƒå¼åè°ƒ)
      - [etcd Goå®¢æˆ·ç«¯](#etcd-goå®¢æˆ·ç«¯)
  - [ç¬¬å…­éƒ¨åˆ†: å¹¶å‘ä¸å¼‚æ­¥](#ç¬¬å…­éƒ¨åˆ†-å¹¶å‘ä¸å¼‚æ­¥)
    - [6.1 antsåç¨‹æ± ](#61-antsåç¨‹æ± )
      - [antsè®¾è®¡åˆ†æ](#antsè®¾è®¡åˆ†æ)
    - [6.2 panjf2000/gnetç½‘ç»œåº“](#62-panjf2000gnetç½‘ç»œåº“)
      - [gnetäº‹ä»¶é©±åŠ¨æ¶æ„](#gnetäº‹ä»¶é©±åŠ¨æ¶æ„)
    - [6.3 errgroupé”™è¯¯ç»„](#63-errgroupé”™è¯¯ç»„)
      - [errgroupè®¾è®¡](#errgroupè®¾è®¡)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
    - [æ ¸å¿ƒç”Ÿæ€](#æ ¸å¿ƒç”Ÿæ€)
    - [é€‰å‹æŒ‡å—](#é€‰å‹æŒ‡å—)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

## ç¬¬ä¸€éƒ¨åˆ†: Webæ¡†æ¶ç”Ÿæ€

### 1.1 Ginæ¡†æ¶å½¢å¼åŒ–åˆ†æ

#### Ginæ¡†æ¶æ ¸å¿ƒæ¶æ„

```mathematical
/* Ginæ¡†æ¶å½¢å¼åŒ–æ¨¡å‹ */

GinEngine = (RouterTree, Middleware, Context)

å…¶ä¸­:
- RouterTree: HTTPè·¯ç”±æ ‘ (Radix Tree)
- Middleware: ä¸­é—´ä»¶é“¾
- Context: è¯·æ±‚ä¸Šä¸‹æ–‡

/* è·¯ç”±æ ‘å®šä¹‰ */

RouterTree = Node[MethodTree]

Node = {
    path: String,
    indices: String,      // å­èŠ‚ç‚¹é¦–å­—ç¬¦ç´¢å¼•
    children: [Node],
    handlers: [Handler],
    priority: Int,        // ä¼˜å…ˆçº§
    nType: NodeType,      // èŠ‚ç‚¹ç±»å‹
    wildChild: Bool
}

NodeType ::= static      // é™æ€è·¯å¾„
           | root        // æ ¹èŠ‚ç‚¹
           | param       // :param
           | catchAll    // *catchall

/* HTTPæ–¹æ³•æ ‘ */

MethodTree = {
    GET: RouterTree,
    POST: RouterTree,
    PUT: RouterTree,
    DELETE: RouterTree,
    PATCH: RouterTree,
    HEAD: RouterTree,
    OPTIONS: RouterTree
}
```

#### è·¯ç”±åŒ¹é…ç®—æ³•

```mathematical
/* è·¯ç”±åŒ¹é…å½¢å¼åŒ– */

function matchRoute(method: HTTPMethod, path: String) -> (Handler, Params):
    tree = MethodTree[method]

    function walk(node: Node, path: String, params: Params) -> (Handler, Params):
        // å®Œå…¨åŒ¹é…
        if path == "":
            return (node.handlers, params)

        // é™æ€åŒ¹é…
        for i, c in node.indices:
            if path[0] == c:
                child = node.children[i]
                if child.path is prefix of path:
                    return walk(child, path[len(child.path):], params)

        // å‚æ•°åŒ¹é… :param
        if node.wildChild:
            child = node.children[0]
            if child.nType == param:
                end = indexOf(path, '/')
                param_value = path[:end]
                params.add(child.path[1:], param_value)
                return walk(child, path[end:], params)

        // é€šé…ç¬¦åŒ¹é… *catchall
        if node.nType == catchAll:
            params.add(node.path[1:], path)
            return (node.handlers, params)

        return (nil, nil)  // 404

    return walk(tree.root, path, {})

/* è·¯ç”±æ’å…¥ç®—æ³• */

function insertRoute(method: HTTPMethod, path: String, handlers: [Handler]):
    tree = MethodTree[method]

    function insert(node: Node, path: String, handlers: [Handler]):
        // æŸ¥æ‰¾æœ€é•¿å…¬å…±å‰ç¼€
        lcp = longestCommonPrefix(node.path, path)

        if lcp < len(node.path):
            // åˆ†è£‚èŠ‚ç‚¹
            child = Node{
                path: node.path[lcp:],
                children: node.children,
                handlers: node.handlers,
                ...
            }

            node.path = node.path[:lcp]
            node.children = [child]
            node.handlers = nil

        if lcp < len(path):
            // ç»§ç»­æ’å…¥
            path = path[lcp:]

            // æŸ¥æ‰¾åŒ¹é…çš„å­èŠ‚ç‚¹
            for child in node.children:
                if child.path[0] == path[0]:
                    return insert(child, path, handlers)

            // åˆ›å»ºæ–°å­èŠ‚ç‚¹
            newChild = Node{path: path, handlers: handlers}
            node.children.append(newChild)
        else:
            // å½“å‰èŠ‚ç‚¹å°±æ˜¯ç›®æ ‡
            node.handlers = handlers

    insert(tree.root, path, handlers)

/* å¤æ‚åº¦åˆ†æ */

æ—¶é—´å¤æ‚åº¦:
- æ’å…¥: O(n) where n = len(path)
- æŸ¥æ‰¾: O(n) where n = len(path)

ç©ºé—´å¤æ‚åº¦: O(total_path_length)
```

#### ä¸­é—´ä»¶æœºåˆ¶

```mathematical
/* ä¸­é—´ä»¶å½¢å¼åŒ– */

Middleware = Context â†’ Next â†’ Response

å…¶ä¸­:
- Context: è¯·æ±‚ä¸Šä¸‹æ–‡
- Next: ä¸‹ä¸€ä¸ªä¸­é—´ä»¶/å¤„ç†å™¨
- Response: HTTPå“åº”

/* ä¸­é—´ä»¶é“¾ */

MiddlewareChain = [Middleware]

function executeChain(chain: MiddlewareChain, ctx: Context) -> Response:
    index = 0

    function next():
        if index < len(chain):
            middleware = chain[index]
            index += 1
            return middleware(ctx, next)
        else:
            return finalHandler(ctx)

    return next()

/* ä¸­é—´ä»¶ç»„åˆ (Monadic) */

(mâ‚ âˆ˜ mâ‚‚)(ctx) = mâ‚(ctx, Î»(). mâ‚‚(ctx, next))

æ€§è´¨:
1. ç»“åˆå¾‹: (mâ‚ âˆ˜ mâ‚‚) âˆ˜ mâ‚ƒ = mâ‚ âˆ˜ (mâ‚‚ âˆ˜ mâ‚ƒ)
2. å•ä½å…ƒ: id(ctx, next) = next()
```

#### æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

```mathematical
/* Ginæ€§èƒ½ä¼˜åŒ–è¦ç‚¹ */

1. é›¶å†…å­˜åˆ†é…è·¯ç”±
   - è·¯ç”±æ ‘é¢„å…ˆæ„å»º
   - è·¯å¾„åŒ¹é…æ— å†…å­˜åˆ†é…

2. Contextæ± åŒ–
   sync.Pool for *gin.Context
   - å‡å°‘GCå‹åŠ›
   - æé«˜ååé‡

3. å¿«é€Ÿè·¯å¾„
   - é™æ€è·¯ç”± O(1) æŸ¥æ‰¾
   - å‚æ•°è·¯ç”± O(n) æŸ¥æ‰¾

/* æ€§èƒ½æ¨¡å‹ */

Throughput(Gin) â‰ˆ
  BaseRPS Ã— (1 - GC_Overhead) Ã— (1 - Middleware_Cost)

å…¶ä¸­:
- BaseRPS: åŸºå‡†è¯·æ±‚/ç§’
- GC_Overhead: GCå¼€é”€æ¯”ä¾‹ (< 5%)
- Middleware_Cost: ä¸­é—´ä»¶æˆæœ¬

åŸºå‡†æ€§èƒ½:
- ç®€å•è·¯ç”±: ~70k RPS
- å¸¦ä¸­é—´ä»¶: ~50k RPS
- JSONåºåˆ—åŒ–: ~40k RPS
```

#### å®é™…åº”ç”¨ç¤ºä¾‹

```go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

// Ginæ¡†æ¶å®æˆ˜ç¤ºä¾‹

type User struct {
    ID   int    `json:"id"`
    Name string `json:"name"`
}

func main() {
    r := gin.Default()

    // ä¸­é—´ä»¶
    r.Use(gin.Logger())
    r.Use(gin.Recovery())

    // è·¯ç”±ç»„
    api := r.Group("/api/v1")
    {
        // RESTful API
        api.GET("/users", getUsers)
        api.GET("/users/:id", getUser)
        api.POST("/users", createUser)
        api.PUT("/users/:id", updateUser)
        api.DELETE("/users/:id", deleteUser)
    }

    r.Run(":8080")
}

func getUsers(c *gin.Context) {
    users := []User{
        {ID: 1, Name: "Alice"},
        {ID: 2, Name: "Bob"},
    }
    c.JSON(http.StatusOK, users)
}

func getUser(c *gin.Context) {
    id := c.Param("id")
    user := User{ID: 1, Name: "Alice"}
    c.JSON(http.StatusOK, user)
}

func createUser(c *gin.Context) {
    var user User
    if err := c.ShouldBindJSON(&user); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    c.JSON(http.StatusCreated, user)
}

func updateUser(c *gin.Context) {
    id := c.Param("id")
    var user User
    if err := c.ShouldBindJSON(&user); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    c.JSON(http.StatusOK, user)
}

func deleteUser(c *gin.Context) {
    id := c.Param("id")
    c.JSON(http.StatusOK, gin.H{"message": "deleted"})
}
```

### 1.2 Echoæ¡†æ¶æ¶æ„ç ”ç©¶

#### Echoæ ¸å¿ƒè®¾è®¡

```mathematical
/* Echoæ¡†æ¶å½¢å¼åŒ–æ¨¡å‹ */

EchoEngine = (Router, Middleware, Context, Binder)

/* è·¯ç”±å™¨è®¾è®¡ */

Router = {
    tree: *node,
    routes: map[method][]*Route,
    echo: *Echo
}

Route = {
    Method: HTTPMethod,
    Path: String,
    Handler: HandlerFunc,
    Name: String
}

/* ä¸Šä¸‹æ–‡æ¥å£ */

Context interface {
    // Request/Response
    Request() *http.Request
    Response() *Response

    // å‚æ•°
    Param(name string) string
    QueryParam(name string) string
    FormValue(name string) string

    // ç»‘å®šä¸æ¸²æŸ“
    Bind(i interface{}) error
    JSON(code int, i interface{}) error
    HTML(code int, html string) error

    // ä¸­é—´ä»¶
    Set(key string, val interface{})
    Get(key string) interface{}
}

/* ä¸­é—´ä»¶ç­¾å */

MiddlewareFunc = func(HandlerFunc) HandlerFunc

è¿™æ˜¯ä¸€ä¸ªé«˜é˜¶å‡½æ•°,æ¥å—ä¸€ä¸ªå¤„ç†å™¨å¹¶è¿”å›åŒ…è£…åçš„å¤„ç†å™¨
```

#### ä¸­é—´ä»¶æ´‹è‘±æ¨¡å‹

```mathematical
/* æ´‹è‘±æ¨¡å‹å½¢å¼åŒ– */

è®¾ä¸­é—´ä»¶é“¾: [mâ‚, mâ‚‚, ..., mâ‚™]
æœ€ç»ˆå¤„ç†å™¨: h

æ‰§è¡Œé¡ºåº:
mâ‚ â†’ mâ‚‚ â†’ ... â†’ mâ‚™ â†’ h â†’ mâ‚™ â†’ ... â†’ mâ‚‚ â†’ mâ‚

å½¢å¼åŒ–:
compose([mâ‚, mâ‚‚, ..., mâ‚™], h) =
  mâ‚(mâ‚‚(...(mâ‚™(h))...))

/* ä¸­é—´ä»¶ç»„åˆè§„åˆ™ */

[Compose-Empty]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
compose([], h) = h

[Compose-Cons]
h' = compose(ms, h)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
compose([m | ms], h) = m(h')

/* æ‰§è¡Œè¯­ä¹‰ */

æ‰§è¡Œ m(h)(ctx):
1. æ‰§è¡Œ m çš„å‰ç½®é€»è¾‘
2. è°ƒç”¨ h(ctx)
3. æ‰§è¡Œ m çš„åç½®é€»è¾‘

ç¤ºä¾‹:
middleware Logger:
  before: log request
  call: next(ctx)
  after: log response
```

#### æ€§èƒ½ç‰¹æ€§

```mathematical
/* Echoæ€§èƒ½ä¼˜åŒ– */

1. è·¯ç”±ä¼˜åŒ–
   - å‰ç¼€æ ‘ (Trie) è·¯ç”±
   - é™æ€è·¯ç”±å¿«é€ŸæŸ¥æ‰¾
   - é›¶å†…å­˜åˆ†é…

2. Contextå¤ç”¨
   - sync.Poolç®¡ç†
   - å‡å°‘GCå‹åŠ›

3. å“åº”å†™å…¥ä¼˜åŒ–
   - ç¼“å†²å†™å…¥
   - åˆ†å—ä¼ è¾“

/* åŸºå‡†æ€§èƒ½ */

Echo vs Gin:
- Echo: ~65k RPS
- Gin:  ~70k RPS

å·®å¼‚åŸå› :
- è·¯ç”±ç®—æ³•å·®å¼‚ (<10%)
- ä¸­é—´ä»¶å®ç°å·®å¼‚ (<5%)

æ€»ä½“: æ€§èƒ½ç›¸å½“
```

### 1.3 Fiberæ¡†æ¶æ€§èƒ½åˆ†æ

#### Fiberé›¶åˆ†é…è®¾è®¡

```mathematical
/* Fiberæ¡†æ¶æ¨¡å‹ */

Fiber = {
    app: *App,
    ctx: *fasthttp.RequestCtx,  // åŸºäºfasthttp
    route: *Route,
    fasthttp: bool
}

/* é›¶å†…å­˜åˆ†é…æŠ€æœ¯ */

1. å­—ç¬¦ä¸²é›¶æ‹·è´
   ä½¿ç”¨ []byte è€Œé string
   é¿å…å­—ç¬¦ä¸²åˆ°å­—èŠ‚çš„è½¬æ¢

2. Contextæ± åŒ–
   é¢„åˆ†é…Contextå¯¹è±¡
   è¯·æ±‚ç»“æŸåå›æ”¶

3. è·¯ç”±é›¶åˆ†é…
   è·¯ç”±æ ‘é¢„å…ˆæ„å»º
   å‚æ•°æå–æ— é¢å¤–åˆ†é…

/* æ€§èƒ½æ¨¡å‹ */

Fiberä½¿ç”¨fasthttpä½œä¸ºåº•å±‚HTTPåº“:

æ€§èƒ½æå‡ â‰ˆ 2-3Ã— vs net/http

åŸå› :
1. é›¶å†…å­˜åˆ†é…è®¾è®¡
2. å¯¹è±¡æ± åŒ–
3. æ›´å°‘çš„ç³»ç»Ÿè°ƒç”¨

åŸºå‡†:
- Fiber: ~100k RPS
- Gin:   ~70k RPS
- Echo:  ~65k RPS
```

#### Fiberæ¶æ„åˆ†æ

```mathematical
/* Fiberè·¯ç”±æ ‘ */

ä½¿ç”¨æ”¹è¿›çš„Radix Tree:

function addRoute(path string, handler Handler):
    node = root

    for segment in split(path, '/'):
        if segment starts with ':':
            // å‚æ•°èŠ‚ç‚¹
            node = node.paramChild
        elif segment starts with '*':
            // é€šé…ç¬¦èŠ‚ç‚¹
            node = node.wildcardChild
        else:
            // é™æ€èŠ‚ç‚¹
            node = findOrCreateChild(node, segment)

    node.handler = handler

/* è¯·æ±‚å¤„ç†æµæ°´çº¿ */

Request â†’ Parse â†’ Route â†’ Middleware â†’ Handler â†’ Response

æ¯ä¸ªé˜¶æ®µéƒ½ä¼˜åŒ–ä¸ºé›¶åˆ†é…:
1. Parse: å¤ç”¨buffer
2. Route: é¢„æ„å»ºæ ‘
3. Middleware: é“¾è¡¨éå†,æ— åˆ†é…
4. Handler: Contextæ± åŒ–
5. Response: ç¼“å†²å†™å…¥

/* å¹¶å‘æ¨¡å‹ */

Fiberé‡‡ç”¨fasthttpçš„one-goroutine-per-requestæ¨¡å‹:

ä¼˜åŠ¿:
- é™ä½goroutineåˆ‡æ¢å¼€é”€
- æ›´å¥½çš„CPUç¼“å­˜å±€éƒ¨æ€§

åŠ£åŠ¿:
- ä¸é€‚åˆé•¿è¿æ¥
- é˜»å¡æ“ä½œå½±å“åå
```

### 1.4 æ¡†æ¶å¯¹æ¯”ä¸é€‰å‹

#### å…¨é¢å¯¹æ¯”

```mathematical
/* æ¡†æ¶ç‰¹æ€§å¯¹æ¯”çŸ©é˜µ */

Feature       | Gin | Echo | Fiber
--------------|-----|------|-------
æ€§èƒ½(RPS)     | 70k | 65k  | 100k
å†…å­˜å ç”¨      | ä¸­  | ä¸­   | ä½
å­¦ä¹ æ›²çº¿      | æ˜“  | æ˜“   | ä¸­
ç”Ÿæ€æˆç†Ÿåº¦    | é«˜  | é«˜   | ä¸­
ä¸­é—´ä»¶ä¸°å¯Œåº¦  | é«˜  | é«˜   | ä¸­
è·¯ç”±çµæ´»æ€§    | é«˜  | é«˜   | é«˜
æ–‡æ¡£è´¨é‡      | ä¼˜  | ä¼˜   | è‰¯
ç¤¾åŒºæ´»è·ƒåº¦    | é«˜  | ä¸­   | é«˜
åº•å±‚HTTPåº“    | net/http | net/http | fasthttp

/* é€‰å‹å†³ç­–æ ‘ */

if è¿½æ±‚æè‡´æ€§èƒ½ and å¯æ¥å—fasthttpé™åˆ¶:
    choose Fiber
elif éœ€è¦æˆç†Ÿç”Ÿæ€ and æ ‡å‡†net/http:
    choose Gin
elif å–œæ¬¢Expressé£æ ¼ and RESTfulè®¾è®¡:
    choose Echo

/* æ€§èƒ½-åŠŸèƒ½æƒè¡¡ */

Performance âˆ 1 / Features

Gin: å¹³è¡¡æ€§èƒ½ä¸åŠŸèƒ½
Echo: æ›´RESTful,ç•¥ä½æ€§èƒ½
Fiber: æè‡´æ€§èƒ½,æœ‰é™åˆ¶

/* æ¨èåœºæ™¯ */

Giné€‚åˆ:
- é€šç”¨Web API
- å¾®æœåŠ¡
- éœ€è¦ä¸°å¯Œä¸­é—´ä»¶

Echoé€‚åˆ:
- RESTful API
- å›¢é˜Ÿç†Ÿæ‚‰Express
- éœ€è¦æ¸…æ™°APIè®¾è®¡

Fiberé€‚åˆ:
- é«˜æ€§èƒ½æœåŠ¡
- ä½å»¶è¿Ÿè¦æ±‚
- å¯¹fasthttpç†Ÿæ‚‰
```

---

## ç¬¬äºŒéƒ¨åˆ†: å¾®æœåŠ¡æ¡†æ¶

### 2.1 Go-Microæ¶æ„åˆ†æ

#### Go-Microæ ¸å¿ƒæŠ½è±¡

```mathematical
/* Go-Microæ¶æ„å½¢å¼åŒ– */

Microservice = (Service, Registry, Transport, Broker, Codec)

å…¶ä¸­:
- Service: æœåŠ¡å®šä¹‰
- Registry: æœåŠ¡æ³¨å†Œä¸å‘ç°
- Transport: ä¼ è¾“å±‚
- Broker: å¼‚æ­¥æ¶ˆæ¯
- Codec: ç¼–è§£ç å™¨

/* æœåŠ¡å®šä¹‰ */

Service = {
    Name: String,
    Version: String,
    Metadata: map[string]string,
    Nodes: []*Node,
    Endpoints: []*Endpoint
}

Node = {
    Id: String,
    Address: String,
    Port: int,
    Metadata: map[string]string
}

Endpoint = {
    Name: String,
    Request: Type,
    Response: Type,
    Metadata: map[string]string
}

/* æœåŠ¡æ³¨å†Œå½¢å¼åŒ– */

Registry interface {
    Register(service *Service) error
    Deregister(service *Service) error
    GetService(name string) ([]*Service, error)
    ListServices() ([]*Service, error)
    Watch(opts ...WatchOption) (Watcher, error)
}

æ³¨å†Œè¿‡ç¨‹:
1. æœåŠ¡å¯åŠ¨ â†’ æ³¨å†Œåˆ°Registry
2. å®šæœŸå¿ƒè·³ â†’ ä¿æŒæ³¨å†ŒçŠ¶æ€
3. æœåŠ¡å…³é—­ â†’ æ³¨é”€æœåŠ¡

/* æœåŠ¡å‘ç°ç®—æ³• */

function discoverService(name: String) -> []*Node:
    services = registry.GetService(name)

    if len(services) == 0:
        return error("service not found")

    // é€‰æ‹©ç­–ç•¥
    nodes = selectNodes(services)

    // è´Ÿè½½å‡è¡¡
    node = loadBalance(nodes)

    return node

/* è´Ÿè½½å‡è¡¡ç­–ç•¥ */

LoadBalancer ::=
    | RoundRobin    // è½®è¯¢
    | Random        // éšæœº
    | LeastConn     // æœ€å°‘è¿æ¥
    | WeightedRR    // åŠ æƒè½®è¯¢

function roundRobin(nodes: []*Node) -> *Node:
    index = (current_index + 1) % len(nodes)
    current_index = index
    return nodes[index]
```

#### RPCé€šä¿¡æ¨¡å‹

```mathematical
/* Go-Micro RPCæ¨¡å‹ */

RPC = Client â†’ Transport â†’ Server

/* å®¢æˆ·ç«¯è°ƒç”¨ */

function call(service: String, method: String, request: Req) -> Resp:
    // 1. æœåŠ¡å‘ç°
    node = registry.GetService(service).SelectNode()

    // 2. ç¼–ç è¯·æ±‚
    data = codec.Marshal(request)

    // 3. å‘é€è¯·æ±‚
    response_data = transport.Send(node.Address, data)

    // 4. è§£ç å“åº”
    response = codec.Unmarshal(response_data)

    return response

/* æœåŠ¡ç«¯å¤„ç† */

function handle(request: []byte) -> []byte:
    // 1. è§£ç è¯·æ±‚
    req = codec.Unmarshal(request)

    // 2. è·¯ç”±åˆ°å¤„ç†å™¨
    handler = router.Match(req.Service, req.Method)

    // 3. æ‰§è¡Œå¤„ç†å™¨
    resp = handler.Call(req.Body)

    // 4. ç¼–ç å“åº”
    response = codec.Marshal(resp)

    return response

/* å®¹é”™æœºåˆ¶ */

1. é‡è¯• (Retry):
   function callWithRetry(call: Call, maxRetries: int) -> Response:
       for i in 1..maxRetries:
           try:
               return call()
           catch error:
               if i == maxRetries:
                   throw error
               backoff(i)

2. è¶…æ—¶ (Timeout):
   function callWithTimeout(call: Call, timeout: Duration) -> Response:
       ctx, cancel = context.WithTimeout(context.Background(), timeout)
       defer cancel()

       return call(ctx)

3. ç†”æ–­ (Circuit Breaker):
   State = Closed | Open | HalfOpen

   function circuitBreaker(call: Call) -> Response:
       if state == Open:
           return error("circuit open")

       try:
           resp = call()
           onSuccess()
           return resp
       catch error:
           onFailure()
           throw error
```

### 2.2 Kratosæ¡†æ¶ç ”ç©¶

#### Kratosæ¶æ„è®¾è®¡

```mathematical
/* Kratoså¾®æœåŠ¡æ¡†æ¶æ¨¡å‹ */

Kratos = (Transport, Registry, Config, Middleware, Tracing)

/* TransportæŠ½è±¡ */

Transport interface {
    Kind() TransportKind
    Endpoint() string
    Operation() string
    RequestHeader() Header
    ReplyHeader() Header
}

TransportKind ::= HTTP | gRPC

/* å¤šåè®®æ”¯æŒ */

Server = HTTPServer | gRPCServer

HTTPServer:
  åŸºäºginæˆ–echo
  RESTful API
  é€‚åˆå¤–éƒ¨è°ƒç”¨

gRPCServer:
  åŸºäºgoogle.golang.org/grpc
  é«˜æ€§èƒ½RPC
  é€‚åˆå†…éƒ¨è°ƒç”¨

/* é…ç½®ç®¡ç† */

Config = Source â†’ Decoder â†’ Config

Source ::= File | Apollo | Consul | etcd

function loadConfig() -> Config:
    // 1. åŠ è½½é…ç½®æº
    data = source.Load()

    // 2. è§£ç 
    config = decoder.Decode(data)

    // 3. ç›‘å¬å˜åŒ–
    source.Watch(func(newData) {
        config = decoder.Decode(newData)
        notifySubscribers(config)
    })

    return config
```

#### Kratosä¸­é—´ä»¶è®¾è®¡

```mathematical
/* Kratosä¸­é—´ä»¶æ¨¡å‹ */

Middleware = func(Handler) Handler

Handler = func(Context, Request) (Response, error)

/* ä¸­é—´ä»¶ç»„åˆ */

function Chain(middlewares: []Middleware, h: Handler) -> Handler:
    for i in reverse(0..len(middlewares)):
        h = middlewares[i](h)
    return h

/* å¸¸ç”¨ä¸­é—´ä»¶ */

1. Recoveryä¸­é—´ä»¶:
   function Recovery(h Handler) Handler:
       return func(ctx Context, req Request) (Response, error):
           defer func():
               if r := recover(); r != nil:
                   return nil, error("panic recovered")

           return h(ctx, req)

2. Loggingä¸­é—´ä»¶:
   function Logging(h Handler) Handler:
       return func(ctx Context, req Request) (Response, error):
           start := time.Now()
           log("request start", req)

           resp, err := h(ctx, req)

           duration := time.Since(start)
           log("request end", resp, duration)

           return resp, err

3. Tracingä¸­é—´ä»¶:
   function Tracing(h Handler) Handler:
       return func(ctx Context, req Request) (Response, error):
           span, ctx := opentracing.StartSpan(ctx, "handler")
           defer span.Finish()

           return h(ctx, req)
```

### 2.3 Go-Zeroæ¶æ„

#### Go-Zeroè®¾è®¡å“²å­¦

```mathematical
/* Go-Zeroå¾®æœåŠ¡å·¥å…·é›† */

GoZero = (API Gateway, RPC, Model, Cache, MQ)

/* APIå®šä¹‰è¯­è¨€ */

API = {
    info: Info,
    types: []Type,
    service: Service
}

ç¤ºä¾‹:
type LoginRequest {
    Username string `json:"username"`
    Password string `json:"password"`
}

type LoginResponse {
    Token string `json:"token"`
}

service user-api {
    @handler login
    post /user/login (LoginRequest) returns (LoginResponse)
}

/* ä»£ç ç”Ÿæˆæµç¨‹ */

function generate(api: API) -> Code:
    // 1. è§£æAPIå®šä¹‰
    ast = parser.Parse(api)

    // 2. ç”ŸæˆHandler
    handlers = generateHandlers(ast.Service)

    // 3. ç”ŸæˆRoutes
    routes = generateRoutes(ast.Service)

    // 4. ç”ŸæˆTypes
    types = generateTypes(ast.Types)

    // 5. ç”ŸæˆLogic
    logic = generateLogic(ast.Service)

    return Code{handlers, routes, types, logic}

/* ç¼“å­˜ç­–ç•¥ */

Cache = {
    primary: DB,
    cache: Redis,
    strategy: CacheStrategy
}

CacheStrategy ::=
    | CacheAside     // æ—è·¯ç¼“å­˜
    | ReadThrough    // è¯»ç©¿é€
    | WriteThrough   // å†™ç©¿é€
    | WriteBack      // å†™å›

function cacheAside(key: String) -> Value:
    // 1. æŸ¥ç¼“å­˜
    value = cache.Get(key)
    if value != nil:
        return value

    // 2. æŸ¥æ•°æ®åº“
    value = db.Get(key)
    if value != nil:
        // 3. å†™ç¼“å­˜
        cache.Set(key, value)

    return value
```

### 2.4 Kitexé«˜æ€§èƒ½RPC

#### Kitexæ¶æ„åˆ†æ

```mathematical
/* Kitex RPCæ¡†æ¶ (by å­—èŠ‚è·³åŠ¨) */

Kitex = (Netpoll, Thrift, Codec, Middleware)

/* Netpollé«˜æ€§èƒ½ç½‘ç»œåº“ */

Netpollç‰¹æ€§:
1. Zero-copyè¯»å†™
2. Epolläº‹ä»¶å¾ªç¯
3. è¿æ¥æ± ç®¡ç†
4. å†…å­˜æ± åŒ–

æ€§èƒ½ä¼˜åŠ¿:
- ç›¸æ¯”netåŒ… 3-5Ã— ååæå‡
- æ›´ä½çš„å»¶è¿Ÿ (P99 < 1ms)

/* Thriftç¼–è§£ç  */

Thriftåè®®:
Binary | Compact | JSON

æ€§èƒ½å¯¹æ¯”:
Binary:  æœ€å¿«,äºŒè¿›åˆ¶
Compact: å‹ç¼©,ä¸­ç­‰æ€§èƒ½
JSON:    å¯è¯»,è¾ƒæ…¢

function encodeThrift(obj: Object) -> []byte:
    // ä½¿ç”¨Apache Thriftåè®®
    transport = TMemoryBuffer()
    protocol = TBinaryProtocol(transport)

    obj.Write(protocol)

    return transport.Bytes()

/* æœåŠ¡æ²»ç† */

Governance = {
    loadBalance: LoadBalancer,
    circuitBreaker: CircuitBreaker,
    rateLimit: RateLimiter,
    timeout: Timeout,
    retry: Retry
}

function call(req: Request) -> Response:
    // 1. é™æµ
    if not rateLimit.Allow():
        return error("rate limited")

    // 2. ç†”æ–­æ£€æŸ¥
    if circuitBreaker.IsOpen():
        return error("circuit open")

    // 3. è´Ÿè½½å‡è¡¡é€‰æ‹©èŠ‚ç‚¹
    node = loadBalance.Select()

    // 4. å¸¦è¶…æ—¶å’Œé‡è¯•çš„è°ƒç”¨
    resp = callWithRetryAndTimeout(node, req)

    // 5. æ›´æ–°ç†”æ–­å™¨çŠ¶æ€
    if isError(resp):
        circuitBreaker.RecordFailure()
    else:
        circuitBreaker.RecordSuccess()

    return resp
```

---

## ç¬¬ä¸‰éƒ¨åˆ†: ORMä¸æ•°æ®åº“

### 3.1 GORMå½¢å¼åŒ–æ¨¡å‹

#### GORMæ ¸å¿ƒæŠ½è±¡

```mathematical
/* GORM ORMæ¡†æ¶æ¨¡å‹ */

GORM = (Model, Query, Association, Hook)

/* æ¨¡å‹å®šä¹‰ */

Model = {
    fields: []Field,
    tableName: String,
    primaryKey: Field,
    associations: []Association
}

Field = {
    name: String,
    type: Type,
    tag: Tag,
    nullable: Bool
}

/* æŸ¥è¯¢æ„é€ å™¨ */

Query = {
    model: Model,
    conditions: []Condition,
    joins: []Join,
    orders: []Order,
    limit: Option[int],
    offset: Option[int]
}

function buildQuery(q: Query) -> SQL:
    sql = "SELECT * FROM " + q.model.tableName

    if len(q.conditions) > 0:
        sql += " WHERE " + joinConditions(q.conditions, " AND ")

    if len(q.joins) > 0:
        for join in q.joins:
            sql += " " + join.type + " JOIN " + join.table +
                   " ON " + join.condition

    if len(q.orders) > 0:
        sql += " ORDER BY " + joinOrders(q.orders)

    if q.limit.IsSome():
        sql += " LIMIT " + q.limit.Unwrap()

    if q.offset.IsSome():
        sql += " OFFSET " + q.offset.Unwrap()

    return sql

/* æŸ¥è¯¢ç¤ºä¾‹ */

// Goä»£ç 
db.Where("age > ?", 18).
   Order("name DESC").
   Limit(10).
   Find(&users)

// ç”ŸæˆSQL
SELECT * FROM users
WHERE age > 18
ORDER BY name DESC
LIMIT 10
```

#### å…³è”å…³ç³»

```mathematical
/* GORMå…³è”å…³ç³»å½¢å¼åŒ– */

Association ::=
    | HasOne(model: Model, foreignKey: Field)
    | HasMany(model: Model, foreignKey: Field)
    | BelongsTo(model: Model, foreignKey: Field)
    | ManyToMany(model: Model, joinTable: String)

/* HasOneå…³ç³» */

User HasOne Profile:
  User.ID â†’ Profile.UserID

SQL:
SELECT * FROM profiles
WHERE user_id = ?

/* HasManyå…³ç³» */

User HasMany Posts:
  User.ID â†’ Posts.UserID

SQL:
SELECT * FROM posts
WHERE user_id = ?

/* BelongsToå…³ç³» */

Post BelongsTo User:
  Post.UserID â†’ User.ID

SQL:
SELECT * FROM users
WHERE id = (SELECT user_id FROM posts WHERE id = ?)

/* ManyToManyå…³ç³» */

User ManyToMany Tags:
  é€šè¿‡ä¸­é—´è¡¨ user_tags

SQL:
SELECT tags.* FROM tags
INNER JOIN user_tags ON tags.id = user_tags.tag_id
WHERE user_tags.user_id = ?

/* é¢„åŠ è½½ (Eager Loading) */

function preload(model: Model, associations: []String) -> Result:
    // 1. åŠ è½½ä¸»æ¨¡å‹
    main_results = query(model)

    // 2. æ”¶é›†å¤–é”®
    foreign_keys = collect_foreign_keys(main_results)

    // 3. æ‰¹é‡æŸ¥è¯¢å…³è”
    for assoc in associations:
        assoc_results = query_association(assoc, foreign_keys)

        // 4. ç»„è£…ç»“æœ
        attach_associations(main_results, assoc_results)

    return main_results

é¿å…N+1é—®é¢˜:
- Without Preload: 1 + N æ¬¡æŸ¥è¯¢
- With Preload: 2 æ¬¡æŸ¥è¯¢
```

#### é’©å­æœºåˆ¶

```mathematical
/* GORMé’©å­ (Hooks) */

Hook ::=
    | BeforeCreate | AfterCreate
    | BeforeUpdate | AfterUpdate
    | BeforeDelete | AfterDelete
    | BeforeSave   | AfterSave
    | AfterFind

/* é’©å­æ‰§è¡Œé¡ºåº */

Create:
  BeforeSave â†’ BeforeCreate â†’ DB.Create â†’ AfterCreate â†’ AfterSave

Update:
  BeforeSave â†’ BeforeUpdate â†’ DB.Update â†’ AfterUpdate â†’ AfterSave

Delete:
  BeforeDelete â†’ DB.Delete â†’ AfterDelete

/* é’©å­ç¤ºä¾‹ */

type User struct {
    ID        uint
    Name      string
    CreatedAt time.Time
    UpdatedAt time.Time
}

func (u *User) BeforeCreate(tx *gorm.DB) error {
    // åœ¨åˆ›å»ºå‰æ‰§è¡Œ
    if u.Name == "" {
        return errors.New("name required")
    }
    u.CreatedAt = time.Now()
    return nil
}

func (u *User) AfterCreate(tx *gorm.DB) error {
    // åœ¨åˆ›å»ºåæ‰§è¡Œ
    log.Printf("User created: %v", u)
    return nil
}

/* é’©å­å½¢å¼åŒ– */

function executeWithHooks(operation: Operation, model: Model) -> Result:
    // 1. æ‰§è¡ŒBeforeé’©å­
    if hasHook(model, "Before" + operation):
        err = model.callHook("Before" + operation)
        if err != nil:
            return error(err)

    // 2. æ‰§è¡Œæ•°æ®åº“æ“ä½œ
    result = db.Execute(operation, model)

    // 3. æ‰§è¡ŒAfteré’©å­
    if hasHook(model, "After" + operation):
        model.callHook("After" + operation)

    return result
```

### 3.2 sqlxæ¶æ„åˆ†æ

#### sqlxè½»é‡è®¾è®¡

```mathematical
/* sqlx: database/sqlæ‰©å±• */

sqlx = database/sql + NamedQuery + StructScan

ä¼˜åŠ¿:
1. ä¿æŒdatabase/sqlå…¼å®¹
2. æ·»åŠ ä¾¿åˆ©åŠŸèƒ½
3. é›¶é¢å¤–å¼€é”€

/* å‘½åå‚æ•°æŸ¥è¯¢ */

NamedQuery:
  å°†ç»“æ„ä½“å­—æ®µæ˜ å°„åˆ°SQLå‚æ•°

ç¤ºä¾‹:
type User struct {
    Name string `db:"name"`
    Age  int    `db:"age"`
}

// å‘½åæŸ¥è¯¢
query := "SELECT * FROM users WHERE name=:name AND age=:age"
rows, err := db.NamedQuery(query, User{Name: "Alice", Age: 30})

/* ç»“æ„ä½“æ‰«æ */

StructScan:
  å°†æŸ¥è¯¢ç»“æœæ˜ å°„åˆ°ç»“æ„ä½“

function structScan(rows: *sql.Rows, dest: interface{}) error:
    // 1. è·å–åˆ—å
    columns, err := rows.Columns()
    if err != nil:
        return err

    // 2. åˆ›å»ºæ‰«æç›®æ ‡
    values := make([]interface{}, len(columns))

    // 3. æ˜ å°„åˆ°ç»“æ„ä½“å­—æ®µ
    for i, col := range columns:
        field := findFieldByTag(dest, col)
        values[i] = field.Addr().Interface()

    // 4. æ‰«æ
    return rows.Scan(values...)

/* æ€§èƒ½ç‰¹æ€§ */

sqlx vs GORM:
- sqlx: æ›´æ¥è¿‘åŸç”ŸSQL,æ€§èƒ½æ›´å¥½
- GORM: æ›´é«˜å±‚æŠ½è±¡,åŠŸèƒ½æ›´ä¸°å¯Œ

åŸºå‡†æµ‹è¯•:
- sqlx: ~50k QPS
- GORM: ~40k QPS

åŸå› :
- sqlxæ›´è½»é‡
- GORMæœ‰æ›´å¤šç‰¹æ€§å¼€é”€
```

### 3.3 Entä»£ç ç”Ÿæˆ

#### Entæ¶æ„

```mathematical
/* Ent: å®ä½“æ¡†æ¶ (by Facebook) */

Ent = Schema â†’ CodeGen â†’ Type-Safe-API

/* Schemaå®šä¹‰ */

Schema:
  ä½¿ç”¨Goä»£ç å®šä¹‰æ¨¡å‹

type User struct {
    ent.Schema
}

func (User) Fields() []ent.Field {
    return []ent.Field{
        field.String("name").
            NotEmpty(),
        field.Int("age").
            Positive(),
    }
}

func (User) Edges() []ent.Edge {
    return []ent.Edge{
        edge.To("posts", Post.Type),
    }
}

/* ä»£ç ç”Ÿæˆ */

function generateCode(schema: Schema) -> Code:
    // 1. è§£æschema
    model = parseSchema(schema)

    // 2. ç”Ÿæˆå®ä½“ç±»å‹
    entity_type = generateEntityType(model)

    // 3. ç”ŸæˆæŸ¥è¯¢æ„é€ å™¨
    query_builder = generateQueryBuilder(model)

    // 4. ç”ŸæˆMutation
    mutation = generateMutation(model)

    // 5. ç”Ÿæˆå…³è”
    edges = generateEdges(model)

    return Code{
        entity_type,
        query_builder,
        mutation,
        edges
    }

/* ç±»å‹å®‰å…¨æŸ¥è¯¢ */

// Entç”Ÿæˆçš„APIæ˜¯ç±»å‹å®‰å…¨çš„
users, err := client.User.
    Query().
    Where(user.AgeGT(18)).       // ç±»å‹æ£€æŸ¥
    Where(user.NameHasPrefix("A")). // ç±»å‹æ£€æŸ¥
    All(ctx)

vs GORM:
// GORMä½¿ç”¨å­—ç¬¦ä¸²,è¿è¡Œæ—¶é”™è¯¯
db.Where("age > ?", 18).
   Where("name LIKE ?", "A%").
   Find(&users)

/* ä¼˜åŠ¿å¯¹æ¯” */

Entä¼˜åŠ¿:
1. ç¼–è¯‘æ—¶ç±»å‹å®‰å…¨
2. IDEè‡ªåŠ¨å®Œæˆ
3. é‡æ„å‹å¥½
4. æ€§èƒ½ä¼˜ç§€

åŠ£åŠ¿:
1. éœ€è¦ä»£ç ç”Ÿæˆ
2. å­¦ä¹ æ›²çº¿é™¡
3. çµæ´»æ€§è¾ƒä½
```

---

## ç¬¬å››éƒ¨åˆ†: æ¶ˆæ¯é˜Ÿåˆ—ä¸æµå¤„ç†

### 4.1 Sarama (Kafkaå®¢æˆ·ç«¯)

#### Saramaæ¶æ„

```mathematical
/* Sarama: Go Kafkaå®¢æˆ·ç«¯ */

Sarama = (Producer, Consumer, Client)

/* ç”Ÿäº§è€…æ¨¡å‹ */

Producer = {
    async: AsyncProducer | sync: SyncProducer
}

AsyncProducer interface {
    Input() chan<- *ProducerMessage
    Successes() <-chan *ProducerMessage
    Errors() <-chan *ProducerError
}

SyncProducer interface {
    SendMessage(msg *ProducerMessage) (partition int32, offset int64, err error)
}

/* ç”Ÿäº§è€…å‘é€æµç¨‹ */

function sendAsync(msg: ProducerMessage):
    // 1. åˆ†åŒºé€‰æ‹©
    partition = selectPartition(msg.Topic, msg.Key)

    // 2. åºåˆ—åŒ–
    encoded_key = encoder.Encode(msg.Key)
    encoded_value = encoder.Encode(msg.Value)

    // 3. æ‰¹å¤„ç†
    batch = getBatch(partition)
    batch.append(ProducerRecord{
        key: encoded_key,
        value: encoded_value,
        headers: msg.Headers
    })

    // 4. å‘é€ (å½“æ‰¹æ¬¡æ»¡æˆ–è¶…æ—¶)
    if batch.isFull() or timeoutExpired():
        sendBatch(batch)

/* åˆ†åŒºç­–ç•¥ */

PartitionStrategy ::=
    | RoundRobin    // è½®è¯¢
    | Hash          // å“ˆå¸Œ(Key)
    | Manual        // æ‰‹åŠ¨æŒ‡å®š
    | Random        // éšæœº

function hashPartition(key: []byte, numPartitions: int) -> int:
    hash = murmur2(key)
    return hash % numPartitions
```

#### æ¶ˆè´¹è€…æ¨¡å‹

```mathematical
/* Saramaæ¶ˆè´¹è€… */

Consumer interface {
    Subscribe(topics []string) error
    Poll(timeout time.Duration) (*ConsumerRecord, error)
    Commit() error
    Close() error
}

/* æ¶ˆè´¹è€…ç»„åè°ƒ */

ConsumerGroup = {
    members: []Member,
    coordinator: Coordinator,
    generation: int,
    protocol: Protocol
}

/* é‡å¹³è¡¡åè®® */

function rebalance(group: ConsumerGroup) -> Assignment:
    // 1. Join Group
    members = []
    for consumer in consumers:
        members.append(consumer.join(group.id))

    // 2. Elect Leader
    leader = selectLeader(members)

    // 3. Assign Partitions
    assignments = leader.assign(topics, members)

    // 4. Sync Group
    for member in members:
        assignment = assignments[member.id]
        member.sync(assignment)

    return assignments

/* åˆ†åŒºåˆ†é…ç­–ç•¥ */

AssignmentStrategy ::=
    | RangeAssignor
    | RoundRobinAssignor
    | StickyAssignor

function rangeAssignor(partitions: []Partition, consumers: []Consumer) -> Assignment:
    sort(partitions)
    sort(consumers)

    partitions_per_consumer = len(partitions) / len(consumers)
    remainder = len(partitions) % len(consumers)

    assignment = {}
    start = 0

    for i, consumer in enumerate(consumers):
        num_partitions = partitions_per_consumer
        if i < remainder:
            num_partitions += 1

        assignment[consumer] = partitions[start:start+num_partitions]
        start += num_partitions

    return assignment

/* Offsetç®¡ç† */

OffsetCommit ::=
    | AutoCommit    // è‡ªåŠ¨æäº¤
    | ManualCommit  // æ‰‹åŠ¨æäº¤

function autoCommit(interval: Duration):
    ticker = time.NewTicker(interval)

    for range ticker.C:
        for partition, offset in currentOffsets:
            commitOffset(partition, offset)

/* At-Least-Onceè¯­ä¹‰ */

ä¿è¯:
1. æ¶ˆæ¯è‡³å°‘è¢«æ¶ˆè´¹ä¸€æ¬¡
2. å¯èƒ½é‡å¤æ¶ˆè´¹

å®ç°:
function consume():
    for record in poll():
        process(record)          // å¤„ç†æ¶ˆæ¯
        commit(record.offset)    // æäº¤offset

å¦‚æœprocesså¤±è´¥,offsetæœªæäº¤ â†’ é‡æ–°æ¶ˆè´¹
```

### 4.2 NSQæ¶æ„åˆ†æ

#### NSQè®¾è®¡å“²å­¦

```mathematical
/* NSQ: å®æ—¶åˆ†å¸ƒå¼æ¶ˆæ¯å¹³å° */

NSQ = (nsqd, nsqlookupd, nsqadmin)

nsqd: æ¶ˆæ¯é˜Ÿåˆ—å®ˆæŠ¤è¿›ç¨‹
nsqlookupd: æœåŠ¡å‘ç°
nsqadmin: Webç®¡ç†ç•Œé¢

/* NSQæ¶ˆæ¯æ¨¡å‹ */

Message = {
    id: [16]byte,
    body: []byte,
    timestamp: int64,
    attempts: uint16
}

Topic = {
    name: string,
    channels: []Channel,
    messages: Queue[Message]
}

Channel = {
    name: string,
    clients: []Consumer,
    inFlightQueue: map[MessageID]Message,
    deferredQueue: PriorityQueue[Message]
}

/* æ¶ˆæ¯ä¼ é€’æµç¨‹ */

Producer â†’ nsqd:Topic â†’ Channel1, Channel2, ... â†’ Consumers

ç‰¹ç‚¹:
1. Topic-Channelæ¨¡å‹
2. æ¯ä¸ªChannelç‹¬ç«‹é˜Ÿåˆ—
3. Channelå†…æ¶ˆæ¯è´Ÿè½½å‡è¡¡

/* æ¶ˆæ¯å¯é æ€§ */

function publish(topic: string, message: []byte):
    msg = Message{
        id: generateID(),
        body: message,
        timestamp: now(),
        attempts: 0
    }

    nsqd.topic(topic).publish(msg)

function consume(channel: Channel) -> Message:
    msg = channel.pop()

    // æ·»åŠ åˆ°in-flighté˜Ÿåˆ—
    channel.inFlightQueue[msg.id] = msg

    // è®¾ç½®è¶…æ—¶
    setTimeout(msg.id, timeout, func():
        if msg.id in channel.inFlightQueue:
            // è¶…æ—¶æœªç¡®è®¤,é‡æ–°å…¥é˜Ÿ
            msg.attempts += 1
            if msg.attempts < maxAttempts:
                channel.requeue(msg)
            else:
                channel.moveToDeadLetter(msg)
    )

    return msg

function finish(messageID: MessageID):
    // ç¡®è®¤æ¶ˆæ¯,ä»in-flightç§»é™¤
    delete(channel.inFlightQueue, messageID)
    cancelTimeout(messageID)

/* æœåŠ¡å‘ç° */

nsqlookupd:
  ç»´æŠ¤nsqdå®ä¾‹æ³¨å†Œè¡¨
  å®¢æˆ·ç«¯é€šè¿‡nsqlookupdå‘ç°nsqd

function discoverProducers(topic: string) -> []nsqdAddress:
    return nsqlookupd.lookup(topic)

å®¢æˆ·ç«¯è¿æ¥ç­–ç•¥:
1. æŸ¥è¯¢nsqlookupdè·å–nsqdåˆ—è¡¨
2. è¿æ¥æ‰€æœ‰nsqdå®ä¾‹
3. ä»æ‰€æœ‰è¿æ¥è´Ÿè½½å‡è¡¡æ¶ˆè´¹
```

### 4.3 NATSå½¢å¼åŒ–æ¨¡å‹

#### NATSæ ¸å¿ƒæŠ½è±¡

```mathematical
/* NATS: é«˜æ€§èƒ½æ¶ˆæ¯ç³»ç»Ÿ */

NATS = (Publish/Subscribe, Request/Reply, Queue Groups)

/* å‘å¸ƒè®¢é˜…æ¨¡å‹ */

Subject = String  // "foo.bar.baz"

Subscription = {
    subject: Subject,
    queue: Option[String],
    handler: Message â†’ void
}

function subscribe(subject: Subject, handler: Handler) -> Subscription:
    sub = Subscription{
        subject: subject,
        handler: handler
    }

    nats.register(sub)
    return sub

function publish(subject: Subject, data: []byte):
    // é€šé…ç¬¦åŒ¹é…è®¢é˜…
    subscriptions = nats.match(subject)

    msg = Message{subject: subject, data: data}

    for sub in subscriptions:
        sub.handler(msg)

/* é€šé…ç¬¦åŒ¹é… */

Wildcard:
  *  : åŒ¹é…ä¸€ä¸ªtoken
  >  : åŒ¹é…æ‰€æœ‰å‰©ä½™token

ç¤ºä¾‹:
"foo.*.baz"  matches "foo.bar.baz"
"foo.>"      matches "foo.bar.baz", "foo.bar"

function matchSubject(pattern: String, subject: String) -> bool:
    pattern_tokens = split(pattern, ".")
    subject_tokens = split(subject, ".")

    i = 0
    j = 0

    while i < len(pattern_tokens) and j < len(subject_tokens):
        if pattern_tokens[i] == "*":
            i += 1
            j += 1
        elif pattern_tokens[i] == ">":
            return true  // åŒ¹é…æ‰€æœ‰å‰©ä½™
        elif pattern_tokens[i] == subject_tokens[j]:
            i += 1
            j += 1
        else:
            return false

    return i == len(pattern_tokens) and j == len(subject_tokens)

/* Request/Replyæ¨¡å¼ */

function request(subject: Subject, data: []byte, timeout: Duration) -> Response:
    // 1. åˆ›å»ºå”¯ä¸€å›å¤subject
    replySubject = generateReplySubject()

    // 2. è®¢é˜…å›å¤subject
    replyChan = make(chan Message, 1)
    sub = subscribe(replySubject, func(msg Message):
        replyChan <- msg
    )
    defer sub.unsubscribe()

    // 3. å‘å¸ƒè¯·æ±‚
    msg = Message{
        subject: subject,
        replyTo: replySubject,
        data: data
    }
    publish(msg)

    // 4. ç­‰å¾…å›å¤
    select {
    case reply := <-replyChan:
        return reply
    case <-time.After(timeout):
        return error("timeout")
    }

/* é˜Ÿåˆ—ç»„ (Queue Groups) */

QueueGroup = {
    name: String,
    members: []Subscription
}

ç‰¹æ€§:
- åŒä¸€queue groupå†…,æ¶ˆæ¯åªå‘ç»™ä¸€ä¸ªæˆå‘˜
- å®ç°è´Ÿè½½å‡è¡¡

function subscribeQueue(subject: Subject, queue: String, handler: Handler):
    sub = Subscription{
        subject: subject,
        queue: Some(queue),
        handler: handler
    }

    nats.registerQueue(sub)

function publish(subject: Subject, data: []byte):
    // 1. æ™®é€šè®¢é˜…:å¹¿æ’­
    normal_subs = nats.matchNormal(subject)
    for sub in normal_subs:
        sub.handler(Message{subject, data})

    // 2. é˜Ÿåˆ—ç»„:è´Ÿè½½å‡è¡¡
    queue_groups = nats.matchQueueGroups(subject)
    for group in queue_groups:
        member = group.selectMember()  // è½®è¯¢æˆ–éšæœº
        member.handler(Message{subject, data})
```

---

## ç¬¬äº”éƒ¨åˆ†: äº‘åŸç”Ÿå·¥å…·é“¾

### 5.1 Kubernetes Client-Go

#### Client-Goæ¶æ„

```mathematical
/* Kubernetes Client-Go */

ClientGo = (ClientSet, Informer, WorkQueue, Controller)

/* ClientSet: APIå®¢æˆ·ç«¯ */

ClientSet = {
    CoreV1: CoreV1Interface,
    AppsV1: AppsV1Interface,
    BatchV1: BatchV1Interface,
    ...
}

CoreV1Interface = {
    Pods(namespace): PodInterface,
    Services(namespace): ServiceInterface,
    ConfigMaps(namespace): ConfigMapInterface,
    ...
}

/* RESTful APIè°ƒç”¨ */

function getPod(namespace, name: String) -> *v1.Pod:
    result = clientset.CoreV1().
        Pods(namespace).
        Get(context.TODO(), name, metav1.GetOptions{})

    return result

/* Informeræœºåˆ¶ */

Informer = (ListWatch, Store, Controller)

ListWatch:
  - List: åˆå§‹è·å–æ‰€æœ‰èµ„æº
  - Watch: ç›‘å¬èµ„æºå˜åŒ–

Store:
  - æœ¬åœ°ç¼“å­˜,å­˜å‚¨èµ„æºå¯¹è±¡

Controller:
  - å¤„ç†èµ„æºå˜åŒ–äº‹ä»¶

function createInformer(lw: ListWatch) -> Informer:
    store = NewStore()

    // List-Watchå¾ªç¯
    go func():
        // 1. Listè·å–åˆå§‹èµ„æº
        list = lw.List()
        for item in list:
            store.Add(item)

        // 2. Watchç›‘å¬å˜åŒ–
        watcher = lw.Watch(resourceVersion)
        for event in watcher:
            match event.Type:
                case Added:
                    store.Add(event.Object)
                    handleAdd(event.Object)
                case Modified:
                    store.Update(event.Object)
                    handleUpdate(event.Object)
                case Deleted:
                    store.Delete(event.Object)
                    handleDelete(event.Object)
    ()

    return Informer{lw, store, controller}

/* SharedInformer */

SharedInformer:
  å¤šä¸ªControllerå…±äº«ä¸€ä¸ªInformer
  å‡å°‘API Serverå‹åŠ›

function newSharedInformer(lw: ListWatch) -> SharedInformer:
    informer = createInformer(lw)

    eventHandlers = []

    informer.AddEventHandler = func(handler: ResourceEventHandler):
        eventHandlers.append(handler)

    // äº‹ä»¶åˆ†å‘
    informer.handleEvent = func(event: Event):
        for handler in eventHandlers:
            handler.OnEvent(event)

    return informer
```

#### Controlleræ¨¡å¼

```mathematical
/* Kubernetes Controller Pattern */

Controller = {
    informer: Informer,
    workqueue: WorkQueue,
    reconcile: ReconcileFunc
}

/* Reconcileå¾ªç¯ */

function runController(controller: Controller):
    // 1. å¯åŠ¨Informer
    controller.informer.AddEventHandler(ResourceEventHandlerFuncs{
        AddFunc: func(obj interface{}):
            key = cache.MetaNamespaceKeyFunc(obj)
            controller.workqueue.Add(key)

        UpdateFunc: func(old, new interface{}):
            key = cache.MetaNamespaceKeyFunc(new)
            controller.workqueue.Add(key)

        DeleteFunc: func(obj interface{}):
            key = cache.MetaNamespaceKeyFunc(obj)
            controller.workqueue.Add(key)
    })

    controller.informer.Run()

    // 2. å¤„ç†å·¥ä½œé˜Ÿåˆ—
    for controller.processNextItem():
        // å¾ªç¯å¤„ç†

function processNextItem() -> bool:
    // 1. ä»é˜Ÿåˆ—å–å‡ºkey
    key, quit = workqueue.Get()
    if quit:
        return false

    defer workqueue.Done(key)

    // 2. Reconcile
    err = reconcile(key)

    // 3. é”™è¯¯å¤„ç†
    if err != nil:
        if workqueue.NumRequeues(key) < maxRetries:
            workqueue.AddRateLimited(key)
        else:
            workqueue.Forget(key)
            log.Error("Max retries reached", key)
    else:
        workqueue.Forget(key)

    return true

/* Reconcileå‡½æ•° */

function reconcile(key: String) -> error:
    // 1. ä»Storeè·å–å¯¹è±¡
    obj, exists = informer.GetStore().GetByKey(key)

    if not exists:
        // å¯¹è±¡å·²åˆ é™¤
        return nil

    // 2. è·å–æœŸæœ›çŠ¶æ€ (Spec)
    desired = obj.Spec

    // 3. è·å–å½“å‰çŠ¶æ€ (Status)
    current = getActualState(obj)

    // 4. è°ƒè°: ä½¿current â†’ desired
    if current != desired:
        applyChanges(obj, desired)

    // 5. æ›´æ–°Status
    obj.Status = current
    updateStatus(obj)

    return nil
```

### 5.2 Prometheusç›‘æ§

#### Prometheus Goå®¢æˆ·ç«¯

```mathematical
/* Prometheus Metrics */

Metric ::=
    | Counter      // åªå¢è®¡æ•°å™¨
    | Gauge        // å¯å¢å¯å‡
    | Histogram    // ç›´æ–¹å›¾
    | Summary      // æ‘˜è¦

/* Counter */

Counter = {
    value: float64,
    labels: map[string]string
}

function inc(counter: Counter, delta: float64):
    atomic.AddFloat64(&counter.value, delta)

ä½¿ç”¨:
requestsTotal = prometheus.NewCounter(prometheus.CounterOpts{
    Name: "http_requests_total",
    Help: "Total number of HTTP requests"
})

requestsTotal.Inc()

/* Gauge */

Gauge = {
    value: float64
}

function set(gauge: Gauge, value: float64):
    atomic.StoreFloat64(&gauge.value, value)

function inc(gauge: Gauge):
    atomic.AddFloat64(&gauge.value, 1)

function dec(gauge: Gauge):
    atomic.AddFloat64(&gauge.value, -1)

ä½¿ç”¨:
currentConnections = prometheus.NewGauge(prometheus.GaugeOpts{
    Name: "current_connections",
    Help: "Current number of connections"
})

currentConnections.Set(42)

/* Histogram */

Histogram = {
    buckets: []float64,
    counts: []uint64,
    sum: float64
}

function observe(h: Histogram, value: float64):
    // 1. æ›´æ–°sum
    atomic.AddFloat64(&h.sum, value)

    // 2. æ‰¾åˆ°å¯¹åº”bucket
    for i, upperBound in enumerate(h.buckets):
        if value <= upperBound:
            atomic.AddUint64(&h.counts[i], 1)

ä½¿ç”¨:
requestDuration = prometheus.NewHistogram(prometheus.HistogramOpts{
    Name: "http_request_duration_seconds",
    Help: "HTTP request duration",
    Buckets: []float64{0.1, 0.5, 1, 2, 5}
})

start := time.Now()
// ... handle request ...
duration := time.Since(start).Seconds()
requestDuration.Observe(duration)

/* Summary */

Summary = {
    objectives: map[float64]float64,  // quantile â†’ error
    observations: []float64
}

ä½¿ç”¨:
requestLatency = prometheus.NewSummary(prometheus.SummaryOpts{
    Name: "http_request_latency_seconds",
    Help: "HTTP request latency",
    Objectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001}
})

/* æŒ‡æ ‡å¯¼å‡º */

function exposeMetrics():
    http.Handle("/metrics", promhttp.Handler())
    http.ListenAndServe(":2112", nil)

PromQLæŸ¥è¯¢:
rate(http_requests_total[5m])           // 5åˆ†é’Ÿå†…QPS
histogram_quantile(0.95, http_request_duration_seconds_bucket)  // P95å»¶è¿Ÿ
```

### 5.3 etcdåˆ†å¸ƒå¼åè°ƒ

#### etcd Goå®¢æˆ·ç«¯

```mathematical
/* etcd v3 API */

etcd = (KV, Watch, Lease, Election, Lock)

/* KVå­˜å‚¨ */

function put(key, value: String) -> (*PutResponse, error):
    ctx, cancel = context.WithTimeout(context.Background(), timeout)
    defer cancel()

    return client.Put(ctx, key, value)

function get(key: String) -> (*GetResponse, error):
    ctx, cancel = context.WithTimeout(context.Background(), timeout)
    defer cancel()

    return client.Get(ctx, key)

function delete(key: String) -> (*DeleteResponse, error):
    ctx, cancel = context.WithTimeout(context.Background(), timeout)
    defer cancel()

    return client.Delete(ctx, key)

/* äº‹åŠ¡ (Transaction) */

Txn = {
    If: []Cmp,      // æ¡ä»¶
    Then: []Op,     // æˆåŠŸæ‰§è¡Œ
    Else: []Op      // å¤±è´¥æ‰§è¡Œ
}

function transaction(txn: Txn) -> (*TxnResponse, error):
    return client.Txn(context.TODO()).
        If(txn.If...).
        Then(txn.Then...).
        Else(txn.Else...).
        Commit()

ç¤ºä¾‹: CAS (Compare-And-Swap)
txn := client.Txn(ctx).
    If(clientv3.Compare(clientv3.Value("key"), "=", "old_value")).
    Then(clientv3.OpPut("key", "new_value")).
    Else(clientv3.OpGet("key"))

/* Watchæœºåˆ¶ */

function watch(key: String) -> WatchChan:
    watchChan = client.Watch(context.Background(), key)

    go func():
        for watchResponse in watchChan:
            for event in watchResponse.Events:
                match event.Type:
                    case PUT:
                        handlePut(event.Kv.Key, event.Kv.Value)
                    case DELETE:
                        handleDelete(event.Kv.Key)
    ()

    return watchChan

/* Leaseç§Ÿçº¦ */

function createLease(ttl: int64) -> (LeaseID, error):
    resp, err = client.Grant(context.TODO(), ttl)
    if err != nil:
        return 0, err

    return resp.ID, nil

function keepAlive(leaseID: LeaseID):
    keepAliveChan, err = client.KeepAlive(context.TODO(), leaseID)
    if err != nil:
        return err

    // æŒç»­æ¥æ”¶keep-aliveå“åº”
    for ka := range keepAliveChan:
        log.Printf("Keep-alive: %v", ka)

ä½¿ç”¨åœºæ™¯:
1. ä¸´æ—¶é”®å€¼: Put(key, value, WithLease(leaseID))
2. æœåŠ¡æ³¨å†Œ: æ³¨å†Œæ—¶åˆ›å»ºç§Ÿçº¦,ä¿æŒå¿ƒè·³
3. åˆ†å¸ƒå¼é”: åŸºäºç§Ÿçº¦çš„é”

/* åˆ†å¸ƒå¼é” */

function acquireLock(key: String, ttl: int64) -> (Lock, error):
    // 1. åˆ›å»ºç§Ÿçº¦
    lease, err = createLease(ttl)
    if err != nil:
        return nil, err

    // 2. å°è¯•è·å–é” (CAS)
    txn = client.Txn(context.TODO()).
        If(clientv3.Compare(clientv3.CreateRevision(key), "=", 0)).
        Then(clientv3.OpPut(key, value, clientv3.WithLease(lease))).
        Else(clientv3.OpGet(key))

    resp, err = txn.Commit()
    if err != nil:
        return nil, err

    if !resp.Succeeded:
        // é”å·²è¢«æŒæœ‰
        return nil, error("lock held")

    // 3. Keep-alive
    go keepAlive(lease)

    return Lock{leaseID: lease, key: key}, nil

function releaseLock(lock: Lock) -> error:
    // æ’¤é”€ç§Ÿçº¦,è‡ªåŠ¨åˆ é™¤key
    return client.Revoke(context.TODO(), lock.leaseID)
```

---

## ç¬¬å…­éƒ¨åˆ†: å¹¶å‘ä¸å¼‚æ­¥

### 6.1 antsåç¨‹æ± 

#### antsè®¾è®¡åˆ†æ

```mathematical
/* ants: é«˜æ€§èƒ½goroutineæ±  */

Pool = {
    capacity: int,
    running: int,
    workers: []*worker,
    lock: sync.Locker,
    cond: *sync.Cond
}

Worker = {
    pool: *Pool,
    task: chan func(),
    recycleTime: time.Time
}

/* æäº¤ä»»åŠ¡ */

function submit(pool: *Pool, task: func()) -> error:
    pool.lock.Lock()
    defer pool.lock.Unlock()

    // 1. æ£€æŸ¥æ˜¯å¦æœ‰ç©ºé—²worker
    if len(pool.workers) > 0:
        worker = pool.workers[0]
        pool.workers = pool.workers[1:]
        worker.task <- task
        return nil

    // 2. æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ›å»ºæ–°worker
    if pool.running < pool.capacity:
        worker = newWorker(pool)
        worker.start()
        worker.task <- task
        pool.running++
        return nil

    // 3. ç­‰å¾…ç©ºé—²worker
    pool.cond.Wait()
    return submit(pool, task)

/* Workeræ‰§è¡Œ */

function (w *Worker) start():
    go func():
        for task := range w.task:
            task()  // æ‰§è¡Œä»»åŠ¡
            w.recycleTime = time.Now()
            w.pool.putWorker(w)  // å›æ”¶worker
    ()

function (p *Pool) putWorker(w *Worker):
    p.lock.Lock()
    defer p.lock.Unlock()

    p.workers = append(p.workers, w)
    p.cond.Signal()  // å”¤é†’ç­‰å¾…çš„submit

/* æ¸…ç†æœºåˆ¶ */

function (p *Pool) periodicallyPurge():
    ticker := time.NewTicker(cleanInterval)

    for range ticker.C:
        p.lock.Lock()

        // æ¸…ç†è¶…æ—¶çš„worker
        now := time.Now()
        n := 0
        for _, w := range p.workers:
            if now.Sub(w.recycleTime) > expiryDuration:
                w.stop()
                p.running--
            else:
                p.workers[n] = w
                n++

        p.workers = p.workers[:n]
        p.lock.Unlock()

/* æ€§èƒ½ä¼˜åŠ¿ */

vs ç›´æ¥ä½¿ç”¨goroutine:
1. å¤ç”¨goroutine,å‡å°‘åˆ›å»ºå¼€é”€
2. æ§åˆ¶å¹¶å‘æ•°,é¿å…è¿‡è½½
3. å‡å°‘GCå‹åŠ›

åŸºå‡†æµ‹è¯•:
- ç›´æ¥goroutine: 100k ops/s, 50MBå†…å­˜
- antsæ± : 500k ops/s, 10MBå†…å­˜

æå‡5Ã—åå, å‡å°‘80%å†…å­˜
```

### 6.2 panjf2000/gnetç½‘ç»œåº“

#### gnetäº‹ä»¶é©±åŠ¨æ¶æ„

```mathematical
/* gnet: é«˜æ€§èƒ½ç½‘ç»œåº“ */

gnet = EventLoop + Reactor

/* Reactoræ¨¡å¼ */

Reactor = {
    poller: Poller,        // epoll/kqueue
    handlers: map[FD]Handler,
    eventQueue: Queue[Event]
}

Poller ::= Epoll (Linux) | Kqueue (macOS/BSD) | IOCP (Windows)

/* äº‹ä»¶å¾ªç¯ */

function runEventLoop(reactor: *Reactor):
    for:
        // 1. Polläº‹ä»¶
        events = reactor.poller.Wait(timeout)

        // 2. å¤„ç†äº‹ä»¶
        for event in events:
            fd = event.FD
            handler = reactor.handlers[fd]

            match event.Type:
                case Readable:
                    handler.OnRead()
                case Writable:
                    handler.OnWrite()
                case Error:
                    handler.OnError()

/* é›¶æ‹·è´è®¾è®¡ */

ReadBuffer = {
    head: *byte,
    tail: *byte,
    capacity: int
}

function read(conn: Conn, buf: ReadBuffer) -> (n int, err error):
    // ç›´æ¥è¯»å…¥buffer,æ— é¢å¤–æ‹·è´
    n = syscall.Read(conn.fd, buf.head[:buf.capacity])
    buf.tail = buf.head + n
    return n, nil

/* å¤šReactoræ¶æ„ */

MainReactor: å¤„ç†Accept
SubReactors: å¤„ç†Read/Write (å¤šä¸ª,ç»‘å®šCPUæ ¸å¿ƒ)

function multiReactor(numReactors: int):
    // ä¸»Reactor
    mainReactor = newReactor()
    mainReactor.register(listenFD, func(event):
        clientFD = accept(listenFD)

        // é€‰æ‹©ä¸€ä¸ªSubReactor
        subReactor = selectSubReactor()
        subReactor.register(clientFD, clientHandler)
    )

    // å¤šä¸ªSubReactor
    subReactors = []
    for i in 0..numReactors:
        subReactor = newReactor()
        subReactor.bindCPU(i)
        go subReactor.runEventLoop()
        subReactors.append(subReactor)

    mainReactor.runEventLoop()

/* æ€§èƒ½ç‰¹æ€§ */

åŸºå‡†æµ‹è¯• (Echo Server):
- gnet: 1.2M QPS
- netåŒ…: 200k QPS

æå‡6Ã—æ€§èƒ½

åŸå› :
1. äº‹ä»¶é©±åŠ¨,é›¶æ‹·è´
2. å¤šReactoræ¶æ„
3. æ— goroutine-per-connectionå¼€é”€
```

### 6.3 errgroupé”™è¯¯ç»„

#### errgroupè®¾è®¡

```mathematical
/* errgroup: å¹¶å‘é”™è¯¯å¤„ç† */

Group = {
    cancel: func(),
    wg: sync.WaitGroup,
    errOnce: sync.Once,
    err: error
}

/* åˆ›å»ºGroup */

function WithContext(ctx: Context) -> (*Group, Context):
    ctx, cancel = context.WithCancel(ctx)

    return &Group{
        cancel: cancel
    }, ctx

/* æ‰§è¡Œå¹¶å‘ä»»åŠ¡ */

function (g *Group) Go(f: func() error):
    g.wg.Add(1)

    go func():
        defer g.wg.Done()

        if err := f(); err != nil:
            // åªè®°å½•ç¬¬ä¸€ä¸ªé”™è¯¯
            g.errOnce.Do(func():
                g.err = err
                if g.cancel != nil:
                    g.cancel()  // å–æ¶ˆå…¶ä»–goroutine
            )

/* ç­‰å¾…æ‰€æœ‰ä»»åŠ¡ */

function (g *Group) Wait() -> error:
    g.wg.Wait()

    if g.cancel != nil:
        g.cancel()

    return g.err

/* ä½¿ç”¨ç¤ºä¾‹ */

g, ctx := errgroup.WithContext(context.Background())

// å¹¶å‘æ‰§è¡Œå¤šä¸ªä»»åŠ¡
for _, url := range urls:
    url := url  // æ•è·å¾ªç¯å˜é‡
    g.Go(func() error:
        return fetch(ctx, url)
    )

// ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ,è¿”å›ç¬¬ä¸€ä¸ªé”™è¯¯
if err := g.Wait(); err != nil:
    return err

/* é™åˆ¶å¹¶å‘æ•° */

function (g *Group) SetLimit(n: int):
    g.sem = make(chan struct{}, n)

function (g *Group) Go(f: func() error):
    if g.sem != nil:
        g.sem <- struct{}{}  // è·å–ä¿¡å·é‡

    g.wg.Add(1)

    go func():
        defer func():
            if g.sem != nil:
                <-g.sem  // é‡Šæ”¾ä¿¡å·é‡
            g.wg.Done()
        ()

        if err := f(); err != nil:
            g.errOnce.Do(func():
                g.err = err
                if g.cancel != nil:
                    g.cancel()
            )

ä½¿ç”¨:
g.SetLimit(10)  // æœ€å¤š10ä¸ªå¹¶å‘
for _, url in urls:
    g.Go(func() error:
        return fetch(url)
    )
```

---

## ğŸ¯ æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†Goå¼€æºç”Ÿæ€ç³»ç»Ÿçš„å…¨é¢å½¢å¼åŒ–åˆ†æ,æ¶µç›–:

### æ ¸å¿ƒç”Ÿæ€

1. **Webæ¡†æ¶** (Gin, Echo, Fiber)
   - è·¯ç”±ç®—æ³•åˆ†æ
   - ä¸­é—´ä»¶æœºåˆ¶
   - æ€§èƒ½å¯¹æ¯”

2. **å¾®æœåŠ¡æ¡†æ¶** (Go-Micro, Kratos, Go-Zero, Kitex)
   - æœåŠ¡æ³¨å†Œä¸å‘ç°
   - RPCé€šä¿¡æ¨¡å‹
   - æœåŠ¡æ²»ç†

3. **ORMä¸æ•°æ®åº“** (GORM, sqlx, Ent)
   - æŸ¥è¯¢æ„é€ å™¨
   - å…³è”å…³ç³»
   - æ€§èƒ½ä¼˜åŒ–

4. **æ¶ˆæ¯é˜Ÿåˆ—** (Sarama, NSQ, NATS)
   - æ¶ˆæ¯ä¼ é€’æ¨¡å‹
   - å¯é æ€§ä¿è¯
   - åˆ†å¸ƒå¼åè°ƒ

5. **äº‘åŸç”Ÿå·¥å…·** (Client-Go, Prometheus, etcd)
   - Kubernetesé›†æˆ
   - ç›‘æ§æŒ‡æ ‡
   - åˆ†å¸ƒå¼é”

6. **å¹¶å‘åº“** (ants, gnet, errgroup)
   - åç¨‹æ± 
   - äº‹ä»¶é©±åŠ¨ç½‘ç»œ
   - é”™è¯¯å¤„ç†

### é€‰å‹æŒ‡å—

åŸºäºæ€§èƒ½ã€åŠŸèƒ½ã€ç”Ÿæ€æˆç†Ÿåº¦çš„ç»¼åˆåˆ†æ,ä¸ºä¸åŒåœºæ™¯æä¾›æ¨èã€‚

### æœ€ä½³å®è·µ

ç»“åˆå½¢å¼åŒ–åˆ†æä¸å®é™…æ¡ˆä¾‹,æä¾›å·¥ç¨‹æœ€ä½³å®è·µã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0

<div align="center">

Made with â¤ï¸ for Go Ecosystem Researchers

[â¬† å›åˆ°é¡¶éƒ¨](#å›åˆ°é¡¶éƒ¨)

</div>
