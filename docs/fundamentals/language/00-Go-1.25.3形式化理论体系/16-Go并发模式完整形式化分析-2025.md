# Goå¹¶å‘æ¨¡å¼å®Œæ•´å½¢å¼åŒ–åˆ†æ

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**åŸºå‡†æ—¥æœŸ**: 2025å¹´10æœˆ23æ—¥  
**Goç‰ˆæœ¬**: Go 1.25.3  
**ç†è®ºåŸºç¡€**: CSP + Ï€-calculus + Session Types + Actor Model  
**å­—æ•°**: ~32,000å­—

---

## ğŸ“‹ ç›®å½•

- [ç¬¬ä¸€éƒ¨åˆ†: ç»å…¸å¹¶å‘æ¨¡å¼](#ç¬¬ä¸€éƒ¨åˆ†-ç»å…¸å¹¶å‘æ¨¡å¼)
  - [1.1 ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼](#11-ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼)
    - [CSPå½¢å¼åŒ–](#cspå½¢å¼åŒ–)
    - [å¸¦ç¼“å†²çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…](#å¸¦ç¼“å†²çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…)
  - [1.2 Fan-Out/Fan-Inæ¨¡å¼](#12-fan-outfan-inæ¨¡å¼)
    - [Fan-Outå½¢å¼åŒ–](#fan-outå½¢å¼åŒ–)
    - [Fan-Inå½¢å¼åŒ–](#fan-inå½¢å¼åŒ–)
    - [å®Œæ•´Fan-Out/Fan-Inç³»ç»Ÿ](#å®Œæ•´fan-outfan-inç³»ç»Ÿ)
  - [1.3 Pipelineæ¨¡å¼](#13-pipelineæ¨¡å¼)
    - [Pipelineå½¢å¼åŒ–](#pipelineå½¢å¼åŒ–)
    - [å¹¶è¡ŒPipeline](#å¹¶è¡Œpipeline)
  - [1.4 Worker Poolæ¨¡å¼](#14-worker-poolæ¨¡å¼)
    - [Worker Poolå½¢å¼åŒ–](#worker-poolå½¢å¼åŒ–)
    - [åŠ¨æ€Worker Pool](#åŠ¨æ€worker-pool)
- [ç¬¬äºŒéƒ¨åˆ†: åŒæ­¥æ¨¡å¼](#ç¬¬äºŒéƒ¨åˆ†-åŒæ­¥æ¨¡å¼)
  - [2.1 BarrieråŒæ­¥](#21-barrieråŒæ­¥)
    - [Barrierå½¢å¼åŒ–](#barrierå½¢å¼åŒ–)
  - [2.2 Future/Promiseæ¨¡å¼](#22-futurepromiseæ¨¡å¼)
    - [Futureå½¢å¼åŒ–](#futureå½¢å¼åŒ–)
  - [2.3 ä¿¡å·é‡æ¨¡å¼](#23-ä¿¡å·é‡æ¨¡å¼)
    - [ä¿¡å·é‡å½¢å¼åŒ–](#ä¿¡å·é‡å½¢å¼åŒ–)
  - [2.4 ç­‰å¾…ç»„æ¨¡å¼](#24-ç­‰å¾…ç»„æ¨¡å¼)
    - [WaitGroupå½¢å¼åŒ–](#waitgroupå½¢å¼åŒ–)
- [ç¬¬ä¸‰éƒ¨åˆ†: æ§åˆ¶æµæ¨¡å¼](#ç¬¬ä¸‰éƒ¨åˆ†-æ§åˆ¶æµæ¨¡å¼)
  - [3.1 è¶…æ—¶ä¸å–æ¶ˆ](#31-è¶…æ—¶ä¸å–æ¶ˆ)
    - [Contextè¶…æ—¶å½¢å¼åŒ–](#contextè¶…æ—¶å½¢å¼åŒ–)
    - [å–æ¶ˆä¼ æ’­](#å–æ¶ˆä¼ æ’­)
  - [3.2 é‡è¯•ä¸é€€é¿](#32-é‡è¯•ä¸é€€é¿)
    - [é‡è¯•ç­–ç•¥å½¢å¼åŒ–](#é‡è¯•ç­–ç•¥å½¢å¼åŒ–)
  - [3.3 ç†”æ–­å™¨æ¨¡å¼](#33-ç†”æ–­å™¨æ¨¡å¼)
    - [ç†”æ–­å™¨å½¢å¼åŒ–](#ç†”æ–­å™¨å½¢å¼åŒ–)
  - [3.4 é™æµæ¨¡å¼](#34-é™æµæ¨¡å¼)
    - [ä»¤ç‰Œæ¡¶ç®—æ³•](#ä»¤ç‰Œæ¡¶ç®—æ³•)
- [ç¬¬å››éƒ¨åˆ†: æ•°æ®æµæ¨¡å¼](#ç¬¬å››éƒ¨åˆ†-æ•°æ®æµæ¨¡å¼)
  - [4.1 æµå¼å¤„ç†](#41-æµå¼å¤„ç†)
    - [æµå¤„ç†å½¢å¼åŒ–](#æµå¤„ç†å½¢å¼åŒ–)
  - [4.2 èƒŒå‹æ§åˆ¶](#42-èƒŒå‹æ§åˆ¶)
    - [èƒŒå‹å½¢å¼åŒ–](#èƒŒå‹å½¢å¼åŒ–)
  - [4.3 æ‰¹å¤„ç†æ¨¡å¼](#43-æ‰¹å¤„ç†æ¨¡å¼)
    - [æ‰¹å¤„ç†å½¢å¼åŒ–](#æ‰¹å¤„ç†å½¢å¼åŒ–)
  - [4.4 çª—å£èšåˆ](#44-çª—å£èšåˆ)
    - [æ»‘åŠ¨çª—å£å½¢å¼åŒ–](#æ»‘åŠ¨çª—å£å½¢å¼åŒ–)
- [ç¬¬äº”éƒ¨åˆ†: Actoræ¨¡å¼](#ç¬¬äº”éƒ¨åˆ†-actoræ¨¡å¼)
  - [5.1 Actoræ¨¡å‹å½¢å¼åŒ–](#51-actoræ¨¡å‹å½¢å¼åŒ–)
  - [5.2 Goroutineä½œä¸ºActor](#52-goroutineä½œä¸ºactor)
    - [Goroutine-Actoræ˜ å°„](#goroutine-actoræ˜ å°„)
  - [5.3 ç›‘ç£æ ‘æ¨¡å¼](#53-ç›‘ç£æ ‘æ¨¡å¼)
    - [ç›‘ç£è€…å½¢å¼åŒ–](#ç›‘ç£è€…å½¢å¼åŒ–)
- [ç¬¬å…­éƒ¨åˆ†: Session Types](#ç¬¬å…­éƒ¨åˆ†-session-types)
  - [6.1 Session Typesç†è®º](#61-session-typesç†è®º)
  - [6.2 Channelåè®®](#62-channelåè®®)
    - [Protocolå®šä¹‰](#protocolå®šä¹‰)
  - [6.3 åè®®æ­£ç¡®æ€§éªŒè¯](#63-åè®®æ­£ç¡®æ€§éªŒè¯)
    - [åè®®å…¼å®¹æ€§æ£€æŸ¥](#åè®®å…¼å®¹æ€§æ£€æŸ¥)
- [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
  - [æ ¸å¿ƒå†…å®¹](#æ ¸å¿ƒå†…å®¹)
  - [ç†è®ºè´¡çŒ®](#ç†è®ºè´¡çŒ®)
  - [å·¥ç¨‹ä»·å€¼](#å·¥ç¨‹ä»·å€¼)

## ç¬¬ä¸€éƒ¨åˆ†: ç»å…¸å¹¶å‘æ¨¡å¼

### 1.1 ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼

#### CSPå½¢å¼åŒ–

```mathematical
/* ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼çš„CSPè¡¨ç¤º */

ç³»ç»Ÿ = Producer || Consumer || Buffer

Producer = produce â†’ buffer!item â†’ Producer

Consumer = buffer?item â†’ consume(item) â†’ Consumer

Buffer = (
    buffer?item â†’ Buffer'(item)  // æ¥æ”¶
  | buffer!item â†’ Buffer         // å‘é€
)

/* ä½¿ç”¨Channelå®ç° */

ç³»ç»Ÿ:
  ch = make(chan Item)
  go Producer(ch)
  go Consumer(ch)

Producer(ch):
  PRODUCER = produce() â†’ ch!item â†’ PRODUCER

Consumer(ch):
  CONSUMER = ch?item â†’ consume(item) â†’ CONSUMER

/* æ€§è´¨éªŒè¯ */

1. æ´»è·ƒæ€§ (Liveness):
   âˆ€ item. produced(item) âŸ¹ â—‡consumed(item)
   
   è¯æ˜: Channelä¿è¯FIFOé¡ºåº,
         ConsumeræŒç»­æ¥æ”¶,
         å› æ­¤æ‰€æœ‰ç”Ÿäº§çš„itemæœ€ç»ˆè¢«æ¶ˆè´¹ âœ“

2. å®‰å…¨æ€§ (Safety):
   consumed(item) âŸ¹ produced(item)
   
   è¯æ˜: Channelåªä¼ è¾“ç”Ÿäº§çš„item,
         ä¸ä¼šå‡­ç©ºäº§ç”Ÿitem âœ“

3. æ— æ­»é”:
   ç³»ç»Ÿä¸ä¼šé™·å…¥æ‰€æœ‰è¿›ç¨‹éƒ½é˜»å¡çš„çŠ¶æ€
   
   è¯æ˜: Producerå’ŒConsumeräº¤æ›¿è¿è¡Œ,
         Channelä½œä¸ºç¼“å†²,é¿å…æ­»é” âœ“
```

#### å¸¦ç¼“å†²çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…

```mathematical
/* å¸¦ç¼“å†²çš„Channel */

BufferedChannel(n) = 
  (buffer?item â†’ BufferedChannel(n-1))  if n > 0
| (buffer!item â†’ BufferedChannel(n+1))  if n < capacity

/* å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€… */

ç³»ç»Ÿ = Pâ‚ || Pâ‚‚ || ... || Pâ‚™ || Câ‚ || Câ‚‚ || ... || Câ‚˜ || Buffer

å½¢å¼åŒ–åˆ†æ:

1. å…¬å¹³æ€§ (Fairness):
   æ¯ä¸ªConsumeræœ‰å…¬å¹³æœºä¼šè·å–item
   
   Goçš„Channelå®ç°äº†å…¬å¹³è°ƒåº¦ âœ“

2. ååé‡:
   Throughput = min(âˆ‘áµ¢ rate(Páµ¢), âˆ‘â±¼ rate(Câ±¼))

3. ç¼“å†²åŒºå¤§å°å½±å“:
   buffer_size â†‘ âŸ¹ decoupling â†‘
   buffer_size â†‘ âŸ¹ memory â†‘

/* Goå®ç° */

func producer(ch chan<- int, id int) {
    for i := 0; ; i++ {
        item := produce(id, i)
        ch <- item  // CSP: ch!item
        log.Printf("Producer %d: produced %d", id, item)
    }
}

func consumer(ch <-chan int, id int) {
    for item := range ch {  // CSP: ch?item
        consume(id, item)
        log.Printf("Consumer %d: consumed %d", id, item)
    }
}

func main() {
    ch := make(chan int, 10)  // ç¼“å†²å¤§å°10
    
    // å¯åŠ¨3ä¸ªç”Ÿäº§è€…
    for i := 0; i < 3; i++ {
        go producer(ch, i)
    }
    
    // å¯åŠ¨2ä¸ªæ¶ˆè´¹è€…
    for i := 0; i < 2; i++ {
        go consumer(ch, i)
    }
    
    select {}  // æ°¸ä¹…é˜»å¡
}
```

### 1.2 Fan-Out/Fan-Inæ¨¡å¼

#### Fan-Outå½¢å¼åŒ–

```mathematical
/* Fan-Out: ä¸€ä¸ªè¾“å…¥åˆ†å‘åˆ°å¤šä¸ªå¤„ç†å™¨ */

FanOut(n) = input?x â†’ (workerâ‚!x || workerâ‚‚!x || ... || workerâ‚™!x) â†’ FanOut(n)

CSPè¡¨ç¤º:
FanOut = input?x â†’ âŸ¦i:1..nâŸ§ workeráµ¢!x â†’ FanOut

/* Goå®ç° */

function fanOut(input <-chan Task, n int) []<-chan Result {
    workers := make([]chan Result, n)
    
    for i := 0; i < n; i++ {
        workers[i] = make(chan Result)
        go worker(i, input, workers[i])
    }
    
    return workers
}

function worker(id int, input <-chan Task, output chan<- Result) {
    for task := range input {
        result := process(task)
        output <- result
    }
}
```

#### Fan-Inå½¢å¼åŒ–

```mathematical
/* Fan-In: å¤šä¸ªè¾“å…¥åˆå¹¶åˆ°ä¸€ä¸ªè¾“å‡º */

FanIn(n) = (
    workerâ‚?x â†’ output!x â†’ FanIn(n)
  | workerâ‚‚?x â†’ output!x â†’ FanIn(n)
  | ...
  | workerâ‚™?x â†’ output!x â†’ FanIn(n)
)

CSPè¡¨ç¤º:
FanIn = âŸ¦i:1..nâŸ§ (workeráµ¢?x â†’ output!x â†’ FanIn)

/* æ€§è´¨ */

1. é¡ºåºä¸ç¡®å®šæ€§:
   è¾“å‡ºé¡ºåºå–å†³äºworkerså®Œæˆé¡ºåº
   
2. æ— æ¶ˆæ¯ä¸¢å¤±:
   âˆ€ msg. sent(msg) âŸ¹ â—‡received(msg)

3. æ— é‡å¤:
   æ¯æ¡æ¶ˆæ¯åªè¾“å‡ºä¸€æ¬¡

/* Goå®ç° */

function fanIn(inputs ...<-chan Result) <-chan Result {
    output := make(chan Result)
    var wg sync.WaitGroup
    
    multiplex := func(input <-chan Result) {
        defer wg.Done()
        for result := range input {
            output <- result
        }
    }
    
    wg.Add(len(inputs))
    for _, input := range inputs {
        go multiplex(input)
    }
    
    go func() {
        wg.Wait()
        close(output)
    }()
    
    return output
}
```

#### å®Œæ•´Fan-Out/Fan-Inç³»ç»Ÿ

```mathematical
/* å®Œæ•´ç³»ç»Ÿ */

ç³»ç»Ÿ = Generator || FanOut(n) || Workers || FanIn || Consumer

Generator â†’ FanOut â†’ (Wâ‚ || Wâ‚‚ || ... || Wâ‚™) â†’ FanIn â†’ Consumer

æ€§èƒ½åˆ†æ:

å¹¶è¡Œåº¦: n (workersæ•°é‡)
ååé‡: n Ã— rate(single_worker)
å»¶è¿Ÿ: delay(generator) + delay(worker) + delay(fanin)

ä¼˜åŒ–ç­–ç•¥:
1. åŠ¨æ€è°ƒæ•´workersæ•°é‡
2. ä»»åŠ¡å·å– (work stealing)
3. ä¼˜å…ˆçº§é˜Ÿåˆ—

/* Goå®Œæ•´ç¤ºä¾‹ */

func main() {
    // Generator
    tasks := generator()
    
    // Fan-Out
    const numWorkers = 10
    workers := fanOut(tasks, numWorkers)
    
    // Fan-In
    results := fanIn(workers...)
    
    // Consumer
    for result := range results {
        process(result)
    }
}
```

### 1.3 Pipelineæ¨¡å¼

#### Pipelineå½¢å¼åŒ–

```mathematical
/* Pipeline: å¤šé˜¶æ®µä¸²è¡Œå¤„ç† */

Pipeline = Stageâ‚ â†’ Stageâ‚‚ â†’ ... â†’ Stageâ‚™

Stage_i = input?x â†’ process(x) â†’ output!result â†’ Stage_i

/* né˜¶æ®µPipeline */

P(n) = in â†’ fâ‚ â†’ fâ‚‚ â†’ ... â†’ fâ‚™ â†’ out

CSPè¡¨ç¤º:
P(n) = in?x â†’ châ‚!(fâ‚(x)) â†’ châ‚‚!(fâ‚‚(...)) â†’ ... â†’ out!(fâ‚™(...))

/* ååé‡åˆ†æ */

ç³»ç»Ÿååé‡ = min(throughput(Stage_i) for i in 1..n)

ç“¶é¢ˆé˜¶æ®µ: argmin_i(throughput(Stage_i))

/* å»¶è¿Ÿåˆ†æ */

æ€»å»¶è¿Ÿ = âˆ‘áµ¢ latency(Stage_i)

æµæ°´çº¿æ•ˆç‡:
Î· = throughput(pipeline) / max_i(throughput(Stage_i))

/* Goå®ç° */

func pipeline(input <-chan int) <-chan int {
    // Stage 1: å¹³æ–¹
    stage1 := make(chan int)
    go func() {
        defer close(stage1)
        for x := range input {
            stage1 <- x * x
        }
    }()
    
    // Stage 2: åŠ å€
    stage2 := make(chan int)
    go func() {
        defer close(stage2)
        for x := range stage1 {
            stage2 <- x * 2
        }
    }()
    
    // Stage 3: åŠ ä¸€
    output := make(chan int)
    go func() {
        defer close(output)
        for x := range stage2 {
            output <- x + 1
        }
    }()
    
    return output
}
```

#### å¹¶è¡ŒPipeline

```mathematical
/* å¹¶è¡ŒPipeline: æ¯ä¸ªé˜¶æ®µæœ‰å¤šä¸ªworker */

ParallelStage(n) = (Wâ‚ || Wâ‚‚ || ... || Wâ‚™)

ParallelPipeline = ParallelStageâ‚(nâ‚) â†’ ... â†’ ParallelStageâ‚–(nâ‚–)

ååé‡:
throughput(Stage_i) = n_i Ã— throughput(single_worker_i)

ç³»ç»Ÿååé‡:
T = min_i(n_i Ã— throughput(single_worker_i))

/* ä¼˜åŒ–é…ç½® */

ç»™å®šå„é˜¶æ®µå¤„ç†æ—¶é—´ tâ‚, tâ‚‚, ..., tâ‚–
å’Œæ€»workeré¢„ç®— N

ä¼˜åŒ–é—®é¢˜:
maximize T
subject to: nâ‚ + nâ‚‚ + ... + nâ‚– â‰¤ N

è§£: n_i âˆ t_i

/* Goå®ç° */

func parallelStage(input <-chan Task, process func(Task) Result, 
                   numWorkers int) <-chan Result {
    output := make(chan Result)
    var wg sync.WaitGroup
    
    worker := func() {
        defer wg.Done()
        for task := range input {
            result := process(task)
            output <- result
        }
    }
    
    wg.Add(numWorkers)
    for i := 0; i < numWorkers; i++ {
        go worker()
    }
    
    go func() {
        wg.Wait()
        close(output)
    }()
    
    return output
}
```

### 1.4 Worker Poolæ¨¡å¼

#### Worker Poolå½¢å¼åŒ–

```mathematical
/* Worker Poolæ¨¡å¼ */

WorkerPool(n) = (Workerâ‚ || Workerâ‚‚ || ... || Workerâ‚™) || TaskQueue

Worker_i = IDLE | BUSY(task)

IDLE = taskQueue?task â†’ BUSY(task)
BUSY(task) = process(task) â†’ resultQueue!result â†’ IDLE

/* ä»»åŠ¡è°ƒåº¦ */

Scheduler = (
    newTask?t â†’ taskQueue!t â†’ Scheduler
  | worker_i?request â†’ taskQueue?task â†’ worker_i!task â†’ Scheduler
)

/* æ€§è´¨ */

1. æœ‰ç•Œå¹¶å‘:
   æ´»è·ƒworkeræ•°é‡ â‰¤ n

2. ä»»åŠ¡å®Œæˆ:
   âˆ€ task. submitted(task) âŸ¹ â—‡completed(task)

3. å…¬å¹³è°ƒåº¦:
   å…ˆæäº¤çš„ä»»åŠ¡ä¼˜å…ˆè¢«å¤„ç† (FIFO)

/* è´Ÿè½½åˆ†æ */

åˆ©ç”¨ç‡:
U = E[busy_workers] / n

ç­‰å¾…æ—¶é—´:
W = Î» / (n Ã— Î¼ - Î»)  // M/M/né˜Ÿåˆ—æ¨¡å‹

å…¶ä¸­:
Î» = ä»»åŠ¡åˆ°è¾¾ç‡
Î¼ = å•workerå¤„ç†ç‡

/* Goå®ç° */

type WorkerPool struct {
    tasks   chan Task
    results chan Result
    workers int
    wg      sync.WaitGroup
}

func NewWorkerPool(numWorkers int) *WorkerPool {
    wp := &WorkerPool{
        tasks:   make(chan Task, 100),
        results: make(chan Result, 100),
        workers: numWorkers,
    }
    
    wp.wg.Add(numWorkers)
    for i := 0; i < numWorkers; i++ {
        go wp.worker(i)
    }
    
    return wp
}

func (wp *WorkerPool) worker(id int) {
    defer wp.wg.Done()
    
    for task := range wp.tasks {
        result := process(task)
        wp.results <- result
    }
}

func (wp *WorkerPool) Submit(task Task) {
    wp.tasks <- task
}

func (wp *WorkerPool) Close() {
    close(wp.tasks)
    wp.wg.Wait()
    close(wp.results)
}
```

#### åŠ¨æ€Worker Pool

```mathematical
/* åŠ¨æ€è°ƒæ•´workeræ•°é‡ */

DynamicPool = (Workers, Monitor, Controller)

Monitor = 
    measure() â†’ 
    if load > high_threshold:
        addWorker()
    elif load < low_threshold:
        removeWorker()
    â†’ Monitor

/* è‡ªé€‚åº”ç®—æ³• */

function adaptWorkers(currentLoad: float, numWorkers: int) -> int:
    targetLoad = 0.75  // 75%åˆ©ç”¨ç‡
    
    if currentLoad > 0.9:
        return min(numWorkers + 1, maxWorkers)
    elif currentLoad < 0.5 and numWorkers > minWorkers:
        return numWorkers - 1
    else:
        return numWorkers

/* å®ç° */

type DynamicWorkerPool struct {
    *WorkerPool
    monitor  *LoadMonitor
    minWorkers int
    maxWorkers int
}

func (dwp *DynamicWorkerPool) adjustWorkers() {
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        load := dwp.monitor.Load()
        targetWorkers := adaptWorkers(load, dwp.workers)
        
        if targetWorkers > dwp.workers {
            dwp.addWorker()
        } else if targetWorkers < dwp.workers {
            dwp.removeWorker()
        }
    }
}
```

---

## ç¬¬äºŒéƒ¨åˆ†: åŒæ­¥æ¨¡å¼

### 2.1 BarrieråŒæ­¥

#### Barrierå½¢å¼åŒ–

```mathematical
/* Barrier: nä¸ªgoroutineåœ¨å±éšœå¤„ç­‰å¾… */

Barrier(n) = 
    (arriveâ‚() || arriveâ‚‚() || ... || arriveâ‚™()) â†’
    (continueâ‚() || continueâ‚‚() || ... || continueâ‚™())

/* CSPè¡¨ç¤º */

Process_i = 
    work_before() â†’
    barrier.arrive() â†’
    barrier.wait() â†’
    work_after()

Barrier(n, count) = 
    if count < n:
        arrive?_ â†’ Barrier(n, count+1)
    else:
        (continue!_ || continue!_ || ... || continue!_) â†’ Barrier(n, 0)

/* æ€§è´¨è¯æ˜ */

å®šç† (Barrier Safety):
æ‰€æœ‰è¿›ç¨‹åˆ°è¾¾barrieråæ‰ç»§ç»­æ‰§è¡Œ

è¯æ˜:
count < næ—¶,barrierä¿æŒwaitçŠ¶æ€
count = næ—¶,æ‰å‘é€continueä¿¡å·
å› æ­¤æ‰€æœ‰nä¸ªè¿›ç¨‹éƒ½åˆ°è¾¾åæ‰ç»§ç»­ âœ“

å®šç† (Barrier Liveness):
å¦‚æœæ‰€æœ‰è¿›ç¨‹æœ€ç»ˆåˆ°è¾¾barrier,
åˆ™æ‰€æœ‰è¿›ç¨‹æœ€ç»ˆç»§ç»­æ‰§è¡Œ

è¯æ˜:
å‡è®¾æ‰€æœ‰è¿›ç¨‹åˆ°è¾¾ âŸ¹ count = n
count = n âŸ¹ å‘é€nä¸ªcontinueä¿¡å·
æ¯ä¸ªè¿›ç¨‹æ”¶åˆ°continue âŸ¹ ç»§ç»­æ‰§è¡Œ âœ“

/* Goå®ç° */

type Barrier struct {
    n       int
    count   int
    mutex   sync.Mutex
    cond    *sync.Cond
    generation int
}

func NewBarrier(n int) *Barrier {
    b := &Barrier{n: n}
    b.cond = sync.NewCond(&b.mutex)
    return b
}

func (b *Barrier) Wait() {
    b.mutex.Lock()
    defer b.mutex.Unlock()
    
    generation := b.generation
    b.count++
    
    if b.count == b.n {
        // æœ€åä¸€ä¸ªåˆ°è¾¾,å”¤é†’æ‰€æœ‰
        b.count = 0
        b.generation++
        b.cond.Broadcast()
    } else {
        // ç­‰å¾…å…¶ä»–goroutine
        for generation == b.generation {
            b.cond.Wait()
        }
    }
}
```

### 2.2 Future/Promiseæ¨¡å¼

#### Futureå½¢å¼åŒ–

```mathematical
/* Future: å¼‚æ­¥è®¡ç®—çš„ç»“æœ */

Future<T> = Pending | Ready(T)

compute() â†’ future
future.get() â†’ é˜»å¡ç›´åˆ°Ready(result)

/* çŠ¶æ€è½¬æ¢ */

FutureçŠ¶æ€æœº:
  Pending --computeå®Œæˆ--> Ready(result)
  Ready(result) --get--> return result

/* CSPè¡¨ç¤º */

Future = 
    compute() â†’ resultChan!(result) â†’ Ready
    
Caller = 
    future = asyncCall(f) â†’
    do_other_work() â†’
    result = future.get() â†’
    use(result)

/* ç»„åˆå­ */

1. map: Future<A> â†’ (A â†’ B) â†’ Future<B>
   future.map(f) = futureä¸­çš„å€¼åº”ç”¨f

2. flatMap: Future<A> â†’ (A â†’ Future<B>) â†’ Future<B>
   future.flatMap(f) = futureå®Œæˆå,æ‰§è¡Œfè¿”å›æ–°future

3. zip: Future<A> Ã— Future<B> â†’ Future<(A, B)>
   zip(f1, f2) = ç­‰å¾…ä¸¤ä¸ªfutureéƒ½å®Œæˆ

/* Goå®ç° */

type Future struct {
    result chan interface{}
    err    chan error
}

func Async(f func() (interface{}, error)) *Future {
    future := &Future{
        result: make(chan interface{}, 1),
        err:    make(chan error, 1),
    }
    
    go func() {
        result, err := f()
        if err != nil {
            future.err <- err
        } else {
            future.result <- result
        }
    }()
    
    return future
}

func (f *Future) Get() (interface{}, error) {
    select {
    case result := <-f.result:
        return result, nil
    case err := <-f.err:
        return nil, err
    }
}

func (f *Future) Map(fn func(interface{}) interface{}) *Future {
    return Async(func() (interface{}, error) {
        result, err := f.Get()
        if err != nil {
            return nil, err
        }
        return fn(result), nil
    })
}

func Zip(futures ...*Future) *Future {
    return Async(func() (interface{}, error) {
        results := make([]interface{}, len(futures))
        for i, f := range futures {
            result, err := f.Get()
            if err != nil {
                return nil, err
            }
            results[i] = result
        }
        return results, nil
    })
}
```

### 2.3 ä¿¡å·é‡æ¨¡å¼

#### ä¿¡å·é‡å½¢å¼åŒ–

```mathematical
/* ä¿¡å·é‡: æ§åˆ¶èµ„æºè®¿é—® */

Semaphore(n) = permits: int = n

P() = (permits > 0) â†’ permits-- â†’ continue
V() = permits++ â†’ wakeup_waiter()

/* CSPè¡¨ç¤º */

Semaphore(n) = SEM(n)

SEM(k) = 
    if k > 0:
        acquire?_ â†’ SEM(k-1)
      | release?_ â†’ SEM(k+1)
    else:
        release?_ â†’ SEM(1)

/* æ€§è´¨ */

ä¸å˜å¼: 0 â‰¤ permits â‰¤ initial_permits

äº’æ–¥æ€§: åŒæ—¶è®¿é—®èµ„æºçš„æ•°é‡ â‰¤ n

/* Goå®ç° */

type Semaphore struct {
    permits chan struct{}
}

func NewSemaphore(n int) *Semaphore {
    sem := &Semaphore{
        permits: make(chan struct{}, n),
    }
    for i := 0; i < n; i++ {
        sem.permits <- struct{}{}
    }
    return sem
}

func (s *Semaphore) Acquire() {
    <-s.permits  // è·å–permit
}

func (s *Semaphore) Release() {
    s.permits <- struct{}{}  // å½’è¿˜permit
}

func (s *Semaphore) TryAcquire() bool {
    select {
    case <-s.permits:
        return true
    default:
        return false
    }
}

/* ä½¿ç”¨ç¤ºä¾‹: é™åˆ¶å¹¶å‘æ•° */

func limitedConcurrency() {
    sem := NewSemaphore(10)  // æœ€å¤š10ä¸ªå¹¶å‘
    
    for _, task := range tasks {
        go func(t Task) {
            sem.Acquire()
            defer sem.Release()
            
            process(t)
        }(task)
    }
}
```

### 2.4 ç­‰å¾…ç»„æ¨¡å¼

#### WaitGroupå½¢å¼åŒ–

```mathematical
/* WaitGroup: ç­‰å¾…ä¸€ç»„goroutineå®Œæˆ */

WaitGroup = counter: int, waiters: Set[Goroutine]

Add(delta) = counter += delta
Done() = counter-- ; if counter == 0: wakeup_all_waiters()
Wait() = if counter > 0: block() else: return

/* çŠ¶æ€è½¬æ¢ */

State = (counter, waiters)

Add(n): (c, W) â†’ (c+n, W)
Done(): (c, W) â†’ (c-1, W) if c > 1
        (1, W) â†’ (0, âˆ…) and wakeup(W)
Wait(): (0, W) â†’ (0, W) immediately
        (c, W) â†’ (c, Wâˆª{current}) and block if c > 0

/* æ­£ç¡®æ€§æ€§è´¨ */

å®‰å…¨æ€§: Wait()è¿”å›æ—¶,æ‰€æœ‰Add()çš„goroutineéƒ½å·²Done()

æ´»è·ƒæ€§: å¦‚æœæ‰€æœ‰goroutineæœ€ç»ˆDone(),åˆ™Wait()æœ€ç»ˆè¿”å›

/* å½¢å¼åŒ–éªŒè¯ */

ä¸å˜å¼:
1. counter â‰¥ 0
2. counter = 0 âŸ¹ waiters = âˆ…
3. counter > 0 âŸ¹ âˆƒ goroutine will call Done()

å®šç† (WaitGroup Correctness):
Wait()è¿”å› âŸº âˆ€g âˆˆ added_goroutines. g called Done()

è¯æ˜:
Wait()è¿”å› âŸº counter = 0
counter = 0 âŸº æ‰€æœ‰Add()å¯¹åº”çš„Done()éƒ½å·²è°ƒç”¨
å› æ­¤Wait()è¿”å›å½“ä¸”ä»…å½“æ‰€æœ‰goroutineå®Œæˆ âœ“

/* Goå†…ç½®å®ç° */

var wg sync.WaitGroup

for _, task := range tasks {
    wg.Add(1)
    go func(t Task) {
        defer wg.Done()
        process(t)
    }(task)
}

wg.Wait()  // ç­‰å¾…æ‰€æœ‰goroutineå®Œæˆ
```

---

## ç¬¬ä¸‰éƒ¨åˆ†: æ§åˆ¶æµæ¨¡å¼

### 3.1 è¶…æ—¶ä¸å–æ¶ˆ

#### Contextè¶…æ—¶å½¢å¼åŒ–

```mathematical
/* Context with Timeout */

Context = (deadline: Time, done: <-chan struct{}, err: error)

WithTimeout(parent, timeout) = 
    ctx = new Context
    ctx.deadline = now() + timeout
    ctx.done = make(chan struct{})
    
    go func():
        select:
            case <-time.After(timeout):
                ctx.err = DeadlineExceeded
                close(ctx.done)
            case <-parent.Done():
                ctx.err = parent.Err()
                close(ctx.done)
    
    return ctx

/* CSPè¡¨ç¤º */

TimeoutProcess(timeout) = 
    (work() â†’ success())
  | (wait(timeout) â†’ cancel())

/* è¶…æ—¶è¯­ä¹‰ */

âŸ¦work with timeout TâŸ§ = 
    if work_completes_before(T):
        return result
    else:
        return TimeoutError

/* Goå®ç° */

func workWithTimeout(timeout time.Duration) error {
    ctx, cancel := context.WithTimeout(context.Background(), timeout)
    defer cancel()
    
    done := make(chan error, 1)
    
    go func() {
        done <- doWork()
    }()
    
    select {
    case err := <-done:
        return err
    case <-ctx.Done():
        return ctx.Err()
    }
}
```

#### å–æ¶ˆä¼ æ’­

```mathematical
/* å–æ¶ˆä¼ æ’­ (Cancellation Propagation) */

Contextæ ‘:
  root
   â”œâ”€â”€ child1
   â”‚    â”œâ”€â”€ grandchild1
   â”‚    â””â”€â”€ grandchild2
   â””â”€â”€ child2

å–æ¶ˆè§„åˆ™:
cancel(node) âŸ¹ âˆ€ descendant. cancel(descendant)

/* å½¢å¼åŒ– */

CancelTree = (nodes, edges, canceled: Set[Node])

cancel(n) = 
    canceled.add(n)
    for child in children(n):
        cancel(child)

/* æ€§è´¨ */

ä¸å˜å¼:
âˆ€n. n âˆˆ canceled âŸ¹ parent(n) âˆˆ canceled âˆ¨ n = root

å®šç† (Cancellation Propagates):
cancel(n) âŸ¹ âˆ€ descendant d of n. â—‡(d âˆˆ canceled)

è¯æ˜:
ç”±é€’å½’å®šä¹‰,cancel(n)ä¼šè°ƒç”¨childrençš„cancel
å› æ­¤æ‰€æœ‰åä»£èŠ‚ç‚¹æœ€ç»ˆè¢«å–æ¶ˆ âœ“

/* Goå®ç° */

func worker(ctx context.Context) error {
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()  // æ”¶åˆ°å–æ¶ˆä¿¡å·
        default:
            // ç»§ç»­å·¥ä½œ
            if err := doUnit(); err != nil {
                return err
            }
        }
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    
    go worker(ctx)
    go worker(ctx)
    go worker(ctx)
    
    time.Sleep(5 * time.Second)
    cancel()  // å–æ¶ˆæ‰€æœ‰workers
}
```

### 3.2 é‡è¯•ä¸é€€é¿

#### é‡è¯•ç­–ç•¥å½¢å¼åŒ–

```mathematical
/* æŒ‡æ•°é€€é¿ (Exponential Backoff) */

Retry(f, maxAttempts, baseDelay) = 
    attempt = 0
    while attempt < maxAttempts:
        try:
            return f()
        catch error:
            attempt++
            if attempt < maxAttempts:
                delay = baseDelay * 2^attempt
                sleep(delay)
    return FinalError

/* é€€é¿å‡½æ•° */

backoff(attempt) = min(baseDelay Ã— 2^attempt, maxDelay)

å¸¦æŠ–åŠ¨:
backoff_jitter(attempt) = backoff(attempt) Ã— (1 + random(-0.2, 0.2))

/* æˆåŠŸç‡åˆ†æ */

è®¾å•æ¬¡æˆåŠŸç‡ä¸º p

næ¬¡é‡è¯•åæˆåŠŸæ¦‚ç‡:
P(success) = 1 - (1 - p)^n

ç¤ºä¾‹:
p = 0.5, n = 3:
P(success) = 1 - 0.5^3 = 0.875 (87.5%)

/* Goå®ç° */

type RetryPolicy struct {
    MaxAttempts int
    BaseDelay   time.Duration
    MaxDelay    time.Duration
}

func (rp *RetryPolicy) Execute(f func() error) error {
    var err error
    
    for attempt := 0; attempt < rp.MaxAttempts; attempt++ {
        err = f()
        
        if err == nil {
            return nil  // æˆåŠŸ
        }
        
        if attempt < rp.MaxAttempts-1 {
            delay := rp.backoff(attempt)
            time.Sleep(delay)
        }
    }
    
    return fmt.Errorf("max retries exceeded: %w", err)
}

func (rp *RetryPolicy) backoff(attempt int) time.Duration {
    delay := rp.BaseDelay * (1 << attempt)  // 2^attempt
    if delay > rp.MaxDelay {
        delay = rp.MaxDelay
    }
    
    // æ·»åŠ æŠ–åŠ¨
    jitter := time.Duration(rand.Float64() * 0.2 * float64(delay))
    return delay + jitter
}
```

### 3.3 ç†”æ–­å™¨æ¨¡å¼

#### ç†”æ–­å™¨å½¢å¼åŒ–

```mathematical
/* Circuit BreakerçŠ¶æ€æœº */

State ::= Closed | Open | HalfOpen

çŠ¶æ€è½¬æ¢:
Closed --failures > threshold--> Open
Open --timeout elapsed--> HalfOpen
HalfOpen --success--> Closed
HalfOpen --failure--> Open

/* å½¢å¼åŒ–å®šä¹‰ */

CircuitBreaker = (state, failures, successes, threshold, timeout)

åˆå§‹: state = Closed, failures = 0

transition:
  Closed:
    on_success: failures = 0
    on_failure: failures++
                if failures > threshold:
                    state = Open
                    start_timer(timeout)
  
  Open:
    on_call: return CircuitOpenError
    on_timeout: state = HalfOpen
                failures = 0
                successes = 0
  
  HalfOpen:
    on_success: successes++
                if successes >= required_successes:
                    state = Closed
    on_failure: state = Open
                start_timer(timeout)

/* æ€§è´¨ */

å®‰å…¨æ€§: OpençŠ¶æ€ä¸ä¼šè°ƒç”¨åº•å±‚æœåŠ¡
      (ä¿æŠ¤æœåŠ¡é¿å…è¿‡è½½)

æ´»è·ƒæ€§: HalfOpençŠ¶æ€ä¼šå°è¯•æ¢å¤
      (ç³»ç»Ÿå¯ä»¥è‡ªåŠ¨æ¢å¤)

/* Goå®ç° */

type CircuitBreaker struct {
    state          State
    failures       int
    successes      int
    threshold      int
    timeout        time.Duration
    lastFailTime   time.Time
    mu             sync.Mutex
}

func (cb *CircuitBreaker) Call(f func() error) error {
    cb.mu.Lock()
    
    switch cb.state {
    case Open:
        if time.Since(cb.lastFailTime) > cb.timeout {
            cb.state = HalfOpen
            cb.successes = 0
            cb.failures = 0
        } else {
            cb.mu.Unlock()
            return ErrCircuitOpen
        }
    }
    
    cb.mu.Unlock()
    
    err := f()
    
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    if err != nil {
        cb.onFailure()
    } else {
        cb.onSuccess()
    }
    
    return err
}

func (cb *CircuitBreaker) onSuccess() {
    cb.failures = 0
    
    if cb.state == HalfOpen {
        cb.successes++
        if cb.successes >= requiredSuccesses {
            cb.state = Closed
        }
    }
}

func (cb *CircuitBreaker) onFailure() {
    cb.failures++
    cb.lastFailTime = time.Now()
    
    if cb.state == HalfOpen || cb.failures > cb.threshold {
        cb.state = Open
    }
}
```

### 3.4 é™æµæ¨¡å¼

#### ä»¤ç‰Œæ¡¶ç®—æ³•

```mathematical
/* Token Bucket Algorithm */

TokenBucket = (capacity, tokens, rate, lastRefill)

åˆå§‹: tokens = capacity

refill():
    now = currentTime()
    elapsed = now - lastRefill
    newTokens = rate Ã— elapsed
    tokens = min(tokens + newTokens, capacity)
    lastRefill = now

allow() -> bool:
    refill()
    if tokens >= 1:
        tokens--
        return true
    else:
        return false

/* é€Ÿç‡åˆ†æ */

å¹³å‡é€Ÿç‡: rate (tokens/second)
çªå‘å®¹é‡: capacity (tokens)

é•¿æœŸå¹³å‡é€Ÿç‡:
lim_{tâ†’âˆ} allowed_requests / t = rate

çŸ­æœŸçªå‘:
å¯ä»¥å…è®¸capacityä¸ªè¿ç»­è¯·æ±‚

/* Goå®ç° */

type TokenBucket struct {
    capacity   float64
    tokens     float64
    rate       float64
    lastRefill time.Time
    mu         sync.Mutex
}

func NewTokenBucket(capacity, rate float64) *TokenBucket {
    return &TokenBucket{
        capacity:   capacity,
        tokens:     capacity,
        rate:       rate,
        lastRefill: time.Now(),
    }
}

func (tb *TokenBucket) Allow() bool {
    tb.mu.Lock()
    defer tb.mu.Unlock()
    
    tb.refill()
    
    if tb.tokens >= 1 {
        tb.tokens--
        return true
    }
    
    return false
}

func (tb *TokenBucket) refill() {
    now := time.Now()
    elapsed := now.Sub(tb.lastRefill).Seconds()
    newTokens := tb.rate * elapsed
    
    tb.tokens = math.Min(tb.tokens+newTokens, tb.capacity)
    tb.lastRefill = now
}

func (tb *TokenBucket) Wait() {
    for !tb.Allow() {
        time.Sleep(time.Millisecond)
    }
}
```

---

## ç¬¬å››éƒ¨åˆ†: æ•°æ®æµæ¨¡å¼

### 4.1 æµå¼å¤„ç†

#### æµå¤„ç†å½¢å¼åŒ–

```mathematical
/* æµå¤„ç† (Stream Processing) */

Stream<T> = Channel<T> with operators

Operators:
- Map: Stream<A> â†’ (A â†’ B) â†’ Stream<B>
- Filter: Stream<A> â†’ (A â†’ bool) â†’ Stream<A>
- FlatMap: Stream<A> â†’ (A â†’ Stream<B>) â†’ Stream<B>
- Reduce: Stream<A> â†’ (A Ã— A â†’ A) â†’ A

/* æµä»£æ•° */

Streamæ˜¯Monad:
1. return: a â†’ Stream<a>
2. bind: Stream<a> â†’ (a â†’ Stream<b>) â†’ Stream<b>

æ»¡è¶³Monadå¾‹:
- å·¦å•ä½: return(a).bind(f) â‰¡ f(a)
- å³å•ä½: m.bind(return) â‰¡ m
- ç»“åˆå¾‹: m.bind(f).bind(g) â‰¡ m.bind(Î»x. f(x).bind(g))

/* Goå®ç° */

type Stream struct {
    source <-chan interface{}
}

func FromChannel(ch <-chan interface{}) *Stream {
    return &Stream{source: ch}
}

func (s *Stream) Map(f func(interface{}) interface{}) *Stream {
    out := make(chan interface{})
    
    go func() {
        defer close(out)
        for item := range s.source {
            out <- f(item)
        }
    }()
    
    return &Stream{source: out}
}

func (s *Stream) Filter(predicate func(interface{}) bool) *Stream {
    out := make(chan interface{})
    
    go func() {
        defer close(out)
        for item := range s.source {
            if predicate(item) {
                out <- item
            }
        }
    }()
    
    return &Stream{source: out}
}

func (s *Stream) Reduce(initial interface{}, 
                        reducer func(interface{}, interface{}) interface{}) interface{} {
    acc := initial
    for item := range s.source {
        acc = reducer(acc, item)
    }
    return acc
}

// ä½¿ç”¨ç¤ºä¾‹
func example() {
    input := make(chan interface{})
    
    go func() {
        for i := 0; i < 100; i++ {
            input <- i
        }
        close(input)
    }()
    
    result := FromChannel(input).
        Filter(func(x interface{}) bool {
            return x.(int)%2 == 0  // å¶æ•°
        }).
        Map(func(x interface{}) interface{} {
            return x.(int) * 2  // ä¹˜2
        }).
        Reduce(0, func(acc, x interface{}) interface{} {
            return acc.(int) + x.(int)  // æ±‚å’Œ
        })
    
    fmt.Println(result)  // æ‰€æœ‰å¶æ•°çš„ä¸¤å€ä¹‹å’Œ
}
```

### 4.2 èƒŒå‹æ§åˆ¶

#### èƒŒå‹å½¢å¼åŒ–

```mathematical
/* èƒŒå‹ (Backpressure) */

é—®é¢˜: ç”Ÿäº§è€…é€Ÿåº¦ > æ¶ˆè´¹è€…é€Ÿåº¦ âŸ¹ å†…å­˜æº¢å‡º

è§£å†³æ–¹æ¡ˆ:
1. é˜»å¡ç”Ÿäº§è€…
2. ä¸¢å¼ƒæ¶ˆæ¯
3. ç¼“å†²+èƒŒå‹ä¿¡å·

/* èƒŒå‹æœºåˆ¶ */

BackpressureChannel = (buffer, capacity, pressure_signal)

send(item):
    if len(buffer) < capacity:
        buffer.append(item)
    else:
        pressure_signal!high
        block_until_space()

receive() -> item:
    item = buffer.pop()
    if len(buffer) < capacity Ã— threshold:
        pressure_signal!low
    return item

/* è‡ªé€‚åº”é€Ÿç‡ */

Produceré€‚åº”:
rate_adjustment = 
    if pressure == high:
        rate *= 0.9  // é™ä½é€Ÿç‡
    elif pressure == low:
        rate *= 1.1  // æé«˜é€Ÿç‡

/* Goå®ç° */

type BackpressureChannel struct {
    data     chan interface{}
    pressure chan PressureSignal
    capacity int
}

type PressureSignal int

const (
    PressureLow PressureSignal = iota
    PressureHigh
)

func NewBackpressureChannel(capacity int) *BackpressureChannel {
    return &BackpressureChannel{
        data:     make(chan interface{}, capacity),
        pressure: make(chan PressureSignal, 1),
        capacity: capacity,
    }
}

func (bpc *BackpressureChannel) Send(item interface{}) {
    bpc.data <- item
    
    // å‘é€å‹åŠ›ä¿¡å·
    if len(bpc.data) > bpc.capacity*8/10 {
        select {
        case bpc.pressure <- PressureHigh:
        default:
        }
    }
}

func (bpc *BackpressureChannel) Receive() interface{} {
    item := <-bpc.data
    
    // å‘é€ä½å‹ä¿¡å·
    if len(bpc.data) < bpc.capacity*2/10 {
        select {
        case bpc.pressure <- PressureLow:
        default:
        }
    }
    
    return item
}

func (bpc *BackpressureChannel) Pressure() <-chan PressureSignal {
    return bpc.pressure
}

// ç”Ÿäº§è€…ç›‘å¬å‹åŠ›
func adaptiveProducer(bpc *BackpressureChannel) {
    rate := time.Second
    
    go func() {
        for signal := range bpc.Pressure() {
            switch signal {
            case PressureHigh:
                rate = rate * 11 / 10  // å‡é€Ÿ
            case PressureLow:
                rate = rate * 9 / 10   // åŠ é€Ÿ
            }
        }
    }()
    
    ticker := time.NewTicker(rate)
    defer ticker.Stop()
    
    for range ticker.C {
        item := produce()
        bpc.Send(item)
    }
}
```

### 4.3 æ‰¹å¤„ç†æ¨¡å¼

#### æ‰¹å¤„ç†å½¢å¼åŒ–

```mathematical
/* æ‰¹å¤„ç† (Batching) */

Batcher = collect items until:
  1. batch_size reached, or
  2. timeout elapsed

then: process batch

/* å½¢å¼åŒ– */

Batcher(size, timeout) = 
    batch = []
    timer = startTimer(timeout)
    
    loop:
        select:
            case item = <-input:
                batch.append(item)
                if len(batch) >= size:
                    process(batch)
                    batch = []
                    timer.reset()
            
            case <-timer:
                if len(batch) > 0:
                    process(batch)
                    batch = []
                timer.reset()

/* æ€§èƒ½åˆ†æ */

å»¶è¿Ÿ:
- æœ€å°: 0 (æ‰¹æ¬¡ç«‹å³æ»¡)
- æœ€å¤§: timeout
- å¹³å‡: timeout/2 (å‡è®¾å‡åŒ€åˆ°è¾¾)

ååé‡:
- æ‰¹å¤„ç†: batch_size / batch_time
- é€ä¸ªå¤„ç†: 1 / item_time

æ‰¹å¤„ç†ä¼˜åŠ¿æ¡ä»¶:
batch_time < batch_size Ã— item_time

/* Goå®ç° */

type Batcher struct {
    batchSize int
    timeout   time.Duration
    input     chan interface{}
    output    chan []interface{}
}

func NewBatcher(batchSize int, timeout time.Duration) *Batcher {
    b := &Batcher{
        batchSize: batchSize,
        timeout:   timeout,
        input:     make(chan interface{}),
        output:    make(chan []interface{}),
    }
    
    go b.run()
    return b
}

func (b *Batcher) Add(item interface{}) {
    b.input <- item
}

func (b *Batcher) Batches() <-chan []interface{} {
    return b.output
}

func (b *Batcher) run() {
    batch := make([]interface{}, 0, b.batchSize)
    timer := time.NewTimer(b.timeout)
    defer timer.Stop()
    
    for {
        select {
        case item := <-b.input:
            batch = append(batch, item)
            
            if len(batch) >= b.batchSize {
                b.output <- batch
                batch = make([]interface{}, 0, b.batchSize)
                timer.Reset(b.timeout)
            }
        
        case <-timer.C:
            if len(batch) > 0 {
                b.output <- batch
                batch = make([]interface{}, 0, b.batchSize)
            }
            timer.Reset(b.timeout)
        }
    }
}
```

### 4.4 çª—å£èšåˆ

#### æ»‘åŠ¨çª—å£å½¢å¼åŒ–

```mathematical
/* æ»‘åŠ¨çª—å£ (Sliding Window) */

Window = [t - window_size, t]

æ»‘åŠ¨çª—å£èšåˆ:
aggregate(stream, window_size, slide_interval)

çª—å£ç±»å‹:
1. æ—¶é—´çª—å£: æŒ‰æ—¶é—´åˆ’åˆ†
2. è®¡æ•°çª—å£: æŒ‰å…ƒç´ æ•°é‡åˆ’åˆ†

/* Tumbling Window (ç¿»æ»šçª—å£) */

Window_i = [i Ã— window_size, (i+1) Ã— window_size)

æ— é‡å ,æ¯ä¸ªå…ƒç´ å±äºå”¯ä¸€çª—å£

/* Sliding Window (æ»‘åŠ¨çª—å£) */

Window_t = [t - window_size, t]

çª—å£é‡å ,å…ƒç´ å¯èƒ½å±äºå¤šä¸ªçª—å£

/* Hopping Window (è·³è·ƒçª—å£) */

Window_i = [i Ã— hop_size, i Ã— hop_size + window_size)

hop_size < window_size: çª—å£é‡å 
hop_size = window_size: ç¿»æ»šçª—å£
hop_size > window_size: çª—å£æœ‰é—´éš™

/* Goå®ç° */

type WindowAggregator struct {
    windowSize time.Duration
    slideInterval time.Duration
    aggregateFn func([]interface{}) interface{}
    input chan TimestampedItem
    output chan interface{}
}

type TimestampedItem struct {
    Timestamp time.Time
    Value     interface{}
}

func NewWindowAggregator(
    windowSize, slideInterval time.Duration,
    aggregateFn func([]interface{}) interface{},
) *WindowAggregator {
    wa := &WindowAggregator{
        windowSize:    windowSize,
        slideInterval: slideInterval,
        aggregateFn:   aggregateFn,
        input:         make(chan TimestampedItem),
        output:        make(chan interface{}),
    }
    
    go wa.run()
    return wa
}

func (wa *WindowAggregator) Add(item TimestampedItem) {
    wa.input <- item
}

func (wa *WindowAggregator) Output() <-chan interface{} {
    return wa.output
}

func (wa *WindowAggregator) run() {
    buffer := []TimestampedItem{}
    ticker := time.NewTicker(wa.slideInterval)
    defer ticker.Stop()
    
    for {
        select {
        case item := <-wa.input:
            buffer = append(buffer, item)
        
        case now := <-ticker.C:
            // ç§»é™¤è¿‡æœŸé¡¹
            cutoff := now.Add(-wa.windowSize)
            validItems := []interface{}{}
            
            newBuffer := buffer[:0]
            for _, item := range buffer {
                if item.Timestamp.After(cutoff) {
                    newBuffer = append(newBuffer, item)
                    validItems = append(validItems, item.Value)
                }
            }
            buffer = newBuffer
            
            // èšåˆå¹¶è¾“å‡º
            if len(validItems) > 0 {
                result := wa.aggregateFn(validItems)
                wa.output <- result
            }
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹: 1åˆ†é’Ÿçª—å£,æ¯10ç§’è®¡ç®—å¹³å‡å€¼
func example() {
    aggregator := NewWindowAggregator(
        time.Minute,
        10*time.Second,
        func(items []interface{}) interface{} {
            sum := 0.0
            for _, item := range items {
                sum += item.(float64)
            }
            return sum / float64(len(items))
        },
    )
    
    go func() {
        for avg := range aggregator.Output() {
            fmt.Printf("Average: %.2f\n", avg)
        }
    }()
    
    // å‘é€æ•°æ®
    for {
        value := readSensor()
        aggregator.Add(TimestampedItem{
            Timestamp: time.Now(),
            Value:     value,
        })
        time.Sleep(time.Second)
    }
}
```

---

## ç¬¬äº”éƒ¨åˆ†: Actoræ¨¡å¼

### 5.1 Actoræ¨¡å‹å½¢å¼åŒ–

```mathematical
/* Actoræ¨¡å‹ */

Actor = (mailbox, behavior, state)

Actorè¡Œä¸º:
1. æ¥æ”¶æ¶ˆæ¯
2. æ”¹å˜çŠ¶æ€
3. å‘é€æ¶ˆæ¯ç»™å…¶ä»–Actor
4. åˆ›å»ºæ–°Actor

/* å½¢å¼åŒ–å®šä¹‰ */

Actor Î± = âŸ¨S_Î±, M_Î±, Î²_Î±âŸ©

å…¶ä¸­:
- S_Î±: ActorçŠ¶æ€ç©ºé—´
- M_Î±: æ¶ˆæ¯ç±»å‹é›†åˆ
- Î²_Î±: S_Î± Ã— M_Î± â†’ (S_Î±, Actions)

Actions ::= Send(actor, message)
          | Create(ActorDef)
          | Îµ

/* Actoré…ç½® */

Configuration = âŸ¨Actors, MessagesâŸ©

Actors = {Î±â‚, Î±â‚‚, ..., Î±â‚™}
Messages = {(from, to, msg) | ...}

/* è½¬æ¢è§„åˆ™ */

[Actor-Receive]
(Î±, s) âˆˆ Actors
(_, Î±, m) âˆˆ Messages
Î²_Î±(s, m) = (s', actions)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Actors â†’ Actors[Î± â†¦ (Î±, s')]
Messages â†’ Messages - {(_, Î±, m)} âˆª new_messages(actions)

/* æ€§è´¨ */

æ¶ˆæ¯ä¼ é€’:
- å¼‚æ­¥: å‘é€ä¸é˜»å¡
- é¡ºåº: åŒä¸€å‘é€è€…çš„æ¶ˆæ¯æŒ‰åºåˆ°è¾¾
- æœ€å¤šä¸€æ¬¡: æ¶ˆæ¯ä¸é‡å¤

ä½ç½®é€æ˜:
Actorå¼•ç”¨ä¸ç‰©ç†ä½ç½®æ— å…³

/* CSP vs Actor */

CSP:
- åŒæ­¥é€šä¿¡ (é»˜è®¤)
- Channelä½œä¸ºä¸€ç­‰å…¬æ°‘
- è¿›ç¨‹é™æ€

Actor:
- å¼‚æ­¥é€šä¿¡
- Actorä½œä¸ºä¸€ç­‰å…¬æ°‘
- ActoråŠ¨æ€åˆ›å»º
```

### 5.2 Goroutineä½œä¸ºActor

#### Goroutine-Actoræ˜ å°„

```mathematical
/* Goroutineå®ç°Actor */

Goroutine + Channel â‰ˆ Actor

Actor = goroutine + mailbox(channel)

å®ç°æ˜ å°„:
- Actor state â†’ goroutine local variables
- Actor mailbox â†’ buffered channel
- Actor behavior â†’ goroutine event loop
- Send message â†’ ch <- msg
- Create actor â†’ go newActor()

/* Goå®ç° */

type Actor interface {
    Start()
    Send(msg interface{})
    Stop()
}

type BaseActor struct {
    mailbox chan interface{}
    done    chan struct{}
    handler func(interface{})
}

func NewActor(bufferSize int, handler func(interface{})) *BaseActor {
    return &BaseActor{
        mailbox: make(chan interface{}, bufferSize),
        done:    make(chan struct{}),
        handler: handler,
    }
}

func (a *BaseActor) Start() {
    go a.run()
}

func (a *BaseActor) Send(msg interface{}) {
    a.mailbox <- msg
}

func (a *BaseActor) Stop() {
    close(a.done)
}

func (a *BaseActor) run() {
    for {
        select {
        case msg := <-a.mailbox:
            a.handler(msg)
        case <-a.done:
            return
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹: Counter Actor
type CounterMsg struct {
    Action string  // "inc", "dec", "get"
    Reply  chan int
}

func CounterActor() *BaseActor {
    count := 0
    
    return NewActor(10, func(msg interface{}) {
        cm := msg.(CounterMsg)
        
        switch cm.Action {
        case "inc":
            count++
        case "dec":
            count--
        case "get":
            cm.Reply <- count
        }
    })
}

func main() {
    counter := CounterActor()
    counter.Start()
    
    // å‘é€æ¶ˆæ¯
    counter.Send(CounterMsg{Action: "inc"})
    counter.Send(CounterMsg{Action: "inc"})
    
    // è·å–å€¼
    reply := make(chan int)
    counter.Send(CounterMsg{Action: "get", Reply: reply})
    fmt.Println("Count:", <-reply)  // è¾“å‡º: 2
}
```

### 5.3 ç›‘ç£æ ‘æ¨¡å¼

#### ç›‘ç£è€…å½¢å¼åŒ–

```mathematical
/* ç›‘ç£æ ‘ (Supervisor Tree) */

Supervisor = (children, strategy, maxRestarts, timeWindow)

Strategy ::= 
    | OneForOne    // åªé‡å¯å¤±è´¥çš„å­èŠ‚ç‚¹
    | OneForAll    // é‡å¯æ‰€æœ‰å­èŠ‚ç‚¹
    | RestForOne   // é‡å¯å¤±è´¥èŠ‚ç‚¹åŠå…¶åçš„èŠ‚ç‚¹

/* é‡å¯ç­–ç•¥ */

OneForOne:
child_i fails âŸ¹ restart(child_i)

OneForAll:
child_i fails âŸ¹ âˆ€j. restart(child_j)

RestForOne:
child_i fails âŸ¹ âˆ€j â‰¥ i. restart(child_j)

/* ç›‘ç£è§„åˆ™ */

OnFailure(child):
    restarts++
    
    if restarts > maxRestarts within timeWindow:
        escalate_to_parent()
    else:
        apply_strategy(child)

/* Goå®ç° */

type SupervisorStrategy int

const (
    OneForOne SupervisorStrategy = iota
    OneForAll
    RestForOne
)

type Supervisor struct {
    children     []Actor
    strategy     SupervisorStrategy
    maxRestarts  int
    timeWindow   time.Duration
    restarts     []time.Time
    mu           sync.Mutex
}

func NewSupervisor(strategy SupervisorStrategy, 
                   maxRestarts int, 
                   timeWindow time.Duration) *Supervisor {
    return &Supervisor{
        strategy:    strategy,
        maxRestarts: maxRestarts,
        timeWindow:  timeWindow,
        restarts:    []time.Time{},
    }
}

func (s *Supervisor) AddChild(child Actor) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    s.children = append(s.children, child)
    child.Start()
}

func (s *Supervisor) OnChildFailure(failedChild Actor) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    // è®°å½•é‡å¯æ—¶é—´
    now := time.Now()
    s.restarts = append(s.restarts, now)
    
    // æ¸…ç†è¿‡æœŸè®°å½•
    cutoff := now.Add(-s.timeWindow)
    validRestarts := []time.Time{}
    for _, t := range s.restarts {
        if t.After(cutoff) {
            validRestarts = append(validRestarts, t)
        }
    }
    s.restarts = validRestarts
    
    // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é‡å¯é™åˆ¶
    if len(s.restarts) > s.maxRestarts {
        s.escalate()
        return
    }
    
    // åº”ç”¨é‡å¯ç­–ç•¥
    switch s.strategy {
    case OneForOne:
        s.restartChild(failedChild)
    
    case OneForAll:
        for _, child := range s.children {
            s.restartChild(child)
        }
    
    case RestForOne:
        restartNext := false
        for _, child := range s.children {
            if child == failedChild {
                restartNext = true
            }
            if restartNext {
                s.restartChild(child)
            }
        }
    }
}

func (s *Supervisor) restartChild(child Actor) {
    child.Stop()
    child.Start()
    log.Printf("Restarted child actor")
}

func (s *Supervisor) escalate() {
    log.Printf("Max restarts exceeded, escalating to parent")
    // å‘çˆ¶ç›‘ç£è€…æŠ¥å‘Š
}
```

---

## ç¬¬å…­éƒ¨åˆ†: Session Types

### 6.1 Session Typesç†è®º

```mathematical
/* Session Types: é€šä¿¡åè®®çš„ç±»å‹ç³»ç»Ÿ */

SessionType ::=
    | end                    // ä¼šè¯ç»“æŸ
    | !Ï„.S                   // å‘é€ç±»å‹Ï„,ç„¶åS
    | ?Ï„.S                   // æ¥æ”¶ç±»å‹Ï„,ç„¶åS
    | Sâ‚ âŠ• Sâ‚‚                // å†…éƒ¨é€‰æ‹©
    | Sâ‚ & Sâ‚‚                // å¤–éƒ¨é€‰æ‹©
    | Î¼X.S                   // é€’å½’

/* å¯¹å¶ (Duality) */

dual(end) = end
dual(!Ï„.S) = ?Ï„.dual(S)
dual(?Ï„.S) = !Ï„.dual(S)
dual(Sâ‚ âŠ• Sâ‚‚) = dual(Sâ‚) & dual(Sâ‚‚)
dual(Sâ‚ & Sâ‚‚) = dual(Sâ‚) âŠ• dual(Sâ‚‚)

/* ä¼šè¯ç±»å‹åˆ¤æ–­ */

Î“ âŠ¢ P :: S

è¡¨ç¤ºè¿›ç¨‹Påœ¨ç¯å¢ƒÎ“ä¸‹å®ç°ä¼šè¯ç±»å‹S

/* ç±»å‹è§„åˆ™ */

[Send]
Î“ âŠ¢ e : Ï„    Î“ âŠ¢ P :: S
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ch!e; P :: !Ï„.S

[Receive]
Î“, x:Ï„ âŠ¢ P :: S
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ch?x; P :: ?Ï„.S

[Choice-Left]
Î“ âŠ¢ P :: Sâ‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ inl; P :: Sâ‚ âŠ• Sâ‚‚

[Choice-Right]
Î“ âŠ¢ P :: Sâ‚‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ inr; P :: Sâ‚ âŠ• Sâ‚‚

/* ç±»å‹å®‰å…¨æ€§ */

å®šç† (Session Fidelity):
å¦‚æœ Î“ âŠ¢ P :: S ä¸” Î“ âŠ¢ Q :: dual(S),
åˆ™ P || Q æ˜¯ç±»å‹å®‰å…¨çš„

è¯æ˜:
ç”±ä¼šè¯ç±»å‹çš„å¯¹å¶æ€§ä¿è¯
å‘é€åŒ¹é…æ¥æ”¶,é€‰æ‹©åŒ¹é…åˆ†æ”¯ âœ“
```

### 6.2 Channelåè®®

#### Protocolå®šä¹‰

```mathematical
/* Go Channel Protocol */

Protocol = sequence of operations

Example: Request-Response Protocol
Protocol = !Request.?Response.end

Client: ch!request; ch?response
Server: ch?request; ch!response

/* æ›´å¤æ‚çš„åè®® */

LoginProtocol = 
    !Username.
    !Password.
    (?Success.end âŠ• ?Failure.LoginProtocol)

è¡¨ç¤º:
1. å‘é€ç”¨æˆ·å
2. å‘é€å¯†ç 
3. æ¥æ”¶æˆåŠŸæˆ–å¤±è´¥
   - æˆåŠŸ: ç»“æŸ
   - å¤±è´¥: é‡æ–°ç™»å½•

/* Goå®ç° */

type LoginRequest struct {
    Username string
    Password string
}

type LoginResponse struct {
    Success bool
    Token   string
    Error   string
}

// Clientå®ç°LoginProtocol
func loginClient(ch chan interface{}) (string, error) {
    for {
        // !Username
        ch <- LoginRequest{
            Username: getUsername(),
            Password: getPassword(),
        }
        
        // ?Response
        resp := (<-ch).(LoginResponse)
        
        if resp.Success {
            return resp.Token, nil  // end
        } else {
            log.Printf("Login failed: %s, retrying...", resp.Error)
            // å¾ªç¯ç»§ç»­ (recursive call)
        }
    }
}

// Serverå®ç°dual(LoginProtocol)
func loginServer(ch chan interface{}) {
    for {
        // ?Request
        req := (<-ch).(LoginRequest)
        
        // Validate
        if authenticate(req.Username, req.Password) {
            // !Success
            ch <- LoginResponse{
                Success: true,
                Token:   generateToken(req.Username),
            }
            break  // end
        } else {
            // !Failure
            ch <- LoginResponse{
                Success: false,
                Error:   "Invalid credentials",
            }
            // å¾ªç¯ç»§ç»­
        }
    }
}
```

### 6.3 åè®®æ­£ç¡®æ€§éªŒè¯

#### åè®®å…¼å®¹æ€§æ£€æŸ¥

```mathematical
/* åè®®å…¼å®¹æ€§ (Protocol Compatibility) */

å®šä¹‰: Protocol Pâ‚ å’Œ Pâ‚‚ å…¼å®¹,å½“ä¸”ä»…å½“:
Pâ‚‚ âŠ‘ dual(Pâ‚)

å…¶ä¸­ âŠ‘ æ˜¯åè®®çš„å­ç±»å‹å…³ç³»

/* å­ç±»å‹è§„åˆ™ */

[Sub-End]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
end âŠ‘ end

[Sub-Send]
Ï„' <: Ï„    S âŠ‘ S'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
!Ï„'.S âŠ‘ !Ï„.S'

[Sub-Recv]
Ï„ <: Ï„'    S âŠ‘ S'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
?Ï„.S âŠ‘ ?Ï„'.S'

[Sub-Choice]
Sâ‚ âŠ‘ Sâ‚'    Sâ‚‚ âŠ‘ Sâ‚‚'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Sâ‚ âŠ• Sâ‚‚ âŠ‘ Sâ‚' âŠ• Sâ‚‚'

/* æ­»é”æ£€æµ‹ */

deadlock_free(P, Q) âŸº 
  âˆ€ reachable state (P', Q'). 
    Â¬(P' blocked âˆ§ Q' blocked)

å®šç† (Deadlock Freedom):
å¦‚æœ Î“ âŠ¢ P :: S ä¸” Î“ âŠ¢ Q :: dual(S),
åˆ™ P || Q æ— æ­»é”

è¯æ˜:
ç”±session typeä¿è¯:
- P å‘é€ âŸ¹ Q æ¥æ”¶ (ä¸ä¼šåŒæ–¹éƒ½é˜»å¡)
- P æ¥æ”¶ âŸ¹ Q å‘é€
å› æ­¤ä¸ä¼šæ­»é” âœ“

/* Goç±»å‹çº§éªŒè¯ (ç¼–è¯‘æ—¶æ£€æŸ¥) */

// ä½¿ç”¨ç±»å‹ç³»ç»Ÿç¼–ç åè®®

type Send struct {
    ch chan<- interface{}
}

type Recv struct {
    ch <-chan interface{}
}

type End struct {}

// Protocol: !int.?string.end
func client(send Send) string {
    send.ch <- 42  // åªèƒ½å‘é€
    
    recv := Recv{ch: send.ch}
    result := <-recv.ch  // åªèƒ½æ¥æ”¶
    
    _ = End{}  // æ ‡è®°ç»“æŸ
    
    return result.(string)
}

// ç¼–è¯‘æ—¶ä¿è¯åè®®éµå¾ª!
// å°è¯•è¿ååè®®ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯

// é”™è¯¯ç¤ºä¾‹:
// <-send.ch  // ç¼–è¯‘é”™è¯¯: send-only channel
// send.ch <- "text"  // åœ¨æ¥æ”¶åå‘é€,è¿ååè®®
```

---

## ğŸ¯ æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†Goå¹¶å‘æ¨¡å¼çš„å®Œæ•´å½¢å¼åŒ–åˆ†æä½“ç³»:

### æ ¸å¿ƒå†…å®¹

1. **ç»å…¸å¹¶å‘æ¨¡å¼**
   - ç”Ÿäº§è€…-æ¶ˆè´¹è€…
   - Fan-Out/Fan-In
   - Pipeline
   - Worker Pool

2. **åŒæ­¥æ¨¡å¼**
   - Barrier
   - Future/Promise
   - ä¿¡å·é‡
   - WaitGroup

3. **æ§åˆ¶æµæ¨¡å¼**
   - è¶…æ—¶ä¸å–æ¶ˆ
   - é‡è¯•ä¸é€€é¿
   - ç†”æ–­å™¨
   - é™æµ

4. **æ•°æ®æµæ¨¡å¼**
   - æµå¼å¤„ç†
   - èƒŒå‹æ§åˆ¶
   - æ‰¹å¤„ç†
   - çª—å£èšåˆ

5. **Actoræ¨¡å¼**
   - Actoræ¨¡å‹å½¢å¼åŒ–
   - Goroutine-Actoræ˜ å°„
   - ç›‘ç£æ ‘

6. **Session Types**
   - ä¼šè¯ç±»å‹ç†è®º
   - Channelåè®®
   - åè®®éªŒè¯

### ç†è®ºè´¡çŒ®

- æ¯ç§æ¨¡å¼çš„CSPå½¢å¼åŒ–
- æ­£ç¡®æ€§æ€§è´¨è¯æ˜
- æ€§èƒ½åˆ†ææ¨¡å‹
- Goå®ç°æ˜ å°„

### å·¥ç¨‹ä»·å€¼

- å¯ç›´æ¥ä½¿ç”¨çš„æ¨¡å¼å®ç°
- æ€§èƒ½ä¼˜åŒ–æŒ‡å¯¼
- å¹¶å‘å®‰å…¨ä¿è¯
- åè®®æ­£ç¡®æ€§éªŒè¯

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**åŸºå‡†æ—¥æœŸ**: 2025å¹´10æœˆ23æ—¥  
**Goç‰ˆæœ¬**: Go 1.25.3  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ

---

<div align="center">

Made with â¤ï¸ for Go Concurrency Researchers

[â¬† å›åˆ°é¡¶éƒ¨](#goå¹¶å‘æ¨¡å¼å®Œæ•´å½¢å¼åŒ–åˆ†æ)

</div>
