# è¿è¡Œæ—¶ä¸å†…å­˜æ¨¡å‹

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0
**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.25.3

---

## ğŸ“‹ ç›®å½•

- [è¿è¡Œæ—¶ä¸å†…å­˜æ¨¡å‹](#è¿è¡Œæ—¶ä¸å†…å­˜æ¨¡å‹)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ç¬¬ä¸€éƒ¨åˆ†: GMPè°ƒåº¦æ¨¡å‹](#ç¬¬ä¸€éƒ¨åˆ†-gmpè°ƒåº¦æ¨¡å‹)
    - [1.1 GMPæ¶æ„](#11-gmpæ¶æ„)
    - [1.2 è°ƒåº¦å™¨å½¢å¼åŒ–](#12-è°ƒåº¦å™¨å½¢å¼åŒ–)
    - [1.3 Work Stealingç®—æ³•](#13-work-stealingç®—æ³•)
    - [1.4 æŠ¢å å¼è°ƒåº¦](#14-æŠ¢å å¼è°ƒåº¦)
  - [ç¬¬äºŒéƒ¨åˆ†: åƒåœ¾å›æ”¶ç®—æ³•](#ç¬¬äºŒéƒ¨åˆ†-åƒåœ¾å›æ”¶ç®—æ³•)
    - [2.1 ä¸‰è‰²æ ‡è®°ç®—æ³•](#21-ä¸‰è‰²æ ‡è®°ç®—æ³•)
    - [2.2 å¹¶å‘GCä¸å†™å±éšœ](#22-å¹¶å‘gcä¸å†™å±éšœ)
    - [2.3 Go 1.25.3 GCä¼˜åŒ–](#23-go-1253-gcä¼˜åŒ–)
    - [2.4 GCæ­£ç¡®æ€§è¯æ˜](#24-gcæ­£ç¡®æ€§è¯æ˜)
  - [ç¬¬ä¸‰éƒ¨åˆ†: å†…å­˜æ¨¡å‹](#ç¬¬ä¸‰éƒ¨åˆ†-å†…å­˜æ¨¡å‹)
    - [3.1 Happens-Beforeå®Œæ•´å®šä¹‰](#31-happens-beforeå®Œæ•´å®šä¹‰)
    - [3.2 åŒæ­¥åŸè¯­è¯­ä¹‰](#32-åŒæ­¥åŸè¯­è¯­ä¹‰)
    - [3.3 åŸå­æ“ä½œè¯­ä¹‰](#33-åŸå­æ“ä½œè¯­ä¹‰)
    - [3.4 å†…å­˜å±éšœ](#34-å†…å­˜å±éšœ)
  - [ç¬¬å››éƒ¨åˆ†: æ•°æ®ç«äº‰æ£€æµ‹](#ç¬¬å››éƒ¨åˆ†-æ•°æ®ç«äº‰æ£€æµ‹)
    - [4.1 æ•°æ®ç«äº‰å½¢å¼åŒ–å®šä¹‰](#41-æ•°æ®ç«äº‰å½¢å¼åŒ–å®šä¹‰)
    - [4.2 åŠ¨æ€ç«äº‰æ£€æµ‹ (Race Detector)](#42-åŠ¨æ€ç«äº‰æ£€æµ‹-race-detector)
    - [4.3 é™æ€ç«äº‰æ£€æµ‹](#43-é™æ€ç«äº‰æ£€æµ‹)
  - [ç¬¬äº”éƒ¨åˆ†: è¿è¡Œæ—¶ä¼˜åŒ–](#ç¬¬äº”éƒ¨åˆ†-è¿è¡Œæ—¶ä¼˜åŒ–)
    - [5.1 å†…è”ä¼˜åŒ–](#51-å†…è”ä¼˜åŒ–)
    - [5.2 é€ƒé€¸åˆ†æ](#52-é€ƒé€¸åˆ†æ)
    - [5.3 è¾¹ç•Œæ£€æŸ¥æ¶ˆé™¤](#53-è¾¹ç•Œæ£€æŸ¥æ¶ˆé™¤)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
    - [æ ¸å¿ƒè´¡çŒ®](#æ ¸å¿ƒè´¡çŒ®)
    - [ç†è®ºæ„ä¹‰](#ç†è®ºæ„ä¹‰)
    - [å®è·µä»·å€¼](#å®è·µä»·å€¼)

## ç¬¬ä¸€éƒ¨åˆ†: GMPè°ƒåº¦æ¨¡å‹

### 1.1 GMPæ¶æ„

```mathematical
/* GMPç»„ä»¶å®šä¹‰ */

/* G - Goroutine */
Goroutine G = {
    id: GID,
    stack: Stack,
    state: G_State,
    pc: ProgramCounter,
    sp: StackPointer,
    sched: SchedData,
    m: Machine?  /* å½“å‰ç»‘å®šçš„M */
}

G_State ::= Created
          | Runnable
          | Running
          | Waiting
          | Dead

/* M - Machine (OS Thread) */
Machine M = {
    id: MID,
    g: Goroutine?,  /* å½“å‰æ‰§è¡Œçš„G */
    p: Processor?,  /* å½“å‰ç»‘å®šçš„P */
    spin: Boolean,  /* æ˜¯å¦åœ¨è‡ªæ—‹ */
    nextp: Processor?,  /* ç­‰å¾…å”¤é†’åç»‘å®šçš„P */
    thread: OSThread
}

/* P - Processor (Logical Processor) */
Processor P = {
    id: PID,
    status: P_Status,
    m: Machine?,  /* å½“å‰ç»‘å®šçš„M */
    runq: LocalQueue[Goroutine],  /* æœ¬åœ°è¿è¡Œé˜Ÿåˆ— */
    runnext: Goroutine?,  /* ä¸‹ä¸€ä¸ªè¦è¿è¡Œçš„G */
    gcBgMarkWorker: Goroutine?,  /* GCåå°æ ‡è®°worker */
}

P_Status ::= Idle
           | Running
           | Syscall
           | GCstop

/* å…¨å±€è¿è¡Œæ—¶çŠ¶æ€ */

Runtime = {
    sched: Scheduler,
    allgs: Set[Goroutine],  /* æ‰€æœ‰G */
    allm: Set[Machine],  /* æ‰€æœ‰M */
    allp: Array[Processor],  /* æ‰€æœ‰P (å›ºå®šæ•°é‡GOMAXPROCS) */
    GOMAXPROCS: â„•
}

Scheduler = {
    global_runq: GlobalQueue[Goroutine],
    idle_p: List[Processor],  /* ç©ºé—²Påˆ—è¡¨ */
    idle_m: List[Machine],  /* ç©ºé—²Måˆ—è¡¨ */
    nmidle: â„•,  /* ç©ºé—²Mæ•°é‡ */
    nmsys: â„•,  /* ç³»ç»ŸMæ•°é‡ */
    nmspinning: â„•  /* è‡ªæ—‹Mæ•°é‡ */
}
```

### 1.2 è°ƒåº¦å™¨å½¢å¼åŒ–

```mathematical
/* è°ƒåº¦å†³ç­–å‡½æ•° */

schedule : Runtime â†’ (Goroutine, Processor, Machine)

/* è°ƒåº¦æµç¨‹ */

function schedule(rt: Runtime):
    /* 1. é€‰æ‹©ä¸€ä¸ªGæ¥è¿è¡Œ */
    g = findRunnable(rt)

    /* 2. é€‰æ‹©ä¸€ä¸ªP */
    p = acquireP(rt)

    /* 3. é€‰æ‹©æˆ–åˆ›å»ºä¸€ä¸ªM */
    m = getMOrCreate(rt)

    /* 4. ç»‘å®šG-P-M */
    bind(g, p, m)

    /* 5. æ‰§è¡ŒG */
    execute(g, p, m)

/* findRunnableç®—æ³• */

function findRunnable(rt: Runtime) -> Goroutine:
    /* 1. æ£€æŸ¥å½“å‰Pçš„runnext */
    if current_p.runnext is not None:
        return current_p.runnext

    /* 2. æ£€æŸ¥æœ¬åœ°è¿è¡Œé˜Ÿåˆ— */
    if current_p.runq is not empty:
        return current_p.runq.pop()

    /* 3. æ£€æŸ¥å…¨å±€è¿è¡Œé˜Ÿåˆ— */
    if rt.sched.global_runq is not empty:
        batch = rt.sched.global_runq.pop_batch()
        return batch[0]  /* å…¶ä½™æ”¾å›æœ¬åœ°é˜Ÿåˆ— */

    /* 4. ä»ç½‘ç»œè½®è¯¢å™¨è·å–å°±ç»ªçš„G */
    if netpoll_ready:
        return netpoll()

    /* 5. Work Stealing - ä»å…¶ä»–På·å– */
    for _ in range(4):  /* æœ€å¤šå°è¯•4æ¬¡ */
        victim = random_p()
        if stolen_g = steal_from(victim):
            return stolen_g

    /* 6. å†æ¬¡æ£€æŸ¥å…¨å±€é˜Ÿåˆ— */
    if rt.sched.global_runq is not empty:
        return rt.sched.global_runq.pop()

    /* 7. å†æ¬¡æ£€æŸ¥ç½‘ç»œè½®è¯¢å™¨ (é˜»å¡æ¨¡å¼) */
    if netpoll_available:
        return netpoll(block=true)

    /* 8. æ²¡æœ‰å¯è¿è¡Œçš„G,Mè¿›å…¥ä¼‘çœ  */
    return None

/* è°ƒåº¦è§„åˆ™ */

[Schedule-Local]
current_p.runq is not empty
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
schedule() â†’ dequeue(current_p.runq)

[Schedule-Global]
current_p.runq is empty âˆ§ global_runq is not empty
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
schedule() â†’ dequeue(global_runq)

[Schedule-Steal]
current_p.runq is empty âˆ§ global_runq is empty âˆ§
âˆƒ p'. p'.runq is not empty
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
schedule() â†’ steal_from(p')

[Schedule-Idle]
âˆ€ source. no runnable goroutines
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
schedule() â†’ idle(current_m)
```

### 1.3 Work Stealingç®—æ³•

```mathematical
/* Work Stealingå½¢å¼åŒ– */

function steal_from(victim: Processor) -> Goroutine?:
    /* 1. å°è¯•è·å–victimçš„é” */
    if not try_lock(victim.runq):
        return None

    /* 2. ä»é˜Ÿåˆ—å°¾éƒ¨å·å–ä¸€åŠ */
    n = len(victim.runq)
    if n == 0:
        unlock(victim.runq)
        return None

    steal_count = n / 2
    stolen = victim.runq.steal_tail(steal_count)

    unlock(victim.runq)

    /* 3. å°†å·å–çš„Gæ”¾å…¥æœ¬åœ°é˜Ÿåˆ— */
    for g in stolen[1:]:
        current_p.runq.push(g)

    return stolen[0]

/* Work Stealingæ­£ç¡®æ€§ */

å®šç† (Work Stealing Correctness):
1. Work Stealingä¸ä¼šä¸¢å¤±G
2. æ¯ä¸ªGæœ€ç»ˆä¼šè¢«æ‰§è¡Œ
3. è´Ÿè½½è¶‹äºå¹³è¡¡

è¯æ˜:

1. ä¸ä¸¢å¤±:
   æ‰€æœ‰Gè¦ä¹ˆåœ¨æŸä¸ªPçš„é˜Ÿåˆ—ä¸­,è¦ä¹ˆåœ¨å…¨å±€é˜Ÿåˆ—ä¸­ã€‚
   Stealæ“ä½œæ˜¯åŸå­çš„,å› æ­¤ä¸ä¼šä¸¢å¤±ã€‚ âœ“

2. æœ€ç»ˆæ‰§è¡Œ:
   å¦‚æœGåœ¨æŸä¸ªé˜Ÿåˆ—ä¸­,åˆ™:
   - å¦‚æœåœ¨æœ¬åœ°é˜Ÿåˆ— â†’ è¯¥Pæœ€ç»ˆä¼šæ‰§è¡Œå®ƒ
   - å¦‚æœåœ¨å…¨å±€é˜Ÿåˆ— â†’ æŸä¸ªPä¼šè·å–å¹¶æ‰§è¡Œå®ƒ
   - å¦‚æœåœ¨è¢«steal â†’ æ–°çš„Pä¼šæ‰§è¡Œå®ƒ
   å› æ­¤æœ€ç»ˆä¼šè¢«æ‰§è¡Œã€‚ âœ“

3. è´Ÿè½½å¹³è¡¡:
   è®¾Pâ‚çš„é˜Ÿåˆ—é•¿åº¦ä¸ºnâ‚, Pâ‚‚çš„é˜Ÿåˆ—é•¿åº¦ä¸ºnâ‚‚ã€‚
   å¦‚æœnâ‚ â‰« nâ‚‚,åˆ™Pâ‚‚ä¼šä»Pâ‚ stealçº¦nâ‚/2ä¸ªGã€‚
   ç»è¿‡å¤šæ¬¡steal,é˜Ÿåˆ—é•¿åº¦è¶‹äºå¹³è¡¡ã€‚ âœ“ â–¡

/* Work Stealingæ•ˆç‡åˆ†æ */

å®šç† (Work Stealing Efficiency):
è®¾T_âˆä¸ºæ— é™å¤„ç†å™¨çš„æ‰§è¡Œæ—¶é—´,
è®¾T_Pä¸ºPä¸ªå¤„ç†å™¨çš„æ‰§è¡Œæ—¶é—´,
åˆ™ T_P = O(T_âˆ + W/P)
å…¶ä¸­Wä¸ºæ€»å·¥ä½œé‡ã€‚

è¯æ˜:
ç”±Work Stealingçš„è´Ÿè½½å‡è¡¡æ€§è´¨ä¿è¯ã€‚ â–¡
```

### 1.4 æŠ¢å å¼è°ƒåº¦

```mathematical
/* æŠ¢å å¼è°ƒåº¦ (Preemption) */

/* æŠ¢å ç‚¹ */

PreemptionPoint ::= FunctionCall
                  | LoopBackEdge
                  | GCCheck
                  | SyscallEntry
                  | SignalHandler

/* æŠ¢å æ£€æŸ¥ */

function check_preempt(g: Goroutine):
    if g.stackguard0 == stackPreempt:
        /* è§¦å‘æŠ¢å  */
        preempt(g)

/* æŠ¢å æµç¨‹ */

[Preempt-Begin]
g.running_time > time_quantum âˆ¨ gc_needs_stop
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
set_preempt_flag(g)

[Preempt-Check]
g reaches safe_point âˆ§ g.preempt_flag is set
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
save_state(g)
g.state := Runnable
enqueue(g, runqueue)
schedule()

/* åŸºäºä¿¡å·çš„æŠ¢å  (Go 1.14+) */

function async_preempt(g: Goroutine):
    /* 1. å‘é€SIGURGä¿¡å· */
    send_signal(g.m.thread, SIGURG)

    /* 2. ä¿¡å·å¤„ç†å™¨ */
    signal_handler:
        save_registers()
        g.state = Runnable
        enqueue(g, runqueue)
        schedule()

/* Go 1.25.3å¢å¼ºçš„æŠ¢å  */

/* æ›´ç²¾ç»†çš„æŠ¢å æ§åˆ¶ */
function enhanced_preempt(g: Goroutine):
    /* 1. æ£€æŸ¥Gçš„ä¼˜å…ˆçº§ */
    if g.priority > threshold:
        /* é«˜ä¼˜å…ˆçº§Gä¸è¢«æŠ¢å  */
        return

    /* 2. æ£€æŸ¥æ˜¯å¦åœ¨å…³é”®åŒº */
    if g.in_critical_section:
        /* æ¨è¿ŸæŠ¢å  */
        g.deferred_preempt = true
        return

    /* 3. æ­£å¸¸æŠ¢å  */
    preempt(g)
```

---

## ç¬¬äºŒéƒ¨åˆ†: åƒåœ¾å›æ”¶ç®—æ³•

### 2.1 ä¸‰è‰²æ ‡è®°ç®—æ³•

```mathematical
/* ä¸‰è‰²æ ‡è®°GC */

/* å¯¹è±¡é¢œè‰² */

Color ::= White  /* æœªè®¿é—®,å¯èƒ½æ˜¯åƒåœ¾ */
        | Grey   /* å·²è®¿é—®,ä½†å­å¯¹è±¡æœªè®¿é—® */
        | Black  /* å·²è®¿é—®,å­å¯¹è±¡ä¹Ÿå·²è®¿é—® */

/* GCçŠ¶æ€ */

GC_State = {
    white_set: Set[Object],
    grey_set: Set[Object],
    black_set: Set[Object],
    roots: Set[Object]
}

/* ä¸‰è‰²ä¸å˜å¼ */

Tricolor_Invariant:
    æ²¡æœ‰é»‘è‰²å¯¹è±¡ç›´æ¥æŒ‡å‘ç™½è‰²å¯¹è±¡

/* æ ‡è®°ç®—æ³• */

function mark(roots: Set[Object]):
    /* 1. åˆå§‹åŒ– */
    white_set = all_objects
    grey_set = roots
    black_set = âˆ…

    /* 2. æ ‡è®°å¾ªç¯ */
    while grey_set is not empty:
        obj = grey_set.pop()

        /* æ‰«æobjçš„å­å¯¹è±¡ */
        for child in children(obj):
            if child in white_set:
                white_set.remove(child)
                grey_set.add(child)

        /* objæ ‡è®°ä¸ºé»‘è‰² */
        black_set.add(obj)

    /* 3. æ¸…æ‰« */
    for obj in white_set:
        free(obj)

/* æ ‡è®°æ­£ç¡®æ€§ */

å®šç† (Mark Correctness):
æ ‡è®°å®Œæˆå,æ‰€æœ‰å¯è¾¾å¯¹è±¡éƒ½åœ¨black_setä¸­,
æ‰€æœ‰ä¸å¯è¾¾å¯¹è±¡éƒ½åœ¨white_setä¸­ã€‚

è¯æ˜:
å½’çº³è¯æ˜:
Base: åˆå§‹æ—¶,rootséƒ½åœ¨grey_setä¸­,æ­£ç¡®ã€‚
Inductive: å‡è®¾å½“å‰æ­£ç¡®,åˆ™:
  - ä»greyå–å‡ºobjæ ‡è®°ä¸ºblack
  - objçš„æ‰€æœ‰å­å¯¹è±¡åŠ å…¥grey
  å› æ­¤æ‰€æœ‰å¯è¾¾å¯¹è±¡æœ€ç»ˆéƒ½ä¼šè¢«æ ‡è®°ä¸ºblackã€‚ â–¡
```

### 2.2 å¹¶å‘GCä¸å†™å±éšœ

```mathematical
/* å¹¶å‘GCé—®é¢˜ */

é—®é¢˜: Mutator(åº”ç”¨ç¨‹åº)åœ¨GCæ ‡è®°æ—¶å¯èƒ½ä¿®æ”¹å¯¹è±¡å›¾,
     å¯¼è‡´ä¸‰è‰²ä¸å˜å¼è¢«ç ´åã€‚

ç¤ºä¾‹:
1. é»‘è‰²å¯¹è±¡Aæ·»åŠ æŒ‡å‘ç™½è‰²å¯¹è±¡Cçš„æŒ‡é’ˆ
2. åˆ é™¤ç°è‰²å¯¹è±¡Båˆ°Cçš„æŒ‡é’ˆ
3. ç»“æœ:Cå˜ä¸ºä¸å¯è¾¾,ä½†ä»ä¸ºç™½è‰²,ä¼šè¢«é”™è¯¯å›æ”¶

/* å†™å±éšœ (Write Barrier) */

/* Dijkstraå†™å±éšœ */

function dijkstra_write_barrier(obj, field, new_value):
    /* å½“é»‘è‰²å¯¹è±¡å†™å…¥æ—¶,å°†æ–°å€¼æ ‡ç° */
    if is_black(obj) and is_white(new_value):
        mark_grey(new_value)

    obj[field] = new_value

/* Yuasaå†™å±éšœ */

function yuasa_write_barrier(obj, field, new_value):
    /* ä¿æŠ¤è¢«è¦†ç›–çš„å€¼ */
    old_value = obj[field]
    if is_white(old_value):
        mark_grey(old_value)

    obj[field] = new_value

/* Goæ··åˆå†™å±éšœ (Go 1.8+) */

function hybrid_write_barrier(obj, field, new_value):
    /* 1. æ ‡ç°è¢«è¦†ç›–çš„å€¼ (Yuasaé£æ ¼) */
    old_value = obj[field]
    if is_white(old_value):
        mark_grey(old_value)

    /* 2. æ ‡ç°æ–°å€¼ (Dijkstraé£æ ¼) */
    if is_black(obj) and is_white(new_value):
        mark_grey(new_value)

    obj[field] = new_value

/* å†™å±éšœæ­£ç¡®æ€§ */

å®šç† (Write Barrier Correctness):
æ··åˆå†™å±éšœä¿è¯ä¸‰è‰²ä¸å˜å¼åœ¨å¹¶å‘GCä¸­æˆç«‹ã€‚

è¯æ˜:
è€ƒè™‘æ‰€æœ‰å¯èƒ½ç ´åä¸‰è‰²ä¸å˜å¼çš„æƒ…å†µ:
1. é»‘â†’ç™½çš„æ–°æŒ‡é’ˆ: è¢«Dijkstraéƒ¨åˆ†å¤„ç†
2. ç™½å¯¹è±¡å¤±å»å¼•ç”¨: è¢«Yuasaéƒ¨åˆ†å¤„ç†
å› æ­¤ä¸‰è‰²ä¸å˜å¼æ€»æ˜¯æˆç«‹ã€‚ â–¡
```

### 2.3 Go 1.25.3 GCä¼˜åŒ–

```mathematical
/* Go 1.25.3 GCå¢å¼º */

/* 1. åˆ†ä»£GCå®éªŒæ€§æ”¯æŒ */

GenerationalGC = {
    young_gen: Heap,  /* æ–°ç”Ÿä»£ */
    old_gen: Heap,    /* è€å¹´ä»£ */
    remembered_set: Set[(Object, Object)]  /* è€â†’æ–°çš„å¼•ç”¨ */
}

function generational_gc():
    /* 1. Minor GC: åªæ‰«ææ–°ç”Ÿä»£ */
    mark_from_roots(young_gen)
    mark_from_remembered_set()
    sweep(young_gen)

    /* 2. æ™‹å‡å­˜æ´»å¯¹è±¡ */
    for obj in survivors(young_gen):
        if obj.age > tenure_threshold:
            promote(obj, old_gen)

    /* 3. Major GC: å®šæœŸå®Œæ•´æ‰«æ */
    if should_major_gc():
        mark_sweep(entire_heap)

/* 2. å¹¶è¡Œæ ‡è®°ä¼˜åŒ– */

function parallel_mark(roots: Set[Object], num_workers: int):
    work_queue = ConcurrentQueue(roots)

    /* å¯åŠ¨å¤šä¸ªæ ‡è®°worker */
    for i in range(num_workers):
        spawn_worker(i, work_queue)

    function mark_worker(id: int, queue: ConcurrentQueue):
        while true:
            obj = queue.pop()
            if obj is None:
                break

            /* æ ‡è®°å­å¯¹è±¡ */
            for child in children(obj):
                if mark_grey(child):  /* åŸå­æ“ä½œ */
                    queue.push(child)

            mark_black(obj)

/* 3. ç²¾ç¡®çš„å †å¤§å°ç›®æ ‡æ§åˆ¶ */

function compute_gc_trigger(prev_heap_size, prev_gc_cpu, target_cpu):
    /* åŠ¨æ€è°ƒæ•´GCè§¦å‘é˜ˆå€¼ */
    if prev_gc_cpu > target_cpu:
        /* GCå ç”¨CPUè¿‡é«˜,å¢åŠ è§¦å‘é˜ˆå€¼ */
        trigger = prev_heap_size * 1.2
    else:
        /* GCå ç”¨CPUè¾ƒä½,é™ä½è§¦å‘é˜ˆå€¼ */
        trigger = prev_heap_size * 1.05

    return trigger

/* Go 1.25.3æ€§èƒ½æå‡ */

æ€§èƒ½æ•°æ®:
- GCå»¶è¿Ÿ: <1ms (99th percentile)
- STWæ—¶é—´: <100Î¼s
- ååé‡æŸå¤±: <5%
- å¹¶è¡Œæ ‡è®°æ•ˆç‡: è¿‘çº¿æ€§æ‰©å±•åˆ°16æ ¸
```

### 2.4 GCæ­£ç¡®æ€§è¯æ˜

```mathematical
/* GCå®‰å…¨æ€§å®šç† */

å®šç† (GC Safety):
GCä¸ä¼šå›æ”¶å¯è¾¾å¯¹è±¡ã€‚

å½¢å¼åŒ–:
âˆ€ obj âˆˆ Objects.
reachable(obj, roots) â‡’ obj âˆ‰ reclaimed_set

è¯æ˜:
ç”±ä¸‰è‰²æ ‡è®°çš„æ­£ç¡®æ€§ + å†™å±éšœçš„æ­£ç¡®æ€§ä¿è¯ã€‚
å¯è¾¾å¯¹è±¡æœ€ç»ˆä¼šè¢«æ ‡è®°ä¸ºé»‘è‰²,
é»‘è‰²å¯¹è±¡ä¸ä¼šè¢«å›æ”¶ã€‚ â–¡

/* GCæ´»æ€§å®šç† */

å®šç† (GC Liveness):
GCæœ€ç»ˆä¼šå›æ”¶æ‰€æœ‰ä¸å¯è¾¾å¯¹è±¡ã€‚

å½¢å¼åŒ–:
âˆ€ obj âˆˆ Objects.
Â¬reachable(obj, roots) â‡’ eventually reclaimed(obj)

è¯æ˜:
ä¸å¯è¾¾å¯¹è±¡æœ€ç»ˆä¿æŒç™½è‰²,
ç™½è‰²å¯¹è±¡åœ¨sweepé˜¶æ®µè¢«å›æ”¶ã€‚ â–¡

/* GCå®Œå¤‡æ€§å®šç† */

å®šç† (GC Completeness):
GCæ ‡è®°é˜¶æ®µæœ€ç»ˆä¼šç»ˆæ­¢ã€‚

è¯æ˜:
å¯¹è±¡å›¾æ˜¯æœ‰é™çš„,
æ ‡è®°ç®—æ³•æ˜¯å•è°ƒçš„(å¯¹è±¡åªèƒ½ä»ç™½â†’ç°â†’é»‘),
å› æ­¤æœ€ç»ˆgrey_setä¼šå˜ç©ºã€‚ â–¡
```

---

## ç¬¬ä¸‰éƒ¨åˆ†: å†…å­˜æ¨¡å‹

### 3.1 Happens-Beforeå®Œæ•´å®šä¹‰

```mathematical
/* Happens-Beforeå…³ç³» */

HB âŠ† Event Ã— Event

/* äº‹ä»¶ç±»å‹ */

Event ::= Read(addr, value)
        | Write(addr, value)
        | Lock(mutex)
        | Unlock(mutex)
        | Send(channel, value)
        | Recv(channel, value)
        | GoCreate(goroutine)
        | GoExit(goroutine)

/* Happens-Beforeè§„åˆ™ */

[HB-PO] Program Order
eâ‚, eâ‚‚ in same goroutine âˆ§ eâ‚ < eâ‚‚ in program order
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ HB eâ‚‚

[HB-Go] Goroutine Creation
eâ‚ = go f() âˆ§ eâ‚‚ = first event in f()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ HB eâ‚‚

[HB-GoExit] Goroutine Termination
eâ‚ = last event in g() âˆ§ eâ‚‚ observes g's termination
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ HB eâ‚‚

[HB-Send] Channel Send/Recv
eâ‚ = send(ch, v) completes âˆ§ eâ‚‚ = recv(ch, v) receives
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ HB eâ‚‚

[HB-Close] Channel Close
eâ‚ = close(ch) âˆ§ eâ‚‚ = recv(ch) returns zero
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ HB eâ‚‚

[HB-Buffered] Buffered Channel (k-th recv)
eâ‚ = k-th send(ch, v) âˆ§ eâ‚‚ = k-th recv(ch, v)
ch.capacity = C
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ HB eâ‚‚ if k â‰¤ C

[HB-Lock] Mutex Lock/Unlock
eâ‚ = unlock(mu) âˆ§ eâ‚‚ = lock(mu) succeeds
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ HB eâ‚‚

[HB-RWLock-R] RWMutex Read Lock
eâ‚ = unlock(mu) âˆ§ eâ‚‚ = rlock(mu)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ HB eâ‚‚

[HB-RWLock-W] RWMutex Write Lock
eâ‚ = runlock(mu) âˆ§ eâ‚‚ = lock(mu) âˆ§ n = rlock_count
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ HB eâ‚‚ if n-th runlock

[HB-Once] sync.Once
eâ‚ = first once.Do(f) starts f âˆ§ eâ‚‚ = any once.Do(f) returns
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ HB eâ‚‚

[HB-Trans] Transitivity
eâ‚ HB eâ‚‚ âˆ§ eâ‚‚ HB eâ‚ƒ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ HB eâ‚ƒ

/* å¹¶å‘å…³ç³» */

eâ‚ âˆ¥ eâ‚‚ âŸº Â¬(eâ‚ HB eâ‚‚) âˆ§ Â¬(eâ‚‚ HB eâ‚)
```

### 3.2 åŒæ­¥åŸè¯­è¯­ä¹‰

```mathematical
/* Mutexè¯­ä¹‰ */

Mutex_State = {
    locked: Boolean,
    owner: GoroutineID?,
    waiters: Queue[GoroutineID]
}

[Mutex-Lock]
mu.locked = false
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨mu.Lock(), gâŸ© â†’ mu.locked := true; mu.owner := g

[Mutex-Lock-Wait]
mu.locked = true
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨mu.Lock(), gâŸ© â†’ g.state := Waiting(WaitMutex(mu))

[Mutex-Unlock]
mu.locked = true âˆ§ mu.owner = g
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨mu.Unlock(), gâŸ© â†’ mu.locked := false; wakeup(mu.waiters.pop())

/* RWMutexè¯­ä¹‰ */

RWMutex_State = {
    readers: â„•,
    writer: GoroutineID?,
    pending_writers: Queue[GoroutineID],
    pending_readers: Queue[GoroutineID]
}

[RWMutex-RLock]
rwmu.writer = None
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨rwmu.RLock(), gâŸ© â†’ rwmu.readers += 1

[RWMutex-Lock]
rwmu.readers = 0 âˆ§ rwmu.writer = None
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨rwmu.Lock(), gâŸ© â†’ rwmu.writer := g

[RWMutex-RUnlock]
rwmu.readers > 0
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨rwmu.RUnlock(), gâŸ© â†’ rwmu.readers -= 1;
                      if rwmu.readers = 0:
                          wakeup(rwmu.pending_writers.pop())

/* WaitGroupè¯­ä¹‰ */

WaitGroup_State = {
    counter: â„•,
    waiters: Set[GoroutineID]
}

[WaitGroup-Add]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨wg.Add(n), gâŸ© â†’ wg.counter += n

[WaitGroup-Done]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨wg.Done(), gâŸ© â†’ wg.counter -= 1;
                 if wg.counter = 0:
                     wakeup_all(wg.waiters)

[WaitGroup-Wait]
wg.counter > 0
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨wg.Wait(), gâŸ© â†’ g.state := Waiting(WaitWG(wg))

/* Condå˜é‡è¯­ä¹‰ */

Cond_State = {
    mu: Mutex,
    waiters: Set[GoroutineID]
}

[Cond-Wait]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨cond.Wait(), gâŸ© â†’
    mu.Unlock()
    g.state := Waiting(WaitCond(cond))
    /* è¢«å”¤é†’å */
    mu.Lock()

[Cond-Signal]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨cond.Signal(), gâŸ© â†’ wakeup(cond.waiters.pop())

[Cond-Broadcast]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨cond.Broadcast(), gâŸ© â†’ wakeup_all(cond.waiters)
```

### 3.3 åŸå­æ“ä½œè¯­ä¹‰

```mathematical
/* åŸå­æ“ä½œ (sync/atomic) */

/* åŸå­è¯» */
[Atomic-Load]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨atomic.Load(&x), gâŸ© â†’ âŸ¨value_of(x), gâŸ©  with memory_order: acquire

/* åŸå­å†™ */
[Atomic-Store]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨atomic.Store(&x, v), gâŸ© â†’ x := v  with memory_order: release

/* åŸå­äº¤æ¢ */
[Atomic-Swap]
old_value = x
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨atomic.Swap(&x, new), gâŸ© â†’ x := new; return old_value
                            with memory_order: seq_cst

/* åŸå­æ¯”è¾ƒäº¤æ¢ */
[Atomic-CAS-Success]
x = old
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨atomic.CompareAndSwap(&x, old, new), gâŸ© â†’
    x := new; return true
    with memory_order: seq_cst

[Atomic-CAS-Fail]
x â‰  old
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨atomic.CompareAndSwap(&x, old, new), gâŸ© â†’
    return false
    with memory_order: seq_cst

/* åŸå­åŠ æ³• */
[Atomic-Add]
old_value = x
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨atomic.Add(&x, delta), gâŸ© â†’
    x := old_value + delta
    return x
    with memory_order: seq_cst

/* å†…å­˜é¡ºåºè¯­ä¹‰ */

MemoryOrder ::= Relaxed  /* æ— åŒæ­¥ */
              | Acquire  /* è¯»å±éšœ */
              | Release  /* å†™å±éšœ */
              | SeqCst   /* é¡ºåºä¸€è‡´æ€§ */

/* Happens-Before for Atomics */

[HB-Atomic-Release-Acquire]
eâ‚ = atomic.Store(x, v) with release âˆ§
eâ‚‚ = atomic.Load(x) reads v with acquire
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
eâ‚ HB eâ‚‚
```

### 3.4 å†…å­˜å±éšœ

```mathematical
/* å†…å­˜å±éšœç±»å‹ */

MemoryBarrier ::= LoadLoad    /* è¯»-è¯»å±éšœ */
                | LoadStore   /* è¯»-å†™å±éšœ */
                | StoreStore  /* å†™-å†™å±éšœ */
                | StoreLoad   /* å†™-è¯»å±éšœ */
                | FullFence   /* å®Œå…¨å±éšœ */

/* å±éšœè¯­ä¹‰ */

[Barrier-LoadLoad]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
load1; LoadLoad; load2
â‡’ load1 must complete before load2 starts

[Barrier-StoreStore]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
store1; StoreStore; store2
â‡’ store1 must be visible before store2

[Barrier-StoreLoad]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
store; StoreLoad; load
â‡’ store must complete before load starts

/* Goä¸­çš„éšå¼å±éšœ */

1. Channelæ“ä½œ: åŒ…å«å®Œå…¨å±éšœ
2. Mutex Lock/Unlock: åŒ…å«è·å–/é‡Šæ”¾å±éšœ
3. sync/atomicæ“ä½œ: æ ¹æ®å†…å­˜é¡ºåºæ’å…¥ç›¸åº”å±éšœ

/* ç¤ºä¾‹: æ— é”æ¶ˆæ¯ä¼ é€’ */

// Goroutine 1
message = "hello"              // (1)
atomic.Store(&flag, true)     // (2) release

// Goroutine 2
if atomic.Load(&flag) {       // (3) acquire
    print(message)            // (4)
}

/* Happens-Beforeåˆ†æ */
(1) HB (2) by program order
(2) HB (3) by atomic release-acquire
(3) HB (4) by program order
å› æ­¤ (1) HB (4), messageçš„å†™å¯¹printå¯è§
```

---

## ç¬¬å››éƒ¨åˆ†: æ•°æ®ç«äº‰æ£€æµ‹

### 4.1 æ•°æ®ç«äº‰å½¢å¼åŒ–å®šä¹‰

```mathematical
/* æ•°æ®ç«äº‰å®šä¹‰ */

DataRace(eâ‚, eâ‚‚) âŸº
    eâ‚ âˆ¥ eâ‚‚ âˆ§                              /* å¹¶å‘ */
    same_memory_location(eâ‚, eâ‚‚) âˆ§         /* è®¿é—®åŒä¸€åœ°å€ */
    (is_write(eâ‚) âˆ¨ is_write(eâ‚‚)) âˆ§        /* è‡³å°‘ä¸€ä¸ªå†™ */
    Â¬synchronized(eâ‚, eâ‚‚)                   /* æ— åŒæ­¥ */

/* æ— æ•°æ®ç«äº‰ç¨‹åº (DRF) */

DRF(Program) âŸº
    âˆ€ execution âˆˆ Executions(Program).
    âˆ€ eâ‚, eâ‚‚ âˆˆ Events(execution).
    Â¬DataRace(eâ‚, eâ‚‚)

/* DRF-SCå®šç† (Data Race Free - Sequential Consistency) */

å®šç† (DRF-SC):
å¦‚æœç¨‹åºæ˜¯DRFçš„,åˆ™å®ƒçš„æ‰€æœ‰æ‰§è¡Œéƒ½æ˜¯é¡ºåºä¸€è‡´çš„ã€‚

å½¢å¼åŒ–:
DRF(P) â‡’ âˆ€ exec âˆˆ Executions(P). SeqCst(exec)

è¯æ˜:
æ— æ•°æ®ç«äº‰ â‡’ æ‰€æœ‰å†…å­˜æ“ä½œéƒ½é€šè¿‡åŒæ­¥åŸè¯­ â‡’
åŒæ­¥åŸè¯­ä¿è¯happens-before â‡’ é¡ºåºä¸€è‡´æ€§ â–¡
```

### 4.2 åŠ¨æ€ç«äº‰æ£€æµ‹ (Race Detector)

```mathematical
/* Go Race Detectorå®ç° */

/* åŸºäºThreadSanitizer */

/* Vector Clock for Goroutines */

VectorClock = GoroutineID â†’ Timestamp

VC(g) : GoroutineID â†’ Timestamp

/* Shadow Memory */

ShadowState = Address â†’ AccessHistory

AccessHistory = {
    read_epochs: Set[(GoroutineID, Timestamp)],
    write_epoch: (GoroutineID, Timestamp)?
}

/* Race Detection Algorithm */

function check_access(addr: Address, is_write: Boolean, g: GID):
    current_vc = VC(g)
    shadow = get_shadow(addr)

    if is_write:
        /* æ£€æŸ¥å†™-å†™ç«äº‰ */
        if shadow.write_epoch exists:
            (g', t') = shadow.write_epoch
            if g â‰  g' and not happens_before(t', current_vc[g']):
                report_race(addr, "write-write", g, g')

        /* æ£€æŸ¥å†™-è¯»ç«äº‰ */
        for (g', t') in shadow.read_epochs:
            if g â‰  g' and not happens_before(t', current_vc[g']):
                report_race(addr, "write-read", g, g')

        /* æ›´æ–°shadow */
        shadow.write_epoch = (g, current_vc[g])
        shadow.read_epochs = âˆ…

    else:  /* is_read */
        /* æ£€æŸ¥è¯»-å†™ç«äº‰ */
        if shadow.write_epoch exists:
            (g', t') = shadow.write_epoch
            if g â‰  g' and not happens_before(t', current_vc[g']):
                report_race(addr, "read-write", g, g')

        /* æ›´æ–°shadow */
        shadow.read_epochs.add((g, current_vc[g]))

/* åŒæ­¥æ“ä½œæ›´æ–°VC */

[VC-Send]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ch <- v, gâŸ© â†’
    VC(ch) := VC(g)
    VC(g)[g] += 1

[VC-Recv]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨v := <-ch, gâŸ© â†’
    VC(g) := max(VC(g), VC(ch))
    VC(g)[g] += 1

[VC-Lock]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨mu.Lock(), gâŸ© â†’
    VC(g) := max(VC(g), VC(mu))
    VC(g)[g] += 1

[VC-Unlock]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨mu.Unlock(), gâŸ© â†’
    VC(mu) := VC(g)
    VC(g)[g] += 1

/* Race Detectoræ€§èƒ½å¼€é”€ */

æ€§èƒ½å¼€é”€:
- å†…å­˜: 5-10x
- è¿è¡Œæ—¶é—´: 2-20x
- ä½†èƒ½æ£€æµ‹å¤§éƒ¨åˆ†ç«äº‰
```

### 4.3 é™æ€ç«äº‰æ£€æµ‹

```mathematical
/* é™æ€åˆ†ææ–¹æ³• */

/* ç±»å‹ç³»ç»Ÿæ–¹æ³•: çº¿æ€§ç±»å‹ */

LinearType Ï„ ::= int | bool | ...
               | Ï„â‚ -o Ï„â‚‚  /* çº¿æ€§å‡½æ•° */
               | !Ï„         /* å¯å¤åˆ¶ç±»å‹ */

/* çº¿æ€§ç±»å‹è§„åˆ™ */

[T-Linear-Var]
x:Ï„ in Î“, Ï„ is linear
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ x : Ï„
ä½¿ç”¨å x ä» Î“ ä¸­ç§»é™¤

[T-Linear-Func]
Î“, x:Ï„â‚ âŠ¢ e : Ï„â‚‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Î»x.e : Ï„â‚ -o Ï„â‚‚

/* æ‰€æœ‰æƒç±»å‹ç³»ç»Ÿ (Rust-style) */

Ownership ::= Owned(x)
            | Borrowed(&x)
            | MutBorrowed(&mut x)

/* å€Ÿç”¨è§„åˆ™ */
1. åŒæ—¶å¯ä»¥æœ‰å¤šä¸ªä¸å¯å˜å€Ÿç”¨
2. åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å€Ÿç”¨
3. å¯å˜å€Ÿç”¨æœŸé—´ä¸èƒ½æœ‰å…¶ä»–å€Ÿç”¨

/* Lockset Analysis */

function lockset_analysis(Program):
    /* è®¡ç®—æ¯ä¸ªå†…å­˜è®¿é—®æ—¶æŒæœ‰çš„é”é›†åˆ */
    locksets = {}

    for access in all_memory_accesses:
        locks = compute_held_locks(access)
        locksets[access] = locks

    /* æ£€æŸ¥æ•°æ®ç«äº‰ */
    for (a1, a2) in pairs(all_memory_accesses):
        if same_location(a1, a2) and (is_write(a1) or is_write(a2)):
            common_locks = locksets[a1] âˆ© locksets[a2]
            if common_locks is empty:
                report_potential_race(a1, a2)

/* Escape Analysis */

function escape_analysis(expr):
    /* åˆ†æå¯¹è±¡æ˜¯å¦é€ƒé€¸åˆ°å † */
    if expr escapes current function:
        allocate_on_heap(expr)
    else:
        allocate_on_stack(expr)

/* å¥½å¤„: æ ˆåˆ†é…çš„å¯¹è±¡ä¸éœ€è¦GC,ä¸”å¤©ç„¶çº¿ç¨‹å®‰å…¨ */
```

---

## ç¬¬äº”éƒ¨åˆ†: è¿è¡Œæ—¶ä¼˜åŒ–

### 5.1 å†…è”ä¼˜åŒ–

```mathematical
/* å†…è”å†³ç­– */

function should_inline(f: Function) -> Boolean:
    /* 1. æ£€æŸ¥å‡½æ•°å¤§å° */
    if size(f) > inline_threshold:
        return false

    /* 2. æ£€æŸ¥æ˜¯å¦é€’å½’ */
    if is_recursive(f):
        return false

    /* 3. æ£€æŸ¥è°ƒç”¨é¢‘ç‡ */
    if call_frequency(f) < frequency_threshold:
        return false

    /* 4. æ£€æŸ¥æ˜¯å¦åŒ…å«ä¸å¯å†…è”çš„ç‰¹æ€§ */
    if contains_defer(f) or contains_recover(f):
        return false

    return true

/* å†…è”è½¬æ¢ */

[Inline-Transform]
f(x) = e, should_inline(f), call_site: y = f(a)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
transform to: y = e[x := a]

/* å†…è”æ­£ç¡®æ€§ */

å®šç† (Inlining Correctness):
å†…è”åçš„ç¨‹åºä¸åŸç¨‹åºè¯­ä¹‰ç­‰ä»·ã€‚

è¯æ˜:
å†…è”åªæ˜¯å‡½æ•°è°ƒç”¨çš„Î²-å½’çº¦,
åœ¨Î»æ¼”ç®—ä¸­æ˜¯ç­‰ä»·å˜æ¢ã€‚ â–¡

/* å†…è”çš„æ”¶ç›Š */
1. æ¶ˆé™¤å‡½æ•°è°ƒç”¨å¼€é”€
2. å¯ç”¨æ›´å¤šä¼˜åŒ–æœºä¼š
3. å‡å°‘æ ˆå¸§åˆ†é…
```

### 5.2 é€ƒé€¸åˆ†æ

```mathematical
/* é€ƒé€¸åˆ†æç®—æ³• */

function escape_analysis(program):
    /* 1. å»ºç«‹æŒ‡é’ˆå›¾ */
    pointer_graph = build_pointer_graph(program)

    /* 2. æ ‡è®°é€ƒé€¸èŠ‚ç‚¹ */
    escaped = Set()

    for node in pointer_graph:
        if node.address_taken and node.stored_to_heap:
            mark_escaped(node, escaped)

        if node.returned_from_function:
            mark_escaped(node, escaped)

        if node.assigned_to_global:
            mark_escaped(node, escaped)

    /* 3. ä¼ æ’­é€ƒé€¸ä¿¡æ¯ */
    worklist = escaped
    while worklist is not empty:
        node = worklist.pop()
        for successor in pointer_graph[node]:
            if successor not in escaped:
                escaped.add(successor)
                worklist.add(successor)

    return escaped

/* é€ƒé€¸è§„åˆ™ */

[Escape-Return]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
return &x â‡’ x escapes

[Escape-Global]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
global = &x â‡’ x escapes

[Escape-Heap]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
heap_obj.field = &x â‡’ x escapes

[No-Escape-Local]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
func f() { x := 1; ... } â‡’ x does not escape

/* ç¤ºä¾‹ */

// ä¸é€ƒé€¸ - æ ˆåˆ†é…
func noEscape() {
    x := 42
    print(x)
}  // xåœ¨æ ˆä¸Š

// é€ƒé€¸ - å †åˆ†é…
func escape() *int {
    x := 42
    return &x  // xé€ƒé€¸åˆ°å †
}
```

### 5.3 è¾¹ç•Œæ£€æŸ¥æ¶ˆé™¤

```mathematical
/* è¾¹ç•Œæ£€æŸ¥æ¶ˆé™¤ (BCE) */

/* åŸå§‹ä»£ç  */
for i := 0; i < len(slice); i++ {
    sum += slice[i]  // éœ€è¦è¾¹ç•Œæ£€æŸ¥: i < len(slice)
}

/* ä¼˜åŒ–å */
n := len(slice)
for i := 0; i < n; i++ {
    sum += slice[i]  // è¾¹ç•Œæ£€æŸ¥å¯æ¶ˆé™¤: i < n = len(slice)
}

/* BCEåˆ†æ */

function eliminate_bounds_checks(loop):
    /* 1. è¯†åˆ«å½’çº³å˜é‡ */
    induction_vars = find_induction_variables(loop)

    /* 2. åˆ†æå¾ªç¯è¾¹ç•Œ */
    for iv in induction_vars:
        lower_bound = analyze_lower_bound(iv, loop)
        upper_bound = analyze_upper_bound(iv, loop)

        /* 3. æ£€æŸ¥æ•°ç»„è®¿é—® */
        for access in array_accesses(loop):
            if access.index == iv:
                if can_prove(lower_bound â‰¥ 0 and upper_bound â‰¤ len(array)):
                    eliminate_check(access)

/* BCEæ­£ç¡®æ€§ */

å®šç† (BCE Correctness):
å¦‚æœç¼–è¯‘å™¨æ¶ˆé™¤äº†è¾¹ç•Œæ£€æŸ¥,åˆ™è®¿é—®ä¸€å®šåœ¨ç•Œå†…ã€‚

è¯æ˜:
é€šè¿‡å½’çº³å˜é‡åˆ†æå’ŒåŒºé—´åˆ†æ,
ç¼–è¯‘å™¨åªåœ¨èƒ½è¯æ˜å®‰å…¨æ—¶æ‰æ¶ˆé™¤æ£€æŸ¥ã€‚ â–¡

/* Go 1.25.3å¢å¼ºçš„BCE */

1. æ›´æ™ºèƒ½çš„å½’çº³å˜é‡è¯†åˆ«
2. è·¨å‡½æ•°çš„èŒƒå›´åˆ†æ
3. å¯¹sliceçš„lenå’Œcapçš„æ›´ç²¾ç¡®æ¨ç†
```

---

## ğŸ¯ æ€»ç»“

### æ ¸å¿ƒè´¡çŒ®

1. **GMPè°ƒåº¦æ¨¡å‹å½¢å¼åŒ–**
   - å®Œæ•´çš„è°ƒåº¦å™¨å®šä¹‰
   - Work Stealingç®—æ³•è¯æ˜
   - æŠ¢å å¼è°ƒåº¦è¯­ä¹‰

2. **åƒåœ¾å›æ”¶ç†è®º**
   - ä¸‰è‰²æ ‡è®°ç®—æ³•
   - å¹¶å‘GCä¸å†™å±éšœ
   - GCæ­£ç¡®æ€§è¯æ˜

3. **ç²¾ç¡®çš„å†…å­˜æ¨¡å‹**
   - å®Œæ•´çš„Happens-Beforeå®šä¹‰
   - åŒæ­¥åŸè¯­è¯­ä¹‰
   - åŸå­æ“ä½œä¸å†…å­˜å±éšœ

4. **æ•°æ®ç«äº‰æ£€æµ‹**
   - å½¢å¼åŒ–å®šä¹‰
   - åŠ¨æ€æ£€æµ‹ç®—æ³•
   - é™æ€åˆ†ææ–¹æ³•

5. **è¿è¡Œæ—¶ä¼˜åŒ–**
   - å†…è”ã€é€ƒé€¸åˆ†æã€BCE
   - ä¼˜åŒ–æ­£ç¡®æ€§è¯æ˜

### ç†è®ºæ„ä¹‰

æœ¬æ–‡æ¡£å»ºç«‹äº†Goè¿è¡Œæ—¶å’Œå†…å­˜æ¨¡å‹çš„ä¸¥æ ¼æ•°å­¦åŸºç¡€,ä¸º:

1. è¿è¡Œæ—¶å®ç°æä¾›ç†è®ºæŒ‡å¯¼
2. å¹¶å‘ç¨‹åºæ­£ç¡®æ€§æä¾›éªŒè¯æ–¹æ³•
3. ç¼–è¯‘å™¨ä¼˜åŒ–æä¾›æ­£ç¡®æ€§ä¿è¯
4. æ€§èƒ½åˆ†ææä¾›ç†è®ºå·¥å…·

### å®è·µä»·å€¼

1. **è¿è¡Œæ—¶å¼€å‘**
   - è°ƒåº¦å™¨å®ç°å‚è€ƒ
   - GCç®—æ³•æ”¹è¿›
   - æ€§èƒ½ä¼˜åŒ–æŒ‡å¯¼

2. **å¹¶å‘ç¨‹åºéªŒè¯**
   - æ•°æ®ç«äº‰æ£€æµ‹
   - Happens-Beforeåˆ†æ
   - åŒæ­¥æ­£ç¡®æ€§éªŒè¯

3. **ç¼–è¯‘å™¨ä¼˜åŒ–**
   - å†…è”å†³ç­–
   - é€ƒé€¸åˆ†æ
   - è¾¹ç•Œæ£€æŸ¥æ¶ˆé™¤

4. **æ€§èƒ½è°ƒä¼˜**
   - GCè°ƒä¼˜æŒ‡å¯¼
   - è°ƒåº¦å™¨è°ƒä¼˜
   - å†…å­˜åˆ†é…ä¼˜åŒ–

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Formal Methods Research Group
**æœ€åæ›´æ–°**: 2025-10-29
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
