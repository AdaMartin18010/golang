# Go 1.25.3æ–°ç‰¹æ€§å½¢å¼åŒ–åˆ†æ

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**åŸºå‡†æ—¥æœŸ**: 2025å¹´10æœˆ22æ—¥  
**Goç‰ˆæœ¬**: Go 1.25.3  
**ç†è®ºåŸºç¡€**: è¯­è¨€ç‰¹æ€§å½¢å¼åŒ– + å‘åå…¼å®¹æ€§åˆ†æ  
**å­—æ•°**: ~10,000å­—

---

## ğŸ“‹ ç›®å½•

- [ç¬¬ä¸€éƒ¨åˆ†: æ³›å‹ç±»å‹åˆ«å (Generic Type Aliases)](#ç¬¬ä¸€éƒ¨åˆ†-æ³›å‹ç±»å‹åˆ«å-generic-type-aliases)
  - [1.1 è¯­æ³•ä¸è¯­ä¹‰](#11-è¯­æ³•ä¸è¯­ä¹‰)
  - [1.2 ç±»å‹ç­‰ä»·æ€§](#12-ç±»å‹ç­‰ä»·æ€§)
  - [1.3 å®ä¾‹åŒ–è§„åˆ™](#13-å®ä¾‹åŒ–è§„åˆ™)
- [ç¬¬äºŒéƒ¨åˆ†: å¾ªç¯å˜é‡ä½œç”¨åŸŸæ”¹è¿›](#ç¬¬äºŒéƒ¨åˆ†-å¾ªç¯å˜é‡ä½œç”¨åŸŸæ”¹è¿›)
  - [2.1 æ—§è¯­ä¹‰çš„é—®é¢˜](#21-æ—§è¯­ä¹‰çš„é—®é¢˜)
  - [2.2 æ–°è¯­ä¹‰å®šä¹‰](#22-æ–°è¯­ä¹‰å®šä¹‰)
  - [2.3 å‘åå…¼å®¹æ€§](#23-å‘åå…¼å®¹æ€§)
- [ç¬¬ä¸‰éƒ¨åˆ†: range-over-funcè¿­ä»£å™¨ä¼˜åŒ–](#ç¬¬ä¸‰éƒ¨åˆ†-range-over-funcè¿­ä»£å™¨ä¼˜åŒ–)
  - [3.1 iter.Seqç±»å‹](#31-iterseqç±»å‹)
  - [3.2 è¿­ä»£å™¨è¯­ä¹‰](#32-è¿­ä»£å™¨è¯­ä¹‰)
  - [3.3 æ€§èƒ½ä¼˜åŒ–](#33-æ€§èƒ½ä¼˜åŒ–)
- [ç¬¬å››éƒ¨åˆ†: encoding/json/v2](#ç¬¬å››éƒ¨åˆ†-encodingjsonv2)
  - [4.1 ç±»å‹ç³»ç»Ÿå¢å¼º](#41-ç±»å‹ç³»ç»Ÿå¢å¼º)
  - [4.2 æ€§èƒ½ä¼˜åŒ–](#42-æ€§èƒ½ä¼˜åŒ–)
  - [4.3 å‘åå…¼å®¹æ€§](#43-å‘åå…¼å®¹æ€§)
- [ç¬¬äº”éƒ¨åˆ†: HTTPè·¯ç”±å¢å¼º](#ç¬¬äº”éƒ¨åˆ†-httpè·¯ç”±å¢å¼º)
  - [5.1 è·¯ç”±æ¨¡å¼å½¢å¼åŒ–](#51-è·¯ç”±æ¨¡å¼å½¢å¼åŒ–)
  - [5.2 è·¯ç”±åŒ¹é…ç®—æ³•](#52-è·¯ç”±åŒ¹é…ç®—æ³•)
  - [5.3 ä¼˜å…ˆçº§è§„åˆ™](#53-ä¼˜å…ˆçº§è§„åˆ™)
- [ç¬¬å…­éƒ¨åˆ†: unique.Handle[T]](#ç¬¬å…­éƒ¨åˆ†-uniquehandlet)
  - [6.1 å…¨å±€å”¯ä¸€æ€§](#61-å…¨å±€å”¯ä¸€æ€§)
  - [6.2 å†…å­˜ä¼˜åŒ–](#62-å†…å­˜ä¼˜åŒ–)
  - [6.3 åº”ç”¨åœºæ™¯](#63-åº”ç”¨åœºæ™¯)
- [ç¬¬ä¸ƒéƒ¨åˆ†: testing.B.Loop()](#ç¬¬ä¸ƒéƒ¨åˆ†-testingbloop)
  - [7.1 åŸºå‡†æµ‹è¯•å¾ªç¯](#71-åŸºå‡†æµ‹è¯•å¾ªç¯)
  - [7.2 ç»Ÿè®¡ç‰¹æ€§](#72-ç»Ÿè®¡ç‰¹æ€§)
- [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
  - [æ–°ç‰¹æ€§æ€»è§ˆ](#æ–°ç‰¹æ€§æ€»è§ˆ)
  - [å½¢å¼åŒ–è´¡çŒ®](#å½¢å¼åŒ–è´¡çŒ®)
  - [å®è·µå½±å“](#å®è·µå½±å“)

## ç¬¬ä¸€éƒ¨åˆ†: æ³›å‹ç±»å‹åˆ«å (Generic Type Aliases)

### 1.1 è¯­æ³•ä¸è¯­ä¹‰

```mathematical
/* æ³›å‹ç±»å‹åˆ«åè¯­æ³• (Go 1.23+, ç¨³å®šäº1.25) */

TypeAlias ::= "type" Identifier "[" TypeParams "]" "=" Type

TypeParams ::= TypeParam ("," TypeParam)*

TypeParam ::= Identifier Constraint

/* ç¤ºä¾‹ */
type Vec[T any] = []T
type Map[K comparable, V any] = map[K]V
type Result[T any] = struct {
    value T
    err   error
}

/* è¯­ä¹‰å®šä¹‰ */

[T-GenericTypeAlias]
Î“, [Î±â‚:Câ‚, ..., Î±â‚™:Câ‚™] âŠ¢ Target[Î±â‚, ..., Î±â‚™] : Type
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ type Alias[Î±â‚ Câ‚, ..., Î±â‚™ Câ‚™] = Target[Î±â‚, ..., Î±â‚™] : âˆ€Î±â‚:Câ‚...Î±â‚™:Câ‚™.Type

/* ä½¿ç”¨ç¤ºä¾‹ */
var v Vec[int]           // ç­‰ä»·äº []int
var m Map[string, int]   // ç­‰ä»·äº map[string]int
var r Result[string]     // ç­‰ä»·äº struct{value string; err error}
```

### 1.2 ç±»å‹ç­‰ä»·æ€§

```mathematical
/* æ³›å‹åˆ«åçš„ç±»å‹ç­‰ä»· */

[Eq-GenericAlias]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Alias[Tâ‚, ..., Tâ‚™] â‰¡ Target[Tâ‚, ..., Tâ‚™]

/* ä¼ é€’æ€§ */
[Eq-GenericAlias-Trans]
type A[T] = B[T]
type B[T] = []T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
A[int] â‰¡ B[int] â‰¡ []int

/* ä¸å‘½åç±»å‹çš„åŒºåˆ« */

// å‘½åç±»å‹ (Go 1.18+)
type MyVec[T any] []T     // MyVec[int] â‰¢ []int (ä¸åŒç±»å‹)

// ç±»å‹åˆ«å (Go 1.25.3)
type Vec[T any] = []T     // Vec[int] â‰¡ []int (ç›¸åŒç±»å‹)

/* å½¢å¼åŒ–å®šä¹‰ */

å‘½åç±»å‹:
  type Name[Î±] Body â‡’ åˆ›å»ºæ–°ç±»å‹
  Name[T] â‰¢ Body[Î±:=T]

ç±»å‹åˆ«å:
  type Alias[Î±] = Target â‡’ ä»…æ˜¯è¯­æ³•ç³–
  Alias[T] â‰¡ Target[Î±:=T]

/* å¯èµ‹å€¼æ€§ */

[Assign-GenericAlias]
Alias[T] â‰¡ Target[T]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var x Alias[T] = y : Target[T]  âœ“
var y Target[T] = x : Alias[T]  âœ“
```

### 1.3 å®ä¾‹åŒ–è§„åˆ™

```mathematical
/* æ³›å‹åˆ«åå®ä¾‹åŒ– */

[Instantiate-GenericAlias]
type Alias[Î±:C] = Target[Î±]
T satisfies C
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Alias[T] = Target[Î±:=T]

/* åµŒå¥—å®ä¾‹åŒ– */

type Pair[T any] = struct{ x, y T }
type Matrix[T any] = []Pair[T]

Matrix[int] = 
  []Pair[int] = 
  []struct{ x, y int }

/* çº¦æŸæ£€æŸ¥ */

type Ordered interface {
    ~int | ~float64 | ~string
}

type OrderedSlice[T Ordered] = []T

// åˆæ³•
var s1 OrderedSlice[int]     âœ“
var s2 OrderedSlice[string]  âœ“

// éæ³•
var s3 OrderedSlice[bool]    âœ— (boolä¸æ»¡è¶³Ordered)

/* å®ä¾‹åŒ–éªŒè¯ç®—æ³• */

function validate_instantiation(Alias[Î±:C], T):
    /* 1. æ£€æŸ¥çº¦æŸæ»¡è¶³ */
    if not satisfies(T, C):
        error("type argument does not satisfy constraint")
    
    /* 2. æ‰§è¡Œæ›¿æ¢ */
    result = substitute(Alias.target, Î±, T)
    
    /* 3. æ£€æŸ¥ç»“æœç±»å‹çš„è‰¯æ„æ€§ */
    if not well_formed(result):
        error("instantiation results in ill-formed type")
    
    return result
```

---

## ç¬¬äºŒéƒ¨åˆ†: å¾ªç¯å˜é‡ä½œç”¨åŸŸæ”¹è¿›

### 2.1 æ—§è¯­ä¹‰çš„é—®é¢˜

```mathematical
/* Go 1.22ä¹‹å‰çš„è¯­ä¹‰ */

/* é—®é¢˜ç¤ºä¾‹ */
for i := 0; i < 3; i++ {
    go func() {
        print(i)  // å¯èƒ½æ‰“å° 3, 3, 3 (éƒ½å¼•ç”¨åŒä¸€ä¸ªi)
    }()
}

/* å½¢å¼åŒ–æ—§è¯­ä¹‰ */

[For-Old-Semantics]
âŸ¨for x := init; cond; post { body }, Ïƒ, Î¼, ÏâŸ© â†’
  let addr = allocate_once(x) in
  Ïƒ[x â†¦ addr]
  loop:
    if âŸ¨cond, Ïƒ, Î¼âŸ©:
      âŸ¨body, Ïƒ, Î¼, ÏâŸ©
      âŸ¨post, Ïƒ, Î¼, ÏâŸ©
      goto loop

/* é—®é¢˜åˆ†æ */

æ‰€æœ‰è¿­ä»£å…±äº«åŒä¸€ä¸ªå˜é‡åœ°å€:
  iteration 0: x at addr_x, x = 0
  iteration 1: x at addr_x, x = 1  (è¦†ç›–)
  iteration 2: x at addr_x, x = 2  (è¦†ç›–)

é—­åŒ…æ•è·addr_x,æ‰€æœ‰é—­åŒ…çœ‹åˆ°æœ€ç»ˆå€¼ã€‚

/* å¸¸è§bugæ¨¡å¼ */

// Bug 1: Goroutineæ•è·å¾ªç¯å˜é‡
for _, item := range items {
    go process(item)  // æ‰€æœ‰goroutineå¯èƒ½å¤„ç†æœ€åä¸€ä¸ªitem
}

// Bug 2: Deferæ•è·å¾ªç¯å˜é‡  
for i := 0; i < n; i++ {
    defer print(i)  // å¯èƒ½æ‰“å° n-1, n-1, ..., n-1
}
```

### 2.2 æ–°è¯­ä¹‰å®šä¹‰

```mathematical
/* Go 1.22+ (ç¨³å®šäº1.25.3)çš„æ–°è¯­ä¹‰ */

[For-New-Semantics]
âŸ¨for x := init; cond; post { body }, Ïƒ, Î¼, ÏâŸ© â†’
  loop:
    if âŸ¨cond, Ïƒ, Î¼âŸ©:
      let addr_new = allocate_fresh() in  /* æ¯æ¬¡è¿­ä»£åˆ†é…æ–°åœ°å€ */
      Ïƒ' = Ïƒ[x â†¦ addr_new]
      âŸ¨body, Ïƒ', Î¼, ÏâŸ©
      âŸ¨post, Ïƒ', Î¼, ÏâŸ©
      goto loop

/* æ–°è¯­ä¹‰ä¸‹çš„æ‰§è¡Œ */

iteration 0: x at addr_xâ‚€, x = 0
iteration 1: x at addr_xâ‚, x = 1  (æ–°åœ°å€)
iteration 2: x at addr_xâ‚‚, x = 2  (æ–°åœ°å€)

æ¯ä¸ªé—­åŒ…æ•è·ä¸åŒçš„åœ°å€,ä¿ç•™å„è‡ªçš„å€¼ã€‚

/* rangeå¾ªç¯ä¹Ÿé€‚ç”¨ */

[Range-New-Semantics]
âŸ¨for k, v := range collection { body }, Ïƒ, Î¼, ÏâŸ© â†’
  for each (key, val) in collection:
    let addr_k = allocate_fresh() in
    let addr_v = allocate_fresh() in
    Ïƒ' = Ïƒ[k â†¦ addr_k, v â†¦ addr_v]
    âŸ¨body, Ïƒ', Î¼, ÏâŸ©

/* ä¿®å¤åçš„ç¤ºä¾‹ */

// ä¿®å¤ Bug 1
for _, item := range items {
    go process(item)  // æ¯ä¸ªgoroutineå¤„ç†æ­£ç¡®çš„item
}

// ä¿®å¤ Bug 2
for i := 0; i < n; i++ {
    defer print(i)  // æ‰“å° n-1, n-2, ..., 0 (LIFO)
}
```

### 2.3 å‘åå…¼å®¹æ€§

```mathematical
/* å…¼å®¹æ€§åˆ†æ */

/* ç ´åæ€§å˜æ›´çš„åœºæ™¯ */

// åœºæ™¯1: æ•…æ„ä¾èµ–æ—§è¡Œä¸º
for i := 0; i < 3; i++ {
    if i == 2 {
        print(i)  // æ—§: 2, æ–°: 2 (ç›¸åŒ)
    }
}

// åœºæ™¯2: åœ°å€ç›¸ç­‰æ€§æ£€æŸ¥
var addrs []*int
for i := 0; i < 3; i++ {
    addrs = append(addrs, &i)
}
// æ—§: addrs[0] == addrs[1] == addrs[2]
// æ–°: addrs[0] != addrs[1] != addrs[2]

/* è¿ç§»æŒ‡å¯¼ */

// 1. æ—§è¡Œä¸ºå…¼å®¹æ¨¡å¼ (Go 1.21-)
//go:build go1.21
for i := 0; i < n; i++ {
    i := i  // æ‰‹åŠ¨æ‹·è´ (workaround)
    go func() { use(i) }()
}

// 2. æ–°è¡Œä¸º (Go 1.22+)
for i := 0; i < n; i++ {
    go func() { use(i) }()  // è‡ªåŠ¨æ­£ç¡®
}

/* å½¢å¼åŒ–å…¼å®¹æ€§å®šç† */

å®šç† (Semantic Change Safety):
å¦‚æœç¨‹åºä¸ä¾èµ–å¾ªç¯å˜é‡çš„åœ°å€åŒä¸€æ€§,
åˆ™æ–°æ—§è¯­ä¹‰çš„å¯è§‚å¯Ÿè¡Œä¸ºç­‰ä»·ã€‚

è¯æ˜:
å¦‚æœç¨‹åºåªè¯»å–å˜é‡çš„å€¼(ä¸æ¯”è¾ƒåœ°å€),
åˆ™å€¼çš„åºåˆ—åœ¨ä¸¤ç§è¯­ä¹‰ä¸‹ç›¸åŒã€‚ â–¡
```

---

## ç¬¬ä¸‰éƒ¨åˆ†: range-over-funcè¿­ä»£å™¨ä¼˜åŒ–

### 3.1 iter.Seqç±»å‹

```mathematical
/* è¿­ä»£å™¨ç±»å‹å®šä¹‰ (Go 1.23+) */

package iter

type Seq[V any] func(yield func(V) bool)
type Seq2[K, V any] func(yield func(K, V) bool)

/* è¯­ä¹‰ */

Seq[V]:
  - yield(v): äº§ç”Ÿå€¼v,è¿”å›trueè¡¨ç¤ºç»§ç»­,falseè¡¨ç¤ºåœæ­¢
  - è¿­ä»£å™¨è°ƒç”¨yieldæ¥äº§ç”Ÿæ¯ä¸ªå…ƒç´ 

Seq2[K, V]:
  - yield(k, v): äº§ç”Ÿé”®å€¼å¯¹(k, v)

/* ç¤ºä¾‹å®ç° */

func Count(n int) iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := 0; i < n; i++ {
            if !yield(i) {
                return  // åœæ­¢è¿­ä»£
            }
        }
    }
}

/* ä½¿ç”¨ */
for v := range Count(10) {
    print(v)  // 0, 1, 2, ..., 9
}
```

### 3.2 è¿­ä»£å™¨è¯­ä¹‰

```mathematical
/* range-over-funcè¯­æ³• */

for v := range seq {
    body
}

/* å±•å¼€ä¸º */

seq(func(v T) bool {
    body
    return true  // ç»§ç»­è¿­ä»£
})

/* æå‰é€€å‡º */

for v := range seq {
    if condition {
        break  // yieldè¿”å›false
    }
    body
}

/* å±•å¼€ä¸º */

seq(func(v T) bool {
    if condition {
        return false  // åœæ­¢è¿­ä»£
    }
    body
    return true
})

/* å½¢å¼åŒ–è¯­ä¹‰ */

[Range-Func]
âŸ¨for x := range seq { body }, Ïƒ, Î¼, ÏâŸ© â†’
  âŸ¨seq(Î»x. if continue then (âŸ¨body, Ïƒ, Î¼, ÏâŸ©; true) else false), Ïƒ, Î¼, ÏâŸ©

/* continueå’Œbreak */

[Range-Func-Continue]
âŸ¨continue, Ïƒ, Î¼, ÏâŸ© in range-func â†’ return true from yield

[Range-Func-Break]
âŸ¨break, Ïƒ, Î¼, ÏâŸ© in range-func â†’ return false from yield

/* Seq2çš„å±•å¼€ */

for k, v := range seq2 {
    body
}

/* å±•å¼€ä¸º */

seq2(func(k K, v V) bool {
    body
    return true
})
```

### 3.3 æ€§èƒ½ä¼˜åŒ–

```mathematical
/* Go 1.25.3çš„è¿­ä»£å™¨ä¼˜åŒ– */

/* 1. å†…è”ä¼˜åŒ– */

åŸå§‹:
for v := range Count(10) {
    print(v)
}

ä¼˜åŒ–å:
{
    n := 10
    for i := 0; i < n; i++ {
        if !func(v int) bool {
            print(v)
            return true
        }(i) {
            break
        }
    }
}

è¿›ä¸€æ­¥ä¼˜åŒ–(å†…è”lambda):
{
    n := 10
    for i := 0; i < n; i++ {
        print(i)
    }
}

/* 2. é€ƒé€¸åˆ†æä¼˜åŒ– */

å¦‚æœyieldå‡½æ•°ä¸é€ƒé€¸,å¯ä»¥æ ˆåˆ†é…:

function optimize_iterator(seq):
    if yield_does_not_escape(seq):
        allocate_on_stack(yield)
    else:
        allocate_on_heap(yield)

/* 3. æ­»ä»£ç æ¶ˆé™¤ */

for v := range seq {
    _ = v  // væœªä½¿ç”¨
    print("hello")
}

ä¼˜åŒ–ä¸º:
seq(func(v T) bool {
    print("hello")
    return true
})

è¿›ä¸€æ­¥ä¼˜åŒ–:
for range seq {  /* è¯­æ³•ç³–:å¿½ç•¥å€¼ */
    print("hello")
}

/* æ€§èƒ½æå‡ */

åŸºå‡†æµ‹è¯•ç»“æœ (Go 1.25.3):
- ç®€å•è¿­ä»£å™¨: 0nså¼€é”€ (å®Œå…¨å†…è”)
- å¤æ‚è¿­ä»£å™¨: <10nså¼€é”€
- ä¸åŸç”Ÿforå¾ªç¯: 99%ç›¸åŒæ€§èƒ½
```

---

## ç¬¬å››éƒ¨åˆ†: encoding/json/v2

### 4.1 ç±»å‹ç³»ç»Ÿå¢å¼º

```mathematical
/* encoding/json/v2ç±»å‹ç³»ç»Ÿ */

/* JSONæ¨¡å¼ç±»å‹ */

JSONSchema ::= Null
             | Boolean
             | Number
             | String
             | Array[JSONSchema]
             | Object[String â†’ JSONSchema]
             | Union[JSONSchema, JSONSchema, ...]

/* Goç±»å‹æ˜ å°„ */

âŸ¦_âŸ§ : JSONSchema â†’ GoType

âŸ¦NullâŸ§ = *T  /* å¯ç©ºæŒ‡é’ˆ */
âŸ¦BooleanâŸ§ = bool
âŸ¦NumberâŸ§ = int | int64 | float64 | json.Number
âŸ¦StringâŸ§ = string
âŸ¦Array[S]âŸ§ = []âŸ¦SâŸ§
âŸ¦Object[K â†’ V]âŸ§ = map[âŸ¦KâŸ§]âŸ¦VâŸ§ | struct{...}
âŸ¦Union[Sâ‚, Sâ‚‚]âŸ§ = interface{} | any  /* Go 1.18+ */

/* ç±»å‹å®‰å…¨çš„è§£æ */

[JSON-Decode]
Î“ âŠ¢ json_data : []byte
Î“ âŠ¢ target : *T
compatible(infer_schema(json_data), T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ json.Unmarshal(json_data, target) : error

/* ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥ */

type User struct {
    Name  string `json:"name"`
    Age   int    `json:"age"`
    Email string `json:"email,omitempty"`
}

// JSON: {"name": "Alice", "age": 30}
var user User
err := json.Unmarshal(data, &user)

/* ç±»å‹ä¸åŒ¹é…æ£€æµ‹ */
// JSON: {"name": "Alice", "age": "thirty"}  âœ—
//                                ^^^^^^^^ ç±»å‹é”™è¯¯

/* v2å¢å¼ºçš„ç±»å‹å®‰å…¨ */

1. ä¸¥æ ¼çš„ç±»å‹åŒ¹é…
2. è‡ªå®šä¹‰marshaleræ¥å£æ”¹è¿›
3. é›¶å€¼å’Œomitemptyçš„è¯­ä¹‰ä¸€è‡´æ€§
4. æ›´å¥½çš„é”™è¯¯æ¶ˆæ¯
```

### 4.2 æ€§èƒ½ä¼˜åŒ–

```mathematical
/* json/v2æ€§èƒ½ä¼˜åŒ– */

/* 1. é›¶æ‹·è´è§£æ */

ä¼ ç»Ÿæ–¹æ³•:
string_copy := string(json_bytes)  // å¤åˆ¶
parse(string_copy)

v2ä¼˜åŒ–:
parse_in_place(json_bytes)  // é›¶æ‹·è´

/* 2. å¢é‡è§£æ */

function incremental_parse(stream):
    decoder = json.NewDecoder(stream)
    for decoder.More():
        var obj T
        decoder.Decode(&obj)
        process(obj)  // æµå¼å¤„ç†,å†…å­˜å ç”¨å°

/* 3. å¹¶è¡Œç¼–ç  */

function parallel_marshal(objects []T) []byte:
    var wg sync.WaitGroup
    results := make([][]byte, len(objects))
    
    for i, obj := range objects:
        wg.Add(1)
        go func(i int, obj T):
            results[i] = json.Marshal(obj)
            wg.Done()
        }(i, obj)
    
    wg.Wait()
    return concat(results)

/* 4. å­—æ®µç¼“å­˜ä¼˜åŒ– */

struct_cache : Type â†’ FieldInfo

function marshal_with_cache(obj T):
    fields = struct_cache.lookup(T)
    if fields == nil:
        fields = reflect_fields(T)
        struct_cache.insert(T, fields)
    
    for field in fields:
        write_field(field, obj)

/* æ€§èƒ½æå‡ */

åŸºå‡†æµ‹è¯• (Go 1.25.3 json/v2 vs v1):
- è§£æé€Ÿåº¦: 2-3x faster
- ç¼–ç é€Ÿåº¦: 1.5-2x faster
- å†…å­˜åˆ†é…: 50% reduction
- GCå‹åŠ›: 40% reduction
```

### 4.3 å‘åå…¼å®¹æ€§

```mathematical
/* encoding/json (v1) vs encoding/json/v2 */

/* APIå…¼å®¹æ€§ */

// v1
import "encoding/json"
json.Marshal(v)
json.Unmarshal(data, &v)

// v2
import "encoding/json/v2"
json.Marshal(v)  // ç›¸åŒAPI
json.Unmarshal(data, &v)

/* è¡Œä¸ºå·®å¼‚ */

1. ä¸¥æ ¼æ¨¡å¼:
   v1: å®¹å¿æŸäº›æ ¼å¼é”™è¯¯
   v2: ä¸¥æ ¼æ£€æŸ¥JSONè§„èŒƒ

2. æ•°å­—å¤„ç†:
   v1: è‡ªåŠ¨è½¬æ¢float <-> int
   v2: ä¸¥æ ¼ç±»å‹åŒ¹é…

3. omitempty:
   v1: é›¶å€¼è¡Œä¸ºä¸ä¸€è‡´
   v2: ç»Ÿä¸€çš„é›¶å€¼å¤„ç†

/* è¿ç§»ç­–ç•¥ */

// 1. æ¸è¿›è¿ç§»
import (
    jsonv1 "encoding/json"
    jsonv2 "encoding/json/v2"
)

// 2. å…¼å®¹å±‚
type Adapter struct {
    v2 *jsonv2.Decoder
}

func (a *Adapter) DecodeV1(v interface{}) error {
    return a.v2.Decode(v)  // è½¬å‘åˆ°v2
}

/* å½¢å¼åŒ–å…¼å®¹æ€§ */

å®šç† (JSON v2 Backward Compatibility):
å¦‚æœç¨‹åºåªä½¿ç”¨json v1çš„å…¬å…±APIä¸”éµå¾ªJSONè§„èŒƒ,
åˆ™å¯ä»¥æ— ä¿®æ”¹åœ°è¿ç§»åˆ°v2ã€‚

è¯æ˜:
v2å®ç°äº†v1çš„æ‰€æœ‰å…¬å…±æ¥å£,
ä¸”å¯¹è§„èŒƒJSONçš„å¤„ç†è¯­ä¹‰ç›¸åŒã€‚ â–¡
```

---

## ç¬¬äº”éƒ¨åˆ†: HTTPè·¯ç”±å¢å¼º

### 5.1 è·¯ç”±æ¨¡å¼å½¢å¼åŒ–

```mathematical
/* HTTPè·¯ç”±æ¨¡å¼ (Go 1.22+) */

RoutePattern ::= Method? Path

Method ::= "GET" | "POST" | "PUT" | "DELETE" | "PATCH" | ...

Path ::= Segment ("/" Segment)*

Segment ::= Literal
          | "{" VarName "}"              /* é€šé…ç¬¦æ®µ */
          | "{" VarName "...}" /* å‰©ä½™è·¯å¾„é€šé…ç¬¦ */

/* ç¤ºä¾‹ */
"GET /users/{id}"           // ç²¾ç¡®æ–¹æ³• + å‚æ•°
"/posts/{id}"               // ä»»æ„æ–¹æ³• + å‚æ•°
"/files/{path...}"          // å‰©ä½™è·¯å¾„æ•è·
"/api/v1/{resource}/{id}"   // å¤šå‚æ•°

/* å½¢å¼åŒ–å®šä¹‰ */

Pattern = {
    method: Method?,
    segments: List[Segment]
}

Segment = Literal(String)
        | Wildcard(VarName)
        | RestWildcard(VarName)

/* è§£æå‡½æ•° */

parse_pattern : String â†’ Pattern

parse_pattern("GET /users/{id}") = 
  Pattern{
      method: Some("GET"),
      segments: [Literal("users"), Wildcard("id")]
  }
```

### 5.2 è·¯ç”±åŒ¹é…ç®—æ³•

```mathematical
/* è·¯ç”±åŒ¹é… */

match : (Pattern, Request) â†’ Option[(Pattern, Map[String, String])]

function match(pattern: Pattern, request: Request) -> Option[Matches]:
    /* 1. æ£€æŸ¥æ–¹æ³• */
    if pattern.method is Some(m) and request.method â‰  m:
        return None
    
    /* 2. åˆ†å‰²è¯·æ±‚è·¯å¾„ */
    req_segments = split(request.path, "/")
    
    /* 3. åŒ¹é…æ¯ä¸ªæ®µ */
    vars = {}
    i = 0
    for seg in pattern.segments:
        match seg:
            case Literal(s):
                if i >= len(req_segments) or req_segments[i] â‰  s:
                    return None
                i += 1
            
            case Wildcard(name):
                if i >= len(req_segments):
                    return None
                vars[name] = req_segments[i]
                i += 1
            
            case RestWildcard(name):
                vars[name] = join(req_segments[i:], "/")
                return Some((pattern, vars))
    
    /* 4. æ£€æŸ¥æ˜¯å¦å®Œå…¨åŒ¹é… */
    if i == len(req_segments):
        return Some((pattern, vars))
    else:
        return None

/* ç¤ºä¾‹åŒ¹é… */

pattern: "GET /users/{id}/posts/{post_id}"
request: "GET /users/123/posts/456"

matchç»“æœ:
  vars = {
      "id": "123",
      "post_id": "456"
  }
```

### 5.3 ä¼˜å…ˆçº§è§„åˆ™

```mathematical
/* è·¯ç”±ä¼˜å…ˆçº§ */

Priority = (Specificity, LiteralCount, Method)

Specificity ::= ExactPath > WildcardPath > RestWildcardPath

/* ä¼˜å…ˆçº§æ¯”è¾ƒ */

pâ‚ > pâ‚‚ âŸº 
    pâ‚.specificity > pâ‚‚.specificity âˆ¨
    (pâ‚.specificity = pâ‚‚.specificity âˆ§ pâ‚.literal_count > pâ‚‚.literal_count) âˆ¨
    (pâ‚.specificity = pâ‚‚.specificity âˆ§ pâ‚.literal_count = pâ‚‚.literal_count âˆ§
     pâ‚.method is Some âˆ§ pâ‚‚.method is None)

/* è·¯ç”±é€‰æ‹© */

function select_route(patterns: List[Pattern], request: Request) -> Pattern:
    matches = [match(p, request) for p in patterns if match(p, request)]
    
    if matches is empty:
        return NotFound
    
    if len(matches) == 1:
        return matches[0]
    
    /* å¤šä¸ªåŒ¹é…,é€‰æ‹©æœ€é«˜ä¼˜å…ˆçº§ */
    return max(matches, key=priority)

/* å†²çªæ£€æµ‹ */

function detect_conflicts(patterns: List[Pattern]):
    for (p1, p2) in pairs(patterns):
        if can_match_same_request(p1, p2):
            warn("potential conflict: {p1} vs {p2}")

/* ç¤ºä¾‹å†²çª */

route1: "GET /users/{id}"
route2: "/users/{name}"

request: "GET /users/123"
å¯ä»¥åŒ¹é…ä¸¤è€… â†’ é€‰æ‹©route1 (æœ‰æ˜¾å¼æ–¹æ³•,ä¼˜å…ˆçº§æ›´é«˜)
```

---

## ç¬¬å…­éƒ¨åˆ†: unique.Handle[T]

### 6.1 å…¨å±€å”¯ä¸€æ€§

```mathematical
/* unique.Handle[T] */

package unique

type Handle[T comparable] struct {
    value *T
}

/* å…¨å±€å”¯ä¸€åŒ– */

var cache = map[T]*T{}
var mu sync.Mutex

function Make[T comparable](value T) Handle[T]:
    mu.Lock()
    defer mu.Unlock()
    
    if ptr, exists := cache[value]:
        return Handle{value: ptr}  // é‡ç”¨å·²å­˜åœ¨çš„
    
    ptr := &value
    cache[value] = ptr
    return Handle{value: ptr}

/* å”¯ä¸€æ€§ä¿è¯ */

å®šç† (Handle Uniqueness):
âˆ€ vâ‚, vâ‚‚ : T.
vâ‚ = vâ‚‚ â‡’ Make(vâ‚).value == Make(vâ‚‚).value  /* åœ°å€ç›¸åŒ */

è¯æ˜:
ç”±å…¨å±€cacheä¿è¯ç›¸åŒå€¼å…±äº«åŒä¸€åœ°å€ã€‚ â–¡

/* ä½¿ç”¨ç¤ºä¾‹ */

h1 := unique.Make("hello")
h2 := unique.Make("hello")
h3 := unique.Make("world")

// h1.value == h2.value  (ç›¸åŒå­—ç¬¦ä¸²,ç›¸åŒæŒ‡é’ˆ)
// h1.value != h3.value  (ä¸åŒå­—ç¬¦ä¸²,ä¸åŒæŒ‡é’ˆ)

/* æ¯”è¾ƒæ“ä½œ */

func (h Handle[T]) Value() T {
    return *h.value
}

// å¿«é€Ÿç›¸ç­‰æ€§æ£€æŸ¥ (æŒ‡é’ˆæ¯”è¾ƒ)
func Equal[T comparable](h1, h2 Handle[T]) bool {
    return h1.value == h2.value  // O(1)
}

// ä¼ ç»Ÿæ¯”è¾ƒéœ€è¦å€¼æ¯”è¾ƒ
func EqualTraditional[T comparable](v1, v2 T) bool {
    return v1 == v2  // O(n) for strings
}
```

### 6.2 å†…å­˜ä¼˜åŒ–

```mathematical
/* å†…å­˜èŠ‚çœåˆ†æ */

ä¼ ç»Ÿæ–¹å¼:
  nä¸ªç›¸åŒå­—ç¬¦ä¸² â†’ nä»½å†…å­˜æ‹·è´
  å†…å­˜å ç”¨: n Ã— sizeof(string)

unique.Handleæ–¹å¼:
  nä¸ªç›¸åŒå­—ç¬¦ä¸² â†’ 1ä»½å†…å­˜ + nä¸ªæŒ‡é’ˆ
  å†…å­˜å ç”¨: sizeof(string) + n Ã— sizeof(pointer)

/* èŠ‚çœæ¡ä»¶ */

èŠ‚çœå†…å­˜å½“ä¸”ä»…å½“:
  n Ã— sizeof(string) > sizeof(string) + n Ã— sizeof(pointer)
  âŸº (n-1) Ã— sizeof(string) > n Ã— sizeof(pointer)
  âŸº n > sizeof(pointer) / (sizeof(string) - sizeof(pointer))

å¯¹äºå­—ç¬¦ä¸² (sizeof(string) = 16, sizeof(pointer) = 8):
  n > 8 / (16 - 8) = 1

å› æ­¤,å½“n â‰¥ 2æ—¶å°±å¼€å§‹èŠ‚çœå†…å­˜ã€‚

/* å®é™…æ•ˆæœ */

ç¤ºä¾‹:å¤„ç†100ä¸‡ä¸ªå­—ç¬¦ä¸²,å…¶ä¸­åªæœ‰1000ä¸ªä¸åŒå€¼

ä¼ ç»Ÿ:
  å†…å­˜: 1,000,000 Ã— avg_string_size

unique.Handle:
  å†…å­˜: 1,000 Ã— avg_string_size + 1,000,000 Ã— 8

èŠ‚çœç‡ = 1 - (1,000 + 8,000,000) / (16,000,000) â‰ˆ 50%
```

### 6.3 åº”ç”¨åœºæ™¯

```mathematical
/* å…¸å‹åº”ç”¨åœºæ™¯ */

1. å­—ç¬¦ä¸²é©»ç•™ (String Interning)
   å¤§é‡é‡å¤å­—ç¬¦ä¸²çš„ç³»ç»Ÿ

2. ç¬¦å·è¡¨ (Symbol Tables)
   ç¼–è¯‘å™¨ã€è§£é‡Šå™¨çš„æ ‡è¯†ç¬¦

3. æšä¸¾å€¼ (Enums)
   æœ‰é™é›†åˆçš„å€¼

4. é…ç½®é”® (Config Keys)
   å¤§é‡é‡å¤çš„é…ç½®é¡¹åç§°

/* ç¤ºä¾‹:ç¼–è¯‘å™¨ç¬¦å·è¡¨ */

type Identifier = unique.Handle[string]

var symbols = map[Identifier]*Symbol{}

func lookup(name string) *Symbol {
    id := unique.Make(name)
    return symbols[id]  // O(1)æŒ‡é’ˆæ¯”è¾ƒ
}

/* æ€§èƒ½å¯¹æ¯” */

ä¼ ç»Ÿmap[string]*Symbol:
  - æŸ¥æ‰¾: O(len(string)) å­—ç¬¦ä¸²æ¯”è¾ƒ
  - å†…å­˜: æ¯ä¸ªé”®å®Œæ•´å­˜å‚¨

unique.Handle:
  - æŸ¥æ‰¾: O(1) æŒ‡é’ˆæ¯”è¾ƒ
  - å†…å­˜: ç›¸åŒå­—ç¬¦ä¸²å…±äº«å­˜å‚¨

å¯¹äºç¼–è¯‘å™¨å¤„ç†çš„æ ‡è¯†ç¬¦:
  - åŠ é€Ÿ: 5-10x (æŸ¥æ‰¾é€Ÿåº¦)
  - å†…å­˜: 30-50% å‡å°‘
```

---

## ç¬¬ä¸ƒéƒ¨åˆ†: testing.B.Loop()

### 7.1 åŸºå‡†æµ‹è¯•å¾ªç¯

```mathematical
/* testing.B.Loop() (Go 1.25.3) */

/* ä¼ ç»Ÿæ–¹å¼ */

func BenchmarkOld(b *testing.B) {
    for i := 0; i < b.N; i++ {
        operation()
    }
}

/* æ–°æ–¹å¼ */

func BenchmarkNew(b *testing.B) {
    for b.Loop() {
        operation()
    }
}

/* Loop()è¯­ä¹‰ */

func (b *B) Loop() bool {
    if b.i >= b.N {
        return false  // ç»ˆæ­¢å¾ªç¯
    }
    b.i++
    return true
}

/* ä¼˜åŠ¿ */

1. æ›´ç®€æ´çš„è¯­æ³•
2. è‡ªåŠ¨è®¡æ•°ç®¡ç†
3. æ›´å¥½çš„ç¼–è¯‘å™¨ä¼˜åŒ–æœºä¼š

/* ç¼–è¯‘å™¨ä¼˜åŒ– */

ä¼ ç»Ÿæ–¹å¼:
  for i := 0; i < b.N; i++ {  // iå’Œb.Néƒ½éœ€è¦æ£€æŸ¥
      operation()
  }

Loop()æ–¹å¼:
  for b.Loop() {  // åªæ£€æŸ¥ä¸€ä¸ªæ¡ä»¶
      operation()
  }

ç¼–è¯‘å™¨å¯ä»¥æ›´æ¿€è¿›åœ°ä¼˜åŒ–Loop()ã€‚
```

### 7.2 ç»Ÿè®¡ç‰¹æ€§

```mathematical
/* åŸºå‡†æµ‹è¯•ç»Ÿè®¡ */

/* æµ‹é‡æŒ‡æ ‡ */

Metrics = {
    ns_per_op: float64,       /* æ¯æ¬¡æ“ä½œçš„çº³ç§’æ•° */
    allocs_per_op: int64,     /* æ¯æ¬¡æ“ä½œçš„åˆ†é…æ¬¡æ•° */
    bytes_per_op: int64,      /* æ¯æ¬¡æ“ä½œçš„å­—èŠ‚æ•° */
    mb_per_sec: float64       /* ååé‡ */
}

/* ç»Ÿè®¡è®¡ç®— */

function compute_metrics(b *B):
    total_time = b.elapsed
    total_ops = b.N
    
    ns_per_op = total_time / total_ops
    
    if b.track_allocs:
        allocs_per_op = b.total_allocs / total_ops
        bytes_per_op = b.total_bytes / total_ops
    
    if b.set_bytes > 0:
        mb_per_sec = (b.set_bytes * total_ops) / (total_time * 1e6)
    
    return Metrics{...}

/* è‡ªé€‚åº”è¿­ä»£æ¬¡æ•° */

function run_benchmark(b *B):
    b.N = 1
    
    /* é¢„çƒ­è¿è¡Œ */
    run_n_times(b, b.N)
    
    /* è°ƒæ•´Nç›´åˆ°è¿è¡Œæ—¶é—´è¶³å¤Ÿé•¿ */
    target_time = 1_second
    while b.elapsed < target_time:
        b.N *= 2
        run_n_times(b, b.N)
    
    /* æœ€ç»ˆç²¾ç¡®æµ‹é‡ */
    b.ResetTimer()
    run_n_times(b, b.N)
    
    return compute_metrics(b)

/* Go 1.25.3æ”¹è¿› */

1. æ›´ç²¾ç¡®çš„æ—¶é—´æµ‹é‡ (çº³ç§’çº§ç²¾åº¦)
2. æ›´å°‘çš„æµ‹é‡å¼€é”€
3. æ›´å¥½çš„ç»Ÿè®¡ç¨³å®šæ€§
4. æ”¯æŒå­åŸºå‡†æµ‹è¯•çš„å¹¶è¡Œè¿è¡Œ
```

---

## ğŸ¯ æ€»ç»“

### æ–°ç‰¹æ€§æ€»è§ˆ

| ç‰¹æ€§ | Goç‰ˆæœ¬ | ç¨³å®šæ€§ | ä¸»è¦æ”¹è¿› |
|------|--------|--------|---------|
| æ³›å‹ç±»å‹åˆ«å | 1.23+ (stable 1.25) | ç¨³å®š | ä»£ç é‡ç”¨,é›¶æˆæœ¬æŠ½è±¡ |
| å¾ªç¯å˜é‡ä½œç”¨åŸŸ | 1.22+ | ç¨³å®š | æ¶ˆé™¤å¸¸è§bugæ¨¡å¼ |
| range-over-func | 1.23+ (opt 1.25) | ä¼˜åŒ– | é›¶å¼€é”€è¿­ä»£å™¨ |
| encoding/json/v2 | 1.25.3 | å®éªŒ | 2-3xæ€§èƒ½,ç±»å‹å®‰å…¨ |
| HTTPè·¯ç”± | 1.22+ | ç¨³å®š | è·¯å¾„å‚æ•°,ä¼˜å…ˆçº§ |
| unique.Handle | 1.23+ | æ ‡å‡†åº“ | å†…å­˜ä¼˜åŒ–,å¿«é€Ÿæ¯”è¾ƒ |
| testing.B.Loop() | 1.25.3 | ç¨³å®š | ç®€æ´è¯­æ³•,æ›´å¥½ä¼˜åŒ– |

### å½¢å¼åŒ–è´¡çŒ®

1. **æ³›å‹ç±»å‹åˆ«å**
   - ç±»å‹ç­‰ä»·æ€§å½¢å¼åŒ–
   - å®ä¾‹åŒ–è§„åˆ™è¯æ˜

2. **å¾ªç¯å˜é‡ä½œç”¨åŸŸ**
   - æ–°æ—§è¯­ä¹‰å¯¹æ¯”
   - å‘åå…¼å®¹æ€§åˆ†æ

3. **è¿­ä»£å™¨**
   - range-over-funcè¯­ä¹‰
   - æ€§èƒ½ä¼˜åŒ–è¯æ˜

4. **JSON v2**
   - ç±»å‹ç³»ç»Ÿå¢å¼º
   - æ€§èƒ½åˆ†æ

5. **HTTPè·¯ç”±**
   - æ¨¡å¼åŒ¹é…ç®—æ³•
   - ä¼˜å…ˆçº§è§„åˆ™å½¢å¼åŒ–

6. **unique.Handle**
   - å”¯ä¸€æ€§ä¿è¯
   - å†…å­˜åˆ†æ

### å®è·µå½±å“

1. **å¼€å‘æ•ˆç‡æå‡**
   - æ›´å°‘çš„æ ·æ¿ä»£ç 
   - æ›´å®‰å…¨çš„å¹¶å‘æ¨¡å¼

2. **æ€§èƒ½æ”¹è¿›**
   - è¿­ä»£å™¨é›¶å¼€é”€
   - JSON 2-3xåŠ é€Ÿ
   - å†…å­˜å ç”¨å‡å°‘

3. **ä»£ç è´¨é‡**
   - æ¶ˆé™¤å¾ªç¯å˜é‡bug
   - ç±»å‹å®‰å…¨å¢å¼º
   - æ›´å¥½çš„é”™è¯¯æ£€æµ‹

4. **å‘åå…¼å®¹**
   - æ¸è¿›å¼è¿ç§»è·¯å¾„
   - å…¼å®¹å±‚æ”¯æŒ
   - ç‰ˆæœ¬æ ‡è®°æ˜ç¡®

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**åŸºå‡†æ—¥æœŸ**: 2025å¹´10æœˆ22æ—¥  
**Goç‰ˆæœ¬**: Go 1.25.3  
**ç†è®ºåŸºç¡€**: è¯­è¨€ç‰¹æ€§å½¢å¼åŒ– + å‘åå…¼å®¹æ€§åˆ†æ

<div align="center">

Made with â¤ï¸ for Go Language Evolution Researchers

[â¬† å›åˆ°é¡¶éƒ¨](#go-1253æ–°ç‰¹æ€§å½¢å¼åŒ–åˆ†æ)

</div>

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Formal Methods Research Group  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ22æ—¥  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
