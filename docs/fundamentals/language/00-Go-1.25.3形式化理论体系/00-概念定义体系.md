# æ¦‚å¿µå®šä¹‰ä½“ç³»

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.25.3

---

## æ ¸å¿ƒæ¦‚å¿µ

### 1. ç±»å‹ç³»ç»Ÿå½¢å¼åŒ–

**ç±»å‹åˆ¤æ–­**:

```text
Î“ âŠ¢ e : T

å®šä¹‰:
- Î“: ç±»å‹ç¯å¢ƒï¼Œæ˜ å°„å˜é‡åˆ°ç±»å‹
- e: è¡¨è¾¾å¼
- T: ç±»å‹
- âŠ¢: ç±»å‹åˆ¤æ–­ç¬¦å·
```

**ç±»å‹è§„åˆ™ç¤ºä¾‹**:

```text
å˜é‡è§„åˆ™:
x : T âˆˆ Î“
-----------
Î“ âŠ¢ x : T

å‡½æ•°åº”ç”¨è§„åˆ™:
Î“ âŠ¢ f : Tâ‚ â†’ Tâ‚‚    Î“ âŠ¢ x : Tâ‚
--------------------------------
Î“ âŠ¢ f(x) : Tâ‚‚
```

---

### 2. æ³›å‹ç±»å‹ç³»ç»Ÿ

**å½¢å¼åŒ–å®šä¹‰**:

```text
æ³›å‹å‡½æ•°:
func F[T Constraint](x T) T

ç±»å‹çº¦æŸ:
type Constraint interface {
    ~int | ~float64 | ...
}

Go 1.25.3ç®€åŒ–:
- ç§»é™¤"core types"æ¦‚å¿µ
- ç®€åŒ–ç±»å‹é›†è¯­ä¹‰
```

---

### 3. CSPå¹¶å‘æ¨¡å‹

**è¿›ç¨‹ä»£æ•°**:

```text
P ::= STOP              ç©ºè¿›ç¨‹
    | c!v â†’ P          å‘é€åç»§ç»­P
    | c?x â†’ P(x)       æ¥æ”¶åç»§ç»­P
    | P || Q           å¹¶è¡Œç»„åˆ
    | P âŠ” Q            é€‰æ‹©

Goå®ç°:
goroutine â†’ Process
channel   â†’ Communication
select    â†’ Choice operator
```

**é€šä¿¡è¯­ä¹‰**:

```text
Send(c, v):
  wait until Receive(c, _) ready
  transfer v

Receive(c):
  wait until Send(c, v) ready
  get v
  return v
```

---

### 4. GMPè°ƒåº¦æ¨¡å‹

**å½¢å¼åŒ–å®šä¹‰**:

```go
type G struct {  // Goroutine
    Stack     []byte
    State     GState
    M         *M
}

type M struct {  // Machine/OS Thread
    G         *G
    P         *P
    Spinning  bool
}

type P struct {  // Processor
    RunQueue  []*G
    M         *M
    Status    PStatus
}

// Go 1.25.3æ–°ç‰¹æ€§
func SetGOMAXPROCS() int {
    if runtime.GOOS == "linux" {
        cgroupLimit := readCgroupCPULimit()
        hostCPUs := runtime.NumCPU()
        return min(cgroupLimit, hostCPUs)
    }
    return runtime.NumCPU()
}
```

---

### 5. Happens-Beforeå…³ç³»

**å½¢å¼åŒ–å®šä¹‰**:

```text
A â†’hb B  (A happens-before B)

å…¬ç†:
1. Program Order:
   åŒä¸€goroutineå†…ï¼ŒAå…ˆäºBæ‰§è¡Œ â†’ A â†’hb B

2. Channel Synchronization:
   send(c, v) â†’hb receive(c, v)

3. Transitivity:
   A â†’hb B âˆ§ B â†’hb C â†’ A â†’hb C

æ•°æ®ç«äº‰:
DataRace(r, w) â‡” Â¬(r â†’hb w) âˆ§ Â¬(w â†’hb r) âˆ§ same_location(r, w)
```

---

### 6. ä¸‰è‰²æ ‡è®°GC

**ç®—æ³•å®šä¹‰**:

```text
Colors = {White, Gray, Black}

åˆå§‹:
  Roots: Gray
  Others: White

æ ‡è®°:
  while âˆƒ gray object o:
    mark o as Black
    for each ref r in o:
      if color(r) = White:
        mark r as Gray

æ¸…é™¤:
  reclaim all White objects

Go 1.25.3 greenteagcä¼˜åŒ–:
- å°å¯¹è±¡æ ‡è®°: O(n) â†’ O(log n)
- GCå¼€é”€: -10% ~ -40%
```

---

### 7. å†…å­˜æ¨¡å‹ä¿è¯

**åŒæ­¥åŸè¯­è¯­ä¹‰**:

```go
// Mutex
type Mutex struct {
    state int32
    sema  uint32
}

// Happens-Beforeä¿è¯:
// Unlock(m) â†’hb Lock(m)

// Channel
// send(c, v) â†’hb receive(c, v)

// WaitGroup
// Add(n) â†’hb Wait() returns
```

---

### 8. Go 1.25.3æ–°æ¦‚å¿µ

**å®¹å™¨æ„ŸçŸ¥è°ƒåº¦**:

```text
å®šä¹‰: è¿è¡Œæ—¶è‡ªåŠ¨æ£€æµ‹å®¹å™¨èµ„æºé™åˆ¶

CgroupAware := {
    CPU_Limit:    cgroup.cpu.cfs_quota_us / cgroup.cpu.cfs_period_us,
    Memory_Limit: cgroup.memory.limit_in_bytes,
    Dynamic:      ç›‘æ§cgroupå˜åŒ–å¹¶è‡ªåŠ¨è°ƒæ•´
}

åº”ç”¨: GOMAXPROCS = min(CPU_Limit, HostCPUs)
```

**Nil Pointeræ£€æŸ¥æ”¹è¿›**:

```text
ä¿è¯: âˆ€ p : *T, p = nil â†’
      Access(p) â‡’ Panic("nil pointer")

Go 1.25.3:
- æ£€æŸ¥ä½ç½®: è®¿é—®ç‚¹ï¼ˆéå»¶è¿Ÿï¼‰
- æ£€æŸ¥å‡†ç¡®æ€§: 100%
- é”™è¯¯ä¿¡æ¯: ç²¾ç¡®
```

---

## ğŸ”— ç›¸å…³æ–‡æ¡£

- [çŸ¥è¯†å›¾è°±](./00-çŸ¥è¯†å›¾è°±.md)
- [å¯¹æ¯”çŸ©é˜µ](./00-å¯¹æ¯”çŸ©é˜µ.md)

---

**æœ€åæ›´æ–°**: 2025-10-29
