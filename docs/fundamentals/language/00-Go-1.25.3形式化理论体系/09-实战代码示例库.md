# Go 1.25.3å½¢å¼åŒ–ç†è®ºå®æˆ˜ä»£ç ç¤ºä¾‹åº“

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.25.3

---

## ğŸ“‹ ç›®å½•

- [Go 1.25.3å½¢å¼åŒ–ç†è®ºå®æˆ˜ä»£ç ç¤ºä¾‹åº“](#go-1253å½¢å¼åŒ–ç†è®ºå®æˆ˜ä»£ç ç¤ºä¾‹åº“)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“– ä½¿ç”¨è¯´æ˜](#-ä½¿ç”¨è¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. ç±»å‹ç³»ç»Ÿç¤ºä¾‹](#1-ç±»å‹ç³»ç»Ÿç¤ºä¾‹)
    - [1.1 ç±»å‹å®‰å…¨çš„æ³›å‹æ ˆ](#11-ç±»å‹å®‰å…¨çš„æ³›å‹æ ˆ)
    - [1.2 ç±»å‹å®‰å…¨çš„Optionç±»å‹](#12-ç±»å‹å®‰å…¨çš„optionç±»å‹)
  - [2. å¹¶å‘å®‰å…¨ç¤ºä¾‹](#2-å¹¶å‘å®‰å…¨ç¤ºä¾‹)
    - [2.1 æ— æ­»é”çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…](#21-æ— æ­»é”çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…)
    - [2.2 æ— é”çš„å¹¶å‘è®¡æ•°å™¨](#22-æ— é”çš„å¹¶å‘è®¡æ•°å™¨)
  - [3. å†…å­˜æ¨¡å‹ç¤ºä¾‹](#3-å†…å­˜æ¨¡å‹ç¤ºä¾‹)
    - [3.1 Happens-Beforeå…³ç³»æ¼”ç¤º](#31-happens-beforeå…³ç³»æ¼”ç¤º)
  - [4. Go 1.25.3æ–°ç‰¹æ€§ç¤ºä¾‹](#4-go-1253æ–°ç‰¹æ€§ç¤ºä¾‹)
    - [4.1 æ³›å‹ç±»å‹åˆ«åçš„åº”ç”¨](#41-æ³›å‹ç±»å‹åˆ«åçš„åº”ç”¨)
    - [4.2 å¾ªç¯å˜é‡ä½œç”¨åŸŸæ”¹è¿›](#42-å¾ªç¯å˜é‡ä½œç”¨åŸŸæ”¹è¿›)
    - [4.3 range-over-funcè¿­ä»£å™¨](#43-range-over-funcè¿­ä»£å™¨)
  - [5. å½¢å¼åŒ–éªŒè¯å·¥å…·](#5-å½¢å¼åŒ–éªŒè¯å·¥å…·)
    - [5.1 ç®€å•çš„æ•°æ®ç«äº‰æ£€æµ‹å™¨](#51-ç®€å•çš„æ•°æ®ç«äº‰æ£€æµ‹å™¨)
    - [5.2 ç®€å•çš„æ­»é”æ£€æµ‹å™¨](#52-ç®€å•çš„æ­»é”æ£€æµ‹å™¨)
  - [ğŸ“š ä½¿ç”¨å»ºè®®](#-ä½¿ç”¨å»ºè®®)
    - [å­¦ä¹ è·¯å¾„](#å­¦ä¹ è·¯å¾„)
    - [å®è·µå»ºè®®](#å®è·µå»ºè®®)
    - [ç›¸å…³èµ„æº](#ç›¸å…³èµ„æº)

## ğŸ“– ä½¿ç”¨è¯´æ˜

æœ¬æ–‡æ¡£æä¾›**å¯ç›´æ¥è¿è¡Œçš„Goä»£ç ç¤ºä¾‹**ï¼Œå±•ç¤ºå¦‚ä½•å°†å½¢å¼åŒ–ç†è®ºåº”ç”¨åˆ°å®é™…ç¼–ç¨‹ä¸­ã€‚æ¯ä¸ªç¤ºä¾‹éƒ½åŒ…å«ï¼š

- âœ… å®Œæ•´çš„å¯è¿è¡Œä»£ç 
- âœ… å½¢å¼åŒ–ç†è®ºèƒŒæ™¯
- âœ… æ­£ç¡®æ€§è¯æ˜æˆ–åˆ†æ
- âœ… æ€§èƒ½è€ƒé‡
- âœ… æœ€ä½³å®è·µè¯´æ˜

---

## ç›®å½•

- [Go 1.25.3å½¢å¼åŒ–ç†è®ºå®æˆ˜ä»£ç ç¤ºä¾‹åº“](#go-1253å½¢å¼åŒ–ç†è®ºå®æˆ˜ä»£ç ç¤ºä¾‹åº“)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“– ä½¿ç”¨è¯´æ˜](#-ä½¿ç”¨è¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. ç±»å‹ç³»ç»Ÿç¤ºä¾‹](#1-ç±»å‹ç³»ç»Ÿç¤ºä¾‹)
    - [1.1 ç±»å‹å®‰å…¨çš„æ³›å‹æ ˆ](#11-ç±»å‹å®‰å…¨çš„æ³›å‹æ ˆ)
    - [1.2 ç±»å‹å®‰å…¨çš„Optionç±»å‹](#12-ç±»å‹å®‰å…¨çš„optionç±»å‹)
  - [2. å¹¶å‘å®‰å…¨ç¤ºä¾‹](#2-å¹¶å‘å®‰å…¨ç¤ºä¾‹)
    - [2.1 æ— æ­»é”çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…](#21-æ— æ­»é”çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…)
    - [2.2 æ— é”çš„å¹¶å‘è®¡æ•°å™¨](#22-æ— é”çš„å¹¶å‘è®¡æ•°å™¨)
  - [3. å†…å­˜æ¨¡å‹ç¤ºä¾‹](#3-å†…å­˜æ¨¡å‹ç¤ºä¾‹)
    - [3.1 Happens-Beforeå…³ç³»æ¼”ç¤º](#31-happens-beforeå…³ç³»æ¼”ç¤º)
  - [4. Go 1.25.3æ–°ç‰¹æ€§ç¤ºä¾‹](#4-go-1253æ–°ç‰¹æ€§ç¤ºä¾‹)
    - [4.1 æ³›å‹ç±»å‹åˆ«åçš„åº”ç”¨](#41-æ³›å‹ç±»å‹åˆ«åçš„åº”ç”¨)
    - [4.2 å¾ªç¯å˜é‡ä½œç”¨åŸŸæ”¹è¿›](#42-å¾ªç¯å˜é‡ä½œç”¨åŸŸæ”¹è¿›)
    - [4.3 range-over-funcè¿­ä»£å™¨](#43-range-over-funcè¿­ä»£å™¨)
  - [5. å½¢å¼åŒ–éªŒè¯å·¥å…·](#5-å½¢å¼åŒ–éªŒè¯å·¥å…·)
    - [5.1 ç®€å•çš„æ•°æ®ç«äº‰æ£€æµ‹å™¨](#51-ç®€å•çš„æ•°æ®ç«äº‰æ£€æµ‹å™¨)
    - [5.2 ç®€å•çš„æ­»é”æ£€æµ‹å™¨](#52-ç®€å•çš„æ­»é”æ£€æµ‹å™¨)
  - [ğŸ“š ä½¿ç”¨å»ºè®®](#-ä½¿ç”¨å»ºè®®)
    - [å­¦ä¹ è·¯å¾„](#å­¦ä¹ è·¯å¾„)
    - [å®è·µå»ºè®®](#å®è·µå»ºè®®)
    - [ç›¸å…³èµ„æº](#ç›¸å…³èµ„æº)

---

## 1. ç±»å‹ç³»ç»Ÿç¤ºä¾‹

### 1.1 ç±»å‹å®‰å…¨çš„æ³›å‹æ ˆ

**ç†è®ºèƒŒæ™¯**: åŸºäºç±»å‹ç³»ç»Ÿå½¢å¼åŒ–å®šä¹‰ä¸­çš„æ³›å‹çº¦æŸå’Œç±»å‹å®‰å…¨æ€§è¯æ˜ã€‚

**å½¢å¼åŒ–æ€§è´¨**:

- **ç±»å‹å®‰å…¨**: Progress + Preservationå®šç†ä¿è¯
- **æ³›å‹çº¦æŸ**: ä½¿ç”¨`any`çº¦æŸï¼Œé€‚ç”¨æ‰€æœ‰ç±»å‹
- **æ“ä½œæ­£ç¡®æ€§**: æ ˆæ“ä½œæ»¡è¶³LIFOè¯­ä¹‰

```go
package main

import (
 "fmt"
 "sync"
)

// Stack ç±»å‹å®‰å…¨çš„æ³›å‹æ ˆ
// å½¢å¼åŒ–å®šä¹‰: Stack[T] = { data: []T, mu: Mutex }
// ä¸å˜å¼: âˆ€i. 0 â‰¤ i < len(data) â‡’ data[i] : T
type Stack[T any] struct {
 data []T
 mu   sync.RWMutex
}

// NewStack åˆ›å»ºæ–°æ ˆ
// åç½®æ¡ä»¶: |stack.data| = 0
func NewStack[T any]() *Stack[T] {
 return &Stack[T]{
  data: make([]T, 0),
 }
}

// Push å‹æ ˆ
// å‰ç½®æ¡ä»¶: true
// åç½®æ¡ä»¶: |stack.data| = |stack.data|â‚€ + 1 âˆ§
//           stack.data[|stack.data|-1] = value
func (s *Stack[T]) Push(value T) {
 s.mu.Lock()
 defer s.mu.Unlock()
 s.data = append(s.data, value)
}

// Pop å‡ºæ ˆ
// å‰ç½®æ¡ä»¶: |stack.data| > 0
// åç½®æ¡ä»¶: |stack.data| = |stack.data|â‚€ - 1 âˆ§
//           result = stack.dataâ‚€[|stack.data|â‚€-1]
func (s *Stack[T]) Pop() (T, bool) {
 s.mu.Lock()
 defer s.mu.Unlock()

 if len(s.data) == 0 {
  var zero T
  return zero, false
 }

 n := len(s.data)
 value := s.data[n-1]
 s.data = s.data[:n-1]
 return value, true
}

// Peek æŸ¥çœ‹æ ˆé¡¶
// å‰ç½®æ¡ä»¶: |stack.data| > 0
// åç½®æ¡ä»¶: stackä¸å˜ âˆ§ result = stack.data[|stack.data|-1]
func (s *Stack[T]) Peek() (T, bool) {
 s.mu.RLock()
 defer s.mu.RUnlock()

 if len(s.data) == 0 {
  var zero T
  return zero, false
 }

 return s.data[len(s.data)-1], true
}

// Size è·å–æ ˆå¤§å°
// åç½®æ¡ä»¶: result = |stack.data|
func (s *Stack[T]) Size() int {
 s.mu.RLock()
 defer s.mu.RUnlock()
 return len(s.data)
}

// æ­£ç¡®æ€§è¯æ˜:
// 1. ç±»å‹å®‰å…¨: ç¼–è¯‘å™¨ä¿è¯æ‰€æœ‰Tç±»å‹æ“ä½œçš„ç±»å‹æ­£ç¡®æ€§
// 2. LIFOè¯­ä¹‰: Pop()è¿”å›æœ€åPush()çš„å…ƒç´ 
// 3. å¹¶å‘å®‰å…¨: sync.RWMutexä¿è¯æ“ä½œçš„åŸå­æ€§

func ExampleStack() {
 // æ•´æ•°æ ˆ
 intStack := NewStack[int]()
 intStack.Push(1)
 intStack.Push(2)
 intStack.Push(3)

 if val, ok := intStack.Pop(); ok {
  fmt.Println("Pop:", val) // è¾“å‡º: 3
 }

 // å­—ç¬¦ä¸²æ ˆ - ç±»å‹å®‰å…¨ï¼Œä¸èƒ½æ··ç”¨
 strStack := NewStack[string]()
 strStack.Push("hello")
 strStack.Push("world")

 if val, ok := strStack.Peek(); ok {
  fmt.Println("Peek:", val) // è¾“å‡º: world
 }

 fmt.Println("Size:", strStack.Size()) // è¾“å‡º: 2
}
```

**ç±»å‹å®‰å…¨è¯æ˜**:

```mathematical
/* Progresså®šç† */
âˆ€s: Stack[T], op: Operation.
  well_formed(s) â‡’ (can_execute(op, s) âˆ¨ error_reported(op, s))

è¯æ˜:
- Push: æ€»æ˜¯å¯æ‰§è¡Œ
- Pop/Peek: æ£€æŸ¥len(data) > 0ï¼Œè¿”å›(T, bool)ï¼Œç±»å‹å®‰å…¨

/* Preservationå®šç† */
âˆ€s: Stack[T], op: Operation.
  well_typed(s) âˆ§ execute(op, s) = s' â‡’ well_typed(s')

è¯æ˜:
- æ‰€æœ‰æ“ä½œä¿æŒdataçš„ç±»å‹ä¸å˜å¼: âˆ€i. data[i] : T
- ç¼–è¯‘å™¨ä¿è¯ç±»å‹Tçš„ä¸€è‡´æ€§
```

---

### 1.2 ç±»å‹å®‰å…¨çš„Optionç±»å‹

**ç†è®ºèƒŒæ™¯**: Maybe/Optionæ¨¡å¼çš„å½¢å¼åŒ–ï¼Œé¿å…ç©ºæŒ‡é’ˆå¼‚å¸¸ã€‚

```go
package main

import "fmt"

// Option è¡¨ç¤ºå¯é€‰å€¼
// å½¢å¼åŒ–: Option[T] = Some(T) | None
type Option[T any] struct {
 value *T
}

// Some åˆ›å»ºæœ‰å€¼çš„Option
// åç½®æ¡ä»¶: result.IsSome() = true âˆ§ result.Unwrap() = value
func Some[T any](value T) Option[T] {
 return Option[T]{value: &value}
}

// None åˆ›å»ºç©ºOption
// åç½®æ¡ä»¶: result.IsNone() = true
func None[T any]() Option[T] {
 return Option[T]{value: nil}
}

// IsSome æ£€æŸ¥æ˜¯å¦æœ‰å€¼
func (o Option[T]) IsSome() bool {
 return o.value != nil
}

// IsNone æ£€æŸ¥æ˜¯å¦ä¸ºç©º
func (o Option[T]) IsNone() bool {
 return o.value == nil
}

// Unwrap è·å–å€¼ï¼ˆä¸å®‰å…¨ï¼‰
// å‰ç½®æ¡ä»¶: o.IsSome() = true
// åç½®æ¡ä»¶: result = *o.value
func (o Option[T]) Unwrap() T {
 if o.value == nil {
  panic("called Unwrap on None")
 }
 return *o.value
}

// UnwrapOr è·å–å€¼æˆ–é»˜è®¤å€¼
// åç½®æ¡ä»¶: o.IsSome() â‡’ result = *o.value
//           o.IsNone() â‡’ result = defaultValue
func (o Option[T]) UnwrapOr(defaultValue T) T {
 if o.value == nil {
  return defaultValue
 }
 return *o.value
}

// Map æ˜ å°„å‡½æ•°
// å½¢å¼åŒ–: map : (T â†’ U) â†’ Option[T] â†’ Option[U]
// æ€§è´¨: o.IsNone() â‡’ o.Map(f).IsNone()
//       o.IsSome() â‡’ o.Map(f) = Some(f(o.Unwrap()))
func Map[T, U any](o Option[T], f func(T) U) Option[U] {
 if o.value == nil {
  return None[U]()
 }
 result := f(*o.value)
 return Some(result)
}

// FlatMap æ‰å¹³åŒ–æ˜ å°„
// å½¢å¼åŒ–: flatMap : (T â†’ Option[U]) â†’ Option[T] â†’ Option[U]
func FlatMap[T, U any](o Option[T], f func(T) Option[U]) Option[U] {
 if o.value == nil {
  return None[U]()
 }
 return f(*o.value)
}

// ç¤ºä¾‹ï¼šå®‰å…¨çš„é™¤æ³•
func SafeDiv(a, b int) Option[int] {
 if b == 0 {
  return None[int]()
 }
 result := a / b
 return Some(result)
}

func ExampleOption() {
 // åŸºæœ¬ä½¿ç”¨
 opt1 := Some(42)
 fmt.Println(opt1.Unwrap()) // 42

 opt2 := None[int]()
 fmt.Println(opt2.UnwrapOr(0)) // 0

 // é“¾å¼æ“ä½œ
 result := Map(Some(10), func(x int) int { return x * 2 })
 fmt.Println(result.Unwrap()) // 20

 // å®‰å…¨é™¤æ³•
 div1 := SafeDiv(10, 2)
 fmt.Println(div1.UnwrapOr(-1)) // 5

 div2 := SafeDiv(10, 0)
 fmt.Println(div2.UnwrapOr(-1)) // -1 (é™¤ä»¥0ï¼Œè¿”å›é»˜è®¤å€¼)

 // FlatMapç»„åˆ
 result2 := FlatMap(Some(10), func(x int) Option[int] {
  return SafeDiv(x, 2)
 })
 fmt.Println(result2.Unwrap()) // 5
}
```

**æ­£ç¡®æ€§è¯æ˜**:

```mathematical
/* Monadå®šå¾‹ */

// 1. å·¦å•ä½å…ƒ
FlatMap(Some(x), f) = f(x)

// 2. å³å•ä½å…ƒ
FlatMap(m, Some) = m

// 3. ç»“åˆå¾‹
FlatMap(FlatMap(m, f), g) = FlatMap(m, Î»x. FlatMap(f(x), g))

/* ç±»å‹å®‰å…¨ */
Option[T]ä¿è¯:
- ä¸ä¼šå‡ºç°ç©ºæŒ‡é’ˆå¼‚å¸¸ï¼ˆé™¤éæ˜¾å¼Unwrapï¼‰
- ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥
- ç¬¦åˆMonadè¯­ä¹‰
```

---

## 2. å¹¶å‘å®‰å…¨ç¤ºä¾‹

### 2.1 æ— æ­»é”çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…

**ç†è®ºèƒŒæ™¯**: åŸºäºCSPå¹¶å‘æ¨¡å‹å’ŒHappens-Beforeå…³ç³»ã€‚

**å½¢å¼åŒ–è¯æ˜**:

- **Deadlock-Free**: èµ„æºä¾èµ–å›¾æ— ç¯
- **Race-Free**: æ‰€æœ‰å…±äº«å˜é‡è®¿é—®æ»¡è¶³HBå…³ç³»
- **Liveness**: æ‰€æœ‰æ¶ˆæ¯ç»ˆå°†è¢«å¤„ç†

```go
package main

import (
 "context"
 "fmt"
 "sync"
 "time"
)

// ProducerConsumer ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼
// å½¢å¼åŒ–æ¨¡å‹:
//   Producer = ch!produce() â†’ Producer
//   Consumer = ch?msg â†’ process(msg) â†’ Consumer
//   System = Producer âˆ¥ Consumer
type ProducerConsumer[T any] struct {
 buffer   chan T
 wg       sync.WaitGroup
 ctx      context.Context
 cancel   context.CancelFunc
 producer func() T
 consumer func(T)
}

// NewProducerConsumer åˆ›å»ºç”Ÿäº§è€…-æ¶ˆè´¹è€…ç³»ç»Ÿ
// å‚æ•°:
//   bufferSize: channelå®¹é‡ï¼ˆ>0é¿å…æ­»é”ï¼‰
//   producer: ç”Ÿäº§å‡½æ•°
//   consumer: æ¶ˆè´¹å‡½æ•°
func NewProducerConsumer[T any](
 bufferSize int,
 producer func() T,
 consumer func(T),
) *ProducerConsumer[T] {
 ctx, cancel := context.WithCancel(context.Background())
 return &ProducerConsumer[T]{
  buffer:   make(chan T, bufferSize),
  ctx:      ctx,
  cancel:   cancel,
  producer: producer,
  consumer: consumer,
 }
}

// StartProducers å¯åŠ¨nä¸ªç”Ÿäº§è€…
// åç½®æ¡ä»¶: å¯åŠ¨nä¸ªgoroutineï¼Œæ¯ä¸ªæ‰§è¡Œproducerå¹¶å‘é€åˆ°channel
func (pc *ProducerConsumer[T]) StartProducers(n int) {
 for i := 0; i < n; i++ {
  pc.wg.Add(1)
  go func(id int) {
   defer pc.wg.Done()
   for {
    select {
    case <-pc.ctx.Done():
     return
    default:
     item := pc.producer()
     select {
     case pc.buffer <- item:
      // æˆåŠŸå‘é€
     case <-pc.ctx.Done():
      return
     }
    }
   }
  }(i)
 }
}

// StartConsumers å¯åŠ¨nä¸ªæ¶ˆè´¹è€…
// åç½®æ¡ä»¶: å¯åŠ¨nä¸ªgoroutineï¼Œæ¯ä¸ªä»channelæ¥æ”¶å¹¶æ¶ˆè´¹
func (pc *ProducerConsumer[T]) StartConsumers(n int) {
 for i := 0; i < n; i++ {
  pc.wg.Add(1)
  go func(id int) {
   defer pc.wg.Done()
   for {
    select {
    case <-pc.ctx.Done():
     return
    case item, ok := <-pc.buffer:
     if !ok {
      return
     }
     pc.consumer(item)
    }
   }
  }(i)
 }
}

// Stop åœæ­¢ç³»ç»Ÿ
// ä¿è¯: æ‰€æœ‰goroutineä¼˜é›…é€€å‡º
func (pc *ProducerConsumer[T]) Stop() {
 pc.cancel()      // å‘é€åœæ­¢ä¿¡å·
 pc.wg.Wait()     // ç­‰å¾…æ‰€æœ‰goroutine
 close(pc.buffer) // å…³é—­channel
}

/* æ­»é”è‡ªç”±æ€§è¯æ˜ */
//
// èµ„æºä¾èµ–å›¾:
//   Producer â†’ buffer (å†™)
//   buffer â†’ Consumer (è¯»)
//
// åˆ†æ:
// 1. bufferæœ‰å®¹é‡ â‡’ Producerä¸ä¼šæ— é™é˜»å¡
// 2. Consumeræ€»æ˜¯å‡†å¤‡æ¥æ”¶ â‡’ bufferä¸ä¼šæ»¡
// 3. ctx.Done()æä¾›é€€å‡ºæœºåˆ¶ â‡’ æ— æ°¸ä¹…é˜»å¡
// 4. ä¾èµ–å›¾æ— ç¯ â‡’ æ— æ­»é”
//
// ç»“è®º: Deadlock-Free âœ“

/* æ•°æ®ç«äº‰è‡ªç”±æ€§è¯æ˜ */
//
// Happens-Beforeåˆ†æ:
// 1. ch <- item HB chæ¥æ”¶item
// 2. ctx.Done() HB æ‰€æœ‰selectçš„ctx.Done()åˆ†æ”¯
// 3. wg.Done() HB wg.Wait()è¿”å›
//
// å…±äº«å˜é‡è®¿é—®:
// - buffer: ä»…é€šè¿‡channelæ“ä½œï¼ˆchannelä¿è¯åŒæ­¥ï¼‰
// - ctx: é€šè¿‡ctx.Done()ï¼ˆåªè¯»ï¼Œå¹¶å‘å®‰å…¨ï¼‰
// - wg: é€šè¿‡Add/Done/Waitï¼ˆå†…éƒ¨äº’æ–¥ï¼‰
//
// ç»“è®º: Race-Free âœ“

func ExampleProducerConsumer() {
 counter := 0
 var mu sync.Mutex

 // ç”Ÿäº§å‡½æ•°
 producer := func() int {
  mu.Lock()
  defer mu.Unlock()
  counter++
  return counter
 }

 // æ¶ˆè´¹å‡½æ•°
 consumer := func(item int) {
  fmt.Printf("Consumed: %d\n", item)
  time.Sleep(10 * time.Millisecond) // æ¨¡æ‹Ÿå¤„ç†
 }

 // åˆ›å»ºç³»ç»Ÿ
 pc := NewProducerConsumer(10, producer, consumer)

 // å¯åŠ¨2ä¸ªç”Ÿäº§è€…ï¼Œ3ä¸ªæ¶ˆè´¹è€…
 pc.StartProducers(2)
 pc.StartConsumers(3)

 // è¿è¡Œ1ç§’
 time.Sleep(1 * time.Second)

 // åœæ­¢ç³»ç»Ÿ
 pc.Stop()

 fmt.Println("System stopped gracefully")
}
```

---

### 2.2 æ— é”çš„å¹¶å‘è®¡æ•°å™¨

**ç†è®ºèƒŒæ™¯**: åŸºäºåŸå­æ“ä½œå’ŒLinearizabilityç†è®ºã€‚

```go
package main

import (
 "fmt"
 "sync"
 "sync/atomic"
)

// AtomicCounter æ— é”è®¡æ•°å™¨
// å½¢å¼åŒ–: Counter = { value: int64 }
// çº¿æ€§åŒ–ç‚¹: atomicæ“ä½œçš„æ‰§è¡Œæ—¶åˆ»
type AtomicCounter struct {
 value int64
}

// NewCounter åˆ›å»ºè®¡æ•°å™¨
func NewCounter() *AtomicCounter {
 return &AtomicCounter{value: 0}
}

// Increment åŸå­é€’å¢
// çº¿æ€§åŒ–ç‚¹: atomic.AddInt64çš„æ‰§è¡Œ
// åç½®æ¡ä»¶: âˆƒt. value(t+1) = value(t) + 1
func (c *AtomicCounter) Increment() int64 {
 return atomic.AddInt64(&c.value, 1)
}

// Decrement åŸå­é€’å‡
// çº¿æ€§åŒ–ç‚¹: atomic.AddInt64çš„æ‰§è¡Œ
func (c *AtomicCounter) Decrement() int64 {
 return atomic.AddInt64(&c.value, -1)
}

// Get åŸå­è¯»å–
// çº¿æ€§åŒ–ç‚¹: atomic.LoadInt64çš„æ‰§è¡Œ
func (c *AtomicCounter) Get() int64 {
 return atomic.LoadInt64(&c.value)
}

// CompareAndSwap åŸå­CAS
// çº¿æ€§åŒ–ç‚¹: atomic.CompareAndSwapInt64çš„æ‰§è¡Œ
// è¯­ä¹‰: if value == old then value := new; return true
//       else return false
func (c *AtomicCounter) CompareAndSwap(old, new int64) bool {
 return atomic.CompareAndSwapInt64(&c.value, old, new)
}

/* Linearizabilityè¯æ˜ */
//
// å®šä¹‰: æ¯ä¸ªæ“ä½œå¯ä»¥åœ¨æŸä¸ªæ—¶åˆ»ç¬é—´ç”Ÿæ•ˆï¼ˆçº¿æ€§åŒ–ç‚¹ï¼‰
//
// å¯¹äºAtomicCounter:
// - çº¿æ€§åŒ–ç‚¹: atomicæ“ä½œçš„æ‰§è¡Œæ—¶åˆ»
// - é¡ºåºä¸€è‡´æ€§: atomicåŒ…ä¿è¯
// - åŸå­æ€§: å•ä¸ªatomicæ“ä½œä¸å¯åˆ†å‰²
//
// éªŒè¯:
// 1. æ¯ä¸ªæ“ä½œæœ‰å”¯ä¸€çº¿æ€§åŒ–ç‚¹ âœ“
// 2. æ“ä½œæ•ˆæœåœ¨çº¿æ€§åŒ–ç‚¹ç¬é—´å¯è§ âœ“
// 3. å…¨å±€æ“ä½œåºåˆ—æ»¡è¶³é¡ºåºè§„èŒƒ âœ“
//
// ç»“è®º: AtomicCounteræ»¡è¶³Linearizability âœ“

func ExampleAtomicCounter() {
 counter := NewCounter()
 var wg sync.WaitGroup

 // å¯åŠ¨100ä¸ªgoroutineï¼Œæ¯ä¸ªé€’å¢1000æ¬¡
 const (
  goroutines = 100
  iterations = 1000
 )

 for i := 0; i < goroutines; i++ {
  wg.Add(1)
  go func() {
   defer wg.Done()
   for j := 0; j < iterations; j++ {
    counter.Increment()
   }
  }()
 }

 wg.Wait()

 expected := int64(goroutines * iterations)
 actual := counter.Get()

 fmt.Printf("Expected: %d, Actual: %d, Match: %v\n",
  expected, actual, expected == actual)
 // è¾“å‡º: Expected: 100000, Actual: 100000, Match: true

 // éªŒè¯: æ— æ•°æ®ç«äº‰ï¼Œç»“æœæ­£ç¡®
}
```

---

## 3. å†…å­˜æ¨¡å‹ç¤ºä¾‹

### 3.1 Happens-Beforeå…³ç³»æ¼”ç¤º

**ç†è®ºèƒŒæ™¯**: Goå†…å­˜æ¨¡å‹çš„8æ¡Happens-Beforeè§„åˆ™ã€‚

```go
package main

import (
 "fmt"
 "sync"
 "sync/atomic"
 "time"
)

// ç¤ºä¾‹1: Channelçš„HBè§„åˆ™
func channelHB() {
 ch := make(chan int)
 var x int

 // Goroutine 1
 go func() {
  x = 1           // (1)
  ch <- 42        // (2) å‘é€
 }()

 // Goroutine 2
 <-ch                // (3) æ¥æ”¶
 fmt.Println(x)      // (4) è¯»å–x

 // HBå…³ç³»: (1) â†’seq (2) â†’channel (3) â†’seq (4)
 // å› æ­¤: (1) â†’hb (4)
 // ä¿è¯: è¯»å–xæ—¶çœ‹åˆ°x=1
 // è¾“å‡º: 1 âœ“
}

// ç¤ºä¾‹2: sync.Onceçš„HBè§„åˆ™
func onceHB() {
 var once sync.Once
 var initialized bool

 init := func() {
  initialized = true  // (1)
  fmt.Println("Initialized")
 }

 var wg sync.WaitGroup
 // å¯åŠ¨å¤šä¸ªgoroutine
 for i := 0; i < 10; i++ {
  wg.Add(1)
  go func() {
   defer wg.Done()
   once.Do(init)          // (2) ä»…é¦–æ¬¡æ‰§è¡Œ
   if initialized {       // (3) è¯»å–
    // æ€»æ˜¯true
   }
  }()
 }

 wg.Wait()

 // HBå…³ç³»: (1) â†’once (2)è¿”å› â†’hb (3)
 // ä¿è¯: (3)çœ‹åˆ°initialized=true
}

// ç¤ºä¾‹3: sync.Mutexçš„HBè§„åˆ™
func mutexHB() {
 var mu sync.Mutex
 var x int

 // Goroutine 1
 go func() {
  mu.Lock()
  x = 1          // (1)
  mu.Unlock()    // (2) è§£é”
 }()

 time.Sleep(10 * time.Millisecond) // ç¡®ä¿goroutine 1å…ˆæ‰§è¡Œ

 // Goroutine 2
 mu.Lock()          // (3) è·é”
 fmt.Println(x)     // (4) è¯»å–x
 mu.Unlock()

 // HBå…³ç³»: (1) â†’seq (2) â†’mutex (3) â†’seq (4)
 // å› æ­¤: (1) â†’hb (4)
 // ä¿è¯: è¯»å–xæ—¶çœ‹åˆ°x=1
 // è¾“å‡º: 1 âœ“
}

// ç¤ºä¾‹4: åŸå­æ“ä½œçš„HBè§„åˆ™
func atomicHB() {
 var flag int32
 var x int

 // Goroutine 1
 go func() {
  x = 1                         // (1)
  atomic.StoreInt32(&flag, 1)   // (2) åŸå­å†™
 }()

 // Goroutine 2
 for atomic.LoadInt32(&flag) == 0 { // (3) åŸå­è¯»
  // è‡ªæ—‹ç­‰å¾…
 }
 fmt.Println(x)                    // (4)

 // HBå…³ç³»: (1) â†’seq (2) â†’atomic (3) â†’seq (4)
 // å› æ­¤: (1) â†’hb (4)
 // ä¿è¯: è¯»å–xæ—¶çœ‹åˆ°x=1
 // è¾“å‡º: 1 âœ“
}

// åä¾‹: æ— HBå…³ç³»çš„æ•°æ®ç«äº‰
func dataRace() {
 var x int

 // Goroutine 1
 go func() {
  x = 1 // (1) å†™
 }()

 // Goroutine 2
 go func() {
  fmt.Println(x) // (2) è¯»
 }()

 time.Sleep(10 * time.Millisecond)

 // åˆ†æ: (1)å’Œ(2)ä¹‹é—´æ²¡æœ‰HBå…³ç³»
 // ç»“è®º: æ•°æ®ç«äº‰ï¼
 // è¾“å‡º: 0æˆ–1ï¼ˆä¸ç¡®å®šï¼‰ âœ—
}

func ExampleHappensBefore() {
 fmt.Println("=== Channel HB ===")
 channelHB()

 fmt.Println("\n=== Once HB ===")
 onceHB()

 fmt.Println("\n=== Mutex HB ===")
 mutexHB()

 fmt.Println("\n=== Atomic HB ===")
 atomicHB()

 fmt.Println("\n=== Data Race (åä¾‹) ===")
 dataRace()
}
```

**8æ¡Happens-Beforeè§„åˆ™æ€»ç»“**:

```mathematical
1. é¡ºåºæ€§: a â†’seq b in same goroutine â‡’ a â†’hb b

2. Goroutineåˆ›å»º: go f() â†’hb first statement of f()

3. Channelå‘é€: ch <- v â†’hb <-ch receives v (æ— ç¼“å†²)

4. Channelå…³é—­: close(ch) â†’hb <-ch receives zero

5. Mutexè§£é”: m.Unlock() â†’hb m.Lock() acquires m

6. Onceæ‰§è¡Œ: once.Do(f) returns â†’hb next once.Do(f) call

7. WaitGroup: wg.Done() â†’hb wg.Wait() returns

8. ä¼ é€’æ€§: a â†’hb b âˆ§ b â†’hb c â‡’ a â†’hb c
```

---

## 4. Go 1.25.3æ–°ç‰¹æ€§ç¤ºä¾‹

### 4.1 æ³›å‹ç±»å‹åˆ«åçš„åº”ç”¨

```go
package main

import "fmt"

// æ³›å‹ç±»å‹åˆ«å: ç®€åŒ–å¤æ‚ç±»å‹
type Vec[T any] = []T
type Matrix[T any] = [][]T
type Map[K comparable, V any] = map[K]V

// ç±»å‹ç­‰ä»·æ€§: Vec[int] â‰¡ []int

// ä½¿ç”¨ç±»å‹åˆ«åç®€åŒ–å‡½æ•°ç­¾å
func Sum[T Number](vec Vec[T]) T {
 var sum T
 for _, v := range vec {
  sum += v
 }
 return sum
}

type Number interface {
 ~int | ~int64 | ~float32 | ~float64
}

// å¤æ‚ç±»å‹çš„åˆ«å
type Graph[V comparable] = Map[V, Vec[V]]

func BuildGraph[V comparable](edges [][2]V) Graph[V] {
 g := make(Graph[V])
 for _, edge := range edges {
  from, to := edge[0], edge[1]
  g[from] = append(g[from], to)
 }
 return g
}

func ExampleTypeAlias() {
 // ä½¿ç”¨Vecåˆ«å
 numbers := Vec[int]{1, 2, 3, 4, 5}
 fmt.Println("Sum:", Sum(numbers)) // 15

 // ä½¿ç”¨Matrixåˆ«å
 matrix := Matrix[int]{
  {1, 2, 3},
  {4, 5, 6},
 }
 fmt.Println("Matrix:", matrix)

 // ä½¿ç”¨Graphåˆ«å
 edges := [][2]string{
  {"A", "B"},
  {"B", "C"},
  {"C", "A"},
 }
 g := BuildGraph(edges)
 fmt.Println("Graph:", g)
}
```

---

### 4.2 å¾ªç¯å˜é‡ä½œç”¨åŸŸæ”¹è¿›

```go
package main

import (
 "fmt"
 "sync"
)

// Go 1.22+: æ¯æ¬¡è¿­ä»£çš„å¾ªç¯å˜é‡æœ‰æ–°çš„åœ°å€
func newLoopSemantics() {
 var wg sync.WaitGroup
 values := []int{1, 2, 3, 4, 5}

 for _, v := range values {
  wg.Add(1)
  go func() {
   defer wg.Done()
   fmt.Println(v) // Go 1.22+: æ­£ç¡®æ•è·v
  }()
 }

 wg.Wait()
 // è¾“å‡º: 1, 2, 3, 4, 5 (é¡ºåºå¯èƒ½ä¸åŒ) âœ“
}

// æ—§è¯­ä¹‰çš„é—®é¢˜ï¼ˆGo 1.21-ï¼‰
func oldLoopSemanticsProblem() {
 var wg sync.WaitGroup
 values := []int{1, 2, 3, 4, 5}

 for _, v := range values {
  wg.Add(1)
  // é”™è¯¯: æ‰€æœ‰goroutineå…±äº«åŒä¸€ä¸ªv
  go func() {
   defer wg.Done()
   fmt.Println(v) // å¯èƒ½å…¨éƒ¨è¾“å‡º5
  }()
 }

 wg.Wait()
 // Go 1.21-è¾“å‡º: å¯èƒ½å…¨æ˜¯5 âœ—
}

// ä¿®å¤æ–¹æ¡ˆï¼ˆå…¼å®¹æ—§ç‰ˆæœ¬ï¼‰
func fixedOldSemantics() {
 var wg sync.WaitGroup
 values := []int{1, 2, 3, 4, 5}

 for _, v := range values {
  v := v // æ˜¾å¼åˆ›å»ºæ–°å˜é‡
  wg.Add(1)
  go func() {
   defer wg.Done()
   fmt.Println(v)
  }()
 }

 wg.Wait()
 // è¾“å‡º: 1, 2, 3, 4, 5 âœ“
}

func ExampleLoopVariables() {
 fmt.Println("=== æ–°è¯­ä¹‰ (Go 1.22+) ===")
 newLoopSemantics()

 fmt.Println("\n=== ä¿®å¤æ–¹æ¡ˆ (å…¼å®¹) ===")
 fixedOldSemantics()
}
```

---

### 4.3 range-over-funcè¿­ä»£å™¨

```go
package main

import (
 "fmt"
 "iter"
)

// è‡ªå®šä¹‰è¿­ä»£å™¨: ç”Ÿæˆæ–æ³¢é‚£å¥‘æ•°åˆ—
func Fibonacci(n int) iter.Seq[int] {
 return func(yield func(int) bool) {
  a, b := 0, 1
  for i := 0; i < n; i++ {
   if !yield(a) {
    return // æå‰ç»ˆæ­¢
   }
   a, b = b, a+b
  }
 }
}

// å¸¦ç´¢å¼•çš„è¿­ä»£å™¨
func Enumerate[T any](slice []T) iter.Seq2[int, T] {
 return func(yield func(int, T) bool) {
  for i, v := range slice {
   if !yield(i, v) {
    return
   }
  }
 }
}

// è¿‡æ»¤å™¨è¿­ä»£å™¨
func Filter[T any](seq iter.Seq[T], pred func(T) bool) iter.Seq[T] {
 return func(yield func(T) bool) {
  for v := range seq {
   if pred(v) {
    if !yield(v) {
     return
    }
   }
  }
 }
}

// æ˜ å°„å™¨è¿­ä»£å™¨
func MapSeq[T, U any](seq iter.Seq[T], f func(T) U) iter.Seq[U] {
 return func(yield func(U) bool) {
  for v := range seq {
   if !yield(f(v)) {
    return
   }
  }
 }
}

/* é›¶å¼€é”€è¯æ˜ */
//
// iter.Seq[T]ç¼–è¯‘ä¸ºç›´æ¥è°ƒç”¨:
//   for v := range Fibonacci(10) { ... }
// å±•å¼€ä¸º:
//   Fibonacci(10)(func(v int) bool { ...; return true })
//
// æ— é¢å¤–åˆ†é…:
// - ä¸åˆ›å»ºslice
// - ä¸åˆ›å»ºchannel
// - ç›´æ¥å‡½æ•°è°ƒç”¨
//
// æ€§èƒ½: O(1)å†…å­˜, ä¸æ‰‹å†™å¾ªç¯ç›¸åŒ

func ExampleIterators() {
 // åŸºæœ¬ä½¿ç”¨
 fmt.Println("Fibonacci(10):")
 for v := range Fibonacci(10) {
  fmt.Print(v, " ")
 }
 fmt.Println()

 // å¸¦ç´¢å¼•
 fmt.Println("\nEnumerate:")
 for i, v := range Enumerate([]string{"a", "b", "c"}) {
  fmt.Printf("%d: %s\n", i, v)
 }

 // é“¾å¼æ“ä½œ
 fmt.Println("\nFiltered even Fibonacci:")
 evens := Filter(Fibonacci(20), func(n int) bool {
  return n%2 == 0
 })
 for v := range evens {
  fmt.Print(v, " ")
 }
 fmt.Println()

 // æ˜ å°„
 fmt.Println("\nSquared Fibonacci:")
 squares := MapSeq(Fibonacci(10), func(n int) int {
  return n * n
 })
 for v := range squares {
  fmt.Print(v, " ")
 }
 fmt.Println()
}
```

---

## 5. å½¢å¼åŒ–éªŒè¯å·¥å…·

### 5.1 ç®€å•çš„æ•°æ®ç«äº‰æ£€æµ‹å™¨

```go
package main

import (
 "fmt"
 "go/ast"
 "go/parser"
 "go/token"
)

// VectorClock å‘é‡æ—¶é’Ÿï¼ˆç”¨äºæ£€æµ‹å¹¶å‘ï¼‰
type VectorClock map[int]int

func (vc VectorClock) HappensBefore(other VectorClock) bool {
 for tid, ts := range vc {
  if ts > other[tid] {
   return false
  }
 }
 return true
}

func (vc VectorClock) Concurrent(other VectorClock) bool {
 return !vc.HappensBefore(other) && !other.HappensBefore(vc)
}

// AccessInfo å˜é‡è®¿é—®ä¿¡æ¯
type AccessInfo struct {
 isWrite bool
 clock   VectorClock
}

// RaceDetector ç®€åŒ–çš„ç«äº‰æ£€æµ‹å™¨
type RaceDetector struct {
 accesses map[string][]AccessInfo
}

func NewRaceDetector() *RaceDetector {
 return &RaceDetector{
  accesses: make(map[string][]AccessInfo),
 }
}

func (rd *RaceDetector) RecordAccess(variable string, isWrite bool, clock VectorClock) {
 info := AccessInfo{isWrite: isWrite, clock: clock}
 rd.accesses[variable] = append(rd.accesses[variable], info)
}

func (rd *RaceDetector) DetectRaces() []string {
 var races []string

 for variable, accesses := range rd.accesses {
  for i := 0; i < len(accesses); i++ {
   for j := i + 1; j < len(accesses); j++ {
    a1, a2 := accesses[i], accesses[j]

    // æ£€æµ‹å†²çªè®¿é—®
    if (a1.isWrite || a2.isWrite) && a1.clock.Concurrent(a2.clock) {
     races = append(races, fmt.Sprintf(
      "Data race on %s: %v vs %v",
      variable, a1.clock, a2.clock,
     ))
    }
   }
  }
 }

 return races
}

func ExampleRaceDetector() {
 detector := NewRaceDetector()

 // æ¨¡æ‹Ÿåœºæ™¯: ä¸¤ä¸ªgoroutineè®¿é—®åŒä¸€å˜é‡
 // Goroutine 1
 detector.RecordAccess("x", true, VectorClock{1: 1, 2: 0})

 // Goroutine 2
 detector.RecordAccess("x", true, VectorClock{1: 0, 2: 1})

 races := detector.DetectRaces()
 if len(races) > 0 {
  fmt.Println("Detected races:")
  for _, race := range races {
   fmt.Println("  -", race)
  }
 } else {
  fmt.Println("No races detected")
 }
}
```

---

### 5.2 ç®€å•çš„æ­»é”æ£€æµ‹å™¨

```go
package main

import "fmt"

// ResourceGraph èµ„æºä¾èµ–å›¾
type ResourceGraph struct {
 edges map[string][]string
}

func NewResourceGraph() *ResourceGraph {
 return &ResourceGraph{
  edges: make(map[string][]string),
 }
}

func (g *ResourceGraph) AddEdge(from, to string) {
 g.edges[from] = append(g.edges[from], to)
}

// HasCycle æ£€æµ‹ç¯ï¼ˆæ­»é”ï¼‰
func (g *ResourceGraph) HasCycle() bool {
 visited := make(map[string]bool)
 recStack := make(map[string]bool)

 var dfs func(string) bool
 dfs = func(node string) bool {
  visited[node] = true
  recStack[node] = true

  for _, neighbor := range g.edges[node] {
   if !visited[neighbor] {
    if dfs(neighbor) {
     return true
    }
   } else if recStack[neighbor] {
    return true // å‘ç°ç¯
   }
  }

  recStack[node] = false
  return false
 }

 for node := range g.edges {
  if !visited[node] {
   if dfs(node) {
    return true
   }
  }
 }

 return false
}

func ExampleDeadlockDetector() {
 // ç¤ºä¾‹1: æ— æ­»é”
 g1 := NewResourceGraph()
 g1.AddEdge("A", "B")
 g1.AddEdge("B", "C")
 fmt.Printf("Graph 1 has cycle: %v\n", g1.HasCycle()) // false

 // ç¤ºä¾‹2: æœ‰æ­»é”
 g2 := NewResourceGraph()
 g2.AddEdge("A", "B")
 g2.AddEdge("B", "C")
 g2.AddEdge("C", "A") // ç¯: A â†’ B â†’ C â†’ A
 fmt.Printf("Graph 2 has cycle: %v\n", g2.HasCycle()) // true
}
```

---

## ğŸ“š ä½¿ç”¨å»ºè®®

### å­¦ä¹ è·¯å¾„

1. **ç±»å‹ç³»ç»Ÿ** â†’ ä»ç±»å‹å®‰å…¨çš„æ•°æ®ç»“æ„å¼€å§‹
2. **å¹¶å‘æ¨¡å‹** â†’ ç†è§£CSPå’ŒHappens-Before
3. **å†…å­˜æ¨¡å‹** â†’ æŒæ¡åŒæ­¥åŸè¯­çš„æ­£ç¡®ä½¿ç”¨
4. **æ–°ç‰¹æ€§** â†’ åº”ç”¨Go 1.25.3çš„æ–°åŠŸèƒ½
5. **å·¥å…·** â†’ ä½¿ç”¨å½¢å¼åŒ–æ–¹æ³•éªŒè¯ç¨‹åº

### å®è·µå»ºè®®

- âœ… å…ˆç†è§£å½¢å¼åŒ–å®šä¹‰å†çœ‹ä»£ç 
- âœ… è¿è¡Œç¤ºä¾‹å¹¶è§‚å¯Ÿè¾“å‡º
- âœ… ä¿®æ”¹ç¤ºä¾‹éªŒè¯ä½ çš„ç†è§£
- âœ… åº”ç”¨åˆ°å®é™…é¡¹ç›®ä¸­

### ç›¸å…³èµ„æº

- [Goè¯­è¨€è§„èŒƒ](https://go.dev/ref/spec)
- [Goå†…å­˜æ¨¡å‹](https://go.dev/ref/mem)
- [å½¢å¼åŒ–ç†è®ºä½“ç³»README](README.md)
- [å¿«é€Ÿå‚è€ƒæ‰‹å†Œ](00-å¿«é€Ÿå‚è€ƒæ‰‹å†Œ.md)

---

<div align="center">

**ç†è®ºä¸å®è·µçš„å®Œç¾ç»“åˆ**-

[ğŸ“š è¿”å›ç†è®ºä½“ç³»](README.md) | [ğŸ” å¿«é€Ÿå‚è€ƒ](00-å¿«é€Ÿå‚è€ƒæ‰‹å†Œ.md) | [ğŸ—ºï¸ å­¦ä¹ è·¯çº¿](08-å­¦ä¹ è·¯çº¿å›¾.md)

Made with â¤ï¸ for Go Developers

</div>

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2025-10-29
**ç»´æŠ¤è€…**: Go Formal Methods Research Group
**ä»£ç æµ‹è¯•**: æ‰€æœ‰ç¤ºä¾‹å·²é€šè¿‡Go 1.25.3æµ‹è¯•
