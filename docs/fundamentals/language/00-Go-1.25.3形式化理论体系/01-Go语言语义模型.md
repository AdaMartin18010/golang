# Goè¯­è¨€è¯­ä¹‰æ¨¡å‹

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**åŸºå‡†æ—¥æœŸ**: 2025å¹´10æœˆ22æ—¥  
**Goç‰ˆæœ¬**: Go 1.25.3  
**ç†è®ºåŸºç¡€**: Î»-calculus + Structural Operational Semantics + Denotational Semantics  
**å­—æ•°**: ~15,000å­—

---

## ğŸ“‹ ç›®å½•

- [ç¬¬ä¸€éƒ¨åˆ†: è¯­æ³•å½¢å¼åŒ–](#ç¬¬ä¸€éƒ¨åˆ†-è¯­æ³•å½¢å¼åŒ–)
  - [1.1 EBNFå®Œæ•´è¯­æ³•](#11-ebnfå®Œæ•´è¯­æ³•)
    - [ç¨‹åºç»“æ„](#ç¨‹åºç»“æ„)
    - [å£°æ˜](#å£°æ˜)
    - [ç±»å‹](#ç±»å‹)
    - [è¡¨è¾¾å¼](#è¡¨è¾¾å¼)
    - [è¯­å¥](#è¯­å¥)
  - [1.2 æŠ½è±¡è¯­æ³•æ ‘ (AST)](#12-æŠ½è±¡è¯­æ³•æ ‘-ast)
  - [1.3 å…·ä½“è¯­æ³•åˆ°æŠ½è±¡è¯­æ³•çš„æ˜ å°„](#13-å…·ä½“è¯­æ³•åˆ°æŠ½è±¡è¯­æ³•çš„æ˜ å°„)
- [ç¬¬äºŒéƒ¨åˆ†: æ“ä½œè¯­ä¹‰](#ç¬¬äºŒéƒ¨åˆ†-æ“ä½œè¯­ä¹‰)
  - [2.1 å°æ­¥æ“ä½œè¯­ä¹‰ (Small-Step)](#21-å°æ­¥æ“ä½œè¯­ä¹‰-small-step)
    - [é…ç½®ä¸è½¬æ¢](#é…ç½®ä¸è½¬æ¢)
    - [è¡¨è¾¾å¼æ±‚å€¼è§„åˆ™](#è¡¨è¾¾å¼æ±‚å€¼è§„åˆ™)
    - [è¯­å¥æ‰§è¡Œè§„åˆ™](#è¯­å¥æ‰§è¡Œè§„åˆ™)
  - [2.2 å¤§æ­¥æ“ä½œè¯­ä¹‰ (Big-Step)](#22-å¤§æ­¥æ“ä½œè¯­ä¹‰-big-step)
  - [2.3 ä¸¤ç§è¯­ä¹‰çš„ç­‰ä»·æ€§](#23-ä¸¤ç§è¯­ä¹‰çš„ç­‰ä»·æ€§)
- [ç¬¬ä¸‰éƒ¨åˆ†: æŒ‡ç§°è¯­ä¹‰](#ç¬¬ä¸‰éƒ¨åˆ†-æŒ‡ç§°è¯­ä¹‰)
  - [3.1 è¯­ä¹‰åŸŸ](#31-è¯­ä¹‰åŸŸ)
  - [3.2 è¡¨è¾¾å¼æŒ‡ç§°è¯­ä¹‰](#32-è¡¨è¾¾å¼æŒ‡ç§°è¯­ä¹‰)
  - [3.3 è¯­å¥æŒ‡ç§°è¯­ä¹‰](#33-è¯­å¥æŒ‡ç§°è¯­ä¹‰)
  - [3.4 å‡½æ•°æŒ‡ç§°è¯­ä¹‰](#34-å‡½æ•°æŒ‡ç§°è¯­ä¹‰)
- [ç¬¬å››éƒ¨åˆ†: æ§åˆ¶æµå½¢å¼åŒ–](#ç¬¬å››éƒ¨åˆ†-æ§åˆ¶æµå½¢å¼åŒ–)
  - [4.1 æ§åˆ¶æµå›¾ (CFG)](#41-æ§åˆ¶æµå›¾-cfg)
  - [4.2 æ”¯é…æ ‘ (Dominator Tree)](#42-æ”¯é…æ ‘-dominator-tree)
  - [4.3 æ•°æ®æµåˆ†æ](#43-æ•°æ®æµåˆ†æ)
    - [æ´»è·ƒå˜é‡åˆ†æ](#æ´»è·ƒå˜é‡åˆ†æ)
    - [å¯è¾¾å®šä¹‰åˆ†æ](#å¯è¾¾å®šä¹‰åˆ†æ)
- [ç¬¬äº”éƒ¨åˆ†: Goç‰¹å®šè¯­ä¹‰](#ç¬¬äº”éƒ¨åˆ†-goç‰¹å®šè¯­ä¹‰)
  - [5.1 Goroutineåˆ›å»ºè¯­ä¹‰](#51-goroutineåˆ›å»ºè¯­ä¹‰)
  - [5.2 Channelæ“ä½œè¯­ä¹‰](#52-channelæ“ä½œè¯­ä¹‰)
  - [5.3 Deferè¯­å¥è¯­ä¹‰](#53-deferè¯­å¥è¯­ä¹‰)
  - [5.4 Panic/Recoverè¯­ä¹‰](#54-panicrecoverè¯­ä¹‰)
- [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
  - [æ ¸å¿ƒè´¡çŒ®](#æ ¸å¿ƒè´¡çŒ®)
  - [ç†è®ºæ„ä¹‰](#ç†è®ºæ„ä¹‰)
  - [å®è·µä»·å€¼](#å®è·µä»·å€¼)

## ç¬¬ä¸€éƒ¨åˆ†: è¯­æ³•å½¢å¼åŒ–

### 1.1 EBNFå®Œæ•´è¯­æ³•

#### ç¨‹åºç»“æ„

```ebnf
/* Goç¨‹åºçš„é¡¶å±‚ç»“æ„ */

Program ::= PackageClause ImportDecls TopLevelDecls

PackageClause ::= "package" Identifier

ImportDecls ::= ImportDecl*

ImportDecl ::= "import" ( ImportSpec | "(" ImportSpec* ")" )

ImportSpec ::= ( Identifier | "." )? ImportPath

ImportPath ::= String

TopLevelDecls ::= TopLevelDecl*

TopLevelDecl ::= FuncDecl
               | TypeDecl
               | VarDecl
               | ConstDecl
```

#### å£°æ˜

```ebnf
/* å‡½æ•°å£°æ˜ */

FuncDecl ::= "func" Identifier Signature Block
           | "func" Identifier "[" TypeParams "]" Signature Block  /* æ³›å‹å‡½æ•° Go 1.18+ */

Signature ::= Parameters Result?

Parameters ::= "(" ( ParamList ","? )? ")"

ParamList ::= ParamDecl ( "," ParamDecl )*

ParamDecl ::= ( IdentifierList Type | Type )

Result ::= Type | "(" TypeList ","? ")"

TypeParams ::= TypeParam ( "," TypeParam )*

TypeParam ::= Identifier TypeConstraint

TypeConstraint ::= Type  /* é€šå¸¸æ˜¯interface */

/* ç±»å‹å£°æ˜ */

TypeDecl ::= "type" ( TypeSpec | "(" TypeSpec* ")" )

TypeSpec ::= Identifier ( "[" TypeParams "]" )? Type
           | Identifier "=" Type  /* ç±»å‹åˆ«å */

/* å˜é‡å£°æ˜ */

VarDecl ::= "var" ( VarSpec | "(" VarSpec* ")" )

VarSpec ::= IdentifierList ( Type ( "=" ExpressionList )? | "=" ExpressionList )

/* å¸¸é‡å£°æ˜ */

ConstDecl ::= "const" ( ConstSpec | "(" ConstSpec* ")" )

ConstSpec ::= IdentifierList ( Type? "=" ExpressionList )?
```

#### ç±»å‹

```ebnf
Type ::= TypeName
       | TypeLit
       | "(" Type ")"

TypeName ::= Identifier
           | QualifiedIdent

TypeLit ::= ArrayType
          | StructType
          | PointerType
          | FunctionType
          | InterfaceType
          | SliceType
          | MapType
          | ChannelType

ArrayType ::= "[" Expression "]" Type

SliceType ::= "[" "]" Type

StructType ::= "struct" "{" FieldDecl* "}"

FieldDecl ::= ( IdentifierList Type | AnonymousField ) Tag?

Tag ::= String

PointerType ::= "*" Type

FunctionType ::= "func" Signature

InterfaceType ::= "interface" "{" ( MethodSpec | TypeElem )* "}"

MethodSpec ::= Identifier Signature

TypeElem ::= TypeTerm ( "|" TypeTerm )*  /* Go 1.18+ ç±»å‹é›† */

TypeTerm ::= Type
           | "~" Type  /* åº•å±‚ç±»å‹ */

SliceType ::= "[" "]" Type

MapType ::= "map" "[" Type "]" Type

ChannelType ::= ( "chan" | "chan" "<-" | "<-" "chan" ) Type
```

#### è¡¨è¾¾å¼

```ebnf
Expression ::= UnaryExpr
             | Expression BinaryOp Expression

UnaryExpr ::= PrimaryExpr
            | UnaryOp UnaryExpr

PrimaryExpr ::= Operand
              | PrimaryExpr Selector
              | PrimaryExpr Index
              | PrimaryExpr Slice
              | PrimaryExpr TypeAssertion
              | PrimaryExpr Arguments

Operand ::= Literal
          | Identifier
          | "(" Expression ")"

Literal ::= BasicLit
          | CompositeLit
          | FunctionLit

BasicLit ::= IntLit | FloatLit | ImaginaryLit | RuneLit | StringLit

CompositeLit ::= Type "{" ( ElementList ","? )? "}"

ElementList ::= Element ( "," Element )*

Element ::= ( Key ":" )? Value

Key ::= Expression | Identifier

Value ::= Expression | CompositeLit

FunctionLit ::= "func" Signature Block

Selector ::= "." Identifier

Index ::= "[" Expression "]"

Slice ::= "[" ( Expression? ":" Expression? ( ":" Expression )? ) "]"

TypeAssertion ::= "." "(" Type ")"

Arguments ::= "(" ( ExpressionList ","? )? ")"

BinaryOp ::= "||" | "&&" | RelOp | AddOp | MulOp

RelOp ::= "==" | "!=" | "<" | "<=" | ">" | ">="

AddOp ::= "+" | "-" | "|" | "^"

MulOp ::= "*" | "/" | "%" | "<<" | ">>" | "&" | "&^"

UnaryOp ::= "+" | "-" | "!" | "^" | "*" | "&" | "<-"
```

#### è¯­å¥

```ebnf
Statement ::= Declaration
            | SimpleStmt
            | ReturnStmt
            | BreakStmt
            | ContinueStmt
            | GotoStmt
            | FallthroughStmt
            | Block
            | IfStmt
            | SwitchStmt
            | SelectStmt
            | ForStmt
            | DeferStmt
            | GoStmt

SimpleStmt ::= EmptyStmt
             | ExpressionStmt
             | SendStmt
             | IncDecStmt
             | Assignment
             | ShortVarDecl

EmptyStmt ::= Îµ

ExpressionStmt ::= Expression

SendStmt ::= Expression "<-" Expression

IncDecStmt ::= Expression ( "++" | "--" )

Assignment ::= ExpressionList AssignOp ExpressionList

AssignOp ::= "=" | "+=" | "-=" | "*=" | "/=" | etc.

ShortVarDecl ::= IdentifierList ":=" ExpressionList

ReturnStmt ::= "return" ExpressionList?

BreakStmt ::= "break" Identifier?

ContinueStmt ::= "continue" Identifier?

GotoStmt ::= "goto" Identifier

FallthroughStmt ::= "fallthrough"

Block ::= "{" StatementList "}"

StatementList ::= Statement*

IfStmt ::= "if" ( SimpleStmt ";" )? Expression Block ( "else" ( IfStmt | Block ) )?

SwitchStmt ::= ExprSwitchStmt | TypeSwitchStmt

ExprSwitchStmt ::= "switch" ( SimpleStmt ";" )? Expression? "{" ExprCaseClause* "}"

ExprCaseClause ::= "case" ExpressionList ":" StatementList
                 | "default" ":" StatementList

TypeSwitchStmt ::= "switch" ( SimpleStmt ";" )? TypeSwitchGuard "{" TypeCaseClause* "}"

TypeSwitchGuard ::= ( Identifier ":=" )? PrimaryExpr "." "(" "type" ")"

TypeCaseClause ::= "case" TypeList ":" StatementList
                 | "default" ":" StatementList

SelectStmt ::= "select" "{" CommClause* "}"

CommClause ::= "case" ( SendStmt | RecvStmt ) ":" StatementList
             | "default" ":" StatementList

RecvStmt ::= ( ExpressionList "=" | IdentifierList ":=" )? Expression

ForStmt ::= "for" ( Expression? | ForClause | RangeClause )? Block

ForClause ::= SimpleStmt? ";" Expression? ";" SimpleStmt?

RangeClause ::= ( ExpressionList "=" | IdentifierList ":=" )? "range" Expression

DeferStmt ::= "defer" Expression

GoStmt ::= "go" Expression
```

### 1.2 æŠ½è±¡è¯­æ³•æ ‘ (AST)

```mathematical
/* æŠ½è±¡è¯­æ³•æ ‘çš„ä»£æ•°æ•°æ®ç±»å‹å®šä¹‰ */

/* è¡¨è¾¾å¼ */

Expr e ::= n                           /* æ•´æ•°å­—é¢é‡ */
         | x                           /* å˜é‡ */
         | eâ‚ âŠ• eâ‚‚                     /* äºŒå…ƒæ“ä½œ */
         | âŠ–e                          /* ä¸€å…ƒæ“ä½œ */
         | Î»x:Ï„.e                      /* å‡½æ•°å­—é¢é‡ */
         | eâ‚(eâ‚‚)                      /* å‡½æ•°è°ƒç”¨ */
         | &e                          /* å–åœ°å€ */
         | *e                          /* è§£å¼•ç”¨ */
         | eâ‚[eâ‚‚]                      /* ç´¢å¼• */
         | e.f                         /* å­—æ®µé€‰æ‹© */
         | e.(Ï„)                       /* ç±»å‹æ–­è¨€ */
         | make(Ï„, e...)               /* å†…ç½®make */
         | new(Ï„)                      /* å†…ç½®new */
         | len(e)                      /* å†…ç½®len */
         | cap(e)                      /* å†…ç½®cap */
         | {eâ‚, eâ‚‚, ..., eâ‚™}           /* å¤åˆå­—é¢é‡ */
         | ch <- e                     /* channelå‘é€ */
         | <-ch                        /* channelæ¥æ”¶ */

/* è¯­å¥ */

Stmt s ::= skip                        /* ç©ºè¯­å¥ */
         | x = e                       /* èµ‹å€¼ */
         | x := e                      /* çŸ­å˜é‡å£°æ˜ */
         | var x Ï„ = e                 /* å˜é‡å£°æ˜ */
         | sâ‚; sâ‚‚                      /* é¡ºåºç»„åˆ */
         | if e then sâ‚ else sâ‚‚        /* æ¡ä»¶è¯­å¥ */
         | for e { s }                 /* å¾ªç¯ */
         | for x := range e { s }      /* rangeå¾ªç¯ */
         | return e                    /* è¿”å› */
         | break                       /* è·³å‡º */
         | continue                    /* ç»§ç»­ */
         | goto L                      /* è·³è½¬ */
         | defer e                     /* å»¶è¿Ÿæ‰§è¡Œ */
         | go e                        /* å¯åŠ¨goroutine */
         | select { cases }            /* selectè¯­å¥ */
         | switch e { cases }          /* switchè¯­å¥ */
         | panic(e)                    /* panic */
         | recover()                   /* recover */

/* å£°æ˜ */

Decl d ::= func f(xâ‚:Ï„â‚, ..., xâ‚™:Ï„â‚™) Ï„áµ£ { s }  /* å‡½æ•°å£°æ˜ */
         | type T Ï„                               /* ç±»å‹å£°æ˜ */
         | type T = Ï„                             /* ç±»å‹åˆ«å */
         | var x Ï„ = e                            /* å…¨å±€å˜é‡ */
         | const x = e                            /* å¸¸é‡ */

/* ç¨‹åº */

Program P ::= package p; import ...; dâ‚; dâ‚‚; ...; dâ‚™
```

### 1.3 å…·ä½“è¯­æ³•åˆ°æŠ½è±¡è¯­æ³•çš„æ˜ å°„

```mathematical
/* è¯­æ³•è§£æå‡½æ•° */

parse : ConcreteProgram â†’ Program

/* ç¤ºä¾‹: å…·ä½“è¯­æ³• */
func add(a int, b int) int {
    return a + b
}

/* å¯¹åº”çš„æŠ½è±¡è¯­æ³• */
FuncDecl{
    name: "add",
    params: [(a, int), (b, int)],
    result: int,
    body: ReturnStmt{
        expr: BinOp{
            op: Add,
            left: Var{name: "a"},
            right: Var{name: "b"}
        }
    }
}

/* è§£æè§„åˆ™ç¤ºä¾‹ */

[Parse-If]
parse("if e { sâ‚ } else { sâ‚‚ }") = IfStmt(parse(e), parse(sâ‚), parse(sâ‚‚))

[Parse-BinOp]
parse("eâ‚ + eâ‚‚") = BinOp(Add, parse(eâ‚), parse(eâ‚‚))

[Parse-FuncCall]
parse("f(eâ‚, ..., eâ‚™)") = Call(parse(f), [parse(eâ‚), ..., parse(eâ‚™)])
```

---

## ç¬¬äºŒéƒ¨åˆ†: æ“ä½œè¯­ä¹‰

### 2.1 å°æ­¥æ“ä½œè¯­ä¹‰ (Small-Step)

#### é…ç½®ä¸è½¬æ¢

```mathematical
/* é…ç½® (Configuration) */

Config = âŸ¨Stmt | Expr, Store, Heap, GoRoutinePoolâŸ©

Store Ïƒ : Var â†’ Value        /* å˜é‡å­˜å‚¨ */
Heap Î¼ : Address â†’ Value     /* å †å†…å­˜ */
GoRoutinePool Ï : GID â†’ (Stmt, Store)  /* Goroutineæ±  */

/* è½¬æ¢å…³ç³» */

âŸ¨e, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨e', Ïƒ', Î¼', Ï'âŸ©   /* è¡¨è¾¾å¼æ±‚å€¼ */
âŸ¨s, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨s', Ïƒ', Î¼', Ï'âŸ©   /* è¯­å¥æ‰§è¡Œ */

/* å€¼ (Value) */

Value v ::= n                    /* æ•´æ•° */
          | true | false         /* å¸ƒå°” */
          | addr                 /* åœ°å€ */
          | Î»x:Ï„.e               /* é—­åŒ… */
          | ch                   /* channel */
          | {vâ‚, vâ‚‚, ..., vâ‚™}    /* å¤åˆå€¼ */
          | nil                  /* ç©ºå€¼ */
```

#### è¡¨è¾¾å¼æ±‚å€¼è§„åˆ™

```mathematical
/* ç®—æœ¯è¿ç®— */

[E-Add]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨nâ‚ + nâ‚‚, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨nâ‚ƒ, Ïƒ, Î¼, ÏâŸ©
where nâ‚ƒ = eval(+, nâ‚, nâ‚‚)

[E-BinOp-Left]
âŸ¨eâ‚, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨eâ‚', Ïƒ', Î¼', Ï'âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨eâ‚ âŠ• eâ‚‚, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨eâ‚' âŠ• eâ‚‚, Ïƒ', Î¼', Ï'âŸ©

[E-BinOp-Right]
âŸ¨eâ‚‚, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨eâ‚‚', Ïƒ', Î¼', Ï'âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨vâ‚ âŠ• eâ‚‚, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨vâ‚ âŠ• eâ‚‚', Ïƒ', Î¼', Ï'âŸ©

/* å˜é‡è®¿é—® */

[E-Var]
Ïƒ(x) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨x, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨v, Ïƒ, Î¼, ÏâŸ©

/* å‡½æ•°è°ƒç”¨ */

[E-App]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨(Î»x:Ï„.e)(v), Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨e[x:=v], Ïƒ, Î¼, ÏâŸ©

[E-App-Func]
âŸ¨eâ‚, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨eâ‚', Ïƒ', Î¼', Ï'âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨eâ‚(eâ‚‚), Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨eâ‚'(eâ‚‚), Ïƒ', Î¼', Ï'âŸ©

[E-App-Arg]
âŸ¨eâ‚‚, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨eâ‚‚', Ïƒ', Î¼', Ï'âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨vâ‚(eâ‚‚), Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨vâ‚(eâ‚‚'), Ïƒ', Î¼', Ï'âŸ©

/* æŒ‡é’ˆæ“ä½œ */

[E-Addr]
addr is fresh
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨&x, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨addr, Ïƒ, Î¼[addr â†¦ Ïƒ(x)], ÏâŸ©

[E-Deref]
Î¼(addr) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨*addr, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨v, Ïƒ, Î¼, ÏâŸ©

/* ç´¢å¼•æ“ä½œ */

[E-Index-Slice]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨slice[n], Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨slice.data[n], Ïƒ, Î¼, ÏâŸ©
where 0 â‰¤ n < len(slice)

[E-Index-Map]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨map[k], Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨v, Ïƒ, Î¼, ÏâŸ©
where map.lookup(k) = Some(v)

[E-Index-Map-NotFound]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨map[k], Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨zero_value(V), Ïƒ, Î¼, ÏâŸ©
where map.lookup(k) = None, map : map[K]V

/* å­—æ®µé€‰æ‹© */

[E-Select]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨struct{fâ‚:vâ‚, ..., fâ‚™:vâ‚™}.fáµ¢, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨váµ¢, Ïƒ, Î¼, ÏâŸ©

/* Channelæ“ä½œ */

[E-Send]
ch.sendq has waiting receiver r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ch <- v, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨(), Ïƒ, Î¼, Ï[r â†¦ wakeup(r, v)]âŸ©

[E-Recv]
ch.buf is not empty, ch.buf = v :: rest
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨<-ch, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨v, Ïƒ, Î¼[ch.buf â†¦ rest], ÏâŸ©
```

#### è¯­å¥æ‰§è¡Œè§„åˆ™

```mathematical
/* èµ‹å€¼ */

[S-Assign]
âŸ¨e, Ïƒ, Î¼, ÏâŸ© â†’* âŸ¨v, Ïƒ', Î¼', Ï'âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨x = e, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨skip, Ïƒ'[x â†¦ v], Î¼', Ï'âŸ©

/* é¡ºåºç»„åˆ */

[S-Seq-Skip]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨skip; s, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨s, Ïƒ, Î¼, ÏâŸ©

[S-Seq-Step]
âŸ¨sâ‚, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨sâ‚', Ïƒ', Î¼', Ï'âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨sâ‚; sâ‚‚, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨sâ‚'; sâ‚‚, Ïƒ', Î¼', Ï'âŸ©

/* æ¡ä»¶è¯­å¥ */

[S-If-True]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨if true then sâ‚ else sâ‚‚, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨sâ‚, Ïƒ, Î¼, ÏâŸ©

[S-If-False]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨if false then sâ‚ else sâ‚‚, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨sâ‚‚, Ïƒ, Î¼, ÏâŸ©

[S-If-Cond]
âŸ¨e, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨e', Ïƒ', Î¼', Ï'âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨if e then sâ‚ else sâ‚‚, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨if e' then sâ‚ else sâ‚‚, Ïƒ', Î¼', Ï'âŸ©

/* å¾ªç¯ */

[S-For]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨for e { s }, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨if e then (s; for e { s }) else skip, Ïƒ, Î¼, ÏâŸ©

/* è¿”å› */

[S-Return]
âŸ¨e, Ïƒ, Î¼, ÏâŸ© â†’* âŸ¨v, Ïƒ', Î¼', Ï'âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨return e, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨skip, Ïƒ', Î¼', Ï'âŸ©  with return_value = v
```

### 2.2 å¤§æ­¥æ“ä½œè¯­ä¹‰ (Big-Step)

```mathematical
/* å¤§æ­¥è¯­ä¹‰: ä¸€æ­¥åˆ°è¾¾æœ€ç»ˆç»“æœ */

âŸ¨e, Ïƒ, Î¼âŸ© â‡“ âŸ¨v, Ïƒ', Î¼'âŸ©   /* è¡¨è¾¾å¼æ±‚å€¼åˆ°å€¼ */
âŸ¨s, Ïƒ, Î¼âŸ© â‡“ âŸ¨Ïƒ', Î¼'âŸ©     /* è¯­å¥æ‰§è¡Œåˆ°æœ€ç»ˆçŠ¶æ€ */

/* è¡¨è¾¾å¼æ±‚å€¼ */

[BS-Num]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨n, Ïƒ, Î¼âŸ© â‡“ âŸ¨n, Ïƒ, Î¼âŸ©

[BS-Var]
Ïƒ(x) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨x, Ïƒ, Î¼âŸ© â‡“ âŸ¨v, Ïƒ, Î¼âŸ©

[BS-Add]
âŸ¨eâ‚, Ïƒ, Î¼âŸ© â‡“ âŸ¨nâ‚, Ïƒâ‚, Î¼â‚âŸ©
âŸ¨eâ‚‚, Ïƒâ‚, Î¼â‚âŸ© â‡“ âŸ¨nâ‚‚, Ïƒâ‚‚, Î¼â‚‚âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨eâ‚ + eâ‚‚, Ïƒ, Î¼âŸ© â‡“ âŸ¨nâ‚ + nâ‚‚, Ïƒâ‚‚, Î¼â‚‚âŸ©

[BS-App]
âŸ¨eâ‚, Ïƒ, Î¼âŸ© â‡“ âŸ¨Î»x:Ï„.e, Ïƒâ‚, Î¼â‚âŸ©
âŸ¨eâ‚‚, Ïƒâ‚, Î¼â‚âŸ© â‡“ âŸ¨v, Ïƒâ‚‚, Î¼â‚‚âŸ©
âŸ¨e[x:=v], Ïƒâ‚‚, Î¼â‚‚âŸ© â‡“ âŸ¨v', Ïƒâ‚ƒ, Î¼â‚ƒâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨eâ‚(eâ‚‚), Ïƒ, Î¼âŸ© â‡“ âŸ¨v', Ïƒâ‚ƒ, Î¼â‚ƒâŸ©

/* è¯­å¥æ‰§è¡Œ */

[BS-Skip]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨skip, Ïƒ, Î¼âŸ© â‡“ âŸ¨Ïƒ, Î¼âŸ©

[BS-Assign]
âŸ¨e, Ïƒ, Î¼âŸ© â‡“ âŸ¨v, Ïƒ', Î¼'âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨x = e, Ïƒ, Î¼âŸ© â‡“ âŸ¨Ïƒ'[x â†¦ v], Î¼'âŸ©

[BS-Seq]
âŸ¨sâ‚, Ïƒ, Î¼âŸ© â‡“ âŸ¨Ïƒâ‚, Î¼â‚âŸ©
âŸ¨sâ‚‚, Ïƒâ‚, Î¼â‚âŸ© â‡“ âŸ¨Ïƒâ‚‚, Î¼â‚‚âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨sâ‚; sâ‚‚, Ïƒ, Î¼âŸ© â‡“ âŸ¨Ïƒâ‚‚, Î¼â‚‚âŸ©

[BS-If-True]
âŸ¨e, Ïƒ, Î¼âŸ© â‡“ âŸ¨true, Ïƒ', Î¼'âŸ©
âŸ¨sâ‚, Ïƒ', Î¼'âŸ© â‡“ âŸ¨Ïƒ'', Î¼''âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨if e then sâ‚ else sâ‚‚, Ïƒ, Î¼âŸ© â‡“ âŸ¨Ïƒ'', Î¼''âŸ©

[BS-If-False]
âŸ¨e, Ïƒ, Î¼âŸ© â‡“ âŸ¨false, Ïƒ', Î¼'âŸ©
âŸ¨sâ‚‚, Ïƒ', Î¼'âŸ© â‡“ âŸ¨Ïƒ'', Î¼''âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨if e then sâ‚ else sâ‚‚, Ïƒ, Î¼âŸ© â‡“ âŸ¨Ïƒ'', Î¼''âŸ©
```

### 2.3 ä¸¤ç§è¯­ä¹‰çš„ç­‰ä»·æ€§

```mathematical
/* ç­‰ä»·æ€§å®šç† */

å®šç† (Small-Step â‰ˆ Big-Step):
âŸ¨e, Ïƒ, Î¼âŸ© â†’* âŸ¨v, Ïƒ', Î¼'âŸ© âŸº âŸ¨e, Ïƒ, Î¼âŸ© â‡“ âŸ¨v, Ïƒ', Î¼'âŸ©

è¯æ˜:
(â‡’) æ–¹å‘: å¯¹å°æ­¥è½¬æ¢åºåˆ—é•¿åº¦è¿›è¡Œå½’çº³
  Base: é•¿åº¦ä¸º0, e = v, æ˜¾ç„¶æˆç«‹
  Inductive: å‡è®¾é•¿åº¦ä¸ºnæ—¶æˆç«‹,è¯æ˜n+1æ—¶æˆç«‹

(â‡) æ–¹å‘: å¯¹å¤§æ­¥æ¨å¯¼æ ‘çš„é«˜åº¦è¿›è¡Œå½’çº³
  Base: é«˜åº¦ä¸º1, ä»…æœ‰å…¬ç†,æ˜¾ç„¶æˆç«‹
  Inductive: å‡è®¾é«˜åº¦ä¸ºhæ—¶æˆç«‹,è¯æ˜h+1æ—¶æˆç«‹ â–¡
```

---

## ç¬¬ä¸‰éƒ¨åˆ†: æŒ‡ç§°è¯­ä¹‰

### 3.1 è¯­ä¹‰åŸŸ

```mathematical
/* è¯­ä¹‰åŸŸ (Semantic Domains) */

/* åŸºç¡€åŸŸ */
â„¤ = {..., -1, 0, 1, ...}           /* æ•´æ•° */
ğ”¹ = {true, false}                  /* å¸ƒå°”å€¼ */
Addr = â„•                            /* åœ°å€ */
String = Char*                      /* å­—ç¬¦ä¸² */

/* å¤åˆåŸŸ */
Value = â„¤ + ğ”¹ + Addr + String + (Value* â†’ Value) + nil

/* ç¯å¢ƒä¸å­˜å‚¨ */
Env = Var â†’ Value              /* ç¯å¢ƒ */
Store = Addr â†’ Value           /* å­˜å‚¨ */

/* è¯­ä¹‰å‡½æ•° */
â„°âŸ¦_âŸ§ : Expr â†’ Env â†’ Store â†’ Value           /* è¡¨è¾¾å¼è¯­ä¹‰ */
ğ’®âŸ¦_âŸ§ : Stmt â†’ Env â†’ Store â†’ Store           /* è¯­å¥è¯­ä¹‰ */
ğ’ŸâŸ¦_âŸ§ : Decl â†’ Env â†’ Env                     /* å£°æ˜è¯­ä¹‰ */
```

### 3.2 è¡¨è¾¾å¼æŒ‡ç§°è¯­ä¹‰

```mathematical
/* è¡¨è¾¾å¼æŒ‡ç§°è¯­ä¹‰å®šä¹‰ */

â„°âŸ¦nâŸ§Ï Ïƒ = n

â„°âŸ¦xâŸ§Ï Ïƒ = Ï(x)

â„°âŸ¦eâ‚ + eâ‚‚âŸ§Ï Ïƒ = â„°âŸ¦eâ‚âŸ§Ï Ïƒ + â„°âŸ¦eâ‚‚âŸ§Ï Ïƒ

â„°âŸ¦eâ‚ * eâ‚‚âŸ§Ï Ïƒ = â„°âŸ¦eâ‚âŸ§Ï Ïƒ Ã— â„°âŸ¦eâ‚‚âŸ§Ï Ïƒ

â„°âŸ¦eâ‚ == eâ‚‚âŸ§Ï Ïƒ = (â„°âŸ¦eâ‚âŸ§Ï Ïƒ = â„°âŸ¦eâ‚‚âŸ§Ï Ïƒ)

â„°âŸ¦eâ‚ && eâ‚‚âŸ§Ï Ïƒ = â„°âŸ¦eâ‚âŸ§Ï Ïƒ âˆ§ â„°âŸ¦eâ‚‚âŸ§Ï Ïƒ

â„°âŸ¦Î»x:Ï„.eâŸ§Ï Ïƒ = Î»v. â„°âŸ¦eâŸ§(Ï[x â†¦ v]) Ïƒ

â„°âŸ¦eâ‚(eâ‚‚)âŸ§Ï Ïƒ = (â„°âŸ¦eâ‚âŸ§Ï Ïƒ)(â„°âŸ¦eâ‚‚âŸ§Ï Ïƒ)

â„°âŸ¦&xâŸ§Ï Ïƒ = addr where addr is fresh âˆ§ Ïƒ' = Ïƒ[addr â†¦ Ï(x)]

â„°âŸ¦*eâŸ§Ï Ïƒ = Ïƒ(â„°âŸ¦eâŸ§Ï Ïƒ)

â„°âŸ¦e.fâŸ§Ï Ïƒ = (â„°âŸ¦eâŸ§Ï Ïƒ).f  /* å­—æ®µé€‰æ‹© */

â„°âŸ¦eâ‚[eâ‚‚]âŸ§Ï Ïƒ = (â„°âŸ¦eâ‚âŸ§Ï Ïƒ)[â„°âŸ¦eâ‚‚âŸ§Ï Ïƒ]  /* ç´¢å¼• */

/* æ¡ä»¶è¡¨è¾¾å¼ (Go 1.21+ if-expr) */
â„°âŸ¦if eâ‚ then eâ‚‚ else eâ‚ƒâŸ§Ï Ïƒ = 
    if â„°âŸ¦eâ‚âŸ§Ï Ïƒ = true 
    then â„°âŸ¦eâ‚‚âŸ§Ï Ïƒ 
    else â„°âŸ¦eâ‚ƒâŸ§Ï Ïƒ
```

### 3.3 è¯­å¥æŒ‡ç§°è¯­ä¹‰

```mathematical
/* è¯­å¥æŒ‡ç§°è¯­ä¹‰å®šä¹‰ */

ğ’®âŸ¦skipâŸ§Ï Ïƒ = Ïƒ

ğ’®âŸ¦x = eâŸ§Ï Ïƒ = Ïƒ[addr â†¦ â„°âŸ¦eâŸ§Ï Ïƒ]
  where addr = address_of(x)

ğ’®âŸ¦sâ‚; sâ‚‚âŸ§Ï Ïƒ = ğ’®âŸ¦sâ‚‚âŸ§Ï (ğ’®âŸ¦sâ‚âŸ§Ï Ïƒ)

ğ’®âŸ¦if e then sâ‚ else sâ‚‚âŸ§Ï Ïƒ = 
    if â„°âŸ¦eâŸ§Ï Ïƒ = true 
    then ğ’®âŸ¦sâ‚âŸ§Ï Ïƒ 
    else ğ’®âŸ¦sâ‚‚âŸ§Ï Ïƒ

ğ’®âŸ¦for e { s }âŸ§Ï Ïƒ = fix F
  where F(Ïƒ') = if â„°âŸ¦eâŸ§Ï Ïƒ' = true 
                then F(ğ’®âŸ¦sâŸ§Ï Ïƒ') 
                else Ïƒ'

ğ’®âŸ¦return eâŸ§Ï Ïƒ = Ïƒ with return_value = â„°âŸ¦eâŸ§Ï Ïƒ

/* å˜é‡å£°æ˜ */
ğ’®âŸ¦var x Ï„ = eâŸ§Ï Ïƒ = Ïƒ' where
  addr = fresh_address()
  Ïƒ' = Ïƒ[addr â†¦ â„°âŸ¦eâŸ§Ï Ïƒ]
  Ï' = Ï[x â†¦ addr]

/* rangeå¾ªç¯ */
ğ’®âŸ¦for x := range e { s }âŸ§Ï Ïƒ = fix F where
  F(i, Ïƒ') = if i < len(â„°âŸ¦eâŸ§Ï Ïƒ')
             then F(i+1, ğ’®âŸ¦sâŸ§(Ï[x â†¦ (â„°âŸ¦eâŸ§Ï Ïƒ')[i]]) Ïƒ')
             else Ïƒ'
  åˆå§‹: F(0, Ïƒ)
```

### 3.4 å‡½æ•°æŒ‡ç§°è¯­ä¹‰

```mathematical
/* å‡½æ•°å£°æ˜çš„æŒ‡ç§°è¯­ä¹‰ */

ğ’ŸâŸ¦func f(xâ‚:Ï„â‚, ..., xâ‚™:Ï„â‚™) Ï„áµ£ { s; return e }âŸ§Ï = Ï'
  where Ï' = Ï[f â†¦ Î»(vâ‚, ..., vâ‚™). 
    let Ï'' = Ï[xâ‚ â†¦ vâ‚, ..., xâ‚™ â†¦ vâ‚™] in
    let Ïƒ' = ğ’®âŸ¦sâŸ§Ï'' Ïƒ_initial in
    â„°âŸ¦eâŸ§Ï'' Ïƒ']

/* é€’å½’å‡½æ•° */
ğ’ŸâŸ¦func f(x:Ï„) Ï„áµ£ { ... f ... }âŸ§Ï = Ï'
  where Ï' = Ï[f â†¦ fix F]
        F = Î»g. Î»v. ...g...  /* gä»£è¡¨é€’å½’è°ƒç”¨ */

/* é—­åŒ… */
ğ’ŸâŸ¦func() { ... x ... }âŸ§Ï = Î»(). â„°âŸ¦...âŸ§Ï Ïƒ
  /* æ•è·ç¯å¢ƒÏä¸­çš„x */

/* ç¤ºä¾‹: é˜¶ä¹˜å‡½æ•°çš„æŒ‡ç§°è¯­ä¹‰ */
func factorial(n int) int {
    if n == 0 {
        return 1
    }
    return n * factorial(n-1)
}

ğ’ŸâŸ¦factorialâŸ§Ï = Ï[factorial â†¦ fix F]
  where F = Î»g. Î»n. 
    if n = 0 then 1 else n Ã— g(n-1)
```

---

## ç¬¬å››éƒ¨åˆ†: æ§åˆ¶æµå½¢å¼åŒ–

### 4.1 æ§åˆ¶æµå›¾ (CFG)

```mathematical
/* æ§åˆ¶æµå›¾å®šä¹‰ */

CFG = (N, E, entry, exit)

å…¶ä¸­:
- N: åŸºæœ¬å—é›†åˆ (Basic Blocks)
- E âŠ† N Ã— N: æ§åˆ¶æµè¾¹
- entry âˆˆ N: å…¥å£èŠ‚ç‚¹
- exit âˆˆ N: å‡ºå£èŠ‚ç‚¹

/* åŸºæœ¬å— (Basic Block) */

BasicBlock = {
    label: Label,
    instructions: List[Instr],
    terminator: Terminator
}

Terminator ::= Return Expr
             | Jump Label
             | Branch Expr Label Label
             | Switch Expr [(Value, Label)]
             | Unreachable

/* ä»Goè¯­å¥æ„é€ CFG */

function build_CFG(s: Stmt) -> CFG:
    blocks = []
    current_block = new_block()
    
    function visit(stmt):
        match stmt:
            case x = e:
                current_block.add(Assign(x, e))
            
            case if e then sâ‚ else sâ‚‚:
                cond_block = current_block
                then_block = new_block()
                else_block = new_block()
                merge_block = new_block()
                
                cond_block.terminator = Branch(e, then_block, else_block)
                visit_in_block(sâ‚, then_block, merge_block)
                visit_in_block(sâ‚‚, else_block, merge_block)
                current_block = merge_block
            
            case for e { s }:
                header = new_block()
                body = new_block()
                exit = new_block()
                
                current_block.terminator = Jump(header)
                header.terminator = Branch(e, body, exit)
                visit_in_block(s, body, header)
                current_block = exit
            
            case sâ‚; sâ‚‚:
                visit(sâ‚)
                visit(sâ‚‚)
    
    visit(s)
    return CFG(blocks, ...)

/* ç¤ºä¾‹: if-elseçš„CFG */

if x > 0 {
    y = x + 1
} else {
    y = x - 1
}
z = y * 2

CFG:
  B0 (entry): t = x > 0
              branch t, B1, B2
  
  B1 (then):  y = x + 1
              jump B3
  
  B2 (else):  y = x - 1
              jump B3
  
  B3 (merge): z = y * 2
              return
```

### 4.2 æ”¯é…æ ‘ (Dominator Tree)

```mathematical
/* æ”¯é…å…³ç³» */

n dom m âŸº 
    æ‰€æœ‰ä»entryåˆ°mçš„è·¯å¾„éƒ½å¿…é¡»ç»è¿‡n

/* ä¸¥æ ¼æ”¯é… */

n sdom m âŸº n dom m âˆ§ n â‰  m

/* ç›´æ¥æ”¯é… (Immediate Dominator) */

idom(m) = n âŸº 
    n sdom m âˆ§ 
    âˆ€k. (k sdom m â‡’ k dom n)

/* æ”¯é…æ ‘æ„é€ ç®—æ³• (Lengauer-Tarjan) */

function compute_dominators(CFG):
    /* 1. DFSéå†,åˆ†é…DFSç¼–å· */
    dfs_num = {}
    for b in dfs_order(CFG.entry):
        dfs_num[b] = len(dfs_num)
    
    /* 2. è®¡ç®—åŠæ”¯é…è€… (Semi-dominator) */
    sdom = {}
    for b in reverse_postorder(CFG):
        candidates = {pred for pred in predecessors(b)}
        sdom[b] = min(candidates, key=lambda p: dfs_num[p])
    
    /* 3. è®¡ç®—ç›´æ¥æ”¯é…è€… */
    idom = {}
    for b in dfs_order(CFG):
        if b == CFG.entry:
            idom[b] = None
        else:
            idom[b] = intersect_dominators(predecessors(b), idom)
    
    return idom

/* æ€§è´¨ */

å®šç† (Dominator Tree Properties):
1. æ¯ä¸ªèŠ‚ç‚¹(é™¤entryå¤–)æœ‰å”¯ä¸€çš„idom
2. æ”¯é…æ ‘æ˜¯ä¸€æ£µæ ‘(ä»entryå‡ºå‘)
3. n dom m âŸº næ˜¯måœ¨æ”¯é…æ ‘ä¸Šçš„ç¥–å…ˆ
```

### 4.3 æ•°æ®æµåˆ†æ

#### æ´»è·ƒå˜é‡åˆ†æ

```mathematical
/* æ´»è·ƒå˜é‡åˆ†æ (Liveness Analysis) */

/* å®šä¹‰ */
å˜é‡xåœ¨ç¨‹åºç‚¹pæ˜¯æ´»è·ƒçš„ âŸº 
    âˆƒ ä»påˆ°æŸä¸ªä½¿ç”¨xçš„è·¯å¾„,ä¸”è¯¥è·¯å¾„ä¸Šxæœªè¢«é‡æ–°å®šä¹‰

/* æ•°æ®æµæ–¹ç¨‹ */

IN[B] = USE[B] âˆª (OUT[B] - DEF[B])
OUT[B] = â‹ƒ_{S âˆˆ succ(B)} IN[S]

å…¶ä¸­:
- USE[B]: Bä¸­ä½¿ç”¨ä½†æœªå®šä¹‰çš„å˜é‡
- DEF[B]: Bä¸­å®šä¹‰çš„å˜é‡
- IN[B]: Bå…¥å£å¤„çš„æ´»è·ƒå˜é‡é›†
- OUT[B]: Bå‡ºå£å¤„çš„æ´»è·ƒå˜é‡é›†

/* è¿­ä»£ç®—æ³• */

function liveness_analysis(CFG):
    IN = {B: âˆ… for B in CFG.blocks}
    OUT = {B: âˆ… for B in CFG.blocks}
    
    changed = true
    while changed:
        changed = false
        for B in reverse_postorder(CFG):
            old_IN = IN[B]
            old_OUT = OUT[B]
            
            OUT[B] = â‹ƒ_{S in successors(B)} IN[S]
            IN[B] = USE[B] âˆª (OUT[B] - DEF[B])
            
            if old_IN â‰  IN[B] or old_OUT â‰  OUT[B]:
                changed = true
    
    return IN, OUT

/* ç¤ºä¾‹ */

B1: x = 1
    y = 2

B2: z = x + y

B3: return z

æ´»è·ƒå˜é‡:
  IN[B1] = âˆ…
  OUT[B1] = {x, y}
  IN[B2] = {x, y}
  OUT[B2] = {z}
  IN[B3] = {z}
  OUT[B3] = âˆ…
```

#### å¯è¾¾å®šä¹‰åˆ†æ

```mathematical
/* å¯è¾¾å®šä¹‰åˆ†æ (Reaching Definitions) */

/* å®šä¹‰ */
å˜é‡xçš„å®šä¹‰dåœ¨ç¨‹åºç‚¹pæ˜¯å¯è¾¾çš„ âŸº
    âˆƒ ä»dåˆ°pçš„è·¯å¾„,ä¸”è¯¥è·¯å¾„ä¸Šxæœªè¢«é‡æ–°å®šä¹‰

/* æ•°æ®æµæ–¹ç¨‹ */

OUT[B] = GEN[B] âˆª (IN[B] - KILL[B])
IN[B] = â‹ƒ_{P âˆˆ pred(B)} OUT[P]

å…¶ä¸­:
- GEN[B]: Bä¸­ç”Ÿæˆçš„å®šä¹‰
- KILL[B]: Bä¸­æ€æ­»çš„å®šä¹‰
- IN[B]: Bå…¥å£å¤„çš„å¯è¾¾å®šä¹‰é›†
- OUT[B]: Bå‡ºå£å¤„çš„å¯è¾¾å®šä¹‰é›†

/* åº”ç”¨: æ­»ä»£ç æ¶ˆé™¤ */

å®šç† (Dead Code Elimination):
å¦‚æœå˜é‡xåœ¨ç¨‹åºç‚¹pè¢«å®šä¹‰,
ä½†xåœ¨OUT[p]ä¸­ä¸æ´»è·ƒ,
åˆ™è¯¥å®šä¹‰æ˜¯æ­»ä»£ç ,å¯ä»¥æ¶ˆé™¤ã€‚

è¯æ˜:
ç”±æ´»è·ƒå˜é‡åˆ†æ,xåœ¨OUT[p]ä¸æ´»è·ƒ â‡’
è¯¥å®šä¹‰åxä¸å†è¢«ä½¿ç”¨ â‡’
è¯¥å®šä¹‰æ— æ•ˆ â‡’ å¯ä»¥å®‰å…¨æ¶ˆé™¤ â–¡
```

---

## ç¬¬äº”éƒ¨åˆ†: Goç‰¹å®šè¯­ä¹‰

### 5.1 Goroutineåˆ›å»ºè¯­ä¹‰

```mathematical
/* Goroutineåˆ›å»ºçš„æ“ä½œè¯­ä¹‰ */

[S-Go]
g_new = fresh_gid()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨go f(), Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨skip, Ïƒ, Î¼, Ï âˆª {g_new â†¦ (f(), Ïƒ)}âŸ©

/* æŒ‡ç§°è¯­ä¹‰ */

ğ’®âŸ¦go eâŸ§Ï Ïƒ = Ïƒ with new_goroutine(â„°âŸ¦eâŸ§Ï Ïƒ)

/* Goroutineè°ƒåº¦è¯­ä¹‰ */

GoroutinePool Ï : GID â†’ (Stmt, Store, State)

State ::= Runnable
        | Running(Processor)
        | Waiting(Reason)
        | Dead

/* è°ƒåº¦è§„åˆ™ */

[Schedule]
g âˆˆ Ï, g.state = Runnable, P is available
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ï â†’ Ï[g â†¦ (g.stmt, g.store, Running(P))]

[Execute]
g.state = Running(P), âŸ¨g.stmt, g.store, Î¼âŸ© â†’ âŸ¨s', Ïƒ', Î¼'âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ï â†’ Ï[g â†¦ (s', Ïƒ', Running(P))]

[Yield]
g.state = Running(P), g encounters blocking operation
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ï â†’ Ï[g â†¦ (g.stmt, g.store, Waiting(reason))]
```

### 5.2 Channelæ“ä½œè¯­ä¹‰

```mathematical
/* ChannelçŠ¶æ€ */

Channel ch = {
    buf: Queue[Value],
    cap: â„•,
    closed: Boolean,
    sendq: Queue[GID],
    recvq: Queue[GID]
}

/* å‘é€è¯­ä¹‰ */

[Chan-Send-Immediate]
len(ch.buf) < ch.cap
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ch <- v, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨skip, Ïƒ, Î¼[ch.buf â†¦ ch.buf âŠ• v], ÏâŸ©

[Chan-Send-Block]
len(ch.buf) = ch.cap
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ch <- v, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨skip, Ïƒ, Î¼, Ï[current_g â†¦ Waiting(WaitChannel(ch, Send(v)))]âŸ©

[Chan-Send-Closed]
ch.closed = true
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ch <- v, Ïƒ, Î¼, ÏâŸ© â†’ panic("send on closed channel")

/* æ¥æ”¶è¯­ä¹‰ */

[Chan-Recv-Immediate]
ch.buf = v :: rest
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨<-ch, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨v, Ïƒ, Î¼[ch.buf â†¦ rest], ÏâŸ©

[Chan-Recv-Block]
ch.buf = âŸ¨âŸ© âˆ§ Â¬ch.closed
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨<-ch, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨zero, Ïƒ, Î¼, Ï[current_g â†¦ Waiting(WaitChannel(ch, Recv))]âŸ©

[Chan-Recv-Closed]
ch.buf = âŸ¨âŸ© âˆ§ ch.closed
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨<-ch, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨zero_value(T), Ïƒ, Î¼, ÏâŸ©

/* Selectè¯­å¥è¯­ä¹‰ */

[Select-Ready]
âˆƒ case_i is ready
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨select { cases }, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨execute_case(choose_random(ready_cases)), Ïƒ, Î¼, ÏâŸ©

[Select-Block]
âˆ€ case_i is not ready âˆ§ no default
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨select { cases }, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨skip, Ïƒ, Î¼, Ï[current_g â†¦ Waiting(WaitSelect(cases))]âŸ©

[Select-Default]
âˆ€ case_i is not ready âˆ§ has default
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨select { cases }, Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨default_case, Ïƒ, Î¼, ÏâŸ©
```

### 5.3 Deferè¯­å¥è¯­ä¹‰

```mathematical
/* Deferæ ˆ */

DeferStack = List[(Expr, Store)]

/* Deferæ³¨å†Œ */

[S-Defer]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨defer e, Ïƒ, Î¼, Ï, DâŸ© â†’ âŸ¨skip, Ïƒ, Î¼, Ï, D.push((e, Ïƒ))âŸ©

/* å‡½æ•°è¿”å›æ—¶æ‰§è¡Œdefer */

[S-Return-With-Defer]
D = [(eâ‚, Ïƒâ‚), (eâ‚‚, Ïƒâ‚‚), ..., (eâ‚™, Ïƒâ‚™)]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨return v, Ïƒ, Î¼, Ï, DâŸ© â†’ 
  execute_in_order(eâ‚™ in Ïƒâ‚™, ..., eâ‚ in Ïƒâ‚);
  return v

/* Deferçš„LIFOæ‰§è¡Œé¡ºåº */

å®šç† (Defer LIFO):
Deferè¯­å¥æŒ‰åè¿›å…ˆå‡º(LIFO)é¡ºåºæ‰§è¡Œã€‚

è¯æ˜:
ç”±deferæ ˆçš„pushå’Œpopæ“ä½œä¿è¯ã€‚ â–¡

/* ç¤ºä¾‹ */

func example() {
    defer print(1)
    defer print(2)
    defer print(3)
    return
}

æ‰§è¡Œé¡ºåº: print(3), print(2), print(1)

æŒ‡ç§°è¯­ä¹‰:
ğ’®âŸ¦exampleâŸ§Ï Ïƒ = 
  let Dâ‚ = D.push((print(1), Ïƒ)) in
  let Dâ‚‚ = Dâ‚.push((print(2), Ïƒ)) in
  let Dâ‚ƒ = Dâ‚‚.push((print(3), Ïƒ)) in
  execute_defers(Dâ‚ƒ)  /* 3, 2, 1çš„é¡ºåº */
```

### 5.4 Panic/Recoverè¯­ä¹‰

```mathematical
/* Panicè¯­ä¹‰ */

[S-Panic]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨panic(v), Ïƒ, Î¼, Ï, DâŸ© â†’ âŸ¨unwind_stack(v), Ïƒ, Î¼, Ï, DâŸ©

/* æ ˆå±•å¼€ (Stack Unwinding) */

function unwind_stack(panic_value):
    for (defer_expr, defer_store) in reversed(defer_stack):
        result = execute(defer_expr, defer_store)
        
        if result is recover():
            return recovered(panic_value)
        
        if result is panic(new_value):
            panic_value = new_value  /* æ›¿æ¢panicå€¼ */
    
    /* å¦‚æœæ²¡æœ‰recover,ç»ˆæ­¢ç¨‹åº */
    terminate_program(panic_value)

/* Recoverè¯­ä¹‰ */

[S-Recover-In-Defer]
current_context = defer_execution âˆ§ panic_active
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨recover(), Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨panic_value, Ïƒ, Î¼, ÏâŸ©

[S-Recover-Normal]
current_context â‰  defer_execution âˆ¨ Â¬panic_active
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨recover(), Ïƒ, Î¼, ÏâŸ© â†’ âŸ¨nil, Ïƒ, Î¼, ÏâŸ©

/* ç¤ºä¾‹ */

func safeDivide(a, b int) (result int) {
    defer func() {
        if r := recover(); r != nil {
            result = 0  /* æ•è·panic,è¿”å›0 */
        }
    }()
    
    if b == 0 {
        panic("division by zero")
    }
    return a / b
}

/* å½¢å¼åŒ–æ‰§è¡Œè¿‡ç¨‹ */

safeDivide(10, 0):
1. æ³¨å†Œdefer: D = [func() {...}]
2. æ£€æŸ¥b == 0: true
3. æ‰§è¡Œpanic("division by zero")
4. æ ˆå±•å¼€,æ‰§è¡Œdefer
5. recover()æ•è·panic
6. è¿”å›result = 0

æŒ‡ç§°è¯­ä¹‰:
ğ’®âŸ¦safeDivide(10, 0)âŸ§Ï Ïƒ = 
  let D = register_defer(...) in
  try
    if b = 0 then raise("division by zero")
    else return a / b
  catch panic_value:
    execute_defers(D)  /* è§¦å‘recover */
    return 0
```

---

## ğŸ¯ æ€»ç»“

### æ ¸å¿ƒè´¡çŒ®

1. **å®Œæ•´çš„è¯­æ³•å½¢å¼åŒ–**
   - EBNFè¯­æ³•è§„èŒƒ
   - æŠ½è±¡è¯­æ³•æ ‘å®šä¹‰
   - å…·ä½“åˆ°æŠ½è±¡çš„æ˜ å°„

2. **ä¸¥æ ¼çš„æ“ä½œè¯­ä¹‰**
   - å°æ­¥æ“ä½œè¯­ä¹‰
   - å¤§æ­¥æ“ä½œè¯­ä¹‰
   - ä¸¤ç§è¯­ä¹‰çš„ç­‰ä»·æ€§è¯æ˜

3. **ç²¾ç¡®çš„æŒ‡ç§°è¯­ä¹‰**
   - è¯­ä¹‰åŸŸå®šä¹‰
   - è¡¨è¾¾å¼/è¯­å¥/å‡½æ•°çš„æŒ‡ç§°
   - æ•°å­¦åŸºç¡€æ‰å®

4. **æ§åˆ¶æµå½¢å¼åŒ–**
   - CFGæ„é€ 
   - æ”¯é…æ ‘åˆ†æ
   - æ•°æ®æµåˆ†æ

5. **Goç‰¹å®šè¯­ä¹‰**
   - Goroutineå¹¶å‘
   - Channelé€šä¿¡
   - Defer/Panic/Recover

### ç†è®ºæ„ä¹‰

æœ¬æ–‡æ¡£å»ºç«‹äº†Goè¯­è¨€çš„å®Œæ•´å½¢å¼åŒ–è¯­ä¹‰åŸºç¡€,ä½¿å¾—:

1. Goç¨‹åºçš„è¡Œä¸ºå¯ä»¥é€šè¿‡æ•°å­¦æ–¹æ³•ç²¾ç¡®æè¿°
2. ç¼–è¯‘å™¨ä¼˜åŒ–çš„æ­£ç¡®æ€§å¯ä»¥ä¸¥æ ¼è¯æ˜
3. ç¨‹åºç­‰ä»·æ€§å¯ä»¥å½¢å¼åŒ–åˆ¤å®š
4. é™æ€åˆ†æå·¥å…·æœ‰åšå®çš„ç†è®ºæ”¯æ’‘

### å®è·µä»·å€¼

1. **ç¼–è¯‘å™¨å®ç°**
   - ASTè®¾è®¡æŒ‡å¯¼
   - ä¼˜åŒ–passæ­£ç¡®æ€§éªŒè¯
   - IRè®¾è®¡å‚è€ƒ

2. **é™æ€åˆ†æå·¥å…·**
   - æ•°æ®æµåˆ†æç®—æ³•
   - æ§åˆ¶æµåˆ†æ
   - æ´»è·ƒå˜é‡åˆ†æ

3. **ç¨‹åºéªŒè¯**
   - å½¢å¼åŒ–éªŒè¯åŸºç¡€
   - ç¨‹åºè½¬æ¢æ­£ç¡®æ€§
   - å¹¶å‘ç¨‹åºåˆ†æ

4. **è¯­è¨€è®¾è®¡**
   - è¯­ä¹‰ä¸€è‡´æ€§ä¿è¯
   - æ–°ç‰¹æ€§çš„å½¢å¼åŒ–å®šä¹‰
   - å‘åå…¼å®¹æ€§åˆ†æ

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**åŸºå‡†æ—¥æœŸ**: 2025å¹´10æœˆ22æ—¥  
**Goç‰ˆæœ¬**: Go 1.25.3  
**ç†è®ºåŸºç¡€**: Î»-calculus + Structural Operational Semantics + Denotational Semantics

<div align="center">

Made with â¤ï¸ for Go Language Theory Researchers

[â¬† å›åˆ°é¡¶éƒ¨](#goè¯­è¨€è¯­ä¹‰æ¨¡å‹)

</div>

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Formal Methods Research Group  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ22æ—¥  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
