# Go 1.25.3形式化理论快速参考手册

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---

## 📋 目录

- [📖 使用说明](#使用说明)
- [1️⃣ 语义模型快速参考](#1-语义模型快速参考)
  - [核心语法 (EBNF)](#核心语法-ebnf)
  - [操作语义关键规则](#操作语义关键规则)
  - [控制流关键算法](#控制流关键算法)
- [[2️⃣ CSP并发模型快速参考](#2-csp并发模型快速参考)
  - [CSP基础映射](#csp基础映射)
  - [Goroutine语义](#goroutine语义)
  - [Channel操作](#channel操作)
  - [并发安全定理](#并发安全定理)
- [3[3️⃣ 类型系统快速参考](#3-类型系统快速参考)  - [类型判断规则](#类型判断规则)
  - [接口满足性](#接口满足性)
  - [类型安全定理](#类型安全定理)
  - [泛型约束](#泛型约束)
- [4️[4️⃣ 包管理模型快速参考](#4-包管理模型快速参考) - [MVS算法](#mvs算法)
  - [依赖图操作](#依赖图操作)
  - [Workspace语义](#workspace语义)
- [5️⃣[5️⃣ 运行时与内存模型快速参考](#5-运行时与内存模型快速参考)- [GMP调度](#gmp调度)
  - [Happens-Before关系](#happens-before关系)
  - [GC算法](#gc算法)
  - [原子操作语义](#原子操作语义)
- [6️⃣ [6️⃣ Go 1.25.3新特性快速参考](#6-go-1.25.3新特性快速参考) [泛型类型别名](#泛型类型别名)
  - [循环变量新语义](#循环变量新语义)
  - [range-over-func迭代器](#range-over-func迭代器)
  - [unique.Handle](#unique.handle)
- [7️⃣ 常[7️⃣ 常用证明技巧](#7-常用证明技巧)[归纳法证明](#归纳法证明)
  - [类型安全证明模板](#类型安全证明模板)
  - [并发安全证明模板](#并发安全证明模板)
- [📊 重要定理速查](#重要定理速查)
  - [类型系统]([类型系统](#类型系统)并发模型](#并发模型)
  - [运行时](#5️-运行时与[运行时](#运行时)](#实用工具速查)
  - [静态分析](#静态分析)
  - [竞争检测](#竞争检测)
- [📚 延伸阅读快速索引](#延伸阅读快速索引)
  - [完整文档](#完整文档)
  - [按主题索引](#按主题索引)
- [💡 使用建议](#使用建议)
  - [查阅策略](#查阅策略)
  - [记忆技巧](#记忆技巧)
- [🎯 关键概念速记卡](#关键概念速记卡)
  - [5秒记忆](#5秒记忆)

## 📖 使用说明

本文档是Go 1.25.3形式化理论体系的精华速查手册，提取了7个核心文档中的关键定义、重要定理和常用公式。建议：

1. **学习时**: 配合完整文档深入理解
2. **工作时**: 快速查阅关键概念
3. **面试时**: 复习理论要点

---

## 1️⃣ 语义模型快速参考

### 核心语法 (EBNF)

```ebnf
/* 程序结构 */
Program     ::= Package ImportDecl* TopLevelDecl*
Package     ::= "package" identifier

/* 类型 */
Type        ::= TypeName | TypeLit | "(" Type ")"
TypeLit     ::= ArrayType | StructType | PointerType 
              | FunctionType | InterfaceType | SliceType
              | MapType | ChannelType

/* 表达式 */
Expression  ::= UnaryExpr | Expression binary_op Expression
Statement   ::= Declaration | SimpleStmt | IfStmt 
              | ForStmt | SwitchStmt | SelectStmt | GoStmt
```

### 操作语义关键规则

```mathematical
/* 小步语义 - 变量赋值 */
[E-Assign]
⟨x = v, σ⟩ → σ[x ↦ v]

/* 大步语义 - 函数调用 */
[E-Call]
⟨f(v₁, ..., vₙ), σ⟩ ⇓ ⟨result, σ'⟩

/* Goroutine创建 */
[E-Go]
⟨go f(), σ, ρ⟩ → ⟨(), σ, ρ ∪ {new_goroutine(f)}⟩
```

### 控制流关键算法

```python
# CFG构造
def build_cfg(statements):
    entry = create_node("entry")
    exit = create_node("exit")
    current = entry
    for stmt in statements:
        node = create_node(stmt)
        add_edge(current, node)
        current = node
    add_edge(current, exit)
    return CFG(entry, exit)
```

---

## 2️⃣ CSP并发模型快速参考

### CSP基础映射

| Go原语 | CSP表示 | 说明 |
|--------|---------|------|
| `go f()` | `P ∥ Q` | 并行组合 |
| `ch <- v` | `c!v` | 发送 |
| `v := <-ch` | `c?v` | 接收 |
| `close(ch)` | `close(c)` | 关闭 |
| `select` | `□ᵢ(gᵢ → Pᵢ)` | 非确定性选择 |

### Goroutine语义

```mathematical
/* Goroutine创建 */
[Go-Spawn]
ρ ⊢ go f(args) ⇒ ρ' where ρ' = ρ ∪ {g_new}

/* Goroutine调度 */
[Schedule]
(ρ, ready_queue) → (ρ', ready_queue')
where ∃g ∈ ready_queue: can_run(g)
```

### Channel操作

```mathematical
/* 发送 */
[Ch-Send]
⟨ch <- v, σ, μ⟩ →
  if ch.buffer_full then block
  else ⟨(), σ, μ[ch ↦ append(μ(ch), v)]⟩

/* 接收 */
[Ch-Recv]
⟨v := <-ch, σ, μ⟩ →
  if ch.buffer_empty then block
  else ⟨(), σ[v ↦ head(μ(ch))], μ[ch ↦ tail(μ(ch))]⟩
```

### 并发安全定理

```mathematical
/* 死锁自由性 */
Theorem (Deadlock-Freedom):
∀P ∈ Programs. well_typed(P) ∧ acyclic(dependency_graph(P))
  ⇒ deadlock_free(P)

/* 数据竞争自由 */
Theorem (Race-Freedom):
∀P ∈ Programs. properly_synchronized(P)
  ⇒ ∀x ∈ Vars. ¬∃(e₁, e₂). concurrent(e₁, e₂) ∧ conflicting(e₁, e₂, x)
```

---

## 3️⃣ 类型系统快速参考

### 类型判断规则

```mathematical
/* 变量 */
[T-Var]
x : T ∈ Γ
─────────
Γ ⊢ x : T

/* 函数应用 */
[T-App]
Γ ⊢ f : T₁ → T₂    Γ ⊢ e : T₁
────────────────────────────────
Γ ⊢ f(e) : T₂

/* 泛型实例化 */
[T-Instantiate]
Γ ⊢ f : ∀α:C.T    Γ ⊢ S satisfies C
──────────────────────────────────────
Γ ⊢ f[S] : T[α:=S]
```

### 接口满足性

```mathematical
/* 接口实现 */
[T-Implements]
∀m ∈ methods(I). ∃m' ∈ methods(T).
  name(m) = name(m') ∧ sig(m) = sig(m')
────────────────────────────────────────
Γ ⊢ T implements I
```

### 类型安全定理

```mathematical
/* Progress定理 */
Theorem (Progress):
∅ ⊢ e : T ⇒ (value(e) ∨ ∃e'. e → e')

/* Preservation定理 */
Theorem (Preservation):
Γ ⊢ e : T ∧ e → e' ⇒ Γ ⊢ e' : T
```

### 泛型约束

```go
// 常用约束
type Ordered interface {
    ~int | ~float64 | ~string
}

type Comparable interface {
    comparable
}

type Number interface {
    ~int | ~int64 | ~float32 | ~float64
}
```

---

## 4️⃣ 包管理模型快速参考

### MVS算法

```mathematical
/* MVS核心 */
function MVS(modules, constraints):
    selected = {}
    for each m in modules:
        candidates = filter(versions(m), satisfies(constraints))
        selected[m] = min(candidates)  // 最小版本
    return selected
```

### 依赖图操作

```mathematical
/* 构建依赖图 */
G = (V, E) where
  V = {modules}
  E = {(m₁, m₂) | m₁ requires m₂}

/* 循环检测 */
has_cycle(G) ⟺ ∃path p. source(p) = target(p)
```

### Workspace语义

```mathematical
/* Workspace替换 */
[WS-Replace]
module M requires N@v
workspace contains N@v'
────────────────────────
use N@v' instead of N@v
```

---

## 5️⃣ 运行时与内存模型快速参考

### GMP调度

```mathematical
/* GMP三元组 */
State = (G, M, P) where
  G = set of goroutines
  M = set of OS threads
  P = set of processors

/* Work Stealing */
[Steal]
P₁.queue = []  ∧  P₂.queue = [g₁, ..., gₙ]  ∧  n > 1
────────────────────────────────────────────────────
P₁.queue := take_half(P₂.queue)
```

### Happens-Before关系

```mathematical
/* HB规则 */
1. 顺序性: a →ₛₑq b in same goroutine ⇒ a →ₕb b
2. Go创建: go f() →ₕb first statement of f()
3. Channel发送: ch <- v →ₕb <-ch receives v
4. Close: close(ch) →ₕb <-ch receives zero
5. Mutex: m.Unlock() →ₕb m.Lock() acquires m
6. Once: once.Do(f) →ₕb f() returns
7. WaitGroup: wg.Done() →ₕb wg.Wait() returns
8. 传递性: a →ₕb b ∧ b →ₕb c ⇒ a →ₕb c
```

### GC算法

```mathematical
/* 三色标记 */
White: not reachable (to be collected)
Gray:  reachable but not scanned
Black: reachable and scanned

Invariants:
1. No black → white pointers
2. All gray objects will be scanned
```

### 原子操作语义

```go
// 关键原子操作
atomic.Load(&x)              // 读取
atomic.Store(&x, v)          // 写入
atomic.CompareAndSwap(&x, old, new)  // CAS
atomic.Add(&x, delta)        // 加法
```

---

## 6️⃣ Go 1.25.3新特性快速参考

### 泛型类型别名

```go
// 语法
type Vec[T any] = []T
type Map[K comparable, V any] = map[K]V

// 语义: 类型等价
Vec[int] ≡ []int  // 相同类型
```

### 循环变量新语义

```mathematical
/* 旧语义 (Go 1.21-) */
for i := 0; i < n; i++ {
    // 所有迭代共享同一个i的地址
}

/* 新语义 (Go 1.22+) */
for i := 0; i < n; i++ {
    // 每次迭代i有新的地址
    // 等价于: i_new := i; use(i_new)
}
```

### range-over-func迭代器

```go
// 定义
type Seq[V any] func(yield func(V) bool)

// 使用
for v := range myIterator {
    // 展开为:
    // myIterator(func(v T) bool { ...; return true })
}
```

### unique.Handle

```go
// 全局唯一化
h1 := unique.Make("hello")
h2 := unique.Make("hello")
// h1.value == h2.value  (相同指针)

// 快速比较: O(1)指针比较 vs O(n)字符串比较
```

---

## 7️⃣ 常用证明技巧

### 归纳法证明

```mathematical
/* 结构归纳 */
Prove: P(e) for all expressions e

Base cases:
- P(literal)  ✓
- P(variable) ✓

Inductive cases:
- Assume P(e₁), P(e₂)
- Show P(e₁ op e₂)
```

### 类型安全证明模板

```mathematical
/* Progress */
1. 对e的结构归纳
2. 如果e是值 → 完成
3. 否则使用类型规则找到e → e'

/* Preservation */
1. 对e → e'的推导归纳
2. 对每个规则,使用类型反演
3. 应用归纳假设
4. 重新构造类型推导
```

### 并发安全证明模板

```mathematical
/* Deadlock-Freedom */
1. 构建资源依赖图
2. 证明图是无环的
3. 应用Coffman条件
4. 结论:不可能死锁

/* Race-Freedom */
1. 识别所有共享变量访问
2. 对每对冲突访问(e₁, e₂):
   - 证明e₁ →ₕb e₂ 或 e₂ →ₕb e₁
3. 由HB传递性得出无竞争
```

---

## 📊 重要定理速查

### 类型系统

| 定理 | 陈述 | 意义 |
|------|------|------|
| **Progress** | `∅ ⊢ e : T ⇒ value(e) ∨ ∃e'.e→e'` | 良类型程序不会卡住 |
| **Preservation** | `Γ ⊢ e : T ∧ e→e' ⇒ Γ ⊢ e':T` | 执行保持类型 |
| **Type Safety** | Progress + Preservation | 类型系统正确 |

### 并发模型

| 定理 | 陈述 | 意义 |
|------|------|------|
| **Deadlock-Free** | `well_typed ∧ acyclic → deadlock_free` | 不会死锁 |
| **Race-Free** | `properly_sync → race_free` | 无数据竞争 |
| **Linearizability** | `∃seq. concurrent_exec ≡ seq` | 并发正确性 |

### 运行时

| 定理 | 陈述 | 意义 |
|------|------|------|
| **GC Safety** | `∀reachable. ¬collected` | 不误回收 |
| **GC Liveness** | `∀unreachable. eventually_collected` | 终会回收 |
| **GC Complete** | `terminates ∧ no_leaks` | GC完备 |

---

## 🔧 实用工具速查

### 静态分析

```go
// 数据流分析框架
type DataFlow struct {
    Entry    *BasicBlock
    Exit     *BasicBlock
    Forward  bool
    Join     func(a, b State) State
    Transfer func(b *BasicBlock, in State) State
}

func (df *DataFlow) Analyze() map[*BasicBlock]State {
    worklist := []*BasicBlock{df.Entry}
    in := make(map[*BasicBlock]State)
    
    for len(worklist) > 0 {
        b := worklist[0]
        worklist = worklist[1:]
        
        newIn := df.Join(predecessors(b)...)
        if !equal(in[b], newIn) {
            in[b] = newIn
            out := df.Transfer(b, newIn)
            worklist = append(worklist, successors(b)...)
        }
    }
    return in
}
```

### 竞争检测

```go
// Vector Clock实现
type VectorClock map[int]int

func (vc VectorClock) HappensBefore(other VectorClock) bool {
    for tid, ts := range vc {
        if ts > other[tid] {
            return false
        }
    }
    return true
}

func (vc VectorClock) Concurrent(other VectorClock) bool {
    return !vc.HappensBefore(other) && !other.HappensBefore(vc)
}
```

---

## 📚 延伸阅读快速索引

### 完整文档

1. [01-语义模型](01-Go语言语义模型.md) - EBNF、AST、操作语义详解
2. [02-CSP模型](02-CSP并发模型与形式化证明.md) - 进程代数与并发证明
3. [03-类型系统](03-Go类型系统形式化定义.md) - 类型判断与泛型
4. [04-包管理](04-Modules与Workspace包管理模型.md) - MVS算法详解
5. [05-运行时](05-运行时与内存模型.md) - GMP调度与GC
6. [06-新特性](06-Go-1.25.3新特性形式化分析.md) - Go 1.25.3特性
7. [07-综合案例](07-综合案例与证明.md) - 实际程序验证

### 按主题索引

- **学习语义**: 01 → 02 → 05
- **学习类型**: 03 → 06 (泛型部分)
- **学习并发**: 02 → 05 → 07 (并发案例)
- **学习实践**: 07 全部

---

## 💡 使用建议

### 查阅策略

1. **概念查询**: 使用Ctrl+F快速定位
2. **定理查询**: 跳转到"重要定理速查"
3. **代码示例**: 查看"实用工具速查"
4. **深入学习**: 点击"延伸阅读"链接

### 记忆技巧

1. **语义模型**: EBNF → AST → 操作语义 (从具体到抽象)
2. **CSP模型**: Go原语 → CSP表示 → 性质证明 (从实现到理论)
3. **类型系统**: 规则 → 推导 → 定理 (从局部到整体)
4. **运行时**: GMP → GC → Happens-Before (从调度到内存)

---

## 🎯 关键概念速记卡

### 5秒记忆

- **语义**: 语法→AST→执行
- **CSP**: Go原语→进程代数→证明
- **类型**: 判断规则→Progress+Preservation
- **包管理**: MVS选最小版本
- **运行时**: GMP调度+三色GC+HB关系
- **新特性**: 泛型别名≡原类型,循环变量每次新地址
- **证明**: 归纳法是王道

---

<div align="center">

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

[📚 返回完整文档](README.md) | [🔍 查看完整索引](../../INDEX.md)

Made with ❤️ for Go Developers

</div>

---

**文档版本**: v1.0  
**最后更新**: 2025-10-29  
**维护者**: Go Formal Methods Research Group  
**反馈**: 发现错误? 请提交Issue
