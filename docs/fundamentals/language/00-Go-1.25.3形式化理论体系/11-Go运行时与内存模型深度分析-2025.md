# Go 1.25.3 è¿è¡Œæ—¶ä¸å†…å­˜æ¨¡å‹æ·±åº¦åˆ†æ

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**åŸºå‡†æ—¥æœŸ**: 2025å¹´10æœˆ23æ—¥  
**Goç‰ˆæœ¬**: Go 1.25.3  
**ç†è®ºåŸºç¡€**: Operational Semantics + Memory Models + GC Theory  
**å­—æ•°**: ~20,000å­—

---

## ğŸ“‹ ç›®å½•

- [ç¬¬ä¸€éƒ¨åˆ†: Goè¿è¡Œæ—¶æ¶æ„](#ç¬¬ä¸€éƒ¨åˆ†-goè¿è¡Œæ—¶æ¶æ„)
  - [1.1 è¿è¡Œæ—¶ç»„ä»¶](#11-è¿è¡Œæ—¶ç»„ä»¶)
    - [å½¢å¼åŒ–å®šä¹‰](#å½¢å¼åŒ–å®šä¹‰)
    - [è¿è¡Œæ—¶æ•°æ®ç»“æ„](#è¿è¡Œæ—¶æ•°æ®ç»“æ„)
  - [1.2 ç¨‹åºå¯åŠ¨æµç¨‹](#12-ç¨‹åºå¯åŠ¨æµç¨‹)
    - [å¯åŠ¨åºåˆ—å½¢å¼åŒ–](#å¯åŠ¨åºåˆ—å½¢å¼åŒ–)
    - [å¯åŠ¨æµç¨‹ä»£ç ](#å¯åŠ¨æµç¨‹ä»£ç )
  - [1.3 è¿è¡Œæ—¶ç³»ç»Ÿè°ƒç”¨](#13-è¿è¡Œæ—¶ç³»ç»Ÿè°ƒç”¨)
- [ç¬¬äºŒéƒ¨åˆ†: å†…å­˜æ¨¡å‹](#ç¬¬äºŒéƒ¨åˆ†-å†…å­˜æ¨¡å‹)
  - [2.1 å†…å­˜å¸ƒå±€](#21-å†…å­˜å¸ƒå±€)
    - [è™šæ‹Ÿå†…å­˜å¸ƒå±€](#è™šæ‹Ÿå†…å­˜å¸ƒå±€)
    - [å†…å­˜åˆ†é…å™¨å±‚æ¬¡](#å†…å­˜åˆ†é…å™¨å±‚æ¬¡)
  - [2.2 æ ˆå†…å­˜ç®¡ç†](#22-æ ˆå†…å­˜ç®¡ç†)
    - [æ ˆå¢é•¿æœºåˆ¶](#æ ˆå¢é•¿æœºåˆ¶)
    - [æ ˆç®¡ç†å®ç°](#æ ˆç®¡ç†å®ç°)
  - [2.3 å †å†…å­˜åˆ†é…](#23-å †å†…å­˜åˆ†é…)
    - [åˆ†é…ç­–ç•¥](#åˆ†é…ç­–ç•¥)
    - [åˆ†é…å®ç°](#åˆ†é…å®ç°)
  - [2.4 é€ƒé€¸åˆ†æ](#24-é€ƒé€¸åˆ†æ)
    - [é€ƒé€¸è§„åˆ™](#é€ƒé€¸è§„åˆ™)
    - [é€ƒé€¸åˆ†æç¤ºä¾‹](#é€ƒé€¸åˆ†æç¤ºä¾‹)
- [ç¬¬ä¸‰éƒ¨åˆ†: åƒåœ¾å›æ”¶](#ç¬¬ä¸‰éƒ¨åˆ†-åƒåœ¾å›æ”¶)
  - [3.1 ä¸‰è‰²æ ‡è®°ç®—æ³•](#31-ä¸‰è‰²æ ‡è®°ç®—æ³•)
    - [3.1.1 å½¢å¼åŒ–å®šä¹‰](#311-å½¢å¼åŒ–å®šä¹‰)
    - [æ ‡è®°å®ç°](#æ ‡è®°å®ç°)
  - [3.2 å¹¶å‘GC](#32-å¹¶å‘gc)
    - [å¹¶å‘æ ‡è®°](#å¹¶å‘æ ‡è®°)
  - [3.3 å†™å±éšœ](#33-å†™å±éšœ)
    - [å†™å±éšœç±»å‹](#å†™å±éšœç±»å‹)
    - [å†™å±éšœå®ç°](#å†™å±éšœå®ç°)
  - [3.4 GCè°ƒä¼˜](#34-gcè°ƒä¼˜)
- [ç¬¬å››éƒ¨åˆ†: æ‰§è¡Œè¯­ä¹‰](#ç¬¬å››éƒ¨åˆ†-æ‰§è¡Œè¯­ä¹‰)
  - [4.1 æ“ä½œè¯­ä¹‰](#41-æ“ä½œè¯­ä¹‰)
  - [4.2 æŒ‡ç§°è¯­ä¹‰](#42-æŒ‡ç§°è¯­ä¹‰)
  - [4.3 å…¬ç†è¯­ä¹‰](#43-å…¬ç†è¯­ä¹‰)
- [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
  - [è¿è¡Œæ—¶ç³»ç»Ÿ](#è¿è¡Œæ—¶ç³»ç»Ÿ)
  - [å†…å­˜æ¨¡å‹](#å†…å­˜æ¨¡å‹)
  - [æ‰§è¡Œè¯­ä¹‰](#æ‰§è¡Œè¯­ä¹‰)
  - [ä¼˜åŒ–å»ºè®®](#ä¼˜åŒ–å»ºè®®)

## ç¬¬ä¸€éƒ¨åˆ†: Goè¿è¡Œæ—¶æ¶æ„

### 1.1 è¿è¡Œæ—¶ç»„ä»¶

Goè¿è¡Œæ—¶(runtime)æ˜¯ç¨‹åºæ‰§è¡Œçš„åŸºç¡€è®¾æ–½ã€‚

#### å½¢å¼åŒ–å®šä¹‰

```mathematical
/* Goè¿è¡Œæ—¶ç³»ç»Ÿ */

Runtime = (Scheduler, MemoryManager, GC, NetPoller, SignalHandler)

å…¶ä¸­:
- Scheduler: è°ƒåº¦å™¨ (GMPæ¨¡å‹)
- MemoryManager: å†…å­˜ç®¡ç†å™¨
- GC: åƒåœ¾å›æ”¶å™¨
- NetPoller: ç½‘ç»œè½®è¯¢å™¨
- SignalHandler: ä¿¡å·å¤„ç†å™¨

/* è¿è¡Œæ—¶çŠ¶æ€ */

RuntimeState = (
    Goroutines: Set[G],
    Machines: Set[M],
    Processors: Set[P],
    Heap: HeapMemory,
    Stack: StackMemory,
    GCState: GCPhase
)

/* çŠ¶æ€è½¬æ¢ç³»ç»Ÿ */

(RuntimeState, Event) â†’ RuntimeState'

Events ::= 
    | GoCreate(func)         /* åˆ›å»ºgoroutine */
    | GoExit                 /* goroutineé€€å‡º */
    | GCSweep                /* GCæ¸…æ‰« */
    | MemAlloc(size)         /* å†…å­˜åˆ†é… */
    | MemFree(ptr)           /* å†…å­˜é‡Šæ”¾ */
    | SyscallEnter           /* è¿›å…¥ç³»ç»Ÿè°ƒç”¨ */
    | SyscallExit            /* é€€å‡ºç³»ç»Ÿè°ƒç”¨ */
```

#### è¿è¡Œæ—¶æ•°æ®ç»“æ„

```go
// runtime/runtime2.go

// 1. g (goroutine)
type g struct {
    // Stack
    stack       stack
    stackguard0 uintptr
    stackguard1 uintptr
    
    // Scheduling
    _panic       *_panic
    _defer       *_defer
    m            *m
    sched        gobuf
    atomicstatus atomic.Uint32
    goid         uint64
    
    // Preemption
    preempt       bool
    preemptStop   bool
    preemptShrink bool
    
    // Tracing
    trackingSeq  uint8
    tracking     bool
    trackingSys  uint8
}

// 2. m (machine/OS thread)
type m struct {
    g0      *g    // goroutine with scheduling stack
    curg    *g    // current running goroutine
    p       *p    // attached p for executing go code
    nextp   *p
    oldp    *p    // p before a syscall
    
    id      int64
    spinning bool
    blocked bool
    
    locks     int32
    mallocing int32
    
    // Signal
    gsignal   *g
    sigmask   sigset
}

// 3. p (processor)
type p struct {
    id          int32
    status      uint32
    
    m           *m    // back-link to associated m
    
    // Queue
    runqhead uint32
    runqtail uint32
    runq     [256]*g
    runnext  *g
    
    // Cache
    mcache      *mcache
    pcache      pageCache
    
    // GC
    gcBgMarkWorker *g
    gcw            gcWork
    
    // Statistics
    schedtick   uint32
    syscalltick uint32
}
```

### 1.2 ç¨‹åºå¯åŠ¨æµç¨‹

#### å¯åŠ¨åºåˆ—å½¢å¼åŒ–

```mathematical
/* ç¨‹åºå¯åŠ¨è¯­ä¹‰ */

[Start-Program]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. runtimeÂ·rt0_go              /* æ±‡ç¼–å…¥å£ */
2. runtimeÂ·check               /* è¿è¡Œæ—¶æ£€æŸ¥ */
3. runtimeÂ·args                /* å‚æ•°å¤„ç† */
4. runtimeÂ·osinit              /* OSåˆå§‹åŒ– */
5. runtimeÂ·schedinit           /* è°ƒåº¦å™¨åˆå§‹åŒ– */
6. runtimeÂ·newproc             /* åˆ›å»ºmain goroutine */
7. runtimeÂ·mstart              /* å¯åŠ¨è°ƒåº¦å¾ªç¯ */
8. mainÂ·main                   /* æ‰§è¡Œmainå‡½æ•° */

/* åˆå§‹åŒ–çŠ¶æ€è½¬æ¢ */

(âˆ…, Start) â†’ (Init, Â·)
(Init, SchedInit) â†’ (Ready, (gâ‚€, mâ‚€, pâ‚€))
(Ready, NewProc(main)) â†’ (Running, (gâ‚˜â‚áµ¢â‚™, mâ‚€, pâ‚€))
(Running, MainExit) â†’ (Terminated, Â·)
```

#### å¯åŠ¨æµç¨‹ä»£ç 

```go
// runtime/asm_amd64.s

TEXT runtimeÂ·rt0_go(SB),NOSPLIT,$0
    // 1. åˆå§‹åŒ–CPUç‰¹æ€§æ£€æµ‹
    CALL runtimeÂ·check(SB)
    
    // 2. ä¿å­˜å‚æ•°
    MOVQ DI, AX
    MOVQ SI, BX
    
    // 3. åˆ›å»ºg0å’Œm0
    LEAQ runtimeÂ·g0(SB), CX
    MOVQ CX, g(BX)
    LEAQ runtimeÂ·m0(SB), AX
    
    // 4. è°ƒç”¨Goåˆå§‹åŒ–ä»£ç 
    CALL runtimeÂ·args(SB)
    CALL runtimeÂ·osinit(SB)
    CALL runtimeÂ·schedinit(SB)
    
    // 5. åˆ›å»ºmain goroutine
    MOVQ $runtimeÂ·mainPC(SB), AX
    PUSHQ AX
    PUSHQ $0
    CALL runtimeÂ·newproc(SB)
    POPQ AX
    POPQ AX
    
    // 6. å¯åŠ¨M
    CALL runtimeÂ·mstart(SB)

// runtime/proc.go

func schedinit() {
    // è·å–g0
    _g_ := getg()
    if raceenabled {
        _g_.racectx, raceprocctx0 = raceinit()
    }
    
    // è®¾ç½®æœ€å¤§çº¿ç¨‹æ•°
    sched.maxmcount = 10000
    
    // åˆå§‹åŒ–æ¨¡å—
    moduledataverify()
    stackinit()
    mallocinit()
    cpuinit()
    alginit()
    modulesinit()
    typelinksinit()
    itabsinit()
    
    // å‘½ä»¤è¡Œå‚æ•°
    goargs()
    goenvs()
    parsedebugvars()
    
    // GCåˆå§‹åŒ–
    gcinit()
    
    // Påˆå§‹åŒ–
    procs := ncpu
    if n := atoi32(gogetenv("GOMAXPROCS")); n > 0 {
        procs = n
    }
    procresize(procs)
}

func newproc(fn *funcval) {
    _g_ := getg()
    pc := getcallerpc()
    systemstack(func() {
        newg := newproc1(fn, _g_, pc)
        _p_ := getg().m.p.ptr()
        runqput(_p_, newg, true)
        
        if mainStarted {
            wakep()
        }
    })
}

func mstart() {
    _g_ := getg()
    
    osStack := _g_.stack.lo == 0
    if osStack {
        // è®¾ç½®g0æ ˆè¾¹ç•Œ
        size := _g_.stack.hi
        if size == 0 {
            size = 8192 * sys.StackGuardMultiplier
        }
        _g_.stack.hi = uintptr(noescape(unsafe.Pointer(&size)))
        _g_.stack.lo = _g_.stack.hi - size + 1024
    }
    
    // åˆå§‹åŒ–M
    mstart1()
}

func mstart1() {
    _g_ := getg()
    
    // è®°å½•Må¯åŠ¨
    if _g_ != _g_.m.g0 {
        throw("bad runtimeÂ·mstart")
    }
    
    // å¯åŠ¨ä¿¡å·å¤„ç†
    if _g_.m == &m0 {
        mstartm0()
    }
    
    // å¼€å§‹è°ƒåº¦å¾ªç¯
    schedule()
}
```

### 1.3 è¿è¡Œæ—¶ç³»ç»Ÿè°ƒç”¨

```go
// runtime/syscall_unix.go

// Syscall æ‰§è¡Œç³»ç»Ÿè°ƒç”¨
func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) {
    entersyscall()
    r1, r2, err = RawSyscall(trap, a1, a2, a3)
    exitsyscall()
    return
}

// entersyscall è¿›å…¥ç³»ç»Ÿè°ƒç”¨å‰çš„å‡†å¤‡
func entersyscall() {
    _g_ := getg()
    
    // ç¦ç”¨æŠ¢å 
    _g_.m.locks++
    
    // ä¿å­˜SPå’ŒPC
    save(getcallerpc(), getcallersp())
    _g_.syscallsp = _g_.sched.sp
    _g_.syscallpc = _g_.sched.pc
    
    // æ›´æ”¹GçŠ¶æ€
    casgstatus(_g_, _Grunning, _Gsyscall)
    
    // è§£ç»‘P
    pp := _g_.m.p.ptr()
    pp.m = 0
    _g_.m.oldp.set(pp)
    _g_.m.p = 0
    atomic.Store(&pp.status, _Psyscall)
    
    // ä¿å­˜Mä¿¡æ¯
    if sched.sysmonwait.Load() {
        systemstack(entersyscall_sysmon)
    }
    
    _g_.m.locks--
}

// exitsyscall ç³»ç»Ÿè°ƒç”¨è¿”å›åçš„å¤„ç†
func exitsyscall() {
    _g_ := getg()
    
    _g_.m.locks++
    
    // å°è¯•å¿«é€Ÿè·¯å¾„é‡æ–°è·å–P
    if exitsyscallfast(oldp) {
        // æˆåŠŸé‡æ–°è·å–P
        if _g_.m.mcache == nil {
            throw("lost mcache")
        }
        casgstatus(_g_, _Gsyscall, _Grunning)
        
        _g_.syscallsp = 0
        _g_.m.locks--
        return
    }
    
    // æ…¢è·¯å¾„: æ— æ³•ç«‹å³è·å–P
    _g_.m.locks--
    
    // å°†Gæ”¾å…¥å…¨å±€é˜Ÿåˆ—
    mcall(exitsyscall0)
}
```

---

## ç¬¬äºŒéƒ¨åˆ†: å†…å­˜æ¨¡å‹

### 2.1 å†…å­˜å¸ƒå±€

#### è™šæ‹Ÿå†…å­˜å¸ƒå±€

```mathematical
/* Goå†…å­˜å¸ƒå±€ */

VirtualMemory = (Stack, Heap, Data, Text)

Stack: æ ˆå†…å­˜ï¼ˆæ¯ä¸ªgoroutineç‹¬ç«‹ï¼‰
Heap: å †å†…å­˜ï¼ˆå…¨å±€å…±äº«ï¼‰
Data: æ•°æ®æ®µï¼ˆå…¨å±€å˜é‡ï¼‰
Text: ä»£ç æ®µï¼ˆåªè¯»ï¼‰

/* 64ä½ç³»ç»Ÿå†…å­˜å¸ƒå±€ */

0x0000000000000000 - 0x00007FFFFFFFFFFF: User Space (128 TB)
â”œâ”€ Text Segment       (ä»£ç æ®µ)
â”œâ”€ Data Segment       (æ•°æ®æ®µ)
â”œâ”€ BSS Segment        (æœªåˆå§‹åŒ–æ•°æ®)
â”œâ”€ Heap               (å †ï¼Œå‘é«˜åœ°å€å¢é•¿)
â”‚  â””â”€ Arena           (mheapç®¡ç†)
â”œâ”€ ...                (é¢„ç•™)
â””â”€ Stack              (æ ˆï¼Œå‘ä½åœ°å€å¢é•¿)

/* Heapç»“æ„ */

Heap = mheap {
    arenas: [1<<20]arena,  /* æœ€å¤š1Mä¸ªarena */
    central: [134]mcentral, /* spanåˆ†é…ä¸­å¿ƒ */
    spanalloc: fixalloc,    /* spanåˆ†é…å™¨ */
}

Arena: 64MBå†…å­˜å—
  â””â”€ Pages: [8192]page   /* æ¯é¡µ8KB */
       â””â”€ Span: è¿ç»­é¡µçš„é›†åˆ
            â””â”€ Objects: å›ºå®šå¤§å°çš„å¯¹è±¡
```

#### å†…å­˜åˆ†é…å™¨å±‚æ¬¡

```go
// runtime/malloc.go

/* ä¸‰çº§å†…å­˜åˆ†é…å™¨ */

// 1. mcache: Pçš„æœ¬åœ°ç¼“å­˜ï¼ˆæ— é”ï¼‰
type mcache struct {
    // 67ä¸ªspané“¾è¡¨ï¼ŒæŒ‰å¯¹è±¡å¤§å°åˆ†ç±»
    alloc [numSpanClasses]*mspan
    
    // å¾®å¯¹è±¡åˆ†é…å™¨ (<16B)
    tiny       uintptr
    tinyoffset uintptr
    tinyAllocs uintptr
    
    // ç»Ÿè®¡
    local_scan  uintptr
    local_alloc uintptr
}

// 2. mcentral: æ‰€æœ‰På…±äº«çš„ä¸­å¿ƒç¼“å­˜ï¼ˆæœ‰é”ï¼‰
type mcentral struct {
    spanclass spanClass
    
    // éƒ¨åˆ†å·²åˆ†é…çš„spané“¾è¡¨
    partial [2]spanSet
    
    // å®Œå…¨å·²åˆ†é…çš„spané“¾è¡¨
    full    [2]spanSet
}

// 3. mheap: å…¨å±€å †ï¼ˆæœ‰é”ï¼‰
type mheap struct {
    lock      mutex
    pages     pageAlloc
    
    // Arena
    arenas [1 << arenaL1Bits]*[1 << arenaL2Bits]*heapArena
    
    // Central
    central [numSpanClasses]struct {
        mcentral mcentral
        pad      [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral{})%cpu.CacheLinePadSize]byte
    }
    
    // Span allocator
    spanalloc fixalloc
    
    // GCç›¸å…³
    sweepgen  uint32
    sweepdone uint32
    sweepers  uint32
}

// Span: è¿ç»­é¡µçš„é›†åˆ
type mspan struct {
    next *mspan
    prev *mspan
    
    // åŸºæœ¬ä¿¡æ¯
    startAddr uintptr
    npages    uintptr
    
    // å¯¹è±¡ç®¡ç†
    manualFreeList gclinkptr
    allocCount     uint16
    spanclass      spanClass
    
    // GCç›¸å…³
    sweepgen    uint32
    baseMask    uintptr
    allocBits   *gcBits
    gcmarkBits  *gcBits
}
```

### 2.2 æ ˆå†…å­˜ç®¡ç†

#### æ ˆå¢é•¿æœºåˆ¶

```mathematical
/* æ ˆå¢é•¿è¯­ä¹‰ */

[Stack-Check]
éœ€è¦æ£€æŸ¥æ ˆç©ºé—´çš„å‡½æ•°å…¥å£:
  if SP < stackguard:
    call morestack

[Stack-Grow]
æ ˆä¸è¶³æ—¶çš„å¤„ç†:
  1. è®¡ç®—æ–°æ ˆå¤§å°: newsize = oldsize * 2
  2. åˆ†é…æ–°æ ˆ: newstack = allocStack(newsize)
  3. å¤åˆ¶æ•°æ®: copy(newstack, oldstack)
  4. è°ƒæ•´æŒ‡é’ˆ: adjustPointers()
  5. é‡Šæ”¾æ—§æ ˆ: freeStack(oldstack)
  6. æ¢å¤æ‰§è¡Œ: resume()

/* æ ˆæ”¶ç¼© */

[Stack-Shrink]
GCæ—¶æ£€æŸ¥æ ˆä½¿ç”¨ç‡:
  if used < size/4 && size > minStackSize:
    shrinkStack(size / 2)
```

#### æ ˆç®¡ç†å®ç°

```go
// runtime/stack.go

const (
    _StackMin       = 2048
    _StackBig       = 4096
    _FixedStack     = _StackMin + _StackSystem
    _StackGuard     = 928*sys.StackGuardMultiplier + _StackSystem
)

// stackalloc åˆ†é…æ ˆ
func stackalloc(n uint32) stack {
    if n&(n-1) != 0 {
        throw("stack size not a power of 2")
    }
    
    // å°æ ˆä»ç¼“å­˜æ± è·å–
    if n < _FixedStack<<_NumStackOrders && n < _StackCacheSize {
        order := uint8(0)
        n2 := n
        for n2 > _FixedStack {
            order++
            n2 >>= 1
        }
        
        var x gclinkptr
        c := _g_.m.mcache
        if stackCache := &c.stackcache[order]; !stackCache.isEmpty() {
            x = stackCache.pop()
        }
        if x == 0 {
            x = stackpoolalloc(order)
        }
        v := unsafe.Pointer(x)
        return stack{uintptr(v), uintptr(v) + uintptr(n)}
    }
    
    // å¤§æ ˆä»å †åˆ†é…
    var s *mspan
    npage := uintptr(n) >> _PageShift
    s = mheap_.allocManual(npage, spanAllocStack)
    if s == nil {
        throw("out of memory")
    }
    return stack{s.base(), s.base() + s.npages<<_PageShift}
}

// newstack å¢é•¿æ ˆ
func newstack() {
    thisg := getg()
    gp := thisg.m.curg
    
    // è®¡ç®—éœ€è¦çš„æ ˆå¤§å°
    sp := gp.sched.sp
    if sp < gp.stack.lo {
        throw("stack overflow")
    }
    
    // è®¡ç®—æ–°æ ˆå¤§å°ï¼ˆç¿»å€ï¼‰
    oldsize := gp.stack.hi - gp.stack.lo
    newsize := oldsize * 2
    
    // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æœ€å¤§æ ˆ
    if newsize > maxstacksize {
        print("runtime: goroutine stack exceeds ", maxstacksize, "-byte limit\n")
        throw("stack overflow")
    }
    
    // åˆ†é…æ–°æ ˆ
    casgstatus(gp, _Grunning, _Gcopystack)
    copystack(gp, newsize)
    casgstatus(gp, _Gcopystack, _Grunning)
    
    // é‡æ–°è°ƒåº¦
    gogo(&gp.sched)
}

// copystack å¤åˆ¶æ ˆå†…å®¹
func copystack(gp *g, newsize uintptr) {
    old := gp.stack
    used := old.hi - gp.sched.sp
    
    // åˆ†é…æ–°æ ˆ
    new := stackalloc(uint32(newsize))
    
    // è°ƒæ•´æŒ‡é’ˆ
    var adjinfo adjustinfo
    adjinfo.old = old
    adjinfo.delta = new.hi - old.hi
    
    // å¤åˆ¶æ ˆå†…å®¹
    ncopy := used
    memmove(unsafe.Pointer(new.hi-ncopy), unsafe.Pointer(old.hi-ncopy), ncopy)
    
    // è°ƒæ•´æ ˆä¸Šçš„æŒ‡é’ˆ
    adjustctxt(gp, &adjinfo)
    adjustdefers(gp, &adjinfo)
    adjustpanics(gp, &adjinfo)
    
    // åˆ‡æ¢åˆ°æ–°æ ˆ
    gp.stack = new
    gp.stackguard0 = new.lo + _StackGuard
    gp.sched.sp = new.hi - used
    
    // é‡Šæ”¾æ—§æ ˆ
    stackfree(old)
}
```

### 2.3 å †å†…å­˜åˆ†é…

#### åˆ†é…ç­–ç•¥

```mathematical
/* å†…å­˜åˆ†é…ç­–ç•¥ */

Allocate(size) = 
  if size == 0:
    return zerobase
  else if size <= 16:
    return tiny_allocate(size)    /* å¾®å¯¹è±¡ */
  else if size <= 32KB:
    return small_allocate(size)   /* å°å¯¹è±¡ */
  else:
    return large_allocate(size)   /* å¤§å¯¹è±¡ */

/* å¾®å¯¹è±¡åˆ†é… (<=16B) */
tiny_allocate(size):
  align size to 8
  if tiny_offset + size <= 16:
    ptr = tiny + tiny_offset
    tiny_offset += size
    return ptr
  else:
    tiny = alloc_from_span(16)
    tiny_offset = size
    return tiny

/* å°å¯¹è±¡åˆ†é… (16B-32KB) */
small_allocate(size):
  class = sizeToClass(size)
  span = mcache.alloc[class]
  if span == nil || span.full:
    span = mcache.refill(class)
  return span.allocate()

/* å¤§å¯¹è±¡åˆ†é… (>32KB) */
large_allocate(size):
  npages = (size + pageSize - 1) / pageSize
  return mheap.alloc(npages)
```

#### åˆ†é…å®ç°

```go
// runtime/malloc.go

func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {
    // å¤§å°ç±»åˆ«
    const (
        maxSmallSize   = 32768
        maxTinySize    = 16
    )
    
    mp := acquirem()
    mp.mallocing = 1
    
    dataSize := size
    c := getMCache()
    var s *mspan
    var x unsafe.Pointer
    
    // é›¶å¤§å°å¯¹è±¡
    if size == 0 {
        return unsafe.Pointer(&zerobase)
    }
    
    // å¾®å¯¹è±¡åˆ†é…
    if size <= maxTinySize && typ != nil && !typ.pointers() {
        off := c.tinyoffset
        if off+size <= maxTinySize && c.tiny != 0 {
            x = unsafe.Pointer(c.tiny + off)
            c.tinyoffset = off + size
            c.tinyAllocs++
            releasem(mp)
            return x
        }
        
        // åˆ†é…æ–°çš„tinyå—
        span := c.alloc[tinySpanClass]
        v := nextFreeFast(span)
        if v == 0 {
            v, span, _ = c.nextFree(tinySpanClass)
        }
        x = unsafe.Pointer(v)
        (*[2]uint64)(x)[0] = 0
        (*[2]uint64)(x)[1] = 0
        
        if size < c.tinyoffset || c.tiny == 0 {
            c.tiny = uintptr(x)
            c.tinyoffset = size
        }
        size = maxTinySize
    } else {
        // å°å¯¹è±¡åˆ†é…
        var sizeclass uint8
        if size <= smallSizeMax-8 {
            sizeclass = size_to_class8[divRoundUp(size, smallSizeDiv)]
        } else {
            sizeclass = size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]
        }
        size = uintptr(class_to_size[sizeclass])
        spc := makeSpanClass(sizeclass, noscan)
        span := c.alloc[spc]
        v := nextFreeFast(span)
        if v == 0 {
            v, span, _ = c.nextFree(spc)
        }
        x = unsafe.Pointer(v)
        if needzero && span.needzero != 0 {
            memclrNoHeapPointers(unsafe.Pointer(v), size)
        }
    }
    
    // è®¾ç½®ç±»å‹ä¿¡æ¯
    if typ != nil {
        scanSize := typ.ptrdata
        c.scanAlloc += scanSize
    }
    
    mp.mallocing = 0
    releasem(mp)
    
    return x
}

// nextFreeFast å¿«é€Ÿåˆ†é…
func nextFreeFast(s *mspan) gclinkptr {
    theBit := sys.Ctz64(s.allocCache)
    if theBit < 64 {
        result := s.freeindex + uintptr(theBit)
        if result < s.nelems {
            freeidx := result + 1
            if freeidx%64 == 0 && freeidx != s.nelems {
                return 0
            }
            s.allocCache >>= uint(theBit + 1)
            s.freeindex = freeidx
            s.allocCount++
            return gclinkptr(result*s.elemsize + s.base())
        }
    }
    return 0
}
```

### 2.4 é€ƒé€¸åˆ†æ

#### é€ƒé€¸è§„åˆ™

```mathematical
/* é€ƒé€¸åˆ†æè§„åˆ™ */

Escape(expr) â†’ {stack, heap}

[Escape-Pointer]
&x è¢«è¿”å›æˆ–èµ‹å€¼ç»™å…¨å±€å˜é‡
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Escape(&x) = heap

[Escape-Closure]
x è¢«é—­åŒ…æ•è·ä¸”é—­åŒ…é€ƒé€¸
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Escape(x) = heap

[Escape-Interface]
x è¢«è½¬æ¢ä¸ºinterface{}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Escape(x) = heap

[Escape-Slice]
åˆ‡ç‰‡å®¹é‡æœªçŸ¥æˆ–è¿‡å¤§
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Escape(make([]T, n)) = heap

[Escape-Channel]
å‘é€åˆ°channelçš„å€¼
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Escape(ch <- x) = heap

/* ä¸é€ƒé€¸çš„æƒ…å†µ */
[No-Escape-Local]
x ä»…åœ¨å‡½æ•°å†…éƒ¨ä½¿ç”¨
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Escape(x) = stack

[No-Escape-Size]
å¯¹è±¡å¤§å°åœ¨ç¼–è¯‘æ—¶å·²çŸ¥ä¸”è¾ƒå°
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Escape(x) = stack (if size < threshold)
```

#### é€ƒé€¸åˆ†æç¤ºä¾‹

```go
package main

// 1. ä¸é€ƒé€¸çš„ä¾‹å­
func noEscape() int {
    x := 42          // åˆ†é…åœ¨æ ˆä¸Š
    return x
}

func noEscapeSlice() {
    s := make([]int, 10)  // å¤§å°å·²çŸ¥ï¼Œåˆ†é…åœ¨æ ˆä¸Š
    _ = s[0]
}

// 2. é€ƒé€¸åˆ°å †çš„ä¾‹å­
func escapePointer() *int {
    x := 42
    return &x    // xé€ƒé€¸åˆ°å †ï¼Œå› ä¸ºåœ°å€è¢«è¿”å›
}

func escapeClosure() func() int {
    x := 42
    return func() int {
        return x  // xé€ƒé€¸åˆ°å †ï¼Œè¢«é—­åŒ…æ•è·
    }
}

func escapeInterface() interface{} {
    x := 42
    return x      // xé€ƒé€¸åˆ°å †ï¼Œè½¬æ¢ä¸ºinterface{}
}

func escapeSliceUnknown(n int) []int {
    return make([]int, n)  // næœªçŸ¥ï¼Œé€ƒé€¸åˆ°å †
}

func escapeChannel() {
    ch := make(chan int, 1)
    x := 42
    ch <- x       // xé€ƒé€¸åˆ°å †ï¼Œå‘é€åˆ°channel
}

// 3. æŸ¥çœ‹é€ƒé€¸åˆ†æ
// go build -gcflags="-m" main.go

/* è¾“å‡ºç¤ºä¾‹:
./main.go:14:2: moved to heap: x
./main.go:19:9: func literal escapes to heap
./main.go:19:9: func literal escapes to heap
./main.go:20:3: moved to heap: x
./main.go:26:2: moved to heap: x
*/
```

---

## ç¬¬ä¸‰éƒ¨åˆ†: åƒåœ¾å›æ”¶

### 3.1 ä¸‰è‰²æ ‡è®°ç®—æ³•

#### 3.1.1 å½¢å¼åŒ–å®šä¹‰

```mathematical
/* ä¸‰è‰²æ ‡è®°ç®—æ³• */

Colors ::= White | Gray | Black

å…¶ä¸­:
- White: æœªè®¿é—®ï¼ˆå¯èƒ½æ˜¯åƒåœ¾ï¼‰
- Gray: å·²è®¿é—®ä½†å­èŠ‚ç‚¹æœªè®¿é—®
- Black: å·²è®¿é—®ä¸”å­èŠ‚ç‚¹å·²è®¿é—®

/* æ ‡è®°è§„åˆ™ */

[Mark-Root]
root âˆˆ Roots
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Color(root) := Gray

[Mark-Scan]
Color(obj) = Gray
child âˆˆ Children(obj)
Color(child) = White
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Color(child) := Gray

[Mark-Complete]
Color(obj) = Gray
âˆ€child âˆˆ Children(obj). Color(child) â‰  White
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Color(obj) := Black

/* ä¸å˜é‡ */

Tricolor Invariant:
  âˆ€obj. Color(obj) = Black â‡’
    âˆ€child âˆˆ Children(obj). Color(child) â‰  White

Strong Tricolor Invariant:
  Blackå¯¹è±¡ä¸èƒ½æŒ‡å‘Whiteå¯¹è±¡

Weak Tricolor Invariant:
  å¦‚æœBlackå¯¹è±¡æŒ‡å‘Whiteå¯¹è±¡ï¼Œ
  åˆ™å­˜åœ¨Grayå¯¹è±¡å¯è¾¾è¯¥Whiteå¯¹è±¡
```

#### æ ‡è®°å®ç°

```go
// runtime/mgc.go

// GC phases
const (
    _GCoff             = iota // GCå…³é—­
    _GCmark                   // æ ‡è®°é˜¶æ®µ
    _GCmarktermination        // æ ‡è®°ç»ˆæ­¢é˜¶æ®µ
)

// gcStart å¯åŠ¨GC
func gcStart(trigger gcTrigger) {
    // åˆ‡æ¢åˆ°æ ‡è®°é˜¶æ®µ
    setGCPhase(_GCmark)
    
    // å¯åŠ¨æ ‡è®°worker
    gcBgMarkStartWorkers()
    
    // STWå‡†å¤‡
    systemstack(stopTheWorldWithSema)
    systemstack(finishsweep_m)
    
    // æ¸…ç†mcaches
    clearpools()
    
    // æ ‡è®°æ ¹å¯¹è±¡
    gcMarkRootPrepare()
    
    // æ ‡è®°å¾®å¯¹è±¡
    gcMarkTinyAllocs()
    
    // å¯åŠ¨ä¸–ç•Œ
    systemstack(func() {
        now = startTheWorldWithSema()
    })
}

// gcDrain æ ‡è®°å¾ªç¯
func gcDrain(gcw *gcWork, flags gcDrainFlags) {
    gp := getg().m.curg
    
    // å¹¶å‘æ ‡è®°
    for !(preemptible && gp.preempt) {
        // ä»å·¥ä½œé˜Ÿåˆ—è·å–å¯¹è±¡
        b := gcw.tryGetFast()
        if b == 0 {
            b = gcw.tryGet()
            if b == 0 {
                break
            }
        }
        
        // æ‰«æå¯¹è±¡
        scanobject(b, gcw)
    }
}

// scanobject æ‰«æå¯¹è±¡
func scanobject(b uintptr, gcw *gcWork) {
    s := spanOfUnchecked(b)
    n := s.elemsize
    
    // è·å–å¯¹è±¡çš„ç±»å‹ä¿¡æ¯
    hbits := heapBitsForAddr(b)
    
    // æ‰«æå¯¹è±¡ä¸­çš„æŒ‡é’ˆ
    for i := uintptr(0); i < n; i += sys.PtrSize {
        if hbits.isPointer() {
            // è·å–æŒ‡é’ˆå€¼
            obj := *(*uintptr)(unsafe.Pointer(b + i))
            
            // æ ‡è®°æŒ‡å‘çš„å¯¹è±¡
            if obj != 0 {
                greyobject(obj, b, i, gcw)
            }
        }
        hbits = hbits.next()
    }
}

// greyobject å°†å¯¹è±¡æ ‡è®°ä¸ºç°è‰²
func greyobject(obj, base, off uintptr, gcw *gcWork) {
    // æ£€æŸ¥æ˜¯å¦åœ¨å †ä¸Š
    if obj < minHeapAddr || obj >= maxHeapAddr {
        return
    }
    
    // è·å–span
    span := spanOfUnchecked(obj)
    if span == nil {
        return
    }
    
    // åŸå­æ ‡è®°
    if span.isFree() {
        return
    }
    
    // è®¾ç½®æ ‡è®°ä½
    mbits := span.markBitsForIndex(span.objIndex(obj))
    if mbits.isMarked() {
        return
    }
    mbits.setMarked()
    
    // æ·»åŠ åˆ°å·¥ä½œé˜Ÿåˆ—
    if !gcw.putFast(obj) {
        gcw.put(obj)
    }
}
```

### 3.2 å¹¶å‘GC

#### å¹¶å‘æ ‡è®°

```go
// gcBgMarkWorker GCåå°æ ‡è®°worker
func gcBgMarkWorker() {
    gp := getg()
    
    for {
        // ç­‰å¾…GCå¯åŠ¨
        gopark(func(g *g, parkp unsafe.Pointer) bool {
            return true
        }, unsafe.Pointer(&pp.gcBgMarkWorker), waitReasonGCWorkerIdle, traceEvGoBlock, 0)
        
        // è·å–å·¥ä½œæ¨¡å¼
        mode := gcMarkWorkerMode(pp)
        
        switch mode {
        case gcMarkWorkerDedicatedMode:
            // ä¸“ç”¨æ¨¡å¼: æŒç»­æ ‡è®°ç›´åˆ°å®Œæˆ
            gcDrain(&pp.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)
            
        case gcMarkWorkerFractionalMode:
            // åˆ†æ—¶æ¨¡å¼: æ ‡è®°ä¸€æ®µæ—¶é—´åè®©å‡º
            gcDrain(&pp.gcw, gcDrainFractional|gcDrainUntilPreempt|gcDrainFlushBgCredit)
            
        case gcMarkWorkerIdleMode:
            // ç©ºé—²æ¨¡å¼: Pç©ºé—²æ—¶æ ‡è®°
            gcDrain(&pp.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)
        }
        
        // å®Œæˆä¸€è½®æ ‡è®°
        incnwait := atomic.Xadd(&work.nwait, +1)
        if incnwait == work.nproc {
            // æ‰€æœ‰workerå®Œæˆï¼Œè¿›å…¥æ ‡è®°ç»ˆæ­¢
            gcMarkDone()
        }
    }
}
```

### 3.3 å†™å±éšœ

#### å†™å±éšœç±»å‹

```mathematical
/* å†™å±éšœ (Write Barrier) */

/* Dijkstraå†™å±éšœ (æ’å…¥å±éšœ) */
[Dijkstra-WB]
*ptr = obj
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if Color(obj) = White:
  Color(obj) := Gray
*ptr = obj

/* Yuasaå†™å±éšœ (åˆ é™¤å±éšœ) */
[Yuasa-WB]
old = *ptr
*ptr = obj
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if Color(old) = White:
  Color(old) := Gray
*ptr = obj

/* æ··åˆå†™å±éšœ (Goä½¿ç”¨) */
[Hybrid-WB]
old = *ptr
*ptr = obj
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if Color(old) = White:
  shade(old)
if Color(obj) = White:
  shade(obj)
*ptr = obj
```

#### å†™å±éšœå®ç°

```go
// runtime/mbarrier.go

// writePointer å†™æŒ‡é’ˆæ—¶çš„å±éšœ
func writePointer(dst *uintptr, src uintptr) {
    if !writeBarrier.enabled {
        *dst = src
        return
    }
    writebarrierptr(dst, src)
}

// writebarrierptr å†™å±éšœå®ç°
func writebarrierptr(dst *uintptr, src uintptr) {
    if src != 0 && (src < minHeapAddr || src >= maxHeapAddr) {
        *dst = src
        return
    }
    
    // æ··åˆå†™å±éšœ
    systemstack(func() {
        // æ ‡è®°æ—§å€¼ (åˆ é™¤å±éšœ)
        old := atomic.Loaduintptr(dst)
        if old != 0 {
            gcmarknobject(old)
        }
        
        // æ ‡è®°æ–°å€¼ (æ’å…¥å±éšœ)
        if src != 0 {
            gcmarknobject(src)
        }
        
        // æ‰§è¡Œå†™å…¥
        atomic.Storeuintptr(dst, src)
    })
}

// wbBufFlush åˆ·æ–°å†™å±éšœç¼“å†²åŒº
func wbBufFlush(dst *uintptr, src uintptr) {
    // è·å–Pçš„å†™å±éšœç¼“å†²åŒº
    _g_ := getg()
    bufp := &_g_.m.p.ptr().wbBuf
    
    // æ·»åŠ åˆ°ç¼“å†²åŒº
    n := bufp.n
    if n < len(bufp.buf) {
        bufp.buf[n] = src
        bufp.n = n + 1
        return
    }
    
    // ç¼“å†²åŒºæ»¡ï¼Œåˆ·æ–°
    wbBufFlush1(bufp)
    bufp.buf[0] = src
    bufp.n = 1
}
```

### 3.4 GCè°ƒä¼˜

```go
// 1. GOGCç¯å¢ƒå˜é‡
// GOGC=100 (é»˜è®¤): å †å¢é•¿100%æ—¶è§¦å‘GC
// GOGC=200: å †å¢é•¿200%æ—¶è§¦å‘GC
// GOGC=off: å…³é—­GC

// 2. runtime/debugåŒ…
import "runtime/debug"

func tuneGC() {
    // è®¾ç½®GCç™¾åˆ†æ¯”
    debug.SetGCPercent(200)
    
    // è®¾ç½®å†…å­˜é™åˆ¶
    debug.SetMemoryLimit(1 << 30) // 1GB
    
    // å¼ºåˆ¶GC
    runtime.GC()
    
    // æŸ¥çœ‹GCç»Ÿè®¡
    var stats debug.GCStats
    debug.ReadGCStats(&stats)
    fmt.Printf("NumGC: %d\n", stats.NumGC)
    fmt.Printf("PauseTotal: %v\n", stats.PauseTotal)
}

// 3. å¯¹è±¡æ± å¤ç”¨
var bufferPool = sync.Pool{
    New: func() interface{} {
        return new(bytes.Buffer)
    },
}

func usePool() {
    buf := bufferPool.Get().(*bytes.Buffer)
    defer bufferPool.Put(buf)
    
    buf.Reset()
    // ä½¿ç”¨buf...
}
```

---

## ç¬¬å››éƒ¨åˆ†: æ‰§è¡Œè¯­ä¹‰

### 4.1 æ“ä½œè¯­ä¹‰

```mathematical
/* å°æ­¥æ“ä½œè¯­ä¹‰ */

(stmt, Ïƒ) â†’ (stmt', Ïƒ')

å…¶ä¸­:
- stmt: è¯­å¥
- Ïƒ: çŠ¶æ€ (å†…å­˜+æ ˆ+å †+goroutines)

/* è¯­å¥æ‰§è¡Œè§„åˆ™ */

[Assign]
Ïƒ(x) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(x = e, Ïƒ) â†’ (skip, Ïƒ[x â†¦ eval(e, Ïƒ)])

[If-True]
eval(e, Ïƒ) = true
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(if e then sâ‚ else sâ‚‚, Ïƒ) â†’ (sâ‚, Ïƒ)

[If-False]
eval(e, Ïƒ) = false
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(if e then sâ‚ else sâ‚‚, Ïƒ) â†’ (sâ‚‚, Ïƒ)

[Go]
g = newGoroutine(f)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(go f(), Ïƒ) â†’ (skip, Ïƒ âŠ• {g})

[Send]
c âˆˆ Channels
v = eval(e, Ïƒ)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(c <- e, Ïƒ) â†’ (skip, send(c, v, Ïƒ))

[Receive]
c âˆˆ Channels
v = receive(c, Ïƒ)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(x = <-c, Ïƒ) â†’ (skip, Ïƒ[x â†¦ v])
```

### 4.2 æŒ‡ç§°è¯­ä¹‰

```mathematical
/* æŒ‡ç§°è¯­ä¹‰ */

âŸ¦stmtâŸ§: State â†’ State

/* åŸºæœ¬è¯­å¥ */
âŸ¦skipâŸ§Ïƒ = Ïƒ
âŸ¦x = eâŸ§Ïƒ = Ïƒ[x â†¦ âŸ¦eâŸ§Ïƒ]
âŸ¦sâ‚; sâ‚‚âŸ§Ïƒ = âŸ¦sâ‚‚âŸ§(âŸ¦sâ‚âŸ§Ïƒ)

/* æ§åˆ¶æµ */
âŸ¦if e then sâ‚ else sâ‚‚âŸ§Ïƒ = 
  if âŸ¦eâŸ§Ïƒ = true then âŸ¦sâ‚âŸ§Ïƒ else âŸ¦sâ‚‚âŸ§Ïƒ

âŸ¦for e do sâŸ§Ïƒ = fix(Î»f.Î»Ïƒ.
  if âŸ¦eâŸ§Ïƒ = true then f(âŸ¦sâŸ§Ïƒ) else Ïƒ)

/* å¹¶å‘è¯­ä¹‰ */
âŸ¦go f()âŸ§Ïƒ = Ïƒ âŠ spawn(âŸ¦fâŸ§)
âŸ¦c <- eâŸ§Ïƒ = Ïƒ âŠ• send(c, âŸ¦eâŸ§Ïƒ)
âŸ¦<-câŸ§Ïƒ = receive(c, Ïƒ)
```

### 4.3 å…¬ç†è¯­ä¹‰

```mathematical
/* Hoareé€»è¾‘ */

{P} stmt {Q}

å…¶ä¸­:
- P: å‰ç½®æ¡ä»¶
- Q: åç½®æ¡ä»¶

/* åŸºæœ¬è§„åˆ™ */

[Assignment]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{Q[x â†¦ e]} x = e {Q}

[Sequence]
{P} sâ‚ {R}    {R} sâ‚‚ {Q}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{P} sâ‚; sâ‚‚ {Q}

[If]
{P âˆ§ e} sâ‚ {Q}    {P âˆ§ Â¬e} sâ‚‚ {Q}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{P} if e then sâ‚ else sâ‚‚ {Q}

[While]
{P âˆ§ e} s {P}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{P} while e do s {P âˆ§ Â¬e}

/* å¹¶å‘è§„åˆ™ */

[Parallel]
{Pâ‚} sâ‚ {Qâ‚}    {Pâ‚‚} sâ‚‚ {Qâ‚‚}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (sâ‚, sâ‚‚ä¸å¹²æ‰°)
{Pâ‚ âˆ§ Pâ‚‚} sâ‚ || sâ‚‚ {Qâ‚ âˆ§ Qâ‚‚}

[Resource]
{P} critical {Q}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{P} lock; critical; unlock {Q}
```

---

## ğŸ¯ æ€»ç»“

### è¿è¡Œæ—¶ç³»ç»Ÿ

1. **GMPè°ƒåº¦æ¨¡å‹**: M:Nçº¿ç¨‹æ˜ å°„
2. **å†…å­˜ç®¡ç†**: ä¸‰çº§åˆ†é…å™¨(mcache/mcentral/mheap)
3. **åƒåœ¾å›æ”¶**: å¹¶å‘ä¸‰è‰²æ ‡è®°
4. **æ ˆç®¡ç†**: åŠ¨æ€å¢é•¿/æ”¶ç¼©

### å†…å­˜æ¨¡å‹

1. **åˆ†é…ç­–ç•¥**: å¾®å¯¹è±¡/å°å¯¹è±¡/å¤§å¯¹è±¡
2. **é€ƒé€¸åˆ†æ**: ç¼–è¯‘æ—¶ä¼˜åŒ–
3. **å¯¹è±¡æ± **: å‡å°‘GCå‹åŠ›
4. **å†™å±éšœ**: ä¿è¯å¹¶å‘GCæ­£ç¡®æ€§

### æ‰§è¡Œè¯­ä¹‰

1. **æ“ä½œè¯­ä¹‰**: çŠ¶æ€è½¬æ¢ç³»ç»Ÿ
2. **æŒ‡ç§°è¯­ä¹‰**: æ•°å­¦å‡½æ•°æ˜ å°„
3. **å…¬ç†è¯­ä¹‰**: Hoareé€»è¾‘éªŒè¯
4. **å¹¶å‘è¯­ä¹‰**: CSP+å†…å­˜æ¨¡å‹

### ä¼˜åŒ–å»ºè®®

1. åˆç†ä½¿ç”¨å¯¹è±¡æ± 
2. é¿å…ä¸å¿…è¦çš„é€ƒé€¸
3. æ§åˆ¶goroutineæ•°é‡
4. è°ƒæ•´GOGCå‚æ•°
5. ä½¿ç”¨pprofåˆ†æ

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**é€‚ç”¨Goç‰ˆæœ¬**: 1.25.3  
**æœ€åæ›´æ–°**: 2025-10-23  
**ç»´æŠ¤å›¢é˜Ÿ**: Go Runtime Team
