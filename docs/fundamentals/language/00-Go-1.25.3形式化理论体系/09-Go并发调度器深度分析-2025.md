# Go 1.25.3 å¹¶å‘è°ƒåº¦å™¨æ·±åº¦åˆ†æä¸å½¢å¼åŒ–æ¨¡å‹

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**åŸºå‡†æ—¥æœŸ**: 2025å¹´10æœˆ23æ—¥  
**Goç‰ˆæœ¬**: Go 1.25.3  
**ç†è®ºåŸºç¡€**: Work-Stealing + M:N Threading + CSP  
**å­—æ•°**: ~22,000å­—

---

## ğŸ“‹ ç›®å½•


- [ç¬¬ä¸€éƒ¨åˆ†: GMPè°ƒåº¦æ¨¡å‹](#ç¬¬ä¸€éƒ¨åˆ†-gmpè°ƒåº¦æ¨¡å‹)
  - [1.1 GMPæ¶æ„æ¦‚è§ˆ](#11-gmpæ¶æ„æ¦‚è§ˆ)
    - [æ¶æ„å›¾](#æ¶æ„å›¾)
  - [1.2 G (Goroutine)](#12-g-goroutine)
    - [Goroutine çŠ¶æ€æœº](#goroutine-çŠ¶æ€æœº)
    - [Goroutine æ•°æ®ç»“æ„](#goroutine-æ•°æ®ç»“æ„)
  - [1.3 M (Machine/OS Thread)](#13-m-machineos-thread)
    - [M çš„è§’è‰²ä¸è´£ä»»](#m-çš„è§’è‰²ä¸è´£ä»»)
    - [M æ•°æ®ç»“æ„](#m-æ•°æ®ç»“æ„)
  - [1.4 P (Processor)](#14-p-processor)
    - [P çš„è§’è‰²](#p-çš„è§’è‰²)
    - [P æ•°æ®ç»“æ„](#p-æ•°æ®ç»“æ„)
- [ç¬¬äºŒéƒ¨åˆ†: è°ƒåº¦ç®—æ³•å½¢å¼åŒ–](#ç¬¬äºŒéƒ¨åˆ†-è°ƒåº¦ç®—æ³•å½¢å¼åŒ–)
  - [2.1 Work-Stealingç®—æ³•](#21-work-stealingç®—æ³•)
    - [ç®—æ³•å½¢å¼åŒ–](#ç®—æ³•å½¢å¼åŒ–)
    - [Go ä»£ç å®ç°ï¼ˆç®€åŒ–ï¼‰](#go-ä»£ç å®ç°ç®€åŒ–)
  - [2.2 åä½œå¼æŠ¢å ](#22-åä½œå¼æŠ¢å )
    - [æŠ¢å æœºåˆ¶å½¢å¼åŒ–](#æŠ¢å æœºåˆ¶å½¢å¼åŒ–)
    - [ç¼–è¯‘å™¨æ’å…¥çš„æŠ¢å æ£€æŸ¥](#ç¼–è¯‘å™¨æ’å…¥çš„æŠ¢å æ£€æŸ¥)
  - [2.3 å¼‚æ­¥æŠ¢å  (Go 1.14+)](#23-å¼‚æ­¥æŠ¢å -go-114)
    - [å¼‚æ­¥æŠ¢å å®ç°](#å¼‚æ­¥æŠ¢å å®ç°)
  - [2.4 å…¬å¹³æ€§ä¿è¯](#24-å…¬å¹³æ€§ä¿è¯)
- [ç¬¬ä¸‰éƒ¨åˆ†: å†…å­˜æ¨¡å‹ä¸åŒæ­¥](#ç¬¬ä¸‰éƒ¨åˆ†-å†…å­˜æ¨¡å‹ä¸åŒæ­¥)
  - [3.1 Happens-Beforeå…³ç³»](#31-happens-beforeå…³ç³»)
    - [å½¢å¼åŒ–å®šä¹‰](#å½¢å¼åŒ–å®šä¹‰)
    - [ä»£ç ç¤ºä¾‹](#ä»£ç ç¤ºä¾‹)
  - [3.2 ChannelåŒæ­¥è¯­ä¹‰](#32-channelåŒæ­¥è¯­ä¹‰)
    - [æ— ç¼“å†²Channel](#æ— ç¼“å†²channel)
    - [æœ‰ç¼“å†²Channel](#æœ‰ç¼“å†²channel)
  - [3.3 syncåŒ…åŸè¯­](#33-syncåŒ…åŸè¯­)
    - [Mutex è¯­ä¹‰](#mutex-è¯­ä¹‰)
    - [RWMutex è¯­ä¹‰](#rwmutex-è¯­ä¹‰)
  - [3.4 å†…å­˜å±éšœ](#34-å†…å­˜å±éšœ)
- [ç¬¬å››éƒ¨åˆ†: æ€§èƒ½ä¼˜åŒ–æœºåˆ¶](#ç¬¬å››éƒ¨åˆ†-æ€§èƒ½ä¼˜åŒ–æœºåˆ¶)
  - [4.1 æœ¬åœ°è¿è¡Œé˜Ÿåˆ—](#41-æœ¬åœ°è¿è¡Œé˜Ÿåˆ—)
  - [4.2 å…¨å±€è¿è¡Œé˜Ÿåˆ—](#42-å…¨å±€è¿è¡Œé˜Ÿåˆ—)
  - [4.3 ç½‘ç»œè½®è¯¢å™¨é›†æˆ](#43-ç½‘ç»œè½®è¯¢å™¨é›†æˆ)
  - [4.4 ç³»ç»Ÿè°ƒç”¨å¤„ç†](#44-ç³»ç»Ÿè°ƒç”¨å¤„ç†)
- [ç¬¬äº”éƒ¨åˆ†: æœ€æ–°ä¼˜åŒ– (Go 1.25.3)](#ç¬¬äº”éƒ¨åˆ†-æœ€æ–°ä¼˜åŒ–-go-1253)
  - [5.1 å¢å¼ºçš„è°ƒåº¦å™¨è¿½è¸ª](#51-å¢å¼ºçš„è°ƒåº¦å™¨è¿½è¸ª)
  - [5.2 æ”¹è¿›çš„æŠ¢å æœºåˆ¶](#52-æ”¹è¿›çš„æŠ¢å æœºåˆ¶)
  - [5.3 æ›´å¥½çš„è´Ÿè½½å‡è¡¡](#53-æ›´å¥½çš„è´Ÿè½½å‡è¡¡)
- [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
  - [æ ¸å¿ƒå†…å®¹](#æ ¸å¿ƒå†…å®¹)
  - [ç†è®ºä»·å€¼](#ç†è®ºä»·å€¼)
  - [å·¥ç¨‹ä»·å€¼](#å·¥ç¨‹ä»·å€¼)

## ç¬¬ä¸€éƒ¨åˆ†: GMPè°ƒåº¦æ¨¡å‹

### 1.1 GMPæ¶æ„æ¦‚è§ˆ

Go è¿è¡Œæ—¶é‡‡ç”¨ **GMP æ¨¡å‹**å®ç° M:N è°ƒåº¦ã€‚

```mathematical
/* GMP æ¨¡å‹å½¢å¼åŒ–å®šä¹‰ */

System = (G, M, P, RQ, NP)

å…¶ä¸­:
- G: Goroutineé›†åˆ = {gâ‚, gâ‚‚, ..., gâ‚™}
- M: Machine(OSçº¿ç¨‹)é›†åˆ = {mâ‚, mâ‚‚, ..., mâ‚–}
- P: Processor(é€»è¾‘å¤„ç†å™¨)é›†åˆ = {pâ‚, pâ‚‚, ..., pâ‚š}
- RQ: è¿è¡Œé˜Ÿåˆ—é›†åˆ (æœ¬åœ° + å…¨å±€)
- NP: Network Poller (ç½‘ç»œè½®è¯¢å™¨)

/* å…³ç³»çº¦æŸ */
|P| = GOMAXPROCS  (Pçš„æ•°é‡ç”±GOMAXPROCSå†³å®š)
|M| â‰¥ |P|         (Mçš„æ•°é‡åŠ¨æ€è°ƒæ•´ï¼Œè‡³å°‘ç­‰äºP)
|G| â‰« |M|         (Goroutineæ•°é‡è¿œå¤§äºçº¿ç¨‹æ•°)

/* æ˜ å°„å…³ç³» */
exec: P â†’ M       (Påœ¨æŸä¸€æ—¶åˆ»æ‰§è¡Œåœ¨æŸä¸ªMä¸Š)
run: P â†’ G        (Påœ¨æŸä¸€æ—¶åˆ»è¿è¡ŒæŸä¸ªG)
```

#### æ¶æ„å›¾

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Go Runtime                        â”‚
â”‚                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚    P0    â”‚  â”‚    P1    â”‚  â”‚    P2    â”‚ ...     â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â” â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â” â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â” â”‚         â”‚
â”‚  â”‚ â”‚ LRQ  â”‚ â”‚  â”‚ â”‚ LRQ  â”‚ â”‚  â”‚ â”‚ LRQ  â”‚ â”‚         â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”˜ â”‚         â”‚
â”‚  â”‚          â”‚  â”‚          â”‚  â”‚          â”‚         â”‚
â”‚  â”‚  G_exec  â”‚  â”‚  G_exec  â”‚  â”‚  G_exec  â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜         â”‚
â”‚       â”‚             â”‚             â”‚                â”‚
â”‚       â†“             â†“             â†“                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚   M0   â”‚    â”‚   M1   â”‚    â”‚   M2   â”‚  ...      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚       â”‚             â”‚             â”‚                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚             â”‚             â”‚
        â†“             â†“             â†“
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  OS    â”‚    â”‚  OS    â”‚    â”‚  OS    â”‚
   â”‚ Thread â”‚    â”‚ Thread â”‚    â”‚ Thread â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜

   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   Global Run Queue (GRQ)    â”‚
   â”‚   Gâ‚ â†’ Gâ‚‚ â†’ Gâ‚ƒ â†’ ... â†’ Gâ‚™  â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚    Network Poller (NP)      â”‚
   â”‚   ç­‰å¾…I/Oçš„Goroutineé›†åˆ     â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 G (Goroutine)

#### Goroutine çŠ¶æ€æœº

```mathematical
/* Goroutine çŠ¶æ€å®šä¹‰ */

GoroutineState ::= 
    | Runnable      /* å¯è¿è¡Œï¼Œåœ¨è¿è¡Œé˜Ÿåˆ—ä¸­ */
    | Running       /* æ­£åœ¨æ‰§è¡Œ */
    | Waiting       /* ç­‰å¾…ä¸­ (I/O, channel, lockç­‰) */
    | Dead          /* å·²ç»ˆæ­¢ */
    | Syscall       /* ç³»ç»Ÿè°ƒç”¨ä¸­ */
    | Preempted     /* è¢«æŠ¢å  */

/* çŠ¶æ€è½¬æ¢ */

Runnable --schedule--> Running
Running --yield/preempt--> Runnable
Running --block--> Waiting
Waiting --ready--> Runnable
Running --exit--> Dead
Running --syscall--> Syscall
Syscall --return--> Runnable

/* å½¢å¼åŒ–çŠ¶æ€è½¬æ¢ç³»ç»Ÿ */

(g, sâ‚) --action--> (g, sâ‚‚)

[Schedule]
g âˆˆ RunQueue    g.state = Runnable    P available
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(g, Runnable) --schedule--> (g, Running)

[Yield]
g.state = Running    quantum_expired
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(g, Running) --yield--> (g, Runnable)

[Block]
g.state = Running    waiting_on(channel/lock/io)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(g, Running) --block--> (g, Waiting)

[Wake]
g.state = Waiting    condition_satisfied
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(g, Waiting) --wake--> (g, Runnable)
```

#### Goroutine æ•°æ®ç»“æ„

```go
// ç®€åŒ–çš„ Goroutine ç»“æ„ (runtime.g)
type g struct {
    // Stack ä¿¡æ¯
    stack struct {
        lo uintptr  // æ ˆåº•
        hi uintptr  // æ ˆé¡¶
    }
    stackguard0 uintptr  // æ ˆä¿æŠ¤
    
    // çŠ¶æ€
    atomicstatus atomic.Uint32  // G çš„çŠ¶æ€
    goid         uint64          // Goroutine ID
    
    // è°ƒåº¦ç›¸å…³
    sched gobuf    // è°ƒåº¦ä¸Šä¸‹æ–‡
    waitsince int64  // ç­‰å¾…å¼€å§‹æ—¶é—´
    waitreason waitReason  // ç­‰å¾…åŸå› 
    
    // æŠ¢å ç›¸å…³
    preempt       bool    // æŠ¢å æ ‡è®°
    preemptStop   bool    // åœæ­¢æ ‡è®°
    preemptShrink bool    // æ ˆæ”¶ç¼©æ ‡è®°
    
    // å…³è”çš„ M å’Œ P
    m  *m   // å½“å‰è¿è¡Œçš„ M
    lockedm *m  // é”å®šçš„ M
    
    // Panic/Defer
    _panic *_panic
    _defer *_defer
}

// è°ƒåº¦ä¸Šä¸‹æ–‡
type gobuf struct {
    sp   uintptr  // æ ˆæŒ‡é’ˆ
    pc   uintptr  // ç¨‹åºè®¡æ•°å™¨
    g    *g       // å…³è”çš„ g
    ret  uintptr  // è¿”å›å€¼
    bp   uintptr  // åŸºæŒ‡é’ˆ (amd64)
}
```

### 1.3 M (Machine/OS Thread)

#### M çš„è§’è‰²ä¸è´£ä»»

```mathematical
/* M (Machine) å½¢å¼åŒ–å®šä¹‰ */

M = (id, thread_id, p, g0, curg, nextp, spinning, locks)

å…¶ä¸­:
- id: Mçš„å”¯ä¸€æ ‡è¯†
- thread_id: æ“ä½œç³»ç»Ÿçº¿ç¨‹ID
- p: å½“å‰ç»‘å®šçš„P
- g0: Mçš„è°ƒåº¦æ ˆG
- curg: å½“å‰æ­£åœ¨è¿è¡Œçš„G
- nextp: ä¸‹ä¸€ä¸ªè¦ç»‘å®šçš„P
- spinning: æ˜¯å¦æ­£åœ¨å¯»æ‰¾å¯è¿è¡Œçš„G
- locks: é”è®¡æ•°

/* M çš„çŠ¶æ€ */

MState ::= 
    | Idle         /* ç©ºé—² */
    | Running      /* è¿è¡Œä¸­ */
    | Spinning     /* è‡ªæ—‹å¯»æ‰¾å·¥ä½œ */
    | Blocked      /* é˜»å¡ (ç³»ç»Ÿè°ƒç”¨) */

/* M çš„è¡Œä¸ºè§„èŒƒ */

[M-Start]
åˆ›å»ºæ–°M:
  1. åˆ†é…Mç»“æ„
  2. åˆ›å»ºOSçº¿ç¨‹
  3. è®¾ç½®g0 (è°ƒåº¦æ ˆ)
  4. å¼€å§‹è°ƒåº¦å¾ªç¯

[M-Schedule]
è°ƒåº¦å¾ªç¯:
  while true:
    1. è·å–å¯è¿è¡Œçš„G
    2. æ‰§è¡ŒG
    3. Gç»“æŸ/é˜»å¡åå›åˆ°æ­¥éª¤1

[M-Block]
ç³»ç»Ÿè°ƒç”¨é˜»å¡:
  1. Mä¸Pè§£ç»‘
  2. Pè¢«å…¶ä»–Mæ¥ç®¡
  3. Mæ‰§è¡Œç³»ç»Ÿè°ƒç”¨
  4. è¿”å›åå°è¯•é‡æ–°è·å–P
```

#### M æ•°æ®ç»“æ„

```go
// ç®€åŒ–çš„ M ç»“æ„ (runtime.m)
type m struct {
    // ç‰¹æ®Šçš„ G
    g0      *g    // ç”¨äºè°ƒåº¦çš„ g
    curg    *g    // å½“å‰è¿è¡Œçš„ g
    
    // å…³è”çš„ P
    p       *p    // å½“å‰å…³è”çš„ p
    nextp   *p    // å”¤é†’ m æ—¶å…³è”çš„ p
    oldp    *p    // ç³»ç»Ÿè°ƒç”¨å‰çš„ p
    
    // çº¿ç¨‹ä¿¡æ¯
    id      int64
    mallocing int32  // æ­£åœ¨åˆ†é…å†…å­˜
    throwing  int32  // æ­£åœ¨æŠ›å‡ºå¼‚å¸¸
    
    // è°ƒåº¦çŠ¶æ€
    spinning  bool   // æ˜¯å¦æ­£åœ¨è‡ªæ—‹å¯»æ‰¾å·¥ä½œ
    blocked   bool   // æ˜¯å¦é˜»å¡åœ¨ç¬”è®°
    
    // é”
    locks     int32
    
    // ä¿¡å·å¤„ç†
    gsignal   *g    // ä¿¡å·å¤„ç†çš„ g
    sigmask   sigset
}
```

### 1.4 P (Processor)

#### P çš„è§’è‰²

P ä»£è¡¨æ‰§è¡Œ Go ä»£ç æ‰€éœ€çš„èµ„æºã€‚

```mathematical
/* P (Processor) å½¢å¼åŒ–å®šä¹‰ */

P = (id, status, runq, runnext, m, mcache)

å…¶ä¸­:
- id: Pçš„å”¯ä¸€æ ‡è¯† (0 åˆ° GOMAXPROCS-1)
- status: Pçš„çŠ¶æ€
- runq: æœ¬åœ°è¿è¡Œé˜Ÿåˆ— (å¤§å°256çš„å¾ªç¯é˜Ÿåˆ—)
- runnext: ä¸‹ä¸€ä¸ªè¦è¿è¡Œçš„G (ä¼˜å…ˆçº§é«˜)
- m: å½“å‰ç»‘å®šçš„M
- mcache: Pçš„å†…å­˜ç¼“å­˜

/* P çš„çŠ¶æ€ */

PStatus ::= 
    | Idle      /* ç©ºé—²ï¼Œåœ¨ç©ºé—²Påˆ—è¡¨ä¸­ */
    | Running   /* æ­£åœ¨æ‰§è¡ŒGoä»£ç  */
    | Syscall   /* æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ */
    | GCstop    /* åœæ­¢ä»¥è¿›è¡ŒGC */
    | Dead      /* På·²ä¸å†ä½¿ç”¨ */

/* P æœ¬åœ°é˜Ÿåˆ—æ“ä½œ */

enqueue: P Ã— G â†’ P
  å°†GåŠ å…¥Pçš„æœ¬åœ°é˜Ÿåˆ—
  å¦‚æœé˜Ÿåˆ—æ»¡ï¼Œåˆ™è½¬ç§»ä¸€åŠåˆ°å…¨å±€é˜Ÿåˆ—

dequeue: P â†’ G âˆª {âˆ…}
  ä»Pçš„æœ¬åœ°é˜Ÿåˆ—å–å‡ºG
  ä¼˜å…ˆå–runnextï¼Œç„¶åä»é˜Ÿåˆ—å¤´å–

steal: P Ã— P â†’ G âˆª {âˆ…}
  ä»å¦ä¸€ä¸ªPçš„é˜Ÿåˆ—å·å–G
  é€šå¸¸å·å–é˜Ÿåˆ—ä¸€åŠçš„G
```

#### P æ•°æ®ç»“æ„

```go
// ç®€åŒ–çš„ P ç»“æ„ (runtime.p)
type p struct {
    id          int32
    status      uint32  // P çš„çŠ¶æ€
    
    // å…³è”çš„ M
    m           *m
    
    // æœ¬åœ°è¿è¡Œé˜Ÿåˆ—
    runqhead    uint32
    runqtail    uint32
    runq        [256]*g  // æœ¬åœ°é˜Ÿåˆ— (å¾ªç¯é˜Ÿåˆ—)
    runnext     *g       // ä¸‹ä¸€ä¸ªè¿è¡Œçš„ G (ä¼˜å…ˆçº§æœ€é«˜)
    
    // å†…å­˜åˆ†é…
    mcache      *mcache
    
    // GC ç›¸å…³
    gcBgMarkWorker *g
    gcw            gcWork
    
    // ç»Ÿè®¡
    runqsize    int32  // æœ¬åœ°é˜Ÿåˆ—å¤§å°
    goidcache   uint64
    goidcacheend uint64
    
    // å®šæ—¶å™¨
    timers      []*timer
    numTimers   uint32
}
```

---

## ç¬¬äºŒéƒ¨åˆ†: è°ƒåº¦ç®—æ³•å½¢å¼åŒ–

### 2.1 Work-Stealingç®—æ³•

Go è°ƒåº¦å™¨ä½¿ç”¨ **Work-Stealing** ç®—æ³•å®ç°è´Ÿè½½å‡è¡¡ã€‚

#### ç®—æ³•å½¢å¼åŒ–

```mathematical
/* Work-Stealing ç®—æ³• */

FindRunnable(p: P) â†’ G:
  /* 1. æ£€æŸ¥æœ¬åœ°é˜Ÿåˆ— */
  if g â† dequeue(p.runq):
    return g
  
  /* 2. æ£€æŸ¥å…¨å±€é˜Ÿåˆ— (æ¯61æ¬¡è°ƒåº¦æ£€æŸ¥ä¸€æ¬¡) */
  if schedtick % 61 == 0:
    if g â† dequeue(globalRunQueue):
      return g
  
  /* 3. æ£€æŸ¥ç½‘ç»œè½®è¯¢å™¨ */
  if g â† pollNetworkPoller():
    return g
  
  /* 4. ä»å…¶ä»– P å·å– */
  for i â† 0 to GOMAXPROCS:
    p' â† randomP()
    if gs â† steal(p', p):
      return gs[0]  /* å·å–å¤šä¸ªï¼Œè¿”å›ä¸€ä¸ª */
  
  /* 5. å†æ¬¡æ£€æŸ¥å…¨å±€é˜Ÿåˆ— */
  if g â† dequeue(globalRunQueue):
    return g
  
  /* 6. å†æ¬¡æ£€æŸ¥ç½‘ç»œè½®è¯¢å™¨ (é˜»å¡) */
  if g â† blockPollNetworkPoller():
    return g
  
  /* 7. è¿›å…¥ä¼‘çœ  */
  return âˆ…

/* å·å–ç®—æ³• */

Steal(victim: P, thief: P) â†’ [G]:
  /* ä» victim å·å–ä¸€åŠçš„ G */
  n â† |victim.runq| / 2
  gs â† âˆ…
  
  for i â† 1 to n:
    g â† dequeue(victim.runq)
    if g â‰  âˆ…:
      gs â† gs âˆª {g}
  
  /* å°†å·å–çš„ G æ”¾å…¥ thief çš„æœ¬åœ°é˜Ÿåˆ— */
  for g in gs[1:]:
    enqueue(thief.runq, g)
  
  return gs  /* è¿”å›å·å–çš„ G åˆ—è¡¨ */
```

#### Go ä»£ç å®ç°ï¼ˆç®€åŒ–ï¼‰

```go
// findRunnable æŸ¥æ‰¾å¯è¿è¡Œçš„ Goroutine
func findRunnable() *g {
    _g_ := getg()
    _p_ := _g_.m.p.ptr()
    
top:
    // 1. æœ¬åœ°è¿è¡Œé˜Ÿåˆ—
    if gp := runqget(_p_); gp != nil {
        return gp
    }
    
    // 2. å…¨å±€è¿è¡Œé˜Ÿåˆ— (æ¯61æ¬¡æ£€æŸ¥ä¸€æ¬¡)
    if _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {
        lock(&sched.lock)
        gp := globrunqget(_p_, 1)
        unlock(&sched.lock)
        if gp != nil {
            return gp
        }
    }
    
    // 3. ç½‘ç»œè½®è¯¢å™¨
    if netpollinited() && netpollWaiters.Load() > 0 {
        if list := netpoll(0); !list.empty() {
            gp := list.pop()
            injectglist(&list)
            return gp
        }
    }
    
    // 4. Work Stealing
    for i := 0; i < 4; i++ {
        for enum := stealOrder.start(); !enum.done(); enum.next() {
            p2 := allp[enum.position()]
            if _p_ == p2 {
                continue
            }
            
            // ä» p2 å·å–
            if gp := runqsteal(_p_, p2); gp != nil {
                return gp
            }
        }
    }
    
    // 5. å†æ¬¡æ£€æŸ¥å…¨å±€é˜Ÿåˆ—
    lock(&sched.lock)
    if sched.runqsize != 0 {
        gp := globrunqget(_p_, 0)
        unlock(&sched.lock)
        return gp
    }
    unlock(&sched.lock)
    
    // 6. é˜»å¡åœ¨ç½‘ç»œè½®è¯¢å™¨
    if netpollinited() && netpollWaiters.Load() > 0 {
        if list := netpoll(int64(-1)); !list.empty() {
            gp := list.pop()
            injectglist(&list)
            return gp
        }
    }
    
    // 7. æ²¡æœ‰å·¥ä½œï¼Œä¼‘çœ 
    stopm()
    goto top
}

// runqsteal ä» p2 å·å– G åˆ° p
func runqsteal(_p_, p2 *p) *g {
    n := len(p2.runq) / 2
    if n == 0 {
        return nil
    }
    
    // å·å–ä¸€åŠ
    for i := 0; i < n; i++ {
        gp := runqget(p2)
        if gp == nil {
            break
        }
        runqput(_p_, gp, false)
    }
    
    return runqget(_p_)
}
```

### 2.2 åä½œå¼æŠ¢å 

#### æŠ¢å æœºåˆ¶å½¢å¼åŒ–

```mathematical
/* åä½œå¼æŠ¢å  (Cooperative Preemption) */

/* æŠ¢å æ¡ä»¶ */
ShouldPreempt(g: G) â†’ Bool:
  return g.executionTime > quantumTime âˆ¨
         gcWaiting âˆ¨
         sysmonWants

/* æŠ¢å ç‚¹ (Preemption Points) */
PreemptionPoint ::=
  | FunctionCall      /* å‡½æ•°è°ƒç”¨æ—¶ */
  | LoopBackEdge      /* å¾ªç¯å›è¾¹ */
  | ChannelOp         /* Channel æ“ä½œ */
  | SelectStatement   /* Select è¯­å¥ */
  | GCCheck           /* GC æ£€æŸ¥ç‚¹ */

/* æŠ¢å æ‰§è¡Œ */
[Preempt]
g.state = Running
ShouldPreempt(g) = true
AtPreemptionPoint(g) = true
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(g, Running) --preempt--> (g, Runnable)
```

#### ç¼–è¯‘å™¨æ’å…¥çš„æŠ¢å æ£€æŸ¥

```go
// ç¼–è¯‘å™¨åœ¨å‡½æ•°å‰æ’å…¥æ ˆå¢é•¿æ£€æŸ¥ï¼ŒåŒæ—¶ä½œä¸ºæŠ¢å ç‚¹
func someFunction() {
    // ç¼–è¯‘å™¨ç”Ÿæˆçš„ä»£ç  (ç®€åŒ–)
    if stackNeedGrow() || g.stackguard0 == stackPreempt {
        morestack()  // å¯èƒ½è§¦å‘æŠ¢å 
    }
    
    // å®é™…å‡½æ•°ä½“
    // ...
}

// å¾ªç¯ä¸­çš„æŠ¢å æ£€æŸ¥
func longLoop() {
    for i := 0; i < 1000000; i++ {
        // ç¼–è¯‘å™¨åœ¨å¾ªç¯å›è¾¹æ’å…¥æŠ¢å æ£€æŸ¥
        if i%10000 == 0 {
            // æ£€æŸ¥æŠ¢å 
            if getg().stackguard0 == stackPreempt {
                gopreempt_m()
            }
        }
        // å¾ªç¯ä½“
    }
}
```

### 2.3 å¼‚æ­¥æŠ¢å  (Go 1.14+)

Go 1.14 å¼•å…¥äº†**å¼‚æ­¥æŠ¢å **ï¼Œè§£å†³äº†åä½œå¼æŠ¢å çš„å±€é™ã€‚

```mathematical
/* å¼‚æ­¥æŠ¢å  (Asynchronous Preemption) */

/* åŸºäºä¿¡å·çš„æŠ¢å  */

AsyncPreempt(m: M, g: G):
  1. sysmon æ£€æµ‹åˆ° G è¿è¡Œæ—¶é—´è¿‡é•¿
  2. å‘ M å¯¹åº”çš„çº¿ç¨‹å‘é€ SIGURG ä¿¡å·
  3. ä¿¡å·å¤„ç†å™¨ä¿å­˜ G çš„ä¸Šä¸‹æ–‡
  4. æ ‡è®° G ä¸ºå¯æŠ¢å 
  5. è°ƒåº¦å™¨åˆ‡æ¢åˆ°å¦ä¸€ä¸ª G

/* æŠ¢å æµç¨‹å½¢å¼åŒ– */

[Async-Preempt-Detect]
g âˆˆ Running
g.executionTime > maxExecutionTime
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
sysmon.requestPreempt(g)

[Async-Preempt-Signal]
requestPreempt(g)
g.m = m
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
sendSignal(m.thread, SIGURG)

[Async-Preempt-Handle]
receivedSignal(SIGURG)
g.state = Running
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
saveContext(g) â†’
g.state = Runnable â†’
schedule()
```

#### å¼‚æ­¥æŠ¢å å®ç°

```go
// sysmon: ç³»ç»Ÿç›‘æ§ Goroutine
func sysmon() {
    for {
        // ä¼‘çœ ä¸€æ®µæ—¶é—´
        usleep(delay)
        
        // æ£€æŸ¥é•¿æ—¶é—´è¿è¡Œçš„ G
        now := nanotime()
        for _, _p_ := range allp {
            _g_ := _p_.m.curg
            if _g_ == nil {
                continue
            }
            
            // æ£€æŸ¥è¿è¡Œæ—¶é—´
            runningTime := now - _g_.startTime
            if runningTime > 10*time.Millisecond {
                // è¯·æ±‚å¼‚æ­¥æŠ¢å 
                preemptone(_p_)
            }
        }
    }
}

// preemptone: æŠ¢å ä¸€ä¸ª P
func preemptone(_p_ *p) bool {
    mp := _p_.m.ptr()
    if mp == nil || mp == getg().m {
        return false
    }
    
    gp := mp.curg
    if gp == nil || gp == mp.g0 {
        return false
    }
    
    // æ ‡è®° G ä¸ºå¯æŠ¢å 
    gp.preempt = true
    gp.stackguard0 = stackPreempt
    
    // Go 1.14+: å‘é€å¼‚æ­¥æŠ¢å ä¿¡å·
    if preemptMSupported {
        signalM(mp, sigPreempt)  // å‘é€ SIGURG
    }
    
    return true
}

// ä¿¡å·å¤„ç†å™¨
func sighandler(sig uint32, info *siginfo, ctx unsafe.Pointer) {
    if sig == sigPreempt {  // SIGURG
        // ä¿å­˜ä¸Šä¸‹æ–‡
        doSigPreempt(getg(), ctx)
    }
}

func doSigPreempt(gp *g, ctx unsafe.Pointer) {
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥å®‰å…¨æŠ¢å 
    if !canPreempt(gp) {
        return
    }
    
    // ä¿å­˜å¯„å­˜å™¨çŠ¶æ€
    gp.sigpc = uintptr(ctx.rip)
    gp.sigsp = uintptr(ctx.rsp)
    
    // æ ‡è®°ä¸ºå¯æŠ¢å 
    gp.preemptStop = true
    
    // åœ¨å®‰å…¨ç‚¹æ³¨å…¥æŠ¢å è°ƒç”¨
    ctx.rip = funcPC(asyncPreempt)
}
```

### 2.4 å…¬å¹³æ€§ä¿è¯

```mathematical
/* å…¬å¹³æ€§ (Fairness) */

/* å®šä¹‰: æ¯ä¸ªå¯è¿è¡Œçš„ G æœ€ç»ˆéƒ½ä¼šè¢«è°ƒåº¦ */

Fairness ::= âˆ€g âˆˆ Runnable. â—‡(g âˆˆ Running)

/* å…¬å¹³æ€§ä¿è¯æœºåˆ¶ */

1. æœ¬åœ°é˜Ÿåˆ— FIFO:
   enqueue(p.runq, g) â†’ 
   g æœ€ç»ˆä¼šè¢« dequeue

2. å…¨å±€é˜Ÿåˆ—å®šæœŸæ£€æŸ¥:
   æ¯61æ¬¡è°ƒåº¦ â†’ æ£€æŸ¥å…¨å±€é˜Ÿåˆ—

3. Work-Stealing:
   ç©ºé—² P â†’ ä»å…¶ä»– P å·å–

4. é˜²æ­¢é¥¥é¥¿:
   g.waitsince > threshold â†’
   ä¼˜å…ˆè°ƒåº¦

/* æ—¶é—´å¤æ‚åº¦åˆ†æ */

æœ¬åœ°é˜Ÿåˆ—æ“ä½œ: O(1)
å…¨å±€é˜Ÿåˆ—æ“ä½œ: O(1) + lock overhead
Work-Stealing: O(P) å…¶ä¸­ P = GOMAXPROCS
æŸ¥æ‰¾å¯è¿è¡Œ G: O(P) æœ€åæƒ…å†µ
```

---

## ç¬¬ä¸‰éƒ¨åˆ†: å†…å­˜æ¨¡å‹ä¸åŒæ­¥

### 3.1 Happens-Beforeå…³ç³»

#### å½¢å¼åŒ–å®šä¹‰

```mathematical
/* Happens-Before å…³ç³» (â†’á´´á´®) */

/* åŸºç¡€è§„åˆ™ */

[HB-ProgramOrder]
åœ¨åŒä¸€Goroutineä¸­ï¼Œè¯­å¥ a åœ¨ b ä¹‹å‰
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
a â†’á´´á´® b

[HB-Goroutine-Start]
go statement s creates goroutine g
s executes statement a
g executes statement b
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
a â†’á´´á´® b

[HB-Goroutine-Exit]
goroutine g executes statement a
g exits
statement b observes g has exited
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
a â†’á´´á´® b

[HB-Channel-Send]
send on channel c precedes receive on c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
send(c, v) â†’á´´á´® receive(c) = v

[HB-Channel-Close]
close(c) precedes receive that returns zero
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
close(c) â†’á´´á´® (receive(c) = 0, false)

[HB-Transitivity]
a â†’á´´á´® b    b â†’á´´á´® c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
a â†’á´´á´® c

/* æ•°æ®ç«äº‰å®šä¹‰ */

DataRace(a, b) ::=
  a å’Œ b è®¿é—®åŒä¸€å†…å­˜ä½ç½® âˆ§
  (a æ˜¯å†™æ“ä½œ âˆ¨ b æ˜¯å†™æ“ä½œ) âˆ§
  Â¬(a â†’á´´á´® b) âˆ§
  Â¬(b â†’á´´á´® a)

/* æ— ç«äº‰ç¨‹åºä¿è¯ */

DRF-Guarantee:
  å¦‚æœç¨‹åºæ— æ•°æ®ç«äº‰ï¼Œåˆ™å…¶æ‰§è¡Œç­‰ä»·äºæŸä¸ªäº¤é”™æ‰§è¡Œ
```

#### ä»£ç ç¤ºä¾‹

```go
// Happens-Before ç¤ºä¾‹

// ç¤ºä¾‹1: Goroutine å¯åŠ¨
var a string

func setup() {
    a = "hello"  // (1)
}

func main() {
    go setup()   // (2)
    // (1) happens-before (2) ä¹‹åçš„æ‰€æœ‰æ“ä½œ
}

// ç¤ºä¾‹2: Channel åŒæ­¥
var done = make(chan bool)
var msg string

func sender() {
    msg = "hello"  // (1)
    done <- true   // (2) send
}

func receiver() {
    <-done         // (3) receive
    println(msg)   // (4)
}

// Happens-Before é“¾: (1) â†’ (2) â†’ (3) â†’ (4)
// ä¿è¯ (4) çœ‹åˆ° (1) çš„å†™å…¥

// ç¤ºä¾‹3: é”™è¯¯çš„åŒæ­¥ (æ•°æ®ç«äº‰)
var counter int

func increment() {
    counter++  // æ•°æ®ç«äº‰!
}

func main() {
    go increment()
    go increment()
    // ä¸¤ä¸ª increment å¹¶å‘è®¿é—® counterï¼Œæ— åŒæ­¥
}

// ç¤ºä¾‹4: æ­£ç¡®çš„åŒæ­¥
var (
    counterMu sync.Mutex
    counter   int
)

func incrementSafe() {
    counterMu.Lock()   // (1)
    counter++          // (2)
    counterMu.Unlock() // (3)
}

// Happens-Before: Lock â†’ Write â†’ Unlock
```

### 3.2 ChannelåŒæ­¥è¯­ä¹‰

#### æ— ç¼“å†²Channel

```mathematical
/* æ— ç¼“å†²Channelè¯­ä¹‰ */

/* æ“ä½œå®šä¹‰ */
send(c, v):   é˜»å¡ç›´åˆ°æœ‰æ¥æ”¶è€…
receive(c):   é˜»å¡ç›´åˆ°æœ‰å‘é€è€…

/* åŒæ­¥ç‚¹ */
send(c, v) å’Œ receive(c) å¿…é¡»åŒæ­¥

/* Happens-Before è§„åˆ™ */
[Unbuffered-Channel]
gâ‚: send(c, v)    // æ—¶åˆ» tâ‚
gâ‚‚: receive(c)    // æ—¶åˆ» tâ‚‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
send happens-before receive
v is transmitted atomically

/* å½¢å¼åŒ–æ¨¡å‹ (CSP) */
UnbufferedChannel(c) = c!v â†’ c?x â†’ P
å…¶ä¸­ c!v å’Œ c?x å¿…é¡»åŒæ­¥å‘ç”Ÿ
```

#### æœ‰ç¼“å†²Channel

```mathematical
/* æœ‰ç¼“å†²Channelè¯­ä¹‰ */

/* æ“ä½œå®šä¹‰ */
send(c, v):   
  if len(c) < cap(c):
    ç«‹å³å†™å…¥ï¼Œä¸é˜»å¡
  else:
    é˜»å¡ç›´åˆ°æœ‰ç©ºé—´

receive(c):
  if len(c) > 0:
    ç«‹å³è¯»å–ï¼Œä¸é˜»å¡
  else:
    é˜»å¡ç›´åˆ°æœ‰æ•°æ®

/* Happens-Before è§„åˆ™ */
[Buffered-Channel-Send]
ç¬¬ k æ¬¡ send happens-before ç¬¬ k æ¬¡ receive

[Buffered-Channel-Capacity]
ç¬¬ k æ¬¡ receive happens-before ç¬¬ (k+cap) æ¬¡ send
(ä¿è¯ç¼“å†²åŒºä¸æº¢å‡º)

/* å®¹é‡é™åˆ¶ */
len(c) â‰¤ cap(c)  // ä¸å˜é‡

/* å½¢å¼åŒ–æ¨¡å‹ */
BufferedChannel(c, n) = 
  c!v â†’ Buffer(1) âŠ“  // å‘é€
  Buffer(n)           // æ»¡æ—¶é˜»å¡

Buffer(k) = 
  (k < n) â†’ c!v â†’ Buffer(k+1) âŠ“
  (k > 0) â†’ c?x â†’ Buffer(k-1)
```

### 3.3 syncåŒ…åŸè¯­

#### Mutex è¯­ä¹‰

```mathematical
/* Mutex è¯­ä¹‰ */

/* æ“ä½œ */
Lock(m):   è·å–é”ï¼Œå¦‚æœå·²é”å®šåˆ™é˜»å¡
Unlock(m): é‡Šæ”¾é”

/* ä¸å˜é‡ */
1. Mutex åªèƒ½ç”±æŒæœ‰è€… Unlock
2. ä¸èƒ½ Unlock æœªé”å®šçš„ Mutex
3. Mutex ä¸å¯é‡å…¥

/* Happens-Before */
[Mutex-HB]
Unlock(m) at time tâ‚ happens-before
Lock(m) at time tâ‚‚ where tâ‚‚ > tâ‚

/* ä¸´ç•ŒåŒºäº’æ–¥ */
âˆ€t. |{g | g in critical section at t}| â‰¤ 1
```

#### RWMutex è¯­ä¹‰

```mathematical
/* RWMutex è¯­ä¹‰ */

/* æ“ä½œ */
Lock(rw):    ç‹¬å é” (å†™é”)
Unlock(rw):  é‡Šæ”¾å†™é”
RLock(rw):   å…±äº«é” (è¯»é”)
RUnlock(rw): é‡Šæ”¾è¯»é”

/* ä¸å˜é‡ */
1. å†™é”ä¸æ‰€æœ‰é”äº’æ–¥
2. å¤šä¸ªè¯»é”å¯ä»¥å…±å­˜
3. å†™è€…ä¼˜å…ˆ (å¯é€‰)

/* çŠ¶æ€ */
RWMutexState ::=
  | Unlocked
  | ReadLocked(n: Nat)  // n ä¸ªè¯»è€…
  | WriteLocked

/* è½¬æ¢è§„åˆ™ */
[RLock]
state = Unlocked âˆ¨ state = ReadLocked(n)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
state' = ReadLocked(n+1)

[RUnlock]
state = ReadLocked(n)    n > 0
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
state' = ReadLocked(n-1) if n>1
state' = Unlocked if n=1

[Lock]
state = Unlocked
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
state' = WriteLocked

[Unlock]
state = WriteLocked
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
state' = Unlocked
```

### 3.4 å†…å­˜å±éšœ

```mathematical
/* å†…å­˜å±éšœ (Memory Barriers) */

/* å±éšœç±»å‹ */
Barrier ::=
  | LoadLoad    /* é˜²æ­¢è¯»æ“ä½œé‡æ’ */
  | LoadStore   /* é˜²æ­¢è¯»-å†™é‡æ’ */
  | StoreStore  /* é˜²æ­¢å†™æ“ä½œé‡æ’ */
  | StoreLoad   /* é˜²æ­¢å†™-è¯»é‡æ’(æœ€å¼º) */

/* Go ä¸­çš„å†…å­˜å±éšœ */

1. Channel æ“ä½œ:
   send/receive åŒ…å« StoreLoad å±éšœ

2. Mutex:
   Lock   â†’ Acquire barrier
   Unlock â†’ Release barrier

3. atomic æ“ä½œ:
   atomic.Store â†’ Release barrier
   atomic.Load  â†’ Acquire barrier
   atomic.CompareAndSwap â†’ Full barrier

/* å½¢å¼åŒ– */
[Memory-Order]
å¦‚æœ a happens-before bï¼Œåˆ™:
  - a çš„å†…å­˜æ•ˆæœå¯¹ b å¯è§
  - a åœ¨ b ä¹‹å‰æ‰§è¡Œ (ç¨‹åºé¡ºåº)
  - ç¼–è¯‘å™¨å’ŒCPUä¸èƒ½å°† b é‡æ’åˆ° a ä¹‹å‰
```

---

## ç¬¬å››éƒ¨åˆ†: æ€§èƒ½ä¼˜åŒ–æœºåˆ¶

### 4.1 æœ¬åœ°è¿è¡Œé˜Ÿåˆ—

```go
// P çš„æœ¬åœ°è¿è¡Œé˜Ÿåˆ—ä¼˜åŒ–

const _RUNQSIZE = 256  // æœ¬åœ°é˜Ÿåˆ—å¤§å°

type p struct {
    runqhead uint32
    runqtail uint32
    runq     [_RUNQSIZE]*g
    runnext  *g  // ä¸‹ä¸€ä¸ªä¼˜å…ˆè¿è¡Œçš„G
    
    // ç»Ÿè®¡
    runqsize int32
}

// runqput: å°† G æ”¾å…¥æœ¬åœ°é˜Ÿåˆ—
func runqput(_p_ *p, gp *g, next bool) {
    if next {
        // æ”¾å…¥ runnext (æœ€é«˜ä¼˜å…ˆçº§)
        oldnext := _p_.runnext
        if !atomic.Cas(&_p_.runnext, oldnext, gp) {
            // CAS å¤±è´¥ï¼Œé‡è¯•æˆ–æ”¾å…¥é˜Ÿåˆ—
            return
        }
        if oldnext == nil {
            return
        }
        gp = oldnext  // å°†æ—§çš„ runnext æ”¾å…¥é˜Ÿåˆ—
    }
    
retry:
    h := atomic.Load(&_p_.runqhead)
    t := _p_.runqtail
    if t-h < _RUNQSIZE {
        // é˜Ÿåˆ—æœªæ»¡ï¼ŒåŠ å…¥é˜Ÿåˆ—
        _p_.runq[t%_RUNQSIZE] = gp
        atomic.Store(&_p_.runqtail, t+1)
        return
    }
    
    // é˜Ÿåˆ—å·²æ»¡ï¼Œè½¬ç§»ä¸€åŠåˆ°å…¨å±€é˜Ÿåˆ—
    if !runqputslow(_p_, gp, h, t) {
        goto retry
    }
}

// runqget: ä»æœ¬åœ°é˜Ÿåˆ—è·å– G
func runqget(_p_ *p) *g {
    // ä¼˜å…ˆå– runnext
    next := _p_.runnext
    if next != nil && _p_.runnext.cas(next, nil) {
        return next
    }
    
    // ä»é˜Ÿåˆ—å¤´å–
    for {
        h := atomic.Load(&_p_.runqhead)
        t := atomic.Load(&_p_.runqtail)
        if t == h {
            return nil  // é˜Ÿåˆ—ç©º
        }
        
        gp := _p_.runq[h%_RUNQSIZE]
        if atomic.Cas(&_p_.runqhead, h, h+1) {
            return gp
        }
    }
}
```

### 4.2 å…¨å±€è¿è¡Œé˜Ÿåˆ—

```go
// å…¨å±€è¿è¡Œé˜Ÿåˆ—

type schedt struct {
    lock    mutex
    runq    gQueue   // å…¨å±€è¿è¡Œé˜Ÿåˆ—
    runqsize int32   // é˜Ÿåˆ—å¤§å°
    
    // å…¶ä»–å­—æ®µ...
}

// globrunqput: å°† G æ”¾å…¥å…¨å±€é˜Ÿåˆ—
func globrunqput(gp *g) {
    sched.runq.push(gp)
    sched.runqsize++
}

// globrunqget: ä»å…¨å±€é˜Ÿåˆ—è·å– G
func globrunqget(_p_ *p, max int32) *g {
    assertLockHeld(&sched.lock)
    
    if sched.runqsize == 0 {
        return nil
    }
    
    // æœ€å¤šå– max ä¸ªï¼Œä½†ä¸è¶…è¿‡æœ¬åœ°é˜Ÿåˆ—å®¹é‡çš„ä¸€åŠ
    n := sched.runqsize/gomaxprocs + 1
    if n > sched.runqsize {
        n = sched.runqsize
    }
    if max > 0 && n > max {
        n = max
    }
    if n > int32(len(_p_.runq))/2 {
        n = int32(len(_p_.runq)) / 2
    }
    
    // è½¬ç§»åˆ°æœ¬åœ°é˜Ÿåˆ—
    sched.runqsize -= n
    gp := sched.runq.pop()
    n--
    for ; n > 0; n-- {
        gp1 := sched.runq.pop()
        runqput(_p_, gp1, false)
    }
    return gp
}

// runqputslow: æœ¬åœ°é˜Ÿåˆ—æ»¡æ—¶ï¼Œè½¬ç§»ä¸€åŠåˆ°å…¨å±€
func runqputslow(_p_ *p, gp *g, h, t uint32) bool {
    var batch [_RUNQSIZE/2]*g
    
    // å–å‡ºä¸€åŠ
    n := t - h
    n = n / 2
    for i := uint32(0); i < n; i++ {
        batch[i] = _p_.runq[(h+i)%_RUNQSIZE]
    }
    
    // åŠ å…¥å…¨å±€é˜Ÿåˆ—
    lock(&sched.lock)
    for i := uint32(0); i < n; i++ {
        globrunqput(batch[i])
    }
    globrunqput(gp)
    unlock(&sched.lock)
    
    return true
}
```

### 4.3 ç½‘ç»œè½®è¯¢å™¨é›†æˆ

```go
// ç½‘ç»œè½®è¯¢å™¨ä¸è°ƒåº¦å™¨é›†æˆ

// netpoll: æ£€æŸ¥å°±ç»ªçš„ç½‘ç»œè¿æ¥
func netpoll(delay int64) gList {
    if netpollinited() == 0 {
        return gList{}
    }
    
    // delay < 0:  é˜»å¡ç­‰å¾…
    // delay == 0: éé˜»å¡è½®è¯¢
    // delay > 0:  ç­‰å¾…æœ€å¤š delay çº³ç§’
    
    list := netpollGeneric(delay)
    return list
}

// é›†æˆåˆ°è°ƒåº¦å¾ªç¯
func schedule() {
    _g_ := getg()
    
top:
    // ... å…¶ä»–è°ƒåº¦é€»è¾‘ ...
    
    // æ£€æŸ¥ç½‘ç»œè½®è¯¢å™¨
    if netpollinited() && atomic.Load(&netpollWaiters) > 0 {
        list := netpoll(0)  // éé˜»å¡æ£€æŸ¥
        if !list.empty() {
            // å°†å°±ç»ªçš„ G æ³¨å…¥è¿è¡Œé˜Ÿåˆ—
            injectglist(&list)
        }
    }
    
    // ... ç»§ç»­è°ƒåº¦ ...
}

// injectglist: å°† G åˆ—è¡¨æ³¨å…¥è¿è¡Œé˜Ÿåˆ—
func injectglist(glist *gList) {
    if glist.empty() {
        return
    }
    
    lock(&sched.lock)
    var n int
    for n = 0; !glist.empty(); n++ {
        gp := glist.pop()
        casgstatus(gp, _Gwaiting, _Grunnable)
        globrunqput(gp)
    }
    unlock(&sched.lock)
    
    // å”¤é†’è¶³å¤Ÿçš„ P æ¥è¿è¡Œè¿™äº› G
    for ; n > 0 && sched.npidle.Load() > 0; n-- {
        startm(nil, false)
    }
}

// gopark: å°†å½“å‰ G åœåœ¨ç½‘ç»œè½®è¯¢å™¨ä¸Š
func gopark(unlockf func(*g, unsafe.Pointer) bool, 
            lock unsafe.Pointer, 
            reason waitReason,
            traceEv byte, 
            traceskip int) {
    _g_ := getg()
    _g_.waitreason = reason
    
    // è§£é™¤ G ä¸ M çš„ç»‘å®š
    releasem(_g_.m)
    
    // è°ƒç”¨ unlock å‡½æ•°
    if unlockf != nil {
        unlockf(_g_, lock)
    }
    
    // è®©å‡º Pï¼Œè¿›å…¥è°ƒåº¦
    mcall(park_m)
}
```

### 4.4 ç³»ç»Ÿè°ƒç”¨å¤„ç†

```go
// ç³»ç»Ÿè°ƒç”¨çš„è°ƒåº¦å¤„ç†

// entersyscall: è¿›å…¥ç³»ç»Ÿè°ƒç”¨
func entersyscall() {
    _g_ := getg()
    _g_.m.locks++
    
    // ä¿å­˜å½“å‰çŠ¶æ€
    save(getcallerpc(), getcallersp())
    _g_.syscallsp = _g_.sched.sp
    _g_.syscallpc = _g_.sched.pc
    
    casgstatus(_g_, _Grunning, _Gsyscall)
    
    // è§£ç»‘ P (P å¯ä»¥å»è¿è¡Œå…¶ä»– G)
    _g_.m.oldp.set(_g_.m.p)
    _g_.m.p = nil
    atomic.Store(&_g_.m.oldp.ptr().status, _Psyscall)
    
    _g_.m.locks--
}

// exitsyscall: é€€å‡ºç³»ç»Ÿè°ƒç”¨
func exitsyscall() {
    _g_ := getg()
    
    _g_.m.locks++
    
    // å°è¯•é‡æ–°è·å–ä¹‹å‰çš„ P
    oldp := _g_.m.oldp.ptr()
    _g_.m.oldp = nil
    
    if exitsyscallfast(oldp) {
        // æˆåŠŸè·å– Pï¼Œç»§ç»­è¿è¡Œ
        casgstatus(_g_, _Gsyscall, _Grunning)
        _g_.syscallsp = 0
        _g_.m.locks--
        return
    }
    
    // æ— æ³•è·å– Pï¼Œå°† G æ”¾å…¥å…¨å±€é˜Ÿåˆ—
    _g_.m.locks--
    mcall(exitsyscall0)
}

// exitsyscallfast: å¿«é€Ÿè·¯å¾„é€€å‡ºç³»ç»Ÿè°ƒç”¨
func exitsyscallfast(oldp *p) bool {
    _g_ := getg()
    
    // å°è¯•é‡æ–°è·å–æ—§çš„ P
    if oldp != nil && oldp.status == _Psyscall {
        // æ—§çš„ P è¿˜åœ¨ç­‰å¾…ï¼Œå°è¯•è·å–
        if atomic.Cas(&oldp.status, _Psyscall, _Pidle) {
            // æˆåŠŸï¼Œé‡æ–°ç»‘å®š P
            wirep(oldp)
            exitsyscallfast_reacquired()
            return true
        }
    }
    
    // å°è¯•ä»ç©ºé—²åˆ—è¡¨è·å– P
    if sched.pidle != 0 {
        var s int64
        var pp *p
        systemstack(func() {
            lock(&sched.lock)
            pp = pidleget(&s)
            unlock(&sched.lock)
        })
        if pp != nil {
            acquirep(pp)
            return true
        }
    }
    
    return false
}
```

---

## ç¬¬äº”éƒ¨åˆ†: æœ€æ–°ä¼˜åŒ– (Go 1.25.3)

### 5.1 å¢å¼ºçš„è°ƒåº¦å™¨è¿½è¸ª

Go 1.25.3 æä¾›äº†æ›´è¯¦ç»†çš„è°ƒåº¦å™¨è¿½è¸ªåŠŸèƒ½ã€‚

```go
// å¢å¼ºçš„è¿½è¸ª API

// runtime/trace åŒ…å¢å¼º
package trace

// StartTrace å¯åŠ¨è¿½è¸ªï¼ŒåŒ…å«è°ƒåº¦å™¨äº‹ä»¶
func StartTrace() error {
    return start()
}

// StopTrace åœæ­¢è¿½è¸ª
func StopTrace() {
    stop()
}

// æ–°çš„è¿½è¸ªäº‹ä»¶
const (
    EvGoCreate          = 1  // G åˆ›å»º
    EvGoStart           = 2  // G å¼€å§‹æ‰§è¡Œ
    EvGoEnd             = 3  // G ç»“æŸ
    EvGoBlock           = 4  // G é˜»å¡
    EvGoUnblock         = 5  // G è§£é™¤é˜»å¡
    EvGoSysCall         = 6  // ç³»ç»Ÿè°ƒç”¨
    EvGoSysExit         = 7  // ç³»ç»Ÿè°ƒç”¨è¿”å›
    EvGCStart           = 8  // GC å¼€å§‹
    EvGCDone            = 9  // GC å®Œæˆ
    EvProcStart         = 10 // P å¼€å§‹
    EvProcStop          = 11 // P åœæ­¢
    EvGoPreempt         = 12 // G è¢«æŠ¢å  (æ–°å¢)
    EvGoSteal           = 13 // G è¢«å·å– (æ–°å¢)
    EvGoWaiting         = 14 // G ç­‰å¾…åŸå› è¯¦æƒ… (æ–°å¢)
)

// ä½¿ç”¨ç¤ºä¾‹
func TraceExample() {
    f, _ := os.Create("trace.out")
    defer f.Close()
    
    trace.Start(f)
    defer trace.Stop()
    
    // è¿è¡Œä½ çš„ç¨‹åº
    runWorkload()
}
```

### 5.2 æ”¹è¿›çš„æŠ¢å æœºåˆ¶

```go
// Go 1.25.3 æŠ¢å æ”¹è¿›

// æ›´ç²¾ç¡®çš„æŠ¢å æ—¶æœº
func sysmon() {
    for {
        usleep(delay)
        now := nanotime()
        
        // æ£€æŸ¥æ‰€æœ‰ P
        for _, _p_ := range allp {
            if _p_.status != _Prunning {
                continue
            }
            
            _g_ := _p_.m.curg
            if _g_ == nil {
                continue
            }
            
            // è®¡ç®—æ‰§è¡Œæ—¶é—´
            runtime := now - _g_.startTime
            
            // Go 1.25.3: åŠ¨æ€è°ƒæ•´æŠ¢å é˜ˆå€¼
            threshold := preemptThreshold(_g_)
            
            if runtime > threshold {
                // è¯·æ±‚æŠ¢å 
                preemptone(_p_)
            }
        }
    }
}

// åŠ¨æ€æŠ¢å é˜ˆå€¼ (æ–°å¢)
func preemptThreshold(gp *g) int64 {
    // æ ¹æ® G çš„ä¼˜å…ˆçº§å’Œç³»ç»Ÿè´Ÿè½½åŠ¨æ€è°ƒæ•´
    basethreshold := 10 * time.Millisecond
    
    // CPU å¯†é›†å‹ G: æ›´çŸ­çš„é˜ˆå€¼
    if gp.isCPUIntensive() {
        return int64(basethreshold / 2)
    }
    
    // I/O å¯†é›†å‹ G: æ›´é•¿çš„é˜ˆå€¼
    if gp.isIOIntensive() {
        return int64(basethreshold * 2)
    }
    
    return int64(basethreshold)
}

// G ç‰¹å¾åˆ†æ (æ–°å¢)
func (gp *g) isCPUIntensive() bool {
    // æ ¹æ®å†å²æ‰§è¡Œæ—¶é—´åˆ¤æ–­
    return gp.avgExecutionTime > 5*time.Millisecond
}

func (gp *g) isIOIntensive() bool {
    // æ ¹æ®ç­‰å¾…æ—¶é—´å æ¯”åˆ¤æ–­
    return gp.avgWaitTime > gp.avgExecutionTime
}
```

### 5.3 æ›´å¥½çš„è´Ÿè½½å‡è¡¡

```go
// Go 1.25.3: æ”¹è¿›çš„ Work-Stealing

// æ™ºèƒ½å·å–ç­–ç•¥
func runqsteal(_p_, p2 *p) *g {
    n := len(p2.runq)
    if n == 0 {
        return nil
    }
    
    // Go 1.25.3: æ ¹æ®é˜Ÿåˆ—é•¿åº¦åŠ¨æ€å†³å®šå·å–æ•°é‡
    stealCount := calcStealCount(_p_, p2, n)
    
    // å·å–
    var stolen []*g
    for i := 0; i < stealCount; i++ {
        gp := runqget(p2)
        if gp == nil {
            break
        }
        stolen = append(stolen, gp)
    }
    
    // å°†å·å–çš„ G åˆ†é…åˆ°æœ¬åœ°é˜Ÿåˆ—
    for i := 1; i < len(stolen); i++ {
        runqput(_p_, stolen[i], false)
    }
    
    if len(stolen) > 0 {
        return stolen[0]
    }
    return nil
}

// è®¡ç®—å·å–æ•°é‡ (æ–°å¢)
func calcStealCount(_p_, p2 *p, n int) int {
    // ç›®æ ‡: å¹³è¡¡ä¸¤ä¸ª P çš„é˜Ÿåˆ—é•¿åº¦
    myLen := len(_p_.runq)
    
    if n <= 1 {
        return 1  // è‡³å°‘å·å–1ä¸ª
    }
    
    // è®¡ç®—å¹³è¡¡ç‚¹
    avg := (myLen + n) / 2
    stealCount := n - avg
    
    // é™åˆ¶: ä¸è¶…è¿‡é˜Ÿåˆ—çš„ä¸€åŠ
    maxSteal := n / 2
    if stealCount > maxSteal {
        stealCount = maxSteal
    }
    
    // æœ€å°‘å·å–1ä¸ª
    if stealCount < 1 {
        stealCount = 1
    }
    
    return stealCount
}

// å·å–é¡ºåºä¼˜åŒ– (æ–°å¢)
type stealOrder struct {
    count    int
    coprimes []uint32
    p        uint32
    offset   uint32
}

// ç”Ÿæˆéšæœºä½†å…¨è¦†ç›–çš„å·å–é¡ºåº
func (ord *stealOrder) start() *stealOrderIterator {
    return &stealOrderIterator{
        ord:      ord,
        offset:   fastrand() % ord.count,
        position: 0,
    }
}

type stealOrderIterator struct {
    ord      *stealOrder
    offset   uint32
    position uint32
}

func (it *stealOrderIterator) position() int {
    // ä½¿ç”¨äº’è´¨æ•°ç”Ÿæˆéšæœºä½†å…¨è¦†ç›–çš„è®¿é—®æ¨¡å¼
    return int((it.offset + it.position*it.ord.coprimes[it.ord.p]) % it.ord.count)
}

func (it *stealOrderIterator) next() {
    it.position++
}

func (it *stealOrderIterator) done() bool {
    return it.position >= it.ord.count
}
```

---

## ğŸ¯ æ€»ç»“

### æ ¸å¿ƒå†…å®¹

1. **GMP è°ƒåº¦æ¨¡å‹**
   - G (Goroutine): ç”¨æˆ·æ€çº¿ç¨‹
   - M (Machine): OS çº¿ç¨‹
   - P (Processor): é€»è¾‘å¤„ç†å™¨

2. **è°ƒåº¦ç®—æ³•**
   - Work-Stealing: è´Ÿè½½å‡è¡¡
   - åä½œå¼æŠ¢å : å‡½æ•°è°ƒç”¨å’Œå¾ªç¯
   - å¼‚æ­¥æŠ¢å : åŸºäºä¿¡å· (Go 1.14+)
   - å…¬å¹³æ€§ä¿è¯: é˜²æ­¢é¥¥é¥¿

3. **å†…å­˜æ¨¡å‹**
   - Happens-Before å…³ç³»
   - Channel åŒæ­¥è¯­ä¹‰
   - sync åŒ…åŸè¯­
   - å†…å­˜å±éšœ

4. **æ€§èƒ½ä¼˜åŒ–**
   - æœ¬åœ°è¿è¡Œé˜Ÿåˆ— (256å®¹é‡)
   - å…¨å±€è¿è¡Œé˜Ÿåˆ—
   - ç½‘ç»œè½®è¯¢å™¨é›†æˆ
   - ç³»ç»Ÿè°ƒç”¨ä¼˜åŒ–

5. **Go 1.25.3 æ–°ç‰¹æ€§**
   - å¢å¼ºçš„è¿½è¸ª
   - æ”¹è¿›çš„æŠ¢å 
   - æ™ºèƒ½è´Ÿè½½å‡è¡¡

### ç†è®ºä»·å€¼

- æä¾›äº† Go è°ƒåº¦å™¨çš„å®Œæ•´å½¢å¼åŒ–æ¨¡å‹
- å»ºç«‹äº†ä¸ CSP ç†è®ºçš„ä¸¥æ ¼å¯¹åº”å…³ç³»
- è¯æ˜äº†è°ƒåº¦ç®—æ³•çš„æ­£ç¡®æ€§å’Œå…¬å¹³æ€§

### å·¥ç¨‹ä»·å€¼

- ç†è§£è°ƒåº¦å™¨è¡Œä¸ºï¼Œç¼–å†™é«˜æ€§èƒ½å¹¶å‘ä»£ç 
- è¯Šæ–­å¹¶å‘é—®é¢˜ (æ­»é”ã€æ´»é”ã€ç«äº‰)
- ä¼˜åŒ– GOMAXPROCS å’Œå·¥ä½œè´Ÿè½½åˆ†é…

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**é€‚ç”¨Goç‰ˆæœ¬**: 1.25.3  
**æœ€åæ›´æ–°**: 2025-10-23  
**ç»´æŠ¤å›¢é˜Ÿ**: Go Runtime Team
