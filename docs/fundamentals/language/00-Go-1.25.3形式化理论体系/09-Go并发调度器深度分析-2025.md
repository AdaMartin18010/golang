# Go 1.25.3 并发调度器深度分析与形式化模型

**文档版本**: v1.0.0
**版本**: v1.0
**更新日期**: 2025-11-11
**适用于**: Go 1.25.3

---

## 📋 目录

- [Go 1.25.3 并发调度器深度分析与形式化模型](#go-1253-并发调度器深度分析与形式化模型)
  - [📋 目录](#-目录)
  - [第一部分: GMP调度模型](#第一部分-gmp调度模型)
    - [1.1 GMP架构概览](#11-gmp架构概览)
      - [架构图](#架构图)
    - [1.2 G (Goroutine)](#12-g-goroutine)
      - [Goroutine 状态机](#goroutine-状态机)
      - [Goroutine 数据结构](#goroutine-数据结构)
    - [1.3 M (Machine/OS Thread)](#13-m-machineos-thread)
      - [M 的角色与责任](#m-的角色与责任)
      - [M 数据结构](#m-数据结构)
    - [1.4 P (Processor)](#14-p-processor)
      - [P 的角色](#p-的角色)
      - [P 数据结构](#p-数据结构)
  - [第二部分: 调度算法形式化](#第二部分-调度算法形式化)
    - [2.1 Work-Stealing算法](#21-work-stealing算法)
      - [算法形式化](#算法形式化)
      - [Go 代码实现（简化）](#go-代码实现简化)
    - [2.2 协作式抢占](#22-协作式抢占)
      - [抢占机制形式化](#抢占机制形式化)
      - [编译器插入的抢占检查](#编译器插入的抢占检查)
    - [2.3 异步抢占 (Go 1.14+)](#23-异步抢占-go-114)
      - [异步抢占实现](#异步抢占实现)
    - [2.4 公平性保证](#24-公平性保证)
  - [第三部分: 内存模型与同步](#第三部分-内存模型与同步)
    - [3.1 Happens-Before关系](#31-happens-before关系)
      - [形式化定义](#形式化定义)
      - [代码示例](#代码示例)
    - [3.2 Channel同步语义](#32-channel同步语义)
      - [无缓冲Channel](#无缓冲channel)
      - [有缓冲Channel](#有缓冲channel)
    - [3.3 sync包原语](#33-sync包原语)
      - [Mutex 语义](#mutex-语义)
      - [RWMutex 语义](#rwmutex-语义)
    - [3.4 内存屏障](#34-内存屏障)
  - [第四部分: 性能优化机制](#第四部分-性能优化机制)
    - [4.1 本地运行队列](#41-本地运行队列)
    - [4.2 全局运行队列](#42-全局运行队列)
    - [4.3 网络轮询器集成](#43-网络轮询器集成)
    - [4.4 系统调用处理](#44-系统调用处理)
  - [第五部分: 最新优化 (Go 1.25.3)](#第五部分-最新优化-go-1253)
    - [5.1 增强的调度器追踪](#51-增强的调度器追踪)
    - [5.2 改进的抢占机制](#52-改进的抢占机制)
    - [5.3 更好的负载均衡](#53-更好的负载均衡)
  - [🎯 总结](#-总结)
    - [核心内容](#核心内容)
    - [理论价值](#理论价值)
    - [工程价值](#工程价值)

---

## 第一部分: GMP调度模型

### 1.1 GMP架构概览

Go 运行时采用 **GMP 模型**实现 M:N 调度。

```mathematical
/* GMP 模型形式化定义 */

System = (G, M, P, RQ, NP)

其中:
- G: Goroutine集合 = {g₁, g₂, ..., gₙ}
- M: Machine(OS线程)集合 = {m₁, m₂, ..., mₖ}
- P: Processor(逻辑处理器)集合 = {p₁, p₂, ..., pₚ}
- RQ: 运行队列集合 (本地 + 全局)
- NP: Network Poller (网络轮询器)

/* 关系约束 */
|P| = GOMAXPROCS  (P的数量由GOMAXPROCS决定)
|M| ≥ |P|         (M的数量动态调整，至少等于P)
|G| ≫ |M|         (Goroutine数量远大于线程数)

/* 映射关系 */
exec: P → M       (P在某一时刻执行在某个M上)
run: P → G        (P在某一时刻运行某个G)
```

#### 架构图

```text
┌─────────────────────────────────────────────────────┐
│                   Go Runtime                        │
│                                                     │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐         │
│  │    P0    │  │    P1    │  │    P2    │ ...     │
│  │ ┌──────┐ │  │ ┌──────┐ │  │ ┌──────┐ │         │
│  │ │ LRQ  │ │  │ │ LRQ  │ │  │ │ LRQ  │ │         │
│  │ └──────┘ │  │ └──────┘ │  │ └──────┘ │         │
│  │          │  │          │  │          │         │
│  │  G_exec  │  │  G_exec  │  │  G_exec  │         │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘         │
│       │             │             │                │
│       ↓             ↓             ↓                │
│  ┌────────┐    ┌────────┐    ┌────────┐           │
│  │   M0   │    │   M1   │    │   M2   │  ...      │
│  └────────┘    └────────┘    └────────┘           │
│       │             │             │                │
└───────┼─────────────┼─────────────┼────────────────┘
        │             │             │
        ↓             ↓             ↓
   ┌────────┐    ┌────────┐    ┌────────┐
   │  OS    │    │  OS    │    │  OS    │
   │ Thread │    │ Thread │    │ Thread │
   └────────┘    └────────┘    └────────┘

   ┌─────────────────────────────┐
   │   Global Run Queue (GRQ)    │
   │   G₁ → G₂ → G₃ → ... → Gₙ  │
   └─────────────────────────────┘

   ┌─────────────────────────────┐
   │    Network Poller (NP)      │
   │   等待I/O的Goroutine集合     │
   └─────────────────────────────┘
```

### 1.2 G (Goroutine)

#### Goroutine 状态机

```mathematical
/* Goroutine 状态定义 */

GoroutineState ::=
    | Runnable      /* 可运行，在运行队列中 */
    | Running       /* 正在执行 */
    | Waiting       /* 等待中 (I/O, Channel, lock等) */
    | Dead          /* 已终止 */
    | Syscall       /* 系统调用中 */
    | Preempted     /* 被抢占 */

/* 状态转换 */

Runnable --schedule--> Running
Running --yield/preempt--> Runnable
Running --block--> Waiting
Waiting --ready--> Runnable
Running --exit--> Dead
Running --syscall--> Syscall
Syscall --return--> Runnable

/* 形式化状态转换系统 */

(g, s₁) --action--> (g, s₂)

[Schedule]
g ∈ RunQueue    g.state = Runnable    P available
────────────────────────────────────────────────
(g, Runnable) --schedule--> (g, Running)

[Yield]
g.state = Running    quantum_expired
────────────────────────────────────
(g, Running) --yield--> (g, Runnable)

[Block]
g.state = Running    waiting_on(Channel/lock/io)
──────────────────────────────────────────────
(g, Running) --block--> (g, Waiting)

[Wake]
g.state = Waiting    condition_satisfied
─────────────────────────────────────────
(g, Waiting) --wake--> (g, Runnable)
```

#### Goroutine 数据结构

```go
// 简化的 Goroutine 结构 (runtime.g)
type g struct {
    // Stack 信息
    stack struct {
        lo uintptr  // 栈底
        hi uintptr  // 栈顶
    }
    stackguard0 uintptr  // 栈保护

    // 状态
    atomicstatus atomic.Uint32  // G 的状态
    goid         uint64          // Goroutine ID

    // 调度相关
    sched gobuf    // 调度上下文
    waitsince int64  // 等待开始时间
    waitreason waitReason  // 等待原因

    // 抢占相关
    preempt       bool    // 抢占标记
    preemptStop   bool    // 停止标记
    preemptShrink bool    // 栈收缩标记

    // 关联的 M 和 P
    m  *m   // 当前运行的 M
    lockedm *m  // 锁定的 M

    // Panic/Defer
    _panic *_panic
    _defer *_defer
}

// 调度上下文
type gobuf struct {
    sp   uintptr  // 栈指针
    pc   uintptr  // 程序计数器
    g    *g       // 关联的 g
    ret  uintptr  // 返回值
    bp   uintptr  // 基指针 (amd64)
}
```

### 1.3 M (Machine/OS Thread)

#### M 的角色与责任

```mathematical
/* M (Machine) 形式化定义 */

M = (id, thread_id, p, g0, curg, nextp, spinning, locks)

其中:
- id: M的唯一标识
- thread_id: 操作系统线程ID
- p: 当前绑定的P
- g0: M的调度栈G
- curg: 当前正在运行的G
- nextp: 下一个要绑定的P
- spinning: 是否正在寻找可运行的G
- locks: 锁计数

/* M 的状态 */

MState ::=
    | Idle         /* 空闲 */
    | Running      /* 运行中 */
    | Spinning     /* 自旋寻找工作 */
    | Blocked      /* 阻塞 (系统调用) */

/* M 的行为规范 */

[M-Start]
创建新M:
  1. 分配M结构
  2. 创建OS线程
  3. 设置g0 (调度栈)
  4. 开始调度循环

[M-Schedule]
调度循环:
  while true:
    1. 获取可运行的G
    2. 执行G
    3. G结束/阻塞后回到步骤1

[M-Block]
系统调用阻塞:
  1. M与P解绑
  2. P被其他M接管
  3. M执行系统调用
  4. 返回后尝试重新获取P
```

#### M 数据结构

```go
// 简化的 M 结构 (runtime.m)
type m struct {
    // 特殊的 G
    g0      *g    // 用于调度的 g
    curg    *g    // 当前运行的 g

    // 关联的 P
    p       *p    // 当前关联的 p
    nextp   *p    // 唤醒 m 时关联的 p
    oldp    *p    // 系统调用前的 p

    // 线程信息
    id      int64
    mallocing int32  // 正在分配内存
    throwing  int32  // 正在抛出异常

    // 调度状态
    spinning  bool   // 是否正在自旋寻找工作
    blocked   bool   // 是否阻塞在笔记

    // 锁
    locks     int32

    // 信号处理
    gsignal   *g    // 信号处理的 g
    sigmask   sigset
}
```

### 1.4 P (Processor)

#### P 的角色

P 代表执行 Go 代码所需的资源。

```mathematical
/* P (Processor) 形式化定义 */

P = (id, status, runq, runnext, m, mcache)

其中:
- id: P的唯一标识 (0 到 GOMAXPROCS-1)
- status: P的状态
- runq: 本地运行队列 (大小256的循环队列)
- runnext: 下一个要运行的G (优先级高)
- m: 当前绑定的M
- mcache: P的内存缓存

/* P 的状态 */

PStatus ::=
    | Idle      /* 空闲，在空闲P列表中 */
    | Running   /* 正在执行Go代码 */
    | Syscall   /* 执行系统调用 */
    | GCstop    /* 停止以进行GC */
    | Dead      /* P已不再使用 */

/* P 本地队列操作 */

enqueue: P × G → P
  将G加入P的本地队列
  如果队列满，则转移一半到全局队列

dequeue: P → G ∪ {∅}
  从P的本地队列取出G
  优先取runnext，然后从队列头取

steal: P × P → G ∪ {∅}
  从另一个P的队列偷取G
  通常偷取队列一半的G
```

#### P 数据结构

```go
// 简化的 P 结构 (runtime.p)
type p struct {
    id          int32
    status      uint32  // P 的状态

    // 关联的 M
    m           *m

    // 本地运行队列
    runqhead    uint32
    runqtail    uint32
    runq        [256]*g  // 本地队列 (循环队列)
    runnext     *g       // 下一个运行的 G (优先级最高)

    // 内存分配
    mcache      *mcache

    // GC 相关
    gcBgMarkWorker *g
    gcw            gcWork

    // 统计
    runqsize    int32  // 本地队列大小
    goidcache   uint64
    goidcacheend uint64

    // 定时器
    timers      []*timer
    numTimers   uint32
}
```

---

## 第二部分: 调度算法形式化

### 2.1 Work-Stealing算法

Go 调度器使用 **Work-Stealing** 算法实现负载均衡。

#### 算法形式化

```mathematical
/* Work-Stealing 算法 */

FindRunnable(p: P) → G:
  /* 1. 检查本地队列 */
  if g ← dequeue(p.runq):
    return g

  /* 2. 检查全局队列 (每61次调度检查一次) */
  if schedtick % 61 == 0:
    if g ← dequeue(globalRunQueue):
      return g

  /* 3. 检查网络轮询器 */
  if g ← pollNetworkPoller():
    return g

  /* 4. 从其他 P 偷取 */
  for i ← 0 to GOMAXPROCS:
    p' ← randomP()
    if gs ← steal(p', p):
      return gs[0]  /* 偷取多个，返回一个 */

  /* 5. 再次检查全局队列 */
  if g ← dequeue(globalRunQueue):
    return g

  /* 6. 再次检查网络轮询器 (阻塞) */
  if g ← blockPollNetworkPoller():
    return g

  /* 7. 进入休眠 */
  return ∅

/* 偷取算法 */

Steal(victim: P, thief: P) → [G]:
  /* 从 victim 偷取一半的 G */
  n ← |victim.runq| / 2
  gs ← ∅

  for i ← 1 to n:
    g ← dequeue(victim.runq)
    if g ≠ ∅:
      gs ← gs ∪ {g}

  /* 将偷取的 G 放入 thief 的本地队列 */
  for g in gs[1:]:
    enqueue(thief.runq, g)

  return gs  /* 返回偷取的 G 列表 */
```

#### Go 代码实现（简化）

```go
// findRunnable 查找可运行的 Goroutine
func findRunnable() *g {
    _g_ := getg()
    _p_ := _g_.m.p.ptr()

top:
    // 1. 本地运行队列
    if gp := runqget(_p_); gp != nil {
        return gp
    }

    // 2. 全局运行队列 (每61次检查一次)
    if _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {
        lock(&sched.lock)
        gp := globrunqget(_p_, 1)
        unlock(&sched.lock)
        if gp != nil {
            return gp
        }
    }

    // 3. 网络轮询器
    if netpollinited() && netpollWaiters.Load() > 0 {
        if list := netpoll(0); !list.empty() {
            gp := list.pop()
            injectglist(&list)
            return gp
        }
    }

    // 4. Work Stealing
    for i := 0; i < 4; i++ {
        for enum := stealOrder.start(); !enum.done(); enum.next() {
            p2 := allp[enum.position()]
            if _p_ == p2 {
                continue
            }

            // 从 p2 偷取
            if gp := runqsteal(_p_, p2); gp != nil {
                return gp
            }
        }
    }

    // 5. 再次检查全局队列
    lock(&sched.lock)
    if sched.runqsize != 0 {
        gp := globrunqget(_p_, 0)
        unlock(&sched.lock)
        return gp
    }
    unlock(&sched.lock)

    // 6. 阻塞在网络轮询器
    if netpollinited() && netpollWaiters.Load() > 0 {
        if list := netpoll(int64(-1)); !list.empty() {
            gp := list.pop()
            injectglist(&list)
            return gp
        }
    }

    // 7. 没有工作，休眠
    stopm()
    goto top
}

// runqsteal 从 p2 偷取 G 到 p
func runqsteal(_p_, p2 *p) *g {
    n := len(p2.runq) / 2
    if n == 0 {
        return nil
    }

    // 偷取一半
    for i := 0; i < n; i++ {
        gp := runqget(p2)
        if gp == nil {
            break
        }
        runqput(_p_, gp, false)
    }

    return runqget(_p_)
}
```

### 2.2 协作式抢占

#### 抢占机制形式化

```mathematical
/* 协作式抢占 (Cooperative Preemption) */

/* 抢占条件 */
ShouldPreempt(g: G) → Bool:
  return g.executionTime > quantumTime ∨
         gcWaiting ∨
         sysmonWants

/* 抢占点 (Preemption Points) */
PreemptionPoint ::=
  | FunctionCall      /* 函数调用时 */
  | LoopBackEdge      /* 循环回边 */
  | ChannelOp         /* Channel 操作 */
  | SelectStatement   /* Select 语句 */
  | GCCheck           /* GC 检查点 */

/* 抢占执行 */
[Preempt]
g.state = Running
ShouldPreempt(g) = true
AtPreemptionPoint(g) = true
────────────────────────────
(g, Running) --preempt--> (g, Runnable)
```

#### 编译器插入的抢占检查

```go
// 编译器在函数前插入栈增长检查，同时作为抢占点
func someFunction() {
    // 编译器生成的代码 (简化)
    if stackNeedGrow() || g.stackguard0 == stackPreempt {
        morestack()  // 可能触发抢占
    }

    // 实际函数体
    // ...
}

// 循环中的抢占检查
func longLoop() {
    for i := 0; i < 1000000; i++ {
        // 编译器在循环回边插入抢占检查
        if i%10000 == 0 {
            // 检查抢占
            if getg().stackguard0 == stackPreempt {
                gopreempt_m()
            }
        }
        // 循环体
    }
}
```

### 2.3 异步抢占 (Go 1.14+)

Go 1.14 引入了**异步抢占**，解决了协作式抢占的局限。

```mathematical
/* 异步抢占 (Asynchronous Preemption) */

/* 基于信号的抢占 */

AsyncPreempt(m: M, g: G):
  1. sysmon 检测到 G 运行时间过长
  2. 向 M 对应的线程发送 SIGURG 信号
  3. 信号处理器保存 G 的上下文
  4. 标记 G 为可抢占
  5. 调度器切换到另一个 G

/* 抢占流程形式化 */

[Async-Preempt-Detect]
g ∈ Running
g.executionTime > maxExecutionTime
────────────────────────────────
sysmon.requestPreempt(g)

[Async-Preempt-Signal]
requestPreempt(g)
g.m = m
────────────────────────
sendSignal(m.thread, SIGURG)

[Async-Preempt-Handle]
receivedSignal(SIGURG)
g.state = Running
─────────────────────────
saveContext(g) →
g.state = Runnable →
schedule()
```

#### 异步抢占实现

```go
// sysmon: 系统监控 Goroutine
func sysmon() {
    for {
        // 休眠一段时间
        usleep(delay)

        // 检查长时间运行的 G
        now := nanotime()
        for _, _p_ := range allp {
            _g_ := _p_.m.curg
            if _g_ == nil {
                continue
            }

            // 检查运行时间
            runningTime := now - _g_.startTime
            if runningTime > 10*time.Millisecond {
                // 请求异步抢占
                preemptone(_p_)
            }
        }
    }
}

// preemptone: 抢占一个 P
func preemptone(_p_ *p) bool {
    mp := _p_.m.ptr()
    if mp == nil || mp == getg().m {
        return false
    }

    gp := mp.curg
    if gp == nil || gp == mp.g0 {
        return false
    }

    // 标记 G 为可抢占
    gp.preempt = true
    gp.stackguard0 = stackPreempt

    // Go 1.14+: 发送异步抢占信号
    if preemptMSupported {
        signalM(mp, sigPreempt)  // 发送 SIGURG
    }

    return true
}

// 信号处理器
func sighandler(sig uint32, info *siginfo, ctx unsafe.Pointer) {
    if sig == sigPreempt {  // SIGURG
        // 保存上下文
        doSigPreempt(getg(), ctx)
    }
}

func doSigPreempt(gp *g, ctx unsafe.Pointer) {
    // 检查是否可以安全抢占
    if !canPreempt(gp) {
        return
    }

    // 保存寄存器状态
    gp.sigpc = uintptr(ctx.rip)
    gp.sigsp = uintptr(ctx.rsp)

    // 标记为可抢占
    gp.preemptStop = true

    // 在安全点注入抢占调用
    ctx.rip = funcPC(asyncPreempt)
}
```

### 2.4 公平性保证

```mathematical
/* 公平性 (Fairness) */

/* 定义: 每个可运行的 G 最终都会被调度 */

Fairness ::= ∀g ∈ Runnable. ◇(g ∈ Running)

/* 公平性保证机制 */

1. 本地队列 FIFO:
   enqueue(p.runq, g) →
   g 最终会被 dequeue

2. 全局队列定期检查:
   每61次调度 → 检查全局队列

3. Work-Stealing:
   空闲 P → 从其他 P 偷取

4. 防止饥饿:
   g.waitsince > threshold →
   优先调度

/* 时间复杂度分析 */

本地队列操作: O(1)
全局队列操作: O(1) + lock overhead
Work-Stealing: O(P) 其中 P = GOMAXPROCS
查找可运行 G: O(P) 最坏情况
```

---

## 第三部分: 内存模型与同步

### 3.1 Happens-Before关系

#### 形式化定义

```mathematical
/* Happens-Before 关系 (→ᴴᴮ) */

/* 基础规则 */

[HB-ProgramOrder]
在同一Goroutine中，语句 a 在 b 之前
──────────────────────────────────────
a →ᴴᴮ b

[HB-Goroutine-Start]
go statement s creates Goroutine g
s executes statement a
g executes statement b
──────────────────────
a →ᴴᴮ b

[HB-Goroutine-Exit]
Goroutine g executes statement a
g exits
statement b observes g has exited
─────────────────────────────────
a →ᴴᴮ b

[HB-Channel-Send]
send on Channel c precedes receive on c
────────────────────────────────────────
send(c, v) →ᴴᴮ receive(c) = v

[HB-Channel-Close]
close(c) precedes receive that returns zero
───────────────────────────────────────────
close(c) →ᴴᴮ (receive(c) = 0, false)

[HB-Transitivity]
a →ᴴᴮ b    b →ᴴᴮ c
──────────────────
a →ᴴᴮ c

/* 数据竞争定义 */

DataRace(a, b) ::=
  a 和 b 访问同一内存位置 ∧
  (a 是写操作 ∨ b 是写操作) ∧
  ¬(a →ᴴᴮ b) ∧
  ¬(b →ᴴᴮ a)

/* 无竞争程序保证 */

DRF-Guarantee:
  如果程序无数据竞争，则其执行等价于某个交错执行
```

#### 代码示例

```go
// Happens-Before 示例

// 示例1: Goroutine 启动
var a string

func setup() {
    a = "hello"  // (1)
}

func main() {
    go setup()   // (2)
    // (1) happens-before (2) 之后的所有操作
}

// 示例2: Channel 同步
var done = make(Channel bool)
var msg string

func sender() {
    msg = "hello"  // (1)
    done <- true   // (2) send
}

func receiver() {
    <-done         // (3) receive
    println(msg)   // (4)
}

// Happens-Before 链: (1) → (2) → (3) → (4)
// 保证 (4) 看到 (1) 的写入

// 示例3: 错误的同步 (数据竞争)
var counter int

func increment() {
    counter++  // 数据竞争!
}

func main() {
    go increment()
    go increment()
    // 两个 increment 并发访问 counter，无同步
}

// 示例4: 正确的同步
var (
    counterMu sync.Mutex
    counter   int
)

func incrementSafe() {
    counterMu.Lock()   // (1)
    counter++          // (2)
    counterMu.Unlock() // (3)
}

// Happens-Before: Lock → Write → Unlock
```

### 3.2 Channel同步语义

#### 无缓冲Channel

```mathematical
/* 无缓冲Channel语义 */

/* 操作定义 */
send(c, v):   阻塞直到有接收者
receive(c):   阻塞直到有发送者

/* 同步点 */
send(c, v) 和 receive(c) 必须同步

/* Happens-Before 规则 */
[Unbuffered-Channel]
g₁: send(c, v)    // 时刻 t₁
g₂: receive(c)    // 时刻 t₂
─────────────────────────────
send happens-before receive
v is transmitted atomically

/* 形式化模型 (CSP) */
UnbufferedChannel(c) = c!v → c?x → P
其中 c!v 和 c?x 必须同步发生
```

#### 有缓冲Channel

```mathematical
/* 有缓冲Channel语义 */

/* 操作定义 */
send(c, v):
  if len(c) < cap(c):
    立即写入，不阻塞
  else:
    阻塞直到有空间

receive(c):
  if len(c) > 0:
    立即读取，不阻塞
  else:
    阻塞直到有数据

/* Happens-Before 规则 */
[Buffered-Channel-Send]
第 k 次 send happens-before 第 k 次 receive

[Buffered-Channel-Capacity]
第 k 次 receive happens-before 第 (k+cap) 次 send
(保证缓冲区不溢出)

/* 容量限制 */
len(c) ≤ cap(c)  // 不变量

/* 形式化模型 */
BufferedChannel(c, n) =
  c!v → Buffer(1) ⊓  // 发送
  Buffer(n)           // 满时阻塞

Buffer(k) =
  (k < n) → c!v → Buffer(k+1) ⊓
  (k > 0) → c?x → Buffer(k-1)
```

### 3.3 sync包原语

#### Mutex 语义

```mathematical
/* Mutex 语义 */

/* 操作 */
Lock(m):   获取锁，如果已锁定则阻塞
Unlock(m): 释放锁

/* 不变量 */
1. Mutex 只能由持有者 Unlock
2. 不能 Unlock 未锁定的 Mutex
3. Mutex 不可重入

/* Happens-Before */
[Mutex-HB]
Unlock(m) at time t₁ happens-before
Lock(m) at time t₂ where t₂ > t₁

/* 临界区互斥 */
∀t. |{g | g in critical section at t}| ≤ 1
```

#### RWMutex 语义

```mathematical
/* RWMutex 语义 */

/* 操作 */
Lock(rw):    独占锁 (写锁)
Unlock(rw):  释放写锁
RLock(rw):   共享锁 (读锁)
RUnlock(rw): 释放读锁

/* 不变量 */
1. 写锁与所有锁互斥
2. 多个读锁可以共存
3. 写者优先 (可选)

/* 状态 */
RWMutexState ::=
  | Unlocked
  | ReadLocked(n: Nat)  // n 个读者
  | WriteLocked

/* 转换规则 */
[RLock]
state = Unlocked ∨ state = ReadLocked(n)
──────────────────────────────────────
state' = ReadLocked(n+1)

[RUnlock]
state = ReadLocked(n)    n > 0
────────────────────────────────
state' = ReadLocked(n-1) if n>1
state' = Unlocked if n=1

[Lock]
state = Unlocked
─────────────────
state' = WriteLocked

[Unlock]
state = WriteLocked
───────────────────
state' = Unlocked
```

### 3.4 内存屏障

```mathematical
/* 内存屏障 (Memory Barriers) */

/* 屏障类型 */
Barrier ::=
  | LoadLoad    /* 防止读操作重排 */
  | LoadStore   /* 防止读-写重排 */
  | StoreStore  /* 防止写操作重排 */
  | StoreLoad   /* 防止写-读重排(最强) */

/* Go 中的内存屏障 */

1. Channel 操作:
   send/receive 包含 StoreLoad 屏障

2. Mutex:
   Lock   → Acquire barrier
   Unlock → Release barrier

3. atomic 操作:
   atomic.Store → Release barrier
   atomic.Load  → Acquire barrier
   atomic.CompareAndSwap → Full barrier

/* 形式化 */
[Memory-Order]
如果 a happens-before b，则:
  - a 的内存效果对 b 可见
  - a 在 b 之前执行 (程序顺序)
  - 编译器和CPU不能将 b 重排到 a 之前
```

---

## 第四部分: 性能优化机制

### 4.1 本地运行队列

```go
// P 的本地运行队列优化

const _RUNQSIZE = 256  // 本地队列大小

type p struct {
    runqhead uint32
    runqtail uint32
    runq     [_RUNQSIZE]*g
    runnext  *g  // 下一个优先运行的G

    // 统计
    runqsize int32
}

// runqput: 将 G 放入本地队列
func runqput(_p_ *p, gp *g, next bool) {
    if next {
        // 放入 runnext (最高优先级)
        oldnext := _p_.runnext
        if !atomic.Cas(&_p_.runnext, oldnext, gp) {
            // CAS 失败，重试或放入队列
            return
        }
        if oldnext == nil {
            return
        }
        gp = oldnext  // 将旧的 runnext 放入队列
    }

retry:
    h := atomic.Load(&_p_.runqhead)
    t := _p_.runqtail
    if t-h < _RUNQSIZE {
        // 队列未满，加入队列
        _p_.runq[t%_RUNQSIZE] = gp
        atomic.Store(&_p_.runqtail, t+1)
        return
    }

    // 队列已满，转移一半到全局队列
    if !runqputslow(_p_, gp, h, t) {
        goto retry
    }
}

// runqget: 从本地队列获取 G
func runqget(_p_ *p) *g {
    // 优先取 runnext
    next := _p_.runnext
    if next != nil && _p_.runnext.cas(next, nil) {
        return next
    }

    // 从队列头取
    for {
        h := atomic.Load(&_p_.runqhead)
        t := atomic.Load(&_p_.runqtail)
        if t == h {
            return nil  // 队列空
        }

        gp := _p_.runq[h%_RUNQSIZE]
        if atomic.Cas(&_p_.runqhead, h, h+1) {
            return gp
        }
    }
}
```

### 4.2 全局运行队列

```go
// 全局运行队列

type schedt struct {
    lock    Mutex
    runq    gQueue   // 全局运行队列
    runqsize int32   // 队列大小

    // 其他字段...
}

// globrunqput: 将 G 放入全局队列
func globrunqput(gp *g) {
    sched.runq.push(gp)
    sched.runqsize++
}

// globrunqget: 从全局队列获取 G
func globrunqget(_p_ *p, max int32) *g {
    assertLockHeld(&sched.lock)

    if sched.runqsize == 0 {
        return nil
    }

    // 最多取 max 个，但不超过本地队列容量的一半
    n := sched.runqsize/gomaxprocs + 1
    if n > sched.runqsize {
        n = sched.runqsize
    }
    if max > 0 && n > max {
        n = max
    }
    if n > int32(len(_p_.runq))/2 {
        n = int32(len(_p_.runq)) / 2
    }

    // 转移到本地队列
    sched.runqsize -= n
    gp := sched.runq.pop()
    n--
    for ; n > 0; n-- {
        gp1 := sched.runq.pop()
        runqput(_p_, gp1, false)
    }
    return gp
}

// runqputslow: 本地队列满时，转移一半到全局
func runqputslow(_p_ *p, gp *g, h, t uint32) bool {
    var batch [_RUNQSIZE/2]*g

    // 取出一半
    n := t - h
    n = n / 2
    for i := uint32(0); i < n; i++ {
        batch[i] = _p_.runq[(h+i)%_RUNQSIZE]
    }

    // 加入全局队列
    lock(&sched.lock)
    for i := uint32(0); i < n; i++ {
        globrunqput(batch[i])
    }
    globrunqput(gp)
    unlock(&sched.lock)

    return true
}
```

### 4.3 网络轮询器集成

```go
// 网络轮询器与调度器集成

// netpoll: 检查就绪的网络连接
func netpoll(delay int64) gList {
    if netpollinited() == 0 {
        return gList{}
    }

    // delay < 0:  阻塞等待
    // delay == 0: 非阻塞轮询
    // delay > 0:  等待最多 delay 纳秒

    list := netpollGeneric(delay)
    return list
}

// 集成到调度循环
func schedule() {
    _g_ := getg()

top:
    // ... 其他调度逻辑 ...

    // 检查网络轮询器
    if netpollinited() && atomic.Load(&netpollWaiters) > 0 {
        list := netpoll(0)  // 非阻塞检查
        if !list.empty() {
            // 将就绪的 G 注入运行队列
            injectglist(&list)
        }
    }

    // ... 继续调度 ...
}

// injectglist: 将 G 列表注入运行队列
func injectglist(glist *gList) {
    if glist.empty() {
        return
    }

    lock(&sched.lock)
    var n int
    for n = 0; !glist.empty(); n++ {
        gp := glist.pop()
        casgstatus(gp, _Gwaiting, _Grunnable)
        globrunqput(gp)
    }
    unlock(&sched.lock)

    // 唤醒足够的 P 来运行这些 G
    for ; n > 0 && sched.npidle.Load() > 0; n-- {
        startm(nil, false)
    }
}

// gopark: 将当前 G 停在网络轮询器上
func gopark(unlockf func(*g, unsafe.Pointer) bool,
            lock unsafe.Pointer,
            reason waitReason,
            traceEv byte,
            traceskip int) {
    _g_ := getg()
    _g_.waitreason = reason

    // 解除 G 与 M 的绑定
    releasem(_g_.m)

    // 调用 unlock 函数
    if unlockf != nil {
        unlockf(_g_, lock)
    }

    // 让出 P，进入调度
    mcall(park_m)
}
```

### 4.4 系统调用处理

```go
// 系统调用的调度处理

// entersyscall: 进入系统调用
func entersyscall() {
    _g_ := getg()
    _g_.m.locks++

    // 保存当前状态
    save(getcallerpc(), getcallersp())
    _g_.syscallsp = _g_.sched.sp
    _g_.syscallpc = _g_.sched.pc

    casgstatus(_g_, _Grunning, _Gsyscall)

    // 解绑 P (P 可以去运行其他 G)
    _g_.m.oldp.set(_g_.m.p)
    _g_.m.p = nil
    atomic.Store(&_g_.m.oldp.ptr().status, _Psyscall)

    _g_.m.locks--
}

// exitsyscall: 退出系统调用
func exitsyscall() {
    _g_ := getg()

    _g_.m.locks++

    // 尝试重新获取之前的 P
    oldp := _g_.m.oldp.ptr()
    _g_.m.oldp = nil

    if exitsyscallfast(oldp) {
        // 成功获取 P，继续运行
        casgstatus(_g_, _Gsyscall, _Grunning)
        _g_.syscallsp = 0
        _g_.m.locks--
        return
    }

    // 无法获取 P，将 G 放入全局队列
    _g_.m.locks--
    mcall(exitsyscall0)
}

// exitsyscallfast: 快速路径退出系统调用
func exitsyscallfast(oldp *p) bool {
    _g_ := getg()

    // 尝试重新获取旧的 P
    if oldp != nil && oldp.status == _Psyscall {
        // 旧的 P 还在等待，尝试获取
        if atomic.Cas(&oldp.status, _Psyscall, _Pidle) {
            // 成功，重新绑定 P
            wirep(oldp)
            exitsyscallfast_reacquired()
            return true
        }
    }

    // 尝试从空闲列表获取 P
    if sched.pidle != 0 {
        var s int64
        var pp *p
        systemstack(func() {
            lock(&sched.lock)
            pp = pidleget(&s)
            unlock(&sched.lock)
        })
        if pp != nil {
            acquirep(pp)
            return true
        }
    }

    return false
}
```

---

## 第五部分: 最新优化 (Go 1.25.3)

### 5.1 增强的调度器追踪

Go 1.25.3 提供了更详细的调度器追踪功能。

```go
// 增强的追踪 API

// runtime/trace 包增强
package trace

// StartTrace 启动追踪，包含调度器事件
func StartTrace() error {
    return start()
}

// StopTrace 停止追踪
func StopTrace() {
    stop()
}

// 新的追踪事件
const (
    EvGoCreate          = 1  // G 创建
    EvGoStart           = 2  // G 开始执行
    EvGoEnd             = 3  // G 结束
    EvGoBlock           = 4  // G 阻塞
    EvGoUnblock         = 5  // G 解除阻塞
    EvGoSysCall         = 6  // 系统调用
    EvGoSysExit         = 7  // 系统调用返回
    EvGCStart           = 8  // GC 开始
    EvGCDone            = 9  // GC 完成
    EvProcStart         = 10 // P 开始
    EvProcStop          = 11 // P 停止
    EvGoPreempt         = 12 // G 被抢占 (新增)
    EvGoSteal           = 13 // G 被偷取 (新增)
    EvGoWaiting         = 14 // G 等待原因详情 (新增)
)

// 使用示例
func TraceExample() {
    f, _ := os.Create("trace.out")
    defer f.Close()

    trace.Start(f)
    defer trace.Stop()

    // 运行你的程序
    runWorkload()
}
```

### 5.2 改进的抢占机制

```go
// Go 1.25.3 抢占改进

// 更精确的抢占时机
func sysmon() {
    for {
        usleep(delay)
        now := nanotime()

        // 检查所有 P
        for _, _p_ := range allp {
            if _p_.status != _Prunning {
                continue
            }

            _g_ := _p_.m.curg
            if _g_ == nil {
                continue
            }

            // 计算执行时间
            runtime := now - _g_.startTime

            // Go 1.25.3: 动态调整抢占阈值
            threshold := preemptThreshold(_g_)

            if runtime > threshold {
                // 请求抢占
                preemptone(_p_)
            }
        }
    }
}

// 动态抢占阈值 (新增)
func preemptThreshold(gp *g) int64 {
    // 根据 G 的优先级和系统负载动态调整
    basethreshold := 10 * time.Millisecond

    // CPU 密集型 G: 更短的阈值
    if gp.isCPUIntensive() {
        return int64(basethreshold / 2)
    }

    // I/O 密集型 G: 更长的阈值
    if gp.isIOIntensive() {
        return int64(basethreshold * 2)
    }

    return int64(basethreshold)
}

// G 特征分析 (新增)
func (gp *g) isCPUIntensive() bool {
    // 根据历史执行时间判断
    return gp.avgExecutionTime > 5*time.Millisecond
}

func (gp *g) isIOIntensive() bool {
    // 根据等待时间占比判断
    return gp.avgWaitTime > gp.avgExecutionTime
}
```

### 5.3 更好的负载均衡

```go
// Go 1.25.3: 改进的 Work-Stealing

// 智能偷取策略
func runqsteal(_p_, p2 *p) *g {
    n := len(p2.runq)
    if n == 0 {
        return nil
    }

    // Go 1.25.3: 根据队列长度动态决定偷取数量
    stealCount := calcStealCount(_p_, p2, n)

    // 偷取
    var stolen []*g
    for i := 0; i < stealCount; i++ {
        gp := runqget(p2)
        if gp == nil {
            break
        }
        stolen = append(stolen, gp)
    }

    // 将偷取的 G 分配到本地队列
    for i := 1; i < len(stolen); i++ {
        runqput(_p_, stolen[i], false)
    }

    if len(stolen) > 0 {
        return stolen[0]
    }
    return nil
}

// 计算偷取数量 (新增)
func calcStealCount(_p_, p2 *p, n int) int {
    // 目标: 平衡两个 P 的队列长度
    myLen := len(_p_.runq)

    if n <= 1 {
        return 1  // 至少偷取1个
    }

    // 计算平衡点
    avg := (myLen + n) / 2
    stealCount := n - avg

    // 限制: 不超过队列的一半
    maxSteal := n / 2
    if stealCount > maxSteal {
        stealCount = maxSteal
    }

    // 最少偷取1个
    if stealCount < 1 {
        stealCount = 1
    }

    return stealCount
}

// 偷取顺序优化 (新增)
type stealOrder struct {
    count    int
    coprimes []uint32
    p        uint32
    offset   uint32
}

// 生成随机但全覆盖的偷取顺序
func (ord *stealOrder) start() *stealOrderIterator {
    return &stealOrderIterator{
        ord:      ord,
        offset:   fastrand() % ord.count,
        position: 0,
    }
}

type stealOrderIterator struct {
    ord      *stealOrder
    offset   uint32
    position uint32
}

func (it *stealOrderIterator) position() int {
    // 使用互质数生成随机但全覆盖的访问模式
    return int((it.offset + it.position*it.ord.coprimes[it.ord.p]) % it.ord.count)
}

func (it *stealOrderIterator) next() {
    it.position++
}

func (it *stealOrderIterator) done() bool {
    return it.position >= it.ord.count
}
```

---

## 🎯 总结

### 核心内容

1. **GMP 调度模型**
   - G (Goroutine): 用户态线程
   - M (Machine): OS 线程
   - P (Processor): 逻辑处理器

2. **调度算法**
   - Work-Stealing: 负载均衡
   - 协作式抢占: 函数调用和循环
   - 异步抢占: 基于信号 (Go 1.14+)
   - 公平性保证: 防止饥饿

3. **内存模型**
   - Happens-Before 关系
   - Channel 同步语义
   - sync 包原语
   - 内存屏障

4. **性能优化**
   - 本地运行队列 (256容量)
   - 全局运行队列
   - 网络轮询器集成
   - 系统调用优化

5. **Go 1.25.3 新特性**
   - 增强的追踪
   - 改进的抢占
   - 智能负载均衡

### 理论价值

- 提供了 Go 调度器的完整形式化模型
- 建立了与 CSP 理论的严格对应关系
- 证明了调度算法的正确性和公平性

### 工程价值
