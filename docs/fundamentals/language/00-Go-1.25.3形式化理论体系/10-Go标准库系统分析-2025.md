# Go 1.25.3 æ ‡å‡†åº“ç³»ç»Ÿåˆ†æä¸å½¢å¼åŒ–è§„èŒƒ

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0
**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.25.3

---

## ğŸ“‹ ç›®å½•

- [Go 1.25.3 æ ‡å‡†åº“ç³»ç»Ÿåˆ†æä¸å½¢å¼åŒ–è§„èŒƒ](#go-1253-æ ‡å‡†åº“ç³»ç»Ÿåˆ†æä¸å½¢å¼åŒ–è§„èŒƒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ç¬¬ä¸€éƒ¨åˆ†: æ ¸å¿ƒåŒ…åˆ†æ](#ç¬¬ä¸€éƒ¨åˆ†-æ ¸å¿ƒåŒ…åˆ†æ)
    - [1.1 contextåŒ…](#11-contextåŒ…)
      - [å½¢å¼åŒ–å®šä¹‰](#å½¢å¼åŒ–å®šä¹‰)
      - [Context å®ç°åˆ†æ](#context-å®ç°åˆ†æ)
      - [Context ä½¿ç”¨æ¨¡å¼](#context-ä½¿ç”¨æ¨¡å¼)
    - [1.2 syncåŒ…](#12-syncåŒ…)
      - [Mutex å½¢å¼åŒ–](#mutex-å½¢å¼åŒ–)
      - [Mutex å®ç°åˆ†æ](#mutex-å®ç°åˆ†æ)
      - [RWMutex å®ç°](#rwmutex-å®ç°)
    - [1.3 ioåŒ…](#13-ioåŒ…)
      - [æ¥å£ä»£æ•°](#æ¥å£ä»£æ•°)
      - [æ ¸å¿ƒæ¥å£](#æ ¸å¿ƒæ¥å£)
    - [1.4 errorsåŒ…](#14-errorsåŒ…)
      - [é”™è¯¯ç³»ç»Ÿå½¢å¼åŒ–](#é”™è¯¯ç³»ç»Ÿå½¢å¼åŒ–)
      - [errors åŒ…å®ç°](#errors-åŒ…å®ç°)
  - [ç¬¬äºŒéƒ¨åˆ†: å¹¶å‘åŸè¯­åŒ…](#ç¬¬äºŒéƒ¨åˆ†-å¹¶å‘åŸè¯­åŒ…)
    - [2.1 sync/atomic](#21-syncatomic)
      - [åŸå­æ“ä½œå½¢å¼åŒ–](#åŸå­æ“ä½œå½¢å¼åŒ–)
      - [atomic åŒ…å®ç°](#atomic-åŒ…å®ç°)
    - [2.2 sync/singleflight](#22-syncsingleflight)
      - [å½¢å¼åŒ–å®šä¹‰1](#å½¢å¼åŒ–å®šä¹‰1)
      - [singleflight å®ç°](#singleflight-å®ç°)
    - [2.3 sync/errgroup](#23-syncerrgroup)
      - [å½¢å¼åŒ–å®šä¹‰2](#å½¢å¼åŒ–å®šä¹‰2)
      - [errgroup å®ç°](#errgroup-å®ç°)
  - [ç¬¬ä¸‰éƒ¨åˆ†: ç½‘ç»œä¸I/OåŒ…](#ç¬¬ä¸‰éƒ¨åˆ†-ç½‘ç»œä¸ioåŒ…)
    - [3.1 netåŒ…](#31-netåŒ…)
      - [ç½‘ç»œç¼–ç¨‹å½¢å¼åŒ–](#ç½‘ç»œç¼–ç¨‹å½¢å¼åŒ–)
      - [net åŒ…æ ¸å¿ƒæ¥å£](#net-åŒ…æ ¸å¿ƒæ¥å£)
    - [3.2 net/httpåŒ…](#32-nethttpåŒ…)
      - [HTTPè¯­ä¹‰å½¢å¼åŒ–](#httpè¯­ä¹‰å½¢å¼åŒ–)
      - [HTTPæœåŠ¡å™¨å®ç°](#httpæœåŠ¡å™¨å®ç°)
    - [3.3 io/fsåŒ…](#33-iofsåŒ…)
      - [æ–‡ä»¶ç³»ç»Ÿå½¢å¼åŒ–](#æ–‡ä»¶ç³»ç»Ÿå½¢å¼åŒ–)
      - [io/fs å®ç°](#iofs-å®ç°)
  - [ç¬¬å››éƒ¨åˆ†: ç¼–ç ä¸åºåˆ—åŒ–](#ç¬¬å››éƒ¨åˆ†-ç¼–ç ä¸åºåˆ—åŒ–)
    - [4.1 encoding/json](#41-encodingjson)
      - [JSONç¼–è§£ç å½¢å¼åŒ–](#jsonç¼–è§£ç å½¢å¼åŒ–)
      - [encoding/json å®ç°](#encodingjson-å®ç°)
    - [4.2 encoding/xml](#42-encodingxml)
    - [4.3 encoding/gob](#43-encodinggob)
  - [ç¬¬äº”éƒ¨åˆ†: ç®—æ³•ä¸æ•°æ®ç»“æ„](#ç¬¬äº”éƒ¨åˆ†-ç®—æ³•ä¸æ•°æ®ç»“æ„)
    - [5.1 containeråŒ…](#51-containeråŒ…)
    - [5.2 sortåŒ…](#52-sortåŒ…)
    - [5.3 slicesåŒ… (Go 1.21+)](#53-slicesåŒ…-go-121)
    - [5.4 mapsåŒ… (Go 1.21+)](#54-mapsåŒ…-go-121)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
    - [æ ¸å¿ƒå†…å®¹](#æ ¸å¿ƒå†…å®¹)
    - [è®¾è®¡å“²å­¦](#è®¾è®¡å“²å­¦)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

## ç¬¬ä¸€éƒ¨åˆ†: æ ¸å¿ƒåŒ…åˆ†æ

### 1.1 contextåŒ…

Context æ˜¯ Go å¹¶å‘ç¼–ç¨‹çš„æ ¸å¿ƒæŠ½è±¡ï¼Œç”¨äºä¼ é€’å–æ¶ˆä¿¡å·ã€æˆªæ­¢æ—¶é—´å’Œè¯·æ±‚ä½œç”¨åŸŸçš„å€¼ã€‚

#### å½¢å¼åŒ–å®šä¹‰

```mathematical
/* Context æ¥å£å½¢å¼åŒ– */

Context = (deadline, done, err, value)

å…¶ä¸­:
- deadline: Option[Time]  /* æˆªæ­¢æ—¶é—´ */
- done: <-chan struct{}   /* å®Œæˆä¿¡å· */
- err: Option[Error]      /* é”™è¯¯åŸå›  */
- value: Key â†’ Value      /* é”®å€¼å­˜å‚¨ */

/* Context ä»£æ•°ç»“æ„ */

/* å¹ºåŠç¾¤ (Monoid) ç»“æ„ */
âŸ¨Context, âŠ•, ÎµâŸ©

Îµ = Background()  /* å•ä½å…ƒ */
ctxâ‚ âŠ• ctxâ‚‚ = WithValue(ctxâ‚, k, v)  /* ç»„åˆæ“ä½œ */

/* æ»¡è¶³å¹ºåŠç¾¤å¾‹ */
1. ç»“åˆå¾‹: (ctxâ‚ âŠ• ctxâ‚‚) âŠ• ctxâ‚ƒ = ctxâ‚ âŠ• (ctxâ‚‚ âŠ• ctxâ‚ƒ)
2. å•ä½å¾‹: Îµ âŠ• ctx = ctx âŠ• Îµ = ctx

/* æ ‘çŠ¶ç»“æ„ */
Context Tree ::=
  | Background
  | TODO
  | WithCancel(parent)
  | WithDeadline(parent, deadline)
  | WithTimeout(parent, duration)
  | WithValue(parent, key, value)

/* å–æ¶ˆä¼ æ’­è§„åˆ™ */
[Cancel-Propagation]
parent.cancel() â†’ æ‰€æœ‰ children.cancel()

/* å€¼æŸ¥æ‰¾è§„åˆ™ */
[Value-Lookup]
ctx.Value(k) =
  if ctx has key k: return v
  else: return parent.Value(k)
```

#### Context å®ç°åˆ†æ

```go
package context

// Context æ¥å£
type Context interface {
    // Deadline è¿”å›æˆªæ­¢æ—¶é—´
    Deadline() (deadline time.Time, ok bool)

    // Done è¿”å›ä¸€ä¸ªchannelï¼Œå½“contextè¢«å–æ¶ˆæ—¶å…³é—­
    Done() <-chan struct{}

    // Err è¿”å›å–æ¶ˆåŸå› 
    Err() error

    // Value è¿”å›å…³è”çš„å€¼
    Value(key any) any
}

// emptyCtx: Background å’Œ TODO çš„å®ç°
type emptyCtx int

func (*emptyCtx) Deadline() (deadline time.Time, ok bool) {
    return
}

func (*emptyCtx) Done() <-chan struct{} {
    return nil
}

func (*emptyCtx) Err() error {
    return nil
}

func (*emptyCtx) Value(key any) any {
    return nil
}

var (
    background = new(emptyCtx)
    todo       = new(emptyCtx)
)

func Background() Context {
    return background
}

func TODO() Context {
    return todo
}

// cancelCtx: å¯å–æ¶ˆçš„context
type cancelCtx struct {
    Context  // åµŒå…¥çˆ¶context

    mu       sync.Mutex
    done     atomic.Value  // chan struct{}, å»¶è¿Ÿåˆ›å»º
    children map[canceler]struct{}  // å­contexté›†åˆ
    err      error
}

func (c *cancelCtx) Done() <-chan struct{} {
    d := c.done.Load()
    if d != nil {
        return d.(chan struct{})
    }
    c.mu.Lock()
    defer c.mu.Unlock()
    d = c.done.Load()
    if d == nil {
        d = make(chan struct{})
        c.done.Store(d)
    }
    return d.(chan struct{})
}

func (c *cancelCtx) Err() error {
    c.mu.Lock()
    err := c.err
    c.mu.Unlock()
    return err
}

// cancel å–æ¶ˆcontextåŠå…¶æ‰€æœ‰å­context
func (c *cancelCtx) cancel(removeFromParent bool, err error) {
    if err == nil {
        panic("context: internal error: missing cancel error")
    }
    c.mu.Lock()
    if c.err != nil {
        c.mu.Unlock()
        return  // å·²ç»è¢«å–æ¶ˆ
    }
    c.err = err
    d, _ := c.done.Load().(chan struct{})
    if d == nil {
        c.done.Store(closedchan)
    } else {
        close(d)  // å…³é—­done channelï¼Œé€šçŸ¥æ‰€æœ‰ç­‰å¾…è€…
    }
    // å–æ¶ˆæ‰€æœ‰å­context
    for child := range c.children {
        child.cancel(false, err)
    }
    c.children = nil
    c.mu.Unlock()

    if removeFromParent {
        removeChild(c.Context, c)
    }
}

// WithCancel åˆ›å»ºå¯å–æ¶ˆçš„context
func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
    c := newCancelCtx(parent)
    propagateCancel(parent, &c)
    return &c, func() { c.cancel(true, Canceled) }
}

// WithTimeout åˆ›å»ºå¸¦è¶…æ—¶çš„context
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {
    return WithDeadline(parent, time.Now().Add(timeout))
}

// WithDeadline åˆ›å»ºå¸¦æˆªæ­¢æ—¶é—´çš„context
func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) {
    if cur, ok := parent.Deadline(); ok && cur.Before(d) {
        // çˆ¶contextçš„æˆªæ­¢æ—¶é—´æ›´æ—©ï¼Œç›´æ¥ä½¿ç”¨çˆ¶context
        return WithCancel(parent)
    }
    c := &timerCtx{
        cancelCtx: newCancelCtx(parent),
        deadline:  d,
    }
    propagateCancel(parent, c)
    dur := time.Until(d)
    if dur <= 0 {
        c.cancel(true, DeadlineExceeded)  // å·²ç»è¶…æ—¶
        return c, func() { c.cancel(false, Canceled) }
    }
    c.mu.Lock()
    defer c.mu.Unlock()
    if c.err == nil {
        c.timer = time.AfterFunc(dur, func() {
            c.cancel(true, DeadlineExceeded)
        })
    }
    return c, func() { c.cancel(true, Canceled) }
}

// WithValue åˆ›å»ºå¸¦å€¼çš„context
func WithValue(parent Context, key, val any) Context {
    if key == nil {
        panic("nil key")
    }
    return &valueCtx{parent, key, val}
}

type valueCtx struct {
    Context
    key, val any
}

func (c *valueCtx) Value(key any) any {
    if c.key == key {
        return c.val
    }
    return value(c.Context, key)
}
```

#### Context ä½¿ç”¨æ¨¡å¼

```go
// æ¨¡å¼1: è¶…æ—¶æ§åˆ¶
func FetchWithTimeout(url string, timeout time.Duration) ([]byte, error) {
    ctx, cancel := context.WithTimeout(context.Background(), timeout)
    defer cancel()

    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, err
    }

    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    return io.ReadAll(resp.Body)
}

// æ¨¡å¼2: å–æ¶ˆä¼ æ’­
func ParallelWork(ctx context.Context, tasks []Task) error {
    g, ctx := errgroup.WithContext(ctx)

    for _, task := range tasks {
        task := task  // æ•è·å¾ªç¯å˜é‡
        g.Go(func() error {
            return task.Run(ctx)  // ä¼ æ’­å–æ¶ˆ
        })
    }

    return g.Wait()
}

// æ¨¡å¼3: å€¼ä¼ é€’ (è¯·æ±‚ä½œç”¨åŸŸ)
type contextKey string

const (
    requestIDKey contextKey = "request-id"
    userIDKey    contextKey = "user-id"
)

func WithRequestID(ctx context.Context, id string) context.Context {
    return context.WithValue(ctx, requestIDKey, id)
}

func RequestIDFromContext(ctx context.Context) (string, bool) {
    id, ok := ctx.Value(requestIDKey).(string)
    return id, ok
}

// HTTPä¸­é—´ä»¶ç¤ºä¾‹
func RequestIDMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        id := generateID()
        ctx := WithRequestID(r.Context(), id)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}
```

### 1.2 syncåŒ…

sync åŒ…æä¾›äº†åŸºæœ¬çš„åŒæ­¥åŸè¯­ã€‚

#### Mutex å½¢å¼åŒ–

```mathematical
/* Mutex å½¢å¼åŒ–è§„èŒƒ */

Mutex = (state, sema)

State ::= Unlocked | Locked(holder: Goroutine)

/* æ“ä½œ */
Lock: Mutex â†’ Mutex
Unlock: Mutex â†’ Mutex

/* è§„åˆ™ */

[Lock-Success]
m.state = Unlocked
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Lock(m) â†’ m' where m'.state = Locked(current_g)

[Lock-Block]
m.state = Locked(g)    g â‰  current_g
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Lock(m) â†’ block until m.state = Unlocked

[Unlock-Success]
m.state = Locked(g)    g = current_g
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Unlock(m) â†’ m' where m'.state = Unlocked

[Unlock-Error]
m.state = Unlocked  âˆ¨  m.holder â‰  current_g
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Unlock(m) â†’ panic
```

#### Mutex å®ç°åˆ†æ

```go
package sync

// Mutex ç»“æ„
type Mutex struct {
    state int32   // çŠ¶æ€å­—æ®µ
    sema  uint32  // ä¿¡å·é‡
}

const (
    mutexLocked = 1 << iota  // 1: å·²é”å®š
    mutexWoken               // 2: æœ‰goroutineè¢«å”¤é†’
    mutexStarving            // 4: é¥¥é¥¿æ¨¡å¼
    mutexWaiterShift = iota  // 3: ç­‰å¾…è€…æ•°é‡çš„ä½ç§»
)

// Lock åŠ é”
func (m *Mutex) Lock() {
    // å¿«é€Ÿè·¯å¾„: å°è¯•CASè·å–é”
    if atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) {
        return
    }
    // æ…¢è·¯å¾„
    m.lockSlow()
}

func (m *Mutex) lockSlow() {
    var waitStartTime int64
    starving := false
    awoke := false
    iter := 0
    old := m.state

    for {
        // æ­£å¸¸æ¨¡å¼ä¸‹ï¼Œå¦‚æœé”è¢«å ç”¨ä¸”ä¸æ˜¯é¥¥é¥¿æ¨¡å¼ï¼Œå°è¯•è‡ªæ—‹
        if old&(mutexLocked|mutexStarving) == mutexLocked && runtime_canSpin(iter) {
            // å°è¯•è®¾ç½® mutexWoken æ ‡å¿—
            if !awoke && old&mutexWoken == 0 && old>>mutexWaiterShift != 0 &&
                atomic.CompareAndSwapInt32(&m.state, old, old|mutexWoken) {
                awoke = true
            }
            runtime_doSpin()
            iter++
            old = m.state
            continue
        }

        new := old
        // å¦‚æœä¸æ˜¯é¥¥é¥¿æ¨¡å¼ï¼Œå°è¯•è·å–é”
        if old&mutexStarving == 0 {
            new |= mutexLocked
        }
        // å¦‚æœé”è¢«å ç”¨æˆ–å¤„äºé¥¥é¥¿æ¨¡å¼ï¼Œå¢åŠ ç­‰å¾…è€…è®¡æ•°
        if old&(mutexLocked|mutexStarving) != 0 {
            new += 1 << mutexWaiterShift
        }
        // å¦‚æœå½“å‰å¤„äºé¥¥é¥¿çŠ¶æ€ä¸”é”è¢«å ç”¨ï¼Œåˆ‡æ¢åˆ°é¥¥é¥¿æ¨¡å¼
        if starving && old&mutexLocked != 0 {
            new |= mutexStarving
        }
        if awoke {
            new &^= mutexWoken
        }

        if atomic.CompareAndSwapInt32(&m.state, old, new) {
            if old&(mutexLocked|mutexStarving) == 0 {
                break  // è·å–é”æˆåŠŸ
            }
            // ç­‰å¾…
            queueLifo := waitStartTime != 0
            if waitStartTime == 0 {
                waitStartTime = runtime_nanotime()
            }
            runtime_SemacquireMutex(&m.sema, queueLifo, 1)
            starving = starving || runtime_nanotime()-waitStartTime > starvationThresholdNs
            old = m.state
            if old&mutexStarving != 0 {
                // åœ¨é¥¥é¥¿æ¨¡å¼ä¸‹è¢«å”¤é†’ï¼Œç›´æ¥è·å–é”
                delta := int32(mutexLocked - 1<<mutexWaiterShift)
                if !starving || old>>mutexWaiterShift == 1 {
                    delta -= mutexStarving
                }
                atomic.AddInt32(&m.state, delta)
                break
            }
            awoke = true
            iter = 0
        } else {
            old = m.state
        }
    }
}

// Unlock è§£é”
func (m *Mutex) Unlock() {
    // å¿«é€Ÿè·¯å¾„: å°è¯•ç›´æ¥è§£é”
    new := atomic.AddInt32(&m.state, -mutexLocked)
    if new != 0 {
        m.unlockSlow(new)
    }
}

func (m *Mutex) unlockSlow(new int32) {
    if (new+mutexLocked)&mutexLocked == 0 {
        panic("sync: unlock of unlocked mutex")
    }
    if new&mutexStarving == 0 {
        // æ­£å¸¸æ¨¡å¼
        old := new
        for {
            // å¦‚æœæ²¡æœ‰ç­‰å¾…è€…ï¼Œæˆ–è€…å·²ç»æœ‰goroutineè¢«å”¤é†’ï¼Œç›´æ¥è¿”å›
            if old>>mutexWaiterShift == 0 || old&(mutexLocked|mutexWoken|mutexStarving) != 0 {
                return
            }
            // å”¤é†’ä¸€ä¸ªç­‰å¾…è€…
            new = (old - 1<<mutexWaiterShift) | mutexWoken
            if atomic.CompareAndSwapInt32(&m.state, old, new) {
                runtime_Semrelease(&m.sema, false, 1)
                return
            }
            old = m.state
        }
    } else {
        // é¥¥é¥¿æ¨¡å¼: ç›´æ¥å”¤é†’ç¬¬ä¸€ä¸ªç­‰å¾…è€…
        runtime_Semrelease(&m.sema, true, 1)
    }
}
```

#### RWMutex å®ç°

```go
// RWMutex è¯»å†™é”
type RWMutex struct {
    w           Mutex  // å†™é”
    writerSem   uint32 // å†™è€…ç­‰å¾…ä¿¡å·é‡
    readerSem   uint32 // è¯»è€…ç­‰å¾…ä¿¡å·é‡
    readerCount int32  // è¯»è€…è®¡æ•°
    readerWait  int32  // å†™è€…ç­‰å¾…çš„è¯»è€…æ•°
}

const rwmutexMaxReaders = 1 << 30

// RLock è¯»é”
func (rw *RWMutex) RLock() {
    if atomic.AddInt32(&rw.readerCount, 1) < 0 {
        // æœ‰å†™è€…ç­‰å¾…ï¼Œé˜»å¡
        runtime_SemacquireMutex(&rw.readerSem, false, 0)
    }
}

// RUnlock è¯»è§£é”
func (rw *RWMutex) RUnlock() {
    if r := atomic.AddInt32(&rw.readerCount, -1); r < 0 {
        // å¯èƒ½å”¤é†’å†™è€…
        rw.rUnlockSlow(r)
    }
}

func (rw *RWMutex) rUnlockSlow(r int32) {
    if r+1 == 0 || r+1 == -rwmutexMaxReaders {
        panic("sync: RUnlock of unlocked RWMutex")
    }
    // å¦‚æœæ˜¯æœ€åä¸€ä¸ªè¯»è€…ï¼Œå”¤é†’å†™è€…
    if atomic.AddInt32(&rw.readerWait, -1) == 0 {
        runtime_Semrelease(&rw.writerSem, false, 1)
    }
}

// Lock å†™é”
func (rw *RWMutex) Lock() {
    // è·å–äº’æ–¥é”
    rw.w.Lock()
    // é€šçŸ¥è¯»è€…æœ‰å†™è€…ç­‰å¾…
    r := atomic.AddInt32(&rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders
    // ç­‰å¾…æ‰€æœ‰è¯»è€…å®Œæˆ
    if r != 0 && atomic.AddInt32(&rw.readerWait, r) != 0 {
        runtime_SemacquireMutex(&rw.writerSem, false, 0)
    }
}

// Unlock å†™è§£é”
func (rw *RWMutex) Unlock() {
    // å…è®¸è¯»è€…
    r := atomic.AddInt32(&rw.readerCount, rwmutexMaxReaders)
    if r >= rwmutexMaxReaders {
        panic("sync: Unlock of unlocked RWMutex")
    }
    // å”¤é†’æ‰€æœ‰ç­‰å¾…çš„è¯»è€…
    for i := 0; i < int(r); i++ {
        runtime_Semrelease(&rw.readerSem, false, 0)
    }
    // é‡Šæ”¾å†™é”
    rw.w.Unlock()
}
```

### 1.3 ioåŒ…

io åŒ…å®šä¹‰äº†åŸºæœ¬çš„ I/O æ¥å£ã€‚

#### æ¥å£ä»£æ•°

```mathematical
/* I/O æ¥å£ä»£æ•° */

Reader = Read: []byte â†’ (int, error)
Writer = Write: []byte â†’ (int, error)
Closer = Close: () â†’ error

/* ç»„åˆæ¥å£ */
ReadWriter = Reader âŠ— Writer
ReadCloser = Reader âŠ— Closer
WriteCloser = Writer âŠ— Closer
ReadWriteCloser = Reader âŠ— Writer âŠ— Closer

/* å¹ºåŠç¾¤ç»“æ„ */
MultiReader: [Reader] â†’ Reader
MultiWriter: [Writer] â†’ Writer

/* èŒƒç•´è®ºè§†è§’ */
Category IO:
  Objects: æ•°æ®ç±»å‹ ([]byte, string, etc.)
  Morphisms: I/O æ“ä½œ (Read, Write, etc.)

Functor Copy: Reader Ã— Writer â†’ (int64, error)
  å°†Readerçš„è¾“å‡ºæ˜ å°„åˆ°Writerçš„è¾“å…¥
```

#### æ ¸å¿ƒæ¥å£

```go
package io

// Reader è¯»æ¥å£
type Reader interface {
    Read(p []byte) (n int, err error)
}

// Writer å†™æ¥å£
type Writer interface {
    Write(p []byte) (n int, err error)
}

// Closer å…³é—­æ¥å£
type Closer interface {
    Close() error
}

// Seeker å®šä½æ¥å£
type Seeker interface {
    Seek(offset int64, whence int) (int64, error)
}

// ç»„åˆæ¥å£
type ReadWriter interface {
    Reader
    Writer
}

type ReadCloser interface {
    Reader
    Closer
}

type WriteCloser interface {
    Writer
    Closer
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}

type ReadSeeker interface {
    Reader
    Seeker
}

// Copy æ ¸å¿ƒå‡½æ•°
func Copy(dst Writer, src Reader) (written int64, err error) {
    return copyBuffer(dst, src, nil)
}

func copyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error) {
    // ä¼˜åŒ–: å¦‚æœsrcå®ç°äº†WriterToï¼Œä½¿ç”¨å®ƒ
    if wt, ok := src.(WriterTo); ok {
        return wt.WriteTo(dst)
    }
    // ä¼˜åŒ–: å¦‚æœdstå®ç°äº†ReaderFromï¼Œä½¿ç”¨å®ƒ
    if rt, ok := dst.(ReaderFrom); ok {
        return rt.ReadFrom(src)
    }
    if buf == nil {
        size := 32 * 1024
        if l, ok := src.(*LimitedReader); ok && int64(size) > l.N {
            if l.N < 1 {
                size = 1
            } else {
                size = int(l.N)
            }
        }
        buf = make([]byte, size)
    }
    for {
        nr, er := src.Read(buf)
        if nr > 0 {
            nw, ew := dst.Write(buf[0:nr])
            if nw < 0 || nr < nw {
                nw = 0
                if ew == nil {
                    ew = errInvalidWrite
                }
            }
            written += int64(nw)
            if ew != nil {
                err = ew
                break
            }
            if nr != nw {
                err = ErrShortWrite
                break
            }
        }
        if er != nil {
            if er != EOF {
                err = er
            }
            break
        }
    }
    return written, err
}

// Pipe åˆ›å»ºåŒæ­¥çš„å†…å­˜ç®¡é“
func Pipe() (*PipeReader, *PipeWriter) {
    p := &pipe{
        wrCh: make(chan []byte),
        rdCh: make(chan int),
        done: make(chan struct{}),
    }
    return &PipeReader{p}, &PipeWriter{p}
}

type pipe struct {
    wrCh chan []byte
    rdCh chan int
    done chan struct{}

    rerr error
    werr error
}

// PipeReader å®ç°
func (r *PipeReader) Read(data []byte) (n int, err error) {
    select {
    case <-r.done:
        return 0, r.readCloseError()
    default:
    }

    select {
    case bw := <-r.wrCh:
        nr := copy(data, bw)
        r.rdCh <- nr
        return nr, nil
    case <-r.done:
        return 0, r.readCloseError()
    }
}

// MultiReader ç»„åˆå¤šä¸ªReader
func MultiReader(readers ...Reader) Reader {
    r := make([]Reader, len(readers))
    copy(r, readers)
    return &multiReader{r}
}

type multiReader struct {
    readers []Reader
}

func (mr *multiReader) Read(p []byte) (n int, err error) {
    for len(mr.readers) > 0 {
        n, err = mr.readers[0].Read(p)
        if err == EOF {
            mr.readers = mr.readers[1:]
        }
        if n > 0 || err != EOF {
            if err == EOF && len(mr.readers) > 0 {
                err = nil
            }
            return
        }
    }
    return 0, EOF
}
```

### 1.4 errorsåŒ…

Go 1.13+ å¼•å…¥äº†é”™è¯¯åŒ…è£…å’Œæ£€æŸ¥æœºåˆ¶ã€‚

#### é”™è¯¯ç³»ç»Ÿå½¢å¼åŒ–

```mathematical
/* é”™è¯¯ç±»å‹ç³»ç»Ÿ */

Error ::= Simple(msg: String)
        | Wrapped(msg: String, cause: Error)
        | Multiple([Error])

/* é”™è¯¯é“¾ */
ErrorChain = Errorâ‚€ â†’ Errorâ‚ â†’ ... â†’ Errorâ‚™

/* æ“ä½œ */
Wrap: Error Ã— String â†’ Error
Unwrap: Error â†’ Option[Error]
Is: Error Ã— Error â†’ Bool
As: Error Ã— *T â†’ Bool

/* Is è¯­ä¹‰ */
Is(err, target) =
  err == target âˆ¨
  âˆƒe âˆˆ ErrorChain(err). e == target

/* As è¯­ä¹‰ */
As(err, *target) =
  âˆƒe âˆˆ ErrorChain(err). TypeOf(e) == TypeOf(*target)
```

#### errors åŒ…å®ç°

```go
package errors

// New åˆ›å»ºç®€å•é”™è¯¯
func New(text string) error {
    return &errorString{text}
}

type errorString struct {
    s string
}

func (e *errorString) Error() string {
    return e.s
}

// Unwrap æ¥å£
type Unwrap interface {
    Unwrap() error
}

// Unwrap å‡½æ•°
func Unwrap(err error) error {
    u, ok := err.(interface {
        Unwrap() error
    })
    if !ok {
        return nil
    }
    return u.Unwrap()
}

// Is æ£€æŸ¥é”™è¯¯é“¾ä¸­æ˜¯å¦åŒ…å«target
func Is(err, target error) bool {
    if target == nil {
        return err == target
    }

    isComparable := reflectlite.TypeOf(target).Comparable()
    for {
        if isComparable && err == target {
            return true
        }
        if x, ok := err.(interface{ Is(error) bool }); ok && x.Is(target) {
            return true
        }
        if err = Unwrap(err); err == nil {
            return false
        }
    }
}

// As æ£€æŸ¥é”™è¯¯é“¾ä¸­æ˜¯å¦æœ‰ç±»å‹åŒ¹é…targetçš„é”™è¯¯
func As(err error, target any) bool {
    if target == nil {
        panic("errors: target cannot be nil")
    }
    val := reflectlite.ValueOf(target)
    typ := val.Type()
    if typ.Kind() != reflectlite.Ptr || val.IsNil() {
        panic("errors: target must be a non-nil pointer")
    }
    targetType := typ.Elem()
    if targetType.Kind() != reflectlite.Interface && !targetType.Implements(errorType) {
        panic("errors: *target must be interface or implement error")
    }
    for err != nil {
        if reflectlite.TypeOf(err).AssignableTo(targetType) {
            val.Elem().Set(reflectlite.ValueOf(err))
            return true
        }
        if x, ok := err.(interface{ As(any) bool }); ok && x.As(target) {
            return true
        }
        err = Unwrap(err)
    }
    return false
}

// Join ç»„åˆå¤šä¸ªé”™è¯¯ (Go 1.20+)
func Join(errs ...error) error {
    n := 0
    for _, err := range errs {
        if err != nil {
            n++
        }
    }
    if n == 0 {
        return nil
    }
    e := &joinError{
        errs: make([]error, 0, n),
    }
    for _, err := range errs {
        if err != nil {
            e.errs = append(e.errs, err)
        }
    }
    return e
}

type joinError struct {
    errs []error
}

func (e *joinError) Error() string {
    var b []byte
    for i, err := range e.errs {
        if i > 0 {
            b = append(b, '\n')
        }
        b = append(b, err.Error()...)
    }
    return string(b)
}

func (e *joinError) Unwrap() []error {
    return e.errs
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleErrors() error {
    // åˆ›å»ºåŸºç¡€é”™è¯¯
    baseErr := errors.New("base error")

    // åŒ…è£…é”™è¯¯
    wrappedErr := fmt.Errorf("operation failed: %w", baseErr)

    // æ£€æŸ¥é”™è¯¯
    if errors.Is(wrappedErr, baseErr) {
        fmt.Println("Contains base error")
    }

    // ç±»å‹æ–­è¨€
    var pathErr *os.PathError
    if errors.As(wrappedErr, &pathErr) {
        fmt.Println("Path:", pathErr.Path)
    }

    // ç»„åˆå¤šä¸ªé”™è¯¯
    err1 := errors.New("error 1")
    err2 := errors.New("error 2")
    combined := errors.Join(err1, err2)

    return combined
}
```

---

## ç¬¬äºŒéƒ¨åˆ†: å¹¶å‘åŸè¯­åŒ…

### 2.1 sync/atomic

atomic åŒ…æä¾›äº†åº•å±‚çš„åŸå­æ“ä½œã€‚

#### åŸå­æ“ä½œå½¢å¼åŒ–

```mathematical
/* åŸå­æ“ä½œè¯­ä¹‰ */

/* Load/Store */
Load: *T â†’ T  (åŸå­è¯»)
Store: *T Ã— T â†’ ()  (åŸå­å†™)

/* Add/Swap */
Add: *T Ã— Î” â†’ T  (åŸå­åŠ æ³•ï¼Œè¿”å›æ–°å€¼)
Swap: *T Ã— T â†’ T  (åŸå­äº¤æ¢ï¼Œè¿”å›æ—§å€¼)

/* Compare-And-Swap */
CAS: *T Ã— old Ã— new â†’ Bool
CAS(addr, old, new) =
  if *addr == old:
    *addr = new
    return true
  else:
    return false

/* å†…å­˜é¡ºåºä¿è¯ */
1. Load: Acquire barrier
2. Store: Release barrier
3. Swap/Add: Full barrier
4. CAS: Full barrier

/* å½¢å¼åŒ–è§„åˆ™ */

[Atomic-Load]
æ‰§è¡Œæ—¶åŸå­åœ°è¯»å–å†…å­˜ä½ç½®çš„å€¼
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
v = Load(addr)
v æ˜¯ä¸€ä¸ªä¸€è‡´çš„å¿«ç…§

[Atomic-Store]
æ‰§è¡Œæ—¶åŸå­åœ°å†™å…¥å†…å­˜ä½ç½®
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Store(addr, v)
å†™å…¥å¯¹å…¶ä»–goroutineç«‹å³å¯è§

[Atomic-CAS]
Compare-And-Swap åŸå­åœ°æ‰§è¡Œæ¯”è¾ƒå’Œäº¤æ¢
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
success = CAS(addr, old, new)
å¦‚æœæˆåŠŸï¼Œ*addr == new
å¦‚æœå¤±è´¥ï¼Œ*addr æœªæ”¹å˜
```

#### atomic åŒ…å®ç°

```go
package atomic

// Value æä¾›åŸå­æ“ä½œçš„å®¹å™¨
type Value struct {
    v any
}

// Load åŸå­åŠ è½½
func (v *Value) Load() (val any) {
    vp := (*ifaceWords)(unsafe.Pointer(v))
    typ := LoadPointer(&vp.typ)
    if typ == nil || typ == unsafe.Pointer(&firstStoreInProgress) {
        return nil
    }
    data := LoadPointer(&vp.data)
    vlp := (*ifaceWords)(unsafe.Pointer(&val))
    vlp.typ = typ
    vlp.data = data
    return
}

// Store åŸå­å­˜å‚¨
func (v *Value) Store(val any) {
    if val == nil {
        panic("sync/atomic: store of nil value into Value")
    }
    vp := (*ifaceWords)(unsafe.Pointer(v))
    vlp := (*ifaceWords)(unsafe.Pointer(&val))
    for {
        typ := LoadPointer(&vp.typ)
        if typ == nil {
            // ç¬¬ä¸€æ¬¡å­˜å‚¨
            runtime_procPin()
            if !CompareAndSwapPointer(&vp.typ, nil, unsafe.Pointer(&firstStoreInProgress)) {
                runtime_procUnpin()
                continue
            }
            StorePointer(&vp.data, vlp.data)
            StorePointer(&vp.typ, vlp.typ)
            runtime_procUnpin()
            return
        }
        if typ == unsafe.Pointer(&firstStoreInProgress) {
            // å…¶ä»–goroutineæ­£åœ¨å­˜å‚¨
            continue
        }
        // ç±»å‹å¿…é¡»åŒ¹é…
        if typ != vlp.typ {
            panic("sync/atomic: store of inconsistently typed value into Value")
        }
        StorePointer(&vp.data, vlp.data)
        return
    }
}

// Swap åŸå­äº¤æ¢
func (v *Value) Swap(new any) (old any) {
    if new == nil {
        panic("sync/atomic: swap of nil value into Value")
    }
    vp := (*ifaceWords)(unsafe.Pointer(v))
    np := (*ifaceWords)(unsafe.Pointer(&new))
    for {
        typ := LoadPointer(&vp.typ)
        if typ == nil || typ == unsafe.Pointer(&firstStoreInProgress) {
            runtime_procPin()
            if !CompareAndSwapPointer(&vp.typ, typ, unsafe.Pointer(&firstStoreInProgress)) {
                runtime_procUnpin()
                continue
            }
            if typ != nil {
                op := (*ifaceWords)(unsafe.Pointer(&old))
                op.typ = typ
                op.data = LoadPointer(&vp.data)
            }
            StorePointer(&vp.data, np.data)
            StorePointer(&vp.typ, np.typ)
            runtime_procUnpin()
            return
        }
        if typ != np.typ {
            panic("sync/atomic: swap of inconsistently typed value into Value")
        }
        op := (*ifaceWords)(unsafe.Pointer(&old))
        op.typ = typ
        op.data = SwapPointer(&vp.data, np.data)
        return
    }
}

// CompareAndSwap åŸå­æ¯”è¾ƒå¹¶äº¤æ¢
func (v *Value) CompareAndSwap(old, new any) (swapped bool) {
    if new == nil {
        panic("sync/atomic: compare and swap of nil value into Value")
    }
    vp := (*ifaceWords)(unsafe.Pointer(v))
    np := (*ifaceWords)(unsafe.Pointer(&new))
    op := (*ifaceWords)(unsafe.Pointer(&old))
    if op.typ != nil && np.typ != op.typ {
        return false
    }
    for {
        typ := LoadPointer(&vp.typ)
        if typ == nil || typ == unsafe.Pointer(&firstStoreInProgress) {
            if old != nil {
                return false
            }
            runtime_procPin()
            if !CompareAndSwapPointer(&vp.typ, typ, unsafe.Pointer(&firstStoreInProgress)) {
                runtime_procUnpin()
                continue
            }
            StorePointer(&vp.data, np.data)
            StorePointer(&vp.typ, np.typ)
            runtime_procUnpin()
            return true
        }
        if typ != np.typ {
            return false
        }
        data := LoadPointer(&vp.data)
        if op.typ != nil && data != op.data {
            return false
        }
        if CompareAndSwapPointer(&vp.data, data, np.data) {
            return true
        }
    }
}

// Int32/Int64/Uint32/Uint64 ç­‰ç±»å‹çš„åŸå­æ“ä½œ
type Int32 struct {
    _ noCopy
    v int32
}

func (x *Int32) Load() int32 {
    return LoadInt32(&x.v)
}

func (x *Int32) Store(val int32) {
    StoreInt32(&x.v, val)
}

func (x *Int32) Swap(new int32) (old int32) {
    return SwapInt32(&x.v, new)
}

func (x *Int32) CompareAndSwap(old, new int32) (swapped bool) {
    return CompareAndSwapInt32(&x.v, old, new)
}

func (x *Int32) Add(delta int32) (new int32) {
    return AddInt32(&x.v, delta)
}
```

### 2.2 sync/singleflight

singleflight åŒ…ç”¨äºæŠ‘åˆ¶é‡å¤çš„å‡½æ•°è°ƒç”¨ï¼Œé€‚ç”¨äºç¼“å­˜åœºæ™¯ã€‚

#### å½¢å¼åŒ–å®šä¹‰1

```mathematical
/* Singleflight è¯­ä¹‰ */

Group = Map[Key, *call]

call = (wg: WaitGroup, val: any, err: error)

/* æ“ä½œ */
Do: Group Ã— Key Ã— (func() (any, error)) â†’ (any, error, bool)

/* è§„åˆ™ */

[First-Call]
key âˆ‰ Group
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Do(g, key, fn) =
  1. åˆ›å»º call c
  2. Group[key] = c
  3. val, err = fn()
  4. c.val = val, c.err = err
  5. delete(Group, key)
  6. return (val, err, false)

[Duplicate-Call]
key âˆˆ Group    c = Group[key]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Do(g, key, fn) =
  1. ç­‰å¾… c.wg
  2. return (c.val, c.err, true)  /* shared=true */
```

#### singleflight å®ç°

```go
package singleflight

import (
    "bytes"
    "fmt"
    "runtime"
    "sync"
)

// Group ä»£è¡¨ä¸€ä¸ªå·¥ä½œç±»
type Group struct {
    mu sync.Mutex
    m  map[string]*call
}

// call ä»£è¡¨ä¸€ä¸ªæ­£åœ¨è¿›è¡Œæˆ–å·²å®Œæˆçš„Doè°ƒç”¨
type call struct {
    wg sync.WaitGroup

    val any
    err error

    dups  int  // é‡å¤è°ƒç”¨æ¬¡æ•°
    chans []chan<- Result
}

// Result ä¿å­˜Doçš„ç»“æœ
type Result struct {
    Val    any
    Err    error
    Shared bool  // æ˜¯å¦æ˜¯å…±äº«ç»“æœ
}

// Do æ‰§è¡Œå¹¶è¿”å›ç»™å®šå‡½æ•°çš„ç»“æœï¼Œç¡®ä¿åŒæ—¶åªæœ‰ä¸€ä¸ªæ‰§è¡Œ
func (g *Group) Do(key string, fn func() (any, error)) (v any, err error, shared bool) {
    g.mu.Lock()
    if g.m == nil {
        g.m = make(map[string]*call)
    }
    if c, ok := g.m[key]; ok {
        c.dups++
        g.mu.Unlock()
        c.wg.Wait()  // ç­‰å¾…ç¬¬ä¸€ä¸ªè°ƒç”¨å®Œæˆ
        return c.val, c.err, true
    }
    c := new(call)
    c.wg.Add(1)
    g.m[key] = c
    g.mu.Unlock()

    g.doCall(c, key, fn)
    return c.val, c.err, c.dups > 0
}

// DoChan ç±»ä¼¼Doï¼Œä½†è¿”å›ä¸€ä¸ªchannel
func (g *Group) DoChan(key string, fn func() (any, error)) <-chan Result {
    ch := make(chan Result, 1)
    g.mu.Lock()
    if g.m == nil {
        g.m = make(map[string]*call)
    }
    if c, ok := g.m[key]; ok {
        c.dups++
        c.chans = append(c.chans, ch)
        g.mu.Unlock()
        return ch
    }
    c := &call{chans: []chan<- Result{ch}}
    c.wg.Add(1)
    g.m[key] = c
    g.mu.Unlock()

    go g.doCall(c, key, fn)

    return ch
}

// doCall æ‰§è¡Œå®é™…çš„è°ƒç”¨
func (g *Group) doCall(c *call, key string, fn func() (any, error)) {
    c.val, c.err = fn()
    c.wg.Done()

    g.mu.Lock()
    delete(g.m, key)
    for _, ch := range c.chans {
        ch <- Result{c.val, c.err, c.dups > 0}
    }
    g.mu.Unlock()
}

// Forget å‘Šè¯‰Groupå¿˜è®°ä¸€ä¸ªkey
func (g *Group) Forget(key string) {
    g.mu.Lock()
    delete(g.m, key)
    g.mu.Unlock()
}

// ä½¿ç”¨ç¤ºä¾‹
type Cache struct {
    g     singleflight.Group
    cache map[string]string
    mu    sync.RWMutex
}

func (c *Cache) Get(key string) (string, error) {
    // å…ˆæŸ¥ç¼“å­˜
    c.mu.RLock()
    val, ok := c.cache[key]
    c.mu.RUnlock()
    if ok {
        return val, nil
    }

    // ä½¿ç”¨singleflighté¿å…ç¼“å­˜å‡»ç©¿
    v, err, shared := c.g.Do(key, func() (any, error) {
        // ä»æ•°æ®åº“åŠ è½½
        val, err := loadFromDB(key)
        if err != nil {
            return "", err
        }
        // æ›´æ–°ç¼“å­˜
        c.mu.Lock()
        c.cache[key] = val
        c.mu.Unlock()
        return val, nil
    })

    if err != nil {
        return "", err
    }
    return v.(string), nil
}
```

### 2.3 sync/errgroup

errgroup åŒ…æä¾›äº†goroutineçš„åŒæ­¥ã€é”™è¯¯ä¼ æ’­å’Œä¸Šä¸‹æ–‡å–æ¶ˆã€‚

#### å½¢å¼åŒ–å®šä¹‰2

```mathematical
/* Errgroup è¯­ä¹‰ */

Group = (wg: WaitGroup, ctx: Context, cancel: CancelFunc, err: error)

/* æ“ä½œ */
Go: Group Ã— (func() error) â†’ ()
Wait: Group â†’ error

/* è§„åˆ™ */

[Go-Submit]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
g.Go(f) =
  1. wg.Add(1)
  2. å¯åŠ¨ goroutine:
       err := f()
       if err â‰  nil:
         ä¿å­˜ç¬¬ä¸€ä¸ªé”™è¯¯
         cancel()
       wg.Done()

[Wait-Return]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
g.Wait() =
  1. wg.Wait()
  2. return ç¬¬ä¸€ä¸ªé”™è¯¯
```

#### errgroup å®ç°

```go
package errgroup

import (
    "context"
    "sync"
)

// Group æ˜¯ä¸€ç»„goroutinesçš„é›†åˆ
type Group struct {
    cancel func()

    wg sync.WaitGroup

    errOnce sync.Once
    err     error
}

// WithContext è¿”å›ä¸€ä¸ªæ–°çš„Groupå’Œå…³è”çš„Context
func WithContext(ctx context.Context) (*Group, context.Context) {
    ctx, cancel := context.WithCancel(ctx)
    return &Group{cancel: cancel}, ctx
}

// Wait ç­‰å¾…æ‰€æœ‰goroutineså®Œæˆï¼Œè¿”å›ç¬¬ä¸€ä¸ªé”™è¯¯
func (g *Group) Wait() error {
    g.wg.Wait()
    if g.cancel != nil {
        g.cancel()
    }
    return g.err
}

// Go å¯åŠ¨ä¸€ä¸ªgoroutine
func (g *Group) Go(f func() error) {
    g.wg.Add(1)

    go func() {
        defer g.wg.Done()

        if err := f(); err != nil {
            g.errOnce.Do(func() {
                g.err = err
                if g.cancel != nil {
                    g.cancel()  // å–æ¶ˆå…¶ä»–goroutines
                }
            })
        }
    }()
}

// SetLimit é™åˆ¶å¹¶å‘goroutineæ•°é‡ (Go 1.20+)
func (g *Group) SetLimit(n int) {
    // å®ç°çœç•¥
}

// ä½¿ç”¨ç¤ºä¾‹
func FetchURLs(ctx context.Context, urls []string) ([]string, error) {
    g, ctx := errgroup.WithContext(ctx)
    results := make([]string, len(urls))

    for i, url := range urls {
        i, url := i, url  // æ•è·å¾ªç¯å˜é‡
        g.Go(func() error {
            resp, err := fetchURL(ctx, url)
            if err != nil {
                return err
            }
            results[i] = resp
            return nil
        })
    }

    if err := g.Wait(); err != nil {
        return nil, err
    }
    return results, nil
}
```

---

## ç¬¬ä¸‰éƒ¨åˆ†: ç½‘ç»œä¸I/OåŒ…

### 3.1 netåŒ…

net åŒ…æä¾›äº†è·¨å¹³å°çš„ç½‘ç»œI/Oæ¥å£ã€‚

#### ç½‘ç»œç¼–ç¨‹å½¢å¼åŒ–

```mathematical
/* ç½‘ç»œè¿æ¥æŠ½è±¡ */

Conn = (Read, Write, Close, LocalAddr, RemoteAddr)

/* ç›‘å¬å™¨æŠ½è±¡ */
Listener = (Accept, Close, Addr)

/* TCPè¿æ¥å»ºç«‹ */
[TCP-Dial]
addr: Address
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Dial("tcp", addr) â†’ (Conn, error)

[TCP-Listen]
addr: Address
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Listen("tcp", addr) â†’ (Listener, error)

[TCP-Accept]
ln: Listener
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ln.Accept() â†’ (Conn, error)
```

#### net åŒ…æ ¸å¿ƒæ¥å£

```go
package net

// Conn æ¥å£å®šä¹‰äº†é€šç”¨çš„ç½‘ç»œè¿æ¥
type Conn interface {
    Read(b []byte) (n int, err error)
    Write(b []byte) (n int, err error)
    Close() error
    LocalAddr() Addr
    RemoteAddr() Addr
    SetDeadline(t time.Time) error
    SetReadDeadline(t time.Time) error
    SetWriteDeadline(t time.Time) error
}

// Listener ç›‘å¬å™¨æ¥å£
type Listener interface {
    Accept() (Conn, error)
    Close() error
    Addr() Addr
}

// TCPæœåŠ¡å™¨ç¤ºä¾‹
func TCPServer(addr string) error {
    ln, err := net.Listen("tcp", addr)
    if err != nil {
        return err
    }
    defer ln.Close()

    for {
        conn, err := ln.Accept()
        if err != nil {
            return err
        }
        go handleConnection(conn)
    }
}

func handleConnection(conn net.Conn) {
    defer conn.Close()

    // è®¾ç½®è¶…æ—¶
    conn.SetDeadline(time.Now().Add(30 * time.Second))

    buf := make([]byte, 1024)
    for {
        n, err := conn.Read(buf)
        if err != nil {
            if err != io.EOF {
                log.Printf("Read error: %v", err)
            }
            return
        }

        _, err = conn.Write(buf[:n])
        if err != nil {
            log.Printf("Write error: %v", err)
            return
        }
    }
}

// TCPå®¢æˆ·ç«¯ç¤ºä¾‹
func TCPClient(addr string, data []byte) error {
    conn, err := net.Dial("tcp", addr)
    if err != nil {
        return err
    }
    defer conn.Close()

    _, err = conn.Write(data)
    if err != nil {
        return err
    }

    reply := make([]byte, 1024)
    n, err := conn.Read(reply)
    if err != nil {
        return err
    }

    fmt.Printf("Reply: %s\n", reply[:n])
    return nil
}
```

### 3.2 net/httpåŒ…

net/http åŒ…æä¾›äº†HTTPå®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨å®ç°ã€‚

#### HTTPè¯­ä¹‰å½¢å¼åŒ–

```mathematical
/* HTTPè¯·æ±‚-å“åº”æ¨¡å‹ */

Request = (Method, URL, Headers, Body)
Response = (StatusCode, Headers, Body)

/* Handler æ¥å£ */
Handler = Request â†’ Response

/* ä¸­é—´ä»¶æ¨¡å¼ */
Middleware = Handler â†’ Handler

/* ç»„åˆå¾‹ */
middlewareâ‚ âˆ˜ middlewareâ‚‚ âˆ˜ handler
= middlewareâ‚(middlewareâ‚‚(handler))
```

#### HTTPæœåŠ¡å™¨å®ç°

```go
package http

// Handler æ¥å£
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}

// HandlerFunc å‡½æ•°é€‚é…å™¨
type HandlerFunc func(ResponseWriter, *Request)

func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)
}

// HTTPæœåŠ¡å™¨ç¤ºä¾‹
func main() {
    // æ–¹æ³•1: ä½¿ç”¨HandleFunc
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Hello, World!")
    })

    // æ–¹æ³•2: ä½¿ç”¨Handler
    http.Handle("/api/", apiHandler())

    // å¯åŠ¨æœåŠ¡å™¨
    log.Fatal(http.ListenAndServe(":8080", nil))
}

// è‡ªå®šä¹‰Handler
type APIHandler struct {
    db *sql.DB
}

func (h *APIHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    switch r.URL.Path {
    case "/api/users":
        h.handleUsers(w, r)
    case "/api/posts":
        h.handlePosts(w, r)
    default:
        http.NotFound(w, r)
    }
}

// ä¸­é—´ä»¶æ¨¡å¼
func loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        next.ServeHTTP(w, r)
        log.Printf("%s %s %v", r.Method, r.URL.Path, time.Since(start))
    })
}

func authMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        token := r.Header.Get("Authorization")
        if !validateToken(token) {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        next.ServeHTTP(w, r)
    })
}

// ç»„åˆä¸­é—´ä»¶
func chainMiddleware(h http.Handler, middlewares ...func(http.Handler) http.Handler) http.Handler {
    for i := len(middlewares) - 1; i >= 0; i-- {
        h = middlewares[i](h)
    }
    return h
}

// HTTPå®¢æˆ·ç«¯ç¤ºä¾‹
func HTTPClient() error {
    client := &http.Client{
        Timeout: 10 * time.Second,
    }

    req, err := http.NewRequest("GET", "https://api.example.com/data", nil)
    if err != nil {
        return err
    }

    req.Header.Set("Authorization", "Bearer token")
    req.Header.Set("Content-Type", "application/json")

    resp, err := client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("unexpected status: %d", resp.StatusCode)
    }

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return err
    }

    fmt.Printf("Response: %s\n", body)
    return nil
}
```

### 3.3 io/fsåŒ…

io/fs åŒ…å®šä¹‰äº†æ–‡ä»¶ç³»ç»Ÿçš„åŸºæœ¬æ¥å£ï¼ˆGo 1.16+ï¼‰ã€‚

#### æ–‡ä»¶ç³»ç»Ÿå½¢å¼åŒ–

```mathematical
/* æ–‡ä»¶ç³»ç»ŸæŠ½è±¡ */

FS = Open: Path â†’ (File, error)

File = (Read, Stat, Close)

FileInfo = (Name, Size, Mode, ModTime, IsDir)

/* æ“ä½œè§„åˆ™ */

[Open-File]
path: Path    fs: FS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
fs.Open(path) â†’ (File, nil)  if exists
fs.Open(path) â†’ (nil, ErrNotExist)  if not exists

[Read-Dir]
path: Path    fs: FS    path is directory
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ReadDir(fs, path) â†’ ([]DirEntry, nil)
```

#### io/fs å®ç°

```go
package fs

// FS æ¥å£å®šä¹‰äº†æ–‡ä»¶ç³»ç»Ÿ
type FS interface {
    Open(name string) (File, error)
}

// File æ¥å£å®šä¹‰äº†æ–‡ä»¶
type File interface {
    Stat() (FileInfo, error)
    Read([]byte) (int, error)
    Close() error
}

// FileInfo æè¿°æ–‡ä»¶ä¿¡æ¯
type FileInfo interface {
    Name() string
    Size() int64
    Mode() FileMode
    ModTime() time.Time
    IsDir() bool
    Sys() any
}

// ReadDir è¯»å–ç›®å½•
func ReadDir(fsys FS, name string) ([]DirEntry, error) {
    // å®ç°çœç•¥
}

// WalkDir éå†ç›®å½•æ ‘
func WalkDir(fsys FS, root string, fn WalkDirFunc) error {
    // å®ç°çœç•¥
}

// ä½¿ç”¨ç¤ºä¾‹: embedæ–‡ä»¶ç³»ç»Ÿ
//go:embed static/*
var staticFiles embed.FS

func ServeStatic() {
    http.Handle("/static/", http.FileServer(http.FS(staticFiles)))
    http.ListenAndServe(":8080", nil)
}

// è‡ªå®šä¹‰æ–‡ä»¶ç³»ç»Ÿ
type MemFS struct {
    files map[string][]byte
}

func (m *MemFS) Open(name string) (fs.File, error) {
    data, ok := m.files[name]
    if !ok {
        return nil, fs.ErrNotExist
    }
    return &memFile{
        name: name,
        data: data,
    }, nil
}

type memFile struct {
    name string
    data []byte
    off  int
}

func (f *memFile) Read(b []byte) (int, error) {
    if f.off >= len(f.data) {
        return 0, io.EOF
    }
    n := copy(b, f.data[f.off:])
    f.off += n
    return n, nil
}
```

---

## ç¬¬å››éƒ¨åˆ†: ç¼–ç ä¸åºåˆ—åŒ–

### 4.1 encoding/json

JSON ç¼–ç å’Œè§£ç ã€‚

#### JSONç¼–è§£ç å½¢å¼åŒ–

```mathematical
/* JSONç±»å‹ç³»ç»Ÿ */

JSON ::= Null
       | Bool
       | Number
       | String
       | Array[JSON]
       | Object[String â†’ JSON]

/* ç¼–è§£ç æ“ä½œ */
Marshal: Go Value â†’ JSON bytes
Unmarshal: JSON bytes â†’ Go Value

/* æ˜ å°„è§„åˆ™ */
Go Type        â†’ JSON Type
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
bool           â†’ Boolean
int/float      â†’ Number
string         â†’ String
[]T            â†’ Array
map[string]T   â†’ Object
struct         â†’ Object
pointer        â†’ value or null
interface{}    â†’ any JSON type
```

#### encoding/json å®ç°

```go
package json

// Marshal å°†Goå€¼ç¼–ç ä¸ºJSON
func Marshal(v any) ([]byte, error) {
    e := newEncodeState()
    defer encodeStatePool.Put(e)

    err := e.marshal(v, encOpts{})
    if err != nil {
        return nil, err
    }
    buf := append([]byte(nil), e.Bytes()...)
    return buf, nil
}

// Unmarshal å°†JSONè§£ç ä¸ºGoå€¼
func Unmarshal(data []byte, v any) error {
    var d decodeState
    d.init(data)
    return d.unmarshal(v)
}

// Encoder æµå¼ç¼–ç å™¨
type Encoder struct {
    w   io.Writer
    err error
}

func NewEncoder(w io.Writer) *Encoder {
    return &Encoder{w: w}
}

func (enc *Encoder) Encode(v any) error {
    if enc.err != nil {
        return enc.err
    }
    e := newEncodeState()
    defer encodeStatePool.Put(e)

    err := e.marshal(v, encOpts{})
    if err != nil {
        return err
    }

    e.WriteByte('\n')
    _, err = enc.w.Write(e.Bytes())
    return err
}

// Decoder æµå¼è§£ç å™¨
type Decoder struct {
    r   io.Reader
    buf []byte
}

func NewDecoder(r io.Reader) *Decoder {
    return &Decoder{r: r}
}

func (dec *Decoder) Decode(v any) error {
    // å®ç°çœç•¥
}

// ä½¿ç”¨ç¤ºä¾‹
type User struct {
    ID        int       `json:"id"`
    Name      string    `json:"name"`
    Email     string    `json:"email,omitempty"`
    CreatedAt time.Time `json:"created_at"`
}

func ExampleJSON() {
    // ç¼–ç 
    user := User{
        ID:        1,
        Name:      "Alice",
        Email:     "alice@example.com",
        CreatedAt: time.Now(),
    }

    data, err := json.Marshal(user)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("JSON: %s\n", data)

    // è§£ç 
    var decoded User
    err = json.Unmarshal(data, &decoded)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("User: %+v\n", decoded)

    // æµå¼ç¼–ç 
    file, _ := os.Create("users.json")
    defer file.Close()
    encoder := json.NewEncoder(file)
    encoder.Encode(user)
}
```

### 4.2 encoding/xml

XML ç¼–ç å’Œè§£ç ã€‚

```go
package xml

// Marshal å°†Goå€¼ç¼–ç ä¸ºXML
func Marshal(v any) ([]byte, error) {
    var b bytes.Buffer
    if err := NewEncoder(&b).Encode(v); err != nil {
        return nil, err
    }
    return b.Bytes(), nil
}

// Unmarshal å°†XMLè§£ç ä¸ºGoå€¼
func Unmarshal(data []byte, v any) error {
    return NewDecoder(bytes.NewReader(data)).Decode(v)
}

// ä½¿ç”¨ç¤ºä¾‹
type Book struct {
    XMLName xml.Name `xml:"book"`
    ID      int      `xml:"id,attr"`
    Title   string   `xml:"title"`
    Author  string   `xml:"author"`
    Price   float64  `xml:"price"`
}

func ExampleXML() {
    book := Book{
        ID:     1,
        Title:  "Go Programming",
        Author: "John Doe",
        Price:  29.99,
    }

    data, _ := xml.MarshalIndent(book, "", "  ")
    fmt.Printf("XML:\n%s\n", data)

    var decoded Book
    xml.Unmarshal(data, &decoded)
    fmt.Printf("Book: %+v\n", decoded)
}
```

### 4.3 encoding/gob

Go ä¸“ç”¨çš„äºŒè¿›åˆ¶ç¼–ç æ ¼å¼ã€‚

```go
package gob

// Encoder ç¼–ç å™¨
type Encoder struct {
    w io.Writer
}

func NewEncoder(w io.Writer) *Encoder {
    return &Encoder{w: w}
}

func (enc *Encoder) Encode(e any) error {
    // å®ç°çœç•¥
}

// Decoder è§£ç å™¨
type Decoder struct {
    r io.Reader
}

func NewDecoder(r io.Reader) *Decoder {
    return &Decoder{r: r}
}

func (dec *Decoder) Decode(e any) error {
    // å®ç°çœç•¥
}

// ä½¿ç”¨ç¤ºä¾‹: RPCé€šä¿¡
func ExampleGob() {
    var network bytes.Buffer

    // ç¼–ç 
    enc := gob.NewEncoder(&network)
    data := map[string]int{"one": 1, "two": 2, "three": 3}
    enc.Encode(data)

    // è§£ç 
    dec := gob.NewDecoder(&network)
    var decoded map[string]int
    dec.Decode(&decoded)
    fmt.Printf("Decoded: %v\n", decoded)
}
```

---

## ç¬¬äº”éƒ¨åˆ†: ç®—æ³•ä¸æ•°æ®ç»“æ„

### 5.1 containeråŒ…

container åŒ…æä¾›äº†heapã€listã€ringä¸‰ç§æ•°æ®ç»“æ„ã€‚

```go
package container

// heap.Interface
type Interface interface {
    sort.Interface
    Push(x any)
    Pop() any
}

// ä¼˜å…ˆé˜Ÿåˆ—ç¤ºä¾‹
type PriorityQueue []*Item

type Item struct {
    value    string
    priority int
    index    int
}

func (pq PriorityQueue) Len() int { return len(pq) }

func (pq PriorityQueue) Less(i, j int) bool {
    return pq[i].priority > pq[j].priority
}

func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
    pq[i].index = i
    pq[j].index = j
}

func (pq *PriorityQueue) Push(x any) {
    n := len(*pq)
    item := x.(*Item)
    item.index = n
    *pq = append(*pq, item)
}

func (pq *PriorityQueue) Pop() any {
    old := *pq
    n := len(old)
    item := old[n-1]
    old[n-1] = nil
    item.index = -1
    *pq = old[0 : n-1]
    return item
}

// é“¾è¡¨ç¤ºä¾‹ (list.List)
func ExampleList() {
    l := list.New()
    l.PushBack(1)
    l.PushBack(2)
    l.PushFront(0)

    for e := l.Front(); e != nil; e = e.Next() {
        fmt.Println(e.Value)
    }
}
```

### 5.2 sortåŒ…

æ’åºç®—æ³•ã€‚

```go
package sort

// Sort å¯¹dataè¿›è¡Œæ’åº
func Sort(data Interface) {
    n := data.Len()
    quickSort(data, 0, n, maxDepth(n))
}

// Interface æ’åºæ¥å£
type Interface interface {
    Len() int
    Less(i, j int) bool
    Swap(i, j int)
}

// ä¾¿æ·å‡½æ•°
func Ints(x []int) { Sort(IntSlice(x)) }
func Float64s(x []float64) { Sort(Float64Slice(x)) }
func Strings(x []string) { Sort(StringSlice(x)) }

// Slice å¯¹åˆ‡ç‰‡æ’åº (Go 1.8+)
func Slice(x any, less func(i, j int) bool) {
    // å®ç°çœç•¥
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleSort() {
    // æ’åºæ•´æ•°
    ints := []int{3, 1, 4, 1, 5, 9, 2, 6}
    sort.Ints(ints)
    fmt.Println(ints)

    // è‡ªå®šä¹‰æ’åº
    type Person struct {
        Name string
        Age  int
    }

    people := []Person{
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 35},
    }

    sort.Slice(people, func(i, j int) bool {
        return people[i].Age < people[j].Age
    })
}
```

### 5.3 slicesåŒ… (Go 1.21+)

æ³›å‹åˆ‡ç‰‡æ“ä½œã€‚

```go
package slices

// BinarySearch äºŒåˆ†æŸ¥æ‰¾
func BinarySearch[S ~[]E, E cmp.Ordered](x S, target E) (int, bool) {
    // å®ç°çœç•¥
}

// Clone å…‹éš†åˆ‡ç‰‡
func Clone[S ~[]E, E any](s S) S {
    return append(S([]E{}), s...)
}

// Compact å‹ç¼©è¿ç»­é‡å¤å…ƒç´ 
func Compact[S ~[]E, E comparable](s S) S {
    // å®ç°çœç•¥
}

// Contains æ£€æŸ¥æ˜¯å¦åŒ…å«å…ƒç´ 
func Contains[S ~[]E, E comparable](s S, v E) bool {
    return Index(s, v) >= 0
}

// Delete åˆ é™¤å…ƒç´ 
func Delete[S ~[]E, E any](s S, i, j int) S {
    return append(s[:i], s[j:]...)
}

// Equal æ¯”è¾ƒä¸¤ä¸ªåˆ‡ç‰‡
func Equal[S ~[]E, E comparable](s1, s2 S) bool {
    if len(s1) != len(s2) {
        return false
    }
    for i := range s1 {
        if s1[i] != s2[i] {
            return false
        }
    }
    return true
}

// Index æŸ¥æ‰¾å…ƒç´ ç´¢å¼•
func Index[S ~[]E, E comparable](s S, v E) int {
    for i := range s {
        if s[i] == v {
            return i
        }
    }
    return -1
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleSlices() {
    s := []int{1, 2, 3, 4, 5}

    // æŸ¥æ‰¾
    if slices.Contains(s, 3) {
        fmt.Println("Found 3")
    }

    // åˆ é™¤
    s = slices.Delete(s, 1, 3)  // [1, 4, 5]

    // å…‹éš†
    s2 := slices.Clone(s)

    // æ¯”è¾ƒ
    if slices.Equal(s, s2) {
        fmt.Println("Equal")
    }
}
```

### 5.4 mapsåŒ… (Go 1.21+)

æ³›å‹mapæ“ä½œã€‚

```go
package maps

// Clone å…‹éš†map
func Clone[M ~map[K]V, K comparable, V any](m M) M {
    r := make(M, len(m))
    for k, v := range m {
        r[k] = v
    }
    return r
}

// Copy å¤åˆ¶map
func Copy[M ~map[K]V, K comparable, V any](dst, src M) {
    for k, v := range src {
        dst[k] = v
    }
}

// DeleteFunc æ¡ä»¶åˆ é™¤
func DeleteFunc[M ~map[K]V, K comparable, V any](m M, del func(K, V) bool) {
    for k, v := range m {
        if del(k, v) {
            delete(m, k)
        }
    }
}

// Equal æ¯”è¾ƒä¸¤ä¸ªmap
func Equal[M ~map[K]V, K, V comparable](m1, m2 M) bool {
    if len(m1) != len(m2) {
        return false
    }
    for k, v1 := range m1 {
        if v2, ok := m2[k]; !ok || v1 != v2 {
            return false
        }
    }
    return true
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleMaps() {
    m1 := map[string]int{"a": 1, "b": 2, "c": 3}

    // å…‹éš†
    m2 := maps.Clone(m1)

    // æ¯”è¾ƒ
    if maps.Equal(m1, m2) {
        fmt.Println("Equal")
    }

    // æ¡ä»¶åˆ é™¤
    maps.DeleteFunc(m1, func(k string, v int) bool {
        return v < 2
    })
}
```

---

## ğŸ¯ æ€»ç»“

### æ ¸å¿ƒå†…å®¹

1. **ContextåŒ…**: å–æ¶ˆä¼ æ’­ã€è¶…æ—¶æ§åˆ¶ã€å€¼ä¼ é€’
2. **SyncåŒ…**: Mutexã€RWMutexã€WaitGroupã€Onceç­‰åŒæ­¥åŸè¯­
3. **I/OåŒ…**: Reader/Writeræ¥å£ã€Pipeã€Copyç­‰æ ¸å¿ƒåŠŸèƒ½
4. **ErrorsåŒ…**: é”™è¯¯åŒ…è£…ã€æ£€æŸ¥ã€ç»„åˆæœºåˆ¶
5. **AtomicåŒ…**: åŸå­æ“ä½œã€å†…å­˜é¡ºåºä¿è¯

### è®¾è®¡å“²å­¦

- **æ¥å£æŠ½è±¡**: å°æ¥å£ç»„åˆæˆå¤§æ¥å£
- **æ­£äº¤æ€§**: åŠŸèƒ½ç‹¬ç«‹ï¼Œå¯è‡ªç”±ç»„åˆ
- **ç®€æ´æ€§**: æœ€å°åŒ–APIè¡¨é¢ç§¯
- **æ€§èƒ½**: é›¶æˆæœ¬æŠ½è±¡

### æœ€ä½³å®è·µ

1. ä½¿ç”¨ Context ä¼ é€’å–æ¶ˆä¿¡å·å’Œæˆªæ­¢æ—¶é—´
2. é€‰æ‹©åˆé€‚çš„åŒæ­¥åŸè¯­ï¼ˆMutex vs Channelï¼‰
3. åˆ©ç”¨ io.Reader/Writer æ¥å£çš„ç»„åˆæ€§
4. æ­£ç¡®å¤„ç†é”™è¯¯é“¾

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0
**é€‚ç”¨Goç‰ˆæœ¬**: 1.25.3
**æœ€åæ›´æ–°**: 2025-10-29
**ç»´æŠ¤å›¢é˜Ÿ**: Go Standard Library Team
