# Go 1.25.3 标准库系统分析与形式化规范

**文档版本**: v1.0.0  
**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---

## 📋 目录

- [第一部分: 核心包分析](#第一部分-核心包分析)
  - [1.1 context包](#1-1-context包)
    - [形式化定义](#形式化定义)
    - [Context 实现分析](#context-实现分析)
    - [Context 使用模式](#context-使用模式)
  - [1.2 sync包](#1-2-sync包)
    - [Mutex 形式化](#mutex-形式化)
    - [Mutex 实现分析](#mutex-实现分析)
    - [RWMutex 实现](#rwmutex-实现)
  - [1.3 io包](#1-3-io包)
    - [接口代数](#接口代数)
    - [核心接口](#核心接口)
  - [1.4 errors包](#1-4-errors包)
    - [错误系统形式化](#错误系统形式化)
    - [errors 包实现](#errors-包实现)
- [第二部分: 并发原语包](#第二部分-并发原语包)
  - [2.1 sync/atomic](#2-1-syncatomic)
    - [原子操作形式化](#原子操作形式化)
    - [atomic 包实现](#atomic-包实现)
  - [2.2 sync/singleflight](#2-2-syncsingleflight)
    - [形式化定义1](#形式化定义1)
    - [singleflight 实现](#singleflight-实现)
  - [2.3 sync/errgroup](#2-3-syncerrgroup)
    - [形式化定义2](#形式化定义2)
    - [errgroup 实现](#errgroup-实现)
- [第三部分: 网络与I/O包](#第三部分-网络与io包)
  - [3.1 net包](#3-1-net包)
    - [网络编程形式化](#网络编程形式化)
    - [net 包核心接口](#net-包核心接口)
  - [3.2 net/http包](#3-2-nethttp包)
    - [HTTP语义形式化](#http语义形式化)
    - [HTTP服务器实现](#http服务器实现)
  - [3.3 io/fs包](#3-3-iofs包)
    - [文件系统形式化](#文件系统形式化)
    - [io/fs 实现](#iofs-实现)
- [第四部分: 编码与序列化](#第四部分-编码与序列化)
  - [4.1 encoding/json](#4-1-encodingjson)
    - [JSON编解码形式化](#json编解码形式化)
    - [encoding/json 实现](#encodingjson-实现)
  - [4.2 encoding/xml](#4-2-encodingxml)
  - [4.3 encoding/gob](#4-3-encodinggob)
- [第五部分: 算法与数据结构](#第五部分-算法与数据结构)
  - [5.1 container包](#5-1-container包)
  - [5.2 sort包](#5-2-sort包)
  - [5.3 slices包 (Go 1.21+)](#5-3-slices包-go-1-21+)
  - [5.4 maps包 (Go 1.21+)](#5-4-maps包-go-1-21+)
- [🎯 总结](#总结)
  - [核心内容](#核心内容)
  - [设计哲学](#设计哲学)
  - [最佳实践](#最佳实践)

## 第一部分: 核心包分析

### 1.1 context包

Context 是 Go 并发编程的核心抽象，用于传递取消信号、截止时间和请求作用域的值。

#### 形式化定义

```mathematical
/* Context 接口形式化 */

Context = (deadline, done, err, value)

其中:
- deadline: Option[Time]  /* 截止时间 */
- done: <-chan struct{}   /* 完成信号 */
- err: Option[Error]      /* 错误原因 */
- value: Key → Value      /* 键值存储 */

/* Context 代数结构 */

/* 幺半群 (Monoid) 结构 */
⟨Context, ⊕, ε⟩

ε = Background()  /* 单位元 */
ctx₁ ⊕ ctx₂ = WithValue(ctx₁, k, v)  /* 组合操作 */

/* 满足幺半群律 */
1. 结合律: (ctx₁ ⊕ ctx₂) ⊕ ctx₃ = ctx₁ ⊕ (ctx₂ ⊕ ctx₃)
2. 单位律: ε ⊕ ctx = ctx ⊕ ε = ctx

/* 树状结构 */
Context Tree ::= 
  | Background
  | TODO
  | WithCancel(parent)
  | WithDeadline(parent, deadline)
  | WithTimeout(parent, duration)
  | WithValue(parent, key, value)

/* 取消传播规则 */
[Cancel-Propagation]
parent.cancel() → 所有 children.cancel()

/* 值查找规则 */
[Value-Lookup]
ctx.Value(k) = 
  if ctx has key k: return v
  else: return parent.Value(k)
```

#### Context 实现分析

```go
package context

// Context 接口
type Context interface {
    // Deadline 返回截止时间
    Deadline() (deadline time.Time, ok bool)
    
    // Done 返回一个channel，当context被取消时关闭
    Done() <-chan struct{}
    
    // Err 返回取消原因
    Err() error
    
    // Value 返回关联的值
    Value(key any) any
}

// emptyCtx: Background 和 TODO 的实现
type emptyCtx int

func (*emptyCtx) Deadline() (deadline time.Time, ok bool) {
    return
}

func (*emptyCtx) Done() <-chan struct{} {
    return nil
}

func (*emptyCtx) Err() error {
    return nil
}

func (*emptyCtx) Value(key any) any {
    return nil
}

var (
    background = new(emptyCtx)
    todo       = new(emptyCtx)
)

func Background() Context {
    return background
}

func TODO() Context {
    return todo
}

// cancelCtx: 可取消的context
type cancelCtx struct {
    Context  // 嵌入父context
    
    mu       sync.Mutex
    done     atomic.Value  // chan struct{}, 延迟创建
    children map[canceler]struct{}  // 子context集合
    err      error
}

func (c *cancelCtx) Done() <-chan struct{} {
    d := c.done.Load()
    if d != nil {
        return d.(chan struct{})
    }
    c.mu.Lock()
    defer c.mu.Unlock()
    d = c.done.Load()
    if d == nil {
        d = make(chan struct{})
        c.done.Store(d)
    }
    return d.(chan struct{})
}

func (c *cancelCtx) Err() error {
    c.mu.Lock()
    err := c.err
    c.mu.Unlock()
    return err
}

// cancel 取消context及其所有子context
func (c *cancelCtx) cancel(removeFromParent bool, err error) {
    if err == nil {
        panic("context: internal error: missing cancel error")
    }
    c.mu.Lock()
    if c.err != nil {
        c.mu.Unlock()
        return  // 已经被取消
    }
    c.err = err
    d, _ := c.done.Load().(chan struct{})
    if d == nil {
        c.done.Store(closedchan)
    } else {
        close(d)  // 关闭done channel，通知所有等待者
    }
    // 取消所有子context
    for child := range c.children {
        child.cancel(false, err)
    }
    c.children = nil
    c.mu.Unlock()
    
    if removeFromParent {
        removeChild(c.Context, c)
    }
}

// WithCancel 创建可取消的context
func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
    c := newCancelCtx(parent)
    propagateCancel(parent, &c)
    return &c, func() { c.cancel(true, Canceled) }
}

// WithTimeout 创建带超时的context
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {
    return WithDeadline(parent, time.Now().Add(timeout))
}

// WithDeadline 创建带截止时间的context
func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) {
    if cur, ok := parent.Deadline(); ok && cur.Before(d) {
        // 父context的截止时间更早，直接使用父context
        return WithCancel(parent)
    }
    c := &timerCtx{
        cancelCtx: newCancelCtx(parent),
        deadline:  d,
    }
    propagateCancel(parent, c)
    dur := time.Until(d)
    if dur <= 0 {
        c.cancel(true, DeadlineExceeded)  // 已经超时
        return c, func() { c.cancel(false, Canceled) }
    }
    c.mu.Lock()
    defer c.mu.Unlock()
    if c.err == nil {
        c.timer = time.AfterFunc(dur, func() {
            c.cancel(true, DeadlineExceeded)
        })
    }
    return c, func() { c.cancel(true, Canceled) }
}

// WithValue 创建带值的context
func WithValue(parent Context, key, val any) Context {
    if key == nil {
        panic("nil key")
    }
    return &valueCtx{parent, key, val}
}

type valueCtx struct {
    Context
    key, val any
}

func (c *valueCtx) Value(key any) any {
    if c.key == key {
        return c.val
    }
    return value(c.Context, key)
}
```

#### Context 使用模式

```go
// 模式1: 超时控制
func FetchWithTimeout(url string, timeout time.Duration) ([]byte, error) {
    ctx, cancel := context.WithTimeout(context.Background(), timeout)
    defer cancel()
    
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, err
    }
    
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    return io.ReadAll(resp.Body)
}

// 模式2: 取消传播
func ParallelWork(ctx context.Context, tasks []Task) error {
    g, ctx := errgroup.WithContext(ctx)
    
    for _, task := range tasks {
        task := task  // 捕获循环变量
        g.Go(func() error {
            return task.Run(ctx)  // 传播取消
        })
    }
    
    return g.Wait()
}

// 模式3: 值传递 (请求作用域)
type contextKey string

const (
    requestIDKey contextKey = "request-id"
    userIDKey    contextKey = "user-id"
)

func WithRequestID(ctx context.Context, id string) context.Context {
    return context.WithValue(ctx, requestIDKey, id)
}

func RequestIDFromContext(ctx context.Context) (string, bool) {
    id, ok := ctx.Value(requestIDKey).(string)
    return id, ok
}

// HTTP中间件示例
func RequestIDMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        id := generateID()
        ctx := WithRequestID(r.Context(), id)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}
```

### 1.2 sync包

sync 包提供了基本的同步原语。

#### Mutex 形式化

```mathematical
/* Mutex 形式化规范 */

Mutex = (state, sema)

State ::= Unlocked | Locked(holder: Goroutine)

/* 操作 */
Lock: Mutex → Mutex
Unlock: Mutex → Mutex

/* 规则 */

[Lock-Success]
m.state = Unlocked
──────────────────────
Lock(m) → m' where m'.state = Locked(current_g)

[Lock-Block]
m.state = Locked(g)    g ≠ current_g
─────────────────────────────────────
Lock(m) → block until m.state = Unlocked

[Unlock-Success]
m.state = Locked(g)    g = current_g
──────────────────────────────────────
Unlock(m) → m' where m'.state = Unlocked

[Unlock-Error]
m.state = Unlocked  ∨  m.holder ≠ current_g
─────────────────────────────────────────────
Unlock(m) → panic
```

#### Mutex 实现分析

```go
package sync

// Mutex 结构
type Mutex struct {
    state int32   // 状态字段
    sema  uint32  // 信号量
}

const (
    mutexLocked = 1 << iota  // 1: 已锁定
    mutexWoken               // 2: 有goroutine被唤醒
    mutexStarving            // 4: 饥饿模式
    mutexWaiterShift = iota  // 3: 等待者数量的位移
)

// Lock 加锁
func (m *Mutex) Lock() {
    // 快速路径: 尝试CAS获取锁
    if atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) {
        return
    }
    // 慢路径
    m.lockSlow()
}

func (m *Mutex) lockSlow() {
    var waitStartTime int64
    starving := false
    awoke := false
    iter := 0
    old := m.state
    
    for {
        // 正常模式下，如果锁被占用且不是饥饿模式，尝试自旋
        if old&(mutexLocked|mutexStarving) == mutexLocked && runtime_canSpin(iter) {
            // 尝试设置 mutexWoken 标志
            if !awoke && old&mutexWoken == 0 && old>>mutexWaiterShift != 0 &&
                atomic.CompareAndSwapInt32(&m.state, old, old|mutexWoken) {
                awoke = true
            }
            runtime_doSpin()
            iter++
            old = m.state
            continue
        }
        
        new := old
        // 如果不是饥饿模式，尝试获取锁
        if old&mutexStarving == 0 {
            new |= mutexLocked
        }
        // 如果锁被占用或处于饥饿模式，增加等待者计数
        if old&(mutexLocked|mutexStarving) != 0 {
            new += 1 << mutexWaiterShift
        }
        // 如果当前处于饥饿状态且锁被占用，切换到饥饿模式
        if starving && old&mutexLocked != 0 {
            new |= mutexStarving
        }
        if awoke {
            new &^= mutexWoken
        }
        
        if atomic.CompareAndSwapInt32(&m.state, old, new) {
            if old&(mutexLocked|mutexStarving) == 0 {
                break  // 获取锁成功
            }
            // 等待
            queueLifo := waitStartTime != 0
            if waitStartTime == 0 {
                waitStartTime = runtime_nanotime()
            }
            runtime_SemacquireMutex(&m.sema, queueLifo, 1)
            starving = starving || runtime_nanotime()-waitStartTime > starvationThresholdNs
            old = m.state
            if old&mutexStarving != 0 {
                // 在饥饿模式下被唤醒，直接获取锁
                delta := int32(mutexLocked - 1<<mutexWaiterShift)
                if !starving || old>>mutexWaiterShift == 1 {
                    delta -= mutexStarving
                }
                atomic.AddInt32(&m.state, delta)
                break
            }
            awoke = true
            iter = 0
        } else {
            old = m.state
        }
    }
}

// Unlock 解锁
func (m *Mutex) Unlock() {
    // 快速路径: 尝试直接解锁
    new := atomic.AddInt32(&m.state, -mutexLocked)
    if new != 0 {
        m.unlockSlow(new)
    }
}

func (m *Mutex) unlockSlow(new int32) {
    if (new+mutexLocked)&mutexLocked == 0 {
        panic("sync: unlock of unlocked mutex")
    }
    if new&mutexStarving == 0 {
        // 正常模式
        old := new
        for {
            // 如果没有等待者，或者已经有goroutine被唤醒，直接返回
            if old>>mutexWaiterShift == 0 || old&(mutexLocked|mutexWoken|mutexStarving) != 0 {
                return
            }
            // 唤醒一个等待者
            new = (old - 1<<mutexWaiterShift) | mutexWoken
            if atomic.CompareAndSwapInt32(&m.state, old, new) {
                runtime_Semrelease(&m.sema, false, 1)
                return
            }
            old = m.state
        }
    } else {
        // 饥饿模式: 直接唤醒第一个等待者
        runtime_Semrelease(&m.sema, true, 1)
    }
}
```

#### RWMutex 实现

```go
// RWMutex 读写锁
type RWMutex struct {
    w           Mutex  // 写锁
    writerSem   uint32 // 写者等待信号量
    readerSem   uint32 // 读者等待信号量
    readerCount int32  // 读者计数
    readerWait  int32  // 写者等待的读者数
}

const rwmutexMaxReaders = 1 << 30

// RLock 读锁
func (rw *RWMutex) RLock() {
    if atomic.AddInt32(&rw.readerCount, 1) < 0 {
        // 有写者等待，阻塞
        runtime_SemacquireMutex(&rw.readerSem, false, 0)
    }
}

// RUnlock 读解锁
func (rw *RWMutex) RUnlock() {
    if r := atomic.AddInt32(&rw.readerCount, -1); r < 0 {
        // 可能唤醒写者
        rw.rUnlockSlow(r)
    }
}

func (rw *RWMutex) rUnlockSlow(r int32) {
    if r+1 == 0 || r+1 == -rwmutexMaxReaders {
        panic("sync: RUnlock of unlocked RWMutex")
    }
    // 如果是最后一个读者，唤醒写者
    if atomic.AddInt32(&rw.readerWait, -1) == 0 {
        runtime_Semrelease(&rw.writerSem, false, 1)
    }
}

// Lock 写锁
func (rw *RWMutex) Lock() {
    // 获取互斥锁
    rw.w.Lock()
    // 通知读者有写者等待
    r := atomic.AddInt32(&rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders
    // 等待所有读者完成
    if r != 0 && atomic.AddInt32(&rw.readerWait, r) != 0 {
        runtime_SemacquireMutex(&rw.writerSem, false, 0)
    }
}

// Unlock 写解锁
func (rw *RWMutex) Unlock() {
    // 允许读者
    r := atomic.AddInt32(&rw.readerCount, rwmutexMaxReaders)
    if r >= rwmutexMaxReaders {
        panic("sync: Unlock of unlocked RWMutex")
    }
    // 唤醒所有等待的读者
    for i := 0; i < int(r); i++ {
        runtime_Semrelease(&rw.readerSem, false, 0)
    }
    // 释放写锁
    rw.w.Unlock()
}
```

### 1.3 io包

io 包定义了基本的 I/O 接口。

#### 接口代数

```mathematical
/* I/O 接口代数 */

Reader = Read: []byte → (int, error)
Writer = Write: []byte → (int, error)
Closer = Close: () → error

/* 组合接口 */
ReadWriter = Reader ⊗ Writer
ReadCloser = Reader ⊗ Closer
WriteCloser = Writer ⊗ Closer
ReadWriteCloser = Reader ⊗ Writer ⊗ Closer

/* 幺半群结构 */
MultiReader: [Reader] → Reader
MultiWriter: [Writer] → Writer

/* 范畴论视角 */
Category IO:
  Objects: 数据类型 ([]byte, string, etc.)
  Morphisms: I/O 操作 (Read, Write, etc.)
  
Functor Copy: Reader × Writer → (int64, error)
  将Reader的输出映射到Writer的输入
```

#### 核心接口

```go
package io

// Reader 读接口
type Reader interface {
    Read(p []byte) (n int, err error)
}

// Writer 写接口
type Writer interface {
    Write(p []byte) (n int, err error)
}

// Closer 关闭接口
type Closer interface {
    Close() error
}

// Seeker 定位接口
type Seeker interface {
    Seek(offset int64, whence int) (int64, error)
}

// 组合接口
type ReadWriter interface {
    Reader
    Writer
}

type ReadCloser interface {
    Reader
    Closer
}

type WriteCloser interface {
    Writer
    Closer
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}

type ReadSeeker interface {
    Reader
    Seeker
}

// Copy 核心函数
func Copy(dst Writer, src Reader) (written int64, err error) {
    return copyBuffer(dst, src, nil)
}

func copyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error) {
    // 优化: 如果src实现了WriterTo，使用它
    if wt, ok := src.(WriterTo); ok {
        return wt.WriteTo(dst)
    }
    // 优化: 如果dst实现了ReaderFrom，使用它
    if rt, ok := dst.(ReaderFrom); ok {
        return rt.ReadFrom(src)
    }
    if buf == nil {
        size := 32 * 1024
        if l, ok := src.(*LimitedReader); ok && int64(size) > l.N {
            if l.N < 1 {
                size = 1
            } else {
                size = int(l.N)
            }
        }
        buf = make([]byte, size)
    }
    for {
        nr, er := src.Read(buf)
        if nr > 0 {
            nw, ew := dst.Write(buf[0:nr])
            if nw < 0 || nr < nw {
                nw = 0
                if ew == nil {
                    ew = errInvalidWrite
                }
            }
            written += int64(nw)
            if ew != nil {
                err = ew
                break
            }
            if nr != nw {
                err = ErrShortWrite
                break
            }
        }
        if er != nil {
            if er != EOF {
                err = er
            }
            break
        }
    }
    return written, err
}

// Pipe 创建同步的内存管道
func Pipe() (*PipeReader, *PipeWriter) {
    p := &pipe{
        wrCh: make(chan []byte),
        rdCh: make(chan int),
        done: make(chan struct{}),
    }
    return &PipeReader{p}, &PipeWriter{p}
}

type pipe struct {
    wrCh chan []byte
    rdCh chan int
    done chan struct{}
    
    rerr error
    werr error
}

// PipeReader 实现
func (r *PipeReader) Read(data []byte) (n int, err error) {
    select {
    case <-r.done:
        return 0, r.readCloseError()
    default:
    }
    
    select {
    case bw := <-r.wrCh:
        nr := copy(data, bw)
        r.rdCh <- nr
        return nr, nil
    case <-r.done:
        return 0, r.readCloseError()
    }
}

// MultiReader 组合多个Reader
func MultiReader(readers ...Reader) Reader {
    r := make([]Reader, len(readers))
    copy(r, readers)
    return &multiReader{r}
}

type multiReader struct {
    readers []Reader
}

func (mr *multiReader) Read(p []byte) (n int, err error) {
    for len(mr.readers) > 0 {
        n, err = mr.readers[0].Read(p)
        if err == EOF {
            mr.readers = mr.readers[1:]
        }
        if n > 0 || err != EOF {
            if err == EOF && len(mr.readers) > 0 {
                err = nil
            }
            return
        }
    }
    return 0, EOF
}
```

### 1.4 errors包

Go 1.13+ 引入了错误包装和检查机制。

#### 错误系统形式化

```mathematical
/* 错误类型系统 */

Error ::= Simple(msg: String)
        | Wrapped(msg: String, cause: Error)
        | Multiple([Error])

/* 错误链 */
ErrorChain = Error₀ → Error₁ → ... → Errorₙ

/* 操作 */
Wrap: Error × String → Error
Unwrap: Error → Option[Error]
Is: Error × Error → Bool
As: Error × *T → Bool

/* Is 语义 */
Is(err, target) = 
  err == target ∨
  ∃e ∈ ErrorChain(err). e == target

/* As 语义 */
As(err, *target) =
  ∃e ∈ ErrorChain(err). TypeOf(e) == TypeOf(*target)
```

#### errors 包实现

```go
package errors

// New 创建简单错误
func New(text string) error {
    return &errorString{text}
}

type errorString struct {
    s string
}

func (e *errorString) Error() string {
    return e.s
}

// Unwrap 接口
type Unwrap interface {
    Unwrap() error
}

// Unwrap 函数
func Unwrap(err error) error {
    u, ok := err.(interface {
        Unwrap() error
    })
    if !ok {
        return nil
    }
    return u.Unwrap()
}

// Is 检查错误链中是否包含target
func Is(err, target error) bool {
    if target == nil {
        return err == target
    }
    
    isComparable := reflectlite.TypeOf(target).Comparable()
    for {
        if isComparable && err == target {
            return true
        }
        if x, ok := err.(interface{ Is(error) bool }); ok && x.Is(target) {
            return true
        }
        if err = Unwrap(err); err == nil {
            return false
        }
    }
}

// As 检查错误链中是否有类型匹配target的错误
func As(err error, target any) bool {
    if target == nil {
        panic("errors: target cannot be nil")
    }
    val := reflectlite.ValueOf(target)
    typ := val.Type()
    if typ.Kind() != reflectlite.Ptr || val.IsNil() {
        panic("errors: target must be a non-nil pointer")
    }
    targetType := typ.Elem()
    if targetType.Kind() != reflectlite.Interface && !targetType.Implements(errorType) {
        panic("errors: *target must be interface or implement error")
    }
    for err != nil {
        if reflectlite.TypeOf(err).AssignableTo(targetType) {
            val.Elem().Set(reflectlite.ValueOf(err))
            return true
        }
        if x, ok := err.(interface{ As(any) bool }); ok && x.As(target) {
            return true
        }
        err = Unwrap(err)
    }
    return false
}

// Join 组合多个错误 (Go 1.20+)
func Join(errs ...error) error {
    n := 0
    for _, err := range errs {
        if err != nil {
            n++
        }
    }
    if n == 0 {
        return nil
    }
    e := &joinError{
        errs: make([]error, 0, n),
    }
    for _, err := range errs {
        if err != nil {
            e.errs = append(e.errs, err)
        }
    }
    return e
}

type joinError struct {
    errs []error
}

func (e *joinError) Error() string {
    var b []byte
    for i, err := range e.errs {
        if i > 0 {
            b = append(b, '\n')
        }
        b = append(b, err.Error()...)
    }
    return string(b)
}

func (e *joinError) Unwrap() []error {
    return e.errs
}

// 使用示例
func ExampleErrors() error {
    // 创建基础错误
    baseErr := errors.New("base error")
    
    // 包装错误
    wrappedErr := fmt.Errorf("operation failed: %w", baseErr)
    
    // 检查错误
    if errors.Is(wrappedErr, baseErr) {
        fmt.Println("Contains base error")
    }
    
    // 类型断言
    var pathErr *os.PathError
    if errors.As(wrappedErr, &pathErr) {
        fmt.Println("Path:", pathErr.Path)
    }
    
    // 组合多个错误
    err1 := errors.New("error 1")
    err2 := errors.New("error 2")
    combined := errors.Join(err1, err2)
    
    return combined
}
```

---

## 第二部分: 并发原语包

### 2.1 sync/atomic

atomic 包提供了底层的原子操作。

#### 原子操作形式化

```mathematical
/* 原子操作语义 */

/* Load/Store */
Load: *T → T  (原子读)
Store: *T × T → ()  (原子写)

/* Add/Swap */
Add: *T × Δ → T  (原子加法，返回新值)
Swap: *T × T → T  (原子交换，返回旧值)

/* Compare-And-Swap */
CAS: *T × old × new → Bool
CAS(addr, old, new) = 
  if *addr == old:
    *addr = new
    return true
  else:
    return false

/* 内存顺序保证 */
1. Load: Acquire barrier
2. Store: Release barrier
3. Swap/Add: Full barrier
4. CAS: Full barrier

/* 形式化规则 */

[Atomic-Load]
执行时原子地读取内存位置的值
───────────────────────────────
v = Load(addr) 
v 是一个一致的快照

[Atomic-Store]
执行时原子地写入内存位置
────────────────────────────
Store(addr, v)
写入对其他goroutine立即可见

[Atomic-CAS]
Compare-And-Swap 原子地执行比较和交换
──────────────────────────────────────
success = CAS(addr, old, new)
如果成功，*addr == new
如果失败，*addr 未改变
```

#### atomic 包实现

```go
package atomic

// Value 提供原子操作的容器
type Value struct {
    v any
}

// Load 原子加载
func (v *Value) Load() (val any) {
    vp := (*ifaceWords)(unsafe.Pointer(v))
    typ := LoadPointer(&vp.typ)
    if typ == nil || typ == unsafe.Pointer(&firstStoreInProgress) {
        return nil
    }
    data := LoadPointer(&vp.data)
    vlp := (*ifaceWords)(unsafe.Pointer(&val))
    vlp.typ = typ
    vlp.data = data
    return
}

// Store 原子存储
func (v *Value) Store(val any) {
    if val == nil {
        panic("sync/atomic: store of nil value into Value")
    }
    vp := (*ifaceWords)(unsafe.Pointer(v))
    vlp := (*ifaceWords)(unsafe.Pointer(&val))
    for {
        typ := LoadPointer(&vp.typ)
        if typ == nil {
            // 第一次存储
            runtime_procPin()
            if !CompareAndSwapPointer(&vp.typ, nil, unsafe.Pointer(&firstStoreInProgress)) {
                runtime_procUnpin()
                continue
            }
            StorePointer(&vp.data, vlp.data)
            StorePointer(&vp.typ, vlp.typ)
            runtime_procUnpin()
            return
        }
        if typ == unsafe.Pointer(&firstStoreInProgress) {
            // 其他goroutine正在存储
            continue
        }
        // 类型必须匹配
        if typ != vlp.typ {
            panic("sync/atomic: store of inconsistently typed value into Value")
        }
        StorePointer(&vp.data, vlp.data)
        return
    }
}

// Swap 原子交换
func (v *Value) Swap(new any) (old any) {
    if new == nil {
        panic("sync/atomic: swap of nil value into Value")
    }
    vp := (*ifaceWords)(unsafe.Pointer(v))
    np := (*ifaceWords)(unsafe.Pointer(&new))
    for {
        typ := LoadPointer(&vp.typ)
        if typ == nil || typ == unsafe.Pointer(&firstStoreInProgress) {
            runtime_procPin()
            if !CompareAndSwapPointer(&vp.typ, typ, unsafe.Pointer(&firstStoreInProgress)) {
                runtime_procUnpin()
                continue
            }
            if typ != nil {
                op := (*ifaceWords)(unsafe.Pointer(&old))
                op.typ = typ
                op.data = LoadPointer(&vp.data)
            }
            StorePointer(&vp.data, np.data)
            StorePointer(&vp.typ, np.typ)
            runtime_procUnpin()
            return
        }
        if typ != np.typ {
            panic("sync/atomic: swap of inconsistently typed value into Value")
        }
        op := (*ifaceWords)(unsafe.Pointer(&old))
        op.typ = typ
        op.data = SwapPointer(&vp.data, np.data)
        return
    }
}

// CompareAndSwap 原子比较并交换
func (v *Value) CompareAndSwap(old, new any) (swapped bool) {
    if new == nil {
        panic("sync/atomic: compare and swap of nil value into Value")
    }
    vp := (*ifaceWords)(unsafe.Pointer(v))
    np := (*ifaceWords)(unsafe.Pointer(&new))
    op := (*ifaceWords)(unsafe.Pointer(&old))
    if op.typ != nil && np.typ != op.typ {
        return false
    }
    for {
        typ := LoadPointer(&vp.typ)
        if typ == nil || typ == unsafe.Pointer(&firstStoreInProgress) {
            if old != nil {
                return false
            }
            runtime_procPin()
            if !CompareAndSwapPointer(&vp.typ, typ, unsafe.Pointer(&firstStoreInProgress)) {
                runtime_procUnpin()
                continue
            }
            StorePointer(&vp.data, np.data)
            StorePointer(&vp.typ, np.typ)
            runtime_procUnpin()
            return true
        }
        if typ != np.typ {
            return false
        }
        data := LoadPointer(&vp.data)
        if op.typ != nil && data != op.data {
            return false
        }
        if CompareAndSwapPointer(&vp.data, data, np.data) {
            return true
        }
    }
}

// Int32/Int64/Uint32/Uint64 等类型的原子操作
type Int32 struct {
    _ noCopy
    v int32
}

func (x *Int32) Load() int32 {
    return LoadInt32(&x.v)
}

func (x *Int32) Store(val int32) {
    StoreInt32(&x.v, val)
}

func (x *Int32) Swap(new int32) (old int32) {
    return SwapInt32(&x.v, new)
}

func (x *Int32) CompareAndSwap(old, new int32) (swapped bool) {
    return CompareAndSwapInt32(&x.v, old, new)
}

func (x *Int32) Add(delta int32) (new int32) {
    return AddInt32(&x.v, delta)
}
```

### 2.2 sync/singleflight

singleflight 包用于抑制重复的函数调用，适用于缓存场景。

#### 形式化定义1

```mathematical
/* Singleflight 语义 */

Group = Map[Key, *call]

call = (wg: WaitGroup, val: any, err: error)

/* 操作 */
Do: Group × Key × (func() (any, error)) → (any, error, bool)

/* 规则 */

[First-Call]
key ∉ Group
────────────────────────────────
Do(g, key, fn) = 
  1. 创建 call c
  2. Group[key] = c
  3. val, err = fn()
  4. c.val = val, c.err = err
  5. delete(Group, key)
  6. return (val, err, false)

[Duplicate-Call]
key ∈ Group    c = Group[key]
──────────────────────────────
Do(g, key, fn) =
  1. 等待 c.wg
  2. return (c.val, c.err, true)  /* shared=true */
```

#### singleflight 实现

```go
package singleflight

import (
    "bytes"
    "fmt"
    "runtime"
    "sync"
)

// Group 代表一个工作类
type Group struct {
    mu sync.Mutex
    m  map[string]*call
}

// call 代表一个正在进行或已完成的Do调用
type call struct {
    wg sync.WaitGroup
    
    val any
    err error
    
    dups  int  // 重复调用次数
    chans []chan<- Result
}

// Result 保存Do的结果
type Result struct {
    Val    any
    Err    error
    Shared bool  // 是否是共享结果
}

// Do 执行并返回给定函数的结果，确保同时只有一个执行
func (g *Group) Do(key string, fn func() (any, error)) (v any, err error, shared bool) {
    g.mu.Lock()
    if g.m == nil {
        g.m = make(map[string]*call)
    }
    if c, ok := g.m[key]; ok {
        c.dups++
        g.mu.Unlock()
        c.wg.Wait()  // 等待第一个调用完成
        return c.val, c.err, true
    }
    c := new(call)
    c.wg.Add(1)
    g.m[key] = c
    g.mu.Unlock()
    
    g.doCall(c, key, fn)
    return c.val, c.err, c.dups > 0
}

// DoChan 类似Do，但返回一个channel
func (g *Group) DoChan(key string, fn func() (any, error)) <-chan Result {
    ch := make(chan Result, 1)
    g.mu.Lock()
    if g.m == nil {
        g.m = make(map[string]*call)
    }
    if c, ok := g.m[key]; ok {
        c.dups++
        c.chans = append(c.chans, ch)
        g.mu.Unlock()
        return ch
    }
    c := &call{chans: []chan<- Result{ch}}
    c.wg.Add(1)
    g.m[key] = c
    g.mu.Unlock()
    
    go g.doCall(c, key, fn)
    
    return ch
}

// doCall 执行实际的调用
func (g *Group) doCall(c *call, key string, fn func() (any, error)) {
    c.val, c.err = fn()
    c.wg.Done()
    
    g.mu.Lock()
    delete(g.m, key)
    for _, ch := range c.chans {
        ch <- Result{c.val, c.err, c.dups > 0}
    }
    g.mu.Unlock()
}

// Forget 告诉Group忘记一个key
func (g *Group) Forget(key string) {
    g.mu.Lock()
    delete(g.m, key)
    g.mu.Unlock()
}

// 使用示例
type Cache struct {
    g     singleflight.Group
    cache map[string]string
    mu    sync.RWMutex
}

func (c *Cache) Get(key string) (string, error) {
    // 先查缓存
    c.mu.RLock()
    val, ok := c.cache[key]
    c.mu.RUnlock()
    if ok {
        return val, nil
    }
    
    // 使用singleflight避免缓存击穿
    v, err, shared := c.g.Do(key, func() (any, error) {
        // 从数据库加载
        val, err := loadFromDB(key)
        if err != nil {
            return "", err
        }
        // 更新缓存
        c.mu.Lock()
        c.cache[key] = val
        c.mu.Unlock()
        return val, nil
    })
    
    if err != nil {
        return "", err
    }
    return v.(string), nil
}
```

### 2.3 sync/errgroup

errgroup 包提供了goroutine的同步、错误传播和上下文取消。

#### 形式化定义2

```mathematical
/* Errgroup 语义 */

Group = (wg: WaitGroup, ctx: Context, cancel: CancelFunc, err: error)

/* 操作 */
Go: Group × (func() error) → ()
Wait: Group → error

/* 规则 */

[Go-Submit]
────────────────────────
g.Go(f) = 
  1. wg.Add(1)
  2. 启动 goroutine:
       err := f()
       if err ≠ nil:
         保存第一个错误
         cancel()
       wg.Done()

[Wait-Return]
────────────────────
g.Wait() =
  1. wg.Wait()
  2. return 第一个错误
```

#### errgroup 实现

```go
package errgroup

import (
    "context"
    "sync"
)

// Group 是一组goroutines的集合
type Group struct {
    cancel func()
    
    wg sync.WaitGroup
    
    errOnce sync.Once
    err     error
}

// WithContext 返回一个新的Group和关联的Context
func WithContext(ctx context.Context) (*Group, context.Context) {
    ctx, cancel := context.WithCancel(ctx)
    return &Group{cancel: cancel}, ctx
}

// Wait 等待所有goroutines完成，返回第一个错误
func (g *Group) Wait() error {
    g.wg.Wait()
    if g.cancel != nil {
        g.cancel()
    }
    return g.err
}

// Go 启动一个goroutine
func (g *Group) Go(f func() error) {
    g.wg.Add(1)
    
    go func() {
        defer g.wg.Done()
        
        if err := f(); err != nil {
            g.errOnce.Do(func() {
                g.err = err
                if g.cancel != nil {
                    g.cancel()  // 取消其他goroutines
                }
            })
        }
    }()
}

// SetLimit 限制并发goroutine数量 (Go 1.20+)
func (g *Group) SetLimit(n int) {
    // 实现省略
}

// 使用示例
func FetchURLs(ctx context.Context, urls []string) ([]string, error) {
    g, ctx := errgroup.WithContext(ctx)
    results := make([]string, len(urls))
    
    for i, url := range urls {
        i, url := i, url  // 捕获循环变量
        g.Go(func() error {
            resp, err := fetchURL(ctx, url)
            if err != nil {
                return err
            }
            results[i] = resp
            return nil
        })
    }
    
    if err := g.Wait(); err != nil {
        return nil, err
    }
    return results, nil
}
```

---

## 第三部分: 网络与I/O包

### 3.1 net包

net 包提供了跨平台的网络I/O接口。

#### 网络编程形式化

```mathematical
/* 网络连接抽象 */

Conn = (Read, Write, Close, LocalAddr, RemoteAddr)

/* 监听器抽象 */
Listener = (Accept, Close, Addr)

/* TCP连接建立 */
[TCP-Dial]
addr: Address
──────────────────────
Dial("tcp", addr) → (Conn, error)

[TCP-Listen]
addr: Address
────────────────────────
Listen("tcp", addr) → (Listener, error)

[TCP-Accept]
ln: Listener
────────────────────────
ln.Accept() → (Conn, error)
```

#### net 包核心接口

```go
package net

// Conn 接口定义了通用的网络连接
type Conn interface {
    Read(b []byte) (n int, err error)
    Write(b []byte) (n int, err error)
    Close() error
    LocalAddr() Addr
    RemoteAddr() Addr
    SetDeadline(t time.Time) error
    SetReadDeadline(t time.Time) error
    SetWriteDeadline(t time.Time) error
}

// Listener 监听器接口
type Listener interface {
    Accept() (Conn, error)
    Close() error
    Addr() Addr
}

// TCP服务器示例
func TCPServer(addr string) error {
    ln, err := net.Listen("tcp", addr)
    if err != nil {
        return err
    }
    defer ln.Close()
    
    for {
        conn, err := ln.Accept()
        if err != nil {
            return err
        }
        go handleConnection(conn)
    }
}

func handleConnection(conn net.Conn) {
    defer conn.Close()
    
    // 设置超时
    conn.SetDeadline(time.Now().Add(30 * time.Second))
    
    buf := make([]byte, 1024)
    for {
        n, err := conn.Read(buf)
        if err != nil {
            if err != io.EOF {
                log.Printf("Read error: %v", err)
            }
            return
        }
        
        _, err = conn.Write(buf[:n])
        if err != nil {
            log.Printf("Write error: %v", err)
            return
        }
    }
}

// TCP客户端示例
func TCPClient(addr string, data []byte) error {
    conn, err := net.Dial("tcp", addr)
    if err != nil {
        return err
    }
    defer conn.Close()
    
    _, err = conn.Write(data)
    if err != nil {
        return err
    }
    
    reply := make([]byte, 1024)
    n, err := conn.Read(reply)
    if err != nil {
        return err
    }
    
    fmt.Printf("Reply: %s\n", reply[:n])
    return nil
}
```

### 3.2 net/http包

net/http 包提供了HTTP客户端和服务器实现。

#### HTTP语义形式化

```mathematical
/* HTTP请求-响应模型 */

Request = (Method, URL, Headers, Body)
Response = (StatusCode, Headers, Body)

/* Handler 接口 */
Handler = Request → Response

/* 中间件模式 */
Middleware = Handler → Handler

/* 组合律 */
middleware₁ ∘ middleware₂ ∘ handler
= middleware₁(middleware₂(handler))
```

#### HTTP服务器实现

```go
package http

// Handler 接口
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}

// HandlerFunc 函数适配器
type HandlerFunc func(ResponseWriter, *Request)

func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)
}

// HTTP服务器示例
func main() {
    // 方法1: 使用HandleFunc
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Hello, World!")
    })
    
    // 方法2: 使用Handler
    http.Handle("/api/", apiHandler())
    
    // 启动服务器
    log.Fatal(http.ListenAndServe(":8080", nil))
}

// 自定义Handler
type APIHandler struct {
    db *sql.DB
}

func (h *APIHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    switch r.URL.Path {
    case "/api/users":
        h.handleUsers(w, r)
    case "/api/posts":
        h.handlePosts(w, r)
    default:
        http.NotFound(w, r)
    }
}

// 中间件模式
func loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        next.ServeHTTP(w, r)
        log.Printf("%s %s %v", r.Method, r.URL.Path, time.Since(start))
    })
}

func authMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        token := r.Header.Get("Authorization")
        if !validateToken(token) {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        next.ServeHTTP(w, r)
    })
}

// 组合中间件
func chainMiddleware(h http.Handler, middlewares ...func(http.Handler) http.Handler) http.Handler {
    for i := len(middlewares) - 1; i >= 0; i-- {
        h = middlewares[i](h)
    }
    return h
}

// HTTP客户端示例
func HTTPClient() error {
    client := &http.Client{
        Timeout: 10 * time.Second,
    }
    
    req, err := http.NewRequest("GET", "https://api.example.com/data", nil)
    if err != nil {
        return err
    }
    
    req.Header.Set("Authorization", "Bearer token")
    req.Header.Set("Content-Type", "application/json")
    
    resp, err := client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("unexpected status: %d", resp.StatusCode)
    }
    
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return err
    }
    
    fmt.Printf("Response: %s\n", body)
    return nil
}
```

### 3.3 io/fs包

io/fs 包定义了文件系统的基本接口（Go 1.16+）。

#### 文件系统形式化

```mathematical
/* 文件系统抽象 */

FS = Open: Path → (File, error)

File = (Read, Stat, Close)

FileInfo = (Name, Size, Mode, ModTime, IsDir)

/* 操作规则 */

[Open-File]
path: Path    fs: FS
────────────────────────
fs.Open(path) → (File, nil)  if exists
fs.Open(path) → (nil, ErrNotExist)  if not exists

[Read-Dir]
path: Path    fs: FS    path is directory
────────────────────────────────────────
ReadDir(fs, path) → ([]DirEntry, nil)
```

#### io/fs 实现

```go
package fs

// FS 接口定义了文件系统
type FS interface {
    Open(name string) (File, error)
}

// File 接口定义了文件
type File interface {
    Stat() (FileInfo, error)
    Read([]byte) (int, error)
    Close() error
}

// FileInfo 描述文件信息
type FileInfo interface {
    Name() string
    Size() int64
    Mode() FileMode
    ModTime() time.Time
    IsDir() bool
    Sys() any
}

// ReadDir 读取目录
func ReadDir(fsys FS, name string) ([]DirEntry, error) {
    // 实现省略
}

// WalkDir 遍历目录树
func WalkDir(fsys FS, root string, fn WalkDirFunc) error {
    // 实现省略
}

// 使用示例: embed文件系统
//go:embed static/*
var staticFiles embed.FS

func ServeStatic() {
    http.Handle("/static/", http.FileServer(http.FS(staticFiles)))
    http.ListenAndServe(":8080", nil)
}

// 自定义文件系统
type MemFS struct {
    files map[string][]byte
}

func (m *MemFS) Open(name string) (fs.File, error) {
    data, ok := m.files[name]
    if !ok {
        return nil, fs.ErrNotExist
    }
    return &memFile{
        name: name,
        data: data,
    }, nil
}

type memFile struct {
    name string
    data []byte
    off  int
}

func (f *memFile) Read(b []byte) (int, error) {
    if f.off >= len(f.data) {
        return 0, io.EOF
    }
    n := copy(b, f.data[f.off:])
    f.off += n
    return n, nil
}
```

---

## 第四部分: 编码与序列化

### 4.1 encoding/json

JSON 编码和解码。

#### JSON编解码形式化

```mathematical
/* JSON类型系统 */

JSON ::= Null
       | Bool
       | Number
       | String
       | Array[JSON]
       | Object[String → JSON]

/* 编解码操作 */
Marshal: Go Value → JSON bytes
Unmarshal: JSON bytes → Go Value

/* 映射规则 */
Go Type        → JSON Type
────────────────────────────
bool           → Boolean
int/float      → Number
string         → String
[]T            → Array
map[string]T   → Object
struct         → Object
pointer        → value or null
interface{}    → any JSON type
```

#### encoding/json 实现

```go
package json

// Marshal 将Go值编码为JSON
func Marshal(v any) ([]byte, error) {
    e := newEncodeState()
    defer encodeStatePool.Put(e)
    
    err := e.marshal(v, encOpts{})
    if err != nil {
        return nil, err
    }
    buf := append([]byte(nil), e.Bytes()...)
    return buf, nil
}

// Unmarshal 将JSON解码为Go值
func Unmarshal(data []byte, v any) error {
    var d decodeState
    d.init(data)
    return d.unmarshal(v)
}

// Encoder 流式编码器
type Encoder struct {
    w   io.Writer
    err error
}

func NewEncoder(w io.Writer) *Encoder {
    return &Encoder{w: w}
}

func (enc *Encoder) Encode(v any) error {
    if enc.err != nil {
        return enc.err
    }
    e := newEncodeState()
    defer encodeStatePool.Put(e)
    
    err := e.marshal(v, encOpts{})
    if err != nil {
        return err
    }
    
    e.WriteByte('\n')
    _, err = enc.w.Write(e.Bytes())
    return err
}

// Decoder 流式解码器
type Decoder struct {
    r   io.Reader
    buf []byte
}

func NewDecoder(r io.Reader) *Decoder {
    return &Decoder{r: r}
}

func (dec *Decoder) Decode(v any) error {
    // 实现省略
}

// 使用示例
type User struct {
    ID        int       `json:"id"`
    Name      string    `json:"name"`
    Email     string    `json:"email,omitempty"`
    CreatedAt time.Time `json:"created_at"`
}

func ExampleJSON() {
    // 编码
    user := User{
        ID:        1,
        Name:      "Alice",
        Email:     "alice@example.com",
        CreatedAt: time.Now(),
    }
    
    data, err := json.Marshal(user)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("JSON: %s\n", data)
    
    // 解码
    var decoded User
    err = json.Unmarshal(data, &decoded)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("User: %+v\n", decoded)
    
    // 流式编码
    file, _ := os.Create("users.json")
    defer file.Close()
    encoder := json.NewEncoder(file)
    encoder.Encode(user)
}
```

### 4.2 encoding/xml

XML 编码和解码。

```go
package xml

// Marshal 将Go值编码为XML
func Marshal(v any) ([]byte, error) {
    var b bytes.Buffer
    if err := NewEncoder(&b).Encode(v); err != nil {
        return nil, err
    }
    return b.Bytes(), nil
}

// Unmarshal 将XML解码为Go值
func Unmarshal(data []byte, v any) error {
    return NewDecoder(bytes.NewReader(data)).Decode(v)
}

// 使用示例
type Book struct {
    XMLName xml.Name `xml:"book"`
    ID      int      `xml:"id,attr"`
    Title   string   `xml:"title"`
    Author  string   `xml:"author"`
    Price   float64  `xml:"price"`
}

func ExampleXML() {
    book := Book{
        ID:     1,
        Title:  "Go Programming",
        Author: "John Doe",
        Price:  29.99,
    }
    
    data, _ := xml.MarshalIndent(book, "", "  ")
    fmt.Printf("XML:\n%s\n", data)
    
    var decoded Book
    xml.Unmarshal(data, &decoded)
    fmt.Printf("Book: %+v\n", decoded)
}
```

### 4.3 encoding/gob

Go 专用的二进制编码格式。

```go
package gob

// Encoder 编码器
type Encoder struct {
    w io.Writer
}

func NewEncoder(w io.Writer) *Encoder {
    return &Encoder{w: w}
}

func (enc *Encoder) Encode(e any) error {
    // 实现省略
}

// Decoder 解码器
type Decoder struct {
    r io.Reader
}

func NewDecoder(r io.Reader) *Decoder {
    return &Decoder{r: r}
}

func (dec *Decoder) Decode(e any) error {
    // 实现省略
}

// 使用示例: RPC通信
func ExampleGob() {
    var network bytes.Buffer
    
    // 编码
    enc := gob.NewEncoder(&network)
    data := map[string]int{"one": 1, "two": 2, "three": 3}
    enc.Encode(data)
    
    // 解码
    dec := gob.NewDecoder(&network)
    var decoded map[string]int
    dec.Decode(&decoded)
    fmt.Printf("Decoded: %v\n", decoded)
}
```

---

## 第五部分: 算法与数据结构

### 5.1 container包

container 包提供了heap、list、ring三种数据结构。

```go
package container

// heap.Interface
type Interface interface {
    sort.Interface
    Push(x any)
    Pop() any
}

// 优先队列示例
type PriorityQueue []*Item

type Item struct {
    value    string
    priority int
    index    int
}

func (pq PriorityQueue) Len() int { return len(pq) }

func (pq PriorityQueue) Less(i, j int) bool {
    return pq[i].priority > pq[j].priority
}

func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
    pq[i].index = i
    pq[j].index = j
}

func (pq *PriorityQueue) Push(x any) {
    n := len(*pq)
    item := x.(*Item)
    item.index = n
    *pq = append(*pq, item)
}

func (pq *PriorityQueue) Pop() any {
    old := *pq
    n := len(old)
    item := old[n-1]
    old[n-1] = nil
    item.index = -1
    *pq = old[0 : n-1]
    return item
}

// 链表示例 (list.List)
func ExampleList() {
    l := list.New()
    l.PushBack(1)
    l.PushBack(2)
    l.PushFront(0)
    
    for e := l.Front(); e != nil; e = e.Next() {
        fmt.Println(e.Value)
    }
}
```

### 5.2 sort包

排序算法。

```go
package sort

// Sort 对data进行排序
func Sort(data Interface) {
    n := data.Len()
    quickSort(data, 0, n, maxDepth(n))
}

// Interface 排序接口
type Interface interface {
    Len() int
    Less(i, j int) bool
    Swap(i, j int)
}

// 便捷函数
func Ints(x []int) { Sort(IntSlice(x)) }
func Float64s(x []float64) { Sort(Float64Slice(x)) }
func Strings(x []string) { Sort(StringSlice(x)) }

// Slice 对切片排序 (Go 1.8+)
func Slice(x any, less func(i, j int) bool) {
    // 实现省略
}

// 使用示例
func ExampleSort() {
    // 排序整数
    ints := []int{3, 1, 4, 1, 5, 9, 2, 6}
    sort.Ints(ints)
    fmt.Println(ints)
    
    // 自定义排序
    type Person struct {
        Name string
        Age  int
    }
    
    people := []Person{
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 35},
    }
    
    sort.Slice(people, func(i, j int) bool {
        return people[i].Age < people[j].Age
    })
}
```

### 5.3 slices包 (Go 1.21+)

泛型切片操作。

```go
package slices

// BinarySearch 二分查找
func BinarySearch[S ~[]E, E cmp.Ordered](x S, target E) (int, bool) {
    // 实现省略
}

// Clone 克隆切片
func Clone[S ~[]E, E any](s S) S {
    return append(S([]E{}), s...)
}

// Compact 压缩连续重复元素
func Compact[S ~[]E, E comparable](s S) S {
    // 实现省略
}

// Contains 检查是否包含元素
func Contains[S ~[]E, E comparable](s S, v E) bool {
    return Index(s, v) >= 0
}

// Delete 删除元素
func Delete[S ~[]E, E any](s S, i, j int) S {
    return append(s[:i], s[j:]...)
}

// Equal 比较两个切片
func Equal[S ~[]E, E comparable](s1, s2 S) bool {
    if len(s1) != len(s2) {
        return false
    }
    for i := range s1 {
        if s1[i] != s2[i] {
            return false
        }
    }
    return true
}

// Index 查找元素索引
func Index[S ~[]E, E comparable](s S, v E) int {
    for i := range s {
        if s[i] == v {
            return i
        }
    }
    return -1
}

// 使用示例
func ExampleSlices() {
    s := []int{1, 2, 3, 4, 5}
    
    // 查找
    if slices.Contains(s, 3) {
        fmt.Println("Found 3")
    }
    
    // 删除
    s = slices.Delete(s, 1, 3)  // [1, 4, 5]
    
    // 克隆
    s2 := slices.Clone(s)
    
    // 比较
    if slices.Equal(s, s2) {
        fmt.Println("Equal")
    }
}
```

### 5.4 maps包 (Go 1.21+)

泛型map操作。

```go
package maps

// Clone 克隆map
func Clone[M ~map[K]V, K comparable, V any](m M) M {
    r := make(M, len(m))
    for k, v := range m {
        r[k] = v
    }
    return r
}

// Copy 复制map
func Copy[M ~map[K]V, K comparable, V any](dst, src M) {
    for k, v := range src {
        dst[k] = v
    }
}

// DeleteFunc 条件删除
func DeleteFunc[M ~map[K]V, K comparable, V any](m M, del func(K, V) bool) {
    for k, v := range m {
        if del(k, v) {
            delete(m, k)
        }
    }
}

// Equal 比较两个map
func Equal[M ~map[K]V, K, V comparable](m1, m2 M) bool {
    if len(m1) != len(m2) {
        return false
    }
    for k, v1 := range m1 {
        if v2, ok := m2[k]; !ok || v1 != v2 {
            return false
        }
    }
    return true
}

// 使用示例
func ExampleMaps() {
    m1 := map[string]int{"a": 1, "b": 2, "c": 3}
    
    // 克隆
    m2 := maps.Clone(m1)
    
    // 比较
    if maps.Equal(m1, m2) {
        fmt.Println("Equal")
    }
    
    // 条件删除
    maps.DeleteFunc(m1, func(k string, v int) bool {
        return v < 2
    })
}
```

---

## 🎯 总结

### 核心内容

1. **Context包**: 取消传播、超时控制、值传递
2. **Sync包**: Mutex、RWMutex、WaitGroup、Once等同步原语
3. **I/O包**: Reader/Writer接口、Pipe、Copy等核心功能
4. **Errors包**: 错误包装、检查、组合机制
5. **Atomic包**: 原子操作、内存顺序保证

### 设计哲学

- **接口抽象**: 小接口组合成大接口
- **正交性**: 功能独立，可自由组合
- **简洁性**: 最小化API表面积
- **性能**: 零成本抽象

### 最佳实践

1. 使用 Context 传递取消信号和截止时间
2. 选择合适的同步原语（Mutex vs Channel）
3. 利用 io.Reader/Writer 接口的组合性
4. 正确处理错误链

---

**文档版本**: v1.0.0  
**适用Go版本**: 1.25.3  
**最后更新**: 2025-10-29  
**维护团队**: Go Standard Library Team
