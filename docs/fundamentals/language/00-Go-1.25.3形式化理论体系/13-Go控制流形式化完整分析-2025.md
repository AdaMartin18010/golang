# Go æ§åˆ¶æµå½¢å¼åŒ–å®Œæ•´åˆ†æ

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**åŸºå‡†æ—¥æœŸ**: 2025å¹´10æœˆ23æ—¥  
**Goç‰ˆæœ¬**: Go 1.25.3  
**ç†è®ºåŸºç¡€**: Control Flow Graph + SSA + Data Flow Analysis + Abstract Interpretation  
**å­—æ•°**: ~30,000å­—

---

## ğŸ“‹ ç›®å½•


- [ç¬¬ä¸€éƒ¨åˆ†: æ§åˆ¶æµå›¾ç†è®º](#ç¬¬ä¸€éƒ¨åˆ†-æ§åˆ¶æµå›¾ç†è®º)
  - [1.1 åŸºæœ¬å—ä¸æ§åˆ¶æµå›¾](#11-åŸºæœ¬å—ä¸æ§åˆ¶æµå›¾)
    - [åŸºæœ¬å—å®šä¹‰](#åŸºæœ¬å—å®šä¹‰)
    - [æ§åˆ¶æµå›¾æ„é€ ](#æ§åˆ¶æµå›¾æ„é€ )
    - [Goè¯­å¥CFGç¤ºä¾‹](#goè¯­å¥cfgç¤ºä¾‹)
  - [1.2 æ”¯é…å…³ç³»](#12-æ”¯é…å…³ç³»)
    - [æ”¯é…å…³ç³»å®šä¹‰](#æ”¯é…å…³ç³»å®šä¹‰)
    - [æ”¯é…æ ‘æ„é€ ç®—æ³•](#æ”¯é…æ ‘æ„é€ ç®—æ³•)
    - [æ”¯é…æ ‘åº”ç”¨](#æ”¯é…æ ‘åº”ç”¨)
  - [1.3 å¾ªç¯ç»“æ„è¯†åˆ«](#13-å¾ªç¯ç»“æ„è¯†åˆ«)
    - [è‡ªç„¶å¾ªç¯å®šä¹‰](#è‡ªç„¶å¾ªç¯å®šä¹‰)
    - [å¾ªç¯åµŒå¥—æ ‘](#å¾ªç¯åµŒå¥—æ ‘)
- [ç¬¬äºŒéƒ¨åˆ†: SSAå½¢å¼](#ç¬¬äºŒéƒ¨åˆ†-ssaå½¢å¼)
  - [2.1 SSAå®šä¹‰ä¸æ€§è´¨](#21-ssaå®šä¹‰ä¸æ€§è´¨)
    - [SSAå½¢å¼å®šä¹‰](#ssaå½¢å¼å®šä¹‰)
    - [SSAæ€§è´¨](#ssaæ€§è´¨)
  - [2.2 Ï†å‡½æ•°è¯­ä¹‰](#22-Ï†å‡½æ•°è¯­ä¹‰)
    - [Ï†å‡½æ•°å½¢å¼åŒ–è¯­ä¹‰](#Ï†å‡½æ•°å½¢å¼åŒ–è¯­ä¹‰)
    - [Ï†å‡½æ•°å®ä¾‹](#Ï†å‡½æ•°å®ä¾‹)
  - [2.3 SSAæ„é€ ç®—æ³•](#23-ssaæ„é€ ç®—æ³•)
    - [SSAæ„é€ æ­¥éª¤](#ssaæ„é€ æ­¥éª¤)
    - [ä»SSAé€€å‡º](#ä»ssaé€€å‡º)
- [ç¬¬ä¸‰éƒ¨åˆ†: æ•°æ®æµåˆ†æ](#ç¬¬ä¸‰éƒ¨åˆ†-æ•°æ®æµåˆ†æ)
  - [3.1 æ•°æ®æµåˆ†ææ¡†æ¶](#31-æ•°æ®æµåˆ†ææ¡†æ¶)
    - [æ•°æ®æµåˆ†æå®šä¹‰](#æ•°æ®æµåˆ†æå®šä¹‰)
  - [3.2 æ´»è·ƒå˜é‡åˆ†æ](#32-æ´»è·ƒå˜é‡åˆ†æ)
    - [æ´»è·ƒå˜é‡å®šä¹‰](#æ´»è·ƒå˜é‡å®šä¹‰)
    - [æ´»è·ƒå˜é‡åº”ç”¨](#æ´»è·ƒå˜é‡åº”ç”¨)
  - [3.3 å¯è¾¾å®šä¹‰åˆ†æ](#33-å¯è¾¾å®šä¹‰åˆ†æ)
    - [å¯è¾¾å®šä¹‰å®šä¹‰](#å¯è¾¾å®šä¹‰å®šä¹‰)
    - [å¯è¾¾å®šä¹‰åº”ç”¨](#å¯è¾¾å®šä¹‰åº”ç”¨)
  - [3.4 å¯ç”¨è¡¨è¾¾å¼åˆ†æ](#34-å¯ç”¨è¡¨è¾¾å¼åˆ†æ)
    - [å¯ç”¨è¡¨è¾¾å¼å®šä¹‰](#å¯ç”¨è¡¨è¾¾å¼å®šä¹‰)
- [ç¬¬å››éƒ¨åˆ†: Goç‰¹å®šæ§åˆ¶æµ](#ç¬¬å››éƒ¨åˆ†-goç‰¹å®šæ§åˆ¶æµ)
  - [4.1 Deferè¯­å¥æ§åˆ¶æµ](#41-deferè¯­å¥æ§åˆ¶æµ)
  - [4.2 Panic/Recoveræ§åˆ¶æµ](#42-panicrecoveræ§åˆ¶æµ)
  - [4.3 Goroutineåˆ›å»ºæ§åˆ¶æµ](#43-goroutineåˆ›å»ºæ§åˆ¶æµ)
  - [4.4 Selectè¯­å¥æ§åˆ¶æµ](#44-selectè¯­å¥æ§åˆ¶æµ)
- [ç¬¬äº”éƒ¨åˆ†: æŠ½è±¡è§£é‡Š](#ç¬¬äº”éƒ¨åˆ†-æŠ½è±¡è§£é‡Š)
  - [5.1 æŠ½è±¡è§£é‡Šç†è®º](#51-æŠ½è±¡è§£é‡Šç†è®º)
  - [5.2 ç¬¦å·æ‰§è¡Œ](#52-ç¬¦å·æ‰§è¡Œ)
  - [5.3 åŒºé—´åˆ†æ](#53-åŒºé—´åˆ†æ)
- [ç¬¬å…­éƒ¨åˆ†: ç¼–è¯‘å™¨ä¼˜åŒ–](#ç¬¬å…­éƒ¨åˆ†-ç¼–è¯‘å™¨ä¼˜åŒ–)
  - [6.1 æ­»ä»£ç æ¶ˆé™¤](#61-æ­»ä»£ç æ¶ˆé™¤)
  - [6.2 å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤](#62-å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤)
  - [6.3 å¾ªç¯ä¼˜åŒ–](#63-å¾ªç¯ä¼˜åŒ–)
- [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
  - [æ ¸å¿ƒå†…å®¹](#æ ¸å¿ƒå†…å®¹)
  - [ç†è®ºä»·å€¼](#ç†è®ºä»·å€¼)
  - [å®è·µåº”ç”¨](#å®è·µåº”ç”¨)

## ç¬¬ä¸€éƒ¨åˆ†: æ§åˆ¶æµå›¾ç†è®º

### 1.1 åŸºæœ¬å—ä¸æ§åˆ¶æµå›¾

#### åŸºæœ¬å—å®šä¹‰

```mathematical
/* åŸºæœ¬å— (Basic Block) */

BasicBlock B = (label, instructions, terminator)

å…¶ä¸­:
- label: Label           /* å”¯ä¸€æ ‡è¯†ç¬¦ */
- instructions: Instr*   /* æŒ‡ä»¤åºåˆ— */
- terminator: Term       /* ç»ˆæ­¢æŒ‡ä»¤ */

/* æŒ‡ä»¤ç±»å‹ */

Instr ::= x = e                    /* èµ‹å€¼ */
        | x = Ï†(vâ‚, vâ‚‚, ..., vâ‚™)   /* Ï†å‡½æ•° (SSA) */
        | x = op(vâ‚, vâ‚‚)           /* äºŒå…ƒæ“ä½œ */
        | x = call f(vâ‚, ..., vâ‚™)  /* å‡½æ•°è°ƒç”¨ */
        | *x = v                   /* å­˜å‚¨ */
        | x = *p                   /* åŠ è½½ */

/* ç»ˆæ­¢æŒ‡ä»¤ */

Term ::= return v                  /* è¿”å› */
       | jump L                    /* æ— æ¡ä»¶è·³è½¬ */
       | branch v Lâ‚ Lâ‚‚            /* æ¡ä»¶è·³è½¬ */
       | switch v [(câ‚,Lâ‚),...,(câ‚™,Lâ‚™)] /* switch */
       | panic v                   /* panic */

/* åŸºæœ¬å—æ€§è´¨ */

æ€§è´¨ 1 (å•å…¥å£å•å‡ºå£):
  - åªèƒ½ä»ç¬¬ä¸€æ¡æŒ‡ä»¤è¿›å…¥
  - åªèƒ½ä»æœ€åä¸€æ¡æŒ‡ä»¤é€€å‡º
  - æ²¡æœ‰å†…éƒ¨è·³è½¬

æ€§è´¨ 2 (é¡ºåºæ‰§è¡Œ):
  - å—å†…æŒ‡ä»¤é¡ºåºæ‰§è¡Œ
  - ä¸ä¼šè·³è¿‡ä¸­é—´æŒ‡ä»¤

æ€§è´¨ 3 (åŸå­æ€§):
  - è¦ä¹ˆæ•´ä¸ªå—éƒ½æ‰§è¡Œ
  - è¦ä¹ˆæ•´ä¸ªå—éƒ½ä¸æ‰§è¡Œ
```

#### æ§åˆ¶æµå›¾æ„é€ 

```mathematical
/* æ§åˆ¶æµå›¾ (CFG) */

CFG = (Blocks, Edges, entry, exit)

å…¶ä¸­:
- Blocks: Set[BasicBlock]      /* åŸºæœ¬å—é›†åˆ */
- Edges: Blocks Ã— Blocks       /* æ§åˆ¶æµè¾¹ */
- entry: BasicBlock            /* å…¥å£å— */
- exit: BasicBlock             /* å‡ºå£å— */

/* CFG æ„é€ ç®—æ³• */

function buildCFG(stmt: Statement) -> CFG:
    blocks = []
    edges = []
    entry_block = newBlock("entry")
    exit_block = newBlock("exit")
    
    function visit(s: Statement, current: BasicBlock) -> BasicBlock:
        match s:
            case Assign(x, e):
                current.add_instr(x = eval(e))
                return current
            
            case If(cond, then_stmt, else_stmt):
                // åˆ›å»ºæ¡ä»¶å—
                cond_block = current
                cond_var = fresh_temp()
                cond_block.add_instr(cond_var = eval(cond))
                
                // åˆ›å»ºthenåˆ†æ”¯
                then_block = newBlock("then")
                then_exit = visit(then_stmt, then_block)
                
                // åˆ›å»ºelseåˆ†æ”¯
                else_block = newBlock("else")
                else_exit = visit(else_stmt, else_block)
                
                // åˆ›å»ºåˆå¹¶å—
                merge_block = newBlock("merge")
                
                // æ·»åŠ è¾¹
                cond_block.set_terminator(branch cond_var then_block else_block)
                edges.add((cond_block, then_block))
                edges.add((cond_block, else_block))
                edges.add((then_exit, merge_block))
                edges.add((else_exit, merge_block))
                
                return merge_block
            
            case While(cond, body):
                // åˆ›å»ºå¾ªç¯å¤´
                header = newBlock("while.header")
                cond_var = fresh_temp()
                header.add_instr(cond_var = eval(cond))
                
                // åˆ›å»ºå¾ªç¯ä½“
                body_block = newBlock("while.body")
                body_exit = visit(body, body_block)
                
                // åˆ›å»ºå¾ªç¯å‡ºå£
                exit_block = newBlock("while.exit")
                
                // æ·»åŠ è¾¹
                current.set_terminator(jump header)
                edges.add((current, header))
                header.set_terminator(branch cond_var body_block exit_block)
                edges.add((header, body_block))
                edges.add((header, exit_block))
                edges.add((body_exit, header))  /* å›è¾¹ */
                
                return exit_block
            
            case Sequence(s1, s2):
                mid = visit(s1, current)
                return visit(s2, mid)
            
            case Return(e):
                current.add_instr(ret_val = eval(e))
                current.set_terminator(return ret_val)
                return current
    
    exit = visit(stmt, entry_block)
    edges.add((exit, exit_block))
    
    return CFG(blocks, edges, entry_block, exit_block)
```

#### Goè¯­å¥CFGç¤ºä¾‹

```go
// Goä»£ç 
func example(x int) int {
    var y int
    if x > 0 {
        y = x + 1
    } else {
        y = x - 1
    }
    z := y * 2
    return z
}

// CFGè¡¨ç¤º
B0 (entry):
    // å‚æ•°åˆå§‹åŒ–
    goto B1

B1:
    t1 = x > 0
    branch t1, B2, B3

B2 (then):
    y = x + 1
    goto B4

B3 (else):
    y = x - 1
    goto B4

B4 (merge):
    z = y * 2
    return z

// æ§åˆ¶æµè¾¹
B0 â†’ B1
B1 â†’ B2 (true)
B1 â†’ B3 (false)
B2 â†’ B4
B3 â†’ B4
```

### 1.2 æ”¯é…å…³ç³»

#### æ”¯é…å…³ç³»å®šä¹‰

```mathematical
/* æ”¯é…å…³ç³» (Dominance) */

å®šä¹‰: èŠ‚ç‚¹næ”¯é…èŠ‚ç‚¹m (è®°ä½œ n dom m) å½“ä¸”ä»…å½“
  ä»entryåˆ°mçš„æ‰€æœ‰è·¯å¾„éƒ½ç»è¿‡n

å½¢å¼åŒ–:
n dom m âŸº âˆ€ path p. (entry â†’* m via p) â‡’ n âˆˆ p

/* æ”¯é…å…³ç³»æ€§è´¨ */

æ€§è´¨ 1 (è‡ªåæ€§):
  n dom n  âˆ€n

æ€§è´¨ 2 (ä¼ é€’æ€§):
  n dom m âˆ§ m dom k â‡’ n dom k

æ€§è´¨ 3 (åå¯¹ç§°æ€§):
  n dom m âˆ§ m dom n â‡’ n = m

/* ä¸¥æ ¼æ”¯é… (Strict Dominance) */

n sdom m âŸº n dom m âˆ§ n â‰  m

/* ç›´æ¥æ”¯é… (Immediate Dominance) */

idom(m) = n âŸº 
  n sdom m âˆ§ 
  (âˆ€k. k sdom m â‡’ k dom n âˆ¨ k = n)

æ€§è´¨: æ¯ä¸ªèŠ‚ç‚¹(é™¤entryå¤–)æœ‰å”¯ä¸€çš„idom

/* æ”¯é…è¾¹ç•Œ (Dominance Frontier) */

DF(n) = {m | âˆƒp âˆˆ pred(m). n dom p âˆ§ Â¬(n sdom m)}

å«ä¹‰: èŠ‚ç‚¹nçš„æ”¯é…è¾¹ç•Œæ˜¯næ”¯é…å…¶å‰é©±ä½†ä¸ä¸¥æ ¼æ”¯é…çš„èŠ‚ç‚¹é›†åˆ

/* æ”¯é…æ ‘ (Dominator Tree) */

æ”¯é…æ ‘æ˜¯ä¸€æ£µæœ‰æ ¹æ ‘,å…¶ä¸­:
- æ ¹èŠ‚ç‚¹æ˜¯entry
- nçš„çˆ¶èŠ‚ç‚¹æ˜¯idom(n)
- næ˜¯mçš„ç¥–å…ˆ âŸº n dom m
```

#### æ”¯é…æ ‘æ„é€ ç®—æ³•

```mathematical
/* Lengauer-Tarjanç®—æ³• */

function computeDominators(CFG) -> Map[Block, Block]:
    // æ­¥éª¤1: DFSéå†,è®¡ç®—DFSåºå·
    dfs_num = {}
    parent = {}
    vertex = []
    
    function dfs(v, p):
        dfs_num[v] = len(vertex)
        vertex.append(v)
        parent[v] = p
        for w in successors(v):
            if w not in dfs_num:
                dfs(w, v)
    
    dfs(entry, None)
    
    // æ­¥éª¤2: è®¡ç®—åŠæ”¯é…è€… (Semi-dominator)
    sdom = {v: v for v in vertex}
    bucket = {v: [] for v in vertex}
    
    for w in reversed(vertex[1:]):
        // è®¡ç®—sdom[w]
        for v in predecessors(w):
            u = eval_sdom(v, w, sdom, dfs_num)
            if dfs_num[sdom[u]] < dfs_num[sdom[w]]:
                sdom[w] = sdom[u]
        
        bucket[sdom[w]].append(w)
        link(parent[w], w)
        
        // å¤„ç†bucket
        for v in bucket[parent[w]]:
            u = eval_sdom(v, parent[w], sdom, dfs_num)
            if sdom[u] == parent[w]:
                idom[v] = parent[w]
            else:
                idom[v] = u
        
        bucket[parent[w]] = []
    
    // æ­¥éª¤3: è®¡ç®—æœ€ç»ˆçš„idom
    for w in vertex[1:]:
        if idom[w] != sdom[w]:
            idom[w] = idom[idom[w]]
    
    return idom

/* ç®—æ³•å¤æ‚åº¦ */

æ—¶é—´å¤æ‚åº¦: O(n Î±(n))  /* Î±æ˜¯é€†Ackermannå‡½æ•° */
ç©ºé—´å¤æ‚åº¦: O(n)
```

#### æ”¯é…æ ‘åº”ç”¨

```mathematical
/* åº”ç”¨1: å¿«é€Ÿæ”¯é…æŸ¥è¯¢ */

function dominates(n, m, dom_tree) -> bool:
    // O(depth)æ—¶é—´,é€šè¿‡æ ‘éå†
    current = m
    while current != None:
        if current == n:
            return true
        current = dom_tree.parent[current]
    return false

/* åº”ç”¨2: æœ€è¿‘å…¬å…±ç¥–å…ˆ (LCA) */

function lca(n, m, dom_tree) -> Block:
    // è¿”å›nå’Œmçš„æœ€è¿‘å…¬å…±æ”¯é…è€…
    path_n = ancestors(n, dom_tree)
    path_m = ancestors(m, dom_tree)
    
    for node in path_n:
        if node in path_m:
            return node
    
    return entry

/* åº”ç”¨3: æ”¯é…è¾¹ç•Œè®¡ç®— */

function computeDF(CFG, dom_tree) -> Map[Block, Set[Block]]:
    DF = {b: set() for b in CFG.blocks}
    
    for block in CFG.blocks:
        if len(predecessors(block)) >= 2:
            for pred in predecessors(block):
                runner = pred
                while runner != idom(block):
                    DF[runner].add(block)
                    runner = idom(runner)
    
    return DF

/* DFçš„åº”ç”¨: SSAæ„é€ ä¸­çš„Ï†å‡½æ•°æ’å…¥ */

å®šç† (Ï†å‡½æ•°æ’å…¥å®šç†):
å¯¹äºå˜é‡xçš„å®šä¹‰é›†åˆ Defs(x),
Ï†å‡½æ•°åº”è¯¥æ’å…¥åœ¨ âˆª_{d âˆˆ Defs(x)} DF(d) ä¸­

è¯æ˜:
Ï†å‡½æ•°æ’å…¥åœ¨æ§åˆ¶æµæ±‡åˆç‚¹,
æ”¯é…è¾¹ç•Œæ°å¥½æ˜¯æ”¯é…è·¯å¾„çš„æ±‡åˆç‚¹ â–¡
```

### 1.3 å¾ªç¯ç»“æ„è¯†åˆ«

#### è‡ªç„¶å¾ªç¯å®šä¹‰

```mathematical
/* è‡ªç„¶å¾ªç¯ (Natural Loop) */

å®šä¹‰: å¯¹äºå›è¾¹ (n, h) (å³ h dom n),
è‡ªç„¶å¾ªç¯ Loop(n, h) = {h} âˆª {m | âˆƒ path m â†’* n âˆ§ Â¬(path via h)}

æ€§è´¨:
1. hæ˜¯å¾ªç¯å¤´ (Loop Header)
2. (n, h)æ˜¯å›è¾¹ (Back Edge)
3. hæ”¯é…å¾ªç¯ä¸­æ‰€æœ‰èŠ‚ç‚¹

/* å›è¾¹è¯†åˆ« */

å›è¾¹: (n, h) æ»¡è¶³ h dom n

function findBackEdges(CFG, dom_tree) -> Set[(Block, Block)]:
    back_edges = set()
    
    for (src, dst) in CFG.edges:
        if dominates(dst, src, dom_tree):
            back_edges.add((src, dst))
    
    return back_edges

/* å¾ªç¯æ„é€  */

function findNaturalLoop(back_edge (n, h), CFG) -> Set[Block]:
    loop = {h}
    stack = [n]
    
    while stack:
        m = stack.pop()
        if m not in loop:
            loop.add(m)
            for pred in predecessors(m):
                if pred not in loop:
                    stack.append(pred)
    
    return loop
```

#### å¾ªç¯åµŒå¥—æ ‘

```mathematical
/* å¾ªç¯åµŒå¥—å…³ç³» */

Loopâ‚ âŠ‚ Loopâ‚‚ âŸº Loopâ‚çš„æ‰€æœ‰èŠ‚ç‚¹éƒ½åœ¨Loopâ‚‚ä¸­

/* å¾ªç¯åµŒå¥—æ ‘ (Loop Nesting Tree) */

LoopTree = Tree[Loop]

æ„é€ :
1. æ ¹èŠ‚ç‚¹è¡¨ç¤ºæ•´ä¸ªç¨‹åº
2. å­èŠ‚ç‚¹è¡¨ç¤ºåµŒå¥—çš„å¾ªç¯
3. å¶å­èŠ‚ç‚¹æ˜¯æœ€å†…å±‚å¾ªç¯

function buildLoopTree(loops: Set[Loop]) -> LoopTree:
    // æŒ‰å¾ªç¯å¤§å°æ’åº
    sorted_loops = sort(loops, key=lambda l: -len(l))
    
    tree = LoopTree()
    tree.root = sorted_loops[0]
    
    for loop in sorted_loops[1:]:
        // æ‰¾åˆ°æœ€å°çš„åŒ…å«å¾ªç¯
        parent = find_smallest_containing(loop, tree)
        tree.add_child(parent, loop)
    
    return tree

/* å¾ªç¯ä¸å˜é‡ (Loop Invariant) */

å®šä¹‰: è¡¨è¾¾å¼eåœ¨å¾ªç¯Lä¸­æ˜¯ä¸å˜çš„,å½“ä¸”ä»…å½“:
  eçš„æ‰€æœ‰æ“ä½œæ•°åœ¨Lå¤–å®šä¹‰,æˆ–åœ¨Lå†…ä¸å˜

å½¢å¼åŒ–:
invariant(e, L) âŸº 
  âˆ€var âˆˆ vars(e). 
    (def(var) âˆ‰ L) âˆ¨ invariant(def(var), L)

/* å¯å½’çº¦æ€§ (Reducibility) */

å®šä¹‰: CFGæ˜¯å¯å½’çº¦çš„,å½“ä¸”ä»…å½“å¯ä»¥é€šè¿‡ä»¥ä¸‹ä¸¤ç§æ“ä½œçº¦ç®€ä¸ºå•ä¸ªèŠ‚ç‚¹:
1. åˆ é™¤è‡ªç¯è¾¹
2. åˆå¹¶ä¸²è¡ŒèŠ‚ç‚¹

å®šç†: æ‰€æœ‰ç»“æ„åŒ–ç¨‹åºçš„CFGéƒ½æ˜¯å¯å½’çº¦çš„
```

---

## ç¬¬äºŒéƒ¨åˆ†: SSAå½¢å¼

### 2.1 SSAå®šä¹‰ä¸æ€§è´¨

#### SSAå½¢å¼å®šä¹‰

```mathematical
/* Static Single Assignment (SSA) */

å®šä¹‰: ç¨‹åºçš„SSAå½¢å¼æ»¡è¶³:
  æ¯ä¸ªå˜é‡åªè¢«èµ‹å€¼ä¸€æ¬¡ (é™æ€)

è½¬æ¢è§„åˆ™:
åŸç¨‹åºä¸­çš„å˜é‡ x â†’ SSAä¸­çš„ xâ‚, xâ‚‚, ..., xâ‚™

ç¤ºä¾‹:
// åŸç¨‹åº
x = 1
y = x + 2
x = 3
z = x + y

// SSAå½¢å¼
xâ‚ = 1
yâ‚ = xâ‚ + 2
xâ‚‚ = 3
zâ‚ = xâ‚‚ + yâ‚

/* Ï†å‡½æ•° (Phi Function) */

åœ¨æ§åˆ¶æµæ±‡åˆç‚¹æ’å…¥Ï†å‡½æ•°:
xâ‚ƒ = Ï†(xâ‚, xâ‚‚)  /* æ ¹æ®æ¥è‡ªå“ªæ¡è·¯å¾„é€‰æ‹© */

ç¤ºä¾‹:
// åŸç¨‹åº
if cond:
    x = 1
else:
    x = 2
y = x + 3

// SSAå½¢å¼
B1:
    branch cond, B2, B3
B2:
    xâ‚ = 1
    goto B4
B3:
    xâ‚‚ = 2
    goto B4
B4:
    xâ‚ƒ = Ï†(xâ‚, xâ‚‚)  /* Ï†å‡½æ•° */
    yâ‚ = xâ‚ƒ + 3
```

#### SSAæ€§è´¨

```mathematical
/* SSAæ€§è´¨ */

æ€§è´¨ 1 (å®šä¹‰å”¯ä¸€æ€§):
  âˆ€ variable v. |definitions(v)| = 1

æ€§è´¨ 2 (ä½¿ç”¨-å®šä¹‰é“¾ç®€å•):
  æ¯ä¸ªä½¿ç”¨ç‚¹å”¯ä¸€å¯¹åº”ä¸€ä¸ªå®šä¹‰ç‚¹

æ€§è´¨ 3 (def-useé“¾ç²¾ç¡®):
  def-useå…³ç³»ç›´æ¥å¯è§,æ— éœ€åˆ†æ

æ€§è´¨ 4 (ä¼˜åŒ–å‹å¥½):
  è®¸å¤šä¼˜åŒ–ç®—æ³•åœ¨SSAä¸Šæ›´ç®€å•é«˜æ•ˆ

/* SSAä¼˜åŠ¿ */

1. ç®€åŒ–æ•°æ®æµåˆ†æ
   - def-useå…³ç³»æ˜¾å¼
   - å¸¸é‡ä¼ æ’­æ›´ç®€å•

2. ç®€åŒ–ä¼˜åŒ–
   - æ­»ä»£ç æ¶ˆé™¤
   - å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤
   - å¾ªç¯ä¼˜åŒ–

3. æ”¯æŒé«˜æ•ˆå¯„å­˜å™¨åˆ†é…
   - æ´»è·ƒå˜é‡åˆ†æç®€åŒ–
   - å¹²æ¶‰å›¾æ„é€ ç®€åŒ–

4. æ”¯æŒç¨€ç–åˆ†æ
   - åªå…³æ³¨ç›¸å…³çš„å®šä¹‰-ä½¿ç”¨
   - é¿å…ä¸å¿…è¦çš„è¿­ä»£
```

### 2.2 Ï†å‡½æ•°è¯­ä¹‰

#### Ï†å‡½æ•°å½¢å¼åŒ–è¯­ä¹‰

```mathematical
/* Ï†å‡½æ•°å®šä¹‰ */

Ï†å‡½æ•°: x = Ï†(vâ‚:Lâ‚, vâ‚‚:Lâ‚‚, ..., vâ‚™:Lâ‚™)

è¯­ä¹‰:
  å¦‚æœæ§åˆ¶æµä»æ ‡ç­¾Láµ¢åˆ°è¾¾,åˆ™ x = váµ¢

/* æ“ä½œè¯­ä¹‰ */

[Phi-Eval]
control_flow_from = L_i
x = Ï†(vâ‚:Lâ‚, vâ‚‚:Lâ‚‚, ..., vâ‚™:Lâ‚™)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
x â† váµ¢

/* Ï†å‡½æ•°æ’å…¥ä½ç½® */

å®šç† (Ï†æ’å…¥å®šç†):
å¯¹äºå˜é‡x,Ï†å‡½æ•°åº”æ’å…¥åœ¨:
  âˆª_{d âˆˆ Defs(x)} DF(d)

å…¶ä¸­ Defs(x) æ˜¯xçš„æ‰€æœ‰å®šä¹‰ç‚¹

è¯æ˜:
è®¾m âˆˆ DF(d),åˆ™å­˜åœ¨:
- mçš„å‰é©±p,æ»¡è¶³ d dom p
- ä½† d Â¬sdom m

è¿™æ„å‘³ç€æœ‰å¤šæ¡è·¯å¾„åˆ°è¾¾m,
å…¶ä¸­ä¸€äº›ç»è¿‡d (xè¢«å®šä¹‰),
å¦ä¸€äº›ä¸ç»è¿‡ (xå¯èƒ½æœ‰å…¶ä»–å®šä¹‰)ã€‚
å› æ­¤åœ¨méœ€è¦Ï†å‡½æ•°é€‰æ‹©æ­£ç¡®çš„å€¼ â–¡

/* Ï†å‡½æ•°è¿­ä»£æ’å…¥ */

ç”±äºÏ†å‡½æ•°æœ¬èº«ä¹Ÿæ˜¯å®šä¹‰,å¯èƒ½éœ€è¦è¿­ä»£æ’å…¥:

function insertPhiFunctions(CFG, var):
    Defs = definitions(var)
    Worklist = Defs.copy()
    PhiInserted = set()
    
    while Worklist:
        d = Worklist.pop()
        for m in DF[d]:
            if m not in PhiInserted:
                insert Ï†-function for var at m
                PhiInserted.add(m)
                if m not in Defs:
                    Worklist.add(m)
    
    return PhiInserted
```

#### Ï†å‡½æ•°å®ä¾‹

```mathematical
/* ç¤ºä¾‹1: if-then-else */

// åŸä»£ç 
x = 1
if cond:
    x = 2
y = x + 3

// CFG
B1: xâ‚ = 1
    branch cond, B2, B3

B2: xâ‚‚ = 2
    goto B4

B3: goto B4

B4: xâ‚ƒ = Ï†(xâ‚‚:B2, xâ‚:B3)
    yâ‚ = xâ‚ƒ + 3

/* ç¤ºä¾‹2: å¾ªç¯ */

// åŸä»£ç 
x = 0
while x < 10:
    x = x + 1
y = x

// SSA (éœ€è¦Ï†å‡½æ•°)
B1: xâ‚ = 0
    goto B2

B2: xâ‚‚ = Ï†(xâ‚:B1, xâ‚ƒ:B3)
    tâ‚ = xâ‚‚ < 10
    branch tâ‚, B3, B4

B3: xâ‚ƒ = xâ‚‚ + 1
    goto B2

B4: yâ‚ = xâ‚‚

/* ç¤ºä¾‹3: åµŒå¥—å¾ªç¯ */

// åŸä»£ç 
x = 0
for i = 0; i < n; i++:
    for j = 0; j < m; j++:
        x = x + 1
y = x

// SSAå½¢å¼
B1: xâ‚ = 0
    iâ‚ = 0
    goto B2

B2: xâ‚‚ = Ï†(xâ‚:B1, xâ‚„:B5)
    iâ‚‚ = Ï†(iâ‚:B1, iâ‚ƒ:B5)
    tâ‚ = iâ‚‚ < n
    branch tâ‚, B3, B6

B3: jâ‚ = 0
    goto B4

B4: xâ‚ƒ = Ï†(xâ‚‚:B3, xâ‚„:B4)
    jâ‚‚ = Ï†(jâ‚:B3, jâ‚ƒ:B4)
    tâ‚‚ = jâ‚‚ < m
    branch tâ‚‚, B5, B6

B5: xâ‚„ = xâ‚ƒ + 1
    jâ‚ƒ = jâ‚‚ + 1
    goto B4

B6: iâ‚ƒ = iâ‚‚ + 1
    goto B2

B7: yâ‚ = xâ‚‚
```

### 2.3 SSAæ„é€ ç®—æ³•

#### SSAæ„é€ æ­¥éª¤

```mathematical
/* SSAæ„é€ ç®—æ³• (å®Œæ•´ç‰ˆ) */

function constructSSA(CFG) -> SSA_CFG:
    // æ­¥éª¤1: è®¡ç®—æ”¯é…æ ‘
    dom_tree = computeDominatorTree(CFG)
    
    // æ­¥éª¤2: è®¡ç®—æ”¯é…è¾¹ç•Œ
    DF = computeDominanceFrontier(CFG, dom_tree)
    
    // æ­¥éª¤3: æ’å…¥Ï†å‡½æ•°
    for each variable x:
        Defs = getAllDefinitions(x)
        Worklist = Defs.copy()
        PhiInserted = set()
        
        while Worklist:
            d = Worklist.pop()
            for m in DF[d]:
                if m not in PhiInserted:
                    insert x = Ï†(...) at beginning of m
                    PhiInserted.add(m)
                    if m not in Defs:
                        Worklist.add(m)
    
    // æ­¥éª¤4: å˜é‡é‡å‘½å
    Counter = {var: 0 for var in variables}
    Stack = {var: [] for var in variables}
    
    function rename(block):
        // ä¸ºå½“å‰å—é‡å‘½å
        for instr in block.instructions:
            // é‡å‘½åä½¿ç”¨çš„å˜é‡
            for var in uses(instr):
                instr.replace(var, Stack[var].top())
            
            // é‡å‘½åå®šä¹‰çš„å˜é‡
            for var in defs(instr):
                i = Counter[var]
                Counter[var] += 1
                Stack[var].push(var_i)
                instr.replace_def(var, var_i)
        
        // ä¸ºåç»§çš„Ï†å‡½æ•°å¡«å……å‚æ•°
        for succ in successors(block):
            for phi in succ.phi_functions:
                var = phi.variable
                phi.add_arg(Stack[var].top(), block.label)
        
        // é€’å½’å¤„ç†æ”¯é…æ ‘çš„å­èŠ‚ç‚¹
        for child in dom_tree_children(block):
            rename(child)
        
        // æ¢å¤æ ˆ (å›æº¯)
        for var in defs(block):
            Stack[var].pop()
    
    rename(entry_block)
    
    return SSA_CFG

/* ç®—æ³•å¤æ‚åº¦ */

Ï†æ’å…¥: O(E Ã— DF)  /* Eæ˜¯è¾¹æ•° */
å˜é‡é‡å‘½å: O(N + E)  /* Næ˜¯æŒ‡ä»¤æ•° */
æ€»å¤æ‚åº¦: O(E Ã— DF)
```

#### ä»SSAé€€å‡º

```mathematical
/* SSAè§£æ„ (SSA Deconstruction) */

é—®é¢˜: å¦‚ä½•å°†SSAå½¢å¼è½¬å›æ™®é€šå½¢å¼?

æ–¹æ³•1: ç®€å•Ï†æ›¿æ¢

replace Ï†(vâ‚:Lâ‚, vâ‚‚:Lâ‚‚) at block B with:
  åœ¨Lâ‚æœ«å°¾æ·»åŠ : x = vâ‚
  åœ¨Lâ‚‚æœ«å°¾æ·»åŠ : x = vâ‚‚

é—®é¢˜: Lost-copy problem
  - å¯èƒ½ç ´åç¨‹åºè¯­ä¹‰
  - å¯èƒ½å¼•å…¥ä¸å¿…è¦çš„å¤åˆ¶

æ–¹æ³•2: Ï†-webåˆå¹¶

1. æ„å»ºÏ†-web
   - å°†ç›¸å…³çš„Ï†å‡½æ•°å’Œå˜é‡åˆ†ç»„
   - æ¯ä¸ªwebå¯¹åº”åŸç¨‹åºä¸­çš„ä¸€ä¸ªå˜é‡

2. åˆå¹¶åŒä¸€webä¸­çš„å˜é‡
   - ä½¿ç”¨å¯„å­˜å™¨åˆ†é…å™¨
   - æˆ–æ’å…¥å¿…è¦çš„å¤åˆ¶æŒ‡ä»¤

function deconstructSSA(SSA_CFG) -> CFG:
    // æ­¥éª¤1: æ„å»ºÏ†-webs
    webs = buildPhiWebs(SSA_CFG)
    
    // æ­¥éª¤2: ä¸ºæ¯ä¸ªwebåˆ†é…ä¸€ä¸ªå˜é‡
    var_map = {}
    for web in webs:
        original_var = web.original_name
        for ssa_var in web.variables:
            var_map[ssa_var] = original_var
    
    // æ­¥éª¤3: é‡å†™æŒ‡ä»¤
    for block in SSA_CFG.blocks:
        for instr in block.instructions:
            if instr is phi:
                // åœ¨å‰é©±å—æ’å…¥å¤åˆ¶
                for (val, pred_label) in instr.args:
                    pred_block = find_block(pred_label)
                    insert_at_end(pred_block, 
                        var_map[instr.var] = var_map[val])
                
                remove(instr)
            else:
                // æ›¿æ¢SSAå˜é‡ä¸ºåŸå§‹å˜é‡
                for var in uses(instr) âˆª defs(instr):
                    instr.replace(var, var_map[var])
    
    return CFG

/* å…³é”®æŒ‘æˆ˜: ä¸¢å¤±å¤åˆ¶é—®é¢˜ */

ç¤ºä¾‹:
B1: xâ‚ = 1
    goto B3

B2: xâ‚‚ = 2
    goto B3

B3: xâ‚ƒ = Ï†(xâ‚:B1, xâ‚‚:B2)
    yâ‚ = xâ‚ƒ

ç›´æ¥æ›¿æ¢:
B1: x = 1
    goto B3

B2: x = 2
    goto B3

B3: y = x  âœ“ æ­£ç¡®

ä½†å¦‚æœæœ‰:
B3: xâ‚ƒ = Ï†(xâ‚:B1, xâ‚‚:B2)
    xâ‚„ = xâ‚ƒ + 1
    yâ‚ = xâ‚ƒ  /* ä½¿ç”¨xâ‚ƒçš„æ—§å€¼ */

ç›´æ¥æ›¿æ¢ä¼šå¯¼è‡´é”™è¯¯!
éœ€è¦æ’å…¥ä¸´æ—¶å˜é‡ã€‚
```

---

## ç¬¬ä¸‰éƒ¨åˆ†: æ•°æ®æµåˆ†æ

### 3.1 æ•°æ®æµåˆ†ææ¡†æ¶

#### æ•°æ®æµåˆ†æå®šä¹‰

```mathematical
/* æ•°æ®æµåˆ†ææ¡†æ¶ (Dataflow Analysis Framework) */

ç»„æˆ:
1. æ•°æ®æµå€¼åŸŸ (Domain): D
2. ä¼ é€’å‡½æ•° (Transfer Function): f: D â†’ D
3. æ±‡åˆæ“ä½œ (Meet Operation): âˆ§: D Ã— D â†’ D
4. åˆå§‹å€¼ (Initial Value): âŠ¤ æˆ– âŠ¥

/* æ•°æ®æµæ–¹ç¨‹ */

å‰å‘åˆ†æ (Forward Analysis):
  OUT[B] = f_B(IN[B])
  IN[B] = âˆ§_{P âˆˆ pred(B)} OUT[P]

åå‘åˆ†æ (Backward Analysis):
  IN[B] = f_B(OUT[B])
  OUT[B] = âˆ§_{S âˆˆ succ(B)} IN[S]

/* æ ¼ç†è®ºåŸºç¡€ (Lattice Theory) */

å®šä¹‰: ååºé›† (L, âŠ‘) æ˜¯æ ¼,å¦‚æœ:
- âˆ€x,y âˆˆ L. âˆƒ x âˆ§ y (æœ€å¤§ä¸‹ç•Œ)
- âˆ€x,y âˆˆ L. âˆƒ x âˆ¨ y (æœ€å°ä¸Šç•Œ)

å®Œå…¨æ ¼: ä»»æ„å­é›†éƒ½æœ‰ä¸Šç•Œå’Œä¸‹ç•Œ

å•è°ƒæ€§: f(x) âŠ‘ f(y) if x âŠ‘ y

/* ä¸åŠ¨ç‚¹ç†è®º (Fixed Point Theory) */

å®šç† (Tarskiä¸åŠ¨ç‚¹å®šç†):
è®¾ (L, âŠ‘) æ˜¯å®Œå…¨æ ¼, f: L â†’ L æ˜¯å•è°ƒå‡½æ•°,
åˆ™ f æœ‰æœ€å°ä¸åŠ¨ç‚¹ lfp(f) = âˆ§{x | f(x) âŠ‘ x}
å’Œæœ€å¤§ä¸åŠ¨ç‚¹ gfp(f) = âˆ¨{x | x âŠ‘ f(x)}

/* è¿­ä»£æ±‚è§£ç®—æ³• */

function solveDataflow(CFG, f, meet, init) -> Map[Block, Domain]:
    // åˆå§‹åŒ–
    IN = {B: init for B in CFG.blocks}
    OUT = {B: init for B in CFG.blocks}
    
    Worklist = CFG.blocks.copy()
    
    while Worklist:
        B = Worklist.pop()
        
        // è®¡ç®—IN[B]
        IN[B] = meet(OUT[P] for P in predecessors(B))
        
        // è®¡ç®—OUT[B]
        old_out = OUT[B]
        OUT[B] = f_B(IN[B])
        
        // å¦‚æœOUTæ”¹å˜,å°†åç»§åŠ å…¥å·¥ä½œåˆ—è¡¨
        if OUT[B] != old_out:
            Worklist.extend(successors(B))
    
    return IN, OUT

/* ç®—æ³•ç»ˆæ­¢æ€§ */

å®šç† (ç»ˆæ­¢æ€§):
å¦‚æœåŸŸLæ˜¯æœ‰é™é«˜åº¦çš„æ ¼,ä¼ é€’å‡½æ•°æ˜¯å•è°ƒçš„,
åˆ™è¿­ä»£ç®—æ³•åœ¨æœ‰é™æ­¥å†…ç»ˆæ­¢ã€‚

è¯æ˜:
- Læœ‰é™é«˜åº¦ â‡’ å­˜åœ¨æœ‰é™é“¾: âŠ¥ âŠ‘ xâ‚ âŠ‘ ... âŠ‘ âŠ¤
- å•è°ƒæ€§ â‡’ æ¯æ¬¡è¿­ä»£åªä¼šå‘ä¸Šç§»åŠ¨æˆ–ä¸å˜
- å› æ­¤æœ€å¤šè¿­ä»£ height(L) Ã— |Blocks| æ¬¡ â–¡

å¤æ‚åº¦: O(height(L) Ã— |Blocks| Ã— |Edges|)
```

### 3.2 æ´»è·ƒå˜é‡åˆ†æ

#### æ´»è·ƒå˜é‡å®šä¹‰

```mathematical
/* æ´»è·ƒå˜é‡åˆ†æ (Liveness Analysis) */

å®šä¹‰: å˜é‡våœ¨ç¨‹åºç‚¹pæ˜¯æ´»è·ƒçš„,å½“ä¸”ä»…å½“:
  âˆƒ è·¯å¾„ p â†’* q,ä½¿å¾—:
    - åœ¨qå¤„ä½¿ç”¨v
    - è·¯å¾„ä¸Švæœªè¢«é‡æ–°å®šä¹‰

/* æ•°æ®æµæ–¹ç¨‹ */

IN[B] = USE[B] âˆª (OUT[B] - DEF[B])
OUT[B] = âˆª_{S âˆˆ succ(B)} IN[S]

å…¶ä¸­:
- USE[B]: Bä¸­ä½¿ç”¨ä½†æœªå…ˆå®šä¹‰çš„å˜é‡
- DEF[B]: Bä¸­å®šä¹‰çš„å˜é‡
- IN[B]: Bå…¥å£çš„æ´»è·ƒå˜é‡
- OUT[B]: Bå‡ºå£çš„æ´»è·ƒå˜é‡

/* æ ¼å®šä¹‰ */

åŸŸ: D = P(Variables)  /* å˜é‡çš„å¹‚é›† */
åº: âŠ‡ (è¶…é›†å…³ç³»,å› ä¸ºæ˜¯åå‘åˆ†æçš„Mayåˆ†æ)
æ±‡åˆ: âˆª (å¹¶é›†)
åˆå§‹: âˆ…

ä¼ é€’å‡½æ•°:
f_B(X) = USE[B] âˆª (X - DEF[B])

/* è®¡ç®—USEå’ŒDEF */

function computeUseDef(block):
    USE = set()
    DEF = set()
    
    for instr in block.instructions:
        // å…ˆå¤„ç†ä½¿ç”¨
        for var in uses(instr):
            if var not in DEF:
                USE.add(var)
        
        // å†å¤„ç†å®šä¹‰
        for var in defs(instr):
            DEF.add(var)
    
    return USE, DEF
```

#### æ´»è·ƒå˜é‡åº”ç”¨

```mathematical
/* åº”ç”¨1: æ­»ä»£ç æ¶ˆé™¤ (Dead Code Elimination) */

function eliminateDeadCode(CFG):
    IN, OUT = livenessAnalysis(CFG)
    
    for block in CFG.blocks:
        live = OUT[block]
        
        for instr in reversed(block.instructions):
            if instr is (x = e):
                if x not in live:
                    // xåœ¨æ­¤åä¸æ´»è·ƒ,åˆ é™¤æ­¤æŒ‡ä»¤
                    remove(instr)
                else:
                    // æ›´æ–°æ´»è·ƒé›†
                    live.remove(x)
                    live.update(uses(e))
            else:
                live.update(uses(instr))
        
        IN[block] = live

/* åº”ç”¨2: å¯„å­˜å™¨åˆ†é… */

function registerAllocation(CFG):
    // æ­¥éª¤1: æ„å»ºå¹²æ¶‰å›¾
    interference_graph = buildInterferenceGraph(CFG)
    
    // æ­¥éª¤2: å›¾ç€è‰²
    coloring = graphColoring(interference_graph, num_registers)
    
    // æ­¥éª¤3: åˆ†é…å¯„å­˜å™¨æˆ–æ ˆä½ç½®
    allocation = {}
    for var, color in coloring.items():
        if color < num_registers:
            allocation[var] = register[color]
        else:
            allocation[var] = stack_slot(color - num_registers)
    
    return allocation

function buildInterferenceGraph(CFG):
    IN, OUT = livenessAnalysis(CFG)
    graph = Graph()
    
    for block in CFG.blocks:
        live = OUT[block].copy()
        
        for instr in reversed(block.instructions):
            if instr is (x = e):
                // xä¸æ‰€æœ‰å½“å‰æ´»è·ƒå˜é‡å¹²æ¶‰
                for v in live:
                    if v != x:
                        graph.add_edge(x, v)
                
                live.discard(x)
                live.update(uses(e))
            elif instr is (x = Ï†(...)):
                // Ï†å‡½æ•°ç‰¹æ®Šå¤„ç†
                for v in live:
                    if v != x and v not in phi_args(instr):
                        graph.add_edge(x, v)
    
    return graph

/* åº”ç”¨3: æŒ‡ä»¤è°ƒåº¦ */

å®šç† (è°ƒåº¦ä¾èµ–):
å¦‚æœå˜é‡xåœ¨æŒ‡ä»¤iâ‚å®šä¹‰,åœ¨æŒ‡ä»¤iâ‚‚ä½¿ç”¨,
ä¸”xåœ¨iâ‚å’Œiâ‚‚ä¹‹é—´æ´»è·ƒ,
åˆ™iâ‚å¿…é¡»åœ¨iâ‚‚ä¹‹å‰æ‰§è¡Œ (æ•°æ®ä¾èµ–)
```

### 3.3 å¯è¾¾å®šä¹‰åˆ†æ

#### å¯è¾¾å®šä¹‰å®šä¹‰

```mathematical
/* å¯è¾¾å®šä¹‰åˆ†æ (Reaching Definitions) */

å®šä¹‰: å®šä¹‰dåœ¨ç¨‹åºç‚¹på¯è¾¾,å½“ä¸”ä»…å½“:
  âˆƒ è·¯å¾„ d â†’* p,ä½¿å¾—:
    - dæ˜¯å˜é‡xçš„å®šä¹‰
    - è·¯å¾„ä¸Šxæœªè¢«é‡æ–°å®šä¹‰

/* æ•°æ®æµæ–¹ç¨‹ */

OUT[B] = GEN[B] âˆª (IN[B] - KILL[B])
IN[B] = âˆª_{P âˆˆ pred(B)} OUT[P]

å…¶ä¸­:
- GEN[B]: Bä¸­ç”Ÿæˆçš„å®šä¹‰
- KILL[B]: Bä¸­æ€æ­»çš„å®šä¹‰
- IN[B]: Bå…¥å£çš„å¯è¾¾å®šä¹‰
- OUT[B]: Bå‡ºå£çš„å¯è¾¾å®šä¹‰

/* æ ¼å®šä¹‰ */

åŸŸ: D = P(Definitions)  /* å®šä¹‰çš„å¹‚é›† */
åº: âŠ† (å­é›†å…³ç³»)
æ±‡åˆ: âˆª (å¹¶é›†)
åˆå§‹: âˆ…

ä¼ é€’å‡½æ•°:
f_B(X) = GEN[B] âˆª (X - KILL[B])

/* è®¡ç®—GENå’ŒKILL */

function computeGenKill(block, all_defs):
    GEN = set()
    KILL = set()
    
    for instr in block.instructions:
        if instr is (x = e):
            // æ·»åŠ æ­¤å®šä¹‰åˆ°GEN
            GEN.add((x, instr))
            
            // æ€æ­»xçš„æ‰€æœ‰å…¶ä»–å®šä¹‰
            for (var, def) in all_defs:
                if var == x and def != instr:
                    KILL.add((var, def))
            
            // ä»GENä¸­ç§»é™¤è¢«æœ¬å—æ€æ­»çš„å®šä¹‰
            GEN = {(v, d) for (v, d) in GEN if v != x or d == instr}
    
    return GEN, KILL
```

#### å¯è¾¾å®šä¹‰åº”ç”¨

```mathematical
/* åº”ç”¨1: Use-Defé“¾æ„é€  */

function buildUseDefChains(CFG):
    IN, OUT = reachingDefinitionsAnalysis(CFG)
    
    use_def = {}  // ä½¿ç”¨ â†’ å¯èƒ½çš„å®šä¹‰é›†åˆ
    
    for block in CFG.blocks:
        reaching = IN[block].copy()
        
        for instr in block.instructions:
            for var in uses(instr):
                // æ‰¾åˆ°varçš„æ‰€æœ‰å¯è¾¾å®šä¹‰
                defs = {d for (v, d) in reaching if v == var}
                use_def[(instr, var)] = defs
            
            # æ›´æ–°å¯è¾¾å®šä¹‰
            reaching = (reaching - KILL[block]) âˆª GEN[block]
    
    return use_def

/* åº”ç”¨2: å¸¸é‡ä¼ æ’­ (Constant Propagation) */

function constantPropagation(CFG):
    use_def = buildUseDefChains(CFG)
    
    for (use_site, var), defs in use_def.items():
        if len(defs) == 1:
            def_instr = list(defs)[0]
            if def_instr is (var = constant):
                // æ›¿æ¢ä½¿ç”¨ä¸ºå¸¸é‡
                use_site.replace(var, constant)

/* åº”ç”¨3: å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤ */

function commonSubexpressionElimination(CFG):
    IN, OUT = reachingDefinitionsAnalysis(CFG)
    
    for block in CFG.blocks:
        available_exprs = {}
        
        for instr in block.instructions:
            if instr is (x = e):
                // æ£€æŸ¥eæ˜¯å¦å¯ç”¨
                expr_key = (e.op, tuple(e.operands))
                
                if expr_key in available_exprs:
                    // è¡¨è¾¾å¼å·²è®¡ç®—,å¤ç”¨
                    temp = available_exprs[expr_key]
                    replace_with(instr, x = temp)
                else:
                    // è®°å½•æ–°è¡¨è¾¾å¼
                    available_exprs[expr_key] = x
```

### 3.4 å¯ç”¨è¡¨è¾¾å¼åˆ†æ

#### å¯ç”¨è¡¨è¾¾å¼å®šä¹‰

```mathematical
/* å¯ç”¨è¡¨è¾¾å¼åˆ†æ (Available Expressions) */

å®šä¹‰: è¡¨è¾¾å¼eåœ¨ç¨‹åºç‚¹på¯ç”¨,å½“ä¸”ä»…å½“:
  - ä»entryåˆ°pçš„æ‰€æœ‰è·¯å¾„éƒ½è®¡ç®—è¿‡e
  - ä¸”è®¡ç®—åeçš„æ“ä½œæ•°æœªè¢«ä¿®æ”¹

/* æ•°æ®æµæ–¹ç¨‹ */

OUT[B] = GEN[B] âˆª (IN[B] - KILL[B])
IN[B] = âˆ©_{P âˆˆ pred(B)} OUT[P]

å…¶ä¸­:
- GEN[B]: Bä¸­è®¡ç®—çš„è¡¨è¾¾å¼
- KILL[B]: Bä¸­ä½¿æ“ä½œæ•°å¤±æ•ˆçš„è¡¨è¾¾å¼
- IN[B]: Bå…¥å£çš„å¯ç”¨è¡¨è¾¾å¼
- OUT[B]: Bå‡ºå£çš„å¯ç”¨è¡¨è¾¾å¼

/* æ ¼å®šä¹‰ */

åŸŸ: D = P(Expressions)
åº: âŠ† (å­é›†å…³ç³»)
æ±‡åˆ: âˆ© (äº¤é›†,å› ä¸ºæ˜¯Muståˆ†æ)
åˆå§‹: âˆ… (entry) æˆ– U (å…¶ä»–å—)

ä¼ é€’å‡½æ•°:
f_B(X) = GEN[B] âˆª (X - KILL[B])

/* è®¡ç®—GENå’ŒKILL */

function computeGenKill(block, all_exprs):
    GEN = set()
    KILL = set()
    
    for instr in block.instructions:
        if instr is (x = e):
            // æ€æ­»åŒ…å«xçš„æ‰€æœ‰è¡¨è¾¾å¼
            for expr in all_exprs:
                if x in operands(expr):
                    KILL.add(expr)
            
            // ç”Ÿæˆæ–°è¡¨è¾¾å¼e
            if is_expression(e):  // ä¸æ˜¯ç®€å•èµ‹å€¼
                GEN.add(e)
                GEN = GEN - KILL  // ç§»é™¤è¢«æ€æ­»çš„
    
    return GEN, KILL

/* ç®—æ³•å®ç° */

function availableExpressionsAnalysis(CFG):
    // æ”¶é›†æ‰€æœ‰è¡¨è¾¾å¼
    all_exprs = collect_all_expressions(CFG)
    
    // è®¡ç®—GENå’ŒKILL
    GEN = {}
    KILL = {}
    for block in CFG.blocks:
        GEN[block], KILL[block] = computeGenKill(block, all_exprs)
    
    // åˆå§‹åŒ–
    IN = {CFG.entry: set()}
    for block in CFG.blocks:
        if block != CFG.entry:
            IN[block] = all_exprs.copy()  // ä¿å®ˆä¼°è®¡
    
    OUT = {block: set() for block in CFG.blocks}
    
    // è¿­ä»£æ±‚è§£
    worklist = CFG.blocks.copy()
    
    while worklist:
        block = worklist.pop()
        
        # è®¡ç®—OUT[block]
        old_out = OUT[block]
        OUT[block] = GEN[block] âˆª (IN[block] - KILL[block])
        
        # å¦‚æœæ”¹å˜,æ›´æ–°åç»§
        if OUT[block] != old_out:
            for succ in successors(block):
                old_in = IN[succ]
                # äº¤é›†æ“ä½œ
                IN[succ] = IN[succ] âˆ© OUT[block]
                if IN[succ] != old_in:
                    worklist.add(succ)
    
    return IN, OUT
```

---

## ç¬¬å››éƒ¨åˆ†: Goç‰¹å®šæ§åˆ¶æµ

### 4.1 Deferè¯­å¥æ§åˆ¶æµ

```mathematical
/* Deferæ§åˆ¶æµå½¢å¼åŒ– */

// Deferæ ˆæ¨¡å‹
DeferStack = List[(func, captured_env)]

// å‡½æ•°çŠ¶æ€æ‰©å±•
FunctionState = (code, pc, locals, defer_stack)

/* Deferæ³¨å†Œè§„åˆ™ */

[CFG-Defer-Register]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨defer f(), pc, S, DâŸ© â†’ âŸ¨skip, pc+1, S, D.push((f, S))âŸ©

å…¶ä¸­:
- Sæ˜¯å½“å‰å±€éƒ¨å˜é‡çŠ¶æ€
- Dæ˜¯deferæ ˆ
- æ•è·å½“å‰ç¯å¢ƒ

/* Deferæ‰§è¡Œè§„åˆ™ (å‡½æ•°è¿”å›æ—¶) */

[CFG-Defer-Execute]
D = [(fâ‚, envâ‚), ..., (fâ‚™, envâ‚™)]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨return v, pc, S, DâŸ© â†’
  execute fâ‚™ in envâ‚™;
  execute fâ‚™â‚‹â‚ in envâ‚™â‚‹â‚;
  ...
  execute fâ‚ in envâ‚;
  return v

/* CFGè¡¨ç¤º */

å¯¹äºå‡½æ•°:
func example() {
    defer cleanup()
    // ... code ...
    return value
}

CFGè¡¨ç¤º:
B_entry:
    register_defer(cleanup)
    goto B_body

B_body:
    // ... code ...
    goto B_return

B_return:
    execute_defer_stack()  // ç‰¹æ®ŠèŠ‚ç‚¹
    return value

/* Deferä¸æ§åˆ¶æµäº¤äº’ */

1. Panicå‘ç”Ÿæ—¶:
   - ç«‹å³å¼€å§‹æ ˆå±•å¼€
   - æ‰§è¡Œå½“å‰å‡½æ•°çš„deferæ ˆ
   - ç»§ç»­å‘ä¸Šå±•å¼€

2. å¤šä¸ªdefer:
   - LIFOé¡ºåºæ‰§è¡Œ
   - æ¯ä¸ªdeferçœ‹åˆ°çš„æ˜¯æ³¨å†Œæ—¶çš„ç¯å¢ƒ

3. Deferä¸­çš„æ§åˆ¶æµ:
   - deferå‡½æ•°å¯ä»¥æœ‰è‡ªå·±çš„æ§åˆ¶æµ
   - å¯ä»¥è°ƒç”¨recover()æ”¹å˜æ§åˆ¶æµ
```

### 4.2 Panic/Recoveræ§åˆ¶æµ

```mathematical
/* Panic/Recoveræ§åˆ¶æµå½¢å¼åŒ– */

// æ‰©å±•çŠ¶æ€
State = Normal(pc, locals, defer_stack)
      | Panicking(value, defer_stack, call_stack)
      | Recovered(value, pc, locals)

/* Panicè§„åˆ™ */

[CFG-Panic]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨panic(v), pc, S, D, CallStackâŸ© â†’
  âŸ¨Panicking(v, D, CallStack)âŸ©

/* æ ˆå±•å¼€è§„åˆ™ */

[CFG-Unwind]
Panicking(v, [(f, env) | rest], [frame | frames])
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â†’ execute f in env;
  if recovered:
    â†’ Recovered(v, frame.pc, frame.locals)
  else:
    â†’ Panicking(v, rest, frames)

/* Recoverè§„åˆ™ */

[CFG-Recover-In-Defer]
context = defer_execution âˆ§ panicking
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
recover() â†’ Some(panic_value)

[CFG-Recover-Normal]
context â‰  defer_execution âˆ¨ Â¬panicking
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
recover() â†’ None

/* CFGç¤ºä¾‹: Panicå¤„ç† */

func safeDivide(a, b int) int {
    defer func() {
        if r := recover(); r != nil {
            return 0  // æ•è·å¹¶æ¢å¤
        }
    }()
    
    if b == 0 {
        panic("division by zero")
    }
    return a / b
}

CFG:
B1: register_defer(recover_func)
    goto B2

B2: t1 = (b == 0)
    branch t1, B3, B4

B3: panic("division by zero")  // ç‰¹æ®Š:è§¦å‘æ ˆå±•å¼€
    /* ä¸å¯è¾¾ */

B4: result = a / b
    goto B5

B5: execute_defers()
    return result

Unwind_Path (when panic):
B3 â†’ execute_defers() â†’ check recover()
  if recovered:
    â†’ continue to B5
  else:
    â†’ propagate to caller
```

### 4.3 Goroutineåˆ›å»ºæ§åˆ¶æµ

```mathematical
/* Goroutineåˆ›å»ºçš„æ§åˆ¶æµæ•ˆåº” */

[CFG-Go]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨go f(), pc, S, GPoolâŸ© â†’
  âŸ¨skip, pc+1, S, GPool âˆª {new_goroutine(f, S)}âŸ©

å…¶ä¸­:
- GPoolæ˜¯å…¨å±€goroutineæ± 
- new_goroutineåˆ›å»ºæ–°çš„æ§åˆ¶æµçº¿ç¨‹

/* å¤šçº¿ç¨‹CFG (mCFG) */

mCFG = (Threads, SharedMemory)

Threads = {(tid, CFG_i, locals_i) | i = 1..n}

æ§åˆ¶æµè§„åˆ™:
1. æ¯ä¸ªgoroutineæœ‰ç‹¬ç«‹çš„CFG
2. å…±äº«å†…å­˜æ“ä½œå¯èƒ½äº¤é”™
3. Channelæ“ä½œå¼•å…¥åŒæ­¥ç‚¹

/* å¹¶å‘æ§åˆ¶æµå›¾ */

å¯¹äº:
func main() {
    x := 0
    go func() {
        x = 1
    }()
    go func() {
        x = 2
    }()
    print(x)
}

å¹¶å‘CFG:
Main Thread:
  B1: x = 0
      spawn G1
      spawn G2
      goto B2
  B2: print(x)

G1:
  B1: x = 1  // å¯èƒ½ä¸Main B2äº¤é”™

G2:
  B1: x = 2  // å¯èƒ½ä¸Main B2äº¤é”™

/* Happens-Beforeè¾¹ */

åœ¨mCFGä¸­æ·»åŠ happens-beforeè¾¹:
- go stmt â†’ goroutine start
- channel send â†’ corresponding receive
- mutex unlock â†’ next mutex lock
```

### 4.4 Selectè¯­å¥æ§åˆ¶æµ

```mathematical
/* Selectè¯­å¥çš„éç¡®å®šæ€§æ§åˆ¶æµ */

select {
case ch1 <- v:
    // case 1
case x := <-ch2:
    // case 2
case <-ch3:
    // case 3
default:
    // default
}

/* å½¢å¼åŒ–è¯­ä¹‰ */

[CFG-Select]
ready_cases = {i | case_i is ready}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨select {...}, pc, SâŸ© â†’
  if ready_cases â‰  âˆ…:
    i = nondeterministic_choice(ready_cases)
    âŸ¨execute case_i, pc_i, SâŸ©
  elif has_default:
    âŸ¨execute default, pc_default, SâŸ©
  else:
    âŸ¨block, pc, SâŸ©  // é˜»å¡

/* CFGè¡¨ç¤º (éç¡®å®šæ€§) */

B_select_entry:
    evaluate all channel expressions
    goto B_select_check

B_select_check:
    // éç¡®å®šæ€§åˆ†æ”¯
    if ch1 is ready: goto B_case1
    if ch2 is ready: goto B_case2
    if ch3 is ready: goto B_case3
    if has_default: goto B_default
    else: block and retry

B_case1:
    ch1 <- v
    // case 1 body
    goto B_select_exit

B_case2:
    x = <-ch2
    // case 2 body
    goto B_select_exit

B_case3:
    <-ch3
    // case 3 body
    goto B_select_exit

B_default:
    // default body
    goto B_select_exit

B_select_exit:
    // ç»§ç»­åç»­ä»£ç 

/* å»ºæ¨¡éç¡®å®šæ€§ */

åœ¨é™æ€åˆ†æä¸­:
1. Muståˆ†æ: è€ƒè™‘æ‰€æœ‰å¯èƒ½è·¯å¾„çš„äº¤é›†
2. Mayåˆ†æ: è€ƒè™‘æ‰€æœ‰å¯èƒ½è·¯å¾„çš„å¹¶é›†

ä¾‹å¦‚æ´»è·ƒå˜é‡åˆ†æ:
OUT[B_select_check] = 
  IN[B_case1] âˆª IN[B_case2] âˆª IN[B_case3] âˆª IN[B_default]
```

---

## ç¬¬äº”éƒ¨åˆ†: æŠ½è±¡è§£é‡Š

### 5.1 æŠ½è±¡è§£é‡Šç†è®º

```mathematical
/* æŠ½è±¡è§£é‡Š (Abstract Interpretation) */

åŸºæœ¬æ€æƒ³:
- å…·ä½“åŸŸ (Concrete Domain): ç¨‹åºçš„å®é™…å€¼
- æŠ½è±¡åŸŸ (Abstract Domain): å€¼çš„æŠ½è±¡è¡¨ç¤º
- é€šè¿‡æŠ½è±¡åŸŸè¿›è¡Œè¿‘ä¼¼æ¨ç†

/* Galoisè¿æ¥ */

è®¾ (C, âŠ‘_C) æ˜¯å…·ä½“åŸŸ, (A, âŠ‘_A) æ˜¯æŠ½è±¡åŸŸ

æŠ½è±¡å‡½æ•°: Î±: C â†’ A
å…·ä½“åŒ–å‡½æ•°: Î³: A â†’ C

Galoisè¿æ¥: (Î±, Î³) æ»¡è¶³:
âˆ€c âˆˆ C, a âˆˆ A. Î±(c) âŠ‘_A a âŸº c âŠ‘_C Î³(a)

æ€§è´¨:
1. Î± âˆ˜ Î³ âŠ‘ id_A  /* æŠ½è±¡åå…·ä½“åŒ–ä¸è¶…è¿‡åŸå€¼ */
2. id_C âŠ‘ Î³ âˆ˜ Î±  /* å…·ä½“åŒ–åæŠ½è±¡ä¸ä¸¢ä¿¡æ¯ */

/* æŠ½è±¡è§£é‡Šæ¡†æ¶ */

å…·ä½“è¯­ä¹‰: âŸ¦stmtâŸ§_C : C â†’ C
æŠ½è±¡è¯­ä¹‰: âŸ¦stmtâŸ§_A : A â†’ A

æ­£ç¡®æ€§æ¡ä»¶:
âŸ¦stmtâŸ§_A âˆ˜ Î± âŠ’ Î± âˆ˜ âŸ¦stmtâŸ§_C

æˆ–ç­‰ä»·åœ°:
Î±(âŸ¦stmtâŸ§_C(Î³(a))) âŠ‘ âŸ¦stmtâŸ§_A(a)

/* æŠ½è±¡åŸŸç¤ºä¾‹ */

1. ç¬¦å·åŸŸ (Sign):
   A_sign = {âŠ¥, negative, zero, positive, âŠ¤}
   âŠ¥ âŠ‘ negative âŠ‘ âŠ¤
   âŠ¥ âŠ‘ zero âŠ‘ âŠ¤
   âŠ¥ âŠ‘ positive âŠ‘ âŠ¤

2. åŒºé—´åŸŸ (Interval):
   A_interval = {[a, b] | a âˆˆ â„¤ âˆª {-âˆ}, b âˆˆ â„¤ âˆª {+âˆ}, a â‰¤ b}

3. å¤šé¢ä½“åŸŸ (Polyhedra):
   A_poly = {P | P = {x | Ax â‰¤ b}}

/* æŠ½è±¡æ“ä½œå®šä¹‰ */

åŠ æ³•çš„æŠ½è±¡:
âŸ¦x + yâŸ§_sign = 
  positive âŠ• positive = positive
  negative âŠ• negative = negative
  positive âŠ• negative = âŠ¤
  ...

åŒºé—´åŠ æ³•:
[a,b] âŠ• [c,d] = [a+c, b+d]

ä¹˜æ³•:
[a,b] âŠ— [c,d] = [min(ac,ad,bc,bd), max(ac,ad,bc,bd)]
```

### 5.2 ç¬¦å·æ‰§è¡Œ

```mathematical
/* ç¬¦å·æ‰§è¡Œ (Symbolic Execution) */

åŸºæœ¬æ€æƒ³:
- ç”¨ç¬¦å·å€¼ä»£æ›¿å…·ä½“å€¼
- ç»´æŠ¤è·¯å¾„çº¦æŸ
- æ¢ç´¢æ‰€æœ‰å¯èƒ½è·¯å¾„

/* ç¬¦å·çŠ¶æ€ */

SymbolicState = (symbolic_store, path_condition)

å…¶ä¸­:
- symbolic_store: Var â†’ SymbolicExpr
- path_condition: List[Constraint]

/* ç¬¦å·æ‰§è¡Œè§„åˆ™ */

[Sym-Assign]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨x = e, Ïƒ_sym, Ï€âŸ© â†’ âŸ¨skip, Ïƒ_sym[x â†¦ eval_sym(e, Ïƒ_sym)], Ï€âŸ©

[Sym-Branch]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨branch cond Lâ‚ Lâ‚‚, Ïƒ_sym, Ï€âŸ© â†’
  // Forkä¸¤æ¡è·¯å¾„
  Path 1: âŸ¨goto Lâ‚, Ïƒ_sym, Ï€ âˆ§ condâŸ©
  Path 2: âŸ¨goto Lâ‚‚, Ïƒ_sym, Ï€ âˆ§ Â¬condâŸ©

[Sym-Assert]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨assert e, Ïƒ_sym, Ï€âŸ© â†’
  if SAT(Ï€ âˆ§ e):
    âŸ¨skip, Ïƒ_sym, Ï€ âˆ§ eâŸ©
  else:
    error("assertion violation")

/* ç¬¦å·æ‰§è¡Œç®—æ³• */

function symbolicExecution(program):
    worklist = [(entry, {}, true)]  // (pc, store, path_cond)
    explored = set()
    errors = []
    
    while worklist:
        (pc, Ïƒ_sym, Ï€) = worklist.pop()
        
        if (pc, Ïƒ_sym, Ï€) in explored:
            continue
        explored.add((pc, Ïƒ_sym, Ï€))
        
        stmt = program[pc]
        
        match stmt:
            case (x = e):
                Ïƒ_sym' = Ïƒ_sym.copy()
                Ïƒ_sym'[x] = eval_symbolic(e, Ïƒ_sym)
                worklist.append((pc+1, Ïƒ_sym', Ï€))
            
            case branch(cond, Lâ‚, Lâ‚‚):
                cond_sym = eval_symbolic(cond, Ïƒ_sym)
                
                # æ£€æŸ¥trueåˆ†æ”¯å¯è¡Œæ€§
                if SAT(Ï€ âˆ§ cond_sym):
                    worklist.append((Lâ‚, Ïƒ_sym, Ï€ âˆ§ cond_sym))
                
                # æ£€æŸ¥falseåˆ†æ”¯å¯è¡Œæ€§
                if SAT(Ï€ âˆ§ Â¬cond_sym):
                    worklist.append((Lâ‚‚, Ïƒ_sym, Ï€ âˆ§ Â¬cond_sym))
            
            case assert(e):
                e_sym = eval_symbolic(e, Ïƒ_sym)
                if not SAT(Ï€ âˆ§ e_sym):
                    errors.append((pc, Ï€, "assertion failure"))
            
            case return:
                # è·¯å¾„æ¢ç´¢å®Œæˆ
                pass
    
    return errors

/* åº”ç”¨: æµ‹è¯•ç”¨ä¾‹ç”Ÿæˆ */

function generateTestCases(program, coverage_goal):
    test_cases = []
    
    # ç¬¦å·æ‰§è¡Œæ‰¾åˆ°æ‰€æœ‰è·¯å¾„
    paths = symbolicExecution(program)
    
    for (path, path_condition) in paths:
        if covers(path, coverage_goal):
            # æ±‚è§£è·¯å¾„çº¦æŸ
            model = SMT_solve(path_condition)
            if model:
                test_cases.append(model)
    
    return test_cases
```

### 5.3 åŒºé—´åˆ†æ

```mathematical
/* åŒºé—´åˆ†æ (Interval Analysis) */

/* åŒºé—´åŸŸ */

Interval = [a, b] where a, b âˆˆ â„¤ âˆª {-âˆ, +âˆ} âˆ§ a â‰¤ b

ç‰¹æ®Šå€¼:
- âŠ¥ = ç©ºåŒºé—´ (ä¸å¯èƒ½çš„å€¼)
- âŠ¤ = [-âˆ, +âˆ] (ä»»æ„å€¼)

/* åŒºé—´æ“ä½œ */

[aâ‚,bâ‚] âŠ” [aâ‚‚,bâ‚‚] = [min(aâ‚,aâ‚‚), max(bâ‚,bâ‚‚)]  /* join */

[aâ‚,bâ‚] âŠ“ [aâ‚‚,bâ‚‚] = [max(aâ‚,aâ‚‚), min(bâ‚,bâ‚‚)]  /* meet */

[aâ‚,bâ‚] + [aâ‚‚,bâ‚‚] = [aâ‚+aâ‚‚, bâ‚+bâ‚‚]

[aâ‚,bâ‚] - [aâ‚‚,bâ‚‚] = [aâ‚-bâ‚‚, bâ‚-aâ‚‚]

[aâ‚,bâ‚] Ã— [aâ‚‚,bâ‚‚] = 
  [min(aâ‚aâ‚‚,aâ‚bâ‚‚,bâ‚aâ‚‚,bâ‚bâ‚‚), max(aâ‚aâ‚‚,aâ‚bâ‚‚,bâ‚aâ‚‚,bâ‚bâ‚‚)]

/* é™¤æ³• */
[a,b] / [c,d] = 
  if 0 âˆˆ [c,d]:
    âŠ¤  // ä¿å®ˆä¼°è®¡
  else:
    [min(a/c,a/d,b/c,b/d), max(a/c,a/d,b/c,b/d)]

/* åŒºé—´åˆ†æç®—æ³• */

function intervalAnalysis(CFG):
    // åˆå§‹åŒ–
    interval_map = {v: âŠ¤ for v in variables}
    
    // å¯¹entryå—çš„å‚æ•°,ä½¿ç”¨ç±»å‹ä¿¡æ¯
    for param in entry_params:
        if param.type == uint8:
            interval_map[param] = [0, 255]
        elif param.type == int32:
            interval_map[param] = [-2^31, 2^31-1]
    
    # è¿­ä»£è®¡ç®—
    worklist = [entry_block]
    
    while worklist:
        block = worklist.pop()
        
        for instr in block.instructions:
            if instr is (x = e):
                old_interval = interval_map[x]
                new_interval = eval_interval(e, interval_map)
                
                if new_interval != old_interval:
                    interval_map[x] = new_interval
                    worklist.extend(successors(block))
            
            elif instr is branch(cond, Lâ‚, Lâ‚‚):
                # ç²¾åŒ– (Refinement)
                if cond is (x < c):
                    # trueåˆ†æ”¯: x âˆˆ [-âˆ, c-1]
                    interval_map_true = interval_map.copy()
                    interval_map_true[x] = interval_map[x] âŠ“ [-âˆ, c-1]
                    
                    # falseåˆ†æ”¯: x âˆˆ [c, +âˆ]
                    interval_map_false = interval_map.copy()
                    interval_map_false[x] = interval_map[x] âŠ“ [c, +âˆ]
    
    return interval_map

/* åº”ç”¨: æ•°ç»„è¶Šç•Œæ£€æµ‹ */

function checkArrayBounds(CFG):
    intervals = intervalAnalysis(CFG)
    errors = []
    
    for block in CFG.blocks:
        for instr in block.instructions:
            if instr is (x = arr[i]):
                arr_len = length_of(arr)
                i_interval = intervals[i]
                
                # æ£€æŸ¥ä¸‹ç•Œ
                if i_interval.lower < 0:
                    errors.append("possible negative index")
                
                # æ£€æŸ¥ä¸Šç•Œ
                if i_interval.upper >= arr_len:
                    errors.append("possible out-of-bounds access")
    
    return errors

/* åŠ å®½æ“ä½œ (Widening) */

ä¸ºäº†ä¿è¯å¾ªç¯åˆ†æç»ˆæ­¢,å®šä¹‰åŠ å®½æ“ä½œ:

[aâ‚,bâ‚] âˆ‡ [aâ‚‚,bâ‚‚] = [
    (aâ‚‚ < aâ‚) ? -âˆ : aâ‚,
    (bâ‚‚ > bâ‚) ? +âˆ : bâ‚
]

æ€§è´¨:
1. [a,b] âŠ‘ [a,b] âˆ‡ [c,d]
2. [c,d] âŠ‘ [a,b] âˆ‡ [c,d]
3. åºåˆ— xâ‚€, xâ‚€ âˆ‡ xâ‚, (xâ‚€ âˆ‡ xâ‚) âˆ‡ xâ‚‚, ... æœ€ç»ˆç¨³å®š

åº”ç”¨äºå¾ªç¯:
æ¯æ¬¡è¿­ä»£ä½¿ç”¨ âˆ‡ è€Œé âŠ”,ä¿è¯æœ‰é™æ­¥ç»ˆæ­¢
```

---

## ç¬¬å…­éƒ¨åˆ†: ç¼–è¯‘å™¨ä¼˜åŒ–

### 6.1 æ­»ä»£ç æ¶ˆé™¤

```mathematical
/* æ­»ä»£ç æ¶ˆé™¤ (Dead Code Elimination, DCE) */

å®šä¹‰: æ­»ä»£ç æ˜¯æŒ‡:
1. ä¸å¯è¾¾ä»£ç  (Unreachable Code)
2. æ­»èµ‹å€¼ (Dead Assignment): èµ‹å€¼åå˜é‡ä¸å†ä½¿ç”¨

/* ä¸å¯è¾¾ä»£ç æ¶ˆé™¤ */

function eliminateUnreachableCode(CFG):
    # ä»entryå¼€å§‹DFS
    reachable = set()
    stack = [CFG.entry]
    
    while stack:
        block = stack.pop()
        if block not in reachable:
            reachable.add(block)
            stack.extend(successors(block))
    
    # åˆ é™¤ä¸å¯è¾¾å—
    for block in CFG.blocks:
        if block not in reachable:
            CFG.remove_block(block)

/* æ­»èµ‹å€¼æ¶ˆé™¤ */

function eliminateDeadAssignments(CFG):
    # æ´»è·ƒå˜é‡åˆ†æ
    IN, OUT = livenessAnalysis(CFG)
    
    for block in CFG.blocks:
        live = OUT[block].copy()
        
        for instr in reversed(block.instructions):
            if instr is (x = e):
                if x not in live:
                    # xä¸æ´»è·ƒ,åˆ é™¤èµ‹å€¼
                    remove(instr)
                else:
                    # æ›´æ–°æ´»è·ƒé›†
                    live.discard(x)
                    live.update(uses(e))
            else:
                live.update(uses(instr))

/* å¼ºåº¦å‰Šå¼± (ç¤ºä¾‹) */

ä¼˜åŒ–: x * 2 â†’ x << 1
ä¼˜åŒ–: x / 8 â†’ x >> 3

function strengthReduction(CFG):
    for block in CFG.blocks:
        for instr in block.instructions:
            if instr is (x = y * c):
                if is_power_of_2(c):
                    shift = log2(c)
                    replace_with(instr, x = y << shift)
```

### 6.2 å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤

```mathematical
/* å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤ (Common Subexpression Elimination, CSE) */

/* å±€éƒ¨CSE (Local CSE) */

function localCSE(block):
    available = {}  // expr â†’ temp_var
    
    for instr in block.instructions:
        if instr is (x = e):
            expr_key = canonicalize(e)
            
            if expr_key in available:
                # è¡¨è¾¾å¼å·²è®¡ç®—
                temp = available[expr_key]
                replace_with(instr, x = temp)
            else:
                # è®°å½•æ–°è¡¨è¾¾å¼
                available[expr_key] = x
        
        elif instr modifies any var in available.values():
            # å¤±æ•ˆç›¸å…³è¡¨è¾¾å¼
            available = {k: v for k, v in available.items()
                        if not uses(k, modified_var)}

/* å…¨å±€CSE (Global CSE) */

function globalCSE(CFG):
    # å¯ç”¨è¡¨è¾¾å¼åˆ†æ
    IN, OUT = availableExpressionsAnalysis(CFG)
    
    # å¯¹æ¯ä¸ªå—è¿›è¡ŒCSE
    for block in CFG.blocks:
        available = IN[block].copy()
        temp_map = {}  // expr â†’ temp_var
        
        for instr in block.instructions:
            if instr is (x = e):
                expr_key = canonicalize(e)
                
                if expr_key in available:
                    if expr_key in temp_map:
                        # å¤ç”¨å·²æœ‰ä¸´æ—¶å˜é‡
                        replace_with(instr, x = temp_map[expr_key])
                    else:
                        # åˆ›å»ºæ–°ä¸´æ—¶å˜é‡
                        temp = fresh_temp()
                        # åœ¨æ”¯é…ç‚¹æ’å…¥: temp = e
                        dom_block = find_dominator_with_expr(expr_key, block)
                        insert_at_end(dom_block, temp = e)
                        replace_with(instr, x = temp)
                        temp_map[expr_key] = temp
                else:
                    # æ–°è¡¨è¾¾å¼
                    available.add(expr_key)
                    temp_map[expr_key] = x

/* CSEæ­£ç¡®æ€§è¯æ˜ */

å®šç† (CSEæ­£ç¡®æ€§):
å¦‚æœè¡¨è¾¾å¼eåœ¨ç¨‹åºç‚¹på¯ç”¨,
åˆ™ç”¨å…ˆå‰è®¡ç®—çš„ç»“æœæ›¿æ¢eæ˜¯å®‰å…¨çš„ã€‚

è¯æ˜:
eå¯ç”¨ â‡’ 
  ä»entryåˆ°pçš„æ‰€æœ‰è·¯å¾„éƒ½è®¡ç®—è¿‡e âˆ§
  eçš„æ“ä½œæ•°æœªè¢«ä¿®æ”¹ â‡’
  eçš„å€¼åœ¨på¤„ä¸å…ˆå‰è®¡ç®—ç›¸åŒ â‡’
  æ›¿æ¢å®‰å…¨ â–¡
```

### 6.3 å¾ªç¯ä¼˜åŒ–

```mathematical
/* å¾ªç¯ä¸å˜ä»£ç å¤–æ (Loop-Invariant Code Motion, LICM) */

function loopInvariantCodeMotion(CFG, loop):
    # è¯†åˆ«å¾ªç¯ä¸å˜è®¡ç®—
    invariant_instrs = []
    
    for block in loop.blocks:
        for instr in block.instructions:
            if instr is (x = e):
                if is_loop_invariant(e, loop):
                    invariant_instrs.append(instr)
    
    # æ£€æŸ¥æ”¯é…å…³ç³»
    for instr in invariant_instrs:
        # instrå®šä¹‰çš„å˜é‡å¿…é¡»æ”¯é…æ‰€æœ‰ä½¿ç”¨ç‚¹
        if dominates_all_uses(instr, loop):
            # ç§»åˆ°preheader
            move_to_preheader(instr, loop)

function is_loop_invariant(expr, loop):
    for operand in operands(expr):
        if is_defined_in_loop(operand, loop):
            return false
    return true

/* å¾ªç¯å±•å¼€ (Loop Unrolling) */

function loopUnrolling(CFG, loop, factor):
    header = loop.header
    body = loop.body
    
    # åˆ›å»ºfactor-1ä»½å¾ªç¯ä½“å‰¯æœ¬
    for i in range(factor - 1):
        body_copy = duplicate(body)
        insert_after(body, body_copy)
    
    # æ›´æ–°å¾ªç¯è®¡æ•°å™¨
    for instr in loop.body:
        if instr is (i = i + 1):
            replace_with(instr, i = i + factor)

ç¤ºä¾‹:
// åŸå¾ªç¯
for i = 0; i < n; i++:
    a[i] = b[i] + c[i]

// å±•å¼€2æ¬¡
for i = 0; i < n; i += 2:
    a[i] = b[i] + c[i]
    a[i+1] = b[i+1] + c[i+1]

/* å¾ªç¯èåˆ (Loop Fusion) */

function loopFusion(loop1, loop2):
    # æ¡ä»¶: ç›¸åŒè¿­ä»£ç©ºé—´,æ— æ•°æ®ä¾èµ–
    if same_iteration_space(loop1, loop2) and
       no_dependency(loop1, loop2):
        # åˆå¹¶å¾ªç¯ä½“
        fused_loop = create_loop(
            header = loop1.header,
            body = loop1.body + loop2.body
        )
        
        replace(loop1, fused_loop)
        remove(loop2)

/* å¾ªç¯åˆ†è£‚ (Loop Fission) */

function loopFission(loop, split_point):
    # å°†å¾ªç¯åˆ†æˆä¸¤ä¸ªç‹¬ç«‹å¾ªç¯
    body1, body2 = split(loop.body, split_point)
    
    loop1 = create_loop(loop.header, body1)
    loop2 = create_loop(loop.header, body2)
    
    replace(loop, [loop1, loop2])

/* å‘é‡åŒ– (Vectorization) */

function vectorization(loop, vector_width):
    # æ£€æŸ¥å‘é‡åŒ–æ¡ä»¶
    if not is_vectorizable(loop):
        return
    
    # è½¬æ¢æ ‡é‡æ“ä½œä¸ºå‘é‡æ“ä½œ
    for instr in loop.body:
        if instr is (a[i] = b[i] + c[i]):
            replace_with(instr, 
                vector_add(a[i:i+vector_width], 
                          b[i:i+vector_width], 
                          c[i:i+vector_width]))
    
    # æ›´æ–°å¾ªç¯è®¡æ•°
    loop.increment *= vector_width

ç¤ºä¾‹:
// åŸå¾ªç¯
for i = 0; i < n; i++:
    a[i] = b[i] * c[i]

// å‘é‡åŒ– (width=4)
for i = 0; i < n; i += 4:
    a[i:i+4] = b[i:i+4] * c[i:i+4]  // SIMDæŒ‡ä»¤
```

---

## ğŸ¯ æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†Goè¯­è¨€æ§åˆ¶æµçš„å®Œæ•´å½¢å¼åŒ–åˆ†æ:

### æ ¸å¿ƒå†…å®¹

1. **æ§åˆ¶æµå›¾ç†è®º**
   - åŸºæœ¬å—æ„é€ 
   - æ”¯é…å…³ç³»ä¸æ”¯é…æ ‘
   - å¾ªç¯ç»“æ„è¯†åˆ«

2. **SSAå½¢å¼**
   - SSAå®šä¹‰ä¸æ€§è´¨
   - Ï†å‡½æ•°è¯­ä¹‰
   - SSAæ„é€ ä¸è§£æ„ç®—æ³•

3. **æ•°æ®æµåˆ†æ**
   - æ´»è·ƒå˜é‡åˆ†æ
   - å¯è¾¾å®šä¹‰åˆ†æ
   - å¯ç”¨è¡¨è¾¾å¼åˆ†æ

4. **Goç‰¹å®šæ§åˆ¶æµ**
   - Deferæ§åˆ¶æµ
   - Panic/Recoveræ§åˆ¶æµ
   - Goroutineä¸Selectæ§åˆ¶æµ

5. **æŠ½è±¡è§£é‡Š**
   - ç¬¦å·æ‰§è¡Œ
   - åŒºé—´åˆ†æ
   - æŠ½è±¡åŸŸç†è®º

6. **ç¼–è¯‘å™¨ä¼˜åŒ–**
   - æ­»ä»£ç æ¶ˆé™¤
   - å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤
   - å¾ªç¯ä¼˜åŒ–

### ç†è®ºä»·å€¼

- ä¸ºGoç¼–è¯‘å™¨æä¾›ç†è®ºåŸºç¡€
- æ”¯æŒé™æ€åˆ†æå·¥å…·å¼€å‘
- æŒ‡å¯¼ç¨‹åºä¼˜åŒ–æŠ€æœ¯

### å®è·µåº”ç”¨

- ç¼–è¯‘å™¨å®ç°
- é™æ€åˆ†æå·¥å…·
- ç¨‹åºéªŒè¯
- æ€§èƒ½ä¼˜åŒ–

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**åŸºå‡†æ—¥æœŸ**: 2025å¹´10æœˆ23æ—¥  
**Goç‰ˆæœ¬**: Go 1.25.3  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ

---

<div align="center">

Made with â¤ï¸ for Go Compiler Researchers

[â¬† å›åˆ°é¡¶éƒ¨](#go-æ§åˆ¶æµå½¢å¼åŒ–å®Œæ•´åˆ†æ)

</div>
