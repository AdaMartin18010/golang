# Go 1.25.3 äº‘åŸç”Ÿéƒ¨ç½²å®Œæ•´å®æˆ˜

**æ–‡æ¡£ç±»å‹**: äº‘åŸç”Ÿéƒ¨ç½²æŒ‡å—  
**Goç‰ˆæœ¬**: Go 1.25.3  
**éš¾åº¦ç­‰çº§**: â­â­â­â­â­ (ä¸“å®¶çº§)  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ22æ—¥

---

## ğŸ“– æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£å±•ç¤ºGo 1.25.3åº”ç”¨çš„**äº‘åŸç”Ÿéƒ¨ç½²å®Œæ•´æ–¹æ¡ˆ**ï¼Œä»å®¹å™¨åŒ–åˆ°Kubernetesç”Ÿäº§éƒ¨ç½²ï¼š

- âœ… Dockerå®¹å™¨åŒ–æœ€ä½³å®è·µ
- âœ… Kuberneteséƒ¨ç½²é…ç½®
- âœ… Helm Chartsç®¡ç†
- âœ… CI/CDè‡ªåŠ¨åŒ–éƒ¨ç½²
- âœ… æœåŠ¡ç½‘æ ¼ï¼ˆService Meshï¼‰
- âœ… ç›‘æ§ä¸æ—¥å¿—
- âœ… é«˜å¯ç”¨ä¸è‡ªåŠ¨æ‰©ç¼©å®¹

---

## ç›®å½•

- [Go 1.25.3 äº‘åŸç”Ÿéƒ¨ç½²å®Œæ•´å®æˆ˜](#go-1253-äº‘åŸç”Ÿéƒ¨ç½²å®Œæ•´å®æˆ˜)
  - [ğŸ“– æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. Dockerå®¹å™¨åŒ–](#1-dockerå®¹å™¨åŒ–)
    - [1.1 å¤šé˜¶æ®µæ„å»ºDockerfile](#11-å¤šé˜¶æ®µæ„å»ºdockerfile)
    - [1.2 .dockerignoreä¼˜åŒ–](#12-dockerignoreä¼˜åŒ–)
    - [1.3 Docker Composeæœ¬åœ°å¼€å‘](#13-docker-composeæœ¬åœ°å¼€å‘)
  - [2. KubernetesåŸºç¡€éƒ¨ç½²](#2-kubernetesåŸºç¡€éƒ¨ç½²)
    - [2.1 Deploymenté…ç½®](#21-deploymenté…ç½®)
    - [2.2 Serviceé…ç½®](#22-serviceé…ç½®)
    - [2.3 Ingressé…ç½®](#23-ingressé…ç½®)
    - [2.4 ConfigMapä¸Secret](#24-configmapä¸secret)
  - [3. Helm Chartsç®¡ç†](#3-helm-chartsç®¡ç†)
    - [3.1 Helm Chartç»“æ„](#31-helm-chartç»“æ„)
    - [3.2 Chart.yaml](#32-chartyaml)
    - [3.3 values.yaml](#33-valuesyaml)
    - [3.4 éƒ¨ç½²å‘½ä»¤](#34-éƒ¨ç½²å‘½ä»¤)
  - [4. CI/CDè‡ªåŠ¨åŒ–](#4-cicdè‡ªåŠ¨åŒ–)
    - [4.1 GitHub Actions](#41-github-actions)
    - [4.2 GitLab CI](#42-gitlab-ci)
  - [5. æœåŠ¡ç½‘æ ¼Istio](#5-æœåŠ¡ç½‘æ ¼istio)
    - [5.1 Istio Gateway](#51-istio-gateway)
    - [5.2 VirtualService](#52-virtualservice)
    - [5.3 DestinationRule](#53-destinationrule)
  - [6. ç›‘æ§ä¸æ—¥å¿—](#6-ç›‘æ§ä¸æ—¥å¿—)
    - [6.1 Prometheus ServiceMonitor](#61-prometheus-servicemonitor)
    - [6.2 åº”ç”¨ç›‘æ§ä»£ç ](#62-åº”ç”¨ç›‘æ§ä»£ç )
  - [7. é«˜å¯ç”¨ä¸æ‰©ç¼©å®¹](#7-é«˜å¯ç”¨ä¸æ‰©ç¼©å®¹)
    - [7.1 HorizontalPodAutoscaler](#71-horizontalpodautoscaler)
    - [7.2 PodDisruptionBudget](#72-poddisruptionbudget)
  - [8. å®Œæ•´æ¡ˆä¾‹](#8-å®Œæ•´æ¡ˆä¾‹)
    - [8.1 å¥åº·æ£€æŸ¥å®ç°](#81-å¥åº·æ£€æŸ¥å®ç°)
  - [ğŸ“š äº‘åŸç”Ÿæœ€ä½³å®è·µ](#-äº‘åŸç”Ÿæœ€ä½³å®è·µ)
    - [Dockeræœ€ä½³å®è·µ](#dockeræœ€ä½³å®è·µ)
    - [Kubernetesæœ€ä½³å®è·µ](#kubernetesæœ€ä½³å®è·µ)
    - [ç›‘æ§ä¸å¯è§‚æµ‹æ€§](#ç›‘æ§ä¸å¯è§‚æµ‹æ€§)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

---

## 1. Dockerå®¹å™¨åŒ–

### 1.1 å¤šé˜¶æ®µæ„å»ºDockerfile

**æœ€ä½³å®è·µDockerfile**:

```dockerfile
# ç¬¬ä¸€é˜¶æ®µï¼šæ„å»º
FROM golang:1.25.3-alpine AS builder

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /build

# å®‰è£…å¿…è¦å·¥å…·
RUN apk add --no-cache git ca-certificates tzdata

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY go.mod go.sum ./
RUN go mod download

# å¤åˆ¶æºä»£ç 
COPY . .

# æ„å»ºåº”ç”¨
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
    -ldflags="-w -s" \
    -o app \
    ./cmd/server

# ç¬¬äºŒé˜¶æ®µï¼šè¿è¡Œ
FROM scratch

# ä»builderå¤åˆ¶å¿…è¦æ–‡ä»¶
COPY --from=builder /usr/share/zoneinfo /usr/share/zoneinfo
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
COPY --from=builder /build/app /app

# å¤åˆ¶é…ç½®æ–‡ä»¶
COPY --from=builder /build/configs /configs

# æš´éœ²ç«¯å£
EXPOSE 8080

# å¥åº·æ£€æŸ¥
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD ["/app", "healthcheck"]

# è¿è¡Œåº”ç”¨
ENTRYPOINT ["/app"]
```

**ä¼˜åŒ–ç‚¹**:

- âœ… å¤šé˜¶æ®µæ„å»ºå‡å°é•œåƒä½“ç§¯ï¼ˆfrom 800MB â†’ 20MBï¼‰
- âœ… ä½¿ç”¨scratchåŸºç¡€é•œåƒ
- âœ… é™æ€ç¼–è¯‘ï¼ˆCGO_ENABLED=0ï¼‰
- âœ… ç§»é™¤è°ƒè¯•ä¿¡æ¯ï¼ˆ-ldflags="-w -s"ï¼‰
- âœ… å†…ç½®å¥åº·æ£€æŸ¥

---

### 1.2 .dockerignoreä¼˜åŒ–

```text
# .dockerignore
.git
.gitignore
.github
*.md
.vscode
.idea

# æµ‹è¯•æ–‡ä»¶
*_test.go
testdata/

# æ„å»ºäº§ç‰©
bin/
dist/
*.exe
*.dll
*.so
*.dylib

# ä¸´æ—¶æ–‡ä»¶
*.swp
*.swo
*~
.DS_Store

# ä¾èµ–
vendor/
```

---

### 1.3 Docker Composeæœ¬åœ°å¼€å‘

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    environment:
      - DB_HOST=postgres
      - REDIS_HOST=redis
      - ENV=development
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - ./configs:/configs:ro
    networks:
      - app-network
    restart: unless-stopped

  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: myapp
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: myapp
    ports:
      - "5432:5432"
    volumes:
      - postgres-data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U myapp"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - app-network

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
    networks:
      - app-network

  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./configs/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus-data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
    networks:
      - app-network

  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana-data:/var/lib/grafana
    depends_on:
      - prometheus
    networks:
      - app-network

volumes:
  postgres-data:
  redis-data:
  prometheus-data:
  grafana-data:

networks:
  app-network:
    driver: bridge
```

---

## 2. KubernetesåŸºç¡€éƒ¨ç½²

### 2.1 Deploymenté…ç½®

```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  namespace: production
  labels:
    app: myapp
    version: v1.0.0
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
        version: v1.0.0
    spec:
      # æœåŠ¡è´¦å·
      serviceAccountName: myapp
      
      # é•œåƒæ‹‰å–å¯†é’¥
      imagePullSecrets:
        - name: registry-secret
      
      # å®¹å™¨é…ç½®
      containers:
      - name: myapp
        image: myregistry.com/myapp:v1.0.0
        imagePullPolicy: Always
        
        # ç«¯å£
        ports:
        - name: http
          containerPort: 8080
          protocol: TCP
        - name: metrics
          containerPort: 9090
          protocol: TCP
        
        # ç¯å¢ƒå˜é‡
        env:
        - name: ENV
          value: "production"
        - name: DB_HOST
          valueFrom:
            configMapKeyRef:
              name: myapp-config
              key: db.host
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: myapp-secret
              key: db.password
        
        # èµ„æºé™åˆ¶
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        
        # å¥åº·æ£€æŸ¥
        livenessProbe:
          httpGet:
            path: /health/live
            port: http
          initialDelaySeconds: 10
          periodSeconds: 10
          timeoutSeconds: 3
          failureThreshold: 3
        
        readinessProbe:
          httpGet:
            path: /health/ready
            port: http
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
        
        # å¯åŠ¨æ¢é’ˆï¼ˆGoåº”ç”¨å¯åŠ¨è¾ƒå¿«ï¼‰
        startupProbe:
          httpGet:
            path: /health/startup
            port: http
          initialDelaySeconds: 0
          periodSeconds: 2
          timeoutSeconds: 3
          failureThreshold: 30
        
        # æŒ‚è½½
        volumeMounts:
        - name: config
          mountPath: /configs
          readOnly: true
        - name: tmp
          mountPath: /tmp
      
      # å·
      volumes:
      - name: config
        configMap:
          name: myapp-config
      - name: tmp
        emptyDir: {}
      
      # äº²å’Œæ€§
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - myapp
              topologyKey: kubernetes.io/hostname
```

---

### 2.2 Serviceé…ç½®

```yaml
# k8s/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: myapp
  namespace: production
  labels:
    app: myapp
spec:
  type: ClusterIP
  ports:
  - name: http
    port: 80
    targetPort: http
    protocol: TCP
  - name: metrics
    port: 9090
    targetPort: metrics
    protocol: TCP
  selector:
    app: myapp
  sessionAffinity: None

---
# Headless Service for StatefulSet
apiVersion: v1
kind: Service
metadata:
  name: myapp-headless
  namespace: production
spec:
  clusterIP: None
  ports:
  - name: http
    port: 8080
    targetPort: 8080
  selector:
    app: myapp
```

---

### 2.3 Ingressé…ç½®

```yaml
# k8s/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: myapp
  namespace: production
  annotations:
    # NGINX Ingress
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    
    # é™æµ
    nginx.ingress.kubernetes.io/limit-rps: "100"
    
    # CORS
    nginx.ingress.kubernetes.io/enable-cors: "true"
    nginx.ingress.kubernetes.io/cors-allow-origin: "https://example.com"
    
    # WebSocket
    nginx.ingress.kubernetes.io/websocket-services: "myapp"
    
    # è¶…æ—¶
    nginx.ingress.kubernetes.io/proxy-read-timeout: "60"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "60"
    
    # Let's Encrypt
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  tls:
  - hosts:
    - api.example.com
    secretName: myapp-tls
  rules:
  - host: api.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: myapp
            port:
              number: 80
```

---

### 2.4 ConfigMapä¸Secret

```yaml
# k8s/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: myapp-config
  namespace: production
data:
  app.yaml: |
    server:
      port: 8080
      timeout: 30s
    db:
      host: postgres.production.svc.cluster.local
      port: 5432
      database: myapp
      maxConnections: 25
    redis:
      host: redis.production.svc.cluster.local
      port: 6379
    log:
      level: info
      format: json

---
# k8s/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: myapp-secret
  namespace: production
type: Opaque
stringData:
  db.password: "your-secure-password"
  jwt.secret: "your-jwt-secret"
  api.key: "your-api-key"
```

---

## 3. Helm Chartsç®¡ç†

### 3.1 Helm Chartç»“æ„

```text
myapp/
â”œâ”€â”€ Chart.yaml
â”œâ”€â”€ values.yaml
â”œâ”€â”€ values-dev.yaml
â”œâ”€â”€ values-staging.yaml
â”œâ”€â”€ values-prod.yaml
â””â”€â”€ templates/
    â”œâ”€â”€ deployment.yaml
    â”œâ”€â”€ service.yaml
    â”œâ”€â”€ ingress.yaml
    â”œâ”€â”€ configmap.yaml
    â”œâ”€â”€ secret.yaml
    â”œâ”€â”€ hpa.yaml
    â”œâ”€â”€ pdb.yaml
    â”œâ”€â”€ serviceaccount.yaml
    â””â”€â”€ _helpers.tpl
```

### 3.2 Chart.yaml

```yaml
apiVersion: v2
name: myapp
description: A Helm chart for MyApp Go application
type: application
version: 1.0.0
appVersion: "1.0.0"

keywords:
  - go
  - microservice
  - cloud-native

maintainers:
  - name: Your Name
    email: your.email@example.com

dependencies:
  - name: postgresql
    version: "12.x.x"
    repository: "https://charts.bitnami.com/bitnami"
    condition: postgresql.enabled
  
  - name: redis
    version: "17.x.x"
    repository: "https://charts.bitnami.com/bitnami"
    condition: redis.enabled
```

### 3.3 values.yaml

```yaml
# Default values for myapp
replicaCount: 3

image:
  repository: myregistry.com/myapp
  pullPolicy: IfNotPresent
  tag: ""  # Overrides the image tag whose default is the chart appVersion

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  create: true
  annotations: {}
  name: ""

podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "9090"
  prometheus.io/path: "/metrics"

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: true

service:
  type: ClusterIP
  port: 80
  targetPort: 8080

ingress:
  enabled: true
  className: "nginx"
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
  hosts:
    - host: api.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: myapp-tls
      hosts:
        - api.example.com

resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 250m
    memory: 256Mi

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

nodeSelector: {}

tolerations: []

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - myapp
          topologyKey: kubernetes.io/hostname

# Application configuration
config:
  env: production
  logLevel: info
  
# PostgreSQL subchart
postgresql:
  enabled: true
  auth:
    username: myapp
    password: changeme
    database: myapp

# Redis subchart
redis:
  enabled: true
  auth:
    enabled: true
    password: changeme
```

### 3.4 éƒ¨ç½²å‘½ä»¤

```bash
# åˆ›å»ºå‘½åç©ºé—´
kubectl create namespace production

# æ·»åŠ ä¾èµ–ä»“åº“
helm repo add bitnami https://charts.bitnami.com/bitnami
helm repo update

# å®‰è£…/å‡çº§ï¼ˆå¼€å‘ç¯å¢ƒï¼‰
helm upgrade --install myapp ./myapp \
  --namespace development \
  --create-namespace \
  --values ./myapp/values-dev.yaml \
  --wait

# å®‰è£…/å‡çº§ï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰
helm upgrade --install myapp ./myapp \
  --namespace production \
  --values ./myapp/values-prod.yaml \
  --set image.tag=v1.0.0 \
  --wait \
  --timeout 10m

# å›æ»š
helm rollback myapp --namespace production

# å¸è½½
helm uninstall myapp --namespace production
```

---

## 4. CI/CDè‡ªåŠ¨åŒ–

### 4.1 GitHub Actions

```yaml
# .github/workflows/deploy.yml
name: Build and Deploy

on:
  push:
    branches: [main]
    tags:
      - 'v*'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-go@v5
        with:
          go-version: '1.25.3'
          cache: true
      
      - name: Run tests
        run: |
          go test -v -race -coverprofile=coverage.out ./...
          go tool cover -html=coverage.out -o coverage.html
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.out

  build:
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha
      
      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v')
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'
      
      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
      
      - name: Deploy with Helm
        run: |
          helm upgrade --install myapp ./charts/myapp \
            --namespace production \
            --set image.tag=${{ github.sha }} \
            --wait \
            --timeout 10m
      
      - name: Verify deployment
        run: |
          kubectl rollout status deployment/myapp -n production
```

---

### 4.2 GitLab CI

```yaml
# .gitlab-ci.yml
stages:
  - test
  - build
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA

test:
  stage: test
  image: golang:1.25.3
  script:
    - go test -v -race -coverprofile=coverage.out ./...
    - go tool cover -func=coverage.out
  coverage: '/total:\s+\(statements\)\s+(\d+\.\d+)%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml

build:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $IMAGE_TAG .
    - docker push $IMAGE_TAG
  only:
    - main
    - tags

deploy:production:
  stage: deploy
  image: alpine/helm:latest
  before_script:
    - kubectl config use-context production
  script:
    - helm upgrade --install myapp ./charts/myapp 
        --namespace production 
        --set image.tag=$CI_COMMIT_SHORT_SHA 
        --wait
  environment:
    name: production
    url: https://api.example.com
  only:
    - tags
```

---

## 5. æœåŠ¡ç½‘æ ¼Istio

### 5.1 Istio Gateway

```yaml
# k8s/istio-gateway.yaml
apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: myapp-gateway
  namespace: production
spec:
  selector:
    istio: ingressgateway
  servers:
  - port:
      number: 443
      name: https
      protocol: HTTPS
    tls:
      mode: SIMPLE
      credentialName: myapp-tls
    hosts:
    - api.example.com
```

### 5.2 VirtualService

```yaml
# k8s/virtualservice.yaml
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: myapp
  namespace: production
spec:
  hosts:
  - api.example.com
  gateways:
  - myapp-gateway
  http:
  - match:
    - uri:
        prefix: "/api/v1"
    route:
    - destination:
        host: myapp
        port:
          number: 80
        subset: v1
      weight: 90
    - destination:
        host: myapp
        port:
          number: 80
        subset: v2
      weight: 10
    retries:
      attempts: 3
      perTryTimeout: 2s
    timeout: 10s
```

### 5.3 DestinationRule

```yaml
# k8s/destinationrule.yaml
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: myapp
  namespace: production
spec:
  host: myapp
  trafficPolicy:
    loadBalancer:
      simple: LEAST_REQUEST
    connectionPool:
      tcp:
        maxConnections: 100
      http:
        http1MaxPendingRequests: 50
        http2MaxRequests: 100
        maxRequestsPerConnection: 2
    outlierDetection:
      consecutiveErrors: 5
      interval: 30s
      baseEjectionTime: 30s
      maxEjectionPercent: 50
  subsets:
  - name: v1
    labels:
      version: v1.0.0
  - name: v2
    labels:
      version: v2.0.0
```

---

## 6. ç›‘æ§ä¸æ—¥å¿—

### 6.1 Prometheus ServiceMonitor

```yaml
# k8s/servicemonitor.yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: myapp
  namespace: production
  labels:
    app: myapp
spec:
  selector:
    matchLabels:
      app: myapp
  endpoints:
  - port: metrics
    interval: 30s
    path: /metrics
```

### 6.2 åº”ç”¨ç›‘æ§ä»£ç 

```go
package monitoring

import (
 "github.com/prometheus/client_golang/prometheus"
 "github.com/prometheus/client_golang/prometheus/promauto"
 "github.com/prometheus/client_golang/prometheus/promhttp"
 "net/http"
 "time"
)

var (
 // HTTPè¯·æ±‚æ€»æ•°
 httpRequestsTotal = promauto.NewCounterVec(
  prometheus.CounterOpts{
   Name: "http_requests_total",
   Help: "Total number of HTTP requests",
  },
  []string{"method", "path", "status"},
 )
 
 // HTTPè¯·æ±‚å»¶è¿Ÿ
 httpRequestDuration = promauto.NewHistogramVec(
  prometheus.HistogramOpts{
   Name:    "http_request_duration_seconds",
   Help:    "HTTP request duration in seconds",
   Buckets: prometheus.DefBuckets,
  },
  []string{"method", "path"},
 )
 
 // æ•°æ®åº“è¿æ¥æ± 
 dbConnectionsInUse = promauto.NewGauge(
  prometheus.GaugeOpts{
   Name: "db_connections_in_use",
   Help: "Number of database connections in use",
  },
 )
)

// MetricsMiddleware ç›‘æ§ä¸­é—´ä»¶
func MetricsMiddleware(next http.Handler) http.Handler {
 return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  start := time.Now()
  
  // å“åº”åŒ…è£…å™¨
  wrapper := &responseWrapper{ResponseWriter: w, statusCode: 200}
  
  // å¤„ç†è¯·æ±‚
  next.ServeHTTP(wrapper, r)
  
  // è®°å½•æŒ‡æ ‡
  duration := time.Since(start).Seconds()
  
  httpRequestsTotal.WithLabelValues(
   r.Method,
   r.URL.Path,
   http.StatusText(wrapper.statusCode),
  ).Inc()
  
  httpRequestDuration.WithLabelValues(
   r.Method,
   r.URL.Path,
  ).Observe(duration)
 })
}

type responseWrapper struct {
 http.ResponseWriter
 statusCode int
}

func (rw *responseWrapper) WriteHeader(code int) {
 rw.statusCode = code
 rw.ResponseWriter.WriteHeader(code)
}

// SetupMetrics è®¾ç½®ç›‘æ§ç«¯ç‚¹
func SetupMetrics() http.Handler {
 return promhttp.Handler()
}
```

---

## 7. é«˜å¯ç”¨ä¸æ‰©ç¼©å®¹

### 7.1 HorizontalPodAutoscaler

```yaml
# k8s/hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: myapp
  namespace: production
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: myapp
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  - type: Pods
    pods:
      metric:
        name: http_requests_per_second
      target:
        type: AverageValue
        averageValue: "1000"
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15
      - type: Pods
        value: 4
        periodSeconds: 15
      selectPolicy: Max
```

### 7.2 PodDisruptionBudget

```yaml
# k8s/pdb.yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: myapp
  namespace: production
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app: myapp
```

---

## 8. å®Œæ•´æ¡ˆä¾‹

### 8.1 å¥åº·æ£€æŸ¥å®ç°

```go
package health

import (
 "context"
 "encoding/json"
 "net/http"
 "sync"
 "time"
)

// HealthChecker å¥åº·æ£€æŸ¥å™¨
type HealthChecker struct {
 checks map[string]Check
 mu     sync.RWMutex
}

// Check æ£€æŸ¥å‡½æ•°
type Check func(ctx context.Context) error

// NewHealthChecker åˆ›å»ºå¥åº·æ£€æŸ¥å™¨
func NewHealthChecker() *HealthChecker {
 return &HealthChecker{
  checks: make(map[string]Check),
 }
}

// Register æ³¨å†Œæ£€æŸ¥
func (hc *HealthChecker) Register(name string, check Check) {
 hc.mu.Lock()
 defer hc.mu.Unlock()
 hc.checks[name] = check
}

// LivenessHandler å­˜æ´»æ¢é’ˆ
func (hc *HealthChecker) LivenessHandler() http.HandlerFunc {
 return func(w http.ResponseWriter, r *http.Request) {
  w.WriteHeader(http.StatusOK)
  w.Write([]byte("OK"))
 }
}

// ReadinessHandler å°±ç»ªæ¢é’ˆ
func (hc *HealthChecker) ReadinessHandler() http.HandlerFunc {
 return func(w http.ResponseWriter, r *http.Request) {
  ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
  defer cancel()
  
  hc.mu.RLock()
  checks := hc.checks
  hc.mu.RUnlock()
  
  results := make(map[string]string)
  healthy := true
  
  for name, check := range checks {
   if err := check(ctx); err != nil {
    results[name] = "unhealthy: " + err.Error()
    healthy = false
   } else {
    results[name] = "healthy"
   }
  }
  
  status := http.StatusOK
  if !healthy {
   status = http.StatusServiceUnavailable
  }
  
  w.Header().Set("Content-Type", "application/json")
  w.WriteHeader(status)
  json.NewEncoder(w).Encode(map[string]interface{}{
   "status": map[bool]string{true: "healthy", false: "unhealthy"}[healthy],
   "checks": results,
  })
 }
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleHealthCheck(db *sql.DB, redis *redis.Client) {
 health := NewHealthChecker()
 
 // æ•°æ®åº“æ£€æŸ¥
 health.Register("database", func(ctx context.Context) error {
  return db.PingContext(ctx)
 })
 
 // Redisæ£€æŸ¥
 health.Register("redis", func(ctx context.Context) error {
  return redis.Ping(ctx).Err()
 })
 
 http.HandleFunc("/health/live", health.LivenessHandler())
 http.HandleFunc("/health/ready", health.ReadinessHandler())
}
```

---

## ğŸ“š äº‘åŸç”Ÿæœ€ä½³å®è·µ

### Dockeræœ€ä½³å®è·µ

- âœ… å¤šé˜¶æ®µæ„å»ºå‡å°é•œåƒä½“ç§¯
- âœ… ä½¿ç”¨.dockerignoreæ’é™¤æ— å…³æ–‡ä»¶
- âœ… ä¸è¦åœ¨å®¹å™¨ä¸­è¿è¡Œrootç”¨æˆ·
- âœ… ä½¿ç”¨å¥åº·æ£€æŸ¥
- âœ… ç‰ˆæœ¬åŒ–é•œåƒæ ‡ç­¾

### Kubernetesæœ€ä½³å®è·µ

- âœ… è®¾ç½®èµ„æºrequestså’Œlimits
- âœ… å®ç°å¥åº·æ£€æŸ¥ï¼ˆliveness/readiness/startupï¼‰
- âœ… ä½¿ç”¨Podåäº²å’Œæ€§æé«˜å¯ç”¨æ€§
- âœ… é…ç½®PodDisruptionBudget
- âœ… ä½¿ç”¨Secretsç®¡ç†æ•æ„Ÿä¿¡æ¯

### ç›‘æ§ä¸å¯è§‚æµ‹æ€§

- âœ… æš´éœ²PrometheusæŒ‡æ ‡
- âœ… ç»“æ„åŒ–æ—¥å¿—ï¼ˆJSONæ ¼å¼ï¼‰
- âœ… å®ç°åˆ†å¸ƒå¼è¿½è¸ª
- âœ… è®¾ç½®å‘Šè­¦è§„åˆ™
- âœ… å»ºç«‹å¯è§†åŒ–é¢æ¿

---

## ğŸ¯ æ€»ç»“

Go 1.25.3äº‘åŸç”Ÿéƒ¨ç½²å…³é”®ç‚¹ï¼š

1. **å®¹å™¨åŒ–**: å¤šé˜¶æ®µæ„å»ºã€é•œåƒä¼˜åŒ–ã€å¥åº·æ£€æŸ¥
2. **K8séƒ¨ç½²**: Deploymentã€Serviceã€Ingresså®Œæ•´é…ç½®
3. **Helmç®¡ç†**: Chartså¤ç”¨ã€å¤šç¯å¢ƒé…ç½®
4. **CI/CD**: è‡ªåŠ¨åŒ–æµ‹è¯•ã€æ„å»ºã€éƒ¨ç½²æµç¨‹
5. **æœåŠ¡ç½‘æ ¼**: Istioæµé‡ç®¡ç†ã€ç†”æ–­ã€é‡è¯•
6. **ç›‘æ§**: PrometheusæŒ‡æ ‡ã€Grafanaå¯è§†åŒ–
7. **é«˜å¯ç”¨**: HPAè‡ªåŠ¨æ‰©ç¼©å®¹ã€PDBä¿æŠ¤

**äº‘åŸç”Ÿè®©Goåº”ç”¨æ›´å¼ºå¤§ï¼**

---

<div align="center">

**æŒæ¡äº‘åŸç”Ÿéƒ¨ç½²ï¼Œæ„å»ºç°ä»£åŒ–åº”ç”¨**:

[ğŸ“š è¿”å›ç›®å½•](../README.md) | [ğŸ“– ä¸‹ä¸€ç« ](11-æœåŠ¡ç½‘æ ¼è¿›é˜¶.md)

Made with â¤ï¸ for Go Developers

</div>

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-10-22  
**Goç‰ˆæœ¬**: Go 1.25.3  
**ç”Ÿäº§å°±ç»ª**: âœ…
