# 教程索引与学习指南

**版本**: v1.0
**更新日期**: 2025-11-11
**适用于**: Go 1.25.3

---

## 📋 目录

- [教程索引与学习指南](#教程索引与学习指南)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 教程体系](#11-教程体系)
  - [2. 入门教程](#2-入门教程)
    - [2.1 教程1：构建第一个HTTP服务](#21-教程1构建第一个http服务)
    - [2.2 教程2：并发编程基础](#22-教程2并发编程基础)
  - [3. 进阶教程](#3-进阶教程)
    - [3.1 教程3：数据库操作与ORM](#31-教程3数据库操作与orm)
    - [3.2 教程4：单元测试与基准测试](#32-教程4单元测试与基准测试)
  - [4. 高级教程](#4-高级教程)
    - [4.1 教程5：微服务架构实践](#41-教程5微服务架构实践)
  - [5. 专题教程](#5-专题教程)
    - [5.1 专题：性能优化实战](#51-专题性能优化实战)
  - [6. 学习路线](#6-学习路线)
    - [6.1 完整学习路径](#61-完整学习路径)

---

---

## 1. 概述

### 1.1 教程体系

```text
教程分类（按难度）:

┌─────────────────────────────────────┐
│         教程体系                    │
├─────────────────────────────────────┤
│                                     │
│  入门教程 (⭐⭐)                     │
│  └─ HTTP服务、并发基础、错误处理    │
│                                     │
│  进阶教程 (⭐⭐⭐)                   │
│  └─ 中间件、数据库、测试、部署      │
│                                     │
│  高级教程 (⭐⭐⭐⭐)                 │
│  └─ 微服务、性能优化、可观测性      │
│                                     │
│  专题教程 (⭐⭐⭐⭐⭐)               │
│  └─ 形式化分析、无锁算法、云原生    │
│                                     │
└─────────────────────────────────────┘
```

---

## 2. 入门教程

### 2.1 教程1：构建第一个HTTP服务

**目标**: 30分钟创建一个完整的HTTP服务

**内容大纲**:

1. 项目初始化
2. 创建HTTP handler
3. 路由配置
4. 中间件添加
5. 测试与运行

**详细步骤**:

```go
// Step 1: 项目初始化
// 创建项目目录
mkdir my-http-server
cd my-http-server
go mod init my-http-server

// Step 2: 创建main.go
// main.go
package main

import (
    "encoding/json"
    "log"
    "net/http"
    "time"
)

// Handler: Hello World
func helloHandler(w http.ResponseWriter, r *http.Request) {
    response := map[string]string{
        "message": "Hello, World!",
        "time":    time.Now().Format(time.RFC3339),
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}

// Handler: Echo
func echoHandler(w http.ResponseWriter, r *http.Request) {
    var data map[string]interface{}

    if err := json.NewDecoder(r.Body).Decode(&data); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(data)
}

// 中间件: 日志
func loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()

        log.Printf("Started %s %s", r.Method, r.URL.Path)

        next.ServeHTTP(w, r)

        log.Printf("Completed in %v", time.Since(start))
    })
}

func main() {
    mux := http.NewServeMux()

    // 注册路由
    mux.HandleFunc("/", helloHandler)
    mux.HandleFunc("/echo", echoHandler)

    // 应用中间件
    handler := loggingMiddleware(mux)

    // 启动服务器
    log.Println("Server starting on :8080")
    if err := http.ListenAndServe(":8080", handler); err != nil {
        log.Fatal(err)
    }
}

// Step 3: 运行
// go run main.go

// Step 4: 测试
// curl http://localhost:8080/
// curl -X POST http://localhost:8080/echo -d '{"name":"test"}'
```

**练习任务**:

1. 添加一个`/health`端点
2. 实现一个计数器中间件
3. 添加CORS支持
4. 实现优雅关闭

---

### 2.2 教程2：并发编程基础

**目标**: 掌握Goroutine和Channel的基本使用

**内容大纲**:

1. Goroutine创建与管理
2. Channel通信
3. Select多路复用
4. WaitGroup同步
5. Context取消

**详细步骤**:

```go
// 示例1: 基础Goroutine
func example1() {
    // 启动goroutine
    go func() {
        fmt.Println("Hello from Goroutine")
    }()

    time.Sleep(time.Second)
}

// 示例2: Channel通信
func example2() {
    ch := make(Channel int)

    // 生产者
    go func() {
        for i := 0; i < 10; i++ {
            ch <- i
        }
        close(ch)
    }()

    // 消费者
    for val := range ch {
        fmt.Println(val)
    }
}

// 示例3: Select多路复用
func example3() {
    ch1 := make(Channel string)
    ch2 := make(Channel string)

    go func() {
        time.Sleep(1 * time.Second)
        ch1 <- "from ch1"
    }()

    go func() {
        time.Sleep(2 * time.Second)
        ch2 <- "from ch2"
    }()

    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-ch1:
            fmt.Println(msg1)
        case msg2 := <-ch2:
            fmt.Println(msg2)
        }
    }
}

// 示例4: WaitGroup
func example4() {
    var wg sync.WaitGroup

    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            fmt.Printf("Worker %d done\n", id)
        }(i)
    }

    wg.Wait()
    fmt.Println("All workers completed")
}

// 示例5: Context取消
func example5() {
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()

    go func() {
        select {
        case <-time.After(5 * time.Second):
            fmt.Println("work done")
        case <-ctx.Done():
            fmt.Println("work cancelled:", ctx.Err())
        }
    }()

    time.Sleep(4 * time.Second)
}
```

**练习任务**:

1. 实现一个Worker池
2. 实现生产者-消费者模式
3. 实现Fan-out/Fan-in模式
4. 处理Goroutine泄漏

---

## 3. 进阶教程

### 3.1 教程3：数据库操作与ORM

**目标**: 掌握PostgreSQL和ORM的使用

**内容大纲**:

1. 数据库连接
2. CRUD操作
3. 事务处理
4. GORM使用
5. 连接池优化

**详细步骤**:

```go
// Step 1: 数据库连接
import (
    "database/sql"
    "gorm.io/driver/postgres"
    "gorm.io/gorm"
)

func connectDB() (*sql.DB, error) {
    dsn := "host=localhost user=postgres password=secret dbname=mydb port=5432"
    return sql.Open("postgres", dsn)
}

// Step 2: 定义模型
type User struct {
    ID        uint   `gorm:"primaryKey"`
    Email     string `gorm:"uniqueIndex"`
    Name      string
    CreatedAt time.Time
}

// Step 3: GORM初始化
func initGORM() (*gorm.DB, error) {
    dsn := "host=localhost user=postgres password=secret dbname=mydb port=5432"
    return gorm.Open(postgres.Open(dsn), &gorm.Config{})
}

// Step 4: CRUD操作
func crudOperations(db *gorm.DB) {
    // Create
    user := User{Email: "test@example.com", Name: "Test User"}
    db.Create(&user)

    // Read
    var found User
    db.First(&found, "email = ?", "test@example.com")

    // Update
    db.Model(&found).Update("Name", "Updated Name")

    // Delete
    db.Delete(&found)
}

// Step 5: 事务
func transactionExample(db *gorm.DB) error {
    return db.Transaction(func(tx *gorm.DB) error {
        if err := tx.Create(&User{Email: "user1@example.com"}).Error; err != nil {
            return err
        }

        if err := tx.Create(&User{Email: "user2@example.com"}).Error; err != nil {
            return err
        }

        return nil
    })
}
```

**练习任务**:

1. 实现用户注册/登录
2. 实现分页查询
3. 实现软删除
4. 优化查询性能

---

### 3.2 教程4：单元测试与基准测试

**目标**: 编写高质量的测试代码

**内容大纲**:

1. 单元测试基础
2. Table-driven测试
3. Mock和Stub
4. 基准测试
5. 覆盖率分析

**详细步骤**:

```go
// 被测试函数
func Add(a, b int) int {
    return a + b
}

func Divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

// 测试文件: math_test.go
func TestAdd(t *testing.T) {
    tests := []struct {
        name     string
        a, b     int
        expected int
    }{
        {"positive", 2, 3, 5},
        {"negative", -1, -1, -2},
        {"zero", 0, 0, 0},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := Add(tt.a, tt.b)
            if result != tt.expected {
                t.Errorf("Add(%d, %d) = %d, want %d", tt.a, tt.b, result, tt.expected)
            }
        })
    }
}

func TestDivide(t *testing.T) {
    // 正常情况
    result, err := Divide(10, 2)
    if err != nil {
        t.Errorf("Unexpected error: %v", err)
    }
    if result != 5.0 {
        t.Errorf("Divide(10, 2) = %f, want 5.0", result)
    }

    // 除零错误
    _, err = Divide(10, 0)
    if err == nil {
        t.Error("Expected error for division by zero")
    }
}

// 基准测试
func BenchmarkAdd(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Add(1, 2)
    }
}

// Mock示例
type UserRepository interface {
    GetByID(id int) (*User, error)
}

type MockUserRepository struct {
    users map[int]*User
}

func (m *MockUserRepository) GetByID(id int) (*User, error) {
    user, ok := m.users[id]
    if !ok {
        return nil, errors.New("user not found")
    }
    return user, nil
}
```

**运行测试**:

```bash
# 运行所有测试
go test ./...

# 运行特定测试
go test -run TestAdd

# 生成覆盖率报告
go test -cover

# 详细覆盖率
go test -coverprofile=coverage.out
go tool cover -html=coverage.out

# 运行基准测试
go test -bench=.

# 内存分配分析
go test -bench=. -benchmem
```

---

## 4. 高级教程

### 4.1 教程5：微服务架构实践

1. gRPC服务定义
2. 服务注册与发现
3. 负载均衡
4. 分布式追踪
5. 服务网格

**详细步骤**:

```proto
// Step 1: 定义proto文件
// user.proto
syntax = "proto3";

package user;

service UserService {
    rpc GetUser(GetUserRequest) returns (User);
    rpc CreateUser(CreateUserRequest) returns (User);
}

message User {
    string id = 1;
    string email = 2;
    string name = 3;
}

message GetUserRequest {
    string id = 1;
}

message CreateUserRequest {
    string email = 1;
    string name = 2;
}
```

```go
// Step 2: 实现服务
type userServer struct {
    pb.UnimplementedUserServiceServer
    repo UserRepository
}

func (s *userServer) GetUser(ctx Context.Context, req *pb.GetUserRequest) (*pb.User, error) {
    user, err := s.repo.GetByID(ctx, req.Id)
    if err != nil {
        return nil, status.Error(codes.NotFound, "user not found")
    }

    return &pb.User{
        Id:    user.ID,
        Email: user.Email,
        Name:  user.Name,
    }, nil
}

// Step 3: 服务注册（Consul）
func registerService() error {
    config := consul.DefaultConfig()
    client, err := consul.NewClient(config)
    if err != nil {
        return err
    }

    registration := &consul.AgentServiceRegistration{
        ID:      "user-service-1",
        Name:    "user-service",
        Port:    50051,
        Address: "localhost",
        Check: &consul.AgentServiceCheck{
            GRPC:     "localhost:50051",
            Interval: "10s",
            Timeout:  "1s",
        },
    }

    return client.Agent().ServiceRegister(registration)
}

// Step 4: 客户端负载均衡
func createClient() (pb.UserServiceClient, error) {
    // 服务发现
    resolver := consul.NewBuilder()

    // 建立连接
    conn, err := grpc.Dial(
        "consul://localhost:8500/user-service",
        grpc.WithResolvers(resolver),
        grpc.WithDefaultServiceConfig(`{"loadBalancingPolicy":"round_robin"}`),
    )
    if err != nil {
        return nil, err
    }

    return pb.NewUserServiceClient(conn), nil
}
```

---

## 5. 专题教程

### 5.1 专题：性能优化实战

**涵盖内容**:

1. **CPU Profiling**
2. **Memory Profiling**
3. **Goroutine分析**
4. **锁竞争分析**
5. **实战案例**

**关键技术**:

- pprof使用
- Benchmark优化
- 逃逸分析
- 内存对齐
- 无锁算法

---

## 6. 学习路线

### 6.1 完整学习路径
