# ğŸš€ Phase 4 å®æ–½æ‰‹å†Œ - å®Œæ•´æŒ‡å—

**æ–‡æ¡£ç±»å‹**: çŸ¥è¯†æ¢³ç† - é¡¹ç›®å®æ–½æŒ‡å—  
**åˆ›å»ºæ—¶é—´**: 2025å¹´10æœˆ24æ—¥  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.23+  
**é¡¹ç›®é˜¶æ®µ**: Phase 4 - åŠŸèƒ½å®Œå–„ä¸å‘å¸ƒå‡†å¤‡

---

## ğŸ“‹ ç›®å½•

- [1. å®æ–½æ¦‚è§ˆ](#1-å®æ–½æ¦‚è§ˆ)
- [2. æ¨¡å—Aï¼šåŠŸèƒ½å¢å¼º](#2-æ¨¡å—aåŠŸèƒ½å¢å¼º)
- [3. æ¨¡å—Bï¼šæ€§èƒ½ä¼˜åŒ–](#3-æ¨¡å—bæ€§èƒ½ä¼˜åŒ–)
- [4. æ¨¡å—Cï¼šç¤¾åŒºå‡†å¤‡](#4-æ¨¡å—cç¤¾åŒºå‡†å¤‡)
- [5. æ¨¡å—Dï¼šè´¨é‡ä¿éšœ](#5-æ¨¡å—dè´¨é‡ä¿éšœ)
- [6. å®æ–½æ—¶é—´è¡¨](#6-å®æ–½æ—¶é—´è¡¨)
- [7. è´¨é‡æ ‡å‡†](#7-è´¨é‡æ ‡å‡†)
- [8. é£é™©ç®¡ç†](#8-é£é™©ç®¡ç†)

---

## 1. å®æ–½æ¦‚è§ˆ

### 1.1 Phase 4 ç›®æ ‡

**æ€»ä½“ç›®æ ‡**: å®Œå–„é¡¹ç›®åŠŸèƒ½ï¼Œä¼˜åŒ–æ€§èƒ½ï¼Œå‡†å¤‡å¼€æºå‘å¸ƒ

**å…³é”®æˆæœ**:
- æ–°å¢ä»£ç ï¼š~7,500è¡Œ
- æ€§èƒ½æå‡ï¼š20%+
- å†…å­˜å‡å°‘ï¼š30%+
- é¡¹ç›®è¯„åˆ†ï¼š9.0 â†’ 9.5+

### 1.2 ä»»åŠ¡æ€»è§ˆ

```text
Phase 4 ä»»åŠ¡å…¨æ™¯ (18ä¸ªä»»åŠ¡):

å·²å®Œæˆ (6ä¸ªï¼Œ33.3%)
â”œâ”€ âœ… A1. æ‰©å±•å¹¶å‘æ¨¡å¼åº“
â”œâ”€ âœ… A2. å¢å¼ºAgentæ¡†æ¶
â”œâ”€ âœ… B1. æ€§èƒ½åˆ†æå’ŒåŸºçº¿
â”œâ”€ âœ… B2. æ ¸å¿ƒæ¨¡å—æ€§èƒ½ä¼˜åŒ–
â”œâ”€ âœ… C1. å®Œå–„é¡¹ç›®æ–‡æ¡£
â””â”€ âœ… D1. æµ‹è¯•è¦†ç›–ç‡æå‡

å¾…å®Œæˆ (12ä¸ªï¼Œ66.7%)
â”œâ”€ æ¨¡å—Aï¼šåŠŸèƒ½å¢å¼º (4ä¸ª)
â”‚   â”œâ”€ â³ A3. HTTP/3å¢å¼ºåŠŸèƒ½
â”‚   â”œâ”€ â³ A4. Memoryç®¡ç†ä¼˜åŒ–
â”‚   â”œâ”€ â³ A5. Observabilityå®Œå–„
â”‚   â””â”€ â³ A6. CLIå·¥å…·å¢å¼º
â”‚
â”œâ”€ æ¨¡å—Bï¼šæ€§èƒ½ä¼˜åŒ– (2ä¸ª)
â”‚   â”œâ”€ â³ B3. å†…å­˜ä¼˜åŒ–
â”‚   â””â”€ â³ B4. å¹¶å‘ä¼˜åŒ–
â”‚
â”œâ”€ æ¨¡å—Cï¼šç¤¾åŒºå‡†å¤‡ (4ä¸ª)
â”‚   â”œâ”€ â³ C2. åˆ›å»ºç¤ºä¾‹é¡¹ç›®
â”‚   â”œâ”€ â³ C3. ç¼–å†™æ•™ç¨‹å’ŒæŒ‡å—
â”‚   â”œâ”€ â³ C4. å‡†å¤‡å‘å¸ƒææ–™
â”‚   â””â”€ â³ C5. å»ºç«‹ç¤¾åŒºæ¸ é“
â”‚
â””â”€ æ¨¡å—Dï¼šè´¨é‡ä¿éšœ (2ä¸ª)
    â”œâ”€ â³ D2. ä»£ç è´¨é‡å®¡æŸ¥
    â””â”€ â³ D3. å®‰å…¨å®¡è®¡
```

---

## 2. æ¨¡å—Aï¼šåŠŸèƒ½å¢å¼º

### 2.1 A3. HTTP/3å¢å¼ºåŠŸèƒ½

#### 2.1.1 ä»»åŠ¡æ¦‚è¿°

**ç›®æ ‡**: å®Œå–„HTTP/3æ”¯æŒï¼Œæ·»åŠ ç”Ÿäº§çº§åŠŸèƒ½

**å·¥ä½œé‡**: ~950è¡Œä»£ç  + 500è¡Œæ–‡æ¡£

**ä¼˜å…ˆçº§**: ğŸ”´ é«˜

#### 2.1.2 è¯¦ç»†è®¾è®¡

##### ä¸­é—´ä»¶ç³»ç»Ÿæ¶æ„

```go
// pkg/http3/middleware/middleware.go

package middleware

import (
    "context"
    "net/http"
    "sync"
    "time"
)

// Middleware ä¸­é—´ä»¶æ¥å£
type Middleware interface {
    // Handle å¤„ç†HTTP/3è¯·æ±‚
    Handle(next http.Handler) http.Handler
}

// Chain ä¸­é—´ä»¶é“¾
type Chain struct {
    middlewares []Middleware
}

// NewChain åˆ›å»ºä¸­é—´ä»¶é“¾
func NewChain(middlewares ...Middleware) *Chain {
    return &Chain{
        middlewares: middlewares,
    }
}

// Then åº”ç”¨ä¸­é—´ä»¶é“¾åˆ°å¤„ç†å™¨
func (c *Chain) Then(h http.Handler) http.Handler {
    for i := len(c.middlewares) - 1; i >= 0; i-- {
        h = c.middlewares[i].Handle(h)
    }
    return h
}
```

##### 1. æ—¥å¿—ä¸­é—´ä»¶

```go
// pkg/http3/middleware/logging.go

package middleware

import (
    "log"
    "net/http"
    "time"
)

// LoggingMiddleware HTTP/3æ—¥å¿—ä¸­é—´ä»¶
type LoggingMiddleware struct {
    logger *log.Logger
}

// NewLoggingMiddleware åˆ›å»ºæ—¥å¿—ä¸­é—´ä»¶
func NewLoggingMiddleware(logger *log.Logger) *LoggingMiddleware {
    return &LoggingMiddleware{
        logger: logger,
    }
}

// Handle å®ç°ä¸­é—´ä»¶æ¥å£
func (m *LoggingMiddleware) Handle(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // åŒ…è£…ResponseWriterä»¥æ•è·çŠ¶æ€ç 
        wrapped := &responseWriter{
            ResponseWriter: w,
            statusCode:     http.StatusOK,
        }
        
        // è°ƒç”¨ä¸‹ä¸€ä¸ªå¤„ç†å™¨
        next.ServeHTTP(wrapped, r)
        
        // è®°å½•æ—¥å¿—
        duration := time.Since(start)
        m.logger.Printf(
            "[HTTP/3] %s %s - Status: %d - Duration: %v - Proto: %s",
            r.Method,
            r.URL.Path,
            wrapped.statusCode,
            duration,
            r.Proto, // "HTTP/3"
        )
    })
}

// responseWriter åŒ…è£…ResponseWriterä»¥æ•è·çŠ¶æ€ç 
type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (w *responseWriter) WriteHeader(statusCode int) {
    w.statusCode = statusCode
    w.ResponseWriter.WriteHeader(statusCode)
}
```

##### 2. é™æµä¸­é—´ä»¶

```go
// pkg/http3/middleware/ratelimit.go

package middleware

import (
    "net/http"
    "sync"
    "time"
    
    "golang.org/x/time/rate"
)

// RateLimitMiddleware HTTP/3é™æµä¸­é—´ä»¶
type RateLimitMiddleware struct {
    limiters sync.Map // map[string]*rate.Limiter
    rate     rate.Limit
    burst    int
}

// NewRateLimitMiddleware åˆ›å»ºé™æµä¸­é—´ä»¶
// rps: æ¯ç§’è¯·æ±‚æ•°
// burst: çªå‘è¯·æ±‚æ•°
func NewRateLimitMiddleware(rps int, burst int) *RateLimitMiddleware {
    return &RateLimitMiddleware{
        rate:  rate.Limit(rps),
        burst: burst,
    }
}

// Handle å®ç°ä¸­é—´ä»¶æ¥å£
func (m *RateLimitMiddleware) Handle(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // è·å–å®¢æˆ·ç«¯IP
        clientIP := getClientIP(r)
        
        // è·å–æˆ–åˆ›å»ºé™æµå™¨
        limiter := m.getLimiter(clientIP)
        
        // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™æµ
        if !limiter.Allow() {
            http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
            return
        }
        
        // è°ƒç”¨ä¸‹ä¸€ä¸ªå¤„ç†å™¨
        next.ServeHTTP(w, r)
    })
}

// getLimiter è·å–æˆ–åˆ›å»ºå®¢æˆ·ç«¯é™æµå™¨
func (m *RateLimitMiddleware) getLimiter(clientIP string) *rate.Limiter {
    if limiter, ok := m.limiters.Load(clientIP); ok {
        return limiter.(*rate.Limiter)
    }
    
    limiter := rate.NewLimiter(m.rate, m.burst)
    m.limiters.Store(clientIP, limiter)
    
    return limiter
}

// getClientIP è·å–å®¢æˆ·ç«¯IP
func getClientIP(r *http.Request) string {
    // ä¼˜å…ˆä»X-Forwarded-Forè·å–
    if ip := r.Header.Get("X-Forwarded-For"); ip != "" {
        return ip
    }
    
    // ä»X-Real-IPè·å–
    if ip := r.Header.Get("X-Real-IP"); ip != "" {
        return ip
    }
    
    // ç›´æ¥ä»RemoteAddrè·å–
    return r.RemoteAddr
}
```

##### 3. CORSä¸­é—´ä»¶

```go
// pkg/http3/middleware/cors.go

package middleware

import (
    "net/http"
    "strings"
)

// CORSConfig CORSé…ç½®
type CORSConfig struct {
    AllowOrigins     []string
    AllowMethods     []string
    AllowHeaders     []string
    ExposeHeaders    []string
    AllowCredentials bool
    MaxAge           int
}

// CORSMiddleware HTTP/3 CORSä¸­é—´ä»¶
type CORSMiddleware struct {
    config CORSConfig
}

// NewCORSMiddleware åˆ›å»ºCORSä¸­é—´ä»¶
func NewCORSMiddleware(config CORSConfig) *CORSMiddleware {
    // è®¾ç½®é»˜è®¤å€¼
    if len(config.AllowMethods) == 0 {
        config.AllowMethods = []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"}
    }
    
    if len(config.AllowHeaders) == 0 {
        config.AllowHeaders = []string{"Accept", "Content-Type", "Authorization"}
    }
    
    if config.MaxAge == 0 {
        config.MaxAge = 3600 // 1å°æ—¶
    }
    
    return &CORSMiddleware{
        config: config,
    }
}

// Handle å®ç°ä¸­é—´ä»¶æ¥å£
func (m *CORSMiddleware) Handle(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        origin := r.Header.Get("Origin")
        
        // æ£€æŸ¥æ˜¯å¦å…è®¸è¯¥Origin
        if m.isOriginAllowed(origin) {
            w.Header().Set("Access-Control-Allow-Origin", origin)
            
            if m.config.AllowCredentials {
                w.Header().Set("Access-Control-Allow-Credentials", "true")
            }
            
            w.Header().Set("Access-Control-Allow-Methods", 
                strings.Join(m.config.AllowMethods, ", "))
            
            w.Header().Set("Access-Control-Allow-Headers", 
                strings.Join(m.config.AllowHeaders, ", "))
            
            if len(m.config.ExposeHeaders) > 0 {
                w.Header().Set("Access-Control-Expose-Headers", 
                    strings.Join(m.config.ExposeHeaders, ", "))
            }
            
            w.Header().Set("Access-Control-Max-Age", 
                fmt.Sprintf("%d", m.config.MaxAge))
        }
        
        // å¤„ç†é¢„æ£€è¯·æ±‚
        if r.Method == "OPTIONS" {
            w.WriteHeader(http.StatusNoContent)
            return
        }
        
        // è°ƒç”¨ä¸‹ä¸€ä¸ªå¤„ç†å™¨
        next.ServeHTTP(w, r)
    })
}

// isOriginAllowed æ£€æŸ¥Originæ˜¯å¦å…è®¸
func (m *CORSMiddleware) isOriginAllowed(origin string) bool {
    if len(m.config.AllowOrigins) == 0 {
        return true // å…è®¸æ‰€æœ‰
    }
    
    for _, allowed := range m.config.AllowOrigins {
        if allowed == "*" || allowed == origin {
            return true
        }
    }
    
    return false
}
```

##### 4. å‹ç¼©ä¸­é—´ä»¶

```go
// pkg/http3/middleware/compression.go

package middleware

import (
    "compress/gzip"
    "io"
    "net/http"
    "strings"
)

// CompressionMiddleware HTTP/3å‹ç¼©ä¸­é—´ä»¶
type CompressionMiddleware struct {
    level int // å‹ç¼©çº§åˆ« (1-9)
}

// NewCompressionMiddleware åˆ›å»ºå‹ç¼©ä¸­é—´ä»¶
func NewCompressionMiddleware(level int) *CompressionMiddleware {
    if level < gzip.BestSpeed || level > gzip.BestCompression {
        level = gzip.DefaultCompression
    }
    
    return &CompressionMiddleware{
        level: level,
    }
}

// Handle å®ç°ä¸­é—´ä»¶æ¥å£
func (m *CompressionMiddleware) Handle(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // æ£€æŸ¥å®¢æˆ·ç«¯æ˜¯å¦æ”¯æŒgzip
        if !strings.Contains(r.Header.Get("Accept-Encoding"), "gzip") {
            next.ServeHTTP(w, r)
            return
        }
        
        // åˆ›å»ºgzip writer
        gz, err := gzip.NewWriterLevel(w, m.level)
        if err != nil {
            next.ServeHTTP(w, r)
            return
        }
        defer gz.Close()
        
        // åŒ…è£…ResponseWriter
        w.Header().Set("Content-Encoding", "gzip")
        w.Header().Del("Content-Length") // å‹ç¼©åé•¿åº¦ä¼šå˜åŒ–
        
        gzw := &gzipResponseWriter{
            ResponseWriter: w,
            Writer:         gz,
        }
        
        // è°ƒç”¨ä¸‹ä¸€ä¸ªå¤„ç†å™¨
        next.ServeHTTP(gzw, r)
    })
}

// gzipResponseWriter åŒ…è£…ResponseWriteræ”¯æŒå‹ç¼©
type gzipResponseWriter struct {
    http.ResponseWriter
    Writer io.Writer
}

func (w *gzipResponseWriter) Write(b []byte) (int, error) {
    return w.Writer.Write(b)
}
```

##### 5. è®¤è¯ä¸­é—´ä»¶

```go
// pkg/http3/middleware/auth.go

package middleware

import (
    "crypto/subtle"
    "net/http"
    "strings"
)

// AuthMiddleware HTTP/3è®¤è¯ä¸­é—´ä»¶
type AuthMiddleware struct {
    validateFunc func(token string) bool
}

// NewAuthMiddleware åˆ›å»ºè®¤è¯ä¸­é—´ä»¶
func NewAuthMiddleware(validateFunc func(token string) bool) *AuthMiddleware {
    return &AuthMiddleware{
        validateFunc: validateFunc,
    }
}

// Handle å®ç°ä¸­é—´ä»¶æ¥å£
func (m *AuthMiddleware) Handle(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // è·å–Authorizationå¤´
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        
        // è§£æBearer token
        parts := strings.SplitN(authHeader, " ", 2)
        if len(parts) != 2 || parts[0] != "Bearer" {
            http.Error(w, "Invalid authorization header", http.StatusUnauthorized)
            return
        }
        
        token := parts[1]
        
        // éªŒè¯token
        if !m.validateFunc(token) {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }
        
        // è°ƒç”¨ä¸‹ä¸€ä¸ªå¤„ç†å™¨
        next.ServeHTTP(w, r)
    })
}

// NewBasicAuthMiddleware åˆ›å»ºBasicè®¤è¯ä¸­é—´ä»¶
func NewBasicAuthMiddleware(username, password string) *AuthMiddleware {
    return NewAuthMiddleware(func(token string) bool {
        // Basicè®¤è¯éªŒè¯é€»è¾‘
        return subtle.ConstantTimeCompare(
            []byte(token),
            []byte(username+":"+password),
        ) == 1
    })
}
```

##### ä½¿ç”¨ç¤ºä¾‹

```go
// examples/http3_middleware_example.go

package main

import (
    "log"
    "net/http"
    "os"
    
    "your-project/pkg/http3/middleware"
    "github.com/quic-go/quic-go/http3"
)

func main() {
    // åˆ›å»ºä¸­é—´ä»¶
    logger := log.New(os.Stdout, "[HTTP3] ", log.LstdFlags)
    
    // ä¸­é—´ä»¶é“¾
    chain := middleware.NewChain(
        middleware.NewLoggingMiddleware(logger),
        middleware.NewRateLimitMiddleware(100, 10), // 100 rps, burst 10
        middleware.NewCORSMiddleware(middleware.CORSConfig{
            AllowOrigins:     []string{"https://example.com"},
            AllowCredentials: true,
        }),
        middleware.NewCompressionMiddleware(gzip.BestSpeed),
    )
    
    // åˆ›å»ºå¤„ç†å™¨
    mux := http.NewServeMux()
    mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("Hello, HTTP/3 with Middleware!"))
    })
    
    // åº”ç”¨ä¸­é—´ä»¶é“¾
    handler := chain.Then(mux)
    
    // å¯åŠ¨HTTP/3æœåŠ¡å™¨
    server := &http3.Server{
        Addr:    ":443",
        Handler: handler,
    }
    
    log.Println("HTTP/3 server listening on :443")
    if err := server.ListenAndServeTLS("cert.pem", "key.pem"); err != nil {
        log.Fatal(err)
    }
}
```

#### 2.1.3 å®æ–½æ­¥éª¤

1. **åˆ›å»ºä¸­é—´ä»¶åŒ…ç»“æ„** (Day 1)
   - åˆ›å»º `pkg/http3/middleware/` ç›®å½•
   - å®ç°åŸºç¡€ä¸­é—´ä»¶æ¥å£
   - å®ç°ä¸­é—´ä»¶é“¾

2. **å®ç°5ä¸ªæ ¸å¿ƒä¸­é—´ä»¶** (Day 2-3)
   - æ—¥å¿—ä¸­é—´ä»¶
   - é™æµä¸­é—´ä»¶
   - CORSä¸­é—´ä»¶
   - å‹ç¼©ä¸­é—´ä»¶
   - è®¤è¯ä¸­é—´ä»¶

3. **ç¼–å†™æµ‹è¯•** (Day 4)
   - å•å…ƒæµ‹è¯•ï¼ˆæ¯ä¸ªä¸­é—´ä»¶ï¼‰
   - é›†æˆæµ‹è¯•ï¼ˆä¸­é—´ä»¶é“¾ï¼‰
   - æ€§èƒ½æµ‹è¯•ï¼ˆbenchmarkï¼‰

4. **æ–‡æ¡£ç¼–å†™** (Day 5)
   - APIæ–‡æ¡£
   - ä½¿ç”¨ç¤ºä¾‹
   - æœ€ä½³å®è·µ

#### 2.1.4 éªŒæ”¶æ ‡å‡†

- âœ… 5ä¸ªä¸­é—´ä»¶å…¨éƒ¨å®ç°
- âœ… æµ‹è¯•è¦†ç›–ç‡ > 80%
- âœ… Benchmarkæ€§èƒ½å¼€é”€ < 5%
- âœ… æ–‡æ¡£å®Œæ•´

---

### 2.2 A4. Memoryç®¡ç†ä¼˜åŒ–

#### 2.2.1 ä»»åŠ¡æ¦‚è¿°

**ç›®æ ‡**: å®ç°é«˜æ•ˆçš„å†…å­˜ç®¡ç†ï¼Œå‡å°‘GCå‹åŠ›

**å·¥ä½œé‡**: ~1,000è¡Œä»£ç  + 400è¡Œæ–‡æ¡£

**ä¼˜å…ˆçº§**: ğŸ”´ é«˜

#### 2.2.2 è¯¦ç»†è®¾è®¡

##### 1. Arenaåˆ†é…å™¨

```go
// pkg/memory/arena.go

package memory

import (
    "sync"
    "unsafe"
)

// Arena å†…å­˜æ± åˆ†é…å™¨
type Arena struct {
    mu      sync.Mutex
    blocks  []*block
    current *block
    size    int // æ¯ä¸ªblockçš„å¤§å°
}

type block struct {
    data   []byte
    offset int
}

// NewArena åˆ›å»ºArena
func NewArena(blockSize int) *Arena {
    return &Arena{
        size:   blockSize,
        blocks: make([]*block, 0, 16),
    }
}

// Alloc åˆ†é…å†…å­˜
func (a *Arena) Alloc(size int) []byte {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    // å¯¹é½åˆ°8å­—èŠ‚
    size = (size + 7) &^ 7
    
    // æ£€æŸ¥å½“å‰blockæ˜¯å¦æœ‰è¶³å¤Ÿç©ºé—´
    if a.current == nil || a.current.offset+size > len(a.current.data) {
        // åˆ†é…æ–°block
        blockSize := a.size
        if size > blockSize {
            blockSize = size
        }
        
        a.current = &block{
            data:   make([]byte, blockSize),
            offset: 0,
        }
        a.blocks = append(a.blocks, a.current)
    }
    
    // ä»å½“å‰blockåˆ†é…
    ptr := a.current.data[a.current.offset : a.current.offset+size]
    a.current.offset += size
    
    return ptr
}

// Reset é‡ç½®Arenaï¼ˆå¤ç”¨å†…å­˜ï¼‰
func (a *Arena) Reset() {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    // é‡ç½®æ‰€æœ‰blockçš„offset
    for _, b := range a.blocks {
        b.offset = 0
    }
    
    if len(a.blocks) > 0 {
        a.current = a.blocks[0]
    }
}

// Free é‡Šæ”¾æ‰€æœ‰å†…å­˜
func (a *Arena) Free() {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    a.blocks = nil
    a.current = nil
}

// Size è¿”å›å·²åˆ†é…çš„æ€»å¤§å°
func (a *Arena) Size() int {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    total := 0
    for _, b := range a.blocks {
        total += b.offset
    }
    return total
}
```

##### 2. å¼±å¼•ç”¨ç¼“å­˜

```go
// pkg/memory/weakcache.go

package memory

import (
    "runtime"
    "sync"
    "time"
)

// WeakCache å¼±å¼•ç”¨ç¼“å­˜
type WeakCache[K comparable, V any] struct {
    mu      sync.RWMutex
    cache   map[K]*weakEntry[V]
    cleaner *time.Ticker
}

type weakEntry[V any] struct {
    value      V
    lastAccess time.Time
    generation int
}

// NewWeakCache åˆ›å»ºå¼±å¼•ç”¨ç¼“å­˜
func NewWeakCache[K comparable, V any](cleanInterval time.Duration) *WeakCache[K, V] {
    wc := &WeakCache[K, V]{
        cache:   make(map[K]*weakEntry[V]),
        cleaner: time.NewTicker(cleanInterval),
    }
    
    // å¯åŠ¨æ¸…ç†goroutine
    go wc.cleanLoop()
    
    return wc
}

// Get è·å–ç¼“å­˜å€¼
func (wc *WeakCache[K, V]) Get(key K) (V, bool) {
    wc.mu.RLock()
    defer wc.mu.RUnlock()
    
    entry, ok := wc.cache[key]
    if !ok {
        var zero V
        return zero, false
    }
    
    entry.lastAccess = time.Now()
    return entry.value, true
}

// Set è®¾ç½®ç¼“å­˜å€¼
func (wc *WeakCache[K, V]) Set(key K, value V) {
    wc.mu.Lock()
    defer wc.mu.Unlock()
    
    wc.cache[key] = &weakEntry[V]{
        value:      value,
        lastAccess: time.Now(),
        generation: 0,
    }
}

// Delete åˆ é™¤ç¼“å­˜å€¼
func (wc *WeakCache[K, V]) Delete(key K) {
    wc.mu.Lock()
    defer wc.mu.Unlock()
    
    delete(wc.cache, key)
}

// cleanLoop æ¸…ç†å¾ªç¯
func (wc *WeakCache[K, V]) cleanLoop() {
    for range wc.cleaner.C {
        wc.clean()
    }
}

// clean æ¸…ç†è¿‡æœŸæ¡ç›®
func (wc *WeakCache[K, V]) clean() {
    wc.mu.Lock()
    defer wc.mu.Unlock()
    
    now := time.Now()
    threshold := 5 * time.Minute
    
    for key, entry := range wc.cache {
        if now.Sub(entry.lastAccess) > threshold {
            entry.generation++
            
            // ä¸¤ä»£æœªè®¿é—®ï¼Œåˆ é™¤
            if entry.generation > 1 {
                delete(wc.cache, key)
            }
        }
    }
    
    // è§¦å‘GCï¼ˆå¯é€‰ï¼‰
    if len(wc.cache) == 0 {
        runtime.GC()
    }
}

// Close å…³é—­ç¼“å­˜
func (wc *WeakCache[K, V]) Close() {
    wc.cleaner.Stop()
}
```

##### 3. å¯¹è±¡æ± 

```go
// pkg/memory/objectpool.go

package memory

import (
    "sync"
)

// ObjectPool å¯¹è±¡æ± 
type ObjectPool[T any] struct {
    pool    sync.Pool
    factory func() T
    reset   func(*T)
}

// NewObjectPool åˆ›å»ºå¯¹è±¡æ± 
func NewObjectPool[T any](
    factory func() T,
    reset func(*T),
) *ObjectPool[T] {
    return &ObjectPool[T]{
        pool: sync.Pool{
            New: func() interface{} {
                obj := factory()
                return &obj
            },
        },
        factory: factory,
        reset:   reset,
    }
}

// Get è·å–å¯¹è±¡
func (p *ObjectPool[T]) Get() *T {
    return p.pool.Get().(*T)
}

// Put å½’è¿˜å¯¹è±¡
func (p *ObjectPool[T]) Put(obj *T) {
    if p.reset != nil {
        p.reset(obj)
    }
    p.pool.Put(obj)
}
```

##### 4. GCè§¦å‘å™¨

```go
// pkg/memory/gctrigger.go

package memory

import (
    "runtime"
    "runtime/debug"
    "time"
)

// GCTrigger GCè§¦å‘å™¨
type GCTrigger struct {
    threshold    uint64        // å†…å­˜é˜ˆå€¼ï¼ˆå­—èŠ‚ï¼‰
    interval     time.Duration // æ£€æŸ¥é—´éš”
    forcePercent int           // å¼ºåˆ¶GCç™¾åˆ†æ¯”
    ticker       *time.Ticker
    stop         chan struct{}
}

// NewGCTrigger åˆ›å»ºGCè§¦å‘å™¨
func NewGCTrigger(threshold uint64, interval time.Duration) *GCTrigger {
    return &GCTrigger{
        threshold:    threshold,
        interval:     interval,
        forcePercent: 200, // å†…å­˜ä½¿ç”¨è¶…è¿‡é˜ˆå€¼200%æ—¶å¼ºåˆ¶GC
        stop:         make(chan struct{}),
    }
}

// Start å¯åŠ¨GCè§¦å‘å™¨
func (t *GCTrigger) Start() {
    t.ticker = time.NewTicker(t.interval)
    
    go func() {
        for {
            select {
            case <-t.ticker.C:
                t.check()
            case <-t.stop:
                return
            }
        }
    }()
}

// check æ£€æŸ¥å¹¶è§¦å‘GC
func (t *GCTrigger) check() {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    // æ£€æŸ¥å †å†…å­˜ä½¿ç”¨
    if m.Alloc > t.threshold {
        percentUsed := int(m.Alloc * 100 / t.threshold)
        
        if percentUsed > t.forcePercent {
            // å¼ºåˆ¶GC
            debug.FreeOSMemory()
        } else {
            // æ¸©å’ŒGC
            runtime.GC()
        }
    }
}

// Stop åœæ­¢GCè§¦å‘å™¨
func (t *GCTrigger) Stop() {
    if t.ticker != nil {
        t.ticker.Stop()
    }
    close(t.stop)
}
```

##### ä½¿ç”¨ç¤ºä¾‹

```go
// examples/memory_optimization_example.go

package main

import (
    "fmt"
    "your-project/pkg/memory"
)

func main() {
    // 1. Arenaåˆ†é…å™¨ç¤ºä¾‹
    arena := memory.NewArena(1024 * 1024) // 1MB blocks
    
    // åˆ†é…100ä¸ªå°å¯¹è±¡
    for i := 0; i < 100; i++ {
        data := arena.Alloc(128) // åˆ†é…128å­—èŠ‚
        // ä½¿ç”¨data...
        _ = data
    }
    
    fmt.Printf("Arena size: %d bytes\n", arena.Size())
    
    // é‡ç½®Arenaå¤ç”¨å†…å­˜
    arena.Reset()
    
    // 2. å¼±å¼•ç”¨ç¼“å­˜ç¤ºä¾‹
    cache := memory.NewWeakCache[string, []byte](1 * time.Minute)
    defer cache.Close()
    
    cache.Set("key1", []byte("value1"))
    
    if value, ok := cache.Get("key1"); ok {
        fmt.Printf("Cache hit: %s\n", string(value))
    }
    
    // 3. å¯¹è±¡æ± ç¤ºä¾‹
    type Buffer struct {
        data []byte
    }
    
    pool := memory.NewObjectPool(
        // factory
        func() Buffer {
            return Buffer{data: make([]byte, 0, 1024)}
        },
        // reset
        func(b *Buffer) {
            b.data = b.data[:0]
        },
    )
    
    // è·å–å¯¹è±¡
    buf := pool.Get()
    buf.data = append(buf.data, []byte("hello")...)
    
    // å½’è¿˜å¯¹è±¡
    pool.Put(buf)
    
    // 4. GCè§¦å‘å™¨ç¤ºä¾‹
    trigger := memory.NewGCTrigger(
        500*1024*1024,  // 500MB threshold
        10*time.Second, // check every 10s
    )
    trigger.Start()
    defer trigger.Stop()
}
```

#### 2.2.3 å®æ–½æ­¥éª¤

1. **å®ç°Arenaåˆ†é…å™¨** (Day 1-2)
2. **å®ç°WeakCache** (Day 2-3)
3. **å®ç°å¯¹è±¡æ± ** (Day 3-4)
4. **å®ç°GCè§¦å‘å™¨** (Day 4-5)
5. **æ€§èƒ½æµ‹è¯•ä¸ä¼˜åŒ–** (Day 6-7)

#### 2.2.4 éªŒæ”¶æ ‡å‡†

- âœ… å†…å­˜åˆ†é…å‡å°‘ 30%+
- âœ… GCæš‚åœæ—¶é—´å‡å°‘ 40%+
- âœ… æ€§èƒ½æµ‹è¯•é€šè¿‡
- âœ… æ–‡æ¡£å®Œæ•´

---

### 2.3 A5. Observabilityå®Œå–„

#### 2.3.1 ä»»åŠ¡æ¦‚è¿°

**ç›®æ ‡**: å®Œå–„å¯è§‚æµ‹æ€§ï¼Œæ·»åŠ è¿½è¸ªã€æŒ‡æ ‡ã€å¥åº·æ£€æŸ¥

**å·¥ä½œé‡**: ~800è¡Œä»£ç  + 400è¡Œæ–‡æ¡£

**ä¼˜å…ˆçº§**: ğŸŸ¡ ä¸­

#### 2.3.2 è¯¦ç»†è®¾è®¡

##### 1. åˆ†å¸ƒå¼è¿½è¸ª

```go
// pkg/observability/tracing.go

package observability

import (
    "context"
    "fmt"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/exporters/jaeger"
    "go.opentelemetry.io/otel/sdk/resource"
    "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
)

// TracingConfig è¿½è¸ªé…ç½®
type TracingConfig struct {
    ServiceName    string
    ServiceVersion string
    JaegerEndpoint string
    SamplingRate   float64
}

// InitTracing åˆå§‹åŒ–è¿½è¸ª
func InitTracing(config TracingConfig) error {
    // åˆ›å»ºJaeger exporter
    exporter, err := jaeger.New(
        jaeger.WithCollectorEndpoint(
            jaeger.WithEndpoint(config.JaegerEndpoint),
        ),
    )
    if err != nil {
        return fmt.Errorf("failed to create Jaeger exporter: %w", err)
    }
    
    // åˆ›å»ºresource
    res, err := resource.New(
        context.Background(),
        resource.WithAttributes(
            semconv.ServiceNameKey.String(config.ServiceName),
            semconv.ServiceVersionKey.String(config.ServiceVersion),
        ),
    )
    if err != nil {
        return fmt.Errorf("failed to create resource: %w", err)
    }
    
    // åˆ›å»ºtrace provider
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
        trace.WithResource(res),
        trace.WithSampler(
            trace.TraceIDRatioBased(config.SamplingRate),
        ),
    )
    
    // è®¾ç½®å…¨å±€trace provider
    otel.SetTracerProvider(tp)
    
    return nil
}

// StartSpan å¼€å§‹è¿½è¸ªspan
func StartSpan(ctx context.Context, name string, attrs ...attribute.KeyValue) (context.Context, trace.Span) {
    tracer := otel.Tracer("your-project")
    return tracer.Start(ctx, name, trace.WithAttributes(attrs...))
}
```

##### 2. æŒ‡æ ‡æ”¶é›†

```go
// pkg/observability/metrics.go

package observability

import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

// Metrics åº”ç”¨æŒ‡æ ‡
type Metrics struct {
    // HTTPæŒ‡æ ‡
    HTTPRequestsTotal     *prometheus.CounterVec
    HTTPRequestDuration   *prometheus.HistogramVec
    HTTPRequestSize       *prometheus.HistogramVec
    HTTPResponseSize      *prometheus.HistogramVec
    
    // ç³»ç»ŸæŒ‡æ ‡
    GoroutineCount        prometheus.Gauge
    HeapAllocBytes        prometheus.Gauge
    GCDurationSeconds     prometheus.Summary
    
    // ä¸šåŠ¡æŒ‡æ ‡
    ActiveConnections     prometheus.Gauge
    QueueLength           prometheus.Gauge
    ProcessingDuration    *prometheus.HistogramVec
}

// NewMetrics åˆ›å»ºæŒ‡æ ‡æ”¶é›†å™¨
func NewMetrics() *Metrics {
    return &Metrics{
        HTTPRequestsTotal: promauto.NewCounterVec(
            prometheus.CounterOpts{
                Name: "http_requests_total",
                Help: "Total number of HTTP requests",
            },
            []string{"method", "path", "status"},
        ),
        
        HTTPRequestDuration: promauto.NewHistogramVec(
            prometheus.HistogramOpts{
                Name:    "http_request_duration_seconds",
                Help:    "HTTP request duration in seconds",
                Buckets: prometheus.DefBuckets,
            },
            []string{"method", "path"},
        ),
        
        HTTPRequestSize: promauto.NewHistogramVec(
            prometheus.HistogramOpts{
                Name:    "http_request_size_bytes",
                Help:    "HTTP request size in bytes",
                Buckets: prometheus.ExponentialBuckets(100, 10, 7),
            },
            []string{"method", "path"},
        ),
        
        HTTPResponseSize: promauto.NewHistogramVec(
            prometheus.HistogramOpts{
                Name:    "http_response_size_bytes",
                Help:    "HTTP response size in bytes",
                Buckets: prometheus.ExponentialBuckets(100, 10, 7),
            },
            []string{"method", "path"},
        ),
        
        GoroutineCount: promauto.NewGauge(
            prometheus.GaugeOpts{
                Name: "goroutine_count",
                Help: "Number of goroutines",
            },
        ),
        
        HeapAllocBytes: promauto.NewGauge(
            prometheus.GaugeOpts{
                Name: "heap_alloc_bytes",
                Help: "Heap allocated bytes",
            },
        ),
        
        GCDurationSeconds: promauto.NewSummary(
            prometheus.SummaryOpts{
                Name:       "gc_duration_seconds",
                Help:       "GC duration in seconds",
                Objectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},
            },
        ),
        
        ActiveConnections: promauto.NewGauge(
            prometheus.GaugeOpts{
                Name: "active_connections",
                Help: "Number of active connections",
            },
        ),
        
        QueueLength: promauto.NewGauge(
            prometheus.GaugeOpts{
                Name: "queue_length",
                Help: "Length of processing queue",
            },
        ),
        
        ProcessingDuration: promauto.NewHistogramVec(
            prometheus.HistogramOpts{
                Name:    "processing_duration_seconds",
                Help:    "Processing duration in seconds",
                Buckets: prometheus.DefBuckets,
            },
            []string{"operation"},
        ),
    }
}
```

##### 3. å¥åº·æ£€æŸ¥

```go
// pkg/observability/health.go

package observability

import (
    "context"
    "encoding/json"
    "net/http"
    "sync"
    "time"
)

// HealthStatus å¥åº·çŠ¶æ€
type HealthStatus string

const (
    HealthStatusUp   HealthStatus = "UP"
    HealthStatusDown HealthStatus = "DOWN"
)

// HealthCheck å¥åº·æ£€æŸ¥æ¥å£
type HealthCheck interface {
    Name() string
    Check(ctx context.Context) error
}

// HealthChecker å¥åº·æ£€æŸ¥å™¨
type HealthChecker struct {
    mu     sync.RWMutex
    checks map[string]HealthCheck
}

// NewHealthChecker åˆ›å»ºå¥åº·æ£€æŸ¥å™¨
func NewHealthChecker() *HealthChecker {
    return &HealthChecker{
        checks: make(map[string]HealthCheck),
    }
}

// Register æ³¨å†Œå¥åº·æ£€æŸ¥
func (hc *HealthChecker) Register(check HealthCheck) {
    hc.mu.Lock()
    defer hc.mu.Unlock()
    
    hc.checks[check.Name()] = check
}

// CheckAll æ‰§è¡Œæ‰€æœ‰å¥åº·æ£€æŸ¥
func (hc *HealthChecker) CheckAll(ctx context.Context) map[string]error {
    hc.mu.RLock()
    defer hc.mu.RUnlock()
    
    results := make(map[string]error)
    
    for name, check := range hc.checks {
        results[name] = check.Check(ctx)
    }
    
    return results
}

// HTTPHandler å¥åº·æ£€æŸ¥HTTPå¤„ç†å™¨
func (hc *HealthChecker) HTTPHandler() http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
        defer cancel()
        
        results := hc.CheckAll(ctx)
        
        // è®¡ç®—æ•´ä½“çŠ¶æ€
        status := HealthStatusUp
        details := make(map[string]string)
        
        for name, err := range results {
            if err != nil {
                status = HealthStatusDown
                details[name] = err.Error()
            } else {
                details[name] = "UP"
            }
        }
        
        // æ„é€ å“åº”
        response := map[string]interface{}{
            "status":  status,
            "details": details,
        }
        
        // è®¾ç½®HTTPçŠ¶æ€ç 
        statusCode := http.StatusOK
        if status == HealthStatusDown {
            statusCode = http.StatusServiceUnavailable
        }
        
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        json.NewEncoder(w).Encode(response)
    }
}

// DatabaseHealthCheck æ•°æ®åº“å¥åº·æ£€æŸ¥
type DatabaseHealthCheck struct {
    name string
    ping func(ctx context.Context) error
}

func NewDatabaseHealthCheck(name string, ping func(ctx context.Context) error) *DatabaseHealthCheck {
    return &DatabaseHealthCheck{
        name: name,
        ping: ping,
    }
}

func (c *DatabaseHealthCheck) Name() string {
    return c.name
}

func (c *DatabaseHealthCheck) Check(ctx context.Context) error {
    return c.ping(ctx)
}
```

#### 2.3.3 å®æ–½æ­¥éª¤

1. **å®ç°åˆ†å¸ƒå¼è¿½è¸ª** (Day 1-2)
2. **å®ç°æŒ‡æ ‡æ”¶é›†** (Day 2-3)
3. **å®ç°å¥åº·æ£€æŸ¥** (Day 3-4)
4. **é›†æˆæµ‹è¯•** (Day 4-5)

---

### 2.4 A6. CLIå·¥å…·å¢å¼º

#### 2.4.1 ä»»åŠ¡æ¦‚è¿°

**ç›®æ ‡**: å¢å¼ºCLIå·¥å…·ï¼Œæ·»åŠ REPLã€é…ç½®ç®¡ç†ã€æ’ä»¶ç³»ç»Ÿ

**å·¥ä½œé‡**: ~1,200è¡Œä»£ç  + 500è¡Œæ–‡æ¡£

**ä¼˜å…ˆçº§**: ğŸŸ¡ ä¸­

#### 2.4.2 è¯¦ç»†è®¾è®¡

##### 1. REPLæ¥å£

```go
// cmd/repl/repl.go

package repl

import (
    "bufio"
    "fmt"
    "io"
    "strings"
)

// REPL Read-Eval-Print Loop
type REPL struct {
    commands map[string]Command
    prompt   string
}

// Command å‘½ä»¤æ¥å£
type Command interface {
    Name() string
    Description() string
    Execute(args []string) error
}

// NewREPL åˆ›å»ºREPL
func NewREPL() *REPL {
    repl := &REPL{
        commands: make(map[string]Command),
        prompt:   "> ",
    }
    
    // æ³¨å†Œå†…ç½®å‘½ä»¤
    repl.Register(&HelpCommand{repl: repl})
    repl.Register(&ExitCommand{})
    
    return repl
}

// Register æ³¨å†Œå‘½ä»¤
func (r *REPL) Register(cmd Command) {
    r.commands[cmd.Name()] = cmd
}

// Run è¿è¡ŒREPL
func (r *REPL) Run(in io.Reader, out io.Writer) error {
    scanner := bufio.NewScanner(in)
    
    fmt.Fprintf(out, "Welcome to the REPL. Type 'help' for commands.\n")
    
    for {
        fmt.Fprint(out, r.prompt)
        
        if !scanner.Scan() {
            break
        }
        
        line := strings.TrimSpace(scanner.Text())
        if line == "" {
            continue
        }
        
        parts := strings.Fields(line)
        cmdName := parts[0]
        args := parts[1:]
        
        cmd, ok := r.commands[cmdName]
        if !ok {
            fmt.Fprintf(out, "Unknown command: %s\n", cmdName)
            continue
        }
        
        if err := cmd.Execute(args); err != nil {
            fmt.Fprintf(out, "Error: %v\n", err)
        }
    }
    
    return scanner.Err()
}

// HelpCommand å¸®åŠ©å‘½ä»¤
type HelpCommand struct {
    repl *REPL
}

func (c *HelpCommand) Name() string { return "help" }
func (c *HelpCommand) Description() string { return "Show available commands" }

func (c *HelpCommand) Execute(args []string) error {
    fmt.Println("Available commands:")
    for name, cmd := range c.repl.commands {
        fmt.Printf("  %-15s %s\n", name, cmd.Description())
    }
    return nil
}

// ExitCommand é€€å‡ºå‘½ä»¤
type ExitCommand struct{}

func (c *ExitCommand) Name() string { return "exit" }
func (c *ExitCommand) Description() string { return "Exit the REPL" }

func (c *ExitCommand) Execute(args []string) error {
    fmt.Println("Goodbye!")
    os.Exit(0)
    return nil
}
```

##### 2. é…ç½®ç®¡ç†

```go
// pkg/config/config.go

package config

import (
    "encoding/json"
    "fmt"
    "os"
    "path/filepath"
    
    "gopkg.in/yaml.v3"
)

// Config é…ç½®
type Config struct {
    Server   ServerConfig   `yaml:"server" json:"server"`
    Database DatabaseConfig `yaml:"database" json:"database"`
    Logging  LoggingConfig  `yaml:"logging" json:"logging"`
}

type ServerConfig struct {
    Host string `yaml:"host" json:"host"`
    Port int    `yaml:"port" json:"port"`
    TLS  struct {
        Enabled  bool   `yaml:"enabled" json:"enabled"`
        CertFile string `yaml:"cert_file" json:"cert_file"`
        KeyFile  string `yaml:"key_file" json:"key_file"`
    } `yaml:"tls" json:"tls"`
}

type DatabaseConfig struct {
    Driver string `yaml:"driver" json:"driver"`
    DSN    string `yaml:"dsn" json:"dsn"`
}

type LoggingConfig struct {
    Level  string `yaml:"level" json:"level"`
    Format string `yaml:"format" json:"format"`
}

// Load åŠ è½½é…ç½®
func Load(path string) (*Config, error) {
    data, err := os.ReadFile(path)
    if err != nil {
        return nil, fmt.Errorf("failed to read config file: %w", err)
    }
    
    var config Config
    
    ext := filepath.Ext(path)
    switch ext {
    case ".yaml", ".yml":
        err = yaml.Unmarshal(data, &config)
    case ".json":
        err = json.Unmarshal(data, &config)
    default:
        return nil, fmt.Errorf("unsupported config format: %s", ext)
    }
    
    if err != nil {
        return nil, fmt.Errorf("failed to parse config: %w", err)
    }
    
    return &config, nil
}

// Save ä¿å­˜é…ç½®
func (c *Config) Save(path string) error {
    var data []byte
    var err error
    
    ext := filepath.Ext(path)
    switch ext {
    case ".yaml", ".yml":
        data, err = yaml.Marshal(c)
    case ".json":
        data, err = json.MarshalIndent(c, "", "  ")
    default:
        return fmt.Errorf("unsupported config format: %s", ext)
    }
    
    if err != nil {
        return fmt.Errorf("failed to marshal config: %w", err)
    }
    
    return os.WriteFile(path, data, 0644)
}
```

##### 3. æ’ä»¶ç³»ç»Ÿ

```go
// pkg/plugin/plugin.go

package plugin

import (
    "fmt"
    "plugin"
    "sync"
)

// Plugin æ’ä»¶æ¥å£
type Plugin interface {
    Name() string
    Version() string
    Init() error
    Start() error
    Stop() error
}

// PluginManager æ’ä»¶ç®¡ç†å™¨
type PluginManager struct {
    mu      sync.RWMutex
    plugins map[string]Plugin
}

// NewPluginManager åˆ›å»ºæ’ä»¶ç®¡ç†å™¨
func NewPluginManager() *PluginManager {
    return &PluginManager{
        plugins: make(map[string]Plugin),
    }
}

// Load åŠ è½½æ’ä»¶
func (pm *PluginManager) Load(path string) error {
    p, err := plugin.Open(path)
    if err != nil {
        return fmt.Errorf("failed to open plugin: %w", err)
    }
    
    // æŸ¥æ‰¾æ’ä»¶ç¬¦å·
    sym, err := p.Lookup("Plugin")
    if err != nil {
        return fmt.Errorf("plugin does not export 'Plugin': %w", err)
    }
    
    // ç±»å‹æ–­è¨€
    plug, ok := sym.(Plugin)
    if !ok {
        return fmt.Errorf("invalid plugin type")
    }
    
    // åˆå§‹åŒ–æ’ä»¶
    if err := plug.Init(); err != nil {
        return fmt.Errorf("failed to initialize plugin: %w", err)
    }
    
    pm.mu.Lock()
    pm.plugins[plug.Name()] = plug
    pm.mu.Unlock()
    
    return nil
}

// Start å¯åŠ¨æ’ä»¶
func (pm *PluginManager) Start(name string) error {
    pm.mu.RLock()
    plug, ok := pm.plugins[name]
    pm.mu.RUnlock()
    
    if !ok {
        return fmt.Errorf("plugin not found: %s", name)
    }
    
    return plug.Start()
}

// Stop åœæ­¢æ’ä»¶
func (pm *PluginManager) Stop(name string) error {
    pm.mu.RLock()
    plug, ok := pm.plugins[name]
    pm.mu.RUnlock()
    
    if !ok {
        return fmt.Errorf("plugin not found: %s", name)
    }
    
    return plug.Stop()
}

// List åˆ—å‡ºæ‰€æœ‰æ’ä»¶
func (pm *PluginManager) List() []string {
    pm.mu.RLock()
    defer pm.mu.RUnlock()
    
    names := make([]string, 0, len(pm.plugins))
    for name := range pm.plugins {
        names = append(names, name)
    }
    
    return names
}
```

---

## 3. æ¨¡å—Bï¼šæ€§èƒ½ä¼˜åŒ–

### 3.1 B3. å†…å­˜ä¼˜åŒ–

**ç›®æ ‡**: å‡å°‘å†…å­˜ä½¿ç”¨30%

**å…³é”®æŠ€æœ¯**:
- Arenaåˆ†é…å™¨ï¼ˆè§A4ï¼‰
- å¯¹è±¡æ± ä¼˜åŒ–
- æ•°æ®ç»“æ„ä¼˜åŒ–
- å†…å­˜æ³„æ¼æ£€æµ‹

**é¢„æœŸæˆæœ**:
- å†…å­˜ä½¿ç”¨ -30%
- GCæš‚åœ -40%
- ååé‡ +15%

---

### 3.2 B4. å¹¶å‘ä¼˜åŒ–

**ç›®æ ‡**: æå‡å¹¶å‘æ€§èƒ½25%

**å…³é”®æŠ€æœ¯**:
- Workeræ± ä¼˜åŒ–
- æ— é”ç®—æ³•
- Channelä¼˜åŒ–
- Goroutineæ± 

**é¢„æœŸæˆæœ**:
- ååé‡ +25%
- å»¶è¿Ÿ -20%
- CPUä½¿ç”¨ç‡ä¼˜åŒ–

---

## 4. æ¨¡å—Cï¼šç¤¾åŒºå‡†å¤‡

### 4.1 C2. åˆ›å»ºç¤ºä¾‹é¡¹ç›®

**ç›®æ ‡**: 5ä¸ªå®Œæ•´çš„ç¤ºä¾‹é¡¹ç›®

**ç¤ºä¾‹åˆ—è¡¨**:
1. **Web API Server** - RESTful API with HTTP/3
2. **gRPC Service** - å¾®æœåŠ¡ç¤ºä¾‹
3. **Worker Pool** - å¹¶å‘å¤„ç†ç¤ºä¾‹
4. **Chat Server** - WebSocketå®æ—¶é€šä¿¡
5. **ETL Pipeline** - æ•°æ®å¤„ç†æµæ°´çº¿

---

### 4.2 C3. ç¼–å†™æ•™ç¨‹å’ŒæŒ‡å—

**ç›®æ ‡**: 5ä¸ªå®Œæ•´æ•™ç¨‹

**æ•™ç¨‹åˆ—è¡¨**:
1. **å¿«é€Ÿå…¥é—¨** - 5åˆ†é’Ÿä¸Šæ‰‹
2. **é«˜çº§ç‰¹æ€§** - æ·±å…¥åŠŸèƒ½
3. **æ€§èƒ½ä¼˜åŒ–** - æœ€ä½³å®è·µ
4. **ç”Ÿäº§éƒ¨ç½²** - éƒ¨ç½²æŒ‡å—
5. **æ•…éšœæ’æŸ¥** - é—®é¢˜è¯Šæ–­

---

### 4.3 C4. å‡†å¤‡å‘å¸ƒææ–™

**æ¸…å•**:
- âœ… READMEä¼˜åŒ–
- âœ… CHANGELOGç¼–å†™
- âœ… LICENSEç¡®è®¤
- âœ… å‘å¸ƒè¯´æ˜
- âœ… è¥é”€ææ–™

---

### 4.4 C5. å»ºç«‹ç¤¾åŒºæ¸ é“

**æ¸ é“**:
- GitHub Discussions
- DiscordæœåŠ¡å™¨
- æŠ€æœ¯åšå®¢
- Twitterè´¦å·
- æ–‡æ¡£ç½‘ç«™

---

## 5. æ¨¡å—Dï¼šè´¨é‡ä¿éšœ

### 5.1 D2. ä»£ç è´¨é‡å®¡æŸ¥

**æ£€æŸ¥é¡¹**:
- âœ… Goä»£ç è§„èŒƒ
- âœ… æ€§èƒ½å®¡æŸ¥
- âœ… å®‰å…¨å®¡æŸ¥
- âœ… æ–‡æ¡£å®Œæ•´æ€§
- âœ… æµ‹è¯•è¦†ç›–ç‡

**å·¥å…·**:
- golangci-lint
- gosec
- go vet
- staticcheck

---

### 5.2 D3. å®‰å…¨å®¡è®¡

**å®¡è®¡å†…å®¹**:
- ä¾èµ–æ¼æ´æ‰«æ
- ä»£ç å®‰å…¨å®¡æŸ¥
- æ•æ„Ÿä¿¡æ¯æ£€æŸ¥
- æƒé™æ§åˆ¶å®¡æŸ¥

**å·¥å…·**:
- govulncheck
- gosec
- trivy

---

## 6. å®æ–½æ—¶é—´è¡¨

### Week 1 (Day 1-7)

| Day | ä»»åŠ¡ | è´Ÿè´£æ¨¡å— | äº§å‡º |
|-----|------|---------|------|
| 1 | HTTP/3ä¸­é—´ä»¶åŸºç¡€ | A3 | ä¸­é—´ä»¶æ¡†æ¶ |
| 2 | HTTP/3æ ¸å¿ƒä¸­é—´ä»¶ | A3 | 5ä¸ªä¸­é—´ä»¶ |
| 3 | Memory Arenaå®ç° | A4 | Arenaåˆ†é…å™¨ |
| 4 | Memory WeakCache | A4 | å¼±å¼•ç”¨ç¼“å­˜ |
| 5 | Memoryå¯¹è±¡æ± +GC | A4 | å¯¹è±¡æ± ã€GCè§¦å‘å™¨ |
| 6 | æµ‹è¯•ä¸æ–‡æ¡£ | A3+A4 | æµ‹è¯•ã€æ–‡æ¡£ |
| 7 | Code Review | - | è´¨é‡å®¡æŸ¥ |

### Week 2 (Day 8-14)

| Day | ä»»åŠ¡ | è´Ÿè´£æ¨¡å— | äº§å‡º |
|-----|------|---------|------|
| 8 | Observabilityè¿½è¸ª | A5 | åˆ†å¸ƒå¼è¿½è¸ª |
| 9 | ObservabilityæŒ‡æ ‡ | A5 | PrometheusæŒ‡æ ‡ |
| 10 | Observabilityå¥åº·æ£€æŸ¥ | A5 | å¥åº·æ£€æŸ¥ |
| 11 | CLI REPLå®ç° | A6 | REPLæ¥å£ |
| 12 | CLIé…ç½®ç®¡ç† | A6 | é…ç½®ç³»ç»Ÿ |
| 13 | CLIæ’ä»¶ç³»ç»Ÿ | A6 | æ’ä»¶ç®¡ç†å™¨ |
| 14 | å†…å­˜ä¼˜åŒ–å®æ–½ | B3 | å†…å­˜ä¼˜åŒ– |

### Week 3 (Day 15-21)

| Day | ä»»åŠ¡ | è´Ÿè´£æ¨¡å— | äº§å‡º |
|-----|------|---------|------|
| 15 | å¹¶å‘ä¼˜åŒ–å®æ–½ | B4 | å¹¶å‘ä¼˜åŒ– |
| 16 | ç¤ºä¾‹é¡¹ç›®1-2 | C2 | Web API + gRPC |
| 17 | ç¤ºä¾‹é¡¹ç›®3-5 | C2 | Worker + Chat + ETL |
| 18 | æ•™ç¨‹ç¼–å†™ | C3 | 5ä¸ªæ•™ç¨‹ |
| 19 | å‘å¸ƒææ–™å‡†å¤‡ | C4 | å‘å¸ƒææ–™ |
| 20 | ä»£ç è´¨é‡å®¡æŸ¥ | D2 | å®¡æŸ¥æŠ¥å‘Š |
| 21 | å®‰å…¨å®¡è®¡ | D3 | å®¡è®¡æŠ¥å‘Š |

---

## 7. è´¨é‡æ ‡å‡†

### 7.1 ä»£ç è´¨é‡

- âœ… æµ‹è¯•è¦†ç›–ç‡ > 70%
- âœ… æ— critical linteré”™è¯¯
- âœ… æ‰€æœ‰å…¬å¼€APIæœ‰æ–‡æ¡£
- âœ… æ€§èƒ½æµ‹è¯•é€šè¿‡

### 7.2 æ–‡æ¡£è´¨é‡

- âœ… READMEæ¸…æ™°å®Œæ•´
- âœ… APIæ–‡æ¡£å®Œæ•´
- âœ… æ•™ç¨‹æ˜“äºç†è§£
- âœ… ç¤ºä¾‹ä»£ç å¯è¿è¡Œ

### 7.3 æ€§èƒ½æ ‡å‡†

- âœ… å†…å­˜ä½¿ç”¨ -30%
- âœ… ååé‡ +20%
- âœ… å»¶è¿Ÿ -15%
- âœ… GCæš‚åœ -40%

---

## 8. é£é™©ç®¡ç†

### 8.1 æŠ€æœ¯é£é™©

| é£é™© | æ¦‚ç‡ | å½±å“ | ç¼“è§£æªæ–½ |
|------|------|------|---------|
| æ€§èƒ½ç›®æ ‡æœªè¾¾æˆ | ä¸­ | é«˜ | æå‰æ€§èƒ½æµ‹è¯• |
| APIä¸å…¼å®¹ | ä½ | é«˜ | ç‰ˆæœ¬æ§åˆ¶ |
| å†…å­˜æ³„æ¼ | ä¸­ | ä¸­ | å†…å­˜profiling |

### 8.2 æ—¶é—´é£é™©

| é£é™© | æ¦‚ç‡ | å½±å“ | ç¼“è§£æªæ–½ |
|------|------|------|---------|
| è¿›åº¦å»¶æœŸ | ä¸­ | ä¸­ | ä¼˜å…ˆçº§è°ƒæ•´ |
| äººåŠ›ä¸è¶³ | ä½ | é«˜ | ä»»åŠ¡ç®€åŒ– |

---

## ğŸ“ æ€»ç»“

### æ ¸å¿ƒç›®æ ‡

**Phase 4å®Œæˆå**:
- âœ… 12ä¸ªä»»åŠ¡å…¨éƒ¨å®Œæˆ
- âœ… æ–°å¢ä»£ç  ~7,500è¡Œ
- âœ… æ€§èƒ½æå‡ 20%+
- âœ… å†…å­˜å‡å°‘ 30%+
- âœ… é¡¹ç›®è¯„åˆ† 9.0 â†’ 9.5+

### å…³é”®é‡Œç¨‹ç¢‘

1. **Week 1**: åŠŸèƒ½å¢å¼ºåŸºç¡€å®Œæˆ
2. **Week 2**: å¯è§‚æµ‹æ€§å’ŒCLIå®Œæˆ
3. **Week 3**: ç¤¾åŒºå‡†å¤‡å’Œè´¨é‡ä¿éšœå®Œæˆ

---

**æ–‡æ¡£å®Œæˆæ—¶é—´**: 2025å¹´10æœˆ24æ—¥  
**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**å®æ–½å‘¨æœŸ**: 3å‘¨

ğŸš€ **Phase 4å®æ–½æ‰‹å†Œå®Œæˆï¼å‡†å¤‡å¯åŠ¨å®æ–½ï¼** ğŸŠ

