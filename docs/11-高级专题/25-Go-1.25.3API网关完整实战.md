# Go 1.25.3 APIç½‘å…³å®Œæ•´å®æˆ˜

**æ–‡æ¡£ç±»å‹**: APIç½‘å…³æ¶æ„æŒ‡å—  
**Goç‰ˆæœ¬**: Go 1.25.3  
**éš¾åº¦ç­‰çº§**: â­â­â­â­â­ (ä¸“å®¶çº§)  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ22æ—¥

---

## ğŸ“– æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£å±•ç¤ºGo 1.25.3çš„**APIç½‘å…³å®Œæ•´æ–¹æ¡ˆ**ï¼Œæ„å»ºç»Ÿä¸€å…¥å£ï¼š

- âœ… è·¯ç”±è½¬å‘
- âœ… è´Ÿè½½å‡è¡¡
- âœ… æœåŠ¡å‘ç°
- âœ… è®¤è¯é‰´æƒ
- âœ… é™æµç†”æ–­
- âœ… åè®®è½¬æ¢
- âœ… APIèšåˆ
- âœ… ç›‘æ§æ—¥å¿—

---

## ç›®å½•

- [Go 1.25.3 APIç½‘å…³å®Œæ•´å®æˆ˜](#go-1253-apiç½‘å…³å®Œæ•´å®æˆ˜)
  - [ğŸ“– æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. åŸºç¡€æ¶æ„](#1-åŸºç¡€æ¶æ„)
    - [1.1 ç½‘å…³æ ¸å¿ƒ](#11-ç½‘å…³æ ¸å¿ƒ)
    - [1.2 è·¯ç”±é…ç½®](#12-è·¯ç”±é…ç½®)
  - [2. è·¯ç”±è½¬å‘](#2-è·¯ç”±è½¬å‘)
    - [2.1 è·¯ç”±åŒ¹é…](#21-è·¯ç”±åŒ¹é…)
    - [2.2 åå‘ä»£ç†](#22-åå‘ä»£ç†)
  - [3. è´Ÿè½½å‡è¡¡](#3-è´Ÿè½½å‡è¡¡)
    - [3.1 è½®è¯¢ç­–ç•¥](#31-è½®è¯¢ç­–ç•¥)
    - [3.2 åŠ æƒè½®è¯¢](#32-åŠ æƒè½®è¯¢)
    - [3.3 ä¸€è‡´æ€§å“ˆå¸Œ](#33-ä¸€è‡´æ€§å“ˆå¸Œ)
  - [4. æœåŠ¡å‘ç°](#4-æœåŠ¡å‘ç°)
    - [4.1 Consulé›†æˆ](#41-consulé›†æˆ)
    - [4.2 å¥åº·æ£€æŸ¥](#42-å¥åº·æ£€æŸ¥)
  - [5. è®¤è¯é‰´æƒ](#5-è®¤è¯é‰´æƒ)
    - [5.1 JWTéªŒè¯](#51-jwtéªŒè¯)
    - [5.2 API Key](#52-api-key)
  - [6. åè®®è½¬æ¢](#6-åè®®è½¬æ¢)
    - [6.1 HTTPè½¬gRPC](#61-httpè½¬grpc)
    - [6.2 WebSocketæ”¯æŒ](#62-websocketæ”¯æŒ)
  - [7. APIèšåˆ](#7-apièšåˆ)
    - [7.1 è¯·æ±‚èšåˆ](#71-è¯·æ±‚èšåˆ)
    - [7.2 å“åº”åˆå¹¶](#72-å“åº”åˆå¹¶)
  - [8. å®Œæ•´æ¡ˆä¾‹](#8-å®Œæ•´æ¡ˆä¾‹)
    - [8.1 ç”Ÿäº§çº§ç½‘å…³](#81-ç”Ÿäº§çº§ç½‘å…³)
  - [ğŸ“š ç½‘å…³æœ€ä½³å®è·µ](#-ç½‘å…³æœ€ä½³å®è·µ)
    - [æ¶æ„è®¾è®¡](#æ¶æ„è®¾è®¡)
    - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
    - [å®‰å…¨åŠ å›º](#å®‰å…¨åŠ å›º)
    - [å¯è§‚æµ‹æ€§](#å¯è§‚æµ‹æ€§)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

---

## 1. åŸºç¡€æ¶æ„

### 1.1 ç½‘å…³æ ¸å¿ƒ

```go
package gateway

import (
 "context"
 "net/http"
 "sync"
)

// Gateway APIç½‘å…³
type Gateway struct {
 router        *Router
 balancer      LoadBalancer
 discovery     ServiceDiscovery
 authenticator Authenticator
 limiter       RateLimiter
 middleware    []Middleware
 
 mu sync.RWMutex
}

// NewGateway åˆ›å»ºç½‘å…³
func NewGateway(config Config) *Gateway {
 return &Gateway{
  router:        NewRouter(),
  balancer:      NewLoadBalancer(config.BalanceStrategy),
  discovery:     NewServiceDiscovery(config.DiscoveryConfig),
  authenticator: NewAuthenticator(config.AuthConfig),
  limiter:       NewRateLimiter(config.LimitConfig),
  middleware:    make([]Middleware, 0),
 }
}

// ServeHTTP å¤„ç†è¯·æ±‚
func (g *Gateway) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 ctx := r.Context()
 
 // æŸ¥æ‰¾è·¯ç”±
 route, params, ok := g.router.Match(r.Method, r.URL.Path)
 if !ok {
  http.Error(w, "Not Found", http.StatusNotFound)
  return
 }
 
 // è®¾ç½®è·¯å¾„å‚æ•°
 ctx = context.WithValue(ctx, "params", params)
 
 // æ„å»ºå¤„ç†é“¾
 handler := g.buildHandler(route)
 
 // æ‰§è¡Œå¤„ç†
 handler.ServeHTTP(w, r.WithContext(ctx))
}

// buildHandler æ„å»ºå¤„ç†é“¾
func (g *Gateway) buildHandler(route *Route) http.Handler {
 handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  g.proxyRequest(w, r, route)
 })
 
 // åº”ç”¨ä¸­é—´ä»¶ï¼ˆå€’åºï¼‰
 for i := len(g.middleware) - 1; i >= 0; i-- {
  handler = g.middleware[i](handler)
 }
 
 return handler
}

// Use æ·»åŠ ä¸­é—´ä»¶
func (g *Gateway) Use(middleware ...Middleware) {
 g.middleware = append(g.middleware, middleware...)
}

// AddRoute æ·»åŠ è·¯ç”±
func (g *Gateway) AddRoute(method, pattern string, backend *Backend) {
 g.router.Add(method, pattern, &Route{
  Backend: backend,
 })
}
```

---

### 1.2 è·¯ç”±é…ç½®

```go
// Route è·¯ç”±
type Route struct {
 Backend     *Backend
 Rewrite     string
 Timeout     time.Duration
 RetryCount  int
 CacheTTL    time.Duration
}

// Backend åç«¯æœåŠ¡
type Backend struct {
 Name      string
 Endpoints []string
 Protocol  string
 Timeout   time.Duration
 HealthCheck *HealthCheck
}

// Config ç½‘å…³é…ç½®
type Config struct {
 BalanceStrategy string
 DiscoveryConfig *DiscoveryConfig
 AuthConfig      *AuthConfig
 LimitConfig     *LimitConfig
}

// DiscoveryConfig æœåŠ¡å‘ç°é…ç½®
type DiscoveryConfig struct {
 Type    string // consul, etcd, etc.
 Address string
}

// AuthConfig è®¤è¯é…ç½®
type AuthConfig struct {
 Type      string // jwt, apikey, oauth2
 SecretKey string
}

// LimitConfig é™æµé…ç½®
type LimitConfig struct {
 Global  int // å…¨å±€é™æµ
 PerIP   int // æ¯IPé™æµ
 PerUser int // æ¯ç”¨æˆ·é™æµ
}
```

---

## 2. è·¯ç”±è½¬å‘

### 2.1 è·¯ç”±åŒ¹é…

```go
package gateway

import (
 "strings"
)

// Router è·¯ç”±å™¨
type Router struct {
 routes map[string]*routeNode
}

type routeNode struct {
 pattern  string
 handlers map[string]*Route // method -> route
 params   []string
}

// NewRouter åˆ›å»ºè·¯ç”±å™¨
func NewRouter() *Router {
 return &Router{
  routes: make(map[string]*routeNode),
 }
}

// Add æ·»åŠ è·¯ç”±
func (r *Router) Add(method, pattern string, route *Route) {
 node, ok := r.routes[pattern]
 if !ok {
  node = &routeNode{
   pattern:  pattern,
   handlers: make(map[string]*Route),
   params:   extractParams(pattern),
  }
  r.routes[pattern] = node
 }
 
 node.handlers[method] = route
}

// Match åŒ¹é…è·¯ç”±
func (r *Router) Match(method, path string) (*Route, map[string]string, bool) {
 for pattern, node := range r.routes {
  if params, ok := matchPattern(pattern, path); ok {
   if route, ok := node.handlers[method]; ok {
    return route, params, true
   }
  }
 }
 
 return nil, nil, false
}

// extractParams æå–å‚æ•°
func extractParams(pattern string) []string {
 params := make([]string, 0)
 parts := strings.Split(pattern, "/")
 
 for _, part := range parts {
  if strings.HasPrefix(part, ":") {
   params = append(params, part[1:])
  }
 }
 
 return params
}

// matchPattern åŒ¹é…æ¨¡å¼
func matchPattern(pattern, path string) (map[string]string, bool) {
 patternParts := strings.Split(pattern, "/")
 pathParts := strings.Split(path, "/")
 
 if len(patternParts) != len(pathParts) {
  return nil, false
 }
 
 params := make(map[string]string)
 
 for i, part := range patternParts {
  if strings.HasPrefix(part, ":") {
   params[part[1:]] = pathParts[i]
  } else if part != pathParts[i] {
   return nil, false
  }
 }
 
 return params, true
}
```

---

### 2.2 åå‘ä»£ç†

```go
// proxyRequest ä»£ç†è¯·æ±‚
func (g *Gateway) proxyRequest(w http.ResponseWriter, r *http.Request, route *Route) {
 // 1. é€‰æ‹©åç«¯
 endpoint, err := g.balancer.Select(route.Backend.Endpoints)
 if err != nil {
  http.Error(w, "No available backend", http.StatusServiceUnavailable)
  return
 }
 
 // 2. åˆ›å»ºä»£ç†è¯·æ±‚
 proxyReq, err := http.NewRequest(r.Method, endpoint+r.URL.Path, r.Body)
 if err != nil {
  http.Error(w, "Internal Server Error", http.StatusInternalServerError)
  return
 }
 
 // 3. å¤åˆ¶è¯·æ±‚å¤´
 copyHeaders(proxyReq.Header, r.Header)
 
 // 4. æ·»åŠ X-Forwarded-*å¤´
 proxyReq.Header.Set("X-Forwarded-For", r.RemoteAddr)
 proxyReq.Header.Set("X-Forwarded-Proto", r.URL.Scheme)
 proxyReq.Header.Set("X-Forwarded-Host", r.Host)
 
 // 5. å‘é€è¯·æ±‚
 client := &http.Client{
  Timeout: route.Timeout,
 }
 
 resp, err := client.Do(proxyReq)
 if err != nil {
  http.Error(w, "Bad Gateway", http.StatusBadGateway)
  return
 }
 defer resp.Body.Close()
 
 // 6. å¤åˆ¶å“åº”å¤´
 copyHeaders(w.Header(), resp.Header)
 
 // 7. å†™å…¥å“åº”
 w.WriteHeader(resp.StatusCode)
 io.Copy(w, resp.Body)
}

// copyHeaders å¤åˆ¶HTTPå¤´
func copyHeaders(dst, src http.Header) {
 for key, values := range src {
  for _, value := range values {
   dst.Add(key, value)
  }
 }
}
```

---

## 3. è´Ÿè½½å‡è¡¡

### 3.1 è½®è¯¢ç­–ç•¥

```go
package loadbalancer

import (
 "errors"
 "sync"
)

// RoundRobinBalancer è½®è¯¢è´Ÿè½½å‡è¡¡
type RoundRobinBalancer struct {
 current int
 mu      sync.Mutex
}

// NewRoundRobinBalancer åˆ›å»ºè½®è¯¢è´Ÿè½½å‡è¡¡
func NewRoundRobinBalancer() *RoundRobinBalancer {
 return &RoundRobinBalancer{}
}

// Select é€‰æ‹©åç«¯
func (rrb *RoundRobinBalancer) Select(endpoints []string) (string, error) {
 if len(endpoints) == 0 {
  return "", errors.New("no endpoints available")
 }
 
 rrb.mu.Lock()
 defer rrb.mu.Unlock()
 
 endpoint := endpoints[rrb.current%len(endpoints)]
 rrb.current++
 
 return endpoint, nil
}
```

---

### 3.2 åŠ æƒè½®è¯¢

```go
// WeightedRoundRobinBalancer åŠ æƒè½®è¯¢
type WeightedRoundRobinBalancer struct {
 endpoints []WeightedEndpoint
 current   int
 gcd       int
 maxWeight int
 mu        sync.Mutex
}

// WeightedEndpoint åŠ æƒç«¯ç‚¹
type WeightedEndpoint struct {
 URL    string
 Weight int
}

// NewWeightedRoundRobinBalancer åˆ›å»ºåŠ æƒè½®è¯¢
func NewWeightedRoundRobinBalancer(endpoints []WeightedEndpoint) *WeightedRoundRobinBalancer {
 gcd := calculateGCD(endpoints)
 maxWeight := getMaxWeight(endpoints)
 
 return &WeightedRoundRobinBalancer{
  endpoints: endpoints,
  gcd:       gcd,
  maxWeight: maxWeight,
 }
}

// Select é€‰æ‹©åç«¯
func (wrrb *WeightedRoundRobinBalancer) Select(endpoints []string) (string, error) {
 wrrb.mu.Lock()
 defer wrrb.mu.Unlock()
 
 for {
  wrrb.current = (wrrb.current + 1) % len(wrrb.endpoints)
  
  if wrrb.current == 0 {
   wrrb.maxWeight -= wrrb.gcd
   if wrrb.maxWeight <= 0 {
    wrrb.maxWeight = getMaxWeight(wrrb.endpoints)
   }
  }
  
  if wrrb.endpoints[wrrb.current].Weight >= wrrb.maxWeight {
   return wrrb.endpoints[wrrb.current].URL, nil
  }
 }
}

// calculateGCD è®¡ç®—æœ€å¤§å…¬çº¦æ•°
func calculateGCD(endpoints []WeightedEndpoint) int {
 divisor := 0
 for _, ep := range endpoints {
  divisor = gcd(divisor, ep.Weight)
 }
 return divisor
}

func gcd(a, b int) int {
 if b == 0 {
  return a
 }
 return gcd(b, a%b)
}

// getMaxWeight è·å–æœ€å¤§æƒé‡
func getMaxWeight(endpoints []WeightedEndpoint) int {
 max := 0
 for _, ep := range endpoints {
  if ep.Weight > max {
   max = ep.Weight
  }
 }
 return max
}
```

---

### 3.3 ä¸€è‡´æ€§å“ˆå¸Œ

```go
// ConsistentHashBalancer ä¸€è‡´æ€§å“ˆå¸Œ
type ConsistentHashBalancer struct {
 circle       map[uint32]string
 sortedHashes []uint32
 replicas     int
 mu           sync.RWMutex
}

// NewConsistentHashBalancer åˆ›å»ºä¸€è‡´æ€§å“ˆå¸Œ
func NewConsistentHashBalancer(replicas int) *ConsistentHashBalancer {
 return &ConsistentHashBalancer{
  circle:   make(map[uint32]string),
  replicas: replicas,
 }
}

// AddNode æ·»åŠ èŠ‚ç‚¹
func (chb *ConsistentHashBalancer) AddNode(endpoint string) {
 chb.mu.Lock()
 defer chb.mu.Unlock()
 
 for i := 0; i < chb.replicas; i++ {
  hash := crc32.ChecksumIEEE([]byte(fmt.Sprintf("%s:%d", endpoint, i)))
  chb.circle[hash] = endpoint
  chb.sortedHashes = append(chb.sortedHashes, hash)
 }
 
 sort.Slice(chb.sortedHashes, func(i, j int) bool {
  return chb.sortedHashes[i] < chb.sortedHashes[j]
 })
}

// Select é€‰æ‹©åç«¯
func (chb *ConsistentHashBalancer) Select(key string) (string, error) {
 chb.mu.RLock()
 defer chb.mu.RUnlock()
 
 if len(chb.circle) == 0 {
  return "", errors.New("no endpoints available")
 }
 
 hash := crc32.ChecksumIEEE([]byte(key))
 
 // äºŒåˆ†æŸ¥æ‰¾
 idx := sort.Search(len(chb.sortedHashes), func(i int) bool {
  return chb.sortedHashes[i] >= hash
 })
 
 if idx == len(chb.sortedHashes) {
  idx = 0
 }
 
 return chb.circle[chb.sortedHashes[idx]], nil
}
```

---

## 4. æœåŠ¡å‘ç°

### 4.1 Consulé›†æˆ

```go
package discovery

import (
 "fmt"
 
 "github.com/hashicorp/consul/api"
)

// ConsulDiscovery ConsulæœåŠ¡å‘ç°
type ConsulDiscovery struct {
 client *api.Client
}

// NewConsulDiscovery åˆ›å»ºConsulæœåŠ¡å‘ç°
func NewConsulDiscovery(address string) (*ConsulDiscovery, error) {
 config := api.DefaultConfig()
 config.Address = address
 
 client, err := api.NewClient(config)
 if err != nil {
  return nil, err
 }
 
 return &ConsulDiscovery{
  client: client,
 }, nil
}

// GetService è·å–æœåŠ¡å®ä¾‹
func (cd *ConsulDiscovery) GetService(serviceName string) ([]string, error) {
 services, _, err := cd.client.Health().Service(serviceName, "", true, nil)
 if err != nil {
  return nil, err
 }
 
 endpoints := make([]string, 0, len(services))
 for _, service := range services {
  endpoint := fmt.Sprintf("http://%s:%d", service.Service.Address, service.Service.Port)
  endpoints = append(endpoints, endpoint)
 }
 
 return endpoints, nil
}

// WatchService ç›‘å¬æœåŠ¡å˜åŒ–
func (cd *ConsulDiscovery) WatchService(serviceName string, callback func([]string)) {
 go func() {
  var lastIndex uint64
  
  for {
   services, meta, err := cd.client.Health().Service(
    serviceName, "", true, &api.QueryOptions{
     WaitIndex: lastIndex,
     WaitTime:  time.Minute,
    })
   
   if err != nil {
    time.Sleep(time.Second * 5)
    continue
   }
   
   lastIndex = meta.LastIndex
   
   endpoints := make([]string, 0, len(services))
   for _, service := range services {
    endpoint := fmt.Sprintf("http://%s:%d", service.Service.Address, service.Service.Port)
    endpoints = append(endpoints, endpoint)
   }
   
   callback(endpoints)
  }
 }()
}
```

---

### 4.2 å¥åº·æ£€æŸ¥

```go
// HealthChecker å¥åº·æ£€æŸ¥å™¨
type HealthChecker struct {
 endpoints map[string]*EndpointHealth
 mu        sync.RWMutex
}

// EndpointHealth ç«¯ç‚¹å¥åº·çŠ¶æ€
type EndpointHealth struct {
 URL           string
 Healthy       bool
 LastCheck     time.Time
 FailureCount  int
 SuccessCount  int
}

// NewHealthChecker åˆ›å»ºå¥åº·æ£€æŸ¥å™¨
func NewHealthChecker() *HealthChecker {
 hc := &HealthChecker{
  endpoints: make(map[string]*EndpointHealth),
 }
 
 go hc.startChecking()
 
 return hc
}

// AddEndpoint æ·»åŠ ç«¯ç‚¹
func (hc *HealthChecker) AddEndpoint(url string) {
 hc.mu.Lock()
 defer hc.mu.Unlock()
 
 hc.endpoints[url] = &EndpointHealth{
  URL:     url,
  Healthy: true,
 }
}

// IsHealthy æ£€æŸ¥æ˜¯å¦å¥åº·
func (hc *HealthChecker) IsHealthy(url string) bool {
 hc.mu.RLock()
 defer hc.mu.RUnlock()
 
 if health, ok := hc.endpoints[url]; ok {
  return health.Healthy
 }
 
 return false
}

// startChecking å¼€å§‹æ£€æŸ¥
func (hc *HealthChecker) startChecking() {
 ticker := time.NewTicker(10 * time.Second)
 defer ticker.Stop()
 
 for range ticker.C {
  hc.mu.RLock()
  endpoints := make([]*EndpointHealth, 0, len(hc.endpoints))
  for _, ep := range hc.endpoints {
   endpoints = append(endpoints, ep)
  }
  hc.mu.RUnlock()
  
  for _, ep := range endpoints {
   go hc.checkEndpoint(ep)
  }
 }
}

// checkEndpoint æ£€æŸ¥ç«¯ç‚¹
func (hc *HealthChecker) checkEndpoint(ep *EndpointHealth) {
 client := &http.Client{
  Timeout: 5 * time.Second,
 }
 
 resp, err := client.Get(ep.URL + "/health")
 
 hc.mu.Lock()
 defer hc.mu.Unlock()
 
 ep.LastCheck = time.Now()
 
 if err != nil || resp.StatusCode != http.StatusOK {
  ep.FailureCount++
  ep.SuccessCount = 0
  
  if ep.FailureCount >= 3 {
   ep.Healthy = false
  }
 } else {
  ep.SuccessCount++
  ep.FailureCount = 0
  
  if ep.SuccessCount >= 2 {
   ep.Healthy = true
  }
 }
}
```

---

## 5. è®¤è¯é‰´æƒ

### 5.1 JWTéªŒè¯

```go
// JWTAuthMiddleware JWTè®¤è¯ä¸­é—´ä»¶
func JWTAuthMiddleware(jwtManager *auth.JWTManager) Middleware {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   // è·å–token
   token := r.Header.Get("Authorization")
   if token == "" {
    http.Error(w, "Missing authorization", http.StatusUnauthorized)
    return
   }
   
   // ç§»é™¤Bearerå‰ç¼€
   if len(token) > 7 && token[:7] == "Bearer " {
    token = token[7:]
   }
   
   // éªŒè¯token
   claims, err := jwtManager.ValidateToken(token)
   if err != nil {
    http.Error(w, "Invalid token", http.StatusUnauthorized)
    return
   }
   
   // è®¾ç½®ç”¨æˆ·ä¿¡æ¯åˆ°context
   ctx := context.WithValue(r.Context(), "user", claims)
   next.ServeHTTP(w, r.WithContext(ctx))
  })
 }
}
```

---

### 5.2 API Key

```go
// APIKeyAuthMiddleware API Keyè®¤è¯ä¸­é—´ä»¶
func APIKeyAuthMiddleware(store APIKeyStore) Middleware {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   // è·å–API Key
   apiKey := r.Header.Get("X-API-Key")
   if apiKey == "" {
    http.Error(w, "Missing API key", http.StatusUnauthorized)
    return
   }
   
   // éªŒè¯API Key
   user, err := store.Validate(r.Context(), apiKey)
   if err != nil {
    http.Error(w, "Invalid API key", http.StatusUnauthorized)
    return
   }
   
   // è®¾ç½®ç”¨æˆ·ä¿¡æ¯åˆ°context
   ctx := context.WithValue(r.Context(), "user", user)
   next.ServeHTTP(w, r.WithContext(ctx))
  })
 }
}

// APIKeyStore API Keyå­˜å‚¨æ¥å£
type APIKeyStore interface {
 Validate(ctx context.Context, apiKey string) (*User, error)
}
```

---

## 6. åè®®è½¬æ¢

### 6.1 HTTPè½¬gRPC

```go
package protocol

import (
 "context"
 "encoding/json"
 "net/http"
 
 "google.golang.org/grpc"
)

// HTTPToGRPCHandler HTTPè½¬gRPCå¤„ç†å™¨
type HTTPToGRPCHandler struct {
 conn *grpc.ClientConn
}

// NewHTTPToGRPCHandler åˆ›å»ºHTTPè½¬gRPCå¤„ç†å™¨
func NewHTTPToGRPCHandler(target string) (*HTTPToGRPCHandler, error) {
 conn, err := grpc.Dial(target, grpc.WithInsecure())
 if err != nil {
  return nil, err
 }
 
 return &HTTPToGRPCHandler{
  conn: conn,
 }, nil
}

// ServeHTTP å¤„ç†HTTPè¯·æ±‚
func (h *HTTPToGRPCHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 // 1. è§£æHTTPè¯·æ±‚ä½“
 var reqData map[string]interface{}
 if err := json.NewDecoder(r.Body).Decode(&reqData); err != nil {
  http.Error(w, "Invalid request body", http.StatusBadRequest)
  return
 }
 
 // 2. è½¬æ¢ä¸ºgRPCè¯·æ±‚
 // è¿™é‡Œéœ€è¦æ ¹æ®å…·ä½“çš„protoå®šä¹‰è¿›è¡Œè½¬æ¢
 // ...
 
 // 3. è°ƒç”¨gRPCæœåŠ¡
 ctx := r.Context()
 // resp, err := grpcClient.Method(ctx, grpcReq)
 
 // 4. è½¬æ¢gRPCå“åº”ä¸ºHTTPå“åº”
 // ...
 
 // 5. è¿”å›HTTPå“åº”
 w.Header().Set("Content-Type", "application/json")
 // json.NewEncoder(w).Encode(httpResp)
}
```

---

### 6.2 WebSocketæ”¯æŒ

```go
// WebSocketProxy WebSocketä»£ç†
type WebSocketProxy struct {
 target string
}

// NewWebSocketProxy åˆ›å»ºWebSocketä»£ç†
func NewWebSocketProxy(target string) *WebSocketProxy {
 return &WebSocketProxy{
  target: target,
 }
}

// ServeHTTP å¤„ç†WebSocketè¯·æ±‚
func (wsp *WebSocketProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 // å‡çº§åˆ°WebSocket
 upgrader := websocket.Upgrader{
  CheckOrigin: func(r *http.Request) bool {
   return true
  },
 }
 
 clientConn, err := upgrader.Upgrade(w, r, nil)
 if err != nil {
  return
 }
 defer clientConn.Close()
 
 // è¿æ¥åç«¯WebSocket
 backendConn, _, err := websocket.DefaultDialer.Dial(wsp.target, nil)
 if err != nil {
  return
 }
 defer backendConn.Close()
 
 // åŒå‘è½¬å‘
 go func() {
  for {
   messageType, data, err := clientConn.ReadMessage()
   if err != nil {
    return
   }
   
   if err := backendConn.WriteMessage(messageType, data); err != nil {
    return
   }
  }
 }()
 
 for {
  messageType, data, err := backendConn.ReadMessage()
  if err != nil {
   return
  }
  
  if err := clientConn.WriteMessage(messageType, data); err != nil {
   return
  }
 }
}
```

---

## 7. APIèšåˆ

### 7.1 è¯·æ±‚èšåˆ

```go
package aggregator

import (
 "context"
 "encoding/json"
 "net/http"
 "sync"
)

// Aggregator APIèšåˆå™¨
type Aggregator struct {
 requests []AggregateRequest
}

// AggregateRequest èšåˆè¯·æ±‚
type AggregateRequest struct {
 Name   string
 URL    string
 Method string
}

// NewAggregator åˆ›å»ºèšåˆå™¨
func NewAggregator(requests []AggregateRequest) *Aggregator {
 return &Aggregator{
  requests: requests,
 }
}

// Execute æ‰§è¡Œèšåˆè¯·æ±‚
func (a *Aggregator) Execute(ctx context.Context) (map[string]interface{}, error) {
 results := make(map[string]interface{})
 var mu sync.Mutex
 var wg sync.WaitGroup
 
 errChan := make(chan error, len(a.requests))
 
 for _, req := range a.requests {
  wg.Add(1)
  
  go func(r AggregateRequest) {
   defer wg.Done()
   
   // å‘é€HTTPè¯·æ±‚
   httpReq, err := http.NewRequestWithContext(ctx, r.Method, r.URL, nil)
   if err != nil {
    errChan <- err
    return
   }
   
   client := &http.Client{
    Timeout: 5 * time.Second,
   }
   
   resp, err := client.Do(httpReq)
   if err != nil {
    errChan <- err
    return
   }
   defer resp.Body.Close()
   
   // è§£æå“åº”
   var data interface{}
   if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
    errChan <- err
    return
   }
   
   // ä¿å­˜ç»“æœ
   mu.Lock()
   results[r.Name] = data
   mu.Unlock()
  }(req)
 }
 
 wg.Wait()
 close(errChan)
 
 // æ£€æŸ¥é”™è¯¯
 for err := range errChan {
  if err != nil {
   return nil, err
  }
 }
 
 return results, nil
}
```

---

### 7.2 å“åº”åˆå¹¶

```go
// AggregatorMiddleware èšåˆä¸­é—´ä»¶
func AggregatorMiddleware() Middleware {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   // æ£€æŸ¥æ˜¯å¦éœ€è¦èšåˆ
   if r.Header.Get("X-Aggregate") != "true" {
    next.ServeHTTP(w, r)
    return
   }
   
   // è§£æèšåˆè¯·æ±‚
   var aggReqs []AggregateRequest
   if err := json.NewDecoder(r.Body).Decode(&aggReqs); err != nil {
    http.Error(w, "Invalid aggregate request", http.StatusBadRequest)
    return
   }
   
   // æ‰§è¡Œèšåˆ
   aggregator := NewAggregator(aggReqs)
   results, err := aggregator.Execute(r.Context())
   if err != nil {
    http.Error(w, "Aggregation failed", http.StatusInternalServerError)
    return
   }
   
   // è¿”å›ç»“æœ
   w.Header().Set("Content-Type", "application/json")
   json.NewEncoder(w).Encode(results)
  })
 }
}
```

---

## 8. å®Œæ•´æ¡ˆä¾‹

### 8.1 ç”Ÿäº§çº§ç½‘å…³

```go
package main

import (
 "log"
 "net/http"
 "time"
)

func main() {
 // 1. åˆ›å»ºç½‘å…³é…ç½®
 config := gateway.Config{
  BalanceStrategy: "round_robin",
  DiscoveryConfig: &gateway.DiscoveryConfig{
   Type:    "consul",
   Address: "localhost:8500",
  },
  AuthConfig: &gateway.AuthConfig{
   Type:      "jwt",
   SecretKey: "my-secret-key",
  },
  LimitConfig: &gateway.LimitConfig{
   Global:  10000,
   PerIP:   100,
   PerUser: 1000,
  },
 }
 
 // 2. åˆ›å»ºç½‘å…³
 gw := gateway.NewGateway(config)
 
 // 3. æ·»åŠ å…¨å±€ä¸­é—´ä»¶
 gw.Use(
  LoggingMiddleware(),
  RecoveryMiddleware(),
  CORSMiddleware(),
  RateLimitMiddleware(config.LimitConfig),
  JWTAuthMiddleware(jwtManager),
  TracingMiddleware(),
 )
 
 // 4. æ·»åŠ è·¯ç”±
 gw.AddRoute("GET", "/api/users/:id", &gateway.Backend{
  Name:      "user-service",
  Endpoints: []string{"http://localhost:8081"},
  Protocol:  "http",
  Timeout:   5 * time.Second,
 })
 
 gw.AddRoute("POST", "/api/orders", &gateway.Backend{
  Name:      "order-service",
  Endpoints: []string{"http://localhost:8082"},
  Protocol:  "http",
  Timeout:   10 * time.Second,
 })
 
 // 5. å¯åŠ¨æœåŠ¡å‘ç°ç›‘å¬
 discovery, _ := discovery.NewConsulDiscovery("localhost:8500")
 discovery.WatchService("user-service", func(endpoints []string) {
  log.Printf("User service endpoints updated: %v", endpoints)
  // æ›´æ–°åç«¯ç«¯ç‚¹
 })
 
 // 6. å¯åŠ¨ç½‘å…³
 server := &http.Server{
  Addr:         ":8080",
  Handler:      gw,
  ReadTimeout:  10 * time.Second,
  WriteTimeout: 10 * time.Second,
  IdleTimeout:  120 * time.Second,
 }
 
 log.Println("API Gateway starting on :8080")
 log.Fatal(server.ListenAndServe())
}

// LoggingMiddleware æ—¥å¿—ä¸­é—´ä»¶
func LoggingMiddleware() gateway.Middleware {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   start := time.Now()
   
   recorder := &statusRecorder{
    ResponseWriter: w,
    statusCode:     http.StatusOK,
   }
   
   next.ServeHTTP(recorder, r)
   
   log.Printf("%s %s %d %v", r.Method, r.URL.Path, recorder.statusCode, time.Since(start))
  })
 }
}

// RecoveryMiddleware æ¢å¤ä¸­é—´ä»¶
func RecoveryMiddleware() gateway.Middleware {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   defer func() {
    if err := recover(); err != nil {
     log.Printf("Panic recovered: %v", err)
     http.Error(w, "Internal Server Error", http.StatusInternalServerError)
    }
   }()
   
   next.ServeHTTP(w, r)
  })
 }
}

// CORSMiddleware CORSä¸­é—´ä»¶
func CORSMiddleware() gateway.Middleware {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   w.Header().Set("Access-Control-Allow-Origin", "*")
   w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
   w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
   
   if r.Method == "OPTIONS" {
    w.WriteHeader(http.StatusOK)
    return
   }
   
   next.ServeHTTP(w, r)
  })
 }
}

type statusRecorder struct {
 http.ResponseWriter
 statusCode int
}

func (sr *statusRecorder) WriteHeader(code int) {
 sr.statusCode = code
 sr.ResponseWriter.WriteHeader(code)
}
```

---

## ğŸ“š ç½‘å…³æœ€ä½³å®è·µ

### æ¶æ„è®¾è®¡

- âœ… æ— çŠ¶æ€è®¾è®¡ï¼Œæ˜“äºæ°´å¹³æ‰©å±•
- âœ… æœåŠ¡å‘ç°ï¼ŒåŠ¨æ€è·¯ç”±
- âœ… å¼‚æ­¥æ—¥å¿—ï¼Œæå‡æ€§èƒ½
- âœ… ç†”æ–­é™çº§ï¼Œä¿æŠ¤åç«¯

### æ€§èƒ½ä¼˜åŒ–

- âœ… è¿æ¥æ± å¤ç”¨
- âœ… å“åº”ç¼“å­˜
- âœ… è¯·æ±‚æ‰¹å¤„ç†
- âœ… åè®®ä¼˜åŒ–ï¼ˆHTTP/2ã€gRPCï¼‰

### å®‰å…¨åŠ å›º

- âœ… è®¤è¯é‰´æƒ
- âœ… é™æµé˜²åˆ·
- âœ… DDoSé˜²æŠ¤
- âœ… æ•°æ®åŠ å¯†

### å¯è§‚æµ‹æ€§

- âœ… è¯·æ±‚è¿½è¸ª
- âœ… æ€§èƒ½ç›‘æ§
- âœ… é”™è¯¯å‘Šè­¦
- âœ… å®¡è®¡æ—¥å¿—

---

## ğŸ¯ æ€»ç»“

Go 1.25.3 APIç½‘å…³å…³é”®ç‚¹ï¼š

1. **è·¯ç”±è½¬å‘**: æ¨¡å¼åŒ¹é…ã€åå‘ä»£ç†ã€è¯·æ±‚é‡å†™
2. **è´Ÿè½½å‡è¡¡**: è½®è¯¢ã€åŠ æƒã€ä¸€è‡´æ€§å“ˆå¸Œ
3. **æœåŠ¡å‘ç°**: Consulé›†æˆã€å¥åº·æ£€æŸ¥ã€åŠ¨æ€æ›´æ–°
4. **è®¤è¯é‰´æƒ**: JWTã€API Keyã€OAuth 2.0
5. **é™æµç†”æ–­**: å¤šçº§é™æµã€ç†”æ–­é™çº§ã€è¿‡è½½ä¿æŠ¤
6. **åè®®è½¬æ¢**: HTTP/gRPCã€WebSocketã€åŒå‘æµ
7. **APIèšåˆ**: å¹¶å‘è¯·æ±‚ã€å“åº”åˆå¹¶ã€è¶…æ—¶æ§åˆ¶

**APIç½‘å…³æ˜¯å¾®æœåŠ¡æ¶æ„çš„ç»Ÿä¸€å…¥å£ï¼**

---

<div align="center">

**æ„å»ºé«˜æ€§èƒ½APIç½‘å…³**:

[ğŸ“š è¿”å›ç›®å½•](../README.md) | [ğŸ“– ä¸‹ä¸€ç« ](26-ä¸‹ä¸€ä¸»é¢˜.md)

Made with â¤ï¸ for Go Developers

</div>

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-10-22  
**Goç‰ˆæœ¬**: Go 1.25.3  
**ç”Ÿäº§å°±ç»ª**: âœ…
