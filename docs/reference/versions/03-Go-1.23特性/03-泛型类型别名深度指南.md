# Go 1.23 æ³›å‹ç±»å‹åˆ«åæ·±åº¦æŒ‡å—

> **å¼•å…¥ç‰ˆæœ¬**: Go 1.23 (2024å¹´8æœˆ)  
> **æ›´æ–°æ—¥æœŸ**: 2025å¹´10æœˆ24æ—¥  
> **çŠ¶æ€**: âœ… ç¨³å®š  
> **éš¾åº¦**: â­â­â­â­  
> **æ ‡ç­¾**: #Go1.23 #æ³›å‹ #ç±»å‹åˆ«å #type-alias

---

## ğŸ“š ç›®å½•

- [Go 1.23 æ³›å‹ç±»å‹åˆ«åæ·±åº¦æŒ‡å—](#go-123-æ³›å‹ç±»å‹åˆ«åæ·±åº¦æŒ‡å—)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [1. æ³›å‹ç±»å‹åˆ«åï¼šçªç ´æ€§è¿›å±•](#1-æ³›å‹ç±»å‹åˆ«åçªç ´æ€§è¿›å±•)
    - [1.1 å†å²èƒŒæ™¯](#11-å†å²èƒŒæ™¯)
    - [1.2 Go 1.23çš„çªç ´](#12-go-123çš„çªç ´)
    - [1.3 æ ¸å¿ƒä»·å€¼](#13-æ ¸å¿ƒä»·å€¼)
  - [2. åŸºç¡€æ¦‚å¿µ](#2-åŸºç¡€æ¦‚å¿µ)
    - [2.1 ä»€ä¹ˆæ˜¯ç±»å‹åˆ«å](#21-ä»€ä¹ˆæ˜¯ç±»å‹åˆ«å)
    - [2.2 ä»€ä¹ˆæ˜¯æ³›å‹ç±»å‹åˆ«å](#22-ä»€ä¹ˆæ˜¯æ³›å‹ç±»å‹åˆ«å)
    - [2.3 è¯­æ³•å¯¹æ¯”](#23-è¯­æ³•å¯¹æ¯”)
  - [3. æ³›å‹ç±»å‹åˆ«åè¯¦è§£](#3-æ³›å‹ç±»å‹åˆ«åè¯¦è§£)
    - [3.1 åŸºæœ¬è¯­æ³•](#31-åŸºæœ¬è¯­æ³•)
    - [3.2 ç±»å‹å‚æ•°](#32-ç±»å‹å‚æ•°)
    - [3.3 çº¦æŸæ¡ä»¶](#33-çº¦æŸæ¡ä»¶)
  - [4. å®æˆ˜åº”ç”¨åœºæ™¯](#4-å®æˆ˜åº”ç”¨åœºæ™¯)
    - [4.1 ç®€åŒ–å¤æ‚æ³›å‹ç±»å‹](#41-ç®€åŒ–å¤æ‚æ³›å‹ç±»å‹)
    - [4.2 è¿ç§»è¾…åŠ©](#42-è¿ç§»è¾…åŠ©)
    - [4.3 APIæ¼”è¿›](#43-apiæ¼”è¿›)
    - [4.4 ç±»å‹ç»„åˆ](#44-ç±»å‹ç»„åˆ)
  - [5. ä¸ä¼ ç»Ÿæ–¹æ¡ˆå¯¹æ¯”](#5-ä¸ä¼ ç»Ÿæ–¹æ¡ˆå¯¹æ¯”)
    - [5.1 vs ç±»å‹å®šä¹‰(type definition)](#51-vs-ç±»å‹å®šä¹‰type-definition)
    - [5.2 vs æ¥å£](#52-vs-æ¥å£)
    - [5.3 vs å‡½æ•°åŒ…è£…](#53-vs-å‡½æ•°åŒ…è£…)
  - [6. é«˜çº§ç”¨æ³•](#6-é«˜çº§ç”¨æ³•)
    - [6.1 åµŒå¥—æ³›å‹åˆ«å](#61-åµŒå¥—æ³›å‹åˆ«å)
    - [6.2 å¤šç±»å‹å‚æ•°](#62-å¤šç±»å‹å‚æ•°)
    - [6.3 é€’å½’ç±»å‹åˆ«å](#63-é€’å½’ç±»å‹åˆ«å)
  - [7. æ ‡å‡†åº“ä¸­çš„åº”ç”¨](#7-æ ‡å‡†åº“ä¸­çš„åº”ç”¨)
    - [7.1 cmpåŒ…](#71-cmpåŒ…)
    - [7.2 slicesåŒ…](#72-slicesåŒ…)
    - [7.3 mapsåŒ…](#73-mapsåŒ…)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
    - [8.1 å‘½åè§„èŒƒ](#81-å‘½åè§„èŒƒ)
    - [8.2 ä½¿ç”¨åœºæ™¯](#82-ä½¿ç”¨åœºæ™¯)
    - [8.3 é¿å…æ»¥ç”¨](#83-é¿å…æ»¥ç”¨)
  - [9. å¸¸è§é™·é˜±](#9-å¸¸è§é™·é˜±)
    - [9.1 ç±»å‹æ¨æ–­é™åˆ¶](#91-ç±»å‹æ¨æ–­é™åˆ¶)
    - [9.2 å¾ªç¯ä¾èµ–](#92-å¾ªç¯ä¾èµ–)
    - [9.3 å¯¼å‡ºè§„åˆ™](#93-å¯¼å‡ºè§„åˆ™)
  - [10. è¿ç§»æŒ‡å—](#10-è¿ç§»æŒ‡å—)
    - [10.1 ä»interface{}è¿ç§»](#101-ä»interfaceè¿ç§»)
    - [10.2 ä»å…·ä½“ç±»å‹è¿ç§»](#102-ä»å…·ä½“ç±»å‹è¿ç§»)
  - [11. å®æˆ˜æ¡ˆä¾‹](#11-å®æˆ˜æ¡ˆä¾‹)
    - [11.1 é€šç”¨æ•°æ®ç»“æ„åº“](#111-é€šç”¨æ•°æ®ç»“æ„åº“)
    - [11.2 HTTPå®¢æˆ·ç«¯å°è£…](#112-httpå®¢æˆ·ç«¯å°è£…)
    - [11.3 æ•°æ®åº“ORM](#113-æ•°æ®åº“orm)
  - [12. å‚è€ƒèµ„æº](#12-å‚è€ƒèµ„æº)
    - [å®˜æ–¹æ–‡æ¡£](#å®˜æ–¹æ–‡æ¡£)
    - [æ ‡å‡†åº“ç¤ºä¾‹](#æ ‡å‡†åº“ç¤ºä¾‹)
    - [åšå®¢æ–‡ç« ](#åšå®¢æ–‡ç« )
    - [ç¤¾åŒºèµ„æº](#ç¤¾åŒºèµ„æº)

---

## 1. æ³›å‹ç±»å‹åˆ«åï¼šçªç ´æ€§è¿›å±•

### 1.1 å†å²èƒŒæ™¯

**Go 1.18ä¹‹å‰ï¼ˆæ— æ³›å‹ï¼‰**:

```go
// åªèƒ½ä½¿ç”¨interface{}æˆ–ä»£ç ç”Ÿæˆ
type StringList []string
type IntList []int

// å¤§é‡é‡å¤ä»£ç 
func SumInts(list IntList) int {
    sum := 0
    for _, v := range list {
        sum += v
    }
    return sum
}

func SumFloats(list []float64) float64 {
    // é‡å¤çš„é€»è¾‘...
}
```

**Go 1.18-1.22ï¼ˆæœ‰æ³›å‹ï¼Œæ— æ³›å‹åˆ«åï¼‰**:

```go
// å¯ä»¥å®šä¹‰æ³›å‹ç±»å‹
type List[T any] []T

// ä½†ä¸èƒ½åˆ›å»ºæ³›å‹åˆ«å
// type Alias[T any] = List[T]  // âŒ ç¼–è¯‘é”™è¯¯ï¼ˆGo 1.22åŠä»¥å‰ï¼‰
```

**Go 1.23ï¼ˆæ³›å‹åˆ«åæ”¯æŒï¼‰**:

```go
// âœ… ç°åœ¨å¯ä»¥ï¼
type Alias[T any] = List[T]

// ç”šè‡³å¯ä»¥æ›´å¤æ‚
type MapAlias[K comparable, V any] = map[K]V
type FuncAlias[T, U any] = func(T) U
```

### 1.2 Go 1.23çš„çªç ´

**å…³é”®æ”¹è¿›**ï¼š

1. **ç±»å‹åˆ«åæ”¯æŒç±»å‹å‚æ•°**
   - å¯ä»¥ç»™åˆ«åæ·»åŠ æ³›å‹å‚æ•°
   - æ”¯æŒæ‰€æœ‰ç±»å‹çº¦æŸ

2. **å¢å¼ºä»£ç å¤ç”¨**
   - å‡å°‘æ ·æ¿ä»£ç 
   - ç®€åŒ–APIè®¾è®¡

3. **å‘åå…¼å®¹**
   - ä¸ç ´åç°æœ‰ä»£ç 
   - æ¸è¿›å¼è¿ç§»

### 1.3 æ ¸å¿ƒä»·å€¼

| ç‰¹æ€§ | Go 1.22 | Go 1.23 |
|------|---------|---------|
| **ç±»å‹åˆ«å** | âœ… æ”¯æŒ | âœ… æ”¯æŒ |
| **æ³›å‹ç±»å‹** | âœ… æ”¯æŒ | âœ… æ”¯æŒ |
| **æ³›å‹åˆ«å** | âŒ ä¸æ”¯æŒ | âœ… æ”¯æŒ |
| **APIæ¼”è¿›** | å›°éš¾ | ç®€å• |
| **ä»£ç å¤ç”¨** | æœ‰é™ | å¼ºå¤§ |

---

## 2. åŸºç¡€æ¦‚å¿µ

### 2.1 ä»€ä¹ˆæ˜¯ç±»å‹åˆ«å

**ç±»å‹åˆ«å**ï¼šä¸ºç°æœ‰ç±»å‹åˆ›å»ºå¦ä¸€ä¸ªåç§°

```go
// åŸºç¡€ç±»å‹åˆ«åï¼ˆGo 1.9+ï¼‰
type MyInt = int           // MyIntå’Œintå®Œå…¨ç›¸åŒ
type StringSlice = []string

// ä½¿ç”¨
var x MyInt = 42
var y int = x  // âœ… æ— éœ€è½¬æ¢ï¼Œå®Œå…¨å…¼å®¹

// ç±»å‹åˆ«å vs ç±»å‹å®šä¹‰
type MyInt2 int            // æ–°ç±»å‹ï¼Œéœ€è¦è½¬æ¢
var z MyInt2 = 42
var w int = int(z)  // âš ï¸ éœ€è¦æ˜¾å¼è½¬æ¢
```

### 2.2 ä»€ä¹ˆæ˜¯æ³›å‹ç±»å‹åˆ«å

**æ³›å‹ç±»å‹åˆ«å**ï¼šå¸¦ç±»å‹å‚æ•°çš„ç±»å‹åˆ«å

```go
// Go 1.23æ–°ç‰¹æ€§
type List[T any] = []T
type Map[K comparable, V any] = map[K]V
type Pair[A, B any] = struct {
    First  A
    Second B
}

// ä½¿ç”¨
var intList List[int] = []int{1, 2, 3}
var strMap Map[string, int] = map[string]int{"a": 1}
var pair Pair[string, int] = struct {
    First  string
    Second int
}{"hello", 42}
```

### 2.3 è¯­æ³•å¯¹æ¯”

**ä¼ ç»Ÿç±»å‹åˆ«å vs æ³›å‹ç±»å‹åˆ«å**:

```go
// 1. ç®€å•ç±»å‹åˆ«åï¼ˆGo 1.9+ï¼‰
type StringList = []string
type IntList = []int

// 2. æ³›å‹ç±»å‹å®šä¹‰ï¼ˆGo 1.18+ï¼‰
type GenericList[T any] []T

// 3. æ³›å‹ç±»å‹åˆ«åï¼ˆGo 1.23+ï¼‰
type List[T any] = []T

// å¯¹æ¯”ä½¿ç”¨
func Example() {
    // ä¼ ç»Ÿåˆ«åï¼šå›ºå®šç±»å‹
    var s StringList = []string{"a", "b"}
    
    // æ³›å‹å®šä¹‰ï¼šæ–°ç±»å‹
    var g GenericList[string] = []string{"a", "b"}
    var slice1 []string = g  // âŒ ç±»å‹ä¸åŒï¼Œéœ€è¦è½¬æ¢
    
    // æ³›å‹åˆ«åï¼šå®Œå…¨ç­‰ä»·
    var l List[string] = []string{"a", "b"}
    var slice2 []string = l  // âœ… å®Œå…¨å…¼å®¹
}
```

---

## 3. æ³›å‹ç±»å‹åˆ«åè¯¦è§£

### 3.1 åŸºæœ¬è¯­æ³•

**è¯­æ³•æ ¼å¼**:

```go
type AliasName[TypeParams Constraints] = UnderlyingType
```

**ç»„æˆéƒ¨åˆ†**:

1. `type` - å…³é”®å­—
2. `AliasName` - åˆ«ååç§°
3. `[TypeParams Constraints]` - ç±»å‹å‚æ•°å’Œçº¦æŸ
4. `=` - åˆ«åæ ‡è¯†ï¼ˆåŒºåˆ«äºç±»å‹å®šä¹‰ï¼‰
5. `UnderlyingType` - åº•å±‚ç±»å‹

**ç¤ºä¾‹**:

```go
// ç®€å•åˆ«å
type Numbers[T ~int | ~float64] = []T

// å¤šå‚æ•°åˆ«å
type KeyValue[K comparable, V any] = map[K]V

// å¤æ‚åˆ«å
type Handler[Req, Resp any] = func(Req) (Resp, error)
```

### 3.2 ç±»å‹å‚æ•°

**å•ç±»å‹å‚æ•°**:

```go
// ä»»æ„ç±»å‹
type Slice[T any] = []T

// å¯æ¯”è¾ƒç±»å‹
type Set[T comparable] = map[T]struct{}

// æ•°å€¼ç±»å‹
type Number[T constraints.Integer | constraints.Float] = T
```

**å¤šç±»å‹å‚æ•°**:

```go
// ä¸¤ä¸ªå‚æ•°
type Pair[A, B any] = struct {
    First  A
    Second B
}

// ä¸‰ä¸ªå‚æ•°
type Triple[A, B, C any] = struct {
    First  A
    Second B
    Third  C
}

// ä¸åŒçº¦æŸ
type Mapper[K comparable, V any] = map[K]V
```

### 3.3 çº¦æŸæ¡ä»¶

**å†…ç½®çº¦æŸ**:

```go
import "golang.org/x/exp/constraints"

// anyï¼šä»»æ„ç±»å‹
type AnySlice[T any] = []T

// comparableï¼šå¯æ¯”è¾ƒç±»å‹ï¼ˆæ”¯æŒ==å’Œ!=ï¼‰
type ComparableMap[K comparable, V any] = map[K]V

// constraints.Orderedï¼šå¯æ’åºç±»å‹
type OrderedSlice[T constraints.Ordered] = []T

// constraints.Integerï¼šæ•´æ•°ç±»å‹
type IntSlice[T constraints.Integer] = []T

// constraints.Floatï¼šæµ®ç‚¹ç±»å‹
type FloatSlice[T constraints.Float] = []T
```

**è‡ªå®šä¹‰çº¦æŸ**:

```go
// æ¥å£çº¦æŸ
type Stringer interface {
    String() string
}

type StringerSlice[T Stringer] = []T

// è”åˆç±»å‹çº¦æŸ
type NumberConstraint interface {
    ~int | ~int64 | ~float64
}

type NumberSlice[T NumberConstraint] = []T

// æ–¹æ³•çº¦æŸ
type Comparable[T any] interface {
    Compare(T) int
}

type ComparableSlice[T Comparable[T]] = []T
```

---

## 4. å®æˆ˜åº”ç”¨åœºæ™¯

### 4.1 ç®€åŒ–å¤æ‚æ³›å‹ç±»å‹

**åœºæ™¯ï¼šç®€åŒ–åµŒå¥—æ³›å‹**:

```go
// åŸå§‹å¤æ‚ç±»å‹
type UserStore = map[string]map[string]interface{}

// Go 1.23ï¼šä½¿ç”¨æ³›å‹åˆ«åç®€åŒ–
type Store[K comparable, V any] = map[K]V
type NestedStore[K1, K2 comparable, V any] = Store[K1, Store[K2, V]]

// ä½¿ç”¨
var users NestedStore[string, string, User] = make(map[string]map[string]User)
```

**åœºæ™¯ï¼šç®€åŒ–å‡½æ•°ç±»å‹**:

```go
// åŸå§‹ï¼šé‡å¤çš„å‡½æ•°ç­¾å
type IntHandler func(int) (int, error)
type StringHandler func(string) (string, error)
type UserHandler func(User) (User, error)

// Go 1.23ï¼šç»Ÿä¸€ä¸ºæ³›å‹åˆ«å
type Handler[T any] = func(T) (T, error)

// ä½¿ç”¨
var intHandler Handler[int]
var strHandler Handler[string]
var userHandler Handler[User]
```

### 4.2 è¿ç§»è¾…åŠ©

**åœºæ™¯ï¼šä»æ—§APIå¹³æ»‘è¿ç§»åˆ°æ–°API**

```go
package mylib

// æ—§APIï¼ˆGo 1.17ï¼‰
type StringMap map[string]interface{}

// æ–°APIï¼ˆGo 1.18+ï¼‰
type Map[K comparable, V any] map[K]V

// Go 1.23ï¼šä½¿ç”¨åˆ«åä¿æŒå…¼å®¹
type StringMap = Map[string, interface{}]

// ç”¨æˆ·ä»£ç æ— éœ€ä¿®æ”¹
var m StringMap = make(StringMap)
m["key"] = "value"
```

**åœºæ™¯ï¼šæ ‡å‡†åº“è¿ç§»**

```go
// æ—§ï¼šä½¿ç”¨interface{}
func ProcessOld(data interface{}) error {
    // ...
}

// æ–°ï¼šä½¿ç”¨æ³›å‹
func ProcessNew[T any](data T) error {
    // ...
}

// åˆ«åä¿æŒå‘åå…¼å®¹
type ProcessFunc = func(interface{}) error
type GenericProcessFunc[T any] = func(T) error

// é€æ­¥è¿ç§»
var oldFunc ProcessFunc = ProcessOld
var newFunc GenericProcessFunc[string] = ProcessNew[string]
```

### 4.3 APIæ¼”è¿›

**åœºæ™¯ï¼šæ‰©å±•æ ‡å‡†åº“ç±»å‹**

```go
package collections

import "sync"

// åŸºäºsync.Mapçš„æ³›å‹åŒ…è£…
type SyncMap[K comparable, V any] struct {
    m sync.Map
}

func (sm *SyncMap[K, V]) Store(key K, value V) {
    sm.m.Store(key, value)
}

func (sm *SyncMap[K, V]) Load(key K) (V, bool) {
    v, ok := sm.m.Load(key)
    if !ok {
        var zero V
        return zero, false
    }
    return v.(V), true
}

// ä¸ºå¸¸ç”¨ç±»å‹åˆ›å»ºåˆ«å
type StringSyncMap[V any] = SyncMap[string, V]
type IntSyncMap[V any] = SyncMap[int, V]

// ä½¿ç”¨
var cache StringSyncMap[User]
cache.Store("user1", User{Name: "Alice"})
```

### 4.4 ç±»å‹ç»„åˆ

**åœºæ™¯ï¼šç»„åˆå¤šä¸ªæ³›å‹ç±»å‹**

```go
// åŸºç¡€æ³›å‹ç±»å‹
type Result[T any] struct {
    Value T
    Error error
}

type Option[T any] struct {
    value *T
}

// ä½¿ç”¨åˆ«åç»„åˆ
type ResultOption[T any] = Result[Option[T]]
type OptionResult[T any] = Option[Result[T]]

// å®é™…åº”ç”¨
func FetchUser(id string) ResultOption[User] {
    user, err := db.GetUser(id)
    if err != nil {
        return Result[Option[User]]{Error: err}
    }
    return Result[Option[User]]{Value: Option[User]{value: &user}}
}
```

**åœºæ™¯ï¼šåˆ›å»ºç±»å‹æ—**

```go
// å®šä¹‰ç±»å‹æ—
type Slice[T any] = []T
type Map[K comparable, V any] = map[K]V
type Chan[T any] = chan T

// ç»„åˆä½¿ç”¨
type SliceMap[K comparable, V any] = Map[K, Slice[V]]
type MapChan[K comparable, V any] = Chan[Map[K, V]]

// å®é™…åº”ç”¨
var usersByRole SliceMap[string, User]
var updates MapChan[string, int]
```

---

## 5. ä¸ä¼ ç»Ÿæ–¹æ¡ˆå¯¹æ¯”

### 5.1 vs ç±»å‹å®šä¹‰(type definition)

**ç±»å‹åˆ«å (Type Alias)**:

```go
// åˆ«åï¼šåº•å±‚ç±»å‹å®Œå…¨ç›¸åŒ
type IntList[T any] = []T

var list IntList[int] = []int{1, 2, 3}
var slice []int = list  // âœ… æ— éœ€è½¬æ¢
```

**ç±»å‹å®šä¹‰ (Type Definition)**:

```go
// å®šä¹‰ï¼šåˆ›å»ºæ–°ç±»å‹
type IntList[T any] []T

var list IntList[int] = []int{1, 2, 3}  // âŒ ç±»å‹ä¸åŒ¹é…
var list2 IntList[int]
list2 = []int{1, 2, 3}  // âŒ éœ€è¦è½¬æ¢
list2 = IntList[int]([]int{1, 2, 3})  // âœ… æ˜¾å¼è½¬æ¢
```

**å¯¹æ¯”è¡¨**:

| ç‰¹æ€§ | ç±»å‹åˆ«å | ç±»å‹å®šä¹‰ |
|------|----------|----------|
| **åº•å±‚ç±»å‹** | å®Œå…¨ç›¸åŒ | æ–°ç±»å‹ |
| **ç±»å‹è½¬æ¢** | ä¸éœ€è¦ | éœ€è¦ |
| **æ–¹æ³•** | ä¸èƒ½æ·»åŠ  | å¯ä»¥æ·»åŠ  |
| **å…¼å®¹æ€§** | å®Œå…¨å…¼å®¹ | éœ€è¦è½¬æ¢ |
| **ç”¨é€”** | ç®€åŒ–ã€è¿ç§» | å°è£…ã€æ‰©å±• |

### 5.2 vs æ¥å£

**æ³›å‹åˆ«åæ–¹å¼**:

```go
type Processor[T any] = func(T) error

func Process[T any](data T, fn Processor[T]) error {
    return fn(data)
}

// ä½¿ç”¨ï¼šç±»å‹å®‰å…¨
Process(42, func(x int) error {
    fmt.Println(x)
    return nil
})
```

**æ¥å£æ–¹å¼**:

```go
type Processor interface {
    Process(interface{}) error
}

func Process(data interface{}, p Processor) error {
    return p.Process(data)
}

// ä½¿ç”¨ï¼šéœ€è¦ç±»å‹æ–­è¨€
type IntProcessor struct{}

func (p IntProcessor) Process(data interface{}) error {
    x, ok := data.(int)  // éœ€è¦æ–­è¨€
    if !ok {
        return errors.New("not an int")
    }
    fmt.Println(x)
    return nil
}
```

**ä¼˜åŠ£å¯¹æ¯”**:

| æ–¹é¢ | æ³›å‹åˆ«å | æ¥å£ |
|------|----------|------|
| **ç±»å‹å®‰å…¨** | âœ… ç¼–è¯‘æ—¶ | âš ï¸ è¿è¡Œæ—¶ |
| **æ€§èƒ½** | âœ… é›¶å¼€é”€ | âš ï¸ é—´æ¥è°ƒç”¨ |
| **çµæ´»æ€§** | âš ï¸ å›ºå®šç­¾å | âœ… å¯æ‰©å±• |
| **å¤æ‚åº¦** | âœ… ç®€å• | âš ï¸ éœ€è¦å®ç° |

### 5.3 vs å‡½æ•°åŒ…è£…

**æ³›å‹åˆ«åæ–¹å¼**:

```go
type Validator[T any] = func(T) bool

func Validate[T any](data T, validators ...Validator[T]) bool {
    for _, v := range validators {
        if !v(data) {
            return false
        }
    }
    return true
}

// ä½¿ç”¨
isPositive := func(x int) bool { return x > 0 }
isEven := func(x int) bool { return x%2 == 0 }

result := Validate(42, isPositive, isEven)
```

**å‡½æ•°åŒ…è£…æ–¹å¼**:

```go
type ValidatorFunc func(interface{}) bool

func Validate(data interface{}, validators ...ValidatorFunc) bool {
    for _, v := range validators {
        if !v(data) {
            return false
        }
    }
    return true
}

// ä½¿ç”¨ï¼šéœ€è¦åŒ…è£…
isPositive := func(data interface{}) bool {
    x, ok := data.(int)
    return ok && x > 0
}

result := Validate(42, isPositive)
```

---

## 6. é«˜çº§ç”¨æ³•

### 6.1 åµŒå¥—æ³›å‹åˆ«å

**åŸºç¡€åµŒå¥—**:

```go
// ä¸€å±‚åµŒå¥—
type Inner[T any] = []T
type Outer[T any] = map[string]Inner[T]

// ä½¿ç”¨
var data Outer[int] = map[string][]int{
    "a": {1, 2, 3},
    "b": {4, 5, 6},
}
```

**å¤šå±‚åµŒå¥—**:

```go
// ä¸‰å±‚åµŒå¥—
type Level1[T any] = T
type Level2[T any] = []Level1[T]
type Level3[T any] = map[string]Level2[T]

// å®é™…ç­‰ä»·äº
// type Level3[T any] = map[string][]T

// ä½¿ç”¨
var nested Level3[int] = map[string][]int{
    "data": {1, 2, 3},
}
```

**å®æˆ˜ç¤ºä¾‹ï¼šé…ç½®ç³»ç»Ÿ**:

```go
package config

// åŸºç¡€ç±»å‹
type Value[T any] = T
type ValueSlice[T any] = []Value[T]
type ValueMap[T any] = map[string]Value[T]

// å¤æ‚åµŒå¥—
type NestedConfig[T any] = map[string]ValueMap[ValueSlice[T]]

// ä½¿ç”¨
type ServerConfig struct {
    Host string
    Port int
}

var config NestedConfig[ServerConfig] = map[string]map[string][]ServerConfig{
    "production": {
        "us-east": {
            {Host: "server1.com", Port: 8080},
            {Host: "server2.com", Port: 8080},
        },
    },
}
```

### 6.2 å¤šç±»å‹å‚æ•°

**åŒå‚æ•°**:

```go
// Mapåˆ«å
type KeyValueStore[K comparable, V any] = map[K]V

// å‡½æ•°åˆ«å
type Transformer[In, Out any] = func(In) Out

// ç»“æ„ä½“åˆ«å
type Pair[A, B any] = struct {
    First  A
    Second B
}
```

**ä¸‰å‚æ•°åŠä»¥ä¸Š**:

```go
// ä¸‰å‚æ•°ï¼šè¾“å…¥ã€è¾“å‡ºã€é”™è¯¯ç±»å‹
type Operation[In, Out, Err any] = func(In) (Out, Err)

// å››å‚æ•°ï¼šé”®1ã€é”®2ã€å€¼ã€å…ƒæ•°æ®
type NestedMap[K1, K2 comparable, V, M any] = map[K1]map[K2]struct {
    Value    V
    Metadata M
}

// ä½¿ç”¨
type UserOperation = Operation[User, string, error]
var op UserOperation = func(u User) (string, error) {
    return u.Name, nil
}
```

**å‚æ•°çº¦æŸç»„åˆ**:

```go
// ä¸åŒçº¦æŸ
type ComparableMap[K comparable, V any] = map[K]V
type OrderedPair[T constraints.Ordered] = struct {
    Min, Max T
}

// ç›¸åŒçº¦æŸ
type BiMap[K, V comparable] struct {
    forward  map[K]V
    backward map[V]K
}

// ä½¿ç”¨åˆ«å
type BiMapAlias[K, V comparable] = BiMap[K, V]
```

### 6.3 é€’å½’ç±»å‹åˆ«å

**æ³¨æ„**ï¼šGo 1.23ä¸­ï¼Œé€’å½’ç±»å‹åˆ«åæœ‰é™åˆ¶

```go
// âŒ ç›´æ¥é€’å½’ä¸æ”¯æŒ
// type Node[T any] = struct {
//     Value T
//     Next  *Node[T]  // é”™è¯¯ï¼šé€’å½’åˆ«å
// }

// âœ… ä½¿ç”¨ç±»å‹å®šä¹‰ï¼ˆéåˆ«åï¼‰
type Node[T any] struct {
    Value T
    Next  *Node[T]  // æ­£ç¡®
}

// âœ… é—´æ¥é€’å½’ï¼ˆé€šè¿‡mapï¼‰
type Tree[T any] = map[string]Tree[T]  // æŸäº›æƒ…å†µå¯è¡Œ
```

**å®ç”¨æ¨¡å¼**:

```go
// é€’å½’æ•°æ®ç»“æ„ï¼šä½¿ç”¨ç±»å‹å®šä¹‰
type LinkedList[T any] struct {
    Value T
    Next  *LinkedList[T]
}

// ç®€åŒ–è®¿é—®ï¼šä½¿ç”¨åˆ«å
type IntList = LinkedList[int]
type StringList = LinkedList[string]

// ä½¿ç”¨
var list IntList = LinkedList[int]{
    Value: 1,
    Next: &LinkedList[int]{
        Value: 2,
        Next:  nil,
    },
}
```

---

## 7. æ ‡å‡†åº“ä¸­çš„åº”ç”¨

### 7.1 cmpåŒ…

```go
package cmp

// Go 1.23æ ‡å‡†åº“ä½¿ç”¨æ³›å‹åˆ«å
type Ordered interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64 |
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
    ~float32 | ~float64 |
    ~string
}

// æ¯”è¾ƒå‡½æ•°ç±»å‹åˆ«å
type CompareFunc[T any] = func(T, T) int

// ä½¿ç”¨ç¤ºä¾‹
func Compare[T Ordered](a, b T) int {
    switch {
    case a < b:
        return -1
    case a > b:
        return 1
    default:
        return 0
    }
}
```

### 7.2 slicesåŒ…

```go
package slices

import "cmp"

// ç±»å‹åˆ«åç®€åŒ–API
type CompareFunc[E any] = func(E, E) int

// ä½¿ç”¨åˆ«å
func SortFunc[E any](x []E, cmp CompareFunc[E]) {
    // ...å®ç°
}

// ç”¨æˆ·ä»£ç 
ages := []int{5, 2, 6, 3, 1, 4}
slices.SortFunc(ages, cmp.Compare[int])
```

### 7.3 mapsåŒ…

```go
package maps

// è¿­ä»£å™¨ç±»å‹åˆ«åï¼ˆé…åˆGo 1.23çš„range-over-funcï¼‰
type Seq[K comparable, V any] = func(yield func(K, V) bool)

// è¿”å›mapçš„æ‰€æœ‰é”®å€¼å¯¹
func All[M ~map[K]V, K comparable, V any](m M) Seq[K, V] {
    return func(yield func(K, V) bool) {
        for k, v := range m {
            if !yield(k, v) {
                return
            }
        }
    }
}

// ä½¿ç”¨
m := map[string]int{"a": 1, "b": 2}
for k, v := range maps.All(m) {
    fmt.Printf("%s: %d\n", k, v)
}
```

---

## 8. æœ€ä½³å®è·µ

### 8.1 å‘½åè§„èŒƒ

**æ¸…æ™°çš„åˆ«åå‘½å**:

```go
// âœ… å¥½ï¼šæè¿°æ€§å‘½å
type UserID = string
type Timestamp = int64
type Handler[T any] = func(T) error

// âŒ ä¸å¥½ï¼šæ¨¡ç³Šå‘½å
type UID = string
type TS = int64
type H[T any] = func(T) error
```

**ç±»å‹å‚æ•°å‘½å**:

```go
// âœ… å¥½ï¼šå•å­—æ¯æˆ–æè¿°æ€§
type Map[K comparable, V any] = map[K]V
type Transformer[Input, Output any] = func(Input) Output

// âŒ ä¸å¥½ï¼šéš¾ä»¥ç†è§£
type Map[X comparable, Y any] = map[X]Y
type Transformer[A, B any] = func(A) B
```

### 8.2 ä½¿ç”¨åœºæ™¯

**é€‚åˆä½¿ç”¨æ³›å‹åˆ«å**:

```go
// âœ… ç®€åŒ–å¤æ‚ç±»å‹
type ResponseHandler[T any] = func(http.ResponseWriter, *http.Request) (T, error)

// âœ… APIå…¼å®¹æ€§
type LegacyMap = Map[string, interface{}]

// âœ… ç±»å‹æ—
type Slice[T any] = []T
type IntSlice = Slice[int]
type StringSlice = Slice[string]
```

**ä¸é€‚åˆä½¿ç”¨æ³›å‹åˆ«å**:

```go
// âŒ éœ€è¦æ·»åŠ æ–¹æ³•ï¼ˆä½¿ç”¨ç±»å‹å®šä¹‰ï¼‰
type Stack[T any] = []T
// æ— æ³•ä¸ºåˆ«åæ·»åŠ æ–¹æ³•

// âœ… æ”¹ç”¨ç±»å‹å®šä¹‰
type Stack[T any] []T

func (s *Stack[T]) Push(v T) {
    *s = append(*s, v)
}

// âŒ è¿‡åº¦ç®€åŒ–ï¼ˆé™ä½å¯è¯»æ€§ï¼‰
type X = func(int) (string, error)  // éš¾ä»¥ç†è§£

// âœ… ä½¿ç”¨æè¿°æ€§åç§°
type IDFormatter = func(int) (string, error)
```

### 8.3 é¿å…æ»¥ç”¨

**æ»¥ç”¨ç¤ºä¾‹**:

```go
// âŒ è¿‡åº¦åˆ«ååŒ–
type S = string
type I = int
type F = func(S) I

// âœ… ç›´æ¥ä½¿ç”¨åŸå§‹ç±»å‹
func Process(s string) int {
    return len(s)
}
```

**é€‚åº¦ä½¿ç”¨**:

```go
// âœ… æœ‰æ„ä¹‰çš„æŠ½è±¡
type UserID = string
type RoleID = string

func AssignRole(user UserID, role RoleID) error {
    // ç±»å‹åˆ«åæé«˜äº†å¯è¯»æ€§
}

// vs åŸå§‹ç‰ˆæœ¬
func AssignRole(user string, role string) error {
    // ä¸æ¸…æ¥šå“ªä¸ªæ˜¯ç”¨æˆ·IDï¼Œå“ªä¸ªæ˜¯è§’è‰²ID
}
```

---

## 9. å¸¸è§é™·é˜±

### 9.1 ç±»å‹æ¨æ–­é™åˆ¶

**é—®é¢˜**ï¼šæ³›å‹åˆ«åå¯èƒ½å½±å“ç±»å‹æ¨æ–­

```go
type Processor[T any] = func(T) error

// âŒ ç±»å‹æ¨æ–­å¤±è´¥
func Process[T any](data T, fn Processor[T]) error {
    return fn(data)
}

// ä½¿ç”¨æ—¶éœ€è¦æ˜¾å¼æŒ‡å®š
err := Process[int](42, func(x int) error {  // éœ€è¦æ˜¾å¼[int]
    return nil
})

// âœ… æ”¹è¿›ï¼šç›´æ¥ä½¿ç”¨å‡½æ•°ç±»å‹
func ProcessBetter[T any](data T, fn func(T) error) error {
    return fn(data)
}

// ç±»å‹æ¨æ–­æˆåŠŸ
err = ProcessBetter(42, func(x int) error {  // æ¨æ–­å‡ºint
    return nil
})
```

### 9.2 å¾ªç¯ä¾èµ–

**é—®é¢˜**ï¼šæ³›å‹åˆ«åå¯èƒ½å¯¼è‡´å¾ªç¯ä¾èµ–

```go
// âŒ å¾ªç¯ä¾èµ–
type A[T any] = B[T]
type B[T any] = A[T]  // é”™è¯¯ï¼šå¾ªç¯åˆ«å

// âœ… è§£å†³ï¼šä½¿ç”¨ä¸€å±‚é—´æ¥
type Base[T any] = T
type A[T any] = Base[T]
type B[T any] = Base[T]
```

### 9.3 å¯¼å‡ºè§„åˆ™

**é—®é¢˜**ï¼šåˆ«åçš„å¯¼å‡ºè§„åˆ™

```go
package mylib

// å†…éƒ¨ç±»å‹
type internal[T any] []T

// âŒ å¯¼å‡ºåˆ«åæŒ‡å‘æœªå¯¼å‡ºç±»å‹
type Exported[T any] = internal[T]  // ç¼–è¯‘è­¦å‘Š

// âœ… ä¸¤è€…éƒ½å¯¼å‡ºæˆ–éƒ½ä¸å¯¼å‡º
type Internal[T any] []T
type Exported[T any] = Internal[T]
```

---

## 10. è¿ç§»æŒ‡å—

### 10.1 ä»interface{}è¿ç§»

**æ­¥éª¤1ï¼šè¯†åˆ«interface{}ç”¨æ³•**

```go
// æ—§ä»£ç 
func Process(data interface{}) error {
    // ç±»å‹æ–­è¨€
    switch v := data.(type) {
    case int:
        return processInt(v)
    case string:
        return processString(v)
    default:
        return errors.New("unsupported type")
    }
}
```

**æ­¥éª¤2ï¼šåˆ›å»ºæ³›å‹åˆ«å**

```go
// åˆ›å»ºåˆ«å
type Processor[T any] = func(T) error

// é‡å†™å‡½æ•°
func Process[T any](data T, processor Processor[T]) error {
    return processor(data)
}
```

**æ­¥éª¤3ï¼šé€æ­¥è¿ç§»è°ƒç”¨æ–¹**

```go
// æ–°ç”¨æ³•
intProcessor := func(x int) error {
    fmt.Println(x)
    return nil
}

err := Process(42, intProcessor)  // ç±»å‹å®‰å…¨
```

### 10.2 ä»å…·ä½“ç±»å‹è¿ç§»

**æ­¥éª¤1ï¼šæ‰¾å‡ºé‡å¤ä»£ç **

```go
// æ—§ä»£ç ï¼šå¤§é‡é‡å¤
type IntList []int
func (l IntList) Sum() int {
    sum := 0
    for _, v := range l {
        sum += v
    }
    return sum
}

type FloatList []float64
func (l FloatList) Sum() float64 {
    sum := 0.0
    for _, v := range l {
        sum += v
    }
    return sum
}
```

**æ­¥éª¤2ï¼šåˆ›å»ºæ³›å‹ç‰ˆæœ¬**

```go
import "golang.org/x/exp/constraints"

// æ³›å‹ç±»å‹å®šä¹‰ï¼ˆéœ€è¦æ–¹æ³•ï¼‰
type List[T constraints.Integer | constraints.Float] []T

func (l List[T]) Sum() T {
    var sum T
    for _, v := range l {
        sum += v
    }
    return sum
}

// ä¸ºå…¼å®¹æ€§åˆ›å»ºåˆ«å
type IntList = List[int]
type FloatList = List[float64]
```

**æ­¥éª¤3ï¼šéªŒè¯å…¼å®¹æ€§**

```go
func main() {
    // æ—§ä»£ç ä»ç„¶å·¥ä½œ
    ints := IntList{1, 2, 3}
    fmt.Println(ints.Sum())  // 6
    
    // æ–°ä»£ç ä¹Ÿå¯ä»¥ä½¿ç”¨
    floats := List[float64]{1.5, 2.5, 3.5}
    fmt.Println(floats.Sum())  // 7.5
}
```

---

## 11. å®æˆ˜æ¡ˆä¾‹

### 11.1 é€šç”¨æ•°æ®ç»“æ„åº“

```go
package collections

// åŸºç¡€æ³›å‹åˆ«å
type List[T any] = []T
type Set[T comparable] = map[T]struct{}
type Stack[T any] = []T

// ç»„åˆåˆ«å
type ListSet[T comparable] = map[T]List[T]
type SetList[T comparable] = []Set[T]

// å®ç”¨å‡½æ•°
func NewSet[T comparable]() Set[T] {
    return make(Set[T])
}

func (s Set[T]) Add(item T) {
    s[item] = struct{}{}
}

func (s Set[T]) Contains(item T) bool {
    _, ok := s[item]
    return ok
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    // æ•´æ•°é›†åˆ
    intSet := NewSet[int]()
    intSet.Add(1)
    intSet.Add(2)
    fmt.Println(intSet.Contains(1))  // true
    
    // å­—ç¬¦ä¸²é›†åˆ
    strSet := NewSet[string]()
    strSet.Add("hello")
    strSet.Add("world")
    
    // å¤æ‚ç±»å‹
    userGroups := make(ListSet[string])
    userGroups["admin"] = List[string]{"alice", "bob"}
    userGroups["user"] = List[string]{"carol", "dave"}
}
```

### 11.2 HTTPå®¢æˆ·ç«¯å°è£…

```go
package httpclient

import (
    "encoding/json"
    "net/http"
)

// æ³›å‹åˆ«åå®šä¹‰
type HTTPClient[Req, Resp any] struct {
    baseURL string
    client  *http.Client
}

type RequestFunc[Req any] = func(*http.Request, Req) error
type ResponseFunc[Resp any] = func(*http.Response) (Resp, error)

// æ ‡å‡†å“åº”ç±»å‹åˆ«å
type JSONResponse[T any] = struct {
    Data  T      `json:"data"`
    Error string `json:"error,omitempty"`
}

// åˆ›å»ºå®¢æˆ·ç«¯
func NewClient[Req, Resp any](baseURL string) *HTTPClient[Req, Resp] {
    return &HTTPClient[Req, Resp]{
        baseURL: baseURL,
        client:  &http.Client{},
    }
}

// å‘é€è¯·æ±‚
func (c *HTTPClient[Req, Resp]) Post(
    path string,
    req Req,
    reqFn RequestFunc[Req],
    respFn ResponseFunc[Resp],
) (Resp, error) {
    httpReq, _ := http.NewRequest("POST", c.baseURL+path, nil)
    
    if err := reqFn(httpReq, req); err != nil {
        var zero Resp
        return zero, err
    }
    
    httpResp, err := c.client.Do(httpReq)
    if err != nil {
        var zero Resp
        return zero, err
    }
    defer httpResp.Body.Close()
    
    return respFn(httpResp)
}

// ä½¿ç”¨ç¤ºä¾‹
type User struct {
    ID   string `json:"id"`
    Name string `json:"name"`
}

type CreateUserRequest struct {
    Name string `json:"name"`
}

func Example() {
    // åˆ›å»ºç±»å‹åŒ–å®¢æˆ·ç«¯
    client := NewClient[CreateUserRequest, JSONResponse[User]]("https://api.example.com")
    
    // å‘é€è¯·æ±‚
    resp, err := client.Post(
        "/users",
        CreateUserRequest{Name: "Alice"},
        func(req *http.Request, data CreateUserRequest) error {
            return json.NewEncoder(req.Body).Encode(data)
        },
        func(resp *http.Response) (JSONResponse[User], error) {
            var result JSONResponse[User]
            err := json.NewDecoder(resp.Body).Decode(&result)
            return result, err
        },
    )
    
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("Created user: %v\n", resp.Data)
}
```

### 11.3 æ•°æ®åº“ORM

```go
package orm

import (
    "database/sql"
    "reflect"
)

// æ³›å‹åˆ«å
type Query[T any] = func(*sql.DB) ([]T, error)
type QueryOne[T any] = func(*sql.DB) (T, error)
type Exec = func(*sql.DB) error

// Repositoryæ¨¡å¼
type Repository[T any] struct {
    db        *sql.DB
    tableName string
}

func NewRepository[T any](db *sql.DB, tableName string) *Repository[T] {
    return &Repository[T]{
        db:        db,
        tableName: tableName,
    }
}

// æŸ¥è¯¢æ‰€æœ‰
func (r *Repository[T]) FindAll() Query[T] {
    return func(db *sql.DB) ([]T, error) {
        rows, err := db.Query("SELECT * FROM " + r.tableName)
        if err != nil {
            return nil, err
        }
        defer rows.Close()
        
        var results []T
        for rows.Next() {
            var item T
            // ä½¿ç”¨åå°„æ‰«æ...
            results = append(results, item)
        }
        return results, nil
    }
}

// æ ¹æ®IDæŸ¥è¯¢
func (r *Repository[T]) FindByID(id int) QueryOne[T] {
    return func(db *sql.DB) (T, error) {
        var result T
        row := db.QueryRow("SELECT * FROM "+r.tableName+" WHERE id = ?", id)
        // æ‰«æ...
        return result, nil
    }
}

// ä½¿ç”¨ç¤ºä¾‹
type User struct {
    ID    int    `db:"id"`
    Name  string `db:"name"`
    Email string `db:"email"`
}

func Example() {
    db, _ := sql.Open("mysql", "user:password@/dbname")
    
    // åˆ›å»ºRepository
    userRepo := NewRepository[User](db, "users")
    
    // æŸ¥è¯¢æ‰€æœ‰ç”¨æˆ·
    users, err := userRepo.FindAll()(db)
    if err != nil {
        panic(err)
    }
    
    for _, user := range users {
        fmt.Printf("User: %s (%s)\n", user.Name, user.Email)
    }
    
    // æŸ¥è¯¢å•ä¸ªç”¨æˆ·
    user, err := userRepo.FindByID(1)(db)
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("Found user: %v\n", user)
}
```

---

## 12. å‚è€ƒèµ„æº

### å®˜æ–¹æ–‡æ¡£

- [Go 1.23 Release Notes - Generic Type Aliases](https://go.dev/doc/go1.23#language)
- [Type Parameters Proposal](https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md)
- [Go Spec - Type Aliases](https://go.dev/ref/spec#Alias_declarations)

### æ ‡å‡†åº“ç¤ºä¾‹

- [cmp Package](https://pkg.go.dev/cmp)
- [slices Package](https://pkg.go.dev/slices)
- [maps Package](https://pkg.go.dev/maps)

### åšå®¢æ–‡ç« 

- [Go Blog - Type Parameters](https://go.dev/blog/type-parameters)
- [Go Blog - Intro to Generics](https://go.dev/blog/intro-generics)

### ç¤¾åŒºèµ„æº

- [Awesome Go Generics](https://github.com/mattn/awesome-go-generics)
- [Go Generics Tutorial](https://go.dev/doc/tutorial/generics)

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ24æ—¥  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.23+

**è´¡çŒ®è€…**: æ¬¢è¿æäº¤Issueå’ŒPRæ”¹è¿›æœ¬æ–‡æ¡£
