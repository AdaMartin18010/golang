# Go 1.23 泛型类型别名深度指南

> **难度**: ⭐⭐⭐⭐
> **标签**: #Go1.23 #泛型 #类型别名 #type-alias

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---

---

## 📋 目录

- [1. 泛型类型别名：突破性进展](#1.-泛型类型别名突破性进展)
  - [1.1 历史背景](#11-历史背景)
  - [1.2 Go 1.23的突破](#12-go-1.23的突破)
  - [1.3 核心价值](#13-核心价值)
- [2. 基础概念](#2.-基础概念)
  - [2.1 什么是类型别名](#21-什么是类型别名)
  - [2.2 什么是泛型类型别名](#22-什么是泛型类型别名)
  - [2.3 语法对比](#23-语法对比)
- [3. 泛型类型别名详解](#3.-泛型类型别名详解)
  - [3.1 基本语法](#31-基本语法)
  - [3.2 类型参数](#32-类型参数)
  - [3.3 约束条件](#33-约束条件)
- [4. 实战应用场景](#4.-实战应用场景)
  - [4.1 简化复杂泛型类型](#41-简化复杂泛型类型)
  - [4.2 迁移辅助](#42-迁移辅助)
  - [4.3 API演进](#43-api演进)
  - [4.4 类型组合](#44-类型组合)
- [5. 与传统方案对比](#5.-与传统方案对比)
  - [5.1 vs 类型定义(type definition)](#51-vs-类型定义type-definition)
  - [5.2 vs 接口](#52-vs-接口)
  - [5.3 vs 函数包装](#53-vs-函数包装)
- [6. 高级用法](#6.-高级用法)
  - [6.1 嵌套泛型别名](#61-嵌套泛型别名)
  - [6.2 多类型参数](#62-多类型参数)
  - [6.3 递归类型别名](#63-递归类型别名)
- [7. 标准库中的应用](#7.-标准库中的应用)
  - [7.1 cmp包](#71-cmp包)
  - [7.2 slices包](#72-slices包)
  - [7.3 maps包](#73-maps包)
- [8. 最佳实践](#8.-最佳实践)
  - [8.1 命名规范](#81-命名规范)
  - [8.2 使用场景](#82-使用场景)
  - [8.3 避免滥用](#83-避免滥用)
- [9. 常见陷阱](#9.-常见陷阱)
  - [9.1 类型推断限制](#91-类型推断限制)
  - [9.2 循环依赖](#92-循环依赖)
  - [9.3 导出规则](#93-导出规则)
- [10. 迁移指南](#10.-迁移指南)
  - [10.1 从interface{}迁移](#101-从interface迁移)
  - [10.2 从具体类型迁移](#102-从具体类型迁移)
- [11. 实战案例](#11.-实战案例)
  - [11.1 通用数据结构库](#111-通用数据结构库)
  - [11.2 HTTP客户端封装](#112-http客户端封装)
  - [11.3 数据库ORM](#113-数据库orm)
- [12. 参考资源](#12.-参考资源)
  - [官方文档](#官方文档)
  - [标准库示例](#标准库示例)
  - [博客文章](#博客文章)
  - [社区资源](#社区资源)

## 1. 泛型类型别名：突破性进展

### 1.1 历史背景

**Go 1.18之前（无泛型）**:

```go
// 只能使用interface{}或代码生成
type StringList []string
type IntList []int

// 大量重复代码
func SumInts(list IntList) int {
    sum := 0
    for _, v := range list {
        sum += v
    }
    return sum
}

func SumFloats(list []float64) float64 {
    // 重复的逻辑...
}
```

**Go 1.18-1.22（有泛型，无泛型别名）**:

```go
// 可以定义泛型类型
type List[T any] []T

// 但不能创建泛型别名
// type Alias[T any] = List[T]  // ❌ 编译错误（Go 1.22及以前）
```

**Go 1.23（泛型别名支持）**:

```go
// ✅ 现在可以！
type Alias[T any] = List[T]

// 甚至可以更复杂
type MapAlias[K comparable, V any] = map[K]V
type FuncAlias[T, U any] = func(T) U
```

### 1.2 Go 1.23的突破

**关键改进**：

1. **类型别名支持类型参数**
   - 可以给别名添加泛型参数
   - 支持所有类型约束

2. **增强代码复用**
   - 减少样板代码
   - 简化API设计

3. **向后兼容**
   - 不破坏现有代码
   - 渐进式迁移

### 1.3 核心价值

| 特性 | Go 1.22 | Go 1.23 |
|------|---------|---------|
| **类型别名** | ✅ 支持 | ✅ 支持 |
| **泛型类型** | ✅ 支持 | ✅ 支持 |
| **泛型别名** | ❌ 不支持 | ✅ 支持 |
| **API演进** | 困难 | 简单 |
| **代码复用** | 有限 | 强大 |

---

## 2. 基础概念

### 2.1 什么是类型别名

**类型别名**：为现有类型创建另一个名称

```go
// 基础类型别名（Go 1.9+）
type MyInt = int           // MyInt和int完全相同
type StringSlice = []string

// 使用
var x MyInt = 42
var y int = x  // ✅ 无需转换，完全兼容

// 类型别名 vs 类型定义
type MyInt2 int            // 新类型，需要转换
var z MyInt2 = 42
var w int = int(z)  // ⚠️ 需要显式转换
```

### 2.2 什么是泛型类型别名

**泛型类型别名**：带类型参数的类型别名

```go
// Go 1.23新特性
type List[T any] = []T
type Map[K comparable, V any] = map[K]V
type Pair[A, B any] = struct {
    First  A
    Second B
}

// 使用
var intList List[int] = []int{1, 2, 3}
var strMap Map[string, int] = map[string]int{"a": 1}
var pair Pair[string, int] = struct {
    First  string
    Second int
}{"hello", 42}
```

### 2.3 语法对比

**传统类型别名 vs 泛型类型别名**:

```go
// 1. 简单类型别名（Go 1.9+）
type StringList = []string
type IntList = []int

// 2. 泛型类型定义（Go 1.18+）
type GenericList[T any] []T

// 3. 泛型类型别名（Go 1.23+）
type List[T any] = []T

// 对比使用
func Example() {
    // 传统别名：固定类型
    var s StringList = []string{"a", "b"}
    
    // 泛型定义：新类型
    var g GenericList[string] = []string{"a", "b"}
    var slice1 []string = g  // ❌ 类型不同，需要转换
    
    // 泛型别名：完全等价
    var l List[string] = []string{"a", "b"}
    var slice2 []string = l  // ✅ 完全兼容
}
```

---

## 3. 泛型类型别名详解

### 3.1 基本语法

**语法格式**:

```go
type AliasName[TypeParams Constraints] = UnderlyingType
```

**组成部分**:

1. `type` - 关键字
2. `AliasName` - 别名名称
3. `[TypeParams Constraints]` - 类型参数和约束
4. `=` - 别名标识（区别于类型定义）
5. `UnderlyingType` - 底层类型

**示例**:

```go
// 简单别名
type Numbers[T ~int | ~float64] = []T

// 多参数别名
type KeyValue[K comparable, V any] = map[K]V

// 复杂别名
type Handler[Req, Resp any] = func(Req) (Resp, error)
```

### 3.2 类型参数

**单类型参数**:

```go
// 任意类型
type Slice[T any] = []T

// 可比较类型
type Set[T comparable] = map[T]struct{}

// 数值类型
type Number[T constraints.Integer | constraints.Float] = T
```

**多类型参数**:

```go
// 两个参数
type Pair[A, B any] = struct {
    First  A
    Second B
}

// 三个参数
type Triple[A, B, C any] = struct {
    First  A
    Second B
    Third  C
}

// 不同约束
type Mapper[K comparable, V any] = map[K]V
```

### 3.3 约束条件

**内置约束**:

```go
import "golang.org/x/exp/constraints"

// any：任意类型
type AnySlice[T any] = []T

// comparable：可比较类型（支持==和!=）
type ComparableMap[K comparable, V any] = map[K]V

// constraints.Ordered：可排序类型
type OrderedSlice[T constraints.Ordered] = []T

// constraints.Integer：整数类型
type IntSlice[T constraints.Integer] = []T

// constraints.Float：浮点类型
type FloatSlice[T constraints.Float] = []T
```

**自定义约束**:

```go
// 接口约束
type Stringer interface {
    String() string
}

type StringerSlice[T Stringer] = []T

// 联合类型约束
type NumberConstraint interface {
    ~int | ~int64 | ~float64
}

type NumberSlice[T NumberConstraint] = []T

// 方法约束
type Comparable[T any] interface {
    Compare(T) int
}

type ComparableSlice[T Comparable[T]] = []T
```

---

## 4. 实战应用场景

### 4.1 简化复杂泛型类型

**场景：简化嵌套泛型**:

```go
// 原始复杂类型
type UserStore = map[string]map[string]interface{}

// Go 1.23：使用泛型别名简化
type Store[K comparable, V any] = map[K]V
type NestedStore[K1, K2 comparable, V any] = Store[K1, Store[K2, V]]

// 使用
var users NestedStore[string, string, User] = make(map[string]map[string]User)
```

**场景：简化函数类型**:

```go
// 原始：重复的函数签名
type IntHandler func(int) (int, error)
type StringHandler func(string) (string, error)
type UserHandler func(User) (User, error)

// Go 1.23：统一为泛型别名
type Handler[T any] = func(T) (T, error)

// 使用
var intHandler Handler[int]
var strHandler Handler[string]
var userHandler Handler[User]
```

### 4.2 迁移辅助

**场景：从旧API平滑迁移到新API**:

```go
package mylib

// 旧API（Go 1.17）
type StringMap map[string]interface{}

// 新API（Go 1.18+）
type Map[K comparable, V any] map[K]V

// Go 1.23：使用别名保持兼容
type StringMap = Map[string, interface{}]

// 用户代码无需修改
var m StringMap = make(StringMap)
m["key"] = "value"
```

**场景：标准库迁移**:

```go
// 旧：使用interface{}
func ProcessOld(data interface{}) error {
    // ...
}

// 新：使用泛型
func ProcessNew[T any](data T) error {
    // ...
}

// 别名保持向后兼容
type ProcessFunc = func(interface{}) error
type GenericProcessFunc[T any] = func(T) error

// 逐步迁移
var oldFunc ProcessFunc = ProcessOld
var newFunc GenericProcessFunc[string] = ProcessNew[string]
```

### 4.3 API演进

**场景：扩展标准库类型**:

```go
package collections

import "sync"

// 基于sync.Map的泛型包装
type SyncMap[K comparable, V any] struct {
    m sync.Map
}

func (sm *SyncMap[K, V]) Store(key K, value V) {
    sm.m.Store(key, value)
}

func (sm *SyncMap[K, V]) Load(key K) (V, bool) {
    v, ok := sm.m.Load(key)
    if !ok {
        var zero V
        return zero, false
    }
    return v.(V), true
}

// 为常用类型创建别名
type StringSyncMap[V any] = SyncMap[string, V]
type IntSyncMap[V any] = SyncMap[int, V]

// 使用
var cache StringSyncMap[User]
cache.Store("user1", User{Name: "Alice"})
```

### 4.4 类型组合

**场景：组合多个泛型类型**:

```go
// 基础泛型类型
type Result[T any] struct {
    Value T
    Error error
}

type Option[T any] struct {
    value *T
}

// 使用别名组合
type ResultOption[T any] = Result[Option[T]]
type OptionResult[T any] = Option[Result[T]]

// 实际应用
func FetchUser(id string) ResultOption[User] {
    user, err := db.GetUser(id)
    if err != nil {
        return Result[Option[User]]{Error: err}
    }
    return Result[Option[User]]{Value: Option[User]{value: &user}}
}
```

**场景：创建类型族**:

```go
// 定义类型族
type Slice[T any] = []T
type Map[K comparable, V any] = map[K]V
type Chan[T any] = chan T

// 组合使用
type SliceMap[K comparable, V any] = Map[K, Slice[V]]
type MapChan[K comparable, V any] = Chan[Map[K, V]]

// 实际应用
var usersByRole SliceMap[string, User]
var updates MapChan[string, int]
```

---

## 5. 与传统方案对比

### 5.1 vs 类型定义(type definition)

**类型别名 (Type Alias)**:

```go
// 别名：底层类型完全相同
type IntList[T any] = []T

var list IntList[int] = []int{1, 2, 3}
var slice []int = list  // ✅ 无需转换
```

**类型定义 (Type Definition)**:

```go
// 定义：创建新类型
type IntList[T any] []T

var list IntList[int] = []int{1, 2, 3}  // ❌ 类型不匹配
var list2 IntList[int]
list2 = []int{1, 2, 3}  // ❌ 需要转换
list2 = IntList[int]([]int{1, 2, 3})  // ✅ 显式转换
```

**对比表**:

| 特性 | 类型别名 | 类型定义 |
|------|----------|----------|
| **底层类型** | 完全相同 | 新类型 |
| **类型转换** | 不需要 | 需要 |
| **方法** | 不能添加 | 可以添加 |
| **兼容性** | 完全兼容 | 需要转换 |
| **用途** | 简化、迁移 | 封装、扩展 |

### 5.2 vs 接口

**泛型别名方式**:

```go
type Processor[T any] = func(T) error

func Process[T any](data T, fn Processor[T]) error {
    return fn(data)
}

// 使用：类型安全
Process(42, func(x int) error {
    fmt.Println(x)
    return nil
})
```

**接口方式**:

```go
type Processor interface {
    Process(interface{}) error
}

func Process(data interface{}, p Processor) error {
    return p.Process(data)
}

// 使用：需要类型断言
type IntProcessor struct{}

func (p IntProcessor) Process(data interface{}) error {
    x, ok := data.(int)  // 需要断言
    if !ok {
        return errors.New("not an int")
    }
    fmt.Println(x)
    return nil
}
```

**优劣对比**:

| 方面 | 泛型别名 | 接口 |
|------|----------|------|
| **类型安全** | ✅ 编译时 | ⚠️ 运行时 |
| **性能** | ✅ 零开销 | ⚠️ 间接调用 |
| **灵活性** | ⚠️ 固定签名 | ✅ 可扩展 |
| **复杂度** | ✅ 简单 | ⚠️ 需要实现 |

### 5.3 vs 函数包装

**泛型别名方式**:

```go
type Validator[T any] = func(T) bool

func Validate[T any](data T, validators ...Validator[T]) bool {
    for _, v := range validators {
        if !v(data) {
            return false
        }
    }
    return true
}

// 使用
isPositive := func(x int) bool { return x > 0 }
isEven := func(x int) bool { return x%2 == 0 }

result := Validate(42, isPositive, isEven)
```

**函数包装方式**:

```go
type ValidatorFunc func(interface{}) bool

func Validate(data interface{}, validators ...ValidatorFunc) bool {
    for _, v := range validators {
        if !v(data) {
            return false
        }
    }
    return true
}

// 使用：需要包装
isPositive := func(data interface{}) bool {
    x, ok := data.(int)
    return ok && x > 0
}

result := Validate(42, isPositive)
```

---

## 6. 高级用法

### 6.1 嵌套泛型别名

**基础嵌套**:

```go
// 一层嵌套
type Inner[T any] = []T
type Outer[T any] = map[string]Inner[T]

// 使用
var data Outer[int] = map[string][]int{
    "a": {1, 2, 3},
    "b": {4, 5, 6},
}
```

**多层嵌套**:

```go
// 三层嵌套
type Level1[T any] = T
type Level2[T any] = []Level1[T]
type Level3[T any] = map[string]Level2[T]

// 实际等价于
// type Level3[T any] = map[string][]T

// 使用
var nested Level3[int] = map[string][]int{
    "data": {1, 2, 3},
}
```

**实战示例：配置系统**:

```go
package config

// 基础类型
type Value[T any] = T
type ValueSlice[T any] = []Value[T]
type ValueMap[T any] = map[string]Value[T]

// 复杂嵌套
type NestedConfig[T any] = map[string]ValueMap[ValueSlice[T]]

// 使用
type ServerConfig struct {
    Host string
    Port int
}

var config NestedConfig[ServerConfig] = map[string]map[string][]ServerConfig{
    "production": {
        "us-east": {
            {Host: "server1.com", Port: 8080},
            {Host: "server2.com", Port: 8080},
        },
    },
}
```

### 6.2 多类型参数

**双参数**:

```go
// Map别名
type KeyValueStore[K comparable, V any] = map[K]V

// 函数别名
type Transformer[In, Out any] = func(In) Out

// 结构体别名
type Pair[A, B any] = struct {
    First  A
    Second B
}
```

**三参数及以上**:

```go
// 三参数：输入、输出、错误类型
type Operation[In, Out, Err any] = func(In) (Out, Err)

// 四参数：键1、键2、值、元数据
type NestedMap[K1, K2 comparable, V, M any] = map[K1]map[K2]struct {
    Value    V
    Metadata M
}

// 使用
type UserOperation = Operation[User, string, error]
var op UserOperation = func(u User) (string, error) {
    return u.Name, nil
}
```

**参数约束组合**:

```go
// 不同约束
type ComparableMap[K comparable, V any] = map[K]V
type OrderedPair[T constraints.Ordered] = struct {
    Min, Max T
}

// 相同约束
type BiMap[K, V comparable] struct {
    forward  map[K]V
    backward map[V]K
}

// 使用别名
type BiMapAlias[K, V comparable] = BiMap[K, V]
```

### 6.3 递归类型别名

**注意**：Go 1.23中，递归类型别名有限制

```go
// ❌ 直接递归不支持
// type Node[T any] = struct {
//     Value T
//     Next  *Node[T]  // 错误：递归别名
// }

// ✅ 使用类型定义（非别名）
type Node[T any] struct {
    Value T
    Next  *Node[T]  // 正确
}

// ✅ 间接递归（通过map）
type Tree[T any] = map[string]Tree[T]  // 某些情况可行
```

**实用模式**:

```go
// 递归数据结构：使用类型定义
type LinkedList[T any] struct {
    Value T
    Next  *LinkedList[T]
}

// 简化访问：使用别名
type IntList = LinkedList[int]
type StringList = LinkedList[string]

// 使用
var list IntList = LinkedList[int]{
    Value: 1,
    Next: &LinkedList[int]{
        Value: 2,
        Next:  nil,
    },
}
```

---

## 7. 标准库中的应用

### 7.1 cmp包

```go
package cmp

// Go 1.23标准库使用泛型别名
type Ordered interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64 |
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
    ~float32 | ~float64 |
    ~string
}

// 比较函数类型别名
type CompareFunc[T any] = func(T, T) int

// 使用示例
func Compare[T Ordered](a, b T) int {
    switch {
    case a < b:
        return -1
    case a > b:
        return 1
    default:
        return 0
    }
}
```

### 7.2 slices包

```go
package slices

import "cmp"

// 类型别名简化API
type CompareFunc[E any] = func(E, E) int

// 使用别名
func SortFunc[E any](x []E, cmp CompareFunc[E]) {
    // ...实现
}

// 用户代码
ages := []int{5, 2, 6, 3, 1, 4}
slices.SortFunc(ages, cmp.Compare[int])
```

### 7.3 maps包

```go
package maps

// 迭代器类型别名（配合Go 1.23的range-over-func）
type Seq[K comparable, V any] = func(yield func(K, V) bool)

// 返回map的所有键值对
func All[M ~map[K]V, K comparable, V any](m M) Seq[K, V] {
    return func(yield func(K, V) bool) {
        for k, v := range m {
            if !yield(k, v) {
                return
            }
        }
    }
}

// 使用
m := map[string]int{"a": 1, "b": 2}
for k, v := range maps.All(m) {
    fmt.Printf("%s: %d\n", k, v)
}
```

---

## 8. 最佳实践

### 8.1 命名规范

**清晰的别名命名**:

```go
// ✅ 好：描述性命名
type UserID = string
type Timestamp = int64
type Handler[T any] = func(T) error

// ❌ 不好：模糊命名
type UID = string
type TS = int64
type H[T any] = func(T) error
```

**类型参数命名**:

```go
// ✅ 好：单字母或描述性
type Map[K comparable, V any] = map[K]V
type Transformer[Input, Output any] = func(Input) Output

// ❌ 不好：难以理解
type Map[X comparable, Y any] = map[X]Y
type Transformer[A, B any] = func(A) B
```

### 8.2 使用场景

**适合使用泛型别名**:

```go
// ✅ 简化复杂类型
type ResponseHandler[T any] = func(http.ResponseWriter, *http.Request) (T, error)

// ✅ API兼容性
type LegacyMap = Map[string, interface{}]

// ✅ 类型族
type Slice[T any] = []T
type IntSlice = Slice[int]
type StringSlice = Slice[string]
```

**不适合使用泛型别名**:

```go
// ❌ 需要添加方法（使用类型定义）
type Stack[T any] = []T
// 无法为别名添加方法

// ✅ 改用类型定义
type Stack[T any] []T

func (s *Stack[T]) Push(v T) {
    *s = append(*s, v)
}

// ❌ 过度简化（降低可读性）
type X = func(int) (string, error)  // 难以理解

// ✅ 使用描述性名称
type IDFormatter = func(int) (string, error)
```

### 8.3 避免滥用

**滥用示例**:

```go
// ❌ 过度别名化
type S = string
type I = int
type F = func(S) I

// ✅ 直接使用原始类型
func Process(s string) int {
    return len(s)
}
```

**适度使用**:

```go
// ✅ 有意义的抽象
type UserID = string
type RoleID = string

func AssignRole(user UserID, role RoleID) error {
    // 类型别名提高了可读性
}

// vs 原始版本
func AssignRole(user string, role string) error {
    // 不清楚哪个是用户ID，哪个是角色ID
}
```

---

## 9. 常见陷阱

### 9.1 类型推断限制

**问题**：泛型别名可能影响类型推断

```go
type Processor[T any] = func(T) error

// ❌ 类型推断失败
func Process[T any](data T, fn Processor[T]) error {
    return fn(data)
}

// 使用时需要显式指定
err := Process[int](42, func(x int) error {  // 需要显式[int]
    return nil
})

// ✅ 改进：直接使用函数类型
func ProcessBetter[T any](data T, fn func(T) error) error {
    return fn(data)
}

// 类型推断成功
err = ProcessBetter(42, func(x int) error {  // 推断出int
    return nil
})
```

### 9.2 循环依赖

**问题**：泛型别名可能导致循环依赖

```go
// ❌ 循环依赖
type A[T any] = B[T]
type B[T any] = A[T]  // 错误：循环别名

// ✅ 解决：使用一层间接
type Base[T any] = T
type A[T any] = Base[T]
type B[T any] = Base[T]
```

### 9.3 导出规则

**问题**：别名的导出规则

```go
package mylib

// 内部类型
type internal[T any] []T

// ❌ 导出别名指向未导出类型
type Exported[T any] = internal[T]  // 编译警告

// ✅ 两者都导出或都不导出
type Internal[T any] []T
type Exported[T any] = Internal[T]
```

---

## 10. 迁移指南

### 10.1 从interface{}迁移

**步骤1：识别interface{}用法**:

```go
// 旧代码
func Process(data interface{}) error {
    // 类型断言
    switch v := data.(type) {
    case int:
        return processInt(v)
    case string:
        return processString(v)
    default:
        return errors.New("unsupported type")
    }
}
```

**步骤2：创建泛型别名**:

```go
// 创建别名
type Processor[T any] = func(T) error

// 重写函数
func Process[T any](data T, processor Processor[T]) error {
    return processor(data)
}
```

**步骤3：逐步迁移调用方**:

```go
// 新用法
intProcessor := func(x int) error {
    fmt.Println(x)
    return nil
}

err := Process(42, intProcessor)  // 类型安全
```

### 10.2 从具体类型迁移

**步骤1：找出重复代码**:

```go
// 旧代码：大量重复
type IntList []int
func (l IntList) Sum() int {
    sum := 0
    for _, v := range l {
        sum += v
    }
    return sum
}

type FloatList []float64
func (l FloatList) Sum() float64 {
    sum := 0.0
    for _, v := range l {
        sum += v
    }
    return sum
}
```

**步骤2：创建泛型版本**:

```go
import "golang.org/x/exp/constraints"

// 泛型类型定义（需要方法）
type List[T constraints.Integer | constraints.Float] []T

func (l List[T]) Sum() T {
    var sum T
    for _, v := range l {
        sum += v
    }
    return sum
}

// 为兼容性创建别名
type IntList = List[int]
type FloatList = List[float64]
```

**步骤3：验证兼容性**:

```go
func main() {
    // 旧代码仍然工作
    ints := IntList{1, 2, 3}
    fmt.Println(ints.Sum())  // 6
    
    // 新代码也可以使用
    floats := List[float64]{1.5, 2.5, 3.5}
    fmt.Println(floats.Sum())  // 7.5
}
```

---

## 11. 实战案例

### 11.1 通用数据结构库

```go
package collections

// 基础泛型别名
type List[T any] = []T
type Set[T comparable] = map[T]struct{}
type Stack[T any] = []T

// 组合别名
type ListSet[T comparable] = map[T]List[T]
type SetList[T comparable] = []Set[T]

// 实用函数
func NewSet[T comparable]() Set[T] {
    return make(Set[T])
}

func (s Set[T]) Add(item T) {
    s[item] = struct{}{}
}

func (s Set[T]) Contains(item T) bool {
    _, ok := s[item]
    return ok
}

// 使用示例
func Example() {
    // 整数集合
    intSet := NewSet[int]()
    intSet.Add(1)
    intSet.Add(2)
    fmt.Println(intSet.Contains(1))  // true
    
    // 字符串集合
    strSet := NewSet[string]()
    strSet.Add("hello")
    strSet.Add("world")
    
    // 复杂类型
    userGroups := make(ListSet[string])
    userGroups["admin"] = List[string]{"alice", "bob"}
    userGroups["user"] = List[string]{"carol", "dave"}
}
```

### 11.2 HTTP客户端封装

```go
package httpclient

import (
    "encoding/json"
    "net/http"
)

// 泛型别名定义
type HTTPClient[Req, Resp any] struct {
    baseURL string
    client  *http.Client
}

type RequestFunc[Req any] = func(*http.Request, Req) error
type ResponseFunc[Resp any] = func(*http.Response) (Resp, error)

// 标准响应类型别名
type JSONResponse[T any] = struct {
    Data  T      `json:"data"`
    Error string `json:"error,omitempty"`
}

// 创建客户端
func NewClient[Req, Resp any](baseURL string) *HTTPClient[Req, Resp] {
    return &HTTPClient[Req, Resp]{
        baseURL: baseURL,
        client:  &http.Client{},
    }
}

// 发送请求
func (c *HTTPClient[Req, Resp]) Post(
    path string,
    req Req,
    reqFn RequestFunc[Req],
    respFn ResponseFunc[Resp],
) (Resp, error) {
    httpReq, _ := http.NewRequest("POST", c.baseURL+path, nil)
    
    if err := reqFn(httpReq, req); err != nil {
        var zero Resp
        return zero, err
    }
    
    httpResp, err := c.client.Do(httpReq)
    if err != nil {
        var zero Resp
        return zero, err
    }
    defer httpResp.Body.Close()
    
    return respFn(httpResp)
}

// 使用示例
type User struct {
    ID   string `json:"id"`
    Name string `json:"name"`
}

type CreateUserRequest struct {
    Name string `json:"name"`
}

func Example() {
    // 创建类型化客户端
    client := NewClient[CreateUserRequest, JSONResponse[User]]("https://api.example.com")
    
    // 发送请求
    resp, err := client.Post(
        "/users",
        CreateUserRequest{Name: "Alice"},
        func(req *http.Request, data CreateUserRequest) error {
            return json.NewEncoder(req.Body).Encode(data)
        },
        func(resp *http.Response) (JSONResponse[User], error) {
            var result JSONResponse[User]
            err := json.NewDecoder(resp.Body).Decode(&result)
            return result, err
        },
    )
    
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("Created user: %v\n", resp.Data)
}
```

### 11.3 数据库ORM

```go
package orm

import (
    "database/sql"
    "reflect"
)

// 泛型别名
type Query[T any] = func(*sql.DB) ([]T, error)
type QueryOne[T any] = func(*sql.DB) (T, error)
type Exec = func(*sql.DB) error

// Repository模式
type Repository[T any] struct {
    db        *sql.DB
    tableName string
}

func NewRepository[T any](db *sql.DB, tableName string) *Repository[T] {
    return &Repository[T]{
        db:        db,
        tableName: tableName,
    }
}

// 查询所有
func (r *Repository[T]) FindAll() Query[T] {
    return func(db *sql.DB) ([]T, error) {
        rows, err := db.Query("SELECT * FROM " + r.tableName)
        if err != nil {
            return nil, err
        }
        defer rows.Close()
        
        var results []T
        for rows.Next() {
            var item T
            // 使用反射扫描...
            results = append(results, item)
        }
        return results, nil
    }
}

// 根据ID查询
func (r *Repository[T]) FindByID(id int) QueryOne[T] {
    return func(db *sql.DB) (T, error) {
        var result T
        row := db.QueryRow("SELECT * FROM "+r.tableName+" WHERE id = ?", id)
        // 扫描...
        return result, nil
    }
}

// 使用示例
type User struct {
    ID    int    `db:"id"`
    Name  string `db:"name"`
    Email string `db:"email"`
}

func Example() {
    db, _ := sql.Open("mysql", "user:password@/dbname")
    
    // 创建Repository
    userRepo := NewRepository[User](db, "users")
    
    // 查询所有用户
    users, err := userRepo.FindAll()(db)
    if err != nil {
        panic(err)
    }
    
    for _, user := range users {
        fmt.Printf("User: %s (%s)\n", user.Name, user.Email)
    }
    
    // 查询单个用户
    user, err := userRepo.FindByID(1)(db)
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("Found user: %v\n", user)
}
```

---

## 12. 参考资源

### 官方文档

- [Go 1.23 Release Notes - Generic Type Aliases](https://go.dev/doc/go1.23#language)
- [Type Parameters Proposal](https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md)
- [Go Spec - Type Aliases](https://go.dev/ref/spec#Alias_declarations)

### 标准库示例

- [cmp Package](https://pkg.go.dev/cmp)
- [slices Package](https://pkg.go.dev/slices)
- [maps Package](https://pkg.go.dev/maps)

### 博客文章

- [Go Blog - Type Parameters](https://go.dev/blog/type-parameters)
- [Go Blog - Intro to Generics](https://go.dev/blog/intro-generics)

### 社区资源

- [Awesome Go Generics](https://github.com/mattn/awesome-go-generics)
- [Go Generics Tutorial](https://go.dev/doc/tutorial/generics)

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025-10-29  
**文档状态**: ✅ 完成  
**适用版本**: Go 1.23+

**贡献者**: 欢迎提交Issue和PR改进本文档
