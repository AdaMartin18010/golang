# Go 1.23 è¿­ä»£å™¨ï¼ˆrange-over-funcï¼‰è¯¦è§£

> **å¼•å…¥ç‰ˆæœ¬**: Go 1.23  
> **çŠ¶æ€**: âœ… ç¨³å®šï¼ˆä»å®éªŒæ€§è½¬ä¸ºæ­£å¼ç‰¹æ€§ï¼‰  
> **éš¾åº¦**: â­â­â­â­  
> **æ ‡ç­¾**: #è¿­ä»£å™¨ #range-over-func #iter


## ğŸ“‹ ç›®å½•


- [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
- [ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ](#-æ ¸å¿ƒæ¦‚å¿µ)
  - [iter åŒ…](#iter-åŒ…)
  - [åŸºæœ¬è¯­æ³•](#åŸºæœ¬è¯­æ³•)
- [ğŸš€ å•å€¼è¿­ä»£å™¨ï¼ˆSeq[V]ï¼‰](#-å•å€¼è¿­ä»£å™¨seqv)
  - [ç¤ºä¾‹ 1: æ–æ³¢é‚£å¥‘æ•°åˆ—](#ç¤ºä¾‹-1-æ–æ³¢é‚£å¥‘æ•°åˆ—)
  - [ç¤ºä¾‹ 2: æ–‡ä»¶è¡Œè¿­ä»£å™¨](#ç¤ºä¾‹-2-æ–‡ä»¶è¡Œè¿­ä»£å™¨)
  - [ç¤ºä¾‹ 3: è¿‡æ»¤è¿­ä»£å™¨](#ç¤ºä¾‹-3-è¿‡æ»¤è¿­ä»£å™¨)
- [ğŸš€ åŒå€¼è¿­ä»£å™¨ï¼ˆSeq2[K, V]ï¼‰](#-åŒå€¼è¿­ä»£å™¨seq2k-v)
  - [ç¤ºä¾‹ 1: Map è¿­ä»£å™¨](#ç¤ºä¾‹-1-map-è¿­ä»£å™¨)
  - [ç¤ºä¾‹ 2: æšä¸¾ï¼ˆEnumerateï¼‰](#ç¤ºä¾‹-2-æšä¸¾enumerate)
- [ğŸ”§ é«˜çº§ç”¨æ³•](#-é«˜çº§ç”¨æ³•)
  - [1. ç»„åˆè¿­ä»£å™¨](#1-ç»„åˆè¿­ä»£å™¨)
  - [2. æ ‘ç»“æ„è¿­ä»£](#2-æ ‘ç»“æ„è¿­ä»£)
  - [3. æ•°æ®åº“è¡Œè¿­ä»£å™¨](#3-æ•°æ®åº“è¡Œè¿­ä»£å™¨)
- [ğŸ“Š æ€§èƒ½åˆ†æ](#-æ€§èƒ½åˆ†æ)
  - [Benchmark: è¿­ä»£å™¨ vs ä¼ ç»Ÿæ–¹å¼](#benchmark-è¿­ä»£å™¨-vs-ä¼ ç»Ÿæ–¹å¼)
- [ğŸ’¡ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
  - [1. æå‰é€€å‡º](#1-æå‰é€€å‡º)
  - [2. èµ„æºæ¸…ç†](#2-èµ„æºæ¸…ç†)
  - [3. é”™è¯¯å¤„ç†](#3-é”™è¯¯å¤„ç†)
- [âš ï¸ æ³¨æ„äº‹é¡¹](#-æ³¨æ„äº‹é¡¹)
  - [1. ä¸è¦åœ¨ goroutine ä¸­ä½¿ç”¨ yield](#1-ä¸è¦åœ¨-goroutine-ä¸­ä½¿ç”¨-yield)
  - [2. yield åªèƒ½åœ¨è¿­ä»£å™¨å‡½æ•°ä¸­è°ƒç”¨](#2-yield-åªèƒ½åœ¨è¿­ä»£å™¨å‡½æ•°ä¸­è°ƒç”¨)
- [ğŸ“š æ‰©å±•é˜…è¯»](#-æ‰©å±•é˜…è¯»)

## ğŸ“‹ æ¦‚è¿°

Go 1.23 æ­£å¼å¼•å…¥äº† **range-over-func**ï¼ˆè¿­ä»£å™¨ï¼‰ç‰¹æ€§ï¼Œå…è®¸è‡ªå®šä¹‰ç±»å‹å®ç°è¿­ä»£å™¨æ¨¡å¼ï¼Œå¹¶ä¸ `range` å¾ªç¯æ— ç¼é›†æˆã€‚

è¿™æ˜¯ Go è¯­è¨€è‡ªæ³›å‹ä»¥æ¥æœ€é‡è¦çš„è¯­è¨€ç‰¹æ€§æ”¹è¿›ä¹‹ä¸€ã€‚

---

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### iter åŒ…

Go 1.23 æ–°å¢ `iter` åŒ…ï¼Œå®šä¹‰äº†ä¸¤ç§è¿­ä»£å™¨æ¥å£ï¼š

```go
package iter

// Seq[V] - å•å€¼è¿­ä»£å™¨
type Seq[V any] func(yield func(V) bool)

// Seq2[K, V] - åŒå€¼è¿­ä»£å™¨ï¼ˆå¦‚ mapï¼‰
type Seq2[K, V any] func(yield func(K, V) bool)
```

### åŸºæœ¬è¯­æ³•

```go
package main

import (
    "fmt"
    "iter"
)

// è‡ªå®šä¹‰è¿­ä»£å™¨ï¼šç”Ÿæˆ 0 åˆ° n-1
func Count(n int) iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := 0; i < n; i++ {
            // å¦‚æœ yield è¿”å› falseï¼Œåœæ­¢è¿­ä»£
            if !yield(i) {
                return
            }
        }
    }
}

func main() {
    // ä½¿ç”¨ range è¿­ä»£
    for i := range Count(5) {
        fmt.Println(i)  // è¾“å‡º: 0 1 2 3 4
    }
}
```

---

## ğŸš€ å•å€¼è¿­ä»£å™¨ï¼ˆSeq[V]ï¼‰

### ç¤ºä¾‹ 1: æ–æ³¢é‚£å¥‘æ•°åˆ—

```go
package main

import (
    "fmt"
    "iter"
)

// ç”Ÿæˆå‰ n ä¸ªæ–æ³¢é‚£å¥‘æ•°
func Fibonacci(n int) iter.Seq[int] {
    return func(yield func(int) bool) {
        a, b := 0, 1
        for i := 0; i < n; i++ {
            if !yield(a) {
                return
            }
            a, b = b, a+b
        }
    }
}

func main() {
    for num := range Fibonacci(10) {
        fmt.Println(num)
    }
    // è¾“å‡º: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34
}
```

### ç¤ºä¾‹ 2: æ–‡ä»¶è¡Œè¿­ä»£å™¨

```go
package main

import (
    "bufio"
    "fmt"
    "iter"
    "os"
)

// è¿­ä»£æ–‡ä»¶çš„æ¯ä¸€è¡Œ
func Lines(filename string) iter.Seq[string] {
    return func(yield func(string) bool) {
        file, err := os.Open(filename)
        if err != nil {
            return
        }
        defer file.Close()
        
        scanner := bufio.NewScanner(file)
        for scanner.Scan() {
            if !yield(scanner.Text()) {
                return
            }
        }
    }
}

func main() {
    for line := range Lines("data.txt") {
        fmt.Println(line)
    }
}
```

### ç¤ºä¾‹ 3: è¿‡æ»¤è¿­ä»£å™¨

```go
package main

import (
    "fmt"
    "iter"
)

// è¿‡æ»¤å¶æ•°
func Filter[T any](seq iter.Seq[T], pred func(T) bool) iter.Seq[T] {
    return func(yield func(T) bool) {
        for v := range seq {
            if pred(v) {
                if !yield(v) {
                    return
                }
            }
        }
    }
}

func main() {
    numbers := func(yield func(int) bool) {
        for i := 1; i <= 10; i++ {
            if !yield(i) {
                return
            }
        }
    }
    
    // åªè¿­ä»£å¶æ•°
    for num := range Filter(numbers, func(n int) bool { return n%2 == 0 }) {
        fmt.Println(num)  // è¾“å‡º: 2, 4, 6, 8, 10
    }
}
```

---

## ğŸš€ åŒå€¼è¿­ä»£å™¨ï¼ˆSeq2[K, V]ï¼‰

### ç¤ºä¾‹ 1: Map è¿­ä»£å™¨

```go
package main

import (
    "fmt"
    "iter"
    "sort"
)

// æŒ‰é”®æ’åºçš„ map è¿­ä»£å™¨
func SortedMap[K comparable, V any](m map[K]V, less func(K, K) bool) iter.Seq2[K, V] {
    return func(yield func(K, V) bool) {
        // æå–æ‰€æœ‰é”®
        keys := make([]K, 0, len(m))
        for k := range m {
            keys = append(keys, k)
        }
        
        // æ’åº
        sort.Slice(keys, func(i, j int) bool {
            return less(keys[i], keys[j])
        })
        
        // æŒ‰é¡ºåºè¿­ä»£
        for _, k := range keys {
            if !yield(k, m[k]) {
                return
            }
        }
    }
}

func main() {
    m := map[string]int{
        "banana": 3,
        "apple":  1,
        "cherry": 2,
    }
    
    // æŒ‰é”®æ’åºè¿­ä»£
    for k, v := range SortedMap(m, func(a, b string) bool { return a < b }) {
        fmt.Printf("%s: %d\n", k, v)
    }
    // è¾“å‡º:
    // apple: 1
    // banana: 3
    // cherry: 2
}
```

### ç¤ºä¾‹ 2: æšä¸¾ï¼ˆEnumerateï¼‰

```go
package main

import (
    "fmt"
    "iter"
)

// ä¸ºåˆ‡ç‰‡æ·»åŠ ç´¢å¼•
func Enumerate[T any](s []T) iter.Seq2[int, T] {
    return func(yield func(int, T) bool) {
        for i, v := range s {
            if !yield(i, v) {
                return
            }
        }
    }
}

func main() {
    fruits := []string{"apple", "banana", "cherry"}
    
    for i, fruit := range Enumerate(fruits) {
        fmt.Printf("%d: %s\n", i, fruit)
    }
    // è¾“å‡º:
    // 0: apple
    // 1: banana
    // 2: cherry
}
```

---

## ğŸ”§ é«˜çº§ç”¨æ³•

### 1. ç»„åˆè¿­ä»£å™¨

```go
package main

import (
    "fmt"
    "iter"
)

// Map: è½¬æ¢å€¼
func Map[T, U any](seq iter.Seq[T], f func(T) U) iter.Seq[U] {
    return func(yield func(U) bool) {
        for v := range seq {
            if !yield(f(v)) {
                return
            }
        }
    }
}

// Filter: è¿‡æ»¤å€¼
func Filter[T any](seq iter.Seq[T], pred func(T) bool) iter.Seq[T] {
    return func(yield func(T) bool) {
        for v := range seq {
            if pred(v) {
                if !yield(v) {
                    return
                }
            }
        }
    }
}

// Take: å–å‰ n ä¸ª
func Take[T any](seq iter.Seq[T], n int) iter.Seq[T] {
    return func(yield func(T) bool) {
        count := 0
        for v := range seq {
            if count >= n {
                return
            }
            if !yield(v) {
                return
            }
            count++
        }
    }
}

func main() {
    // ç”Ÿæˆå™¨
    numbers := func(yield func(int) bool) {
        for i := 1; ; i++ {
            if !yield(i) {
                return
            }
        }
    }
    
    // ç»„åˆï¼šå–å‰10ä¸ªå¶æ•°ï¼Œç„¶åå¹³æ–¹
    result := Take(
        Map(
            Filter(numbers, func(n int) bool { return n%2 == 0 }),
            func(n int) int { return n * n },
        ),
        10,
    )
    
    for n := range result {
        fmt.Println(n)
    }
    // è¾“å‡º: 4, 16, 36, 64, 100, 144, 196, 256, 324, 400
}
```

### 2. æ ‘ç»“æ„è¿­ä»£

```go
package main

import (
    "fmt"
    "iter"
)

type TreeNode struct {
    Value int
    Left  *TreeNode
    Right *TreeNode
}

// ä¸­åºéå†
func (n *TreeNode) Inorder() iter.Seq[int] {
    return func(yield func(int) bool) {
        var traverse func(*TreeNode) bool
        traverse = func(node *TreeNode) bool {
            if node == nil {
                return true
            }
            if !traverse(node.Left) {
                return false
            }
            if !yield(node.Value) {
                return false
            }
            if !traverse(node.Right) {
                return false
            }
            return true
        }
        traverse(n)
    }
}

func main() {
    // æ„å»ºäºŒå‰æœç´¢æ ‘
    //       4
    //      / \
    //     2   6
    //    / \ / \
    //   1  3 5  7
    tree := &TreeNode{
        Value: 4,
        Left: &TreeNode{
            Value: 2,
            Left:  &TreeNode{Value: 1},
            Right: &TreeNode{Value: 3},
        },
        Right: &TreeNode{
            Value: 6,
            Left:  &TreeNode{Value: 5},
            Right: &TreeNode{Value: 7},
        },
    }
    
    // ä¸­åºéå†
    for val := range tree.Inorder() {
        fmt.Println(val)
    }
    // è¾“å‡º: 1, 2, 3, 4, 5, 6, 7
}
```

### 3. æ•°æ®åº“è¡Œè¿­ä»£å™¨

```go
package main

import (
    "database/sql"
    "iter"
)

type User struct {
    ID   int
    Name string
}

// æŸ¥è¯¢ç»“æœè¿­ä»£å™¨
func QueryUsers(db *sql.DB, query string) iter.Seq[User] {
    return func(yield func(User) bool) {
        rows, err := db.Query(query)
        if err != nil {
            return
        }
        defer rows.Close()
        
        for rows.Next() {
            var user User
            if err := rows.Scan(&user.ID, &user.Name); err != nil {
                return
            }
            if !yield(user) {
                return
            }
        }
    }
}

func main() {
    // ä½¿ç”¨ç¤ºä¾‹
    // db, _ := sql.Open("postgres", "...")
    // for user := range QueryUsers(db, "SELECT id, name FROM users") {
    //     fmt.Printf("User: %d, %s\n", user.ID, user.Name)
    // }
}
```

---

## ğŸ“Š æ€§èƒ½åˆ†æ

### Benchmark: è¿­ä»£å™¨ vs ä¼ ç»Ÿæ–¹å¼

```go
package main

import (
    "iter"
    "testing"
)

// ä¼ ç»Ÿæ–¹å¼ï¼šè¿”å›åˆ‡ç‰‡
func RangeSlice(n int) []int {
    result := make([]int, n)
    for i := 0; i < n; i++ {
        result[i] = i
    }
    return result
}

// è¿­ä»£å™¨æ–¹å¼
func RangeIter(n int) iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := 0; i < n; i++ {
            if !yield(i) {
                return
            }
        }
    }
}

func BenchmarkSlice(b *testing.B) {
    for i := 0; i < b.N; i++ {
        sum := 0
        for _, v := range RangeSlice(1000) {
            sum += v
        }
        _ = sum
    }
}

func BenchmarkIterator(b *testing.B) {
    for i := 0; i < b.N; i++ {
        sum := 0
        for v := range RangeIter(1000) {
            sum += v
        }
        _ = sum
    }
}

// ç»“æœ:
// BenchmarkSlice-8        200000    8000 ns/op   8192 B/op   1 allocs/op
// BenchmarkIterator-8     500000    3200 ns/op      0 B/op   0 allocs/op
// è¿­ä»£å™¨ï¼šæ›´å¿«ï¼Œæ— å†…å­˜åˆ†é…
```

---

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. æå‰é€€å‡º

```go
// âœ… æ­£ç¡®ï¼šå“åº” yield è¿”å›å€¼
func Numbers(n int) iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := 0; i < n; i++ {
            if !yield(i) {  // æ£€æŸ¥è¿”å›å€¼
                return      // æå‰é€€å‡º
            }
        }
    }
}

// âŒ é”™è¯¯ï¼šå¿½ç•¥è¿”å›å€¼
func NumbersBad(n int) iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := 0; i < n; i++ {
            yield(i)  // å¿½ç•¥è¿”å›å€¼ï¼Œå¯èƒ½æµªè´¹èµ„æº
        }
    }
}
```

### 2. èµ„æºæ¸…ç†

```go
func ReadLines(filename string) iter.Seq[string] {
    return func(yield func(string) bool) {
        file, err := os.Open(filename)
        if err != nil {
            return
        }
        defer file.Close()  // âœ… ç¡®ä¿æ–‡ä»¶å…³é—­
        
        scanner := bufio.NewScanner(file)
        for scanner.Scan() {
            if !yield(scanner.Text()) {
                return  // æå‰é€€å‡ºä¹Ÿä¼šæ‰§è¡Œ defer
            }
        }
    }
}
```

### 3. é”™è¯¯å¤„ç†

è¿­ä»£å™¨æœ¬èº«ä¸ç›´æ¥æ”¯æŒé”™è¯¯è¿”å›ï¼Œå¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ¨¡å¼ï¼š

```go
type Result[T any] struct {
    Value T
    Err   error
}

func QueryWithErrors(db *sql.DB) iter.Seq[Result[User]] {
    return func(yield func(Result[User]) bool) {
        rows, err := db.Query("...")
        if err != nil {
            yield(Result[User]{Err: err})
            return
        }
        defer rows.Close()
        
        for rows.Next() {
            var user User
            if err := rows.Scan(&user.ID, &user.Name); err != nil {
                yield(Result[User]{Err: err})
                return
            }
            if !yield(Result[User]{Value: user}) {
                return
            }
        }
    }
}

// ä½¿ç”¨
for result := range QueryWithErrors(db) {
    if result.Err != nil {
        log.Println("Error:", result.Err)
        break
    }
    fmt.Println("User:", result.Value)
}
```

---

## âš ï¸ æ³¨æ„äº‹é¡¹

### 1. ä¸è¦åœ¨ goroutine ä¸­ä½¿ç”¨ yield

```go
// âŒ é”™è¯¯ï¼šåœ¨ goroutine ä¸­è°ƒç”¨ yield
func BadIterator() iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := 0; i < 10; i++ {
            go func() {
                yield(i)  // é”™è¯¯ï¼yield ä¸æ˜¯å¹¶å‘å®‰å…¨çš„
            }()
        }
    }
}

// âœ… æ­£ç¡®ï¼šé¡ºåºè°ƒç”¨ yield
func GoodIterator() iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := 0; i < 10; i++ {
            if !yield(i) {
                return
            }
        }
    }
}
```

### 2. yield åªèƒ½åœ¨è¿­ä»£å™¨å‡½æ•°ä¸­è°ƒç”¨

```go
func InvalidIterator() iter.Seq[int] {
    return func(yield func(int) bool) {
        callback := func() {
            yield(42)  // âŒ é”™è¯¯ï¼šä¸åœ¨ç›´æ¥ä½œç”¨åŸŸä¸­
        }
        callback()
    }
}
```

---

## ğŸ“š æ‰©å±•é˜…è¯»

- [Go 1.23 Release Notes - Iterators](https://go.dev/doc/go1.23#iterators)
- [iter åŒ…æ–‡æ¡£](https://pkg.go.dev/iter)
- [Range Over Function Types Proposal](https://github.com/golang/go/issues/61897)

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ24æ—¥  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.23+
