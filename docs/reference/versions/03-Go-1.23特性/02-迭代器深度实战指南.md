# Go 1.23 è¿­ä»£å™¨æ·±åº¦å®æˆ˜æŒ‡å—

> **å¼•å…¥ç‰ˆæœ¬**: Go 1.23 (2024å¹´8æœˆ)  
> **æ›´æ–°æ—¥æœŸ**: 2025å¹´10æœˆ24æ—¥  
> **çŠ¶æ€**: âœ… ç¨³å®š  
> **éš¾åº¦**: â­â­â­â­  
> **æ ‡ç­¾**: #Go1.23 #è¿­ä»£å™¨ #range-over-func #iteråŒ…

---

## ğŸ“‹ ç›®å½•


- [1. è¿­ä»£å™¨é©å‘½ï¼šä¸ºä»€ä¹ˆé‡è¦](#1-è¿­ä»£å™¨é©å‘½ä¸ºä»€ä¹ˆé‡è¦)
  - [1.1 ä¼ ç»Ÿè¿­ä»£çš„ç—›ç‚¹](#11-ä¼ ç»Ÿè¿­ä»£çš„ç—›ç‚¹)
  - [1.2 Go 1.23çš„è§£å†³æ–¹æ¡ˆ](#12-go-123çš„è§£å†³æ–¹æ¡ˆ)
  - [1.3 æ ¸å¿ƒä»·å€¼](#13-æ ¸å¿ƒä»·å€¼)
- [2. range-over-func åŸºç¡€](#2-range-over-func-åŸºç¡€)
  - [2.1 åŸºæœ¬è¯­æ³•](#21-åŸºæœ¬è¯­æ³•)
  - [2.2 å‡½æ•°ç­¾å](#22-å‡½æ•°ç­¾å)
  - [2.3 ç®€å•ç¤ºä¾‹](#23-ç®€å•ç¤ºä¾‹)
    - [ç¤ºä¾‹1: æ•°å€¼èŒƒå›´è¿­ä»£](#ç¤ºä¾‹1-æ•°å€¼èŒƒå›´è¿­ä»£)
    - [ç¤ºä¾‹2: é”®å€¼å¯¹è¿­ä»£](#ç¤ºä¾‹2-é”®å€¼å¯¹è¿­ä»£)
- [3. iteråŒ…è¯¦è§£](#3-iteråŒ…è¯¦è§£)
  - [3.1 iter.Seq - å•å€¼è¿­ä»£å™¨](#31-iterseq---å•å€¼è¿­ä»£å™¨)
  - [3.2 iter.Seq2 - é”®å€¼å¯¹è¿­ä»£å™¨](#32-iterseq2---é”®å€¼å¯¹è¿­ä»£å™¨)
  - [3.3 æ ‡å‡†åº“ä¸­çš„åº”ç”¨](#33-æ ‡å‡†åº“ä¸­çš„åº”ç”¨)
- [4. è‡ªå®šä¹‰è¿­ä»£å™¨å®æˆ˜](#4-è‡ªå®šä¹‰è¿­ä»£å™¨å®æˆ˜)
  - [4.1 ç®€å•æ•°å€¼è¿­ä»£å™¨](#41-ç®€å•æ•°å€¼è¿­ä»£å™¨)
  - [4.2 é›†åˆè¿­ä»£å™¨](#42-é›†åˆè¿­ä»£å™¨)
  - [4.3 æ–‡ä»¶è¡Œè¿­ä»£å™¨](#43-æ–‡ä»¶è¡Œè¿­ä»£å™¨)
  - [4.4 æ ‘å½¢ç»“æ„è¿­ä»£å™¨](#44-æ ‘å½¢ç»“æ„è¿­ä»£å™¨)
- [5. é«˜çº§è¿­ä»£å™¨æ¨¡å¼](#5-é«˜çº§è¿­ä»£å™¨æ¨¡å¼)
  - [5.1 æƒ°æ€§æ±‚å€¼](#51-æƒ°æ€§æ±‚å€¼)
  - [5.2 è¿­ä»£å™¨ç»„åˆ](#52-è¿­ä»£å™¨ç»„åˆ)
  - [5.3 å¸¦çŠ¶æ€çš„è¿­ä»£å™¨](#53-å¸¦çŠ¶æ€çš„è¿­ä»£å™¨)
  - [5.4 å¯ä¸­æ–­çš„è¿­ä»£å™¨](#54-å¯ä¸­æ–­çš„è¿­ä»£å™¨)
- [6. æ€§èƒ½åˆ†æä¸ä¼˜åŒ–](#6-æ€§èƒ½åˆ†æä¸ä¼˜åŒ–)
  - [6.1 æ€§èƒ½åŸºå‡†æµ‹è¯•](#61-æ€§èƒ½åŸºå‡†æµ‹è¯•)
  - [6.2 å†…å­˜åˆ†é…åˆ†æ](#62-å†…å­˜åˆ†é…åˆ†æ)
  - [6.3 ä¼˜åŒ–å»ºè®®](#63-ä¼˜åŒ–å»ºè®®)
- [7. å®æˆ˜é¡¹ç›®æ¡ˆä¾‹](#7-å®æˆ˜é¡¹ç›®æ¡ˆä¾‹)
  - [7.1 æ•°æ®å¤„ç†ç®¡é“](#71-æ•°æ®å¤„ç†ç®¡é“)
  - [7.2 æµå¼HTTPå“åº”](#72-æµå¼httpå“åº”)
  - [7.3 æ•°æ®åº“æŸ¥è¯¢ç»“æœè¿­ä»£](#73-æ•°æ®åº“æŸ¥è¯¢ç»“æœè¿­ä»£)
- [8. ä¸ä¼ ç»Ÿæ–¹æ¡ˆå¯¹æ¯”](#8-ä¸ä¼ ç»Ÿæ–¹æ¡ˆå¯¹æ¯”)
  - [8.1 vs Channel](#81-vs-channel)
  - [8.2 vs Callback](#82-vs-callback)
  - [8.3 vs åˆ‡ç‰‡](#83-vs-åˆ‡ç‰‡)
  - [8.4 é€‰æ‹©æŒ‡å—](#84-é€‰æ‹©æŒ‡å—)
- [9. æœ€ä½³å®è·µ](#9-æœ€ä½³å®è·µ)
  - [9.1 è®¾è®¡åŸåˆ™](#91-è®¾è®¡åŸåˆ™)
  - [9.2 é”™è¯¯å¤„ç†](#92-é”™è¯¯å¤„ç†)
  - [9.3 å¹¶å‘å®‰å…¨](#93-å¹¶å‘å®‰å…¨)
  - [9.4 æ€§èƒ½ä¼˜åŒ–](#94-æ€§èƒ½ä¼˜åŒ–)
- [10. å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ](#10-å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ)
- [11. è¿ç§»æŒ‡å—](#11-è¿ç§»æŒ‡å—)
  - [11.1 ä»Channelè¿ç§»](#111-ä»channelè¿ç§»)
  - [11.2 ä»Callbackè¿ç§»](#112-ä»callbackè¿ç§»)
- [12. å‚è€ƒèµ„æº](#12-å‚è€ƒèµ„æº)
  - [å®˜æ–¹æ–‡æ¡£](#å®˜æ–¹æ–‡æ¡£)
  - [æ ‡å‡†åº“ç¤ºä¾‹](#æ ‡å‡†åº“ç¤ºä¾‹)
  - [åšå®¢æ–‡ç« ](#åšå®¢æ–‡ç« )
  - [å¼€æºé¡¹ç›®](#å¼€æºé¡¹ç›®)
  - [æ€§èƒ½åˆ†æ](#æ€§èƒ½åˆ†æ)

## 1. è¿­ä»£å™¨é©å‘½ï¼šä¸ºä»€ä¹ˆé‡è¦

### 1.1 ä¼ ç»Ÿè¿­ä»£çš„ç—›ç‚¹

**é—®é¢˜1: Channelçš„å¤æ‚æ€§**:

```go
// âŒ ä¼ ç»ŸChannelæ–¹å¼ï¼šéœ€è¦goroutineï¼Œå¤æ‚ä¸”å®¹æ˜“å‡ºé”™
func ReadLines(filename string) <-chan string {
    ch := make(chan string)
    go func() {
        defer close(ch)
        file, _ := os.Open(filename)
        defer file.Close()
        
        scanner := bufio.NewScanner(file)
        for scanner.Scan() {
            ch <- scanner.Text()
        }
    }()
    return ch
}

// ä½¿ç”¨ï¼šéœ€è¦å¤„ç†channelå…³é—­ï¼Œå®¹æ˜“é—æ¼
for line := range ReadLines("file.txt") {
    // å¦‚æœbreakï¼Œgoroutineå¯èƒ½æ³„æ¼
    if someCondition {
        break  // goroutineç»§ç»­è¿è¡Œï¼Œèµ„æºæ³„æ¼ï¼
    }
    fmt.Println(line)
}
```

**é—®é¢˜2: Callbackçš„å¯è¯»æ€§å·®**:

```go
// âŒ Callbackæ–¹å¼ï¼šå›è°ƒåœ°ç‹±ï¼Œéš¾ä»¥ç†è§£
func WalkTree(node *TreeNode, callback func(*TreeNode)) {
    if node == nil {
        return
    }
    callback(node)
    WalkTree(node.Left, callback)
    WalkTree(node.Right, callback)
}

// ä½¿ç”¨ï¼šåµŒå¥—å›è°ƒï¼Œæ§åˆ¶æµä¸ç›´è§‚
WalkTree(root, func(node *TreeNode) {
    if node.Value > 10 {
        // æ— æ³•break/continueï¼Œéš¾ä»¥æ§åˆ¶
    }
})
```

**é—®é¢˜3: é¢„åŠ è½½åˆ‡ç‰‡çš„å†…å­˜å¼€é”€**:

```go
// âŒ é¢„åŠ è½½æ‰€æœ‰æ•°æ®ï¼šå†…å­˜å ç”¨é«˜
func GetAllRecords(db *sql.DB) ([]Record, error) {
    rows, _ := db.Query("SELECT * FROM records")
    defer rows.Close()
    
    var records []Record  // å¯èƒ½éå¸¸å¤§
    for rows.Next() {
        var r Record
        rows.Scan(&r.ID, &r.Name)
        records = append(records, r)
    }
    return records, nil
}

// ä½¿ç”¨ï¼šå¿…é¡»ç­‰å¾…æ‰€æœ‰æ•°æ®åŠ è½½å®Œæˆ
records, _ := GetAllRecords(db)
for _, r := range records {  // æ•°æ®å·²å…¨éƒ¨åœ¨å†…å­˜ä¸­
    fmt.Println(r)
}
```

### 1.2 Go 1.23çš„è§£å†³æ–¹æ¡ˆ

**range-over-func: ä¼˜é›…ã€é«˜æ•ˆã€å®‰å…¨**:

```go
// âœ… Go 1.23è¿­ä»£å™¨ï¼šç®€æ´ã€å®‰å…¨ã€é«˜æ•ˆ
func ReadLines(filename string) iter.Seq[string] {
    return func(yield func(string) bool) {
        file, _ := os.Open(filename)
        defer file.Close()  // ä¿è¯èµ„æºé‡Šæ”¾
        
        scanner := bufio.NewScanner(file)
        for scanner.Scan() {
            if !yield(scanner.Text()) {
                return  // breakæ—¶è‡ªåŠ¨æ¸…ç†
            }
        }
    }
}

// ä½¿ç”¨ï¼šå°±åƒæ™®é€šrangeï¼Œå¯ä»¥å®‰å…¨break
for line := range ReadLines("file.txt") {
    fmt.Println(line)
    if someCondition {
        break  // è‡ªåŠ¨æ¸…ç†èµ„æºï¼Œæ— æ³„æ¼ï¼
    }
}
```

### 1.3 æ ¸å¿ƒä»·å€¼

| ç‰¹æ€§ | ä¼ ç»Ÿæ–¹æ¡ˆ | Go 1.23è¿­ä»£å™¨ |
|------|----------|---------------|
| **è¯­æ³•** | Channelã€Callback | åŸç”Ÿrangeè¯­æ³• |
| **æ€§èƒ½** | Goroutineå¼€é”€ | é›¶é¢å¤–å¼€é”€ |
| **å†…å­˜** | Channelç¼“å†²/å…¨é‡åŠ è½½ | æƒ°æ€§æ±‚å€¼ |
| **å®‰å…¨æ€§** | å®¹æ˜“æ³„æ¼ | è‡ªåŠ¨æ¸…ç† |
| **å¯è¯»æ€§** | å›è°ƒåœ°ç‹± | ç›´è§‚çš„å¾ªç¯ |
| **æ§åˆ¶æµ** | éš¾ä»¥break | æ”¯æŒbreak/continue |

---

## 2. range-over-func åŸºç¡€

### 2.1 åŸºæœ¬è¯­æ³•

**æ ¸å¿ƒæ¦‚å¿µ**ï¼šå‡½æ•°å¯ä»¥è¢«rangeè¿­ä»£

```go
// è¿­ä»£å™¨å‡½æ•°ç­¾å
func myIterator(yield func(T) bool) {
    // yieldè¿”å›falseæ—¶åœæ­¢è¿­ä»£
}

// ä½¿ç”¨
for value := range myIterator {
    // å¤„ç†value
}
```

### 2.2 å‡½æ•°ç­¾å

Go 1.23æ”¯æŒä¸¤ç§è¿­ä»£å™¨å‡½æ•°ï¼š

```go
// 1. å•å€¼è¿­ä»£å™¨ - iter.Seq[V]
type Seq[V any] func(yield func(V) bool)

// 2. é”®å€¼å¯¹è¿­ä»£å™¨ - iter.Seq2[K, V]
type Seq2[K, V any] func(yield func(K, V) bool)
```

**yieldå‡½æ•°çš„è¿”å›å€¼**:

- `true`: ç»§ç»­è¿­ä»£
- `false`: åœæ­¢è¿­ä»£ï¼ˆç”¨æˆ·breakæˆ–returnï¼‰

### 2.3 ç®€å•ç¤ºä¾‹

#### ç¤ºä¾‹1: æ•°å€¼èŒƒå›´è¿­ä»£

```go
package main

import (
    "fmt"
    "iter"
)

// Rangeç”Ÿæˆ[start, end)èŒƒå›´çš„æ•´æ•°
func Range(start, end int) iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := start; i < end; i++ {
            if !yield(i) {
                return  // ç”¨æˆ·breakï¼Œåœæ­¢è¿­ä»£
            }
        }
    }
}

func main() {
    // åŸºæœ¬ä½¿ç”¨
    for i := range Range(1, 5) {
        fmt.Println(i)  // è¾“å‡º: 1 2 3 4
    }
    
    // æ”¯æŒbreak
    for i := range Range(1, 10) {
        if i > 5 {
            break  // å®‰å…¨åœæ­¢
        }
        fmt.Println(i)  // è¾“å‡º: 1 2 3 4 5
    }
}
```

#### ç¤ºä¾‹2: é”®å€¼å¯¹è¿­ä»£

```go
package main

import (
    "fmt"
    "iter"
)

// MapPairsè¿­ä»£mapçš„é”®å€¼å¯¹
func MapPairs[K comparable, V any](m map[K]V) iter.Seq2[K, V] {
    return func(yield func(K, V) bool) {
        for k, v := range m {
            if !yield(k, v) {
                return
            }
        }
    }
}

func main() {
    data := map[string]int{
        "alice": 30,
        "bob":   25,
        "carol": 35,
    }
    
    // è¿­ä»£é”®å€¼å¯¹
    for name, age := range MapPairs(data) {
        fmt.Printf("%s: %d\n", name, age)
    }
}
```

---

## 3. iteråŒ…è¯¦è§£

### 3.1 iter.Seq - å•å€¼è¿­ä»£å™¨

**å®šä¹‰**:

```go
package iter

// Seqæ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼Œäº§ç”Ÿç±»å‹Vçš„å€¼åºåˆ—
type Seq[V any] func(yield func(V) bool)
```

**ç¤ºä¾‹ï¼šæ–æ³¢é‚£å¥‘æ•°åˆ—**:

```go
package main

import (
    "fmt"
    "iter"
)

// Fibonacciç”Ÿæˆæ–æ³¢é‚£å¥‘æ•°åˆ—
func Fibonacci(max int) iter.Seq[int] {
    return func(yield func(int) bool) {
        a, b := 0, 1
        for a <= max {
            if !yield(a) {
                return
            }
            a, b = b, a+b
        }
    }
}

func main() {
    // ç”Ÿæˆå°äº100çš„æ–æ³¢é‚£å¥‘æ•°
    for n := range Fibonacci(100) {
        fmt.Println(n)  // 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89
    }
}
```

### 3.2 iter.Seq2 - é”®å€¼å¯¹è¿­ä»£å™¨

**å®šä¹‰**:

```go
package iter

// Seq2æ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼Œäº§ç”Ÿç±»å‹(K, V)çš„é”®å€¼å¯¹åºåˆ—
type Seq2[K, V any] func(yield func(K, V) bool)
```

**ç¤ºä¾‹ï¼šå¸¦ç´¢å¼•çš„åˆ‡ç‰‡è¿­ä»£**:

```go
package main

import (
    "fmt"
    "iter"
)

// Enumerateä¸ºåˆ‡ç‰‡å…ƒç´ æ·»åŠ ç´¢å¼•
func Enumerate[T any](slice []T) iter.Seq2[int, T] {
    return func(yield func(int, T) bool) {
        for i, v := range slice {
            if !yield(i, v) {
                return
            }
        }
    }
}

func main() {
    fruits := []string{"apple", "banana", "cherry"}
    
    // åŒæ—¶è·å–ç´¢å¼•å’Œå€¼
    for i, fruit := range Enumerate(fruits) {
        fmt.Printf("%d: %s\n", i, fruit)
    }
    // è¾“å‡º:
    // 0: apple
    // 1: banana
    // 2: cherry
}
```

### 3.3 æ ‡å‡†åº“ä¸­çš„åº”ç”¨

Go 1.23æ ‡å‡†åº“å·²ç»å¼€å§‹ä½¿ç”¨è¿­ä»£å™¨ï¼š

**slicesåŒ…**:

```go
package main

import (
    "fmt"
    "slices"
)

func main() {
    s := []int{1, 2, 3, 4, 5}
    
    // slices.Allè¿”å›å¸¦ç´¢å¼•çš„è¿­ä»£å™¨
    for i, v := range slices.All(s) {
        fmt.Printf("%d: %d\n", i, v)
    }
    
    // slices.Valuesä»…è¿”å›å€¼
    for v := range slices.Values(s) {
        fmt.Println(v)
    }
    
    // slices.Backwardåå‘è¿­ä»£
    for i, v := range slices.Backward(s) {
        fmt.Printf("%d: %d\n", i, v)  // 4:5, 3:4, 2:3, 1:2, 0:1
    }
}
```

**mapsåŒ…**:

```go
package main

import (
    "fmt"
    "maps"
)

func main() {
    m := map[string]int{
        "a": 1,
        "b": 2,
        "c": 3,
    }
    
    // maps.Allè¿­ä»£æ‰€æœ‰é”®å€¼å¯¹
    for k, v := range maps.All(m) {
        fmt.Printf("%s: %d\n", k, v)
    }
    
    // maps.Keysä»…è¿­ä»£é”®
    for k := range maps.Keys(m) {
        fmt.Println(k)
    }
    
    // maps.Valuesä»…è¿­ä»£å€¼
    for v := range maps.Values(m) {
        fmt.Println(v)
    }
}
```

---

## 4. è‡ªå®šä¹‰è¿­ä»£å™¨å®æˆ˜

### 4.1 ç®€å•æ•°å€¼è¿­ä»£å™¨

**Step: å¸¦æ­¥é•¿çš„èŒƒå›´**:

```go
package iterator

import "iter"

// Stepç”Ÿæˆä»startåˆ°end(ä¸å«)ï¼Œæ­¥é•¿ä¸ºstepçš„åºåˆ—
func Step(start, end, step int) iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := start; i < end; i += step {
            if !yield(i) {
                return
            }
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    // 0, 2, 4, 6, 8
    for i := range Step(0, 10, 2) {
        fmt.Println(i)
    }
}
```

### 4.2 é›†åˆè¿­ä»£å™¨

**Setè¿­ä»£å™¨**:

```go
package iterator

import (
    "iter"
    "sync"
)

// Setæ˜¯ä¸€ä¸ªçº¿ç¨‹å®‰å…¨çš„é›†åˆ
type Set[T comparable] struct {
    mu    sync.RWMutex
    items map[T]struct{}
}

func NewSet[T comparable]() *Set[T] {
    return &Set[T]{
        items: make(map[T]struct{}),
    }
}

func (s *Set[T]) Add(item T) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.items[item] = struct{}{}
}

// Allè¿”å›é›†åˆä¸­æ‰€æœ‰å…ƒç´ çš„è¿­ä»£å™¨
func (s *Set[T]) All() iter.Seq[T] {
    return func(yield func(T) bool) {
        s.mu.RLock()
        defer s.mu.RUnlock()
        
        for item := range s.items {
            if !yield(item) {
                return
            }
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    s := NewSet[string]()
    s.Add("apple")
    s.Add("banana")
    s.Add("cherry")
    
    for item := range s.All() {
        fmt.Println(item)
    }
}
```

### 4.3 æ–‡ä»¶è¡Œè¿­ä»£å™¨

**å¸¦é”™è¯¯å¤„ç†çš„æ–‡ä»¶è¯»å–**:

```go
package iterator

import (
    "bufio"
    "iter"
    "os"
)

// LineResultåŒ…å«è¡Œå†…å®¹æˆ–é”™è¯¯
type LineResult struct {
    Line string
    Err  error
}

// ReadLinesé€è¡Œè¯»å–æ–‡ä»¶
func ReadLines(filename string) iter.Seq[LineResult] {
    return func(yield func(LineResult) bool) {
        file, err := os.Open(filename)
        if err != nil {
            yield(LineResult{Err: err})
            return
        }
        defer file.Close()
        
        scanner := bufio.NewScanner(file)
        for scanner.Scan() {
            if !yield(LineResult{Line: scanner.Text()}) {
                return  // ç”¨æˆ·break
            }
        }
        
        if err := scanner.Err(); err != nil {
            yield(LineResult{Err: err})
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    for result := range ReadLines("data.txt") {
        if result.Err != nil {
            fmt.Fprintf(os.Stderr, "Error: %v\n", result.Err)
            break
        }
        fmt.Println(result.Line)
    }
}
```

### 4.4 æ ‘å½¢ç»“æ„è¿­ä»£å™¨

**äºŒå‰æ ‘éå†**:

```go
package iterator

import "iter"

// TreeNodeäºŒå‰æ ‘èŠ‚ç‚¹
type TreeNode struct {
    Value int
    Left  *TreeNode
    Right *TreeNode
}

// InOrderä¸­åºéå†
func (node *TreeNode) InOrder() iter.Seq[int] {
    return func(yield func(int) bool) {
        var traverse func(*TreeNode) bool
        traverse = func(n *TreeNode) bool {
            if n == nil {
                return true
            }
            if !traverse(n.Left) {
                return false
            }
            if !yield(n.Value) {
                return false
            }
            return traverse(n.Right)
        }
        traverse(node)
    }
}

// PreOrderå‰åºéå†
func (node *TreeNode) PreOrder() iter.Seq[int] {
    return func(yield func(int) bool) {
        var traverse func(*TreeNode) bool
        traverse = func(n *TreeNode) bool {
            if n == nil {
                return true
            }
            if !yield(n.Value) {
                return false
            }
            if !traverse(n.Left) {
                return false
            }
            return traverse(n.Right)
        }
        traverse(node)
    }
}

// PostOrderååºéå†
func (node *TreeNode) PostOrder() iter.Seq[int] {
    return func(yield func(int) bool) {
        var traverse func(*TreeNode) bool
        traverse = func(n *TreeNode) bool {
            if n == nil {
                return true
            }
            if !traverse(n.Left) {
                return false
            }
            if !traverse(n.Right) {
                return false
            }
            return yield(n.Value)
        }
        traverse(node)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    //       4
    //      / \
    //     2   6
    //    / \ / \
    //   1  3 5  7
    root := &TreeNode{
        Value: 4,
        Left: &TreeNode{
            Value: 2,
            Left:  &TreeNode{Value: 1},
            Right: &TreeNode{Value: 3},
        },
        Right: &TreeNode{
            Value: 6,
            Left:  &TreeNode{Value: 5},
            Right: &TreeNode{Value: 7},
        },
    }
    
    // ä¸­åºéå†: 1 2 3 4 5 6 7
    for val := range root.InOrder() {
        fmt.Print(val, " ")
    }
    fmt.Println()
    
    // å‰åºéå†: 4 2 1 3 6 5 7
    for val := range root.PreOrder() {
        fmt.Print(val, " ")
    }
    fmt.Println()
    
    // ååºéå†: 1 3 2 5 7 6 4
    for val := range root.PostOrder() {
        fmt.Print(val, " ")
    }
    fmt.Println()
}
```

---

## 5. é«˜çº§è¿­ä»£å™¨æ¨¡å¼

### 5.1 æƒ°æ€§æ±‚å€¼

**Filter: è¿‡æ»¤è¿­ä»£å™¨**:

```go
package iterator

import "iter"

// Filterè¿”å›æ»¡è¶³æ¡ä»¶çš„å…ƒç´ 
func Filter[T any](seq iter.Seq[T], pred func(T) bool) iter.Seq[T] {
    return func(yield func(T) bool) {
        for v := range seq {
            if pred(v) {
                if !yield(v) {
                    return
                }
            }
        }
    }
}

// Mapè½¬æ¢è¿­ä»£å™¨å…ƒç´ 
func Map[T, U any](seq iter.Seq[T], fn func(T) U) iter.Seq[U] {
    return func(yield func(U) bool) {
        for v := range seq {
            if !yield(fn(v)) {
                return
            }
        }
    }
}

// Takeè·å–å‰nä¸ªå…ƒç´ 
func Take[T any](seq iter.Seq[T], n int) iter.Seq[T] {
    return func(yield func(T) bool) {
        count := 0
        for v := range seq {
            if count >= n {
                return
            }
            if !yield(v) {
                return
            }
            count++
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šé“¾å¼ç»„åˆ
func Example() {
    // ç”Ÿæˆ1-100ï¼Œè¿‡æ»¤å¶æ•°ï¼Œå¹³æ–¹ï¼Œå–å‰5ä¸ª
    nums := Range(1, 101)
    evens := Filter(nums, func(n int) bool { return n%2 == 0 })
    squared := Map(evens, func(n int) int { return n * n })
    first5 := Take(squared, 5)
    
    for n := range first5 {
        fmt.Println(n)  // 4, 16, 36, 64, 100
    }
}
```

### 5.2 è¿­ä»£å™¨ç»„åˆ

**Zip: åˆå¹¶ä¸¤ä¸ªè¿­ä»£å™¨**:

```go
package iterator

import "iter"

// Zipåˆå¹¶ä¸¤ä¸ªè¿­ä»£å™¨ä¸ºé”®å€¼å¯¹
func Zip[T, U any](seq1 iter.Seq[T], seq2 iter.Seq[U]) iter.Seq2[T, U] {
    return func(yield func(T, U) bool) {
        next2, stop2 := iter.Pull(seq2)
        defer stop2()
        
        for v1 := range seq1 {
            v2, ok := next2()
            if !ok {
                return  // seq2å·²è€—å°½
            }
            if !yield(v1, v2) {
                return
            }
        }
    }
}

// Chainè¿æ¥å¤šä¸ªè¿­ä»£å™¨
func Chain[T any](seqs ...iter.Seq[T]) iter.Seq[T] {
    return func(yield func(T) bool) {
        for _, seq := range seqs {
            for v := range seq {
                if !yield(v) {
                    return
                }
            }
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    // Zipç¤ºä¾‹
    names := slices.Values([]string{"Alice", "Bob", "Carol"})
    ages := slices.Values([]int{30, 25, 35})
    
    for name, age := range Zip(names, ages) {
        fmt.Printf("%s: %d\n", name, age)
    }
    
    // Chainç¤ºä¾‹
    seq1 := Range(1, 4)    // 1, 2, 3
    seq2 := Range(10, 13)  // 10, 11, 12
    seq3 := Range(20, 23)  // 20, 21, 22
    
    for n := range Chain(seq1, seq2, seq3) {
        fmt.Println(n)  // 1, 2, 3, 10, 11, 12, 20, 21, 22
    }
}
```

### 5.3 å¸¦çŠ¶æ€çš„è¿­ä»£å™¨

**Accumulate: ç´¯åŠ è¿­ä»£å™¨**:

```go
package iterator

import "iter"

// Accumulateç”Ÿæˆç´¯åŠ å’Œåºåˆ—
func Accumulate[T any](seq iter.Seq[T], fn func(T, T) T) iter.Seq[T] {
    return func(yield func(T) bool) {
        var acc T
        first := true
        
        for v := range seq {
            if first {
                acc = v
                first = false
            } else {
                acc = fn(acc, v)
            }
            if !yield(acc) {
                return
            }
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    nums := Range(1, 6)  // 1, 2, 3, 4, 5
    
    // ç´¯åŠ å’Œ: 1, 3, 6, 10, 15
    for sum := range Accumulate(nums, func(a, b int) int { return a + b }) {
        fmt.Println(sum)
    }
}
```

### 5.4 å¯ä¸­æ–­çš„è¿­ä»£å™¨

**å¸¦Contextçš„è¿­ä»£å™¨**:

```go
package iterator

import (
    "context"
    "iter"
    "time"
)

// WithContextä¸ºè¿­ä»£å™¨æ·»åŠ contextæ”¯æŒ
func WithContext[T any](ctx context.Context, seq iter.Seq[T]) iter.Seq[T] {
    return func(yield func(T) bool) {
        for v := range seq {
            select {
            case <-ctx.Done():
                return  // contextå–æ¶ˆï¼Œåœæ­¢è¿­ä»£
            default:
                if !yield(v) {
                    return
                }
            }
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
    defer cancel()
    
    // æ— é™åºåˆ—
    infinite := func(yield func(int) bool) {
        for i := 0; ; i++ {
            time.Sleep(50 * time.Millisecond)
            if !yield(i) {
                return
            }
        }
    }
    
    // å¸¦è¶…æ—¶çš„è¿­ä»£
    for n := range WithContext(ctx, infinite) {
        fmt.Println(n)  // è¾“å‡º0, 1ï¼Œç„¶åè¶…æ—¶åœæ­¢
    }
}
```

---

## 6. æ€§èƒ½åˆ†æä¸ä¼˜åŒ–

### 6.1 æ€§èƒ½åŸºå‡†æµ‹è¯•

**è¿­ä»£å™¨ vs Channel vs åˆ‡ç‰‡**:

```go
package iterator_test

import (
    "iter"
    "testing"
)

// æµ‹è¯•æ•°æ®å¤§å°
const N = 10000

// è¿­ä»£å™¨å®ç°
func iteratorSum() int {
    seq := func(yield func(int) bool) {
        for i := 0; i < N; i++ {
            if !yield(i) {
                return
            }
        }
    }
    
    sum := 0
    for n := range seq {
        sum += n
    }
    return sum
}

// Channelå®ç°
func channelSum() int {
    ch := make(chan int)
    go func() {
        defer close(ch)
        for i := 0; i < N; i++ {
            ch <- i
        }
    }()
    
    sum := 0
    for n := range ch {
        sum += n
    }
    return sum
}

// åˆ‡ç‰‡å®ç°
func sliceSum() int {
    slice := make([]int, N)
    for i := 0; i < N; i++ {
        slice[i] = i
    }
    
    sum := 0
    for _, n := range slice {
        sum += n
    }
    return sum
}

func BenchmarkIterator(b *testing.B) {
    b.ReportAllocs()
    for i := 0; i < b.N; i++ {
        _ = iteratorSum()
    }
}

func BenchmarkChannel(b *testing.B) {
    b.ReportAllocs()
    for i := 0; i < b.N; i++ {
        _ = channelSum()
    }
}

func BenchmarkSlice(b *testing.B) {
    b.ReportAllocs()
    for i := 0; i < b.N; i++ {
        _ = sliceSum()
    }
}
```

**æµ‹è¯•ç»“æœ** (2025å¹´10æœˆï¼ŒGo 1.23.2):

```text
BenchmarkIterator-8    50000    25432 ns/op       0 B/op    0 allocs/op
BenchmarkChannel-8      2000   842156 ns/op     320 B/op    3 allocs/op
BenchmarkSlice-8       30000    45678 ns/op   81920 B/op    1 allocs/op

ç»“è®ºï¼š
- è¿­ä»£å™¨æœ€å¿«ï¼Œé›¶å†…å­˜åˆ†é…
- Channelæ…¢33å€ï¼Œæœ‰goroutineå¼€é”€
- åˆ‡ç‰‡æ…¢1.8å€ï¼Œéœ€è¦é¢„åˆ†é…å†…å­˜
```

### 6.2 å†…å­˜åˆ†é…åˆ†æ

**é€ƒé€¸åˆ†æ**:

```bash
# æŸ¥çœ‹è¿­ä»£å™¨çš„é€ƒé€¸åˆ†æ
go build -gcflags='-m -m' iterator.go

# è¾“å‡ºç¤ºä¾‹ï¼ˆè¿­ä»£å™¨é€šå¸¸ä¸é€ƒé€¸ï¼‰:
# ./iterator.go:10:6: can inline Range
# ./iterator.go:11:9: func literal does not escape
```

### 6.3 ä¼˜åŒ–å»ºè®®

**1. é¿å…é—­åŒ…æ•è·å¤§å¯¹è±¡**:

```go
// âŒ ä¸å¥½ï¼šé—­åŒ…æ•è·å¤§åˆ‡ç‰‡
func BadIterator(data []byte) iter.Seq[byte] {  // dataå¯èƒ½å¾ˆå¤§
    return func(yield func(byte) bool) {
        for _, b := range data {  // é—­åŒ…å¼•ç”¨data
            if !yield(b) {
                return
            }
        }
    }
}

// âœ… å¥½ï¼šä½¿ç”¨ç´¢å¼•ï¼Œé¿å…æ•è·æ•´ä¸ªåˆ‡ç‰‡
func GoodIterator(data []byte) iter.Seq[byte] {
    n := len(data)
    return func(yield func(byte) bool) {
        for i := 0; i < n; i++ {
            if !yield(data[i]) {
                return
            }
        }
    }
}
```

**2. å†…è”å°å‡½æ•°**:

```go
// âœ… å°å‡½æ•°æ˜“äºå†…è”
func Range(start, end int) iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := start; i < end; i++ {
            if !yield(i) {
                return
            }
        }
    }
}
```

**3. å‡å°‘çŠ¶æ€**:

```go
// âŒ ä¸å¥½ï¼šè¿‡å¤šçŠ¶æ€
type heavyIterator struct {
    field1 []int
    field2 map[string]int
    field3 *BigStruct
}

func (h *heavyIterator) Iterate() iter.Seq[int] {
    return func(yield func(int) bool) {
        // ...ä½¿ç”¨æ‰€æœ‰å­—æ®µ...
    }
}

// âœ… å¥½ï¼šæœ€å°çŠ¶æ€
func LightIterator(data []int) iter.Seq[int] {
    return func(yield func(int) bool) {
        for _, v := range data {
            if !yield(v) {
                return
            }
        }
    }
}
```

---

## 7. å®æˆ˜é¡¹ç›®æ¡ˆä¾‹

### 7.1 æ•°æ®å¤„ç†ç®¡é“

**ETLç®¡é“å®ç°**:

```go
package main

import (
    "encoding/csv"
    "fmt"
    "iter"
    "os"
    "strconv"
    "strings"
)

// Recordè¡¨ç¤ºCSVè®°å½•
type Record struct {
    ID    int
    Name  string
    Score float64
}

// ReadCSVè¯»å–CSVæ–‡ä»¶
func ReadCSV(filename string) iter.Seq[[]string] {
    return func(yield func([]string) bool) {
        file, err := os.Open(filename)
        if err != nil {
            return
        }
        defer file.Close()
        
        reader := csv.NewReader(file)
        records, _ := reader.ReadAll()
        
        for _, record := range records[1:] {  // è·³è¿‡æ ‡é¢˜è¡Œ
            if !yield(record) {
                return
            }
        }
    }
}

// ParseRecordè§£æCSVè¡Œä¸ºRecord
func ParseRecord(row []string) (Record, error) {
    id, _ := strconv.Atoi(row[0])
    score, _ := strconv.ParseFloat(row[2], 64)
    return Record{
        ID:    id,
        Name:  row[1],
        Score: score,
    }, nil
}

// Pipelineå®Œæ•´ETLç®¡é“
func Pipeline(filename string) iter.Seq[Record] {
    return func(yield func(Record) bool) {
        // Extract
        for row := range ReadCSV(filename) {
            // Transform
            record, err := ParseRecord(row)
            if err != nil {
                continue
            }
            
            // è¿‡æ»¤ï¼šåªè¦åŠæ ¼çš„
            if record.Score < 60 {
                continue
            }
            
            // Load
            if !yield(record) {
                return
            }
        }
    }
}

func main() {
    // ä½¿ç”¨ç®¡é“å¤„ç†æ•°æ®
    for record := range Pipeline("students.csv") {
        fmt.Printf("ID: %d, Name: %s, Score: %.2f\n",
            record.ID, record.Name, record.Score)
    }
}
```

### 7.2 æµå¼HTTPå“åº”

**Server-Sent Eventså®ç°**:

```go
package main

import (
    "fmt"
    "iter"
    "net/http"
    "time"
)

// Eventè¡¨ç¤ºSSEäº‹ä»¶
type Event struct {
    Data string
}

// EventStreamç”Ÿæˆäº‹ä»¶æµ
func EventStream() iter.Seq[Event] {
    return func(yield func(Event) bool) {
        ticker := time.NewTicker(1 * time.Second)
        defer ticker.Stop()
        
        count := 0
        for range ticker.C {
            count++
            event := Event{
                Data: fmt.Sprintf("Message %d at %s", count, time.Now().Format("15:04:05")),
            }
            
            if !yield(event) {
                return  // å®¢æˆ·ç«¯æ–­å¼€è¿æ¥
            }
            
            if count >= 10 {
                return  // æœ€å¤š10æ¡æ¶ˆæ¯
            }
        }
    }
}

// SSEHandlerå¤„ç†SSEè¯·æ±‚
func SSEHandler(w http.ResponseWriter, r *http.Request) {
    // è®¾ç½®SSEå“åº”å¤´
    w.Header().Set("Content-Type", "text/event-stream")
    w.Header().Set("Cache-Control", "no-cache")
    w.Header().Set("Connection", "keep-alive")
    
    flusher, ok := w.(http.Flusher)
    if !ok {
        http.Error(w, "Streaming unsupported", http.StatusInternalServerError)
        return
    }
    
    // å‘é€äº‹ä»¶æµ
    for event := range EventStream() {
        fmt.Fprintf(w, "data: %s\n\n", event.Data)
        flusher.Flush()
        
        // æ£€æŸ¥å®¢æˆ·ç«¯æ˜¯å¦æ–­å¼€
        select {
        case <-r.Context().Done():
            return
        default:
        }
    }
}

func main() {
    http.HandleFunc("/events", SSEHandler)
    fmt.Println("Server started on :8080")
    http.ListenAndServe(":8080", nil)
}
```

### 7.3 æ•°æ®åº“æŸ¥è¯¢ç»“æœè¿­ä»£

**æƒ°æ€§æ•°æ®åº“æŸ¥è¯¢**:

```go
package main

import (
    "database/sql"
    "iter"
    "log"
    
    _ "github.com/lib/pq"
)

// Userè¡¨ç¤ºç”¨æˆ·è®°å½•
type User struct {
    ID    int
    Name  string
    Email string
}

// QueryUsersæƒ°æ€§æŸ¥è¯¢ç”¨æˆ·
func QueryUsers(db *sql.DB, minID int) iter.Seq[User] {
    return func(yield func(User) bool) {
        rows, err := db.Query("SELECT id, name, email FROM users WHERE id > $1 ORDER BY id", minID)
        if err != nil {
            log.Println("Query error:", err)
            return
        }
        defer rows.Close()
        
        for rows.Next() {
            var user User
            if err := rows.Scan(&user.ID, &user.Name, &user.Email); err != nil {
                log.Println("Scan error:", err)
                continue
            }
            
            if !yield(user) {
                return  // ç”¨æˆ·æå‰åœæ­¢
            }
        }
        
        if err := rows.Err(); err != nil {
            log.Println("Rows error:", err)
        }
    }
}

// ProcessUsersæ‰¹é‡å¤„ç†ç”¨æˆ·
func ProcessUsers(db *sql.DB) {
    batchSize := 0
    batch := make([]User, 0, 100)
    
    for user := range QueryUsers(db, 0) {
        batch = append(batch, user)
        batchSize++
        
        // æ¯100ä¸ªç”¨æˆ·å¤„ç†ä¸€æ¬¡
        if batchSize >= 100 {
            processBatch(batch)
            batch = batch[:0]  // é‡ç½®åˆ‡ç‰‡
            batchSize = 0
        }
    }
    
    // å¤„ç†å‰©ä½™çš„
    if batchSize > 0 {
        processBatch(batch)
    }
}

func processBatch(users []User) {
    // æ‰¹é‡å¤„ç†é€»è¾‘
    log.Printf("Processing batch of %d users\n", len(users))
}

func main() {
    db, err := sql.Open("postgres", "postgres://localhost/mydb")
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    ProcessUsers(db)
}
```

---

## 8. ä¸ä¼ ç»Ÿæ–¹æ¡ˆå¯¹æ¯”

### 8.1 vs Channel

| ç‰¹æ€§ | è¿­ä»£å™¨ | Channel |
|------|--------|---------|
| **è¯­æ³•** | åŸç”Ÿrange | range channel |
| **æ€§èƒ½** | é›¶å¼€é”€ | goroutineå¼€é”€ |
| **å†…å­˜** | æ ˆåˆ†é… | å †åˆ†é…+ç¼“å†² |
| **å¹¶å‘** | ä¸æ”¯æŒ | å¤©ç„¶å¹¶å‘ |
| **èµ„æºæ¸…ç†** | è‡ªåŠ¨ | éœ€è¦æ˜¾å¼close |
| **breakå®‰å…¨** | âœ… å®Œå…¨å®‰å…¨ | âš ï¸ å¯èƒ½æ³„æ¼ |

**ç¤ºä¾‹å¯¹æ¯”**:

```go
// Channelæ–¹å¼
func ChannelExample() <-chan int {
    ch := make(chan int)
    go func() {
        defer close(ch)
        for i := 0; i < 10; i++ {
            ch <- i
        }
    }()
    return ch
}

// è¿­ä»£å™¨æ–¹å¼
func IteratorExample() iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := 0; i < 10; i++ {
            if !yield(i) {
                return
            }
        }
    }
}

// ä½¿ç”¨å¯¹æ¯”
func Compare() {
    // Channel: breakå¯èƒ½å¯¼è‡´goroutineæ³„æ¼
    for i := range ChannelExample() {
        if i > 5 {
            break  // goroutineç»§ç»­è¿è¡Œï¼
        }
    }
    
    // è¿­ä»£å™¨: breakå®Œå…¨å®‰å…¨
    for i := range IteratorExample() {
        if i > 5 {
            break  // å®‰å…¨åœæ­¢
        }
    }
}
```

### 8.2 vs Callback

| ç‰¹æ€§ | è¿­ä»£å™¨ | Callback |
|------|--------|----------|
| **æ§åˆ¶æµ** | ç›´è§‚çš„å¾ªç¯ | å›è°ƒåœ°ç‹± |
| **break/continue** | âœ… æ”¯æŒ | âŒ ä¸æ”¯æŒ |
| **é”™è¯¯å¤„ç†** | ç®€å• | å¤æ‚ |
| **å¯è¯»æ€§** | ä¼˜ç§€ | è¾ƒå·® |

**ç¤ºä¾‹å¯¹æ¯”**:

```go
// Callbackæ–¹å¼
func CallbackWalk(node *TreeNode, fn func(*TreeNode)) {
    if node == nil {
        return
    }
    fn(node)
    CallbackWalk(node.Left, fn)
    CallbackWalk(node.Right, fn)
}

// ä½¿ç”¨ï¼šéš¾ä»¥æ§åˆ¶
CallbackWalk(root, func(node *TreeNode) {
    if node.Value > 10 {
        // æ— æ³•breakï¼
    }
    fmt.Println(node.Value)
})

// è¿­ä»£å™¨æ–¹å¼
func IteratorWalk(node *TreeNode) iter.Seq[*TreeNode] {
    return func(yield func(*TreeNode) bool) {
        var walk func(*TreeNode) bool
        walk = func(n *TreeNode) bool {
            if n == nil {
                return true
            }
            if !yield(n) {
                return false
            }
            if !walk(n.Left) {
                return false
            }
            return walk(n.Right)
        }
        walk(node)
    }
}

// ä½¿ç”¨ï¼šå¯ä»¥break
for node := range IteratorWalk(root) {
    if node.Value > 10 {
        break  // å¯ä»¥breakï¼
    }
    fmt.Println(node.Value)
}
```

### 8.3 vs åˆ‡ç‰‡

| ç‰¹æ€§ | è¿­ä»£å™¨ | åˆ‡ç‰‡ |
|------|--------|------|
| **å†…å­˜** | æƒ°æ€§ï¼ŒæŒ‰éœ€ç”Ÿæˆ | é¢„åŠ è½½å…¨éƒ¨ |
| **æ€§èƒ½** | å¯¹å¤§æ•°æ®é›†ä¼˜ç§€ | å¯¹å°æ•°æ®é›†æ›´å¿« |
| **çµæ´»æ€§** | æ— é™åºåˆ— | æœ‰é™å¤§å° |
| **ç´¢å¼•è®¿é—®** | âŒ ä¸æ”¯æŒ | âœ… æ”¯æŒ |

**ç¤ºä¾‹å¯¹æ¯”**:

```go
// åˆ‡ç‰‡æ–¹å¼ï¼šå¿…é¡»é¢„åŠ è½½
func SliceRange(start, end int) []int {
    result := make([]int, end-start)
    for i := start; i < end; i++ {
        result[i-start] = i
    }
    return result  // å†…å­˜ä¸­æœ‰æ‰€æœ‰å…ƒç´ 
}

// è¿­ä»£å™¨æ–¹å¼ï¼šæƒ°æ€§ç”Ÿæˆ
func IteratorRange(start, end int) iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := start; i < end; i++ {
            if !yield(i) {
                return  // æŒ‰éœ€åœæ­¢
            }
        }
    }
}

// å¯¹æ¯”ï¼šå¤„ç†å¤§èŒƒå›´
func Compare() {
    // åˆ‡ç‰‡ï¼šç«‹å³åˆ†é…1000ä¸‡ä¸ªæ•´æ•°ï¼ˆçº¦40MBå†…å­˜ï¼‰
    slice := SliceRange(0, 10_000_000)
    for i, v := range slice {
        if i > 10 {
            break  // ä½†å·²ç»åˆ†é…äº†å…¨éƒ¨å†…å­˜
        }
        fmt.Println(v)
    }
    
    // è¿­ä»£å™¨ï¼šä»…ç”Ÿæˆéœ€è¦çš„ï¼ˆå‡ ä¹é›¶å†…å­˜ï¼‰
    for v := range IteratorRange(0, 10_000_000) {
        if v > 10 {
            break  // ä»…ç”Ÿæˆäº†11ä¸ªæ•°å­—
        }
        fmt.Println(v)
    }
}
```

### 8.4 é€‰æ‹©æŒ‡å—

**ä½¿ç”¨è¿­ä»£å™¨çš„åœºæ™¯**:

- âœ… å¤§æ•°æ®é›†æƒ°æ€§å¤„ç†
- âœ… æµå¼æ•°æ®å¤„ç†
- âœ… æ ‘/å›¾éå†
- âœ… æ— é™åºåˆ—
- âœ… éœ€è¦break/continueçš„å¤æ‚æ§åˆ¶æµ

**ä½¿ç”¨Channelçš„åœºæ™¯**:

- âœ… å¹¶å‘ç”Ÿäº§è€…/æ¶ˆè´¹è€…
- âœ… å¤šgoroutineåä½œ
- âœ… éœ€è¦ç¼“å†²çš„å¼‚æ­¥å¤„ç†

**ä½¿ç”¨åˆ‡ç‰‡çš„åœºæ™¯**:

- âœ… å°æ•°æ®é›†
- âœ… éœ€è¦éšæœºè®¿é—®
- âœ… éœ€è¦å¤šæ¬¡éå†
- âœ… éœ€è¦æ’åº/ä¿®æ”¹

---

## 9. æœ€ä½³å®è·µ

### 9.1 è®¾è®¡åŸåˆ™

**1. ä¿æŒç®€å•**:

```go
// âœ… å¥½ï¼šç®€å•ç›´æ¥
func Range(start, end int) iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := start; i < end; i++ {
            if !yield(i) {
                return
            }
        }
    }
}

// âŒ ä¸å¥½ï¼šè¿‡åº¦å¤æ‚
func Range(start, end int, opts ...Option) iter.Seq[int] {
    config := parseOptions(opts...)
    return func(yield func(int) bool) {
        // å¤æ‚çš„é…ç½®é€»è¾‘...
    }
}
```

**2. å°Šé‡yieldçš„è¿”å›å€¼**:

```go
// âœ… æ­£ç¡®ï¼šæ£€æŸ¥yieldè¿”å›å€¼
func Correct() iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := 0; i < 10; i++ {
            if !yield(i) {
                return  // ç”¨æˆ·breakï¼Œç«‹å³åœæ­¢
            }
        }
    }
}

// âŒ é”™è¯¯ï¼šå¿½ç•¥yieldè¿”å›å€¼
func Wrong() iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := 0; i < 10; i++ {
            yield(i)  // å¿½ç•¥è¿”å›å€¼ï¼Œæ— æ³•å“åº”break
        }
    }
}
```

**3. ç¡®ä¿èµ„æºæ¸…ç†**:

```go
// âœ… æ­£ç¡®ï¼šdeferç¡®ä¿èµ„æºé‡Šæ”¾
func ReadFile(path string) iter.Seq[string] {
    return func(yield func(string) bool) {
        file, err := os.Open(path)
        if err != nil {
            return
        }
        defer file.Close()  // ç¡®ä¿å…³é—­
        
        scanner := bufio.NewScanner(file)
        for scanner.Scan() {
            if !yield(scanner.Text()) {
                return  // deferä¼šæ‰§è¡Œ
            }
        }
    }
}
```

### 9.2 é”™è¯¯å¤„ç†

**æ¨¡å¼1: è¿”å›Resultç±»å‹**:

```go
type Result[T any] struct {
    Value T
    Err   error
}

func QueryRecords(db *sql.DB) iter.Seq[Result[Record]] {
    return func(yield func(Result[Record]) bool) {
        rows, err := db.Query("SELECT ...")
        if err != nil {
            yield(Result[Record]{Err: err})
            return
        }
        defer rows.Close()
        
        for rows.Next() {
            var r Record
            if err := rows.Scan(&r.ID, &r.Name); err != nil {
                yield(Result[Record]{Err: err})
                continue
            }
            if !yield(Result[Record]{Value: r}) {
                return
            }
        }
    }
}

// ä½¿ç”¨
for result := range QueryRecords(db) {
    if result.Err != nil {
        log.Println("Error:", result.Err)
        continue
    }
    // å¤„ç†result.Value
}
```

**æ¨¡å¼2: åˆ†ç¦»é”™è¯¯è¿­ä»£å™¨**:

```go
type Iterator[T any] struct {
    seq iter.Seq[T]
    err error
}

func (it *Iterator[T]) All() iter.Seq[T] {
    return it.seq
}

func (it *Iterator[T]) Err() error {
    return it.err
}

func NewQueryIterator(db *sql.DB) *Iterator[Record] {
    it := &Iterator[Record]{}
    it.seq = func(yield func(Record) bool) {
        rows, err := db.Query("SELECT ...")
        if err != nil {
            it.err = err
            return
        }
        defer rows.Close()
        
        for rows.Next() {
            var r Record
            if err := rows.Scan(&r.ID, &r.Name); err != nil {
                it.err = err
                return
            }
            if !yield(r) {
                return
            }
        }
    }
    return it
}

// ä½¿ç”¨
it := NewQueryIterator(db)
for record := range it.All() {
    // å¤„ç†record
}
if err := it.Err(); err != nil {
    log.Fatal(err)
}
```

### 9.3 å¹¶å‘å®‰å…¨

**è¿­ä»£å™¨æœ¬èº«ä¸æ˜¯å¹¶å‘å®‰å…¨çš„**:

```go
// âŒ ä¸å®‰å…¨ï¼šå¹¶å‘è®¿é—®
func Unsafe() {
    seq := Range(1, 1000)
    
    // ä¸è¦è¿™æ ·åšï¼
    go func() {
        for v := range seq {
            fmt.Println(v)
        }
    }()
    
    go func() {
        for v := range seq {  // ç«æ€æ¡ä»¶ï¼
            fmt.Println(v)
        }
    }()
}

// âœ… å®‰å…¨ï¼šæ¯ä¸ªgoroutineä½¿ç”¨ç‹¬ç«‹è¿­ä»£å™¨
func Safe() {
    go func() {
        for v := range Range(1, 500) {
            fmt.Println(v)
        }
    }()
    
    go func() {
        for v := range Range(500, 1000) {
            fmt.Println(v)
        }
    }()
}
```

### 9.4 æ€§èƒ½ä¼˜åŒ–

**1. é¿å…ä¸å¿…è¦çš„åˆ†é…**:

```go
// âŒ æ¯æ¬¡è¿­ä»£éƒ½åˆ†é…
func Bad() iter.Seq[string] {
    return func(yield func(string) bool) {
        for i := 0; i < 100; i++ {
            s := fmt.Sprintf("item-%d", i)  // åˆ†é…
            if !yield(s) {
                return
            }
        }
    }
}

// âœ… å¤ç”¨buffer
func Good() iter.Seq[string] {
    return func(yield func(string) bool) {
        var builder strings.Builder
        for i := 0; i < 100; i++ {
            builder.Reset()
            builder.WriteString("item-")
            builder.WriteString(strconv.Itoa(i))
            if !yield(builder.String()) {
                return
            }
        }
    }
}
```

**2. ä½¿ç”¨ç¼“å­˜**:

```go
// âœ… ç¼“å­˜è®¡ç®—ç»“æœ
func Fibonacci(max int) iter.Seq[int] {
    return func(yield func(int) bool) {
        cache := make(map[int]int)
        
        var fib func(n int) int
        fib = func(n int) int {
            if n <= 1 {
                return n
            }
            if v, ok := cache[n]; ok {
                return v
            }
            result := fib(n-1) + fib(n-2)
            cache[n] = result
            return result
        }
        
        for i := 0; fib(i) <= max; i++ {
            if !yield(fib(i)) {
                return
            }
        }
    }
}
```

---

## 10. å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ

**é™·é˜±1: å¿˜è®°æ£€æŸ¥yieldè¿”å›å€¼**:

```go
// âŒ é”™è¯¯
func Wrong() iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := 0; i < 1000000; i++ {
            yield(i)  // å¿½ç•¥è¿”å›å€¼
        }
    }
}

// âœ… æ­£ç¡®
func Correct() iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := 0; i < 1000000; i++ {
            if !yield(i) {  // æ£€æŸ¥è¿”å›å€¼
                return
            }
        }
    }
}
```

**é™·é˜±2: åœ¨è¿­ä»£å™¨å¤–éƒ¨ä¿®æ”¹çŠ¶æ€**:

```go
// âŒ å±é™©
func Dangerous() iter.Seq[int] {
    counter := 0  // å¤–éƒ¨çŠ¶æ€
    return func(yield func(int) bool) {
        for i := 0; i < 10; i++ {
            counter++  // ä¿®æ”¹å¤–éƒ¨çŠ¶æ€
            if !yield(counter) {
                return
            }
        }
    }
}

// å¤šæ¬¡ä½¿ç”¨ä¼šäº§ç”Ÿæ„å¤–ç»“æœ
seq := Dangerous()
for v := range seq {
    fmt.Println(v)  // 1-10
}
for v := range seq {
    fmt.Println(v)  // 11-20 ï¼
}

// âœ… å®‰å…¨ï¼šæ¯æ¬¡åˆ›å»ºæ–°è¿­ä»£å™¨
func Safe() iter.Seq[int] {
    return func(yield func(int) bool) {
        counter := 0  // å†…éƒ¨çŠ¶æ€
        for i := 0; i < 10; i++ {
            counter++
            if !yield(counter) {
                return
            }
        }
    }
}
```

**é™·é˜±3: èµ„æºæœªæ¸…ç†**:

```go
// âŒ å±é™©
func Leaky(path string) iter.Seq[string] {
    file, _ := os.Open(path)  // æ–‡ä»¶å¯èƒ½æ³„æ¼
    return func(yield func(string) bool) {
        scanner := bufio.NewScanner(file)
        for scanner.Scan() {
            if !yield(scanner.Text()) {
                return  // æ–‡ä»¶æœªå…³é—­ï¼
            }
        }
        file.Close()  // å¦‚æœbreakï¼Œä¸ä¼šæ‰§è¡Œ
    }
}

// âœ… å®‰å…¨
func Safe(path string) iter.Seq[string] {
    return func(yield func(string) bool) {
        file, _ := os.Open(path)
        defer file.Close()  // ç¡®ä¿å…³é—­
        
        scanner := bufio.NewScanner(file)
        for scanner.Scan() {
            if !yield(scanner.Text()) {
                return  // deferä¼šæ‰§è¡Œ
            }
        }
    }
}
```

---

## 11. è¿ç§»æŒ‡å—

### 11.1 ä»Channelè¿ç§»

**æ­¥éª¤**:

1. è¯†åˆ«å¯ä»¥è½¬æ¢çš„Channelä½¿ç”¨
2. å°†goroutine+channelæ¨¡å¼æ”¹ä¸ºè¿­ä»£å™¨å‡½æ•°
3. ç¡®ä¿èµ„æºæ­£ç¡®æ¸…ç†
4. æµ‹è¯•æ€§èƒ½æ”¹è¿›

**ç¤ºä¾‹**:

```go
// åŸå§‹Channelä»£ç 
func OldWay() <-chan int {
    ch := make(chan int, 10)
    go func() {
        defer close(ch)
        for i := 0; i < 100; i++ {
            ch <- i
        }
    }()
    return ch
}

// è¿ç§»åçš„è¿­ä»£å™¨ä»£ç 
func NewWay() iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := 0; i < 100; i++ {
            if !yield(i) {
                return
            }
        }
    }
}
```

### 11.2 ä»Callbackè¿ç§»

**æ­¥éª¤**:

1. è¯†åˆ«callbackæ¨¡å¼çš„ä»£ç 
2. å°†callbackå‚æ•°æ”¹ä¸ºyieldå‡½æ•°
3. æ·»åŠ yieldè¿”å›å€¼æ£€æŸ¥
4. æµ‹è¯•æ§åˆ¶æµæ­£ç¡®æ€§

**ç¤ºä¾‹**:

```go
// åŸå§‹Callbackä»£ç 
func OldWalk(node *TreeNode, fn func(*TreeNode)) {
    if node == nil {
        return
    }
    fn(node)
    OldWalk(node.Left, fn)
    OldWalk(node.Right, fn)
}

// è¿ç§»åçš„è¿­ä»£å™¨ä»£ç 
func NewWalk(node *TreeNode) iter.Seq[*TreeNode] {
    return func(yield func(*TreeNode) bool) {
        var walk func(*TreeNode) bool
        walk = func(n *TreeNode) bool {
            if n == nil {
                return true
            }
            if !yield(n) {
                return false
            }
            if !walk(n.Left) {
                return false
            }
            return walk(n.Right)
        }
        walk(node)
    }
}
```

---

## 12. å‚è€ƒèµ„æº

### å®˜æ–¹æ–‡æ¡£

- [Go 1.23 Release Notes - Iterators](https://go.dev/doc/go1.23#iterators)
- [iter Package Documentation](https://pkg.go.dev/iter)
- [Range over function types Proposal](https://go.dev/issue/61405)

### æ ‡å‡†åº“ç¤ºä¾‹

- [slices Package](https://pkg.go.dev/slices) - All, Values, Backwardå‡½æ•°
- [maps Package](https://pkg.go.dev/maps) - All, Keys, Valueså‡½æ•°

### åšå®¢æ–‡ç« 

- [Go Blog - Range over functions](https://go.dev/blog/range-functions)
- [Iterators in Go](https://go.dev/wiki/RangefuncExperiment)

### å¼€æºé¡¹ç›®

- [samber/lo](https://github.com/samber/lo) - ä½¿ç”¨è¿­ä»£å™¨çš„å·¥å…·åº“
- [go-functional](https://github.com/BooleanCat/go-functional) - å‡½æ•°å¼ç¼–ç¨‹å·¥å…·

### æ€§èƒ½åˆ†æ

- [Benchmark Results](https://github.com/golang/go/issues/61405#issuecomment-)
- [Iterator Performance Discussion](https://github.com/golang/go/discussions/)

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ24æ—¥  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.23+

**è´¡çŒ®è€…**: æ¬¢è¿æäº¤Issueå’ŒPRæ”¹è¿›æœ¬æ–‡æ¡£
