# Go 1.21 标准库增强详解

> **引入版本**: Go 1.21  
> **状态**: ✅ 稳定  
> **难度**: ⭐⭐⭐  
> **标签**: #log/slog #slices #maps #cmp


## 📋 目录

- [1. 📋 概述](#-概述)
- [2. 🎯 log/slog - 结构化日志](#-logslog---结构化日志)
- [3. 🎯 slices 包 - 泛型切片操作](#-slices-包---泛型切片操作)
- [4. 🎯 maps 包 - 泛型映射操作](#-maps-包---泛型映射操作)
- [5. 🎯 cmp 包 - 比较工具](#-cmp-包---比较工具)
- [6. 💡 最佳实践](#-最佳实践)
- [7. 📚 扩展阅读](#-扩展阅读)

---

## 📋 概述

Go 1.21 在标准库方面进行了重大更新，引入了三个新包和一个革命性的日志包：

- **`log/slog`** - 结构化日志标准库
- **`slices`** - 泛型切片操作
- **`maps`** - 泛型映射操作  
- **`cmp`** - 比较工具包

---

## 🎯 log/slog - 结构化日志

### 为什么需要 slog？

传统 `log` 包的局限：

```go
// 传统 log：难以解析和查询
log.Printf("User %s logged in from %s with status %d", username, ip, status)
// 输出: 2025/10/24 10:00:00 User alice logged in from 192.168.1.1 with status 200
```

`slog` 的优势：

```go
// slog：结构化，易于解析
slog.Info("user logged in",
    "username", username,
    "ip", ip,
    "status", status,
)
// 输出（JSON）: {"time":"2025-10-24T10:00:00Z","level":"INFO","msg":"user logged in","username":"alice","ip":"192.168.1.1","status":200}
```

### 基本用法

#### 1. 默认 Logger

```go
package main

import (
    "log/slog"
)

func main() {
    // 使用默认 logger
    slog.Info("application started", "version", "1.0.0", "port", 8080)
    slog.Warn("high memory usage", "usage", "85%")
    slog.Error("database connection failed", "error", "connection refused")
    
    // Debug 级别（默认不显示）
    slog.Debug("processing request", "user_id", 123)
}
```

输出（默认文本格式）：

```text
2025/10/24 10:00:00 INFO application started version=1.0.0 port=8080
2025/10/24 10:00:01 WARN high memory usage usage=85%
2025/10/24 10:00:02 ERROR database connection failed error="connection refused"
```

#### 2. JSON Handler

```go
package main

import (
    "log/slog"
    "os"
)

func main() {
    // 创建 JSON handler
    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
    
    logger.Info("user action",
        slog.String("user", "alice"),
        slog.Int("user_id", 123),
        slog.Float64("amount", 99.99),
    )
}
```

输出：

```json
{"time":"2025-10-24T10:00:00Z","level":"INFO","msg":"user action","user":"alice","user_id":123,"amount":99.99}
```

#### 3. 自定义 Handler 配置

```go
package main

import (
    "log/slog"
    "os"
)

func main() {
    opts := &slog.HandlerOptions{
        Level: slog.LevelDebug,  // 设置最低日志级别
        AddSource: true,          // 添加源文件信息
        ReplaceAttr: func(groups []string, a slog.Attr) slog.Attr {
            // 自定义属性
            if a.Key == slog.TimeKey {
                // 自定义时间格式
                return slog.String("timestamp", a.Value.Time().Format("2006-01-02 15:04:05"))
            }
            return a
        },
    }
    
    logger := slog.New(slog.NewJSONHandler(os.Stdout, opts))
    logger.Debug("debug message", "detail", "some info")
}
```

### 高级特性

#### 1. With() - 添加上下文字段

```go
package main

import (
    "log/slog"
)

func main() {
    // 基础 logger
    baseLogger := slog.Default()
    
    // 为特定模块添加上下文
    dbLogger := baseLogger.With("module", "database", "connection", "primary")
    dbLogger.Info("query executed", "duration", "150ms")
    // 输出: ... module=database connection=primary duration=150ms
    
    apiLogger := baseLogger.With("module", "api", "version", "v1")
    apiLogger.Info("request processed", "status", 200)
    // 输出: ... module=api version=v1 status=200
}
```

#### 2. WithGroup() - 字段分组

```go
package main

import (
    "log/slog"
    "os"
)

func main() {
    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
    
    logger.Info("request received",
        slog.Group("http",
            slog.String("method", "GET"),
            slog.String("path", "/api/users"),
            slog.Int("status", 200),
        ),
        slog.Group("client",
            slog.String("ip", "192.168.1.1"),
            slog.String("user_agent", "Mozilla/5.0"),
        ),
    )
}
```

输出：

```json
{
  "time": "2025-10-24T10:00:00Z",
  "level": "INFO",
  "msg": "request received",
  "http": {
    "method": "GET",
    "path": "/api/users",
    "status": 200
  },
  "client": {
    "ip": "192.168.1.1",
    "user_agent": "Mozilla/5.0"
  }
}
```

#### 3. LogValuer - 自定义类型日志

```go
package main

import (
    "fmt"
    "log/slog"
)

type User struct {
    ID       int
    Username string
    Email    string
    Password string  // 敏感信息
}

// 实现 LogValuer 接口
func (u User) LogValue() slog.Value {
    return slog.GroupValue(
        slog.Int("id", u.ID),
        slog.String("username", u.Username),
        // 不记录 Email 和 Password
    )
}

func main() {
    user := User{
        ID:       123,
        Username: "alice",
        Email:    "alice@example.com",
        Password: "secret123",
    }
    
    slog.Info("user login", "user", user)
    // 输出: ... user.id=123 user.username=alice
    // Email 和 Password 不会被记录
}
```

### 实战案例：Web 应用日志

```go
package main

import (
    "context"
    "log/slog"
    "net/http"
    "os"
    "time"
)

// Logger 中间件
func LoggerMiddleware(logger *slog.Logger) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()
            
            // 创建带请求 ID 的 logger
            requestID := generateRequestID()
            reqLogger := logger.With(
                "request_id", requestID,
                "method", r.Method,
                "path", r.URL.Path,
            )
            
            // 将 logger 放入 context
            ctx := context.WithValue(r.Context(), "logger", reqLogger)
            
            // 记录请求开始
            reqLogger.Info("request started", "remote_addr", r.RemoteAddr)
            
            // 处理请求
            next.ServeHTTP(w, r.WithContext(ctx))
            
            // 记录请求完成
            duration := time.Since(start)
            reqLogger.Info("request completed",
                "duration_ms", duration.Milliseconds(),
            )
        })
    }
}

func generateRequestID() string {
    return fmt.Sprintf("%d", time.Now().UnixNano())
}

// 从 context 获取 logger
func GetLogger(ctx context.Context) *slog.Logger {
    if logger, ok := ctx.Value("logger").(*slog.Logger); ok {
        return logger
    }
    return slog.Default()
}

func main() {
    // 创建 logger
    logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
        Level: slog.LevelInfo,
    }))
    
    mux := http.NewServeMux()
    
    mux.HandleFunc("/api/users", func(w http.ResponseWriter, r *http.Request) {
        logger := GetLogger(r.Context())
        
        // 业务逻辑
        logger.Info("fetching users")
        
        w.Header().Set("Content-Type", "application/json")
        w.Write([]byte(`{"users": []}`))
    })
    
    // 应用中间件
    handler := LoggerMiddleware(logger)(mux)
    
    logger.Info("server starting", "port", 8080)
    http.ListenAndServe(":8080", handler)
}
```

---

## 🎯 slices 包 - 泛型切片操作

### 常用函数

#### 1. 排序相关

```go
package main

import (
    "fmt"
    "slices"
)

func main() {
    s := []int{5, 2, 8, 1, 9}
    
    // 排序
    slices.Sort(s)
    fmt.Println(s)  // [1 2 5 8 9]
    
    // 检查是否已排序
    fmt.Println(slices.IsSorted(s))  // true
    
    // 自定义排序
    people := []string{"Alice", "bob", "Charlie"}
    slices.SortFunc(people, func(a, b string) int {
        return strings.Compare(strings.ToLower(a), strings.ToLower(b))
    })
    fmt.Println(people)  // [Alice bob Charlie]
}
```

#### 2. 查找相关

```go
package main

import (
    "fmt"
    "slices"
)

func main() {
    s := []int{1, 2, 3, 4, 5}
    
    // 包含检查
    fmt.Println(slices.Contains(s, 3))  // true
    
    // 查找索引
    fmt.Println(slices.Index(s, 3))     // 2
    fmt.Println(slices.Index(s, 10))    // -1
    
    // 二分查找（需要已排序）
    idx, found := slices.BinarySearch(s, 3)
    fmt.Println(idx, found)  // 2 true
    
    // 查找满足条件的元素
    idx = slices.IndexFunc(s, func(n int) bool {
        return n > 3
    })
    fmt.Println(idx)  // 3 (第一个 > 3 的元素索引)
}
```

#### 3. 操作相关

```go
package main

import (
    "fmt"
    "slices"
)

func main() {
    s := []int{1, 2, 2, 3, 3, 3, 4}
    
    // 去重（需要已排序）
    unique := slices.Compact(s)
    fmt.Println(unique)  // [1 2 3 4]
    
    // 克隆
    s2 := slices.Clone(s)
    fmt.Println(s2)
    
    // 比较
    s3 := []int{1, 2, 2, 3, 3, 3, 4}
    fmt.Println(slices.Equal(s, s3))  // true
    
    // 反转
    slices.Reverse(s)
    fmt.Println(s)  // [4 3 3 3 2 2 1]
}
```

#### 4. 高级操作

```go
package main

import (
    "fmt"
    "slices"
)

func main() {
    // 删除元素
    s := []int{1, 2, 3, 4, 5}
    s = slices.Delete(s, 2, 4)  // 删除索引 2-3 的元素
    fmt.Println(s)  // [1 2 5]
    
    // 插入元素
    s = []int{1, 2, 5}
    s = slices.Insert(s, 2, 3, 4)  // 在索引 2 插入 3, 4
    fmt.Println(s)  // [1 2 3 4 5]
    
    // 替换
    s = []int{1, 2, 3, 4, 5}
    s = slices.Replace(s, 1, 3, 10, 20)  // 替换索引 1-2 为 10, 20
    fmt.Println(s)  // [1 10 20 4 5]
    
    // 增长容量
    s = make([]int, 0, 5)
    s = slices.Grow(s, 10)  // 确保至少还能容纳 10 个元素
    fmt.Println(cap(s))     // >= 10
    
    // 裁剪多余容量
    s = make([]int, 5, 20)
    s = slices.Clip(s)
    fmt.Println(len(s), cap(s))  // 5 5
}
```

---

## 🎯 maps 包 - 泛型映射操作

### 常用函数1

```go
package main

import (
    "fmt"
    "maps"
)

func main() {
    m1 := map[string]int{"a": 1, "b": 2}
    m2 := map[string]int{"b": 3, "c": 4}
    
    // 克隆
    m3 := maps.Clone(m1)
    fmt.Println(m3)  // map[a:1 b:2]
    
    // 复制（合并）
    maps.Copy(m3, m2)
    fmt.Println(m3)  // map[a:1 b:3 c:4]
    
    // 比较
    fmt.Println(maps.Equal(m1, m2))  // false
    
    // 删除满足条件的键值对
    maps.DeleteFunc(m3, func(k string, v int) bool {
        return v < 3
    })
    fmt.Println(m3)  // map[b:3 c:4]
}
```

---

## 🎯 cmp 包 - 比较工具

### 基本用法1

```go
package main

import (
    "cmp"
    "fmt"
    "slices"
)

func main() {
    // cmp.Compare: 三向比较
    fmt.Println(cmp.Compare(1, 2))   // -1 (1 < 2)
    fmt.Println(cmp.Compare(2, 2))   // 0  (2 == 2)
    fmt.Println(cmp.Compare(3, 2))   // 1  (3 > 2)
    
    // cmp.Less: 简化版
    fmt.Println(cmp.Less(1, 2))      // true
    
    // 与 slices 结合
    type Person struct {
        Name string
        Age  int
    }
    
    people := []Person{
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 35},
    }
    
    // 按年龄排序
    slices.SortFunc(people, func(a, b Person) int {
        return cmp.Compare(a.Age, b.Age)
    })
    fmt.Println(people)
    // [{Bob 25} {Alice 30} {Charlie 35}]
    
    // 使用 cmp.Or 实现多字段排序
    slices.SortFunc(people, func(a, b Person) int {
        return cmp.Or(
            cmp.Compare(a.Age, b.Age),          // 首先按年龄
            cmp.Compare(a.Name, b.Name),        // 年龄相同按名字
        )
    })
}
```

---

## 💡 最佳实践

### 1. slog 使用建议

✅ **推荐**：

```go
// 使用结构化字段
slog.Info("user login", "user_id", 123, "ip", "192.168.1.1")

// 使用 With() 添加上下文
logger := slog.Default().With("service", "api", "version", "v1")
```

❌ **不推荐**：

```go
// 不要在消息中插入变量
slog.Info(fmt.Sprintf("user %d login from %s", userID, ip))
```

### 2. slices 性能优化

```go
// ✅ 使用 slices.Grow 预分配
s := make([]int, 0)
s = slices.Grow(s, 1000)  // 预分配容量

// ❌ 频繁 append 导致多次扩容
s := make([]int, 0)
for i := 0; i < 1000; i++ {
    s = append(s, i)
}
```

---

## 📚 扩展阅读

- [log/slog 包文档](https://pkg.go.dev/log/slog)
- [slices 包文档](https://pkg.go.dev/slices)
- [maps 包文档](https://pkg.go.dev/maps)
- [cmp 包文档](https://pkg.go.dev/cmp)
- [结构化日志最佳实践](https://go.dev/blog/slog)

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025年10月24日  
**文档状态**: ✅ 完成  
**适用版本**: Go 1.21+
