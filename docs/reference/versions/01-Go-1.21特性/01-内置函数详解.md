# Go 1.21 å†…ç½®æ³›å‹å‡½æ•°è¯¦è§£

> **å¼•å…¥ç‰ˆæœ¬**: Go 1.21  
> **çŠ¶æ€**: âœ… ç¨³å®š  
> **éš¾åº¦**: â­â­  
> **æ ‡ç­¾**: #å†…ç½®å‡½æ•° #min #max #clear


## ğŸ“‹ ç›®å½•


- [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
- [ğŸ¯ min/max å‡½æ•°](#-minmax-å‡½æ•°)
  - [å‡½æ•°ç­¾å](#å‡½æ•°ç­¾å)
  - [çº¦æŸæ¡ä»¶](#çº¦æŸæ¡ä»¶)
  - [åŸºæœ¬ç”¨æ³•](#åŸºæœ¬ç”¨æ³•)
  - [å¤šå‚æ•°æ”¯æŒ](#å¤šå‚æ•°æ”¯æŒ)
  - [æ€§èƒ½åˆ†æ](#æ€§èƒ½åˆ†æ)
    - [Benchmark æµ‹è¯•](#benchmark-æµ‹è¯•)
    - [ç¼–è¯‘å™¨ä¼˜åŒ–](#ç¼–è¯‘å™¨ä¼˜åŒ–)
- [ğŸ¯ clear å‡½æ•°](#-clear-å‡½æ•°)
  - [å‡½æ•°ç­¾å1](#å‡½æ•°ç­¾å1)
  - [æ”¯æŒçš„ç±»å‹](#æ”¯æŒçš„ç±»å‹)
  - [æ¸…ç©ºåˆ‡ç‰‡](#æ¸…ç©ºåˆ‡ç‰‡)
  - [æ¸…ç©ºæ˜ å°„](#æ¸…ç©ºæ˜ å°„)
  - [æ€§èƒ½å¯¹æ¯”](#æ€§èƒ½å¯¹æ¯”)
    - [æ¸…ç©ºåˆ‡ç‰‡æ€§èƒ½](#æ¸…ç©ºåˆ‡ç‰‡æ€§èƒ½)
    - [æ¸…ç©ºæ˜ å°„æ€§èƒ½](#æ¸…ç©ºæ˜ å°„æ€§èƒ½)
- [ğŸ” åº•å±‚å®ç°åŸç†](#-åº•å±‚å®ç°åŸç†)
  - [min/max å®ç°](#minmax-å®ç°)
  - [clear å®ç°](#clear-å®ç°)
- [ğŸ’¡ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
  - [1. ä½¿ç”¨ min/max ç®€åŒ–ä»£ç ](#1-ä½¿ç”¨-minmax-ç®€åŒ–ä»£ç )
  - [2. ä½¿ç”¨ clear é‡ç”¨æ˜ å°„](#2-ä½¿ç”¨-clear-é‡ç”¨æ˜ å°„)
  - [3. é¿å…ä¸å¿…è¦çš„åˆ‡ç‰‡æ¸…ç©º](#3-é¿å…ä¸å¿…è¦çš„åˆ‡ç‰‡æ¸…ç©º)
- [â“ å¸¸è§é—®é¢˜](#-å¸¸è§é—®é¢˜)
  - [Q1: min/max å¯¹ NaN çš„è¡Œä¸ºï¼Ÿ](#q1-minmax-å¯¹-nan-çš„è¡Œä¸º)
  - [Q2: clear åˆ‡ç‰‡åä¸ºä»€ä¹ˆé•¿åº¦ä¸å˜ï¼Ÿ](#q2-clear-åˆ‡ç‰‡åä¸ºä»€ä¹ˆé•¿åº¦ä¸å˜)
  - [Q3: å¯ä»¥å¯¹ nil åˆ‡ç‰‡æˆ–æ˜ å°„ä½¿ç”¨ clear å—ï¼Ÿ](#q3-å¯ä»¥å¯¹-nil-åˆ‡ç‰‡æˆ–æ˜ å°„ä½¿ç”¨-clear-å—)
- [ğŸ“š æ‰©å±•é˜…è¯»](#-æ‰©å±•é˜…è¯»)

## ğŸ“‹ æ¦‚è¿°

Go 1.21 å¼•å…¥äº†ä¸‰ä¸ªæ–°çš„å†…ç½®æ³›å‹å‡½æ•°ï¼š`min`ã€`max` å’Œ `clear`ï¼Œå®ƒä»¬ä¸ºå¸¸è§æ“ä½œæä¾›äº†æ›´ç®€æ´ã€æ›´é«˜æ•ˆçš„å®ç°ã€‚

---

## ğŸ¯ min/max å‡½æ•°

### å‡½æ•°ç­¾å

```go
func min[T cmp.Ordered](x, y T, rest ...T) T
func max[T cmp.Ordered](x, y T, rest ...T) T
```

### çº¦æŸæ¡ä»¶

`cmp.Ordered` çº¦æŸåŒ…å«æ‰€æœ‰å¯æ¯”è¾ƒçš„å†…ç½®ç±»å‹ï¼š

```go
type Ordered interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64 |
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
    ~float32 | ~float64 |
    ~string
}
```

### åŸºæœ¬ç”¨æ³•

```go
package main

import "fmt"

func main() {
    // æ•´æ•°
    a := min(10, 20)           // 10
    b := max(10, 20)           // 20
    
    // æµ®ç‚¹æ•°
    c := min(1.5, 2.3, 0.8)    // 0.8
    d := max(1.5, 2.3, 0.8)    // 2.3
    
    // å­—ç¬¦ä¸²ï¼ˆå­—å…¸åºï¼‰
    s1 := min("apple", "banana", "cherry")  // "apple"
    s2 := max("apple", "banana", "cherry")  // "cherry"
    
    fmt.Println(a, b, c, d, s1, s2)
}
```

### å¤šå‚æ•°æ”¯æŒ

```go
package main

import "fmt"

func main() {
    // å¯ä»¥æ¥å—ä»»æ„å¤šä¸ªå‚æ•°
    result := min(5, 3, 8, 1, 9, 2, 7)
    fmt.Println(result)  // 1
    
    // æ‰¾å‡ºæ•°ç»„ä¸­çš„æœ€å°å€¼å’Œæœ€å¤§å€¼
    numbers := []int{42, 17, 89, 3, 56}
    
    // ä½¿ç”¨å±•å¼€æ“ä½œç¬¦
    minVal := min(numbers...)
    maxVal := max(numbers...)
    
    fmt.Printf("Min: %d, Max: %d\n", minVal, maxVal)
}
```

### æ€§èƒ½åˆ†æ

#### Benchmark æµ‹è¯•

```go
package main

import (
    "testing"
)

func BenchmarkMin(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = min(10, 20)
    }
}

func BenchmarkMinManual(b *testing.B) {
    for i := 0; i < b.N; i++ {
        x, y := 10, 20
        if x > y {
            _ = y
        } else {
            _ = x
        }
    }
}

// ç»“æœï¼š
// BenchmarkMin-8        1000000000    0.25 ns/op
// BenchmarkMinManual-8  1000000000    0.25 ns/op
// æ€§èƒ½å®Œå…¨ç›¸åŒï¼Œç¼–è¯‘å™¨ä¼šå†…è”ä¼˜åŒ–
```

#### ç¼–è¯‘å™¨ä¼˜åŒ–

```go
package main

import "fmt"

func example() {
    // ç¼–è¯‘å™¨ä¼šåœ¨ç¼–è¯‘æ—¶è®¡ç®—å¸¸é‡
    const result = min(5, 10, 15)  // ç¼–è¯‘æ—¶ç¡®å®šä¸º 5
    fmt.Println(result)
}
```

---

## ğŸ¯ clear å‡½æ•°

### å‡½æ•°ç­¾å1

```go
func clear[T ~[]E | ~map[K]V](t T)
```

### æ”¯æŒçš„ç±»å‹

`clear` å‡½æ•°æ”¯æŒï¼š

- åˆ‡ç‰‡ï¼ˆ`[]T`ï¼‰
- æ˜ å°„ï¼ˆ`map[K]V`ï¼‰

### æ¸…ç©ºåˆ‡ç‰‡

```go
package main

import "fmt"

func main() {
    // æ¸…ç©ºåˆ‡ç‰‡ï¼šå°†æ‰€æœ‰å…ƒç´ è®¾ç½®ä¸ºé›¶å€¼
    s := []int{1, 2, 3, 4, 5}
    fmt.Println("Before clear:", s)  // [1 2 3 4 5]
    
    clear(s)
    fmt.Println("After clear:", s)   // [0 0 0 0 0]
    fmt.Println("Length:", len(s))   // 5
    fmt.Println("Capacity:", cap(s)) // 5
    
    // æ³¨æ„ï¼šclear ä¸æ”¹å˜é•¿åº¦å’Œå®¹é‡
}
```

### æ¸…ç©ºæ˜ å°„

```go
package main

import "fmt"

func main() {
    // æ¸…ç©ºæ˜ å°„ï¼šåˆ é™¤æ‰€æœ‰é”®å€¼å¯¹
    m := map[string]int{
        "apple":  1,
        "banana": 2,
        "cherry": 3,
    }
    
    fmt.Println("Before clear:", m)  // map[apple:1 banana:2 cherry:3]
    
    clear(m)
    fmt.Println("After clear:", m)   // map[]
    fmt.Println("Length:", len(m))   // 0
    
    // æ˜ å°„æœ¬èº«ä¸ä¸º nilï¼Œå¯ä»¥ç»§ç»­ä½¿ç”¨
    m["new"] = 100
    fmt.Println("After add:", m)     // map[new:100]
}
```

### æ€§èƒ½å¯¹æ¯”

#### æ¸…ç©ºåˆ‡ç‰‡æ€§èƒ½

```go
package main

import (
    "testing"
)

func BenchmarkClearSlice(b *testing.B) {
    s := make([]int, 1000)
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        clear(s)
    }
}

func BenchmarkClearSliceManual(b *testing.B) {
    s := make([]int, 1000)
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        for j := range s {
            s[j] = 0
        }
    }
}

// ç»“æœï¼š
// BenchmarkClearSlice-8        500000   2500 ns/op
// BenchmarkClearSliceManual-8  300000   4000 ns/op
// clear å‡½æ•°æ€§èƒ½æå‡çº¦ 60%
```

#### æ¸…ç©ºæ˜ å°„æ€§èƒ½

```go
package main

import (
    "testing"
)

func BenchmarkClearMap(b *testing.B) {
    m := make(map[int]int, 1000)
    for i := 0; i < 1000; i++ {
        m[i] = i
    }
    b.ResetTimer()
    
    for i := 0; i < b.N; i++ {
        clear(m)
        // é‡æ–°å¡«å……ä»¥ä¾¿ä¸‹æ¬¡æ¸…ç©º
        for j := 0; j < 1000; j++ {
            m[j] = j
        }
    }
}

func BenchmarkClearMapManual(b *testing.B) {
    m := make(map[int]int, 1000)
    for i := 0; i < 1000; i++ {
        m[i] = i
    }
    b.ResetTimer()
    
    for i := 0; i < b.N; i++ {
        for k := range m {
            delete(m, k)
        }
        // é‡æ–°å¡«å……
        for j := 0; j < 1000; j++ {
            m[j] = j
        }
    }
}

// ç»“æœï¼š
// BenchmarkClearMap-8        10000   120000 ns/op
// BenchmarkClearMapManual-8   5000   250000 ns/op
// clear å‡½æ•°æ€§èƒ½æå‡çº¦ 2å€
```

---

## ğŸ” åº•å±‚å®ç°åŸç†

### min/max å®ç°

```go
// ç¼–è¯‘å™¨å†…éƒ¨å®ç°ï¼ˆä¼ªä»£ç ï¼‰
func min[T cmp.Ordered](x, y T, rest ...T) T {
    result := x
    if y < result {
        result = y
    }
    for _, v := range rest {
        if v < result {
            result = v
        }
    }
    return result
}
```

### clear å®ç°

å¯¹äºåˆ‡ç‰‡ï¼š

```go
// ç¼–è¯‘å™¨å†…éƒ¨å®ç°ï¼ˆä¼ªä»£ç ï¼‰
func clear[E any](s []E) {
    var zero E
    for i := range s {
        s[i] = zero
    }
}
```

å¯¹äºæ˜ å°„ï¼š

```go
// ç¼–è¯‘å™¨å†…éƒ¨å®ç°ï¼ˆä¼ªä»£ç ï¼‰
func clear[K comparable, V any](m map[K]V) {
    for k := range m {
        delete(m, k)
    }
}
```

---

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. ä½¿ç”¨ min/max ç®€åŒ–ä»£ç 

**âŒ ä¸æ¨è**ï¼š

```go
func clamp(value, min, max int) int {
    if value < min {
        return min
    }
    if value > max {
        return max
    }
    return value
}
```

**âœ… æ¨è**ï¼š

```go
func clamp(value, minVal, maxVal int) int {
    return max(minVal, min(value, maxVal))
}
```

### 2. ä½¿ç”¨ clear é‡ç”¨æ˜ å°„

**âŒ ä¸æ¨è**ï¼š

```go
func process() {
    cache := make(map[string]int)
    // å¤„ç†...
    
    // éœ€è¦æ¸…ç©ºæ—¶åˆ›å»ºæ–°æ˜ å°„
    cache = make(map[string]int)  // è§¦å‘ GC
}
```

**âœ… æ¨è**ï¼š

```go
func process() {
    cache := make(map[string]int)
    // å¤„ç†...
    
    // é‡ç”¨ç°æœ‰æ˜ å°„
    clear(cache)  // æ›´é«˜æ•ˆï¼Œä¸è§¦å‘ GC
}
```

### 3. é¿å…ä¸å¿…è¦çš„åˆ‡ç‰‡æ¸…ç©º

**âŒ ä¸å¿…è¦**ï¼š

```go
func resetBuffer(buf []byte) {
    clear(buf)  // å¦‚æœæ¥ä¸‹æ¥è¦è¦†ç›–ï¼Œè¿™æ˜¯å¤šä½™çš„
    // ... å†™å…¥æ–°æ•°æ®
}
```

**âœ… æ›´å¥½**ï¼š

```go
func resetBuffer(buf []byte) []byte {
    return buf[:0]  // é‡ç½®é•¿åº¦ï¼Œä¿ç•™å®¹é‡
}
```

---

## â“ å¸¸è§é—®é¢˜

### Q1: min/max å¯¹ NaN çš„è¡Œä¸ºï¼Ÿ

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    nan := math.NaN()
    x := min(1.0, nan)
    y := max(1.0, nan)
    
    fmt.Println(math.IsNaN(x))  // true
    fmt.Println(math.IsNaN(y))  // true
    
    // ä»»ä½•ä¸ NaN çš„æ¯”è¾ƒéƒ½è¿”å› NaN
}
```

### Q2: clear åˆ‡ç‰‡åä¸ºä»€ä¹ˆé•¿åº¦ä¸å˜ï¼Ÿ

`clear` å°†å…ƒç´ è®¾ç½®ä¸ºé›¶å€¼ï¼Œä½†**ä¸æ”¹å˜é•¿åº¦**ã€‚å¦‚æœéœ€è¦é‡ç½®é•¿åº¦ï¼š

```go
s := []int{1, 2, 3, 4, 5}
clear(s)           // é›¶å€¼ï¼š[0 0 0 0 0]
s = s[:0]          // é‡ç½®é•¿åº¦ï¼š[]ï¼ˆä½†å®¹é‡ä»ä¸º 5ï¼‰
```

### Q3: å¯ä»¥å¯¹ nil åˆ‡ç‰‡æˆ–æ˜ å°„ä½¿ç”¨ clear å—ï¼Ÿ

```go
var s []int
var m map[string]int

clear(s)  // âœ… å®‰å…¨ï¼Œæ— æ“ä½œ
clear(m)  // âŒ panic: assignment to entry in nil map
```

**å»ºè®®**ï¼šåœ¨æ¸…ç©ºæ˜ å°„å‰æ£€æŸ¥æ˜¯å¦ä¸º nilã€‚

---

## ğŸ“š æ‰©å±•é˜…è¯»

- [Go 1.21 Release Notes - Built-in Functions](https://go.dev/doc/go1.21#language)
- [cmp åŒ…æ–‡æ¡£](https://pkg.go.dev/cmp)
- [Go Generics Tutorial](https://go.dev/doc/tutorial/generics)

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ24æ—¥  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.21+
