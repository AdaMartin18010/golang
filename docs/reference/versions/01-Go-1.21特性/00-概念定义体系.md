# Go 1.21特性 - 概念定义体系

**版本**: v1.0  
**发布日期**: 2023年8月  
**更新日期**: 2025-10-28

---

## 1. 核心概念

### 1.1 PGO (Profile-Guided Optimization)

**形式化定义**:
```go
type PGO struct {
    Profile      *ProfileData  // 性能数据
    Optimization OptimizeFunc  // 优化函数
    Improvement  float64       // 性能提升(2-14%)
}

type ProfileData struct {
    CPUProfile   []byte
    MemProfile   []byte
    HotPaths     []HotPath
}
```

**工作原理**:
1. **Profile**: 收集程序运行时性能数据
2. **Analyze**: 分析热点路径
3. **Optimize**: 针对性优化编译
4. **Deploy**: 部署优化后的二进制

**Go实现**:
```go
// 1. 收集profile
go test -cpuprofile=cpu.prof

// 2. 使用PGO编译
go build -pgo=cpu.prof -o myapp

// 性能提升: 2-14%
```

---

### 1.2 min/max内置函数

**形式化定义**:
```go
// 内置函数签名
func min[T cmp.Ordered](values ...T) T
func max[T cmp.Ordered](values ...T) T

// 约束
type Ordered interface {
    ~int | ~float64 | ~string | ...
}
```

**特性**:
- 泛型实现
- 编译时类型检查
- 零运行时开销
- 支持任意可比较类型

**使用示例**:
```go
// 整数
min(1, 2, 3)      // 1
max(1, 2, 3)      // 3

// 浮点数
min(1.5, 2.3)     // 1.5

// 字符串
min("a", "b", "c") // "a"

// 自定义类型
type Age int
min(Age(10), Age(20)) // Age(10)
```

---

### 1.3 clear内置函数

**形式化定义**:
```go
// 内置函数签名
func clear[T ~[]E | ~map[K]V](t T)

// 语义
// 对于切片: 将所有元素置为零值
// 对于映射: 删除所有键值对
```

**行为**:
```go
// 切片
s := []int{1, 2, 3}
clear(s)  // [0, 0, 0], len=3, cap不变

// 映射
m := map[string]int{"a": 1, "b": 2}
clear(m)  // map[], len=0
```

---

### 1.4 log/slog包

**形式化定义**:
```go
type Logger struct {
    handler  Handler
    ctx      context.Context
}

type Record struct {
    Time    time.Time
    Message string
    Level   Level
    Attrs   []Attr
}
```

**核心特性**:
- **结构化**: 键值对日志
- **高性能**: 零分配设计
- **可扩展**: 自定义Handler
- **上下文**: Context集成

**使用示例**:
```go
import "log/slog"

// 基础使用
slog.Info("user login",
    "user_id", 123,
    "ip", "192.168.1.1")

// 自定义Logger
logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
logger.Error("operation failed",
    "error", err,
    "operation", "save")

// 输出:
// {"time":"...","level":"ERROR","msg":"operation failed",...}
```

---

### 1.5 slices包

**形式化定义**:
```go
package slices

func Sort[S ~[]E, E cmp.Ordered](s S)
func Contains[S ~[]E, E comparable](s S, v E) bool
func Index[S ~[]E, E comparable](s S, v E) int
func Equal[S ~[]E, E comparable](s1, s2 S) bool
```

**核心函数**:
- `Sort`: 原地排序
- `Contains`: 检查包含
- `Index`: 查找索引
- `Equal`: 比较相等
- `Clone`: 克隆切片
- `Compact`: 去重

**使用示例**:
```go
import "slices"

s := []int{3, 1, 2}

// 排序
slices.Sort(s)  // [1, 2, 3]

// 查找
found := slices.Contains(s, 2)  // true
idx := slices.Index(s, 2)       // 1

// 比较
s2 := []int{1, 2, 3}
equal := slices.Equal(s, s2)    // true
```

---

### 1.6 maps包

**形式化定义**:
```go
package maps

func Clone[M ~map[K]V, K comparable, V any](m M) M
func Copy[M ~map[K]V, K comparable, V any](dst, src M)
func DeleteFunc[M ~map[K]V, K comparable, V any](m M, del func(K, V) bool)
func Equal[M ~map[K]V, K comparable, V comparable](m1, m2 M) bool
```

**核心函数**:
- `Clone`: 克隆映射
- `Copy`: 复制到目标
- `DeleteFunc`: 条件删除
- `Equal`: 比较相等

**使用示例**:
```go
import "maps"

m1 := map[string]int{"a": 1, "b": 2}

// 克隆
m2 := maps.Clone(m1)

// 复制
m3 := map[string]int{"c": 3}
maps.Copy(m3, m1)  // m3: {"a":1, "b":2, "c":3}

// 条件删除
maps.DeleteFunc(m1, func(k string, v int) bool {
    return v < 2  // 删除值<2的
})
```

---

## 🔗 相关文档

- [知识图谱](./00-知识图谱.md)
- [对比矩阵](./00-对比矩阵.md)
- [README.md](./README.md)

---

**最后更新**: 2025-10-28
