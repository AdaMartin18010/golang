# Go 1.21ç‰¹æ€§ - æ¦‚å¿µå®šä¹‰ä½“ç³»

**ç‰ˆæœ¬**: v1.0  
**å‘å¸ƒæ—¥æœŸ**: 2023å¹´8æœˆ  
**æ›´æ–°æ—¥æœŸ**: 2025-10-28

---

## 1. æ ¸å¿ƒæ¦‚å¿µ

### 1.1 PGO (Profile-Guided Optimization)

**å½¢å¼åŒ–å®šä¹‰**:
```go
type PGO struct {
    Profile      *ProfileData  // æ€§èƒ½æ•°æ®
    Optimization OptimizeFunc  // ä¼˜åŒ–å‡½æ•°
    Improvement  float64       // æ€§èƒ½æå‡(2-14%)
}

type ProfileData struct {
    CPUProfile   []byte
    MemProfile   []byte
    HotPaths     []HotPath
}
```

**å·¥ä½œåŸç†**:
1. **Profile**: æ”¶é›†ç¨‹åºè¿è¡Œæ—¶æ€§èƒ½æ•°æ®
2. **Analyze**: åˆ†æçƒ­ç‚¹è·¯å¾„
3. **Optimize**: é’ˆå¯¹æ€§ä¼˜åŒ–ç¼–è¯‘
4. **Deploy**: éƒ¨ç½²ä¼˜åŒ–åçš„äºŒè¿›åˆ¶

**Goå®ç°**:
```go
// 1. æ”¶é›†profile
go test -cpuprofile=cpu.prof

// 2. ä½¿ç”¨PGOç¼–è¯‘
go build -pgo=cpu.prof -o myapp

// æ€§èƒ½æå‡: 2-14%
```

---

### 1.2 min/maxå†…ç½®å‡½æ•°

**å½¢å¼åŒ–å®šä¹‰**:
```go
// å†…ç½®å‡½æ•°ç­¾å
func min[T cmp.Ordered](values ...T) T
func max[T cmp.Ordered](values ...T) T

// çº¦æŸ
type Ordered interface {
    ~int | ~float64 | ~string | ...
}
```

**ç‰¹æ€§**:
- æ³›å‹å®ç°
- ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥
- é›¶è¿è¡Œæ—¶å¼€é”€
- æ”¯æŒä»»æ„å¯æ¯”è¾ƒç±»å‹

**ä½¿ç”¨ç¤ºä¾‹**:
```go
// æ•´æ•°
min(1, 2, 3)      // 1
max(1, 2, 3)      // 3

// æµ®ç‚¹æ•°
min(1.5, 2.3)     // 1.5

// å­—ç¬¦ä¸²
min("a", "b", "c") // "a"

// è‡ªå®šä¹‰ç±»å‹
type Age int
min(Age(10), Age(20)) // Age(10)
```

---

### 1.3 clearå†…ç½®å‡½æ•°

**å½¢å¼åŒ–å®šä¹‰**:
```go
// å†…ç½®å‡½æ•°ç­¾å
func clear[T ~[]E | ~map[K]V](t T)

// è¯­ä¹‰
// å¯¹äºåˆ‡ç‰‡: å°†æ‰€æœ‰å…ƒç´ ç½®ä¸ºé›¶å€¼
// å¯¹äºæ˜ å°„: åˆ é™¤æ‰€æœ‰é”®å€¼å¯¹
```

**è¡Œä¸º**:
```go
// åˆ‡ç‰‡
s := []int{1, 2, 3}
clear(s)  // [0, 0, 0], len=3, capä¸å˜

// æ˜ å°„
m := map[string]int{"a": 1, "b": 2}
clear(m)  // map[], len=0
```

---

### 1.4 log/slogåŒ…

**å½¢å¼åŒ–å®šä¹‰**:
```go
type Logger struct {
    handler  Handler
    ctx      context.Context
}

type Record struct {
    Time    time.Time
    Message string
    Level   Level
    Attrs   []Attr
}
```

**æ ¸å¿ƒç‰¹æ€§**:
- **ç»“æ„åŒ–**: é”®å€¼å¯¹æ—¥å¿—
- **é«˜æ€§èƒ½**: é›¶åˆ†é…è®¾è®¡
- **å¯æ‰©å±•**: è‡ªå®šä¹‰Handler
- **ä¸Šä¸‹æ–‡**: Contexté›†æˆ

**ä½¿ç”¨ç¤ºä¾‹**:
```go
import "log/slog"

// åŸºç¡€ä½¿ç”¨
slog.Info("user login",
    "user_id", 123,
    "ip", "192.168.1.1")

// è‡ªå®šä¹‰Logger
logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
logger.Error("operation failed",
    "error", err,
    "operation", "save")

// è¾“å‡º:
// {"time":"...","level":"ERROR","msg":"operation failed",...}
```

---

### 1.5 slicesåŒ…

**å½¢å¼åŒ–å®šä¹‰**:
```go
package slices

func Sort[S ~[]E, E cmp.Ordered](s S)
func Contains[S ~[]E, E comparable](s S, v E) bool
func Index[S ~[]E, E comparable](s S, v E) int
func Equal[S ~[]E, E comparable](s1, s2 S) bool
```

**æ ¸å¿ƒå‡½æ•°**:
- `Sort`: åŸåœ°æ’åº
- `Contains`: æ£€æŸ¥åŒ…å«
- `Index`: æŸ¥æ‰¾ç´¢å¼•
- `Equal`: æ¯”è¾ƒç›¸ç­‰
- `Clone`: å…‹éš†åˆ‡ç‰‡
- `Compact`: å»é‡

**ä½¿ç”¨ç¤ºä¾‹**:
```go
import "slices"

s := []int{3, 1, 2}

// æ’åº
slices.Sort(s)  // [1, 2, 3]

// æŸ¥æ‰¾
found := slices.Contains(s, 2)  // true
idx := slices.Index(s, 2)       // 1

// æ¯”è¾ƒ
s2 := []int{1, 2, 3}
equal := slices.Equal(s, s2)    // true
```

---

### 1.6 mapsåŒ…

**å½¢å¼åŒ–å®šä¹‰**:
```go
package maps

func Clone[M ~map[K]V, K comparable, V any](m M) M
func Copy[M ~map[K]V, K comparable, V any](dst, src M)
func DeleteFunc[M ~map[K]V, K comparable, V any](m M, del func(K, V) bool)
func Equal[M ~map[K]V, K comparable, V comparable](m1, m2 M) bool
```

**æ ¸å¿ƒå‡½æ•°**:
- `Clone`: å…‹éš†æ˜ å°„
- `Copy`: å¤åˆ¶åˆ°ç›®æ ‡
- `DeleteFunc`: æ¡ä»¶åˆ é™¤
- `Equal`: æ¯”è¾ƒç›¸ç­‰

**ä½¿ç”¨ç¤ºä¾‹**:
```go
import "maps"

m1 := map[string]int{"a": 1, "b": 2}

// å…‹éš†
m2 := maps.Clone(m1)

// å¤åˆ¶
m3 := map[string]int{"c": 3}
maps.Copy(m3, m1)  // m3: {"a":1, "b":2, "c":3}

// æ¡ä»¶åˆ é™¤
maps.DeleteFunc(m1, func(k string, v int) bool {
    return v < 2  // åˆ é™¤å€¼<2çš„
})
```

---

## ğŸ”— ç›¸å…³æ–‡æ¡£

- [çŸ¥è¯†å›¾è°±](./00-çŸ¥è¯†å›¾è°±.md)
- [å¯¹æ¯”çŸ©é˜µ](./00-å¯¹æ¯”çŸ©é˜µ.md)
- [README.md](./README.md)

---

**æœ€åæ›´æ–°**: 2025-10-28
