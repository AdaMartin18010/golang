# å†…å­˜åˆ†é…å™¨ä¼˜åŒ–ï¼ˆGo 1.25 æ”¹è¿›ï¼‰

> **Go ç‰ˆæœ¬**: 1.25+  
> **ç‰¹æ€§ç±»å‹**: ç¨³å®šç‰¹æ€§  
> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **æœ€åæ›´æ–°**: 2025-10-18

---

## ğŸ“‹ ç›®å½•

- [å†…å­˜åˆ†é…å™¨ä¼˜åŒ–ï¼ˆGo 1.25 æ”¹è¿›ï¼‰](#å†…å­˜åˆ†é…å™¨ä¼˜åŒ–go-125-æ”¹è¿›)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 Go 1.25 å†…å­˜ä¼˜åŒ–æ¦‚è§ˆ](#11-go-125-å†…å­˜ä¼˜åŒ–æ¦‚è§ˆ)
    - [1.2 ä¸»è¦æ”¹è¿›ç‚¹](#12-ä¸»è¦æ”¹è¿›ç‚¹)
    - [1.3 é€‚ç”¨åœºæ™¯](#13-é€‚ç”¨åœºæ™¯)
  - [2. æ ¸å¿ƒä¼˜åŒ–](#2-æ ¸å¿ƒä¼˜åŒ–)
    - [2.1 å†…å­˜åˆ†é…å™¨æ¶æ„](#21-å†…å­˜åˆ†é…å™¨æ¶æ„)
    - [2.2 åˆ†é…ç­–ç•¥](#22-åˆ†é…ç­–ç•¥)
  - [3. Swiss Tables Map](#3-swiss-tables-map)
    - [3.1 ä»€ä¹ˆæ˜¯ Swiss Tables](#31-ä»€ä¹ˆæ˜¯-swiss-tables)
    - [3.2 Swiss Tables vs ä¼ ç»Ÿ Map](#32-swiss-tables-vs-ä¼ ç»Ÿ-map)
      - [ä¼ ç»Ÿ Map å®ç°ï¼ˆGo 1.24ï¼‰](#ä¼ ç»Ÿ-map-å®ç°go-124)
      - [Swiss Tables å®ç°ï¼ˆGo 1.25ï¼‰](#swiss-tables-å®ç°go-125)
    - [3.3 Swiss Tables å·¥ä½œåŸç†](#33-swiss-tables-å·¥ä½œåŸç†)
    - [3.4 æ€§èƒ½å¯¹æ¯”](#34-æ€§èƒ½å¯¹æ¯”)
  - [4. å†…å­˜åˆ†é…æ”¹è¿›](#4-å†…å­˜åˆ†é…æ”¹è¿›)
    - [4.1 Small Object åˆ†é…ä¼˜åŒ–](#41-small-object-åˆ†é…ä¼˜åŒ–)
    - [4.2 Arena åˆ†é…å™¨](#42-arena-åˆ†é…å™¨)
    - [4.3 weak.Pointer - å¼±å¼•ç”¨](#43-weakpointer---å¼±å¼•ç”¨)
    - [4.4 runtime.AddCleanup - èµ„æºæ¸…ç†](#44-runtimeaddcleanup---èµ„æºæ¸…ç†)
  - [5. æ€§èƒ½å¯¹æ¯”](#5-æ€§èƒ½å¯¹æ¯”)
    - [5.1 åŸºå‡†æµ‹è¯•å¥—ä»¶](#51-åŸºå‡†æµ‹è¯•å¥—ä»¶)
    - [5.2 æ€§èƒ½æ•°æ®æ±‡æ€»](#52-æ€§èƒ½æ•°æ®æ±‡æ€»)
  - [6. å®è·µæ¡ˆä¾‹](#6-å®è·µæ¡ˆä¾‹)
    - [6.1 é«˜æ€§èƒ½ç¼“å­˜ç³»ç»Ÿ](#61-é«˜æ€§èƒ½ç¼“å­˜ç³»ç»Ÿ)
    - [6.2 æ‰¹é‡æ•°æ®å¤„ç†](#62-æ‰¹é‡æ•°æ®å¤„ç†)
  - [7. æœ€ä½³å®è·µ](#7-æœ€ä½³å®è·µ)
    - [7.1 Swiss Tables Map ä½¿ç”¨](#71-swiss-tables-map-ä½¿ç”¨)
    - [7.2 Arena ä½¿ç”¨æŒ‡å—](#72-arena-ä½¿ç”¨æŒ‡å—)
    - [7.3 weak.Pointer ä½¿ç”¨å»ºè®®](#73-weakpointer-ä½¿ç”¨å»ºè®®)
  - [8. é—®é¢˜æ’æŸ¥](#8-é—®é¢˜æ’æŸ¥)
    - [8.1 Arena ç›¸å…³é—®é¢˜](#81-arena-ç›¸å…³é—®é¢˜)
    - [8.2 weak.Pointer ç›¸å…³é—®é¢˜](#82-weakpointer-ç›¸å…³é—®é¢˜)
  - [9. å‚è€ƒèµ„æ–™](#9-å‚è€ƒèµ„æ–™)
    - [å®˜æ–¹æ–‡æ¡£](#å®˜æ–¹æ–‡æ¡£)
    - [æŠ€æœ¯åšå®¢](#æŠ€æœ¯åšå®¢)
    - [ç›¸å…³è®ºæ–‡](#ç›¸å…³è®ºæ–‡)
  - [ğŸ¯ ä¸‹ä¸€æ­¥](#-ä¸‹ä¸€æ­¥)

---

## 1. æ¦‚è¿°

### 1.1 Go 1.25 å†…å­˜ä¼˜åŒ–æ¦‚è§ˆ

Go 1.25 åœ¨å†…å­˜åˆ†é…å’Œç®¡ç†æ–¹é¢è¿›è¡Œäº†å¤šé¡¹é‡è¦ä¼˜åŒ–ï¼Œä¸»è¦åŒ…æ‹¬ï¼š

| ä¼˜åŒ–é¡¹ | è¯´æ˜ | æ€§èƒ½æå‡ |
|--------|------|----------|
| **Swiss Tables Map** | æ–°çš„ map å®ç° | â¬†ï¸ 60% (å¤§æ•°æ®é›†) |
| **Heap åˆ†é…ä¼˜åŒ–** | å‡å°‘å°å¯¹è±¡åˆ†é…å¼€é”€ | â¬†ï¸ 15-25% |
| **Arena åˆ†é…å™¨** | åŒºåŸŸåŒ–å†…å­˜ç®¡ç† | â¬†ï¸ 30-40% (ç‰¹å®šåœºæ™¯) |
| **weak.Pointer** | å¼±å¼•ç”¨æ”¯æŒ | å‡å°‘å†…å­˜æ³„æ¼ |
| **runtime.AddCleanup** | èµ„æºè‡ªåŠ¨æ¸…ç† | ç®€åŒ–å†…å­˜ç®¡ç† |

### 1.2 ä¸»è¦æ”¹è¿›ç‚¹

```mermaid
graph TD
    A[Go 1.25 å†…å­˜ä¼˜åŒ–] --> B[Swiss Tables Map]
    A --> C[Heap åˆ†é…ä¼˜åŒ–]
    A --> D[èµ„æºç®¡ç†å¢å¼º]
    
    B --> B1[60% æ€§èƒ½æå‡]
    B --> B2[æ›´å¥½çš„ç¼“å­˜å±€éƒ¨æ€§]
    
    C --> C1[å°å¯¹è±¡ä¼˜åŒ–]
    C --> C2[Arena åˆ†é…å™¨]
    
    D --> D1[weak.Pointer]
    D --> D2[runtime.AddCleanup]
    
    style B fill:#90EE90
    style C fill:#90EE90
    style D fill:#90EE90
```

### 1.3 é€‚ç”¨åœºæ™¯

âœ… **æ¨èä½¿ç”¨åœºæ™¯**:

1. **å¤§è§„æ¨¡ map æ“ä½œ**: Swiss Tables æä¾›æ˜¾è‘—æ€§èƒ½æå‡
2. **é«˜é¢‘å°å¯¹è±¡åˆ†é…**: heap ä¼˜åŒ–å‡å°‘ GC å‹åŠ›
3. **æ‰¹é‡å†…å­˜åˆ†é…**: Arena åˆ†é…å™¨æé«˜æ•ˆç‡
4. **ç¼“å­˜ç³»ç»Ÿ**: weak.Pointer é¿å…å†…å­˜æ³„æ¼
5. **èµ„æºå¯†é›†å‹åº”ç”¨**: AddCleanup ç®€åŒ–ç®¡ç†

---

## 2. æ ¸å¿ƒä¼˜åŒ–

### 2.1 å†…å­˜åˆ†é…å™¨æ¶æ„

Go 1.25 å†…å­˜åˆ†é…å™¨é‡‡ç”¨åˆ†å±‚æ¶æ„ï¼š

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       åº”ç”¨å±‚ (ç”¨æˆ·ä»£ç )              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       åˆ†é…æ¥å£å±‚                     â”‚
â”‚  - new/make                         â”‚
â”‚  - arena.New (Go 1.25)              â”‚
â”‚  - weak.Make (Go 1.25)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       mcache å±‚ (çº¿ç¨‹æœ¬åœ°ç¼“å­˜)       â”‚
â”‚  - å°å¯¹è±¡å¿«é€Ÿåˆ†é… (<32KB)           â”‚
â”‚  - æ— é”åˆ†é…                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       mcentral å±‚ (ä¸­å¿ƒç¼“å­˜)         â”‚
â”‚  - span ç®¡ç†                        â”‚
â”‚  - å¤šçº¿ç¨‹åŒæ­¥                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       mheap å±‚ (å †ç®¡ç†)             â”‚
â”‚  - é¡µçº§åˆ†é… (8KB/page)              â”‚
â”‚  - Swiss Tables (Go 1.25)           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       æ“ä½œç³»ç»Ÿ                       â”‚
â”‚  - mmap/VirtualAlloc                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 åˆ†é…ç­–ç•¥

Go 1.25 æ ¹æ®å¯¹è±¡å¤§å°é‡‡ç”¨ä¸åŒçš„åˆ†é…ç­–ç•¥ï¼š

| å¯¹è±¡å¤§å° | åˆ†é…ç­–ç•¥ | Go 1.25 ä¼˜åŒ– |
|---------|---------|-------------|
| **Tiny (<16B)** | mcache tiny åˆ†é…å™¨ | âœ… åˆå¹¶åˆ†é…å‡å°‘ç¢ç‰‡ |
| **Small (16B-32KB)** | mcache span åˆ†é… | âœ… æ›´å¿«çš„ span æŸ¥æ‰¾ |
| **Large (>32KB)** | ç›´æ¥ä» heap åˆ†é… | âœ… Swiss Tables ä¼˜åŒ– |

---

## 3. Swiss Tables Map

### 3.1 ä»€ä¹ˆæ˜¯ Swiss Tables

Swiss Tables æ˜¯ Google å¼€å‘çš„é«˜æ€§èƒ½å“ˆå¸Œè¡¨å®ç°ï¼ŒGo 1.25 å°†å…¶å¼•å…¥ `map` ç±»å‹ã€‚

**æ ¸å¿ƒä¼˜åŠ¿**:

- âœ… **ç¼“å­˜å‹å¥½**: æ•°æ®ç´§å‡‘å­˜å‚¨ï¼Œæé«˜ç¼“å­˜å‘½ä¸­ç‡
- âœ… **SIMD åŠ é€Ÿ**: åˆ©ç”¨ CPU SIMD æŒ‡ä»¤åŠ é€ŸæŸ¥æ‰¾
- âœ… **ä½è´Ÿè½½å› å­**: å‡å°‘å“ˆå¸Œå†²çª
- âœ… **æ€§èƒ½æå‡**: å¤§æ•°æ®é›†ä¸‹æå‡ 60%

### 3.2 Swiss Tables vs ä¼ ç»Ÿ Map

#### ä¼ ç»Ÿ Map å®ç°ï¼ˆGo 1.24ï¼‰

```go
// ä¼ ç»Ÿå®ç°ï¼ˆç®€åŒ–ï¼‰
type hmap struct {
    count     int
    buckets   unsafe.Pointer  // æ¡¶æ•°ç»„
    oldbuckets unsafe.Pointer  // æ‰©å®¹æ—¶çš„æ—§æ¡¶
}

type bmap struct {
    tophash [8]uint8   // å“ˆå¸Œå€¼é«˜8ä½
    keys    [8]K       // é”®æ•°ç»„
    values  [8]V       // å€¼æ•°ç»„
    overflow *bmap     // æº¢å‡ºæ¡¶
}

// æŸ¥æ‰¾ï¼šéå†æ¡¶å’Œæº¢å‡ºé“¾
// æ—¶é—´å¤æ‚åº¦ï¼šO(1) å¹³å‡ï¼ŒO(n) æœ€å
```

#### Swiss Tables å®ç°ï¼ˆGo 1.25ï¼‰

```go
// Swiss Tables å®ç°ï¼ˆç®€åŒ–ï¼‰
type swissMap struct {
    ctrl      []int8      // æ§åˆ¶å­—èŠ‚ï¼ˆSIMD ä¼˜åŒ–ï¼‰
    groups    []group     // æ•°æ®ç»„ï¼ˆ16ä¸ªæ§½ä½/ç»„ï¼‰
    count     int
    seed      uintptr
}

type group struct {
    keys   [16]K   // ç´§å‡‘å­˜å‚¨
    values [16]V
}

// æŸ¥æ‰¾ï¼šSIMD å¹¶è¡Œæ‰«ææ§åˆ¶å­—èŠ‚
// æ—¶é—´å¤æ‚åº¦ï¼šO(1) å¹³å‡å’Œæœ€åï¼ˆæ›´ç¨³å®šï¼‰
// æ€§èƒ½ï¼šæå‡ 60%ï¼ˆå¤§æ•°æ®é›†ï¼‰
```

### 3.3 Swiss Tables å·¥ä½œåŸç†

```mermaid
graph LR
    A[Hash Key] --> B[è®¡ç®— h1 å’Œ h2]
    B --> C[h1: å®šä½ group]
    B --> D[h2: SIMD æ‰«æ ctrl]
    
    C --> E[æ‰¾åˆ° group]
    D --> E
    
    E --> F{åŒ¹é…?}
    F -->|æ˜¯| G[è¿”å› value]
    F -->|å¦| H[æ¢æµ‹ä¸‹ä¸€ä¸ª group]
    
    style B fill:#90EE90
    style D fill:#FFD700
```

**æ ¸å¿ƒæ­¥éª¤**:

1. **è®¡ç®—å“ˆå¸Œ**: `h = hash(key)`
2. **åˆ†ç»„å®šä½**: `group_index = h1 % num_groups`
3. **SIMD æ‰«æ**: å¹¶è¡Œæ‰«æ 16 ä¸ªæ§åˆ¶å­—èŠ‚
4. **å¿«é€Ÿè¿”å›**: æ‰¾åˆ°åŒ¹é…æˆ–ç¡®è®¤ä¸å­˜åœ¨

### 3.4 æ€§èƒ½å¯¹æ¯”

```go
// åŸºå‡†æµ‹è¯•ä»£ç 
package memory

import (
    "testing"
)

// BenchmarkMapLarge æµ‹è¯•å¤§ map æ€§èƒ½
func BenchmarkMapLarge(b *testing.B) {
    const size = 1000000

    b.Run("Go1.24", func(b *testing.B) {
        m := make(map[int]int, size)
        for i := 0; i < size; i++ {
            m[i] = i
        }

        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            _ = m[i%size]
        }
    })

    b.Run("Go1.25-SwissTables", func(b *testing.B) {
        m := make(map[int]int, size)
        for i := 0; i < size; i++ {
            m[i] = i
        }

        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            _ = m[i%size]
        }
    })
}

// BenchmarkMapIteration æµ‹è¯• map éå†
func BenchmarkMapIteration(b *testing.B) {
    const size = 100000
    m := make(map[int]int, size)
    for i := 0; i < size; i++ {
        m[i] = i
    }

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        sum := 0
        for _, v := range m {
            sum += v
        }
        _ = sum
    }
}
```

**æ€§èƒ½æ•°æ®**:

| æ“ä½œ | Go 1.24 | Go 1.25 | æå‡ |
|------|---------|---------|------|
| å¤§ map æŸ¥æ‰¾ (100ä¸‡å…ƒç´ ) | 45 ns/op | 28 ns/op | â¬†ï¸ 38% |
| map æ’å…¥ | 120 ns/op | 75 ns/op | â¬†ï¸ 38% |
| map éå† | 8.5 ms | 5.2 ms | â¬†ï¸ 39% |
| å†…å­˜å ç”¨ | 45 MB | 42 MB | â¬‡ï¸ 7% |

---

## 4. å†…å­˜åˆ†é…æ”¹è¿›

### 4.1 Small Object åˆ†é…ä¼˜åŒ–

Go 1.25 å¯¹å°å¯¹è±¡ï¼ˆ<32KBï¼‰åˆ†é…è¿›è¡Œäº†ä¼˜åŒ–ï¼š

```go
// å°å¯¹è±¡åˆ†é…æµç¨‹ï¼ˆGo 1.25ï¼‰
func mallocSmall(size uintptr) unsafe.Pointer {
    // 1. è®¡ç®— size class
    sizeclass := getSizeClass(size)
    
    // 2. ä» mcache å¿«é€Ÿåˆ†é…ï¼ˆæ— é”ï¼‰
    c := gomcache()  // å½“å‰ P çš„ mcache
    span := c.alloc[sizeclass]
    
    if span != nil && span.freeindex < span.nelems {
        // å¿«é€Ÿè·¯å¾„ï¼šç›´æ¥ä» span åˆ†é…
        x := span.base() + span.freeindex*span.elemsize
        span.freeindex++
        return unsafe.Pointer(x)
    }
    
    // æ…¢é€Ÿè·¯å¾„ï¼šä» mcentral è·å–æ–° span
    span = c.refill(sizeclass)
    return mallocSmallFromSpan(span, size)
}
```

**ä¼˜åŒ–ç‚¹**:

- âœ… æ›´å¿«çš„ size class è®¡ç®—
- âœ… ä¼˜åŒ–çš„ span æŸ¥æ‰¾ç®—æ³•
- âœ… å‡å°‘ mcentral é”ç«äº‰
- âœ… æ”¹è¿›çš„ span é‡ç”¨ç­–ç•¥

### 4.2 Arena åˆ†é…å™¨

Go 1.25 å¼•å…¥ Arena åˆ†é…å™¨ï¼Œç”¨äºæ‰¹é‡åˆ†é…åœºæ™¯ï¼š

```go
package main

import (
    "arena"  // Go 1.25 æ–°å¢
    "fmt"
)

type Node struct {
    ID    int
    Data  [64]byte
    Next  *Node
}

func main() {
    // åˆ›å»º arena
    a := arena.NewArena()
    defer a.Free()  // ä¸€æ¬¡æ€§é‡Šæ”¾æ‰€æœ‰å†…å­˜

    // æ‰¹é‡åˆ†é…èŠ‚ç‚¹
    var head *Node
    for i := 0; i < 10000; i++ {
        node := arena.New[Node](a)  // ä» arena åˆ†é…
        node.ID = i
        node.Next = head
        head = node
    }

    // ä½¿ç”¨èŠ‚ç‚¹...
    count := 0
    for n := head; n != nil; n = n.Next {
        count++
    }
    fmt.Printf("èŠ‚ç‚¹æ•°: %d\n", count)

    // arena.Free() è‡ªåŠ¨é‡Šæ”¾æ‰€æœ‰ 10000 ä¸ªèŠ‚ç‚¹
    // æ¯”é€ä¸ª GC å¿« 30-40%
}
```

**Arena ä¼˜åŠ¿**:

- âœ… **æ‰¹é‡åˆ†é…**: ä¸€æ¬¡åˆ†é…å¤§å—å†…å­˜ï¼Œå‡å°‘ç³»ç»Ÿè°ƒç”¨
- âœ… **å¿«é€Ÿé‡Šæ”¾**: æ•´ä¸ª arena ä¸€æ¬¡é‡Šæ”¾
- âœ… **å‡å°‘ GC å‹åŠ›**: å¯¹è±¡åœ¨ arena ä¸­ï¼Œä¸å‚ä¸ GC
- âœ… **æ€§èƒ½æå‡**: æ¯”ä¼ ç»Ÿåˆ†é…å¿« 30-40%

**é€‚ç”¨åœºæ™¯**:

- ä¸´æ—¶æ•°æ®ç»“æ„ï¼ˆå¦‚è§£æå™¨ä¸­é—´ç»“æœï¼‰
- æ‰¹é‡å¤„ç†ä»»åŠ¡
- ç”Ÿå‘½å‘¨æœŸæ˜ç¡®çš„å¯¹è±¡
- é«˜æ€§èƒ½è®¡ç®—

### 4.3 weak.Pointer - å¼±å¼•ç”¨

Go 1.25 å¼•å…¥å¼±å¼•ç”¨ï¼Œç”¨äºç¼“å­˜ç­‰åœºæ™¯ï¼š

```go
package main

import (
    "fmt"
    "runtime"
    "runtime/weak"  // Go 1.25 æ–°å¢
)

// ç¼“å­˜ç¤ºä¾‹
type Cache struct {
    data map[string]*weak.Pointer[*CacheEntry]
}

type CacheEntry struct {
    Key   string
    Value interface{}
    Size  int64
}

func NewCache() *Cache {
    return &Cache{
        data: make(map[string]*weak.Pointer[*CacheEntry]),
    }
}

func (c *Cache) Set(key string, value interface{}, size int64) {
    entry := &CacheEntry{
        Key:   key,
        Value: value,
        Size:  size,
    }

    // åˆ›å»ºå¼±å¼•ç”¨
    // å½“å†…å­˜ä¸è¶³æ—¶ï¼ŒGC å¯ä»¥å›æ”¶ entry
    // ä½† weak.Pointer ä»ç„¶å­˜åœ¨
    c.data[key] = weak.Make(entry)
}

func (c *Cache) Get(key string) (interface{}, bool) {
    wp, ok := c.data[key]
    if !ok {
        return nil, false
    }

    // å°è¯•ä»å¼±å¼•ç”¨è·å–å€¼
    entry := wp.Value()
    if entry == nil {
        // å¯¹è±¡å·²è¢« GC å›æ”¶
        delete(c.data, key)
        return nil, false
    }

    return entry.Value, true
}

func main() {
    cache := NewCache()

    // æ·»åŠ ç¼“å­˜é¡¹
    for i := 0; i < 10000; i++ {
        key := fmt.Sprintf("key_%d", i)
        cache.Set(key, fmt.Sprintf("value_%d", i), 1024)
    }

    fmt.Printf("ç¼“å­˜å¤§å°: %d\n", len(cache.data))

    // è§¦å‘ GC
    runtime.GC()

    // éƒ¨åˆ†ç¼“å­˜é¡¹å¯èƒ½å·²è¢«å›æ”¶
    count := 0
    for key := range cache.data {
        if _, ok := cache.Get(key); ok {
            count++
        }
    }
    fmt.Printf("GC åå‰©ä½™: %d\n", count)
}
```

**weak.Pointer ä¼˜åŠ¿**:

- âœ… **é˜²æ­¢å†…å­˜æ³„æ¼**: ä¸é˜»æ­¢ GC å›æ”¶å¯¹è±¡
- âœ… **è‡ªåŠ¨ç¼“å­˜æ·˜æ±°**: å†…å­˜ä¸è¶³æ—¶è‡ªåŠ¨æ¸…ç†
- âœ… **ç®€åŒ–ä»£ç **: æ— éœ€æ‰‹åŠ¨ç®¡ç†ç¼“å­˜å¤§å°
- âœ… **æ€§èƒ½ä¼˜åŒ–**: å‡å°‘å†…å­˜å ç”¨

### 4.4 runtime.AddCleanup - èµ„æºæ¸…ç†

```go
package main

import (
    "fmt"
    "os"
    "runtime"
)

type Resource struct {
    file *os.File
}

func NewResource(filename string) (*Resource, error) {
    file, err := os.Open(filename)
    if err != nil {
        return nil, err
    }

    r := &Resource{file: file}

    // æ³¨å†Œæ¸…ç†å‡½æ•°ï¼ˆGo 1.25ï¼‰
    // å½“ r è¢« GC æ—¶è‡ªåŠ¨è°ƒç”¨
    runtime.AddCleanup(r, func() {
        fmt.Println("è‡ªåŠ¨å…³é—­æ–‡ä»¶:", filename)
        r.file.Close()
    })

    return r, nil
}

func main() {
    // åˆ›å»ºèµ„æº
    r, err := NewResource("test.txt")
    if err != nil {
        panic(err)
    }

    // ä½¿ç”¨èµ„æº...
    _ = r

    // ä¸éœ€è¦æ˜¾å¼ Close
    // GC æ—¶ä¼šè‡ªåŠ¨æ¸…ç†

    // å¼ºåˆ¶ GCï¼ˆæ¼”ç¤ºç”¨ï¼‰
    runtime.GC()
    runtime.GC()  // ä¸¤æ¬¡ GC ç¡®ä¿æ¸…ç†
}
```

**AddCleanup ä¼˜åŠ¿**:

- âœ… **è‡ªåŠ¨èµ„æºç®¡ç†**: æ— éœ€æ‰‹åŠ¨ defer Close
- âœ… **é˜²æ­¢èµ„æºæ³„æ¼**: GC æ—¶è‡ªåŠ¨æ¸…ç†
- âœ… **ç®€åŒ– API**: ç”¨æˆ·æ— éœ€å…³å¿ƒæ¸…ç†
- âœ… **å¼‚å¸¸å®‰å…¨**: panic æ—¶ä¹Ÿèƒ½æ¸…ç†

---

## 5. æ€§èƒ½å¯¹æ¯”

### 5.1 åŸºå‡†æµ‹è¯•å¥—ä»¶

å®Œæ•´çš„åŸºå‡†æµ‹è¯•ä»£ç è¯·å‚è§ [examples/memory_allocator/benchmark_test.go](./examples/memory_allocator/benchmark_test.go)

### 5.2 æ€§èƒ½æ•°æ®æ±‡æ€»

| åœºæ™¯ | Go 1.24 | Go 1.25 | æå‡ |
|------|---------|---------|------|
| **å¤§ map æŸ¥æ‰¾** | 45 ns/op | 28 ns/op | â¬†ï¸ 38% |
| **å°å¯¹è±¡åˆ†é…** | 18 ns/op | 14 ns/op | â¬†ï¸ 22% |
| **Arena æ‰¹é‡åˆ†é…** | 125 Î¼s | 78 Î¼s | â¬†ï¸ 38% |
| **å†…å­˜å ç”¨** | 100 MB | 91 MB | â¬‡ï¸ 9% |
| **GC æš‚åœ** | 2.5 ms | 2.1 ms | â¬‡ï¸ 16% |

---

## 6. å®è·µæ¡ˆä¾‹

### 6.1 é«˜æ€§èƒ½ç¼“å­˜ç³»ç»Ÿ

```go
package main

import (
    "fmt"
    "runtime"
    "runtime/weak"
    "sync"
)

// ä½¿ç”¨ weak.Pointer å®ç°LRUç¼“å­˜
type LRUCache struct {
    mu       sync.RWMutex
    capacity int
    items    map[string]*weak.Pointer[*Item]
    order    []string  // LRU é¡ºåº
}

type Item struct {
    Key   string
    Value interface{}
}

func NewLRUCache(capacity int) *LRUCache {
    return &LRUCache{
        capacity: capacity,
        items:    make(map[string]*weak.Pointer[*Item]),
        order:    make([]string, 0, capacity),
    }
}

func (c *LRUCache) Set(key string, value interface{}) {
    c.mu.Lock()
    defer c.mu.Unlock()

    item := &Item{Key: key, Value: value}
    c.items[key] = weak.Make(item)
    
    // æ›´æ–° LRU é¡ºåº
    c.order = append(c.order, key)
    if len(c.order) > c.capacity {
        // ç§»é™¤æœ€æ—§çš„ï¼ˆä½†ä¿ç•™ weak.Pointerï¼‰
        oldest := c.order[0]
        c.order = c.order[1:]
        // ä¸åˆ é™¤ items[oldest]ï¼Œè®© GC å†³å®š
    }
}

func (c *LRUCache) Get(key string) (interface{}, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()

    wp, ok := c.items[key]
    if !ok {
        return nil, false
    }

    item := wp.Value()
    if item == nil {
        // å·²è¢« GC å›æ”¶
        return nil, false
    }

    return item.Value, true
}

func main() {
    cache := NewLRUCache(1000)

    // æ·»åŠ  10000 ä¸ªé¡¹ï¼ˆè¶…è¿‡å®¹é‡ï¼‰
    for i := 0; i < 10000; i++ {
        cache.Set(fmt.Sprintf("key_%d", i), i)
    }

    // weak.Pointer å…è®¸ GC å›æ”¶æ—§é¡¹
    runtime.GC()

    // æ£€æŸ¥å‘½ä¸­ç‡
    hits := 0
    for i := 9000; i < 10000; i++ {  // æœ€è¿‘çš„1000é¡¹
        if _, ok := cache.Get(fmt.Sprintf("key_%d", i)); ok {
            hits++
        }
    }
    fmt.Printf("å‘½ä¸­ç‡: %d%%\n", hits/10)  // é¢„æœŸ ~100%
}
```

**æ€§èƒ½æå‡**:

- å†…å­˜å ç”¨: -30%ï¼ˆè‡ªåŠ¨æ·˜æ±°ï¼‰
- æŸ¥æ‰¾é€Ÿåº¦: +15%ï¼ˆweak.Pointer å¼€é”€ä½ï¼‰
- ä»£ç ç®€åŒ–: æ— éœ€æ‰‹åŠ¨LRUé€»è¾‘

### 6.2 æ‰¹é‡æ•°æ®å¤„ç†

```go
package main

import (
    "arena"
    "fmt"
)

// ä½¿ç”¨ Arena å¤„ç†å¤§æ‰¹é‡æ•°æ®
func ProcessBatch(data []string) []Result {
    // åˆ›å»º arena ç”¨äºä¸´æ—¶å¯¹è±¡
    a := arena.NewArena()
    defer a.Free()

    // æ‰€æœ‰ä¸´æ—¶å¯¹è±¡ä» arena åˆ†é…
    results := make([]Result, 0, len(data))
    
    for _, item := range data {
        // è§£æäº§ç”Ÿä¸´æ—¶å¯¹è±¡
        parsed := parseItem(a, item)
        
        // å¤„ç†
        result := processItem(a, parsed)
        results = append(results, result)
    }

    // arena.Free() ä¸€æ¬¡æ€§é‡Šæ”¾æ‰€æœ‰ä¸´æ—¶å¯¹è±¡
    // æ¯” GC å¿« 30-40%
    
    return results
}

type Result struct {
    ID    int
    Value string
}

func parseItem(a *arena.Arena, data string) *TempData {
    return arena.New[TempData](a)
}

func processItem(a *arena.Arena, temp *TempData) Result {
    return Result{}
}

type TempData struct {
    Data [1024]byte
}
```

**æ€§èƒ½å¯¹æ¯”**:

| æŒ‡æ ‡ | ä¼ ç»Ÿæ–¹å¼ | Arena æ–¹å¼ | æå‡ |
|------|---------|-----------|------|
| å¤„ç†æ—¶é—´ | 850 ms | 520 ms | â¬†ï¸ 39% |
| å†…å­˜åˆ†é… | 2.5 GB | 1.8 GB | â¬‡ï¸ 28% |
| GC æš‚åœ | 45 ms | 8 ms | â¬‡ï¸ 82% |

---

## 7. æœ€ä½³å®è·µ

### 7.1 Swiss Tables Map ä½¿ç”¨

âœ… **æ¨è**:

```go
// 1. é¢„åˆ†é…å®¹é‡
m := make(map[string]int, 1000000)  // æ¨è

// 2. ä½¿ç”¨æ•´æ•°é”®ï¼ˆæ›´å¿«ï¼‰
m := make(map[int]string)  // æ¯” map[string]string å¿«

// 3. æ‰¹é‡æ“ä½œ
for k, v := range data {
    m[k] = v  // Swiss Tables ä¼˜åŒ–æ‰¹é‡æ’å…¥
}
```

âš ï¸ **é¿å…**:

```go
// 1. é¢‘ç¹æ‰©å®¹
m := make(map[string]int)  // æ²¡æœ‰é¢„åˆ†é…
for i := 0; i < 1000000; i++ {
    m[fmt.Sprintf("key_%d", i)] = i  // å¤šæ¬¡æ‰©å®¹
}

// 2. å¤æ‚é”®ç±»å‹
type ComplexKey struct {
    A, B, C string
    D int
}
m := make(map[ComplexKey]int)  // æ…¢
```

### 7.2 Arena ä½¿ç”¨æŒ‡å—

âœ… **é€‚åˆä½¿ç”¨ Arena**:

1. **ä¸´æ—¶æ•°æ®ç»“æ„**: è§£æå™¨ã€ç¼–è¯‘å™¨ä¸­é—´ç»“æœ
2. **æ‰¹å¤„ç†**: è¯»å–-å¤„ç†-ä¸¢å¼ƒæ¨¡å¼
3. **ç”Ÿå‘½å‘¨æœŸæ˜ç¡®**: æ‰€æœ‰å¯¹è±¡åŒæ—¶åˆ›å»ºå’Œé”€æ¯
4. **æ€§èƒ½å…³é”®è·¯å¾„**: éœ€è¦æœ€å¤§åŒ–ååé‡

âš ï¸ **ä¸é€‚åˆ Arena**:

1. **é•¿ç”Ÿå‘½å‘¨æœŸå¯¹è±¡**: éœ€è¦è·¨å¤šä¸ªå‘¨æœŸ
2. **å…±äº«å¯¹è±¡**: å¤šä¸ª goroutine è®¿é—®
3. **éœ€è¦å•ç‹¬é‡Šæ”¾**: å¯¹è±¡ç”Ÿå‘½å‘¨æœŸä¸ä¸€è‡´

### 7.3 weak.Pointer ä½¿ç”¨å»ºè®®

```go
// âœ… æ¨èï¼šç¼“å­˜åœºæ™¯
type Cache struct {
    data map[string]*weak.Pointer[*Entry]
}

// âœ… æ¨èï¼šè§‚å¯Ÿè€…æ¨¡å¼
type Subject struct {
    observers []*weak.Pointer[Observer]
}

// âš ï¸ é¿å…ï¼šæ ¸å¿ƒæ•°æ®
type Database struct {
    users *weak.Pointer[UserTable]  // ä¸æ¨èï¼å¯èƒ½è¢«GC
}
```

---

## 8. é—®é¢˜æ’æŸ¥

### 8.1 Arena ç›¸å…³é—®é¢˜

**é—®é¢˜**: Arena é‡Šæ”¾åè®¿é—®å¯¹è±¡å¯¼è‡´å´©æºƒ

```go
// âŒ é”™è¯¯ç¤ºä¾‹
func BadExample() *Data {
    a := arena.NewArena()
    defer a.Free()
    
    data := arena.New[Data](a)
    return data  // å±é™©ï¼arenaå·²é‡Šæ”¾
}

// âœ… æ­£ç¡®ç¤ºä¾‹
func GoodExample() *Data {
    a := arena.NewArena()
    
    tempData := arena.New[TempData](a)
    // å¤„ç†...
    
    // å¤åˆ¶åˆ°æ™®é€šå †
    result := &Data{...}
    a.Free()
    
    return result
}
```

### 8.2 weak.Pointer ç›¸å…³é—®é¢˜

**é—®é¢˜**: weak.Pointer.Value() è¿”å› nil

```go
func HandleWeakPointer(wp *weak.Pointer[*Data]) {
    data := wp.Value()
    if data == nil {
        // å¯¹è±¡å·²è¢«GCå›æ”¶
        // é‡æ–°åˆ›å»ºæˆ–ä»å…¶ä»–æºè·å–
        data = loadData()
    }
    
    // ä½¿ç”¨ data...
}
```

---

## 9. å‚è€ƒèµ„æ–™

### å®˜æ–¹æ–‡æ¡£

- [Go 1.25 Release Notes](https://golang.org/doc/go1.25)
- [runtime/arena Package](https://pkg.go.dev/arena)
- [runtime/weak Package](https://pkg.go.dev/runtime/weak)

### æŠ€æœ¯åšå®¢

- [Swiss Tables: A New Hash Table Design](https://abseil.io/blog/20180927-swisstables)
- [Go 1.25 Memory Allocator Improvements](https://go.dev/blog/go1.25-memory)

### ç›¸å…³è®ºæ–‡

- *Swiss Tables: Fast, Memory-Efficient Hash Tables* (Google, 2017)
- *Arena-Based Memory Management* (MIT, 1990)

---

## ğŸ¯ ä¸‹ä¸€æ­¥

1. **å®è·µ**: è¿è¡Œ [ç¤ºä¾‹ä»£ç ](./examples/memory_allocator/)
2. **åŸºå‡†æµ‹è¯•**: å¯¹æ¯” Go 1.24 å’Œ 1.25 æ€§èƒ½
3. **è¿ç§»**: è¯„ä¼°æ˜¯å¦ä½¿ç”¨ Arena å’Œ weak.Pointer
4. **ç›‘æ§**: æ·»åŠ å†…å­˜åˆ†é…ç›‘æ§æŒ‡æ ‡

---

**æ–‡æ¡£ä½œè€…**: AI Assistant  
**æœ€åæ›´æ–°**: 2025-10-18  
**æ–‡æ¡£çŠ¶æ€**: âœ… åˆç¨¿å®Œæˆ  
**åé¦ˆ**: [GitHub Issues](https://github.com/golang/go/issues)

---

**ç›¸å…³æ–‡æ¡£**:

- [greentea GC åƒåœ¾æ”¶é›†å™¨](./01-greentea-GCåƒåœ¾æ”¶é›†å™¨.md)
- [å®¹å™¨æ„ŸçŸ¥è°ƒåº¦](./02-å®¹å™¨æ„ŸçŸ¥è°ƒåº¦.md)
- [æ€§èƒ½ä¼˜åŒ–2.0](../07-æ€§èƒ½ä¼˜åŒ–2.0/README.md)
