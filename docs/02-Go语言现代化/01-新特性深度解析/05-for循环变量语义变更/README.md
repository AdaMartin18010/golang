# Go 1.22+ for 循环变量语义变更深度解析

<!-- TOC START -->
- [Go 1.22+ for 循环变量语义变更深度解析](#go-122-for-循环变量语义变更深度解析)
  - [1.1.5.1.1 🎯 **核心问题：旧版 `for` 循环的"陷阱"**](#11511--核心问题旧版-for-循环的陷阱)
  - [1.1.5.1.2 ✨ **Go 1.22+ 的解决方案：语义变更**](#11512--go-122-的解决方案语义变更)
  - [1.1.5.1.3 ⚙️ **兼容性与实验性标志**](#11513-️-兼容性与实验性标志)
  - [1.1.5.1.4 🚀 **总结**](#11514--总结)
<!-- TOC END -->

## 1.1.5.1.1 🎯 **核心问题：旧版 `for` 循环的"陷阱"**

在 Go 1.22 版本之前，`for` 循环中的循环变量（如 `for i, v := range mySlice` 中的 `i` 和 `v`）在整个循环过程中**只被创建一次**。这意味着每次迭代，循环变量的内存地址都是相同的，只是其存储的值在改变。

这个设计在与**闭包（Closures）**和 **goroutines** 结合使用时，会引发一个非常常见且难以察觉的 bug。

**经典错误示例 (Go < 1.22):**

```go
func main() {
    items := []string{"a", "b", "c"}
    var wg sync.WaitGroup

    for _, item := range items {
        wg.Add(1)
        go func() {
            defer wg.Done()
            // 这里的 'item' 是闭包捕获的循环变量
            fmt.Println(item)
        }()
    }
    wg.Wait()
}

```

**意外的输出:**

```text
c
c
c

```

**原因分析:**

1. `for` 循环的迭代速度远快于 goroutine 的调度和执行速度。
2. 当 goroutine 开始执行 `fmt.Println(item)` 时，`for` 循环很可能已经完成了所有迭代。
3. 此时，循环变量 `item` 的值是最后一次迭代的值，即 `"c"`。
4. 由于所有 goroutine 的闭包都捕获了**同一个** `item` 变量的引用（内存地址），因此它们最终打印出来的都是这个变量的最终值 `"c"`。

**传统的修复方法 (The "Shadowing" Idiom):**
为了解决这个问题，开发者必须在循环体内创建一个新的局部变量，将循环变量的值"复制"一份。

```go
// ...
for _, item := range items {
    item := item // 创建一个同名的局部变量"遮蔽"循环变量
    wg.Add(1)
    go func() {
        defer wg.Done()
        fmt.Println(item) // 闭包现在捕获的是新创建的局部变量
    }()
}
// ...

```

这种写法虽然有效，但违反直觉，对新手不友好，且容易忘记。

## 1.1.5.1.2 ✨ **Go 1.22+ 的解决方案：语义变更**

从 Go 1.22 开始，语言规范对 `for` 循环的语义进行了修正：**循环变量现在会在每次迭代时被重新创建**。

这意味着每次循环，`item` 都是一个全新的、独立的变量，拥有自己独立的内存地址。

**使用 Go 1.22+ 编译运行最初的错误代码，会得到预期的输出:**

```text
a
b
c
(顺序可能不同)

```

**原因:**

- 每个 goroutine 的闭包现在捕获的是**不同迭代中创建的不同 `item` 变量**。
- `go func() { ... }` 捕获了第一次迭代的 `item`（值为 "a"），第二次迭代的 `item`（值为 "b"），以此类推。
- 这样，即使 goroutine 延迟执行，它们持有的也是在它们被创建那一刻的 `item` 的正确副本。

## 1.1.5.1.3 ⚙️ **兼容性与实验性标志**

- **向后兼容**: 这是一个重大的语义变更，但 Go 团队认为其修复的 bug 远比可能破坏的（依赖于旧行为的）代码更有价值。绝大多数情况下，这个变更是安全的。
- **`GOEXPERIMENT=loopvar`**: 在 Go 1.21 中，可以通过设置环境变量 `GOEXPERIMENT=loopvar` 来提前启用这个新特性，以便于代码库的迁移和测试。
- **`go vet`**: Go 的 `vet` 工具也得到了增强，可以检测出在旧版 Go 中可能受此问题影响的 `for` 循环，并给出警告。

## 1.1.5.1.4 🚀 **总结**

`for` 循环变量语义变更是 Go 语言在提升开发者体验和代码健壮性方面迈出的重要一步。它消除了一个长期存在的、最常见的 Go 编程陷阱之一，使得代码的行为更加符合直觉。对于所有 Go 开发者来说，理解这一变更的背景和影响至关重要，它让编写并发代码变得更简单、更安全。
