# 性能测试

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---

## 📋 目录


- [1. 📖 概念介绍](#1.-概念介绍)
- [2. 🎯 核心知识点](#2.-核心知识点)
  - [2.1 基准测试基础](#2.1-基准测试基础)
  - [2.2 表格驱动基准测试](#2.2-表格驱动基准测试)
  - [2.3 重置计时器](#2.3-重置计时器)
  - [2.4 并行基准测试](#2.4-并行基准测试)
  - [2.5 内存分配分析](#2.5-内存分配分析)
  - [2.6 CPU Profiling](#2.6-cpu-profiling)
  - [2.7 内存Profiling](#2.7-内存profiling)
  - [2.8 性能对比](#2.8-性能对比)
- [3. 🏗️ 实战案例](#3.-实战案例)
  - [3.1 案例：优化JSON序列化](#3.1-案例优化json序列化)
- [4. 💡 最佳实践](#4.-最佳实践)
  - [4.1 基准测试命名](#4.1-基准测试命名)
  - [4.2 避免编译器优化](#4.2-避免编译器优化)
  - [4.3 使用b.StopTimer/StartTimer](#4.3-使用b.stoptimerstarttimer)
  - [4.4 多次运行取平均](#4.4-多次运行取平均)
  - [4.5 固定CPU核心数](#4.5-固定cpu核心数)
- [5. ⚠️ 常见问题](#5.-常见问题)
- [6. 📚 相关资源](#6--相关资源)

## 1. 📖 概念介绍

性能测试用于衡量代码的执行效率，包括基准测试（Benchmark）、性能分析（Profiling）和内存分析。Go提供了强大的内置工具支持性能测试。

---

## 2. 🎯 核心知识点

### 2.1 基准测试基础

```go
package benchmark

import "testing"

func Fibonacci(n int) int {
    if n < 2 {
        return n
    }
    return Fibonacci(n-1) + Fibonacci(n-2)
}

// 基准测试函数以Benchmark开头
func BenchmarkFibonacci(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Fibonacci(10)
    }
}

// 运行：go test -bench=. -benchmem
```

输出示例：
```
BenchmarkFibonacci-8    2000000    855 ns/op    0 B/op    0 allocs/op
```

---

### 2.2 表格驱动基准测试

```go
func BenchmarkFibonacci(b *testing.B) {
    benchmarks := []struct {
        name string
        n    int
    }{
        {"Fib10", 10},
        {"Fib20", 20},
        {"Fib30", 30},
    }
    
    for _, bm := range benchmarks {
        b.Run(bm.name, func(b *testing.B) {
            for i := 0; i < b.N; i++ {
                Fibonacci(bm.n)
            }
        })
    }
}

// 运行：go test -bench=Fibonacci -benchmem
```

---

### 2.3 重置计时器

```go
func BenchmarkWithSetup(b *testing.B) {
    // Setup（不计入性能测试）
    data := generateLargeDataset()
    
    b.ResetTimer() // 重置计时器
    
    for i := 0; i < b.N; i++ {
        processData(data)
    }
}
```

---

### 2.4 并行基准测试

```go
func BenchmarkParallel(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            // 测试代码
            result := expensiveOperation()
            _ = result
        }
    })
}
```

---

### 2.5 内存分配分析

```go
func BenchmarkStringConcat(b *testing.B) {
    b.ReportAllocs() // 报告内存分配
    
    for i := 0; i < b.N; i++ {
        var s string
        for j := 0; j < 100; j++ {
            s += "a"
        }
        _ = s
    }
}

func BenchmarkStringBuilder(b *testing.B) {
    b.ReportAllocs()
    
    for i := 0; i < b.N; i++ {
        var sb strings.Builder
        for j := 0; j < 100; j++ {
            sb.WriteString("a")
        }
        _ = sb.String()
    }
}

// 对比：
// BenchmarkStringConcat-8      20000    82549 ns/op   503992 B/op    99 allocs/op
// BenchmarkStringBuilder-8    500000     2847 ns/op      512 B/op     3 allocs/op
```

---

### 2.6 CPU Profiling

```bash
# 生成CPU profile
go test -bench=. -cpuprofile=cpu.prof

# 分析profile
go tool pprof cpu.prof

# 常用命令
(pprof) top10          # 显示前10个函数
(pprof) list FuncName  # 显示函数详情
(pprof) web            # 生成调用图（需要graphviz）
```

---

### 2.7 内存Profiling

```bash
# 生成内存profile
go test -bench=. -memprofile=mem.prof

# 分析
go tool pprof mem.prof

(pprof) top            # 按内存分配排序
(pprof) list FuncName  # 查看详情
```

---

### 2.8 性能对比

```go
// 保存基准结果
go test -bench=. > old.txt

// 修改代码后
go test -bench=. > new.txt

// 对比
go install golang.org/x/perf/cmd/benchstat@latest
benchstat old.txt new.txt
```

输出示例：
```
name        old time/op    new time/op    delta
Fibonacci   855ns ± 2%     721ns ± 1%   -15.67%  (p=0.000 n=10+10)

name        old alloc/op   new alloc/op   delta
Fibonacci   0.00B          0.00B           ~     (all equal)
```

---

## 3. 🏗️ 实战案例

### 3.1 案例：优化JSON序列化

```go
package benchmark

import (
    "encoding/json"
    "testing"
)

type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

// 原始方法
func BenchmarkJSONMarshal(b *testing.B) {
    user := User{ID: 1, Name: "Alice", Email: "alice@example.com"}
    
    b.ReportAllocs()
    for i := 0; i < b.N; i++ {
        _, err := json.Marshal(user)
        if err != nil {
            b.Fatal(err)
        }
    }
}

// 优化：复用encoder
func BenchmarkJSONEncoder(b *testing.B) {
    user := User{ID: 1, Name: "Alice", Email: "alice@example.com"}
    
    b.ReportAllocs()
    for i := 0; i < b.N; i++ {
        buf := new(bytes.Buffer)
        enc := json.NewEncoder(buf)
        err := enc.Encode(user)
        if err != nil {
            b.Fatal(err)
        }
    }
}

// 进一步优化：预分配buffer
func BenchmarkJSONEncoderPrealloc(b *testing.B) {
    user := User{ID: 1, Name: "Alice", Email: "alice@example.com"}
    buf := new(bytes.Buffer)
    
    b.ReportAllocs()
    for i := 0; i < b.N; i++ {
        buf.Reset()
        enc := json.NewEncoder(buf)
        err := enc.Encode(user)
        if err != nil {
            b.Fatal(err)
        }
    }
}
```

---

## 4. 💡 最佳实践

### 4.1 基准测试命名
```go
// ✅ 好：清晰描述测试内容
func BenchmarkFibonacci_Iterative(b *testing.B)
func BenchmarkFibonacci_Recursive(b *testing.B)

// ❌ 差
func BenchmarkTest1(b *testing.B)
```

### 4.2 避免编译器优化
```go
var result int

func BenchmarkSomething(b *testing.B) {
    var r int
    for i := 0; i < b.N; i++ {
        r = expensiveOperation()
    }
    result = r // 防止被优化掉
}
```

### 4.3 使用b.StopTimer/StartTimer
```go
func BenchmarkWithCleanup(b *testing.B) {
    for i := 0; i < b.N; i++ {
        b.StopTimer()
        setup()
        b.StartTimer()
        
        operation()
        
        b.StopTimer()
        cleanup()
        b.StartTimer()
    }
}
```

### 4.4 多次运行取平均
```bash
go test -bench=. -count=10
```

### 4.5 固定CPU核心数
```bash
go test -bench=. -cpu=1,2,4,8
```

---

## 5. ⚠️ 常见问题

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---

**最后更新**: 2025-10-29
