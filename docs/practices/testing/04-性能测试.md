# 性能测试

**难度**: 中级 | **预计阅读**: 20分钟 | **前置知识**: 基准测试、pprof

---

## 📋 目录

- [1. 📖 概念介绍](#1--概念介绍)
- [2. 🎯 核心知识点](#2--核心知识点)
  - [2.1 基准测试基础](#21-基准测试基础)
  - [2.2 表格驱动基准测试](#22-表格驱动基准测试)
  - [2.3 重置计时器](#23-重置计时器)
  - [2.4 并行基准测试](#24-并行基准测试)
  - [2.5 内存分配分析](#25-内存分配分析)
  - [2.6 CPU Profiling](#26-cpu-profiling)
  - [2.7 内存Profiling](#27-内存profiling)
  - [2.8 性能对比](#28-性能对比)
- [3. 🏗️ 实战案例](#3-️-实战案例)
- [4. 💡 最佳实践](#4--最佳实践)
- [5. ⚠️ 常见问题](#5-️-常见问题)
- [6. 📚 相关资源](#6--相关资源)

---

## 1. 📖 概念介绍

性能测试用于衡量代码的执行效率，包括基准测试（Benchmark）、性能分析（Profiling）和内存分析。Go提供了强大的内置工具支持性能测试。

---

## 2. 🎯 核心知识点

### 2.1 基准测试基础

```go
package benchmark

import "testing"

func Fibonacci(n int) int {
    if n < 2 {
        return n
    }
    return Fibonacci(n-1) + Fibonacci(n-2)
}

// 基准测试函数以Benchmark开头
func BenchmarkFibonacci(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Fibonacci(10)
    }
}

// 运行：go test -bench=. -benchmem
```

输出示例：
```
BenchmarkFibonacci-8    2000000    855 ns/op    0 B/op    0 allocs/op
```

---

### 2.2 表格驱动基准测试

```go
func BenchmarkFibonacci(b *testing.B) {
    benchmarks := []struct {
        name string
        n    int
    }{
        {"Fib10", 10},
        {"Fib20", 20},
        {"Fib30", 30},
    }
    
    for _, bm := range benchmarks {
        b.Run(bm.name, func(b *testing.B) {
            for i := 0; i < b.N; i++ {
                Fibonacci(bm.n)
            }
        })
    }
}

// 运行：go test -bench=Fibonacci -benchmem
```

---

### 2.3 重置计时器

```go
func BenchmarkWithSetup(b *testing.B) {
    // Setup（不计入性能测试）
    data := generateLargeDataset()
    
    b.ResetTimer() // 重置计时器
    
    for i := 0; i < b.N; i++ {
        processData(data)
    }
}
```

---

### 2.4 并行基准测试

```go
func BenchmarkParallel(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            // 测试代码
            result := expensiveOperation()
            _ = result
        }
    })
}
```

---

### 2.5 内存分配分析

```go
func BenchmarkStringConcat(b *testing.B) {
    b.ReportAllocs() // 报告内存分配
    
    for i := 0; i < b.N; i++ {
        var s string
        for j := 0; j < 100; j++ {
            s += "a"
        }
        _ = s
    }
}

func BenchmarkStringBuilder(b *testing.B) {
    b.ReportAllocs()
    
    for i := 0; i < b.N; i++ {
        var sb strings.Builder
        for j := 0; j < 100; j++ {
            sb.WriteString("a")
        }
        _ = sb.String()
    }
}

// 对比：
// BenchmarkStringConcat-8      20000    82549 ns/op   503992 B/op    99 allocs/op
// BenchmarkStringBuilder-8    500000     2847 ns/op      512 B/op     3 allocs/op
```

---

### 2.6 CPU Profiling

```bash
# 生成CPU profile
go test -bench=. -cpuprofile=cpu.prof

# 分析profile
go tool pprof cpu.prof

# 常用命令
(pprof) top10          # 显示前10个函数
(pprof) list FuncName  # 显示函数详情
(pprof) web            # 生成调用图（需要graphviz）
```

---

### 2.7 内存Profiling

```bash
# 生成内存profile
go test -bench=. -memprofile=mem.prof

# 分析
go tool pprof mem.prof

(pprof) top            # 按内存分配排序
(pprof) list FuncName  # 查看详情
```

---

### 2.8 性能对比

```go
// 保存基准结果
go test -bench=. > old.txt

// 修改代码后
go test -bench=. > new.txt

// 对比
go install golang.org/x/perf/cmd/benchstat@latest
benchstat old.txt new.txt
```

输出示例：
```
name        old time/op    new time/op    delta
Fibonacci   855ns ± 2%     721ns ± 1%   -15.67%  (p=0.000 n=10+10)

name        old alloc/op   new alloc/op   delta
Fibonacci   0.00B          0.00B           ~     (all equal)
```

---

## 3. 🏗️ 实战案例

### 3.1 案例：优化JSON序列化

```go
package benchmark

import (
    "encoding/json"
    "testing"
)

type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

// 原始方法
func BenchmarkJSONMarshal(b *testing.B) {
    user := User{ID: 1, Name: "Alice", Email: "alice@example.com"}
    
    b.ReportAllocs()
    for i := 0; i < b.N; i++ {
        _, err := json.Marshal(user)
        if err != nil {
            b.Fatal(err)
        }
    }
}

// 优化：复用encoder
func BenchmarkJSONEncoder(b *testing.B) {
    user := User{ID: 1, Name: "Alice", Email: "alice@example.com"}
    
    b.ReportAllocs()
    for i := 0; i < b.N; i++ {
        buf := new(bytes.Buffer)
        enc := json.NewEncoder(buf)
        err := enc.Encode(user)
        if err != nil {
            b.Fatal(err)
        }
    }
}

// 进一步优化：预分配buffer
func BenchmarkJSONEncoderPrealloc(b *testing.B) {
    user := User{ID: 1, Name: "Alice", Email: "alice@example.com"}
    buf := new(bytes.Buffer)
    
    b.ReportAllocs()
    for i := 0; i < b.N; i++ {
        buf.Reset()
        enc := json.NewEncoder(buf)
        err := enc.Encode(user)
        if err != nil {
            b.Fatal(err)
        }
    }
}
```

---

## 4. 💡 最佳实践

### 4.1 基准测试命名
```go
// ✅ 好：清晰描述测试内容
func BenchmarkFibonacci_Iterative(b *testing.B)
func BenchmarkFibonacci_Recursive(b *testing.B)

// ❌ 差
func BenchmarkTest1(b *testing.B)
```

### 4.2 避免编译器优化
```go
var result int

func BenchmarkSomething(b *testing.B) {
    var r int
    for i := 0; i < b.N; i++ {
        r = expensiveOperation()
    }
    result = r // 防止被优化掉
}
```

### 4.3 使用b.StopTimer/StartTimer
```go
func BenchmarkWithCleanup(b *testing.B) {
    for i := 0; i < b.N; i++ {
        b.StopTimer()
        setup()
        b.StartTimer()
        
        operation()
        
        b.StopTimer()
        cleanup()
        b.StartTimer()
    }
}
```

### 4.4 多次运行取平均
```bash
go test -bench=. -count=10
```

### 4.5 固定CPU核心数
```bash
go test -bench=. -cpu=1,2,4,8
```

---

## 5. ⚠️ 常见问题

**Q1: b.N是什么？**
- testing框架自动调整的迭代次数
- 确保测试运行至少1秒
- 不要在测试中修改b.N

**Q2: 如何选择合适的基准测试时间？**
```bash
# 默认1秒
go test -bench=.

# 运行10秒（更准确）
go test -bench=. -benchtime=10s

# 运行固定次数
go test -bench=. -benchtime=1000000x
```

**Q3: 为什么结果不稳定？**
- CPU频率调节
- 其他进程干扰
- GC影响
- 解决：多次运行、禁用Turbo Boost、关闭其他程序

**Q4: 如何benchmark HTTP handler？**
```go
func BenchmarkHandler(b *testing.B) {
    handler := setupHandler()
    req := httptest.NewRequest("GET", "/", nil)
    
    b.ReportAllocs()
    for i := 0; i < b.N; i++ {
        rec := httptest.NewRecorder()
        handler.ServeHTTP(rec, req)
    }
}
```

---

## 6. 📚 相关资源

- [Go Benchmark Guide](https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go)
- [pprof Documentation](https://github.com/google/pprof)
- [benchstat Tool](https://pkg.go.dev/golang.org/x/perf/cmd/benchstat)

**下一步**: [05-测试覆盖率](./05-测试覆盖率.md)

---

**最后更新**: 2025-10-28
