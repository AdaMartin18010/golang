# 表格驱动测试

**难度**: 中级 | **预计阅读**: 15分钟 | **前置知识**: 单元测试基础

---

## 📖 概念介绍

表格驱动测试（Table-Driven Tests）是Go社区推荐的测试模式，通过定义测试用例表格来组织测试数据，使测试更加简洁、可维护和易于扩展。

---

## 🎯 核心知识点

### 1. 基础表格驱动测试

```go
package math

import "testing"

func Add(a, b int) int {
    return a + b
}

func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a    int
        b    int
        want int
    }{
        {"正数相加", 2, 3, 5},
        {"负数相加", -1, -2, -3},
        {"零值", 0, 5, 5},
        {"大数", 1000000, 2000000, 3000000},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := Add(tt.a, tt.b)
            if got != tt.want {
                t.Errorf("Add(%d, %d) = %d, want %d", tt.a, tt.b, got, tt.want)
            }
        })
    }
}
```

---

### 2. 使用t.Run进行子测试

```go
func TestDivide(t *testing.T) {
    tests := []struct {
        name      string
        dividend  float64
        divisor   float64
        want      float64
        wantError bool
    }{
        {
            name:      "正常除法",
            dividend:  10,
            divisor:   2,
            want:      5,
            wantError: false,
        },
        {
            name:      "除以零",
            dividend:  10,
            divisor:   0,
            want:      0,
            wantError: true,
        },
        {
            name:      "负数除法",
            dividend:  -10,
            divisor:   2,
            want:      -5,
            wantError: false,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := Divide(tt.dividend, tt.divisor)
            
            if (err != nil) != tt.wantError {
                t.Errorf("Divide() error = %v, wantError %v", err, tt.wantError)
                return
            }
            
            if !tt.wantError && got != tt.want {
                t.Errorf("Divide() = %v, want %v", got, tt.want)
            }
        })
    }
}

// 运行特定子测试
// go test -run TestDivide/正常除法
```

---

### 3. 复杂结构的测试

```go
type User struct {
    ID    int
    Name  string
    Email string
    Age   int
}

func ValidateUser(u *User) error {
    if u.Name == "" {
        return errors.New("name is required")
    }
    if u.Email == "" {
        return errors.New("email is required")
    }
    if u.Age < 0 || u.Age > 150 {
        return errors.New("invalid age")
    }
    return nil
}

func TestValidateUser(t *testing.T) {
    tests := []struct {
        name    string
        user    *User
        wantErr string
    }{
        {
            name: "有效用户",
            user: &User{ID: 1, Name: "Alice", Email: "alice@example.com", Age: 25},
            wantErr: "",
        },
        {
            name: "缺少名字",
            user: &User{ID: 2, Email: "bob@example.com", Age: 30},
            wantErr: "name is required",
        },
        {
            name: "缺少邮箱",
            user: &User{ID: 3, Name: "Charlie", Age: 35},
            wantErr: "email is required",
        },
        {
            name: "年龄无效",
            user: &User{ID: 4, Name: "Dave", Email: "dave@example.com", Age: -5},
            wantErr: "invalid age",
        },
        {
            name: "年龄过大",
            user: &User{ID: 5, Name: "Eve", Email: "eve@example.com", Age: 200},
            wantErr: "invalid age",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := ValidateUser(tt.user)
            
            if tt.wantErr == "" {
                if err != nil {
                    t.Errorf("ValidateUser() unexpected error = %v", err)
                }
            } else {
                if err == nil {
                    t.Errorf("ValidateUser() expected error %q, got nil", tt.wantErr)
                } else if err.Error() != tt.wantErr {
                    t.Errorf("ValidateUser() error = %q, want %q", err.Error(), tt.wantErr)
                }
            }
        })
    }
}
```

---

### 4. 并行测试

```go
func TestParallel(t *testing.T) {
    tests := []struct {
        name  string
        input int
        want  int
    }{
        {"test1", 1, 2},
        {"test2", 2, 4},
        {"test3", 3, 6},
        {"test4", 4, 8},
    }
    
    for _, tt := range tests {
        tt := tt // 捕获range变量
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel() // 标记为并行
            
            got := tt.input * 2
            if got != tt.want {
                t.Errorf("got %d, want %d", got, tt.want)
            }
        })
    }
}
```

---

### 5. 测试辅助函数

```go
// 创建辅助函数简化测试
func assertNoError(t *testing.T, err error) {
    t.Helper()
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
}

func assertEqual(t *testing.T, got, want interface{}) {
    t.Helper()
    if got != want {
        t.Errorf("got %v, want %v", got, want)
    }
}

func TestWithHelpers(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"case1", 1, 1, 2},
        {"case2", 2, 3, 5},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := Add(tt.a, tt.b)
            assertEqual(t, got, tt.want)
        })
    }
}
```

---

## 🏗️ 实战案例

### 案例：HTTP Handler测试

```go
func HandleUser(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodGet {
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }
    
    id := r.URL.Query().Get("id")
    if id == "" {
        http.Error(w, "Missing id", http.StatusBadRequest)
        return
    }
    
    w.WriteHeader(http.StatusOK)
    fmt.Fprintf(w, `{"id":"%s","name":"User %s"}`, id, id)
}

func TestHandleUser(t *testing.T) {
    tests := []struct {
        name           string
        method         string
        query          string
        wantStatusCode int
        wantBody       string
    }{
        {
            name:           "正常请求",
            method:         http.MethodGet,
            query:          "?id=123",
            wantStatusCode: http.StatusOK,
            wantBody:       `{"id":"123","name":"User 123"}`,
        },
        {
            name:           "缺少ID",
            method:         http.MethodGet,
            query:          "",
            wantStatusCode: http.StatusBadRequest,
            wantBody:       "Missing id\n",
        },
        {
            name:           "错误的方法",
            method:         http.MethodPost,
            query:          "?id=123",
            wantStatusCode: http.StatusMethodNotAllowed,
            wantBody:       "Method not allowed\n",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            req := httptest.NewRequest(tt.method, "/user"+tt.query, nil)
            rec := httptest.NewRecorder()
            
            HandleUser(rec, req)
            
            if rec.Code != tt.wantStatusCode {
                t.Errorf("status code = %d, want %d", rec.Code, tt.wantStatusCode)
            }
            
            if rec.Body.String() != tt.wantBody {
                t.Errorf("body = %q, want %q", rec.Body.String(), tt.wantBody)
            }
        })
    }
}
```

---

## 💡 最佳实践

### 1. 命名清晰
```go
// ✅ 好：描述性强
{"两个正数相加返回和", 2, 3, 5}

// ❌ 差：不清晰
{"test1", 2, 3, 5}
```

### 2. 一个表格测试一个函数
```go
// ✅ 好
func TestAdd(t *testing.T) { /* 只测试Add */ }
func TestSubtract(t *testing.T) { /* 只测试Subtract */ }

// ❌ 差
func TestMath(t *testing.T) { /* 测试多个函数 */ }
```

### 3. 测试用例要全面
```go
tests := []struct{...}{
    // 正常情况
    {"正常输入", normalInput, normalOutput},
    // 边界情况
    {"零值", 0, expected},
    {"最大值", math.MaxInt, expected},
    // 错误情况
    {"无效输入", invalidInput, error},
}
```

### 4. 使用t.Helper()
```go
func checkResult(t *testing.T, got, want int) {
    t.Helper() // 错误会指向调用者
    if got != want {
        t.Errorf("got %d, want %d", got, want)
    }
}
```

### 5. 考虑并行测试
```go
// 测试互不影响时使用
t.Parallel()
```

---

## ⚠️ 常见问题

**Q1: 何时使用表格驱动测试？**
- 有多个类似的测试用例
- 测试逻辑相同，只是输入输出不同
- 需要测试边界条件和错误情况

**Q2: 如何组织大型测试表格？**
```go
// 可以分组
tests := []struct{...}{
    // 正常情况
    {...},
    {...},
    // 边界情况  
    {...},
    // 错误情况
    {...},
}
```

**Q3: t.Run的好处？**
- 可以单独运行某个子测试
- 失败时更容易定位
- 支持并行测试

**Q4: 如何处理setup和cleanup？**
```go
t.Run("test", func(t *testing.T) {
    // Setup
    resource := setupResource()
    
    // Cleanup
    t.Cleanup(func() {
        resource.Close()
    })
    
    // Test logic
})
```

---

## 📚 相关资源

- [Table Driven Tests Wiki](https://go.dev/wiki/TableDrivenTests)
- [Go Testing Style Guide](https://github.com/golang/go/wiki/TestComments)

**下一步**: [03-集成测试](./03-集成测试.md)

---

**最后更新**: 2025-10-28

