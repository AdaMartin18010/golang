# Go表格驱动测试

> **简介**: Go表格驱动测试完整指南，包括基本模式、高级技巧和最佳实践

> **版本**: Go 1.25.3  
> **难度**: ⭐⭐⭐  
> **标签**: #测试 #表格驱动 #TDD

---

## 📚 目录

1. [基本模式](#基本模式)
2. [子测试](#子测试)
3. [高级用法](#高级用法)
4. [常见场景](#常见场景)
5. [最佳实践](#最佳实践)

---

## 1. 基本模式

### 简单测试表格

```go
func TestAdd(t *testing.T) {
    tests := []struct {
        a, b int
        want int
    }{
        {1, 2, 3},
        {0, 0, 0},
        {-1, 1, 0},
        {100, 200, 300},
    }
    
    for _, tt := range tests {
        got := Add(tt.a, tt.b)
        if got != tt.want {
            t.Errorf("Add(%d, %d) = %d; want %d", tt.a, tt.b, got, tt.want)
        }
    }
}
```

---

### 带名称的测试表格

```go
func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"positive numbers", 1, 2, 3},
        {"zero values", 0, 0, 0},
        {"negative and positive", -1, 1, 0},
        {"large numbers", 100, 200, 300},
    }
    
    for _, tt := range tests {
        got := Add(tt.a, tt.b)
        if got != tt.want {
            t.Errorf("%s: Add(%d, %d) = %d; want %d", 
                tt.name, tt.a, tt.b, got, tt.want)
        }
    }
}
```

---

## 2. 子测试

### 使用t.Run

```go
func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"positive", 1, 2, 3},
        {"zero", 0, 0, 0},
        {"negative", -1, 1, 0},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := Add(tt.a, tt.b)
            if got != tt.want {
                t.Errorf("got %d, want %d", got, tt.want)
            }
        })
    }
}
```

**运行特定子测试**:
```bash
go test -run TestAdd/positive
go test -run TestAdd/zero
```

---

### 并行子测试

```go
func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"case1", 1, 2, 3},
        {"case2", 0, 0, 0},
        {"case3", -1, 1, 0},
    }
    
    for _, tt := range tests {
        tt := tt  // 捕获循环变量
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()  // 并行运行
            
            got := Add(tt.a, tt.b)
            if got != tt.want {
                t.Errorf("got %d, want %d", got, tt.want)
            }
        })
    }
}
```

---

## 3. 高级用法

### 带错误处理

```go
func TestDivide(t *testing.T) {
    tests := []struct {
        name    string
        a, b    int
        want    int
        wantErr bool
    }{
        {"normal", 10, 2, 5, false},
        {"divide by zero", 10, 0, 0, true},
        {"negative", -10, 2, -5, false},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := Divide(tt.a, tt.b)
            
            if tt.wantErr {
                if err == nil {
                    t.Error("expected error but got none")
                }
                return
            }
            
            if err != nil {
                t.Fatalf("unexpected error: %v", err)
            }
            
            if got != tt.want {
                t.Errorf("got %d, want %d", got, tt.want)
            }
        })
    }
}
```

---

### 使用setup和cleanup

```go
func TestUserService(t *testing.T) {
    tests := []struct {
        name string
        id   int
        want *User
    }{
        {"existing user", 1, &User{ID: 1, Name: "Alice"}},
        {"non-existing user", 999, nil},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Setup
            db := setupTestDB(t)
            defer cleanupTestDB(t, db)
            
            service := NewUserService(db)
            
            // Test
            got, err := service.GetUser(tt.id)
            if err != nil {
                t.Fatalf("unexpected error: %v", err)
            }
            
            if !reflect.DeepEqual(got, tt.want) {
                t.Errorf("got %+v, want %+v", got, tt.want)
            }
        })
    }
}
```

---

### 使用辅助函数

```go
func TestCalculate(t *testing.T) {
    tests := []struct {
        name string
        op   string
        a, b int
        want int
    }{
        {"add", "+", 2, 3, 5},
        {"subtract", "-", 5, 3, 2},
        {"multiply", "*", 2, 3, 6},
        {"divide", "/", 6, 2, 3},
    }
    
    assertEqual := func(t *testing.T, got, want int) {
        t.Helper()
        if got != want {
            t.Errorf("got %d, want %d", got, want)
        }
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := Calculate(tt.op, tt.a, tt.b)
            assertEqual(t, got, tt.want)
        })
    }
}
```

---

## 4. 常见场景

### 场景1: HTTP Handler测试

```go
func TestUserHandler(t *testing.T) {
    tests := []struct {
        name           string
        method         string
        path           string
        body           string
        wantStatusCode int
        wantBody       string
    }{
        {
            "get user",
            "GET",
            "/users/1",
            "",
            200,
            `{"id":1,"name":"Alice"}`,
        },
        {
            "user not found",
            "GET",
            "/users/999",
            "",
            404,
            `{"error":"not found"}`,
        },
        {
            "create user",
            "POST",
            "/users",
            `{"name":"Bob"}`,
            201,
            `{"id":2,"name":"Bob"}`,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            req := httptest.NewRequest(tt.method, tt.path, 
                strings.NewReader(tt.body))
            w := httptest.NewRecorder()
            
            handler.ServeHTTP(w, req)
            
            if w.Code != tt.wantStatusCode {
                t.Errorf("status = %d; want %d", w.Code, tt.wantStatusCode)
            }
            
            if got := strings.TrimSpace(w.Body.String()); got != tt.wantBody {
                t.Errorf("body = %s; want %s", got, tt.wantBody)
            }
        })
    }
}
```

---

### 场景2: JSON编解码测试

```go
func TestUserJSON(t *testing.T) {
    tests := []struct {
        name string
        user User
        want string
    }{
        {
            "basic user",
            User{ID: 1, Name: "Alice", Email: "alice@example.com"},
            `{"id":1,"name":"Alice","email":"alice@example.com"}`,
        },
        {
            "empty email",
            User{ID: 2, Name: "Bob"},
            `{"id":2,"name":"Bob","email":""}`,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            data, err := json.Marshal(tt.user)
            if err != nil {
                t.Fatalf("marshal error: %v", err)
            }
            
            got := string(data)
            if got != tt.want {
                t.Errorf("got %s, want %s", got, tt.want)
            }
            
            // 反向测试
            var user User
            if err := json.Unmarshal([]byte(tt.want), &user); err != nil {
                t.Fatalf("unmarshal error: %v", err)
            }
            
            if !reflect.DeepEqual(user, tt.user) {
                t.Errorf("roundtrip failed: got %+v, want %+v", user, tt.user)
            }
        })
    }
}
```

---

### 场景3: 数据库查询测试

```go
func TestUserRepository(t *testing.T) {
    tests := []struct {
        name    string
        setup   func(*sql.DB)
        query   string
        want    []User
        wantErr bool
    }{
        {
            "find all users",
            func(db *sql.DB) {
                db.Exec("INSERT INTO users (name) VALUES ('Alice'), ('Bob')")
            },
            "SELECT * FROM users",
            []User{
                {ID: 1, Name: "Alice"},
                {ID: 2, Name: "Bob"},
            },
            false,
        },
        {
            "no users",
            func(db *sql.DB) {},
            "SELECT * FROM users",
            []User{},
            false,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            db := setupTestDB(t)
            defer cleanupTestDB(t, db)
            
            tt.setup(db)
            
            got, err := QueryUsers(db, tt.query)
            if (err != nil) != tt.wantErr {
                t.Fatalf("error = %v, wantErr %v", err, tt.wantErr)
            }
            
            if !reflect.DeepEqual(got, tt.want) {
                t.Errorf("got %+v, want %+v", got, tt.want)
            }
        })
    }
}
```

---

### 场景4: 错误类型测试

```go
func TestValidation(t *testing.T) {
    tests := []struct {
        name    string
        input   User
        wantErr error
    }{
        {
            "valid user",
            User{Name: "Alice", Email: "alice@example.com"},
            nil,
        },
        {
            "empty name",
            User{Email: "alice@example.com"},
            ErrEmptyName,
        },
        {
            "invalid email",
            User{Name: "Alice", Email: "invalid"},
            ErrInvalidEmail,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := Validate(tt.input)
            
            if tt.wantErr == nil {
                if err != nil {
                    t.Errorf("unexpected error: %v", err)
                }
                return
            }
            
            if !errors.Is(err, tt.wantErr) {
                t.Errorf("error = %v, want %v", err, tt.wantErr)
            }
        })
    }
}
```

---

## 5. 最佳实践

### 1. 使用有意义的测试名称

```go
// ✅ 推荐：描述性名称
tests := []struct {
    name string
    // ...
}{
    {"empty input returns error"},
    {"valid input returns success"},
    {"duplicate name returns conflict error"},
}

// ❌ 不推荐：无意义的名称
tests := []struct {
    name string
    // ...
}{
    {"test1"},
    {"test2"},
    {"test3"},
}
```

---

### 2. 组织测试数据

```go
// ✅ 推荐：清晰的结构
tests := []struct {
    name    string
    input   string
    want    string
    wantErr bool
}{
    {
        name:    "normal case",
        input:   "hello",
        want:    "HELLO",
        wantErr: false,
    },
}

// ❌ 不推荐：混乱的字段顺序
tests := []struct {
    wantErr bool
    want    string
    name    string
    input   string
}{
    {false, "HELLO", "normal case", "hello"},
}
```

---

### 3. 使用表格驱动的边界条件

```go
func TestStringLength(t *testing.T) {
    tests := []struct {
        name  string
        input string
        want  int
    }{
        {"empty string", "", 0},
        {"single char", "a", 1},
        {"normal string", "hello", 5},
        {"unicode string", "你好", 2},
        {"very long string", strings.Repeat("a", 10000), 10000},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := StringLength(tt.input)
            if got != tt.want {
                t.Errorf("got %d, want %d", got, tt.want)
            }
        })
    }
}
```

---

### 4. 避免测试之间的依赖

```go
// ✅ 推荐：独立测试
func TestUserService(t *testing.T) {
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            db := setupTestDB(t)  // 每个测试独立的DB
            defer cleanupTestDB(t, db)
            // 测试代码
        })
    }
}

// ❌ 不推荐：共享状态
func TestUserService(t *testing.T) {
    db := setupTestDB(t)  // 共享DB
    defer cleanupTestDB(t, db)
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 测试可能相互影响
        })
    }
}
```

---

### 5. 使用辅助函数提高可读性

```go
// ✅ 推荐：使用辅助函数
func assertUser(t *testing.T, got, want *User) {
    t.Helper()
    
    if got.ID != want.ID {
        t.Errorf("ID: got %d, want %d", got.ID, want.ID)
    }
    if got.Name != want.Name {
        t.Errorf("Name: got %s, want %s", got.Name, want.Name)
    }
    if got.Email != want.Email {
        t.Errorf("Email: got %s, want %s", got.Email, want.Email)
    }
}

func TestGetUser(t *testing.T) {
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := GetUser(tt.id)
            assertUser(t, got, tt.want)
        })
    }
}
```

---

## 🎯 完整示例

```go
package user

import (
    "errors"
    "reflect"
    "testing"
)

func TestUserValidation(t *testing.T) {
    tests := []struct {
        name    string
        user    User
        wantErr error
    }{
        {
            name: "valid user",
            user: User{
                Name:  "Alice",
                Email: "alice@example.com",
                Age:   25,
            },
            wantErr: nil,
        },
        {
            name: "empty name",
            user: User{
                Email: "alice@example.com",
                Age:   25,
            },
            wantErr: ErrEmptyName,
        },
        {
            name: "invalid email",
            user: User{
                Name:  "Alice",
                Email: "invalid",
                Age:   25,
            },
            wantErr: ErrInvalidEmail,
        },
        {
            name: "negative age",
            user: User{
                Name:  "Alice",
                Email: "alice@example.com",
                Age:   -1,
            },
            wantErr: ErrInvalidAge,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := ValidateUser(tt.user)
            
            if tt.wantErr == nil {
                if err != nil {
                    t.Errorf("unexpected error: %v", err)
                }
                return
            }
            
            if !errors.Is(err, tt.wantErr) {
                t.Errorf("error = %v, want %v", err, tt.wantErr)
            }
        })
    }
}
```

---

## 🔗 相关资源

- [单元测试](./01-单元测试.md)
- [集成测试](./03-集成测试.md)
- [测试最佳实践](./07-测试最佳实践.md)

---

**最后更新**: 2025-10-28  
**Go版本**: 1.25.3
