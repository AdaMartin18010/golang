# Goè¡¨æ ¼é©±åŠ¨æµ‹è¯•

> **ç®€ä»‹**: Goè¡¨æ ¼é©±åŠ¨æµ‹è¯•å®Œæ•´æŒ‡å—ï¼ŒåŒ…æ‹¬åŸºæœ¬æ¨¡å¼ã€é«˜çº§æŠ€å·§å’Œæœ€ä½³å®è·µ

> **ç‰ˆæœ¬**: Go 1.25.3  
> **éš¾åº¦**: â­â­â­  
> **æ ‡ç­¾**: #æµ‹è¯• #è¡¨æ ¼é©±åŠ¨ #TDD

---

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¨¡å¼](#åŸºæœ¬æ¨¡å¼)
2. [å­æµ‹è¯•](#å­æµ‹è¯•)
3. [é«˜çº§ç”¨æ³•](#é«˜çº§ç”¨æ³•)
4. [å¸¸è§åœºæ™¯](#å¸¸è§åœºæ™¯)
5. [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

---

## 1. åŸºæœ¬æ¨¡å¼

### ç®€å•æµ‹è¯•è¡¨æ ¼

```go
func TestAdd(t *testing.T) {
    tests := []struct {
        a, b int
        want int
    }{
        {1, 2, 3},
        {0, 0, 0},
        {-1, 1, 0},
        {100, 200, 300},
    }
    
    for _, tt := range tests {
        got := Add(tt.a, tt.b)
        if got != tt.want {
            t.Errorf("Add(%d, %d) = %d; want %d", tt.a, tt.b, got, tt.want)
        }
    }
}
```

---

### å¸¦åç§°çš„æµ‹è¯•è¡¨æ ¼

```go
func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"positive numbers", 1, 2, 3},
        {"zero values", 0, 0, 0},
        {"negative and positive", -1, 1, 0},
        {"large numbers", 100, 200, 300},
    }
    
    for _, tt := range tests {
        got := Add(tt.a, tt.b)
        if got != tt.want {
            t.Errorf("%s: Add(%d, %d) = %d; want %d", 
                tt.name, tt.a, tt.b, got, tt.want)
        }
    }
}
```

---

## 2. å­æµ‹è¯•

### ä½¿ç”¨t.Run

```go
func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"positive", 1, 2, 3},
        {"zero", 0, 0, 0},
        {"negative", -1, 1, 0},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := Add(tt.a, tt.b)
            if got != tt.want {
                t.Errorf("got %d, want %d", got, tt.want)
            }
        })
    }
}
```

**è¿è¡Œç‰¹å®šå­æµ‹è¯•**:
```bash
go test -run TestAdd/positive
go test -run TestAdd/zero
```

---

### å¹¶è¡Œå­æµ‹è¯•

```go
func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"case1", 1, 2, 3},
        {"case2", 0, 0, 0},
        {"case3", -1, 1, 0},
    }
    
    for _, tt := range tests {
        tt := tt  // æ•è·å¾ªç¯å˜é‡
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()  // å¹¶è¡Œè¿è¡Œ
            
            got := Add(tt.a, tt.b)
            if got != tt.want {
                t.Errorf("got %d, want %d", got, tt.want)
            }
        })
    }
}
```

---

## 3. é«˜çº§ç”¨æ³•

### å¸¦é”™è¯¯å¤„ç†

```go
func TestDivide(t *testing.T) {
    tests := []struct {
        name    string
        a, b    int
        want    int
        wantErr bool
    }{
        {"normal", 10, 2, 5, false},
        {"divide by zero", 10, 0, 0, true},
        {"negative", -10, 2, -5, false},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := Divide(tt.a, tt.b)
            
            if tt.wantErr {
                if err == nil {
                    t.Error("expected error but got none")
                }
                return
            }
            
            if err != nil {
                t.Fatalf("unexpected error: %v", err)
            }
            
            if got != tt.want {
                t.Errorf("got %d, want %d", got, tt.want)
            }
        })
    }
}
```

---

### ä½¿ç”¨setupå’Œcleanup

```go
func TestUserService(t *testing.T) {
    tests := []struct {
        name string
        id   int
        want *User
    }{
        {"existing user", 1, &User{ID: 1, Name: "Alice"}},
        {"non-existing user", 999, nil},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Setup
            db := setupTestDB(t)
            defer cleanupTestDB(t, db)
            
            service := NewUserService(db)
            
            // Test
            got, err := service.GetUser(tt.id)
            if err != nil {
                t.Fatalf("unexpected error: %v", err)
            }
            
            if !reflect.DeepEqual(got, tt.want) {
                t.Errorf("got %+v, want %+v", got, tt.want)
            }
        })
    }
}
```

---

### ä½¿ç”¨è¾…åŠ©å‡½æ•°

```go
func TestCalculate(t *testing.T) {
    tests := []struct {
        name string
        op   string
        a, b int
        want int
    }{
        {"add", "+", 2, 3, 5},
        {"subtract", "-", 5, 3, 2},
        {"multiply", "*", 2, 3, 6},
        {"divide", "/", 6, 2, 3},
    }
    
    assertEqual := func(t *testing.T, got, want int) {
        t.Helper()
        if got != want {
            t.Errorf("got %d, want %d", got, want)
        }
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := Calculate(tt.op, tt.a, tt.b)
            assertEqual(t, got, tt.want)
        })
    }
}
```

---

## 4. å¸¸è§åœºæ™¯

### åœºæ™¯1: HTTP Handleræµ‹è¯•

```go
func TestUserHandler(t *testing.T) {
    tests := []struct {
        name           string
        method         string
        path           string
        body           string
        wantStatusCode int
        wantBody       string
    }{
        {
            "get user",
            "GET",
            "/users/1",
            "",
            200,
            `{"id":1,"name":"Alice"}`,
        },
        {
            "user not found",
            "GET",
            "/users/999",
            "",
            404,
            `{"error":"not found"}`,
        },
        {
            "create user",
            "POST",
            "/users",
            `{"name":"Bob"}`,
            201,
            `{"id":2,"name":"Bob"}`,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            req := httptest.NewRequest(tt.method, tt.path, 
                strings.NewReader(tt.body))
            w := httptest.NewRecorder()
            
            handler.ServeHTTP(w, req)
            
            if w.Code != tt.wantStatusCode {
                t.Errorf("status = %d; want %d", w.Code, tt.wantStatusCode)
            }
            
            if got := strings.TrimSpace(w.Body.String()); got != tt.wantBody {
                t.Errorf("body = %s; want %s", got, tt.wantBody)
            }
        })
    }
}
```

---

### åœºæ™¯2: JSONç¼–è§£ç æµ‹è¯•

```go
func TestUserJSON(t *testing.T) {
    tests := []struct {
        name string
        user User
        want string
    }{
        {
            "basic user",
            User{ID: 1, Name: "Alice", Email: "alice@example.com"},
            `{"id":1,"name":"Alice","email":"alice@example.com"}`,
        },
        {
            "empty email",
            User{ID: 2, Name: "Bob"},
            `{"id":2,"name":"Bob","email":""}`,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            data, err := json.Marshal(tt.user)
            if err != nil {
                t.Fatalf("marshal error: %v", err)
            }
            
            got := string(data)
            if got != tt.want {
                t.Errorf("got %s, want %s", got, tt.want)
            }
            
            // åå‘æµ‹è¯•
            var user User
            if err := json.Unmarshal([]byte(tt.want), &user); err != nil {
                t.Fatalf("unmarshal error: %v", err)
            }
            
            if !reflect.DeepEqual(user, tt.user) {
                t.Errorf("roundtrip failed: got %+v, want %+v", user, tt.user)
            }
        })
    }
}
```

---

### åœºæ™¯3: æ•°æ®åº“æŸ¥è¯¢æµ‹è¯•

```go
func TestUserRepository(t *testing.T) {
    tests := []struct {
        name    string
        setup   func(*sql.DB)
        query   string
        want    []User
        wantErr bool
    }{
        {
            "find all users",
            func(db *sql.DB) {
                db.Exec("INSERT INTO users (name) VALUES ('Alice'), ('Bob')")
            },
            "SELECT * FROM users",
            []User{
                {ID: 1, Name: "Alice"},
                {ID: 2, Name: "Bob"},
            },
            false,
        },
        {
            "no users",
            func(db *sql.DB) {},
            "SELECT * FROM users",
            []User{},
            false,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            db := setupTestDB(t)
            defer cleanupTestDB(t, db)
            
            tt.setup(db)
            
            got, err := QueryUsers(db, tt.query)
            if (err != nil) != tt.wantErr {
                t.Fatalf("error = %v, wantErr %v", err, tt.wantErr)
            }
            
            if !reflect.DeepEqual(got, tt.want) {
                t.Errorf("got %+v, want %+v", got, tt.want)
            }
        })
    }
}
```

---

### åœºæ™¯4: é”™è¯¯ç±»å‹æµ‹è¯•

```go
func TestValidation(t *testing.T) {
    tests := []struct {
        name    string
        input   User
        wantErr error
    }{
        {
            "valid user",
            User{Name: "Alice", Email: "alice@example.com"},
            nil,
        },
        {
            "empty name",
            User{Email: "alice@example.com"},
            ErrEmptyName,
        },
        {
            "invalid email",
            User{Name: "Alice", Email: "invalid"},
            ErrInvalidEmail,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := Validate(tt.input)
            
            if tt.wantErr == nil {
                if err != nil {
                    t.Errorf("unexpected error: %v", err)
                }
                return
            }
            
            if !errors.Is(err, tt.wantErr) {
                t.Errorf("error = %v, want %v", err, tt.wantErr)
            }
        })
    }
}
```

---

## 5. æœ€ä½³å®è·µ

### 1. ä½¿ç”¨æœ‰æ„ä¹‰çš„æµ‹è¯•åç§°

```go
// âœ… æ¨èï¼šæè¿°æ€§åç§°
tests := []struct {
    name string
    // ...
}{
    {"empty input returns error"},
    {"valid input returns success"},
    {"duplicate name returns conflict error"},
}

// âŒ ä¸æ¨èï¼šæ— æ„ä¹‰çš„åç§°
tests := []struct {
    name string
    // ...
}{
    {"test1"},
    {"test2"},
    {"test3"},
}
```

---

### 2. ç»„ç»‡æµ‹è¯•æ•°æ®

```go
// âœ… æ¨èï¼šæ¸…æ™°çš„ç»“æ„
tests := []struct {
    name    string
    input   string
    want    string
    wantErr bool
}{
    {
        name:    "normal case",
        input:   "hello",
        want:    "HELLO",
        wantErr: false,
    },
}

// âŒ ä¸æ¨èï¼šæ··ä¹±çš„å­—æ®µé¡ºåº
tests := []struct {
    wantErr bool
    want    string
    name    string
    input   string
}{
    {false, "HELLO", "normal case", "hello"},
}
```

---

### 3. ä½¿ç”¨è¡¨æ ¼é©±åŠ¨çš„è¾¹ç•Œæ¡ä»¶

```go
func TestStringLength(t *testing.T) {
    tests := []struct {
        name  string
        input string
        want  int
    }{
        {"empty string", "", 0},
        {"single char", "a", 1},
        {"normal string", "hello", 5},
        {"unicode string", "ä½ å¥½", 2},
        {"very long string", strings.Repeat("a", 10000), 10000},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := StringLength(tt.input)
            if got != tt.want {
                t.Errorf("got %d, want %d", got, tt.want)
            }
        })
    }
}
```

---

### 4. é¿å…æµ‹è¯•ä¹‹é—´çš„ä¾èµ–

```go
// âœ… æ¨èï¼šç‹¬ç«‹æµ‹è¯•
func TestUserService(t *testing.T) {
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            db := setupTestDB(t)  // æ¯ä¸ªæµ‹è¯•ç‹¬ç«‹çš„DB
            defer cleanupTestDB(t, db)
            // æµ‹è¯•ä»£ç 
        })
    }
}

// âŒ ä¸æ¨èï¼šå…±äº«çŠ¶æ€
func TestUserService(t *testing.T) {
    db := setupTestDB(t)  // å…±äº«DB
    defer cleanupTestDB(t, db)
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // æµ‹è¯•å¯èƒ½ç›¸äº’å½±å“
        })
    }
}
```

---

### 5. ä½¿ç”¨è¾…åŠ©å‡½æ•°æé«˜å¯è¯»æ€§

```go
// âœ… æ¨èï¼šä½¿ç”¨è¾…åŠ©å‡½æ•°
func assertUser(t *testing.T, got, want *User) {
    t.Helper()
    
    if got.ID != want.ID {
        t.Errorf("ID: got %d, want %d", got.ID, want.ID)
    }
    if got.Name != want.Name {
        t.Errorf("Name: got %s, want %s", got.Name, want.Name)
    }
    if got.Email != want.Email {
        t.Errorf("Email: got %s, want %s", got.Email, want.Email)
    }
}

func TestGetUser(t *testing.T) {
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := GetUser(tt.id)
            assertUser(t, got, tt.want)
        })
    }
}
```

---

## ğŸ¯ å®Œæ•´ç¤ºä¾‹

```go
package user

import (
    "errors"
    "reflect"
    "testing"
)

func TestUserValidation(t *testing.T) {
    tests := []struct {
        name    string
        user    User
        wantErr error
    }{
        {
            name: "valid user",
            user: User{
                Name:  "Alice",
                Email: "alice@example.com",
                Age:   25,
            },
            wantErr: nil,
        },
        {
            name: "empty name",
            user: User{
                Email: "alice@example.com",
                Age:   25,
            },
            wantErr: ErrEmptyName,
        },
        {
            name: "invalid email",
            user: User{
                Name:  "Alice",
                Email: "invalid",
                Age:   25,
            },
            wantErr: ErrInvalidEmail,
        },
        {
            name: "negative age",
            user: User{
                Name:  "Alice",
                Email: "alice@example.com",
                Age:   -1,
            },
            wantErr: ErrInvalidAge,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := ValidateUser(tt.user)
            
            if tt.wantErr == nil {
                if err != nil {
                    t.Errorf("unexpected error: %v", err)
                }
                return
            }
            
            if !errors.Is(err, tt.wantErr) {
                t.Errorf("error = %v, want %v", err, tt.wantErr)
            }
        })
    }
}
```

---

## ğŸ”— ç›¸å…³èµ„æº

- [å•å…ƒæµ‹è¯•](./01-å•å…ƒæµ‹è¯•.md)
- [é›†æˆæµ‹è¯•](./03-é›†æˆæµ‹è¯•.md)
- [æµ‹è¯•æœ€ä½³å®è·µ](./07-æµ‹è¯•æœ€ä½³å®è·µ.md)

---

**æœ€åæ›´æ–°**: 2025-10-28  
**Goç‰ˆæœ¬**: 1.25.3
