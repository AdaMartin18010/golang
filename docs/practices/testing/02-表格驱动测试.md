# è¡¨æ ¼é©±åŠ¨æµ‹è¯•

**éš¾åº¦**: ä¸­çº§ | **é¢„è®¡é˜…è¯»**: 15åˆ†é’Ÿ | **å‰ç½®çŸ¥è¯†**: å•å…ƒæµ‹è¯•åŸºç¡€

---

## ğŸ“– æ¦‚å¿µä»‹ç»

è¡¨æ ¼é©±åŠ¨æµ‹è¯•ï¼ˆTable-Driven Testsï¼‰æ˜¯Goç¤¾åŒºæ¨èçš„æµ‹è¯•æ¨¡å¼ï¼Œé€šè¿‡å®šä¹‰æµ‹è¯•ç”¨ä¾‹è¡¨æ ¼æ¥ç»„ç»‡æµ‹è¯•æ•°æ®ï¼Œä½¿æµ‹è¯•æ›´åŠ ç®€æ´ã€å¯ç»´æŠ¤å’Œæ˜“äºæ‰©å±•ã€‚

---

## ğŸ¯ æ ¸å¿ƒçŸ¥è¯†ç‚¹

### 1. åŸºç¡€è¡¨æ ¼é©±åŠ¨æµ‹è¯•

```go
package math

import "testing"

func Add(a, b int) int {
    return a + b
}

func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a    int
        b    int
        want int
    }{
        {"æ­£æ•°ç›¸åŠ ", 2, 3, 5},
        {"è´Ÿæ•°ç›¸åŠ ", -1, -2, -3},
        {"é›¶å€¼", 0, 5, 5},
        {"å¤§æ•°", 1000000, 2000000, 3000000},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := Add(tt.a, tt.b)
            if got != tt.want {
                t.Errorf("Add(%d, %d) = %d, want %d", tt.a, tt.b, got, tt.want)
            }
        })
    }
}
```

---

### 2. ä½¿ç”¨t.Runè¿›è¡Œå­æµ‹è¯•

```go
func TestDivide(t *testing.T) {
    tests := []struct {
        name      string
        dividend  float64
        divisor   float64
        want      float64
        wantError bool
    }{
        {
            name:      "æ­£å¸¸é™¤æ³•",
            dividend:  10,
            divisor:   2,
            want:      5,
            wantError: false,
        },
        {
            name:      "é™¤ä»¥é›¶",
            dividend:  10,
            divisor:   0,
            want:      0,
            wantError: true,
        },
        {
            name:      "è´Ÿæ•°é™¤æ³•",
            dividend:  -10,
            divisor:   2,
            want:      -5,
            wantError: false,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := Divide(tt.dividend, tt.divisor)
            
            if (err != nil) != tt.wantError {
                t.Errorf("Divide() error = %v, wantError %v", err, tt.wantError)
                return
            }
            
            if !tt.wantError && got != tt.want {
                t.Errorf("Divide() = %v, want %v", got, tt.want)
            }
        })
    }
}

// è¿è¡Œç‰¹å®šå­æµ‹è¯•
// go test -run TestDivide/æ­£å¸¸é™¤æ³•
```

---

### 3. å¤æ‚ç»“æ„çš„æµ‹è¯•

```go
type User struct {
    ID    int
    Name  string
    Email string
    Age   int
}

func ValidateUser(u *User) error {
    if u.Name == "" {
        return errors.New("name is required")
    }
    if u.Email == "" {
        return errors.New("email is required")
    }
    if u.Age < 0 || u.Age > 150 {
        return errors.New("invalid age")
    }
    return nil
}

func TestValidateUser(t *testing.T) {
    tests := []struct {
        name    string
        user    *User
        wantErr string
    }{
        {
            name: "æœ‰æ•ˆç”¨æˆ·",
            user: &User{ID: 1, Name: "Alice", Email: "alice@example.com", Age: 25},
            wantErr: "",
        },
        {
            name: "ç¼ºå°‘åå­—",
            user: &User{ID: 2, Email: "bob@example.com", Age: 30},
            wantErr: "name is required",
        },
        {
            name: "ç¼ºå°‘é‚®ç®±",
            user: &User{ID: 3, Name: "Charlie", Age: 35},
            wantErr: "email is required",
        },
        {
            name: "å¹´é¾„æ— æ•ˆ",
            user: &User{ID: 4, Name: "Dave", Email: "dave@example.com", Age: -5},
            wantErr: "invalid age",
        },
        {
            name: "å¹´é¾„è¿‡å¤§",
            user: &User{ID: 5, Name: "Eve", Email: "eve@example.com", Age: 200},
            wantErr: "invalid age",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := ValidateUser(tt.user)
            
            if tt.wantErr == "" {
                if err != nil {
                    t.Errorf("ValidateUser() unexpected error = %v", err)
                }
            } else {
                if err == nil {
                    t.Errorf("ValidateUser() expected error %q, got nil", tt.wantErr)
                } else if err.Error() != tt.wantErr {
                    t.Errorf("ValidateUser() error = %q, want %q", err.Error(), tt.wantErr)
                }
            }
        })
    }
}
```

---

### 4. å¹¶è¡Œæµ‹è¯•

```go
func TestParallel(t *testing.T) {
    tests := []struct {
        name  string
        input int
        want  int
    }{
        {"test1", 1, 2},
        {"test2", 2, 4},
        {"test3", 3, 6},
        {"test4", 4, 8},
    }
    
    for _, tt := range tests {
        tt := tt // æ•è·rangeå˜é‡
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel() // æ ‡è®°ä¸ºå¹¶è¡Œ
            
            got := tt.input * 2
            if got != tt.want {
                t.Errorf("got %d, want %d", got, tt.want)
            }
        })
    }
}
```

---

### 5. æµ‹è¯•è¾…åŠ©å‡½æ•°

```go
// åˆ›å»ºè¾…åŠ©å‡½æ•°ç®€åŒ–æµ‹è¯•
func assertNoError(t *testing.T, err error) {
    t.Helper()
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
}

func assertEqual(t *testing.T, got, want interface{}) {
    t.Helper()
    if got != want {
        t.Errorf("got %v, want %v", got, want)
    }
}

func TestWithHelpers(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"case1", 1, 1, 2},
        {"case2", 2, 3, 5},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := Add(tt.a, tt.b)
            assertEqual(t, got, tt.want)
        })
    }
}
```

---

## ğŸ—ï¸ å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹ï¼šHTTP Handleræµ‹è¯•

```go
func HandleUser(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodGet {
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }
    
    id := r.URL.Query().Get("id")
    if id == "" {
        http.Error(w, "Missing id", http.StatusBadRequest)
        return
    }
    
    w.WriteHeader(http.StatusOK)
    fmt.Fprintf(w, `{"id":"%s","name":"User %s"}`, id, id)
}

func TestHandleUser(t *testing.T) {
    tests := []struct {
        name           string
        method         string
        query          string
        wantStatusCode int
        wantBody       string
    }{
        {
            name:           "æ­£å¸¸è¯·æ±‚",
            method:         http.MethodGet,
            query:          "?id=123",
            wantStatusCode: http.StatusOK,
            wantBody:       `{"id":"123","name":"User 123"}`,
        },
        {
            name:           "ç¼ºå°‘ID",
            method:         http.MethodGet,
            query:          "",
            wantStatusCode: http.StatusBadRequest,
            wantBody:       "Missing id\n",
        },
        {
            name:           "é”™è¯¯çš„æ–¹æ³•",
            method:         http.MethodPost,
            query:          "?id=123",
            wantStatusCode: http.StatusMethodNotAllowed,
            wantBody:       "Method not allowed\n",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            req := httptest.NewRequest(tt.method, "/user"+tt.query, nil)
            rec := httptest.NewRecorder()
            
            HandleUser(rec, req)
            
            if rec.Code != tt.wantStatusCode {
                t.Errorf("status code = %d, want %d", rec.Code, tt.wantStatusCode)
            }
            
            if rec.Body.String() != tt.wantBody {
                t.Errorf("body = %q, want %q", rec.Body.String(), tt.wantBody)
            }
        })
    }
}
```

---

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. å‘½åæ¸…æ™°
```go
// âœ… å¥½ï¼šæè¿°æ€§å¼º
{"ä¸¤ä¸ªæ­£æ•°ç›¸åŠ è¿”å›å’Œ", 2, 3, 5}

// âŒ å·®ï¼šä¸æ¸…æ™°
{"test1", 2, 3, 5}
```

### 2. ä¸€ä¸ªè¡¨æ ¼æµ‹è¯•ä¸€ä¸ªå‡½æ•°
```go
// âœ… å¥½
func TestAdd(t *testing.T) { /* åªæµ‹è¯•Add */ }
func TestSubtract(t *testing.T) { /* åªæµ‹è¯•Subtract */ }

// âŒ å·®
func TestMath(t *testing.T) { /* æµ‹è¯•å¤šä¸ªå‡½æ•° */ }
```

### 3. æµ‹è¯•ç”¨ä¾‹è¦å…¨é¢
```go
tests := []struct{...}{
    // æ­£å¸¸æƒ…å†µ
    {"æ­£å¸¸è¾“å…¥", normalInput, normalOutput},
    // è¾¹ç•Œæƒ…å†µ
    {"é›¶å€¼", 0, expected},
    {"æœ€å¤§å€¼", math.MaxInt, expected},
    // é”™è¯¯æƒ…å†µ
    {"æ— æ•ˆè¾“å…¥", invalidInput, error},
}
```

### 4. ä½¿ç”¨t.Helper()
```go
func checkResult(t *testing.T, got, want int) {
    t.Helper() // é”™è¯¯ä¼šæŒ‡å‘è°ƒç”¨è€…
    if got != want {
        t.Errorf("got %d, want %d", got, want)
    }
}
```

### 5. è€ƒè™‘å¹¶è¡Œæµ‹è¯•
```go
// æµ‹è¯•äº’ä¸å½±å“æ—¶ä½¿ç”¨
t.Parallel()
```

---

## âš ï¸ å¸¸è§é—®é¢˜

**Q1: ä½•æ—¶ä½¿ç”¨è¡¨æ ¼é©±åŠ¨æµ‹è¯•ï¼Ÿ**
- æœ‰å¤šä¸ªç±»ä¼¼çš„æµ‹è¯•ç”¨ä¾‹
- æµ‹è¯•é€»è¾‘ç›¸åŒï¼Œåªæ˜¯è¾“å…¥è¾“å‡ºä¸åŒ
- éœ€è¦æµ‹è¯•è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯æƒ…å†µ

**Q2: å¦‚ä½•ç»„ç»‡å¤§å‹æµ‹è¯•è¡¨æ ¼ï¼Ÿ**
```go
// å¯ä»¥åˆ†ç»„
tests := []struct{...}{
    // æ­£å¸¸æƒ…å†µ
    {...},
    {...},
    // è¾¹ç•Œæƒ…å†µ  
    {...},
    // é”™è¯¯æƒ…å†µ
    {...},
}
```

**Q3: t.Runçš„å¥½å¤„ï¼Ÿ**
- å¯ä»¥å•ç‹¬è¿è¡ŒæŸä¸ªå­æµ‹è¯•
- å¤±è´¥æ—¶æ›´å®¹æ˜“å®šä½
- æ”¯æŒå¹¶è¡Œæµ‹è¯•

**Q4: å¦‚ä½•å¤„ç†setupå’Œcleanupï¼Ÿ**
```go
t.Run("test", func(t *testing.T) {
    // Setup
    resource := setupResource()
    
    // Cleanup
    t.Cleanup(func() {
        resource.Close()
    })
    
    // Test logic
})
```

---

## ğŸ“š ç›¸å…³èµ„æº

- [Table Driven Tests Wiki](https://go.dev/wiki/TableDrivenTests)
- [Go Testing Style Guide](https://github.com/golang/go/wiki/TestComments)

**ä¸‹ä¸€æ­¥**: [03-é›†æˆæµ‹è¯•](./03-é›†æˆæµ‹è¯•.md)

---

**æœ€åæ›´æ–°**: 2025-10-28

