# 集成测试

**难度**: 中级 | **预计阅读**: 20分钟 | **前置知识**: 单元测试、Docker基础

---

## 📖 概念介绍

集成测试验证多个组件协同工作的正确性，通常涉及数据库、外部API、消息队列等真实依赖。Go的集成测试需要妥善管理测试环境和资源清理。

---

## 🎯 核心知识点

### 1. 数据库集成测试

```go
package repository

import (
    "database/sql"
    "testing"
    _ "github.com/lib/pq"
)

func setupTestDB(t *testing.T) *sql.DB {
    t.Helper()
    
    // 连接测试数据库
    db, err := sql.Open("postgres", 
        "host=localhost port=5432 user=test password=test dbname=testdb sslmode=disable")
    if err != nil {
        t.Fatalf("Failed to connect to test database: %v", err)
    }
    
    // 清理数据
    _, err = db.Exec("TRUNCATE TABLE users")
    if err != nil {
        t.Fatalf("Failed to clean database: %v", err)
    }
    
    // Cleanup
    t.Cleanup(func() {
        db.Close()
    })
    
    return db
}

func TestUserRepository_Create(t *testing.T) {
    db := setupTestDB(t)
    repo := NewUserRepository(db)
    
    user := &User{
        Name:  "Alice",
        Email: "alice@example.com",
    }
    
    err := repo.Create(user)
    if err != nil {
        t.Fatalf("Create() failed: %v", err)
    }
    
    // 验证创建
    found, err := repo.GetByEmail("alice@example.com")
    if err != nil {
        t.Fatalf("GetByEmail() failed: %v", err)
    }
    
    if found.Name != user.Name {
        t.Errorf("Name = %s, want %s", found.Name, user.Name)
    }
}
```

---

### 2. 使用TestContainers

```go
package repository

import (
    "context"
    "testing"
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/wait"
)

func setupPostgres(t *testing.T) *sql.DB {
    t.Helper()
    ctx := context.Background()
    
    // 启动PostgreSQL容器
    req := testcontainers.ContainerRequest{
        Image:        "postgres:15-alpine",
        ExposedPorts: []string{"5432/tcp"},
        Env: map[string]string{
            "POSTGRES_USER":     "test",
            "POSTGRES_PASSWORD": "test",
            "POSTGRES_DB":       "testdb",
        },
        WaitingFor: wait.ForLog("database system is ready to accept connections"),
    }
    
    postgres, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
        ContainerRequest: req,
        Started:          true,
    })
    if err != nil {
        t.Fatalf("Failed to start container: %v", err)
    }
    
    // Cleanup
    t.Cleanup(func() {
        postgres.Terminate(ctx)
    })
    
    // 获取连接信息
    host, _ := postgres.Host(ctx)
    port, _ := postgres.MappedPort(ctx, "5432")
    
    dsn := fmt.Sprintf("host=%s port=%s user=test password=test dbname=testdb sslmode=disable",
        host, port.Port())
    
    db, err := sql.Open("postgres", dsn)
    if err != nil {
        t.Fatalf("Failed to connect: %v", err)
    }
    
    return db
}
```

---

### 3. HTTP API集成测试

```go
package api

import (
    "net/http"
    "net/http/httptest"
    "strings"
    "testing"
)

func setupTestServer(t *testing.T) *httptest.Server {
    t.Helper()
    
    // 创建测试服务器
    mux := http.NewServeMux()
    mux.HandleFunc("/users", handleUsers)
    
    server := httptest.NewServer(mux)
    
    t.Cleanup(func() {
        server.Close()
    })
    
    return server
}

func TestAPI_CreateUser(t *testing.T) {
    server := setupTestServer(t)
    
    // 发送请求
    body := strings.NewReader(`{"name":"Alice","email":"alice@example.com"}`)
    resp, err := http.Post(server.URL+"/users", "application/json", body)
    if err != nil {
        t.Fatalf("POST failed: %v", err)
    }
    defer resp.Body.Close()
    
    // 验证响应
    if resp.StatusCode != http.StatusCreated {
        t.Errorf("StatusCode = %d, want %d", resp.StatusCode, http.StatusCreated)
    }
}
```

---

### 4. 外部服务Mock

```go
package service

import (
    "net/http"
    "net/http/httptest"
    "testing"
)

func setupMockAPI(t *testing.T) *httptest.Server {
    t.Helper()
    
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Mock响应
        if r.URL.Path == "/api/users/123" {
            w.WriteHeader(http.StatusOK)
            w.Write([]byte(`{"id":"123","name":"Alice"}`))
            return
        }
        w.WriteHeader(http.StatusNotFound)
    }))
    
    t.Cleanup(server.Close)
    return server
}

func TestFetchUser(t *testing.T) {
    mockAPI := setupMockAPI(t)
    
    client := NewAPIClient(mockAPI.URL)
    user, err := client.FetchUser("123")
    
    if err != nil {
        t.Fatalf("FetchUser() failed: %v", err)
    }
    
    if user.Name != "Alice" {
        t.Errorf("Name = %s, want Alice", user.Name)
    }
}
```

---

### 5. 端到端测试

```go
func TestE2E_UserWorkflow(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping E2E test in short mode")
    }
    
    // 1. Setup
    db := setupTestDB(t)
    server := setupTestServer(t)
    
    // 2. 创建用户
    createResp := createUser(t, server.URL, "Alice", "alice@example.com")
    userID := extractUserID(createResp)
    
    // 3. 获取用户
    user := getUser(t, server.URL, userID)
    if user.Name != "Alice" {
        t.Errorf("Name = %s, want Alice", user.Name)
    }
    
    // 4. 更新用户
    updateUser(t, server.URL, userID, "Alice Smith")
    
    // 5. 验证更新
    updated := getUser(t, server.URL, userID)
    if updated.Name != "Alice Smith" {
        t.Errorf("Name = %s, want Alice Smith", updated.Name)
    }
    
    // 6. 删除用户
    deleteUser(t, server.URL, userID)
    
    // 7. 验证删除
    _, err := getUserRaw(t, server.URL, userID)
    if err == nil {
        t.Error("Expected user to be deleted")
    }
}
```

---

## 💡 最佳实践

### 1. 使用Build Tags隔离

```go
// +build integration

package repository

import "testing"

func TestIntegration(t *testing.T) {
    // 集成测试代码
}
```

运行：
```bash
# 只运行集成测试
go test -tags=integration

# 跳过集成测试
go test -short
```

---

### 2. 环境变量配置

```go
func getTestDSN() string {
    if dsn := os.Getenv("TEST_DATABASE_URL"); dsn != "" {
        return dsn
    }
    return "postgres://test:test@localhost/testdb"
}
```

---

### 3. 数据清理策略

```go
func cleanDatabase(t *testing.T, db *sql.DB) {
    t.Helper()
    
    tables := []string{"orders", "users", "products"}
    for _, table := range tables {
        _, err := db.Exec(fmt.Sprintf("TRUNCATE TABLE %s CASCADE", table))
        if err != nil {
            t.Fatalf("Failed to clean table %s: %v", table, err)
        }
    }
}
```

---

### 4. 事务隔离

```go
func TestWithTransaction(t *testing.T) {
    db := setupTestDB(t)
    
    tx, err := db.Begin()
    if err != nil {
        t.Fatal(err)
    }
    
    t.Cleanup(func() {
        tx.Rollback() // 回滚所有更改
    })
    
    // 在事务中执行测试
    repo := NewUserRepository(tx)
    // ... 测试逻辑
}
```

---

## ⚠️ 常见问题

**Q1: 集成测试vs单元测试？**
- 单元测试：快速、隔离、不依赖外部
- 集成测试：真实、完整、但较慢

**Q2: 如何加速集成测试？**
- 使用t.Parallel()
- 使用内存数据库（SQLite）
- 复用容器实例
- 合理使用TestMain

**Q3: CI环境如何运行？**
```yaml
# GitHub Actions示例
services:
  postgres:
    image: postgres:15
    env:
      POSTGRES_PASSWORD: test
    options: >-
      --health-cmd pg_isready
      --health-interval 10s
```

---

## 📚 相关资源

- [TestContainers](https://golang.testcontainers.org/)
- [httptest Package](https://pkg.go.dev/net/http/httptest)

**下一步**: [04-性能测试](./04-性能测试.md)

---

**最后更新**: 2025-10-28

