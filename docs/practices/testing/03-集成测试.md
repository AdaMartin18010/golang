# é›†æˆæµ‹è¯•

**éš¾åº¦**: ä¸­çº§ | **é¢„è®¡é˜…è¯»**: 20åˆ†é’Ÿ | **å‰ç½®çŸ¥è¯†**: å•å…ƒæµ‹è¯•ã€DockeråŸºç¡€

---

## ğŸ“– æ¦‚å¿µä»‹ç»

é›†æˆæµ‹è¯•éªŒè¯å¤šä¸ªç»„ä»¶ååŒå·¥ä½œçš„æ­£ç¡®æ€§ï¼Œé€šå¸¸æ¶‰åŠæ•°æ®åº“ã€å¤–éƒ¨APIã€æ¶ˆæ¯é˜Ÿåˆ—ç­‰çœŸå®ä¾èµ–ã€‚Goçš„é›†æˆæµ‹è¯•éœ€è¦å¦¥å–„ç®¡ç†æµ‹è¯•ç¯å¢ƒå’Œèµ„æºæ¸…ç†ã€‚

---

## ğŸ¯ æ ¸å¿ƒçŸ¥è¯†ç‚¹

### 1. æ•°æ®åº“é›†æˆæµ‹è¯•

```go
package repository

import (
    "database/sql"
    "testing"
    _ "github.com/lib/pq"
)

func setupTestDB(t *testing.T) *sql.DB {
    t.Helper()
    
    // è¿æ¥æµ‹è¯•æ•°æ®åº“
    db, err := sql.Open("postgres", 
        "host=localhost port=5432 user=test password=test dbname=testdb sslmode=disable")
    if err != nil {
        t.Fatalf("Failed to connect to test database: %v", err)
    }
    
    // æ¸…ç†æ•°æ®
    _, err = db.Exec("TRUNCATE TABLE users")
    if err != nil {
        t.Fatalf("Failed to clean database: %v", err)
    }
    
    // Cleanup
    t.Cleanup(func() {
        db.Close()
    })
    
    return db
}

func TestUserRepository_Create(t *testing.T) {
    db := setupTestDB(t)
    repo := NewUserRepository(db)
    
    user := &User{
        Name:  "Alice",
        Email: "alice@example.com",
    }
    
    err := repo.Create(user)
    if err != nil {
        t.Fatalf("Create() failed: %v", err)
    }
    
    // éªŒè¯åˆ›å»º
    found, err := repo.GetByEmail("alice@example.com")
    if err != nil {
        t.Fatalf("GetByEmail() failed: %v", err)
    }
    
    if found.Name != user.Name {
        t.Errorf("Name = %s, want %s", found.Name, user.Name)
    }
}
```

---

### 2. ä½¿ç”¨TestContainers

```go
package repository

import (
    "context"
    "testing"
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/wait"
)

func setupPostgres(t *testing.T) *sql.DB {
    t.Helper()
    ctx := context.Background()
    
    // å¯åŠ¨PostgreSQLå®¹å™¨
    req := testcontainers.ContainerRequest{
        Image:        "postgres:15-alpine",
        ExposedPorts: []string{"5432/tcp"},
        Env: map[string]string{
            "POSTGRES_USER":     "test",
            "POSTGRES_PASSWORD": "test",
            "POSTGRES_DB":       "testdb",
        },
        WaitingFor: wait.ForLog("database system is ready to accept connections"),
    }
    
    postgres, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
        ContainerRequest: req,
        Started:          true,
    })
    if err != nil {
        t.Fatalf("Failed to start container: %v", err)
    }
    
    // Cleanup
    t.Cleanup(func() {
        postgres.Terminate(ctx)
    })
    
    // è·å–è¿æ¥ä¿¡æ¯
    host, _ := postgres.Host(ctx)
    port, _ := postgres.MappedPort(ctx, "5432")
    
    dsn := fmt.Sprintf("host=%s port=%s user=test password=test dbname=testdb sslmode=disable",
        host, port.Port())
    
    db, err := sql.Open("postgres", dsn)
    if err != nil {
        t.Fatalf("Failed to connect: %v", err)
    }
    
    return db
}
```

---

### 3. HTTP APIé›†æˆæµ‹è¯•

```go
package api

import (
    "net/http"
    "net/http/httptest"
    "strings"
    "testing"
)

func setupTestServer(t *testing.T) *httptest.Server {
    t.Helper()
    
    // åˆ›å»ºæµ‹è¯•æœåŠ¡å™¨
    mux := http.NewServeMux()
    mux.HandleFunc("/users", handleUsers)
    
    server := httptest.NewServer(mux)
    
    t.Cleanup(func() {
        server.Close()
    })
    
    return server
}

func TestAPI_CreateUser(t *testing.T) {
    server := setupTestServer(t)
    
    // å‘é€è¯·æ±‚
    body := strings.NewReader(`{"name":"Alice","email":"alice@example.com"}`)
    resp, err := http.Post(server.URL+"/users", "application/json", body)
    if err != nil {
        t.Fatalf("POST failed: %v", err)
    }
    defer resp.Body.Close()
    
    // éªŒè¯å“åº”
    if resp.StatusCode != http.StatusCreated {
        t.Errorf("StatusCode = %d, want %d", resp.StatusCode, http.StatusCreated)
    }
}
```

---

### 4. å¤–éƒ¨æœåŠ¡Mock

```go
package service

import (
    "net/http"
    "net/http/httptest"
    "testing"
)

func setupMockAPI(t *testing.T) *httptest.Server {
    t.Helper()
    
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Mockå“åº”
        if r.URL.Path == "/api/users/123" {
            w.WriteHeader(http.StatusOK)
            w.Write([]byte(`{"id":"123","name":"Alice"}`))
            return
        }
        w.WriteHeader(http.StatusNotFound)
    }))
    
    t.Cleanup(server.Close)
    return server
}

func TestFetchUser(t *testing.T) {
    mockAPI := setupMockAPI(t)
    
    client := NewAPIClient(mockAPI.URL)
    user, err := client.FetchUser("123")
    
    if err != nil {
        t.Fatalf("FetchUser() failed: %v", err)
    }
    
    if user.Name != "Alice" {
        t.Errorf("Name = %s, want Alice", user.Name)
    }
}
```

---

### 5. ç«¯åˆ°ç«¯æµ‹è¯•

```go
func TestE2E_UserWorkflow(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping E2E test in short mode")
    }
    
    // 1. Setup
    db := setupTestDB(t)
    server := setupTestServer(t)
    
    // 2. åˆ›å»ºç”¨æˆ·
    createResp := createUser(t, server.URL, "Alice", "alice@example.com")
    userID := extractUserID(createResp)
    
    // 3. è·å–ç”¨æˆ·
    user := getUser(t, server.URL, userID)
    if user.Name != "Alice" {
        t.Errorf("Name = %s, want Alice", user.Name)
    }
    
    // 4. æ›´æ–°ç”¨æˆ·
    updateUser(t, server.URL, userID, "Alice Smith")
    
    // 5. éªŒè¯æ›´æ–°
    updated := getUser(t, server.URL, userID)
    if updated.Name != "Alice Smith" {
        t.Errorf("Name = %s, want Alice Smith", updated.Name)
    }
    
    // 6. åˆ é™¤ç”¨æˆ·
    deleteUser(t, server.URL, userID)
    
    // 7. éªŒè¯åˆ é™¤
    _, err := getUserRaw(t, server.URL, userID)
    if err == nil {
        t.Error("Expected user to be deleted")
    }
}
```

---

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. ä½¿ç”¨Build Tagséš”ç¦»

```go
// +build integration

package repository

import "testing"

func TestIntegration(t *testing.T) {
    // é›†æˆæµ‹è¯•ä»£ç 
}
```

è¿è¡Œï¼š
```bash
# åªè¿è¡Œé›†æˆæµ‹è¯•
go test -tags=integration

# è·³è¿‡é›†æˆæµ‹è¯•
go test -short
```

---

### 2. ç¯å¢ƒå˜é‡é…ç½®

```go
func getTestDSN() string {
    if dsn := os.Getenv("TEST_DATABASE_URL"); dsn != "" {
        return dsn
    }
    return "postgres://test:test@localhost/testdb"
}
```

---

### 3. æ•°æ®æ¸…ç†ç­–ç•¥

```go
func cleanDatabase(t *testing.T, db *sql.DB) {
    t.Helper()
    
    tables := []string{"orders", "users", "products"}
    for _, table := range tables {
        _, err := db.Exec(fmt.Sprintf("TRUNCATE TABLE %s CASCADE", table))
        if err != nil {
            t.Fatalf("Failed to clean table %s: %v", table, err)
        }
    }
}
```

---

### 4. äº‹åŠ¡éš”ç¦»

```go
func TestWithTransaction(t *testing.T) {
    db := setupTestDB(t)
    
    tx, err := db.Begin()
    if err != nil {
        t.Fatal(err)
    }
    
    t.Cleanup(func() {
        tx.Rollback() // å›æ»šæ‰€æœ‰æ›´æ”¹
    })
    
    // åœ¨äº‹åŠ¡ä¸­æ‰§è¡Œæµ‹è¯•
    repo := NewUserRepository(tx)
    // ... æµ‹è¯•é€»è¾‘
}
```

---

## âš ï¸ å¸¸è§é—®é¢˜

**Q1: é›†æˆæµ‹è¯•vså•å…ƒæµ‹è¯•ï¼Ÿ**
- å•å…ƒæµ‹è¯•ï¼šå¿«é€Ÿã€éš”ç¦»ã€ä¸ä¾èµ–å¤–éƒ¨
- é›†æˆæµ‹è¯•ï¼šçœŸå®ã€å®Œæ•´ã€ä½†è¾ƒæ…¢

**Q2: å¦‚ä½•åŠ é€Ÿé›†æˆæµ‹è¯•ï¼Ÿ**
- ä½¿ç”¨t.Parallel()
- ä½¿ç”¨å†…å­˜æ•°æ®åº“ï¼ˆSQLiteï¼‰
- å¤ç”¨å®¹å™¨å®ä¾‹
- åˆç†ä½¿ç”¨TestMain

**Q3: CIç¯å¢ƒå¦‚ä½•è¿è¡Œï¼Ÿ**
```yaml
# GitHub Actionsç¤ºä¾‹
services:
  postgres:
    image: postgres:15
    env:
      POSTGRES_PASSWORD: test
    options: >-
      --health-cmd pg_isready
      --health-interval 10s
```

---

## ğŸ“š ç›¸å…³èµ„æº

- [TestContainers](https://golang.testcontainers.org/)
- [httptest Package](https://pkg.go.dev/net/http/httptest)

**ä¸‹ä¸€æ­¥**: [04-æ€§èƒ½æµ‹è¯•](./04-æ€§èƒ½æµ‹è¯•.md)

---

**æœ€åæ›´æ–°**: 2025-10-28

