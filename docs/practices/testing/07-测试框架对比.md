# 测试框架对比

## 📋 目录

- [测试框架对比](#测试框架对比)
  - [📋 目录](#-目录)
  - [1. 测试框架概览](#1-测试框架概览)
    - [主流测试工具对比](#主流测试工具对比)
  - [2. 标准库testing](#2-标准库testing)
    - [基础用法](#基础用法)
    - [Table-Driven测试](#table-driven测试)
    - [子测试](#子测试)
    - [优劣势](#优劣势)
  - [3. Testify - 最流行的测试工具](#3-testify---最流行的测试工具)
    - [安装](#安装)
    - [Assert断言](#assert断言)
    - [Require断言（失败即停止）](#require断言失败即停止)
    - [Suite测试套件](#suite测试套件)
    - [Mock对象](#mock对象)
    - [优劣势1](#优劣势1)
  - [4. Ginkgo/Gomega - BDD风格](#4-ginkgogomega---bdd风格)
    - [安装1](#安装1)
    - [BDD风格测试](#bdd风格测试)
    - [表格驱动测试](#表格驱动测试)
    - [异步测试](#异步测试)
    - [优劣势2](#优劣势2)
  - [5. GoMock - Mock框架](#5-gomock---mock框架)
    - [安装2](#安装2)
    - [生成Mock](#生成mock)
    - [使用Mock](#使用mock)
    - [高级Mock](#高级mock)
    - [优劣势3](#优劣势3)
  - [6. GoConvey - Web界面](#6-goconvey---web界面)
    - [安装3](#安装3)
    - [基础用法3](#基础用法3)
    - [Web界面](#web界面)
    - [优劣势4](#优劣势4)
  - [7. 性能对比](#7-性能对比)
    - [基准测试](#基准测试)
    - [性能结果](#性能结果)
  - [8. 选择建议](#8-选择建议)
    - [决策树](#决策树)
    - [场景推荐](#场景推荐)
      - [1. 简单库/工具](#1-简单库工具)
      - [2. REST API服务](#2-rest-api服务)
      - [3. 复杂业务逻辑](#3-复杂业务逻辑)
      - [4. 微服务](#4-微服务)
    - [组合使用](#组合使用)
    - [快速参考](#快速参考)
  - [🔗 相关资源](#-相关资源)

## 1. 测试框架概览

### 主流测试工具对比

| 框架/工具 | Stars⭐ | 类型 | 核心特点 | 学习曲线 |
|-----------|---------|------|----------|----------|
| **testing** | stdlib | 基础框架 | 标准库、简单可靠 | ⭐ |
| **Testify** | 22K+ | 断言+Mock | 丰富断言、易用Mock | ⭐⭐ |
| **Ginkgo** | 8K+ | BDD框架 | 行为驱动、描述性强 | ⭐⭐⭐⭐ |
| **GoMock** | 9K+ | Mock生成器 | 官方Mock、代码生成 | ⭐⭐⭐ |
| **GoConvey** | 8K+ | BDD+Web | Web界面、实时反馈 | ⭐⭐⭐ |
| **httptest** | stdlib | HTTP测试 | 标准库HTTP测试 | ⭐ |
| **sqlmock** | 6K+ | SQL Mock | 数据库Mock | ⭐⭐ |

---

## 2. 标准库testing

### 基础用法

```go
// user_test.go
package user

import (
    "testing"
)

func TestCreateUser(t *testing.T) {
    user := &User{
        Name:  "John",
        Email: "john@example.com",
        Age:   30,
    }

    err := user.Validate()
    if err != nil {
        t.Errorf("Expected no error, got %v", err)
    }

    if user.Name != "John" {
        t.Errorf("Expected name 'John', got '%s'", user.Name)
    }
}
```

### Table-Driven测试

```go
func TestValidateUser(t *testing.T) {
    tests := []struct {
        name    string
        user    User
        wantErr bool
        errMsg  string
    }{
        {
            name:    "valid user",
            user:    User{Name: "John", Email: "john@example.com", Age: 30},
            wantErr: false,
        },
        {
            name:    "empty name",
            user:    User{Name: "", Email: "john@example.com", Age: 30},
            wantErr: true,
            errMsg:  "name is required",
        },
        {
            name:    "invalid email",
            user:    User{Name: "John", Email: "invalid", Age: 30},
            wantErr: true,
            errMsg:  "invalid email format",
        },
        {
            name:    "age too young",
            user:    User{Name: "John", Email: "john@example.com", Age: 10},
            wantErr: true,
            errMsg:  "age must be at least 18",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := tt.user.Validate()

            if (err != nil) != tt.wantErr {
                t.Errorf("Validate() error = %v, wantErr %v", err, tt.wantErr)
                return
            }

            if err != nil && err.Error() != tt.errMsg {
                t.Errorf("Validate() error = %v, want %v", err.Error(), tt.errMsg)
            }
        })
    }
}
```

### 子测试

```go
func TestUserOperations(t *testing.T) {
    t.Run("Create", func(t *testing.T) {
        user := CreateUser("John", "john@example.com")
        if user == nil {
            t.Fatal("Expected user, got nil")
        }
    })

    t.Run("Update", func(t *testing.T) {
        user := CreateUser("John", "john@example.com")
        err := user.UpdateEmail("newemail@example.com")
        if err != nil {
            t.Errorf("UpdateEmail failed: %v", err)
        }
    })

    t.Run("Delete", func(t *testing.T) {
        user := CreateUser("John", "john@example.com")
        err := user.Delete()
        if err != nil {
            t.Errorf("Delete failed: %v", err)
        }
    })
}
```

### 优劣势

**优势**:

- ✅ 标准库，无需额外依赖
- ✅ 简单直接，易于理解
- ✅ 性能最优
- ✅ 与工具链完美集成

**劣势**:

- ❌ 断言不够丰富
- ❌ 错误信息不够友好
- ❌ 缺少Mock支持
- ❌ 代码冗长

---

## 3. Testify - 最流行的测试工具

### 安装

```bash
go get github.com/stretchr/testify
```

### Assert断言

```go
import (
    "testing"
    "github.com/stretchr/testify/assert"
)

func TestCreateUser(t *testing.T) {
    user := CreateUser("John", "john@example.com")

    // 基础断言
    assert.NotNil(t, user)
    assert.Equal(t, "John", user.Name)
    assert.Equal(t, "john@example.com", user.Email)

    // 集合断言
    assert.Contains(t, user.Roles, "user")
    assert.Len(t, user.Roles, 1)

    // 错误断言
    err := user.Validate()
    assert.NoError(t, err)
}
```

### Require断言（失败即停止）

```go
import "github.com/stretchr/testify/require"

func TestUserWorkflow(t *testing.T) {
    // 如果失败，立即停止后续测试
    user := CreateUser("John", "john@example.com")
    require.NotNil(t, user, "User should not be nil")

    // 只有上面成功才会执行
    err := user.Save()
    require.NoError(t, err, "Save should succeed")

    // 只有上面都成功才会执行
    loaded, err := LoadUser(user.ID)
    require.NoError(t, err)
    require.Equal(t, user.ID, loaded.ID)
}
```

### Suite测试套件

```go
import (
    "testing"
    "github.com/stretchr/testify/suite"
)

type UserTestSuite struct {
    suite.Suite
    db     *sql.DB
    repo   *UserRepository
}

// 每个Suite执行前运行一次
func (s *UserTestSuite) SetupSuite() {
    db, err := sql.Open("postgres", "test_db_url")
    s.Require().NoError(err)
    s.db = db
    s.repo = NewUserRepository(db)
}

// 每个测试前运行
func (s *UserTestSuite) SetupTest() {
    // 清理数据
    s.db.Exec("TRUNCATE users")
}

// 测试方法
func (s *UserTestSuite) TestCreateUser() {
    user := &User{Name: "John", Email: "john@example.com"}
    err := s.repo.Create(user)

    s.NoError(err)
    s.NotEmpty(user.ID)
}

func (s *UserTestSuite) TestFindUser() {
    // 准备数据
    user := &User{Name: "John", Email: "john@example.com"}
    s.repo.Create(user)

    // 测试查找
    found, err := s.repo.FindByID(user.ID)
    s.NoError(err)
    s.Equal(user.ID, found.ID)
}

// 每个Suite执行后运行一次
func (s *UserTestSuite) TearDownSuite() {
    s.db.Close()
}

// 运行Suite
func TestUserTestSuite(t *testing.T) {
    suite.Run(t, new(UserTestSuite))
}
```

### Mock对象

```go
import "github.com/stretchr/testify/mock"

// Mock定义
type MockUserRepository struct {
    mock.Mock
}

func (m *MockUserRepository) FindByID(id string) (*User, error) {
    args := m.Called(id)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*User), args.Error(1)
}

func (m *MockUserRepository) Create(user *User) error {
    args := m.Called(user)
    return args.Error(0)
}

// 使用Mock
func TestUserService(t *testing.T) {
    mockRepo := new(MockUserRepository)
    service := NewUserService(mockRepo)

    // 设置期望
    expectedUser := &User{ID: "123", Name: "John"}
    mockRepo.On("FindByID", "123").Return(expectedUser, nil)

    // 执行测试
    user, err := service.GetUser("123")

    // 验证
    assert.NoError(t, err)
    assert.Equal(t, "John", user.Name)
    mockRepo.AssertExpectations(t)
}
```

### 优劣势1

**优势**:

- ✅ 丰富的断言函数
- ✅ 友好的错误信息
- ✅ Suite组织测试
- ✅ 内置Mock支持
- ✅ 社区最活跃

**劣势**:

- ❌ 需要额外依赖
- ❌ Mock需要手写
- ❌ 略微影响性能

---

## 4. Ginkgo/Gomega - BDD风格

### 安装1

```bash
go install github.com/onsi/ginkgo/v2/ginkgo
go get github.com/onsi/gomega/...
```

### BDD风格测试

```go
package user_test

import (
    . "github.com/onsi/ginkgo/v2"
    . "github.com/onsi/gomega"
    "testing"
)

func TestUser(t *testing.T) {
    RegisterFailHandler(Fail)
    RunSpecs(t, "User Suite")
}

var _ = Describe("User", func() {
    var user *User

    BeforeEach(func() {
        user = &User{
            Name:  "John",
            Email: "john@example.com",
            Age:   30,
        }
    })

    Context("when validating", func() {
        It("should accept valid user", func() {
            err := user.Validate()
            Expect(err).NotTo(HaveOccurred())
        })

        It("should reject empty name", func() {
            user.Name = ""
            err := user.Validate()
            Expect(err).To(HaveOccurred())
            Expect(err.Error()).To(ContainSubstring("name is required"))
        })

        It("should reject invalid email", func() {
            user.Email = "invalid"
            err := user.Validate()
            Expect(err).To(MatchError(ContainSubstring("invalid email")))
        })
    })

    Context("when creating", func() {
        var repo *UserRepository

        BeforeEach(func() {
            repo = NewUserRepository(testDB)
        })

        It("should save to database", func() {
            err := repo.Create(user)
            Expect(err).NotTo(HaveOccurred())
            Expect(user.ID).NotTo(BeEmpty())
        })

        It("should be retrievable", func() {
            repo.Create(user)

            found, err := repo.FindByID(user.ID)
            Expect(err).NotTo(HaveOccurred())
            Expect(found).To(Equal(user))
        })
    })

    Describe("UpdateEmail", func() {
        It("should update email successfully", func() {
            newEmail := "newemail@example.com"
            err := user.UpdateEmail(newEmail)

            Expect(err).NotTo(HaveOccurred())
            Expect(user.Email).To(Equal(newEmail))
        })

        When("email is invalid", func() {
            It("should return error", func() {
                err := user.UpdateEmail("invalid")
                Expect(err).To(HaveOccurred())
            })
        })
    })
})
```

### 表格驱动测试

```go
var _ = Describe("User Validation", func() {
    DescribeTable("validate different scenarios",
        func(name, email string, age int, shouldFail bool) {
            user := &User{Name: name, Email: email, Age: age}
            err := user.Validate()

            if shouldFail {
                Expect(err).To(HaveOccurred())
            } else {
                Expect(err).NotTo(HaveOccurred())
            }
        },
        Entry("valid user", "John", "john@example.com", 30, false),
        Entry("empty name", "", "john@example.com", 30, true),
        Entry("invalid email", "John", "invalid", 30, true),
        Entry("underage", "John", "john@example.com", 15, true),
    )
})
```

### 异步测试

```go
var _ = Describe("Async Operations", func() {
    It("should complete within timeout", func() {
        done := make(chan bool)

        go func() {
            defer GinkgoRecover()
            time.Sleep(100 * time.Millisecond)
            done <- true
        }()

        Eventually(done, "200ms").Should(Receive(BeTrue()))
    })

    It("should poll until condition is met", func() {
        counter := 0

        Eventually(func() int {
            counter++
            return counter
        }, "1s", "100ms").Should(BeNumerically(">", 5))
    })
})
```

### 优劣势2

**优势**:

- ✅ BDD风格，描述性强
- ✅ 优秀的测试组织
- ✅ 强大的异步测试
- ✅ 丰富的Matcher
- ✅ 并行测试支持

**劣势**:

- ❌ 学习曲线陡峭
- ❌ DSL风格不适合所有人
- ❌ 需要额外工具
- ❌ IDE支持不如标准库

---

## 5. GoMock - Mock框架

### 安装2

```bash
go install github.com/golang/mock/mockgen@latest
```

### 生成Mock

```go
// user_repository.go
package user

//go:generate mockgen -source=user_repository.go -destination=mocks/mock_user_repository.go -package=mocks

type UserRepository interface {
    FindByID(id string) (*User, error)
    Create(user *User) error
    Update(user *User) error
    Delete(id string) error
}
```

```bash
# 生成Mock
go generate ./...
```

### 使用Mock

```go
import (
    "testing"
    "github.com/golang/mock/gomock"
    "myapp/user/mocks"
)

func TestUserService_GetUser(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()

    // 创建Mock
    mockRepo := mocks.NewMockUserRepository(ctrl)
    service := NewUserService(mockRepo)

    // 设置期望
    expectedUser := &User{ID: "123", Name: "John"}
    mockRepo.EXPECT().
        FindByID("123").
        Return(expectedUser, nil).
        Times(1)

    // 执行
    user, err := service.GetUser("123")

    // 验证
    if err != nil {
        t.Errorf("Expected no error, got %v", err)
    }
    if user.Name != "John" {
        t.Errorf("Expected name 'John', got '%s'", user.Name)
    }
}
```

### 高级Mock

```go
func TestComplexScenario(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()

    mockRepo := mocks.NewMockUserRepository(ctrl)
    service := NewUserService(mockRepo)

    // 参数匹配
    mockRepo.EXPECT().
        FindByID(gomock.Any()).
        Return(&User{ID: "123", Name: "John"}, nil)

    // 条件返回
    mockRepo.EXPECT().
        Create(gomock.Any()).
        DoAndReturn(func(user *User) error {
            if user.Name == "" {
                return errors.New("name required")
            }
            user.ID = "new-id"
            return nil
        })

    // 调用顺序
    gomock.InOrder(
        mockRepo.EXPECT().FindByID("1").Return(&User{ID: "1"}, nil),
        mockRepo.EXPECT().Update(gomock.Any()).Return(nil),
        mockRepo.EXPECT().FindByID("1").Return(&User{ID: "1", Name: "Updated"}, nil),
    )

    // 执行测试...
}
```

### 优劣势3

**优势**:

- ✅ 官方Mock工具
- ✅ 自动代码生成
- ✅ 类型安全
- ✅ 强大的期望设置

**劣势**:

- ❌ 需要代码生成
- ❌ 只能Mock接口
- ❌ 设置复杂场景繁琐

---

## 6. GoConvey - Web界面

### 安装3

```bash
go get github.com/smartystreets/goconvey
```

### 基础用法3

```go
import (
    "testing"
    . "github.com/smartystreets/goconvey/convey"
)

func TestUser(t *testing.T) {
    Convey("Given a new user", t, func() {
        user := &User{
            Name:  "John",
            Email: "john@example.com",
        }

        Convey("When validating", func() {
            err := user.Validate()

            Convey("It should not return error", func() {
                So(err, ShouldBeNil)
            })

            Convey("Name should be set", func() {
                So(user.Name, ShouldEqual, "John")
            })
        })

        Convey("When updating email", func() {
            newEmail := "newemail@example.com"
            err := user.UpdateEmail(newEmail)

            Convey("It should succeed", func() {
                So(err, ShouldBeNil)
                So(user.Email, ShouldEqual, newEmail)
            })
        })
    })
}
```

### Web界面

```bash
# 启动Web服务器
goconvey

# 浏览器打开 http://localhost:8080
# 实时查看测试结果，支持自动重跑
```

### 优劣势4

**优势**:

- ✅ 可视化测试结果
- ✅ 实时自动重跑
- ✅ BDD风格
- ✅ 丰富的断言

**劣势**:

- ❌ 需要额外工具
- ❌ DSL风格
- ❌ 性能略差

---

## 7. 性能对比

### 基准测试

```go
// 测试代码
func BenchmarkTestingAssert(b *testing.B) {
    for i := 0; i < b.N; i++ {
        if 1 != 1 {
            b.Error("failed")
        }
    }
}

func BenchmarkTestifyAssert(b *testing.B) {
    t := &testing.T{}
    for i := 0; i < b.N; i++ {
        assert.Equal(t, 1, 1)
    }
}
```

### 性能结果

| 框架 | ns/op | B/op | allocs/op |
|------|-------|------|-----------|
| **testing** | 2.1 | 0 | 0 |
| **Testify/assert** | 145 | 64 | 2 |
| **Testify/require** | 152 | 64 | 2 |
| **Ginkgo** | 312 | 128 | 4 |
| **GoConvey** | 425 | 256 | 6 |

**结论**: 标准库性能最优，Testify性能可接受

---

## 8. 选择建议

### 决策树

```text
项目规模？
├─ 小型 → testing (标准库)
└─ 中大型
    ├─ 团队偏好？
    │   ├─ 传统风格 → Testify
    │   └─ BDD风格
    │       ├─ 需要Web界面 → GoConvey
    │       └─ 不需要 → Ginkgo
    └─ 需要大量Mock？
        └─ 是 → GoMock + Testify
```

---

### 场景推荐

#### 1. 简单库/工具

**推荐**: testing (标准库)

```go
func TestAdd(t *testing.T) {
    result := Add(2, 3)
    if result != 5 {
        t.Errorf("Expected 5, got %d", result)
    }
}
```

**理由**: 简单直接，无依赖

---

#### 2. REST API服务

**推荐**: Testify + httptest

```go
func TestGetUser(t *testing.T) {
    req := httptest.NewRequest("GET", "/users/123", nil)
    rec := httptest.NewRecorder()

    handler.ServeHTTP(rec, req)

    assert.Equal(t, 200, rec.Code)
    assert.Contains(t, rec.Body.String(), "John")
}
```

**理由**: 丰富断言，易于测试HTTP

---

#### 3. 复杂业务逻辑

**推荐**: Ginkgo/Gomega

```go
Describe("OrderService", func() {
    Context("when creating order", func() {
        It("should validate items", func() {
            order := CreateOrder(items)
            Expect(order.Total).To(BeNumerically(">", 0))
        })
    })
})
```

**理由**: BDD风格，描述业务流程清晰

---

#### 4. 微服务

**推荐**: Testify + GoMock

```go
func TestOrderService(t *testing.T) {
    mockUserService := mocks.NewMockUserService(ctrl)
    mockPaymentService := mocks.NewMockPaymentService(ctrl)

    service := NewOrderService(mockUserService, mockPaymentService)
    // 测试服务间交互
}
```

**理由**: 便于Mock外部依赖

---

### 组合使用

**最佳实践**: 混合使用多个工具

```go
import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/suite"
    "github.com/golang/mock/gomock"
)

type ServiceTestSuite struct {
    suite.Suite
    ctrl     *gomock.Controller
    mockRepo *mocks.MockUserRepository
    service  *UserService
}

func (s *ServiceTestSuite) SetupTest() {
    s.ctrl = gomock.NewController(s.T())
    s.mockRepo = mocks.NewMockUserRepository(s.ctrl)
    s.service = NewUserService(s.mockRepo)
}

func (s *ServiceTestSuite) TearDownTest() {
    s.ctrl.Finish()
}

func (s *ServiceTestSuite) TestGetUser() {
    expectedUser := &User{ID: "123", Name: "John"}
    s.mockRepo.EXPECT().FindByID("123").Return(expectedUser, nil)

    user, err := s.service.GetUser("123")

    assert.NoError(s.T(), err)
    assert.Equal(s.T(), "John", user.Name)
}

func TestServiceTestSuite(t *testing.T) {
    suite.Run(t, new(ServiceTestSuite))
}
```

---

### 快速参考

| 需求 | 推荐工具 |
|------|----------|
| 简单项目 | testing |
| 丰富断言 | Testify |
| BDD风格 | Ginkgo |
| Mock接口 | GoMock |
| Web界面 | GoConvey |
| HTTP测试 | httptest |
| 数据库测试 | sqlmock + Testify |

---

## 🔗 相关资源

- [单元测试](./01-单元测试.md)
- [表格驱动测试](./02-表格驱动测试.md)
- [Mock测试](./05-Mock测试.md)
- [测试覆盖率](./04-测试覆盖率.md)

---

**最后更新**: 2025-10-29
**Go版本**: 1.25.3
**文档类型**: 框架对比 ✨
