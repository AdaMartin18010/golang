# æµ‹è¯•æ¡†æ¶å¯¹æ¯”

## ğŸ“‹ ç›®å½•

- [æµ‹è¯•æ¡†æ¶å¯¹æ¯”](#æµ‹è¯•æ¡†æ¶å¯¹æ¯”)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æµ‹è¯•æ¡†æ¶æ¦‚è§ˆ](#1-æµ‹è¯•æ¡†æ¶æ¦‚è§ˆ)
    - [ä¸»æµæµ‹è¯•å·¥å…·å¯¹æ¯”](#ä¸»æµæµ‹è¯•å·¥å…·å¯¹æ¯”)
  - [2. æ ‡å‡†åº“testing](#2-æ ‡å‡†åº“testing)
    - [åŸºç¡€ç”¨æ³•](#åŸºç¡€ç”¨æ³•)
    - [Table-Drivenæµ‹è¯•](#table-drivenæµ‹è¯•)
    - [å­æµ‹è¯•](#å­æµ‹è¯•)
    - [ä¼˜åŠ£åŠ¿](#ä¼˜åŠ£åŠ¿)
  - [3. Testify - æœ€æµè¡Œçš„æµ‹è¯•å·¥å…·](#3-testify---æœ€æµè¡Œçš„æµ‹è¯•å·¥å…·)
    - [å®‰è£…](#å®‰è£…)
    - [Assertæ–­è¨€](#assertæ–­è¨€)
    - [Requireæ–­è¨€ï¼ˆå¤±è´¥å³åœæ­¢ï¼‰](#requireæ–­è¨€å¤±è´¥å³åœæ­¢)
    - [Suiteæµ‹è¯•å¥—ä»¶](#suiteæµ‹è¯•å¥—ä»¶)
    - [Mockå¯¹è±¡](#mockå¯¹è±¡)
    - [ä¼˜åŠ£åŠ¿1](#ä¼˜åŠ£åŠ¿1)
  - [4. Ginkgo/Gomega - BDDé£æ ¼](#4-ginkgogomega---bddé£æ ¼)
    - [å®‰è£…1](#å®‰è£…1)
    - [BDDé£æ ¼æµ‹è¯•](#bddé£æ ¼æµ‹è¯•)
    - [è¡¨æ ¼é©±åŠ¨æµ‹è¯•](#è¡¨æ ¼é©±åŠ¨æµ‹è¯•)
    - [å¼‚æ­¥æµ‹è¯•](#å¼‚æ­¥æµ‹è¯•)
    - [ä¼˜åŠ£åŠ¿2](#ä¼˜åŠ£åŠ¿2)
  - [5. GoMock - Mockæ¡†æ¶](#5-gomock---mockæ¡†æ¶)
    - [å®‰è£…2](#å®‰è£…2)
    - [ç”ŸæˆMock](#ç”Ÿæˆmock)
    - [ä½¿ç”¨Mock](#ä½¿ç”¨mock)
    - [é«˜çº§Mock](#é«˜çº§mock)
    - [ä¼˜åŠ£åŠ¿3](#ä¼˜åŠ£åŠ¿3)
  - [6. GoConvey - Webç•Œé¢](#6-goconvey---webç•Œé¢)
    - [å®‰è£…3](#å®‰è£…3)
    - [åŸºç¡€ç”¨æ³•3](#åŸºç¡€ç”¨æ³•3)
    - [Webç•Œé¢](#webç•Œé¢)
    - [ä¼˜åŠ£åŠ¿4](#ä¼˜åŠ£åŠ¿4)
  - [7. æ€§èƒ½å¯¹æ¯”](#7-æ€§èƒ½å¯¹æ¯”)
    - [åŸºå‡†æµ‹è¯•](#åŸºå‡†æµ‹è¯•)
    - [æ€§èƒ½ç»“æœ](#æ€§èƒ½ç»“æœ)
  - [8. é€‰æ‹©å»ºè®®](#8-é€‰æ‹©å»ºè®®)
    - [å†³ç­–æ ‘](#å†³ç­–æ ‘)
    - [åœºæ™¯æ¨è](#åœºæ™¯æ¨è)
      - [1. ç®€å•åº“/å·¥å…·](#1-ç®€å•åº“å·¥å…·)
      - [2. REST APIæœåŠ¡](#2-rest-apiæœåŠ¡)
      - [3. å¤æ‚ä¸šåŠ¡é€»è¾‘](#3-å¤æ‚ä¸šåŠ¡é€»è¾‘)
      - [4. å¾®æœåŠ¡](#4-å¾®æœåŠ¡)
    - [ç»„åˆä½¿ç”¨](#ç»„åˆä½¿ç”¨)
    - [å¿«é€Ÿå‚è€ƒ](#å¿«é€Ÿå‚è€ƒ)
  - [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

## 1. æµ‹è¯•æ¡†æ¶æ¦‚è§ˆ

### ä¸»æµæµ‹è¯•å·¥å…·å¯¹æ¯”

| æ¡†æ¶/å·¥å…· | Starsâ­ | ç±»å‹ | æ ¸å¿ƒç‰¹ç‚¹ | å­¦ä¹ æ›²çº¿ |
|-----------|---------|------|----------|----------|
| **testing** | stdlib | åŸºç¡€æ¡†æ¶ | æ ‡å‡†åº“ã€ç®€å•å¯é  | â­ |
| **Testify** | 22K+ | æ–­è¨€+Mock | ä¸°å¯Œæ–­è¨€ã€æ˜“ç”¨Mock | â­â­ |
| **Ginkgo** | 8K+ | BDDæ¡†æ¶ | è¡Œä¸ºé©±åŠ¨ã€æè¿°æ€§å¼º | â­â­â­â­ |
| **GoMock** | 9K+ | Mockç”Ÿæˆå™¨ | å®˜æ–¹Mockã€ä»£ç ç”Ÿæˆ | â­â­â­ |
| **GoConvey** | 8K+ | BDD+Web | Webç•Œé¢ã€å®æ—¶åé¦ˆ | â­â­â­ |
| **httptest** | stdlib | HTTPæµ‹è¯• | æ ‡å‡†åº“HTTPæµ‹è¯• | â­ |
| **sqlmock** | 6K+ | SQL Mock | æ•°æ®åº“Mock | â­â­ |

---

## 2. æ ‡å‡†åº“testing

### åŸºç¡€ç”¨æ³•

```go
// user_test.go
package user

import (
    "testing"
)

func TestCreateUser(t *testing.T) {
    user := &User{
        Name:  "John",
        Email: "john@example.com",
        Age:   30,
    }

    err := user.Validate()
    if err != nil {
        t.Errorf("Expected no error, got %v", err)
    }

    if user.Name != "John" {
        t.Errorf("Expected name 'John', got '%s'", user.Name)
    }
}
```

### Table-Drivenæµ‹è¯•

```go
func TestValidateUser(t *testing.T) {
    tests := []struct {
        name    string
        user    User
        wantErr bool
        errMsg  string
    }{
        {
            name:    "valid user",
            user:    User{Name: "John", Email: "john@example.com", Age: 30},
            wantErr: false,
        },
        {
            name:    "empty name",
            user:    User{Name: "", Email: "john@example.com", Age: 30},
            wantErr: true,
            errMsg:  "name is required",
        },
        {
            name:    "invalid email",
            user:    User{Name: "John", Email: "invalid", Age: 30},
            wantErr: true,
            errMsg:  "invalid email format",
        },
        {
            name:    "age too young",
            user:    User{Name: "John", Email: "john@example.com", Age: 10},
            wantErr: true,
            errMsg:  "age must be at least 18",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := tt.user.Validate()

            if (err != nil) != tt.wantErr {
                t.Errorf("Validate() error = %v, wantErr %v", err, tt.wantErr)
                return
            }

            if err != nil && err.Error() != tt.errMsg {
                t.Errorf("Validate() error = %v, want %v", err.Error(), tt.errMsg)
            }
        })
    }
}
```

### å­æµ‹è¯•

```go
func TestUserOperations(t *testing.T) {
    t.Run("Create", func(t *testing.T) {
        user := CreateUser("John", "john@example.com")
        if user == nil {
            t.Fatal("Expected user, got nil")
        }
    })

    t.Run("Update", func(t *testing.T) {
        user := CreateUser("John", "john@example.com")
        err := user.UpdateEmail("newemail@example.com")
        if err != nil {
            t.Errorf("UpdateEmail failed: %v", err)
        }
    })

    t.Run("Delete", func(t *testing.T) {
        user := CreateUser("John", "john@example.com")
        err := user.Delete()
        if err != nil {
            t.Errorf("Delete failed: %v", err)
        }
    })
}
```

### ä¼˜åŠ£åŠ¿

**ä¼˜åŠ¿**:

- âœ… æ ‡å‡†åº“ï¼Œæ— éœ€é¢å¤–ä¾èµ–
- âœ… ç®€å•ç›´æ¥ï¼Œæ˜“äºç†è§£
- âœ… æ€§èƒ½æœ€ä¼˜
- âœ… ä¸å·¥å…·é“¾å®Œç¾é›†æˆ

**åŠ£åŠ¿**:

- âŒ æ–­è¨€ä¸å¤Ÿä¸°å¯Œ
- âŒ é”™è¯¯ä¿¡æ¯ä¸å¤Ÿå‹å¥½
- âŒ ç¼ºå°‘Mockæ”¯æŒ
- âŒ ä»£ç å†—é•¿

---

## 3. Testify - æœ€æµè¡Œçš„æµ‹è¯•å·¥å…·

### å®‰è£…

```bash
go get github.com/stretchr/testify
```

### Assertæ–­è¨€

```go
import (
    "testing"
    "github.com/stretchr/testify/assert"
)

func TestCreateUser(t *testing.T) {
    user := CreateUser("John", "john@example.com")

    // åŸºç¡€æ–­è¨€
    assert.NotNil(t, user)
    assert.Equal(t, "John", user.Name)
    assert.Equal(t, "john@example.com", user.Email)

    // é›†åˆæ–­è¨€
    assert.Contains(t, user.Roles, "user")
    assert.Len(t, user.Roles, 1)

    // é”™è¯¯æ–­è¨€
    err := user.Validate()
    assert.NoError(t, err)
}
```

### Requireæ–­è¨€ï¼ˆå¤±è´¥å³åœæ­¢ï¼‰

```go
import "github.com/stretchr/testify/require"

func TestUserWorkflow(t *testing.T) {
    // å¦‚æœå¤±è´¥ï¼Œç«‹å³åœæ­¢åç»­æµ‹è¯•
    user := CreateUser("John", "john@example.com")
    require.NotNil(t, user, "User should not be nil")

    // åªæœ‰ä¸Šé¢æˆåŠŸæ‰ä¼šæ‰§è¡Œ
    err := user.Save()
    require.NoError(t, err, "Save should succeed")

    // åªæœ‰ä¸Šé¢éƒ½æˆåŠŸæ‰ä¼šæ‰§è¡Œ
    loaded, err := LoadUser(user.ID)
    require.NoError(t, err)
    require.Equal(t, user.ID, loaded.ID)
}
```

### Suiteæµ‹è¯•å¥—ä»¶

```go
import (
    "testing"
    "github.com/stretchr/testify/suite"
)

type UserTestSuite struct {
    suite.Suite
    db     *sql.DB
    repo   *UserRepository
}

// æ¯ä¸ªSuiteæ‰§è¡Œå‰è¿è¡Œä¸€æ¬¡
func (s *UserTestSuite) SetupSuite() {
    db, err := sql.Open("postgres", "test_db_url")
    s.Require().NoError(err)
    s.db = db
    s.repo = NewUserRepository(db)
}

// æ¯ä¸ªæµ‹è¯•å‰è¿è¡Œ
func (s *UserTestSuite) SetupTest() {
    // æ¸…ç†æ•°æ®
    s.db.Exec("TRUNCATE users")
}

// æµ‹è¯•æ–¹æ³•
func (s *UserTestSuite) TestCreateUser() {
    user := &User{Name: "John", Email: "john@example.com"}
    err := s.repo.Create(user)

    s.NoError(err)
    s.NotEmpty(user.ID)
}

func (s *UserTestSuite) TestFindUser() {
    // å‡†å¤‡æ•°æ®
    user := &User{Name: "John", Email: "john@example.com"}
    s.repo.Create(user)

    // æµ‹è¯•æŸ¥æ‰¾
    found, err := s.repo.FindByID(user.ID)
    s.NoError(err)
    s.Equal(user.ID, found.ID)
}

// æ¯ä¸ªSuiteæ‰§è¡Œåè¿è¡Œä¸€æ¬¡
func (s *UserTestSuite) TearDownSuite() {
    s.db.Close()
}

// è¿è¡ŒSuite
func TestUserTestSuite(t *testing.T) {
    suite.Run(t, new(UserTestSuite))
}
```

### Mockå¯¹è±¡

```go
import "github.com/stretchr/testify/mock"

// Mockå®šä¹‰
type MockUserRepository struct {
    mock.Mock
}

func (m *MockUserRepository) FindByID(id string) (*User, error) {
    args := m.Called(id)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*User), args.Error(1)
}

func (m *MockUserRepository) Create(user *User) error {
    args := m.Called(user)
    return args.Error(0)
}

// ä½¿ç”¨Mock
func TestUserService(t *testing.T) {
    mockRepo := new(MockUserRepository)
    service := NewUserService(mockRepo)

    // è®¾ç½®æœŸæœ›
    expectedUser := &User{ID: "123", Name: "John"}
    mockRepo.On("FindByID", "123").Return(expectedUser, nil)

    // æ‰§è¡Œæµ‹è¯•
    user, err := service.GetUser("123")

    // éªŒè¯
    assert.NoError(t, err)
    assert.Equal(t, "John", user.Name)
    mockRepo.AssertExpectations(t)
}
```

### ä¼˜åŠ£åŠ¿1

**ä¼˜åŠ¿**:

- âœ… ä¸°å¯Œçš„æ–­è¨€å‡½æ•°
- âœ… å‹å¥½çš„é”™è¯¯ä¿¡æ¯
- âœ… Suiteç»„ç»‡æµ‹è¯•
- âœ… å†…ç½®Mockæ”¯æŒ
- âœ… ç¤¾åŒºæœ€æ´»è·ƒ

**åŠ£åŠ¿**:

- âŒ éœ€è¦é¢å¤–ä¾èµ–
- âŒ Mockéœ€è¦æ‰‹å†™
- âŒ ç•¥å¾®å½±å“æ€§èƒ½

---

## 4. Ginkgo/Gomega - BDDé£æ ¼

### å®‰è£…1

```bash
go install github.com/onsi/ginkgo/v2/ginkgo
go get github.com/onsi/gomega/...
```

### BDDé£æ ¼æµ‹è¯•

```go
package user_test

import (
    . "github.com/onsi/ginkgo/v2"
    . "github.com/onsi/gomega"
    "testing"
)

func TestUser(t *testing.T) {
    RegisterFailHandler(Fail)
    RunSpecs(t, "User Suite")
}

var _ = Describe("User", func() {
    var user *User

    BeforeEach(func() {
        user = &User{
            Name:  "John",
            Email: "john@example.com",
            Age:   30,
        }
    })

    Context("when validating", func() {
        It("should accept valid user", func() {
            err := user.Validate()
            Expect(err).NotTo(HaveOccurred())
        })

        It("should reject empty name", func() {
            user.Name = ""
            err := user.Validate()
            Expect(err).To(HaveOccurred())
            Expect(err.Error()).To(ContainSubstring("name is required"))
        })

        It("should reject invalid email", func() {
            user.Email = "invalid"
            err := user.Validate()
            Expect(err).To(MatchError(ContainSubstring("invalid email")))
        })
    })

    Context("when creating", func() {
        var repo *UserRepository

        BeforeEach(func() {
            repo = NewUserRepository(testDB)
        })

        It("should save to database", func() {
            err := repo.Create(user)
            Expect(err).NotTo(HaveOccurred())
            Expect(user.ID).NotTo(BeEmpty())
        })

        It("should be retrievable", func() {
            repo.Create(user)

            found, err := repo.FindByID(user.ID)
            Expect(err).NotTo(HaveOccurred())
            Expect(found).To(Equal(user))
        })
    })

    Describe("UpdateEmail", func() {
        It("should update email successfully", func() {
            newEmail := "newemail@example.com"
            err := user.UpdateEmail(newEmail)

            Expect(err).NotTo(HaveOccurred())
            Expect(user.Email).To(Equal(newEmail))
        })

        When("email is invalid", func() {
            It("should return error", func() {
                err := user.UpdateEmail("invalid")
                Expect(err).To(HaveOccurred())
            })
        })
    })
})
```

### è¡¨æ ¼é©±åŠ¨æµ‹è¯•

```go
var _ = Describe("User Validation", func() {
    DescribeTable("validate different scenarios",
        func(name, email string, age int, shouldFail bool) {
            user := &User{Name: name, Email: email, Age: age}
            err := user.Validate()

            if shouldFail {
                Expect(err).To(HaveOccurred())
            } else {
                Expect(err).NotTo(HaveOccurred())
            }
        },
        Entry("valid user", "John", "john@example.com", 30, false),
        Entry("empty name", "", "john@example.com", 30, true),
        Entry("invalid email", "John", "invalid", 30, true),
        Entry("underage", "John", "john@example.com", 15, true),
    )
})
```

### å¼‚æ­¥æµ‹è¯•

```go
var _ = Describe("Async Operations", func() {
    It("should complete within timeout", func() {
        done := make(chan bool)

        go func() {
            defer GinkgoRecover()
            time.Sleep(100 * time.Millisecond)
            done <- true
        }()

        Eventually(done, "200ms").Should(Receive(BeTrue()))
    })

    It("should poll until condition is met", func() {
        counter := 0

        Eventually(func() int {
            counter++
            return counter
        }, "1s", "100ms").Should(BeNumerically(">", 5))
    })
})
```

### ä¼˜åŠ£åŠ¿2

**ä¼˜åŠ¿**:

- âœ… BDDé£æ ¼ï¼Œæè¿°æ€§å¼º
- âœ… ä¼˜ç§€çš„æµ‹è¯•ç»„ç»‡
- âœ… å¼ºå¤§çš„å¼‚æ­¥æµ‹è¯•
- âœ… ä¸°å¯Œçš„Matcher
- âœ… å¹¶è¡Œæµ‹è¯•æ”¯æŒ

**åŠ£åŠ¿**:

- âŒ å­¦ä¹ æ›²çº¿é™¡å³­
- âŒ DSLé£æ ¼ä¸é€‚åˆæ‰€æœ‰äºº
- âŒ éœ€è¦é¢å¤–å·¥å…·
- âŒ IDEæ”¯æŒä¸å¦‚æ ‡å‡†åº“

---

## 5. GoMock - Mockæ¡†æ¶

### å®‰è£…2

```bash
go install github.com/golang/mock/mockgen@latest
```

### ç”ŸæˆMock

```go
// user_repository.go
package user

//go:generate mockgen -source=user_repository.go -destination=mocks/mock_user_repository.go -package=mocks

type UserRepository interface {
    FindByID(id string) (*User, error)
    Create(user *User) error
    Update(user *User) error
    Delete(id string) error
}
```

```bash
# ç”ŸæˆMock
go generate ./...
```

### ä½¿ç”¨Mock

```go
import (
    "testing"
    "github.com/golang/mock/gomock"
    "myapp/user/mocks"
)

func TestUserService_GetUser(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()

    // åˆ›å»ºMock
    mockRepo := mocks.NewMockUserRepository(ctrl)
    service := NewUserService(mockRepo)

    // è®¾ç½®æœŸæœ›
    expectedUser := &User{ID: "123", Name: "John"}
    mockRepo.EXPECT().
        FindByID("123").
        Return(expectedUser, nil).
        Times(1)

    // æ‰§è¡Œ
    user, err := service.GetUser("123")

    // éªŒè¯
    if err != nil {
        t.Errorf("Expected no error, got %v", err)
    }
    if user.Name != "John" {
        t.Errorf("Expected name 'John', got '%s'", user.Name)
    }
}
```

### é«˜çº§Mock

```go
func TestComplexScenario(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()

    mockRepo := mocks.NewMockUserRepository(ctrl)
    service := NewUserService(mockRepo)

    // å‚æ•°åŒ¹é…
    mockRepo.EXPECT().
        FindByID(gomock.Any()).
        Return(&User{ID: "123", Name: "John"}, nil)

    // æ¡ä»¶è¿”å›
    mockRepo.EXPECT().
        Create(gomock.Any()).
        DoAndReturn(func(user *User) error {
            if user.Name == "" {
                return errors.New("name required")
            }
            user.ID = "new-id"
            return nil
        })

    // è°ƒç”¨é¡ºåº
    gomock.InOrder(
        mockRepo.EXPECT().FindByID("1").Return(&User{ID: "1"}, nil),
        mockRepo.EXPECT().Update(gomock.Any()).Return(nil),
        mockRepo.EXPECT().FindByID("1").Return(&User{ID: "1", Name: "Updated"}, nil),
    )

    // æ‰§è¡Œæµ‹è¯•...
}
```

### ä¼˜åŠ£åŠ¿3

**ä¼˜åŠ¿**:

- âœ… å®˜æ–¹Mockå·¥å…·
- âœ… è‡ªåŠ¨ä»£ç ç”Ÿæˆ
- âœ… ç±»å‹å®‰å…¨
- âœ… å¼ºå¤§çš„æœŸæœ›è®¾ç½®

**åŠ£åŠ¿**:

- âŒ éœ€è¦ä»£ç ç”Ÿæˆ
- âŒ åªèƒ½Mockæ¥å£
- âŒ è®¾ç½®å¤æ‚åœºæ™¯ç¹ç

---

## 6. GoConvey - Webç•Œé¢

### å®‰è£…3

```bash
go get github.com/smartystreets/goconvey
```

### åŸºç¡€ç”¨æ³•3

```go
import (
    "testing"
    . "github.com/smartystreets/goconvey/convey"
)

func TestUser(t *testing.T) {
    Convey("Given a new user", t, func() {
        user := &User{
            Name:  "John",
            Email: "john@example.com",
        }

        Convey("When validating", func() {
            err := user.Validate()

            Convey("It should not return error", func() {
                So(err, ShouldBeNil)
            })

            Convey("Name should be set", func() {
                So(user.Name, ShouldEqual, "John")
            })
        })

        Convey("When updating email", func() {
            newEmail := "newemail@example.com"
            err := user.UpdateEmail(newEmail)

            Convey("It should succeed", func() {
                So(err, ShouldBeNil)
                So(user.Email, ShouldEqual, newEmail)
            })
        })
    })
}
```

### Webç•Œé¢

```bash
# å¯åŠ¨WebæœåŠ¡å™¨
goconvey

# æµè§ˆå™¨æ‰“å¼€ http://localhost:8080
# å®æ—¶æŸ¥çœ‹æµ‹è¯•ç»“æœï¼Œæ”¯æŒè‡ªåŠ¨é‡è·‘
```

### ä¼˜åŠ£åŠ¿4

**ä¼˜åŠ¿**:

- âœ… å¯è§†åŒ–æµ‹è¯•ç»“æœ
- âœ… å®æ—¶è‡ªåŠ¨é‡è·‘
- âœ… BDDé£æ ¼
- âœ… ä¸°å¯Œçš„æ–­è¨€

**åŠ£åŠ¿**:

- âŒ éœ€è¦é¢å¤–å·¥å…·
- âŒ DSLé£æ ¼
- âŒ æ€§èƒ½ç•¥å·®

---

## 7. æ€§èƒ½å¯¹æ¯”

### åŸºå‡†æµ‹è¯•

```go
// æµ‹è¯•ä»£ç 
func BenchmarkTestingAssert(b *testing.B) {
    for i := 0; i < b.N; i++ {
        if 1 != 1 {
            b.Error("failed")
        }
    }
}

func BenchmarkTestifyAssert(b *testing.B) {
    t := &testing.T{}
    for i := 0; i < b.N; i++ {
        assert.Equal(t, 1, 1)
    }
}
```

### æ€§èƒ½ç»“æœ

| æ¡†æ¶ | ns/op | B/op | allocs/op |
|------|-------|------|-----------|
| **testing** | 2.1 | 0 | 0 |
| **Testify/assert** | 145 | 64 | 2 |
| **Testify/require** | 152 | 64 | 2 |
| **Ginkgo** | 312 | 128 | 4 |
| **GoConvey** | 425 | 256 | 6 |

**ç»“è®º**: æ ‡å‡†åº“æ€§èƒ½æœ€ä¼˜ï¼ŒTestifyæ€§èƒ½å¯æ¥å—

---

## 8. é€‰æ‹©å»ºè®®

### å†³ç­–æ ‘

```text
é¡¹ç›®è§„æ¨¡ï¼Ÿ
â”œâ”€ å°å‹ â†’ testing (æ ‡å‡†åº“)
â””â”€ ä¸­å¤§å‹
    â”œâ”€ å›¢é˜Ÿåå¥½ï¼Ÿ
    â”‚   â”œâ”€ ä¼ ç»Ÿé£æ ¼ â†’ Testify
    â”‚   â””â”€ BDDé£æ ¼
    â”‚       â”œâ”€ éœ€è¦Webç•Œé¢ â†’ GoConvey
    â”‚       â””â”€ ä¸éœ€è¦ â†’ Ginkgo
    â””â”€ éœ€è¦å¤§é‡Mockï¼Ÿ
        â””â”€ æ˜¯ â†’ GoMock + Testify
```

---

### åœºæ™¯æ¨è

#### 1. ç®€å•åº“/å·¥å…·

**æ¨è**: testing (æ ‡å‡†åº“)

```go
func TestAdd(t *testing.T) {
    result := Add(2, 3)
    if result != 5 {
        t.Errorf("Expected 5, got %d", result)
    }
}
```

**ç†ç”±**: ç®€å•ç›´æ¥ï¼Œæ— ä¾èµ–

---

#### 2. REST APIæœåŠ¡

**æ¨è**: Testify + httptest

```go
func TestGetUser(t *testing.T) {
    req := httptest.NewRequest("GET", "/users/123", nil)
    rec := httptest.NewRecorder()

    handler.ServeHTTP(rec, req)

    assert.Equal(t, 200, rec.Code)
    assert.Contains(t, rec.Body.String(), "John")
}
```

**ç†ç”±**: ä¸°å¯Œæ–­è¨€ï¼Œæ˜“äºæµ‹è¯•HTTP

---

#### 3. å¤æ‚ä¸šåŠ¡é€»è¾‘

**æ¨è**: Ginkgo/Gomega

```go
Describe("OrderService", func() {
    Context("when creating order", func() {
        It("should validate items", func() {
            order := CreateOrder(items)
            Expect(order.Total).To(BeNumerically(">", 0))
        })
    })
})
```

**ç†ç”±**: BDDé£æ ¼ï¼Œæè¿°ä¸šåŠ¡æµç¨‹æ¸…æ™°

---

#### 4. å¾®æœåŠ¡

**æ¨è**: Testify + GoMock

```go
func TestOrderService(t *testing.T) {
    mockUserService := mocks.NewMockUserService(ctrl)
    mockPaymentService := mocks.NewMockPaymentService(ctrl)

    service := NewOrderService(mockUserService, mockPaymentService)
    // æµ‹è¯•æœåŠ¡é—´äº¤äº’
}
```

**ç†ç”±**: ä¾¿äºMockå¤–éƒ¨ä¾èµ–

---

### ç»„åˆä½¿ç”¨

**æœ€ä½³å®è·µ**: æ··åˆä½¿ç”¨å¤šä¸ªå·¥å…·

```go
import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/suite"
    "github.com/golang/mock/gomock"
)

type ServiceTestSuite struct {
    suite.Suite
    ctrl     *gomock.Controller
    mockRepo *mocks.MockUserRepository
    service  *UserService
}

func (s *ServiceTestSuite) SetupTest() {
    s.ctrl = gomock.NewController(s.T())
    s.mockRepo = mocks.NewMockUserRepository(s.ctrl)
    s.service = NewUserService(s.mockRepo)
}

func (s *ServiceTestSuite) TearDownTest() {
    s.ctrl.Finish()
}

func (s *ServiceTestSuite) TestGetUser() {
    expectedUser := &User{ID: "123", Name: "John"}
    s.mockRepo.EXPECT().FindByID("123").Return(expectedUser, nil)

    user, err := s.service.GetUser("123")

    assert.NoError(s.T(), err)
    assert.Equal(s.T(), "John", user.Name)
}

func TestServiceTestSuite(t *testing.T) {
    suite.Run(t, new(ServiceTestSuite))
}
```

---

### å¿«é€Ÿå‚è€ƒ

| éœ€æ±‚ | æ¨èå·¥å…· |
|------|----------|
| ç®€å•é¡¹ç›® | testing |
| ä¸°å¯Œæ–­è¨€ | Testify |
| BDDé£æ ¼ | Ginkgo |
| Mockæ¥å£ | GoMock |
| Webç•Œé¢ | GoConvey |
| HTTPæµ‹è¯• | httptest |
| æ•°æ®åº“æµ‹è¯• | sqlmock + Testify |

---

## ğŸ”— ç›¸å…³èµ„æº

- [å•å…ƒæµ‹è¯•](./01-å•å…ƒæµ‹è¯•.md)
- [è¡¨æ ¼é©±åŠ¨æµ‹è¯•](./02-è¡¨æ ¼é©±åŠ¨æµ‹è¯•.md)
- [Mockæµ‹è¯•](./05-Mockæµ‹è¯•.md)
- [æµ‹è¯•è¦†ç›–ç‡](./04-æµ‹è¯•è¦†ç›–ç‡.md)

---

**æœ€åæ›´æ–°**: 2025-10-29
**Goç‰ˆæœ¬**: 1.25.3
**æ–‡æ¡£ç±»å‹**: æ¡†æ¶å¯¹æ¯” âœ¨
