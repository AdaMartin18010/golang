# 测试最佳实践

**难度**: 中级 | **预计阅读**: 15分钟 | **前置知识**: 单元测试、集成测试

---

## 📋 目录

- [1. 📖 概念介绍](#1--概念介绍)
- [2. 🎯 核心原则](#2--核心原则)
- [3. 💡 最佳实践清单](#3--最佳实践清单)
- [4. 🔧 工具推荐](#4--工具推荐)
- [5. 📋 测试检查清单](#5--测试检查清单)
- [6. ⚠️ 常见陷阱](#6-️-常见陷阱)
- [7. 📚 相关资源](#7--相关资源)

---

## 1. 📖 概念介绍

测试最佳实践是经过验证的测试方法和原则，遵循这些实践可以编写出高质量、可维护的测试代码。

---

## 2. 🎯 核心原则

### 2.1 测试金字塔

```
        /\
       /  \
      / E2E \       少量：端到端测试
     /-------\
    /集成测试 \      适量：集成测试
   /-----------\
  /  单元测试   \    大量：单元测试
 /--------------\
```

**比例建议**: 70% 单元 + 20% 集成 + 10% E2E

---

### 2.2 FIRST原则

- **F**ast - 快速：测试应该快速执行
- **I**solated - 隔离：测试互不依赖
- **R**epeatable - 可重复：每次运行结果一致
- **S**elf-validating - 自验证：自动判断通过/失败
- **T**imely - 及时：与生产代码同步编写

---

### 2.3 AAA模式

```go
func TestUserService_Create(t *testing.T) {
    // Arrange（准备）
    repo := setupMockRepository()
    service := NewUserService(repo)
    user := &User{Name: "Alice", Email: "alice@example.com"}
    
    // Act（执行）
    err := service.Create(user)
    
    // Assert（断言）
    if err != nil {
        t.Errorf("Create() failed: %v", err)
    }
}
```

---

## 3. 💡 最佳实践清单

### 3.1 测试命名

```go
// ✅ 好：描述测试场景
func TestUserService_Create_WithValidData_Succeeds(t *testing.T)
func TestUserService_Create_WithDuplicateEmail_ReturnsError(t *testing.T)

// ❌ 差：不清晰
func TestCreate(t *testing.T)
func TestCreate2(t *testing.T)
```

---

### 3.2 测试独立性

```go
// ✅ 好：每个测试独立
func TestAdd(t *testing.T) {
    result := Add(2, 3)
    assert.Equal(t, 5, result)
}

func TestSubtract(t *testing.T) {
    result := Subtract(5, 3)
    assert.Equal(t, 2, result)
}

// ❌ 差：测试依赖全局状态
var globalCounter int

func TestIncrement(t *testing.T) {
    globalCounter++ // 依赖执行顺序
    assert.Equal(t, 1, globalCounter)
}
```

---

### 3.3 一个测试一个断言

```go
// ✅ 好：关注点单一
func TestUser_Name(t *testing.T) {
    user := User{Name: "Alice"}
    assert.Equal(t, "Alice", user.Name)
}

func TestUser_Email(t *testing.T) {
    user := User{Email: "alice@example.com"}
    assert.Equal(t, "alice@example.com", user.Email)
}

// ❌ 差：多个断言
func TestUser(t *testing.T) {
    user := User{Name: "Alice", Email: "alice@example.com"}
    assert.Equal(t, "Alice", user.Name)
    assert.Equal(t, "alice@example.com", user.Email) // 第一个失败后不会执行
}
```

---

### 3.4 清晰的错误消息

```go
// ✅ 好：清晰的错误消息
func TestAdd(t *testing.T) {
    got := Add(2, 3)
    want := 5
    if got != want {
        t.Errorf("Add(2, 3) = %d; want %d", got, want)
    }
}

// ❌ 差：不清晰
func TestAdd(t *testing.T) {
    if Add(2, 3) != 5 {
        t.Error("failed")
    }
}
```

---

### 3.5 测试边界条件

```go
func TestDivide(t *testing.T) {
    tests := []struct {
        name string
        a, b float64
        want float64
        wantErr bool
    }{
        {"正常情况", 10, 2, 5, false},
        {"除以零", 10, 0, 0, true},          // 边界
        {"负数", -10, 2, -5, false},
        {"零除以数", 0, 5, 0, false},        // 边界
        {"极大数", math.MaxFloat64, 2, math.MaxFloat64/2, false}, // 边界
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := Divide(tt.a, tt.b)
            if (err != nil) != tt.wantErr {
                t.Errorf("wantErr %v, got err %v", tt.wantErr, err)
            }
            if !tt.wantErr && got != tt.want {
                t.Errorf("got %v, want %v", got, tt.want)
            }
        })
    }
}
```

---

### 3.6 使用Table-Driven Tests

```go
// ✅ 好：表格驱动
func TestValidateEmail(t *testing.T) {
    tests := []struct {
        email string
        valid bool
    }{
        {"valid@example.com", true},
        {"invalid", false},
        {"@example.com", false},
        {"user@", false},
        {"", false},
    }
    
    for _, tt := range tests {
        t.Run(tt.email, func(t *testing.T) {
            got := ValidateEmail(tt.email)
            if got != tt.valid {
                t.Errorf("ValidateEmail(%q) = %v; want %v", tt.email, got, tt.valid)
            }
        })
    }
}
```

---

### 3.7 测试应该快速

```go
// ✅ 好：快速测试
func TestQuickOperation(t *testing.T) {
    result := QuickCalculation(10)
    assert.Equal(t, 100, result)
}

// ❌ 差：慢测试
func TestSlowOperation(t *testing.T) {
    time.Sleep(5 * time.Second) // 避免
    // ...
}

// ✅ 改进：使用Short模式跳过慢测试
func TestSlowOperation(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping slow test in short mode")
    }
    // ... 慢操作
}

// 运行：go test -short
```

---

### 3.8 正确使用t.Helper()

```go
func assertEqual(t *testing.T, got, want int) {
    t.Helper() // 标记为辅助函数
    if got != want {
        t.Errorf("got %d, want %d", got, want) // 错误会指向调用者
    }
}

func TestSomething(t *testing.T) {
    result := Calculate(10)
    assertEqual(t, result, 100) // 如果失败，错误指向这一行
}
```

---

### 3.9 清理资源

```go
func TestWithCleanup(t *testing.T) {
    // Setup
    file, err := os.Create("test.txt")
    if err != nil {
        t.Fatal(err)
    }
    
    // 注册清理函数
    t.Cleanup(func() {
        file.Close()
        os.Remove("test.txt")
    })
    
    // 测试逻辑
    _, err = file.WriteString("test data")
    if err != nil {
        t.Fatal(err)
    }
}
```

---

### 3.10 测试错误情况

```go
func TestUserService_Create_ErrorCases(t *testing.T) {
    tests := []struct {
        name    string
        user    *User
        wantErr string
    }{
        {
            name:    "空用户名",
            user:    &User{Name: "", Email: "test@example.com"},
            wantErr: "name is required",
        },
        {
            name:    "无效邮箱",
            user:    &User{Name: "Alice", Email: "invalid"},
            wantErr: "invalid email format",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            service := NewUserService(mockRepo)
            err := service.Create(tt.user)
            
            if err == nil {
                t.Error("expected error, got nil")
            } else if err.Error() != tt.wantErr {
                t.Errorf("error = %q, want %q", err.Error(), tt.wantErr)
            }
        })
    }
}
```

---

## 4. 🔧 工具推荐

### 4.1 testify
```go
import "github.com/stretchr/testify/assert"

func TestSomething(t *testing.T) {
    assert.Equal(t, expected, actual)
    assert.NoError(t, err)
    assert.True(t, condition)
}
```

### 4.2 gomock
```bash
go install github.com/golang/mock/mockgen@latest
```

### 4.3 golangci-lint
```bash
golangci-lint run --enable=testpackage
```

---

## 5. 📋 测试检查清单

### 编写测试前
- [ ] 明确测试目标
- [ ] 识别边界条件
- [ ] 规划测试用例

### 编写测试时
- [ ] 使用描述性的测试名称
- [ ] 遵循AAA模式
- [ ] 一个测试一个关注点
- [ ] 包含正常和错误情况
- [ ] 测试边界值

### 编写测试后
- [ ] 测试能独立运行
- [ ] 测试运行快速
- [ ] 有清晰的错误消息
- [ ] 资源正确清理
- [ ] 覆盖率达标

---

## 6. ⚠️ 常见陷阱

### 6.1 测试实现而非行为
```go
// ❌ 差：测试实现细节
func TestUserService_Create(t *testing.T) {
    // 测试内部如何调用数据库
}

// ✅ 好：测试行为
func TestUserService_Create(t *testing.T) {
    // 测试用户是否被正确创建
}
```

### 6.2 过度Mock
```go
// ❌ 差：Mock太多
mockRepo := NewMockRepo()
mockCache := NewMockCache()
mockLogger := NewMockLogger()
mockMetrics := NewMockMetrics()
// ... 太多Mock

// ✅ 好：只Mock必要的
mockRepo := NewMockRepo()
service := NewUserService(mockRepo)
```

### 6.3 测试间有依赖
```go
// ❌ 差：测试依赖顺序
func TestA(t *testing.T) {
    setupGlobalState()
}

func TestB(t *testing.T) {
    useGlobalState() // 依赖TestA
}
```

---

## 7. 📚 相关资源

- [Go Testing Guide](https://go.dev/doc/code#Testing)
- [Table Driven Tests](https://go.dev/wiki/TableDrivenTests)
- [testify](https://github.com/stretchr/testify)

---

**最后更新**: 2025-10-28
