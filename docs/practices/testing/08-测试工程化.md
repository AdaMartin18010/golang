# Go测试工程化

> **简介**: Go测试工程化完整指南，包括测试组织、CI/CD集成和质量保证

> **版本**: Go 1.25.3  
> **难度**: ⭐⭐⭐⭐  
> **标签**: #测试 #工程化 #CI/CD #质量保证

---

## 📚 目录

1. [测试组织结构](#测试组织结构)
2. [CI/CD集成](#cicd集成)
3. [测试报告](#测试报告)
4. [质量门禁](#质量门禁)
5. [最佳实践](#最佳实践)

---

## 1. 测试组织结构

### 标准项目结构

```
myproject/
├── cmd/
│   └── myapp/
│       └── main.go
├── internal/
│   ├── handler/
│   │   ├── user.go
│   │   └── user_test.go
│   └── service/
│       ├── auth.go
│       └── auth_test.go
├── pkg/
│   └── utils/
│       ├── string.go
│       └── string_test.go
├── test/
│   ├── integration/
│   │   └── api_test.go
│   ├── e2e/
│   │   └── user_flow_test.go
│   └── testdata/
│       └── fixtures/
├── go.mod
└── Makefile
```

---

### 测试文件命名

```go
// 单元测试
user.go → user_test.go

// 集成测试
user_integration_test.go

// E2E测试
user_e2e_test.go

// 性能测试
user_bench_test.go
```

---

### 使用build tags分离测试

```go
//go:build integration
// +build integration

package integration

import "testing"

func TestUserAPI(t *testing.T) {
    // 集成测试代码
}
```

**运行**:
```bash
# 只运行集成测试
go test -tags=integration ./...

# 运行所有测试
go test -tags=integration,e2e ./...
```

---

## 2. CI/CD集成

### GitHub Actions

```yaml
# .github/workflows/test.yml
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.25.3'
    
    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-
    
    - name: Download dependencies
      run: go mod download
    
    - name: Run tests
      run: go test -v -race -coverprofile=coverage.out ./...
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        files: ./coverage.out
```

---

### GitLab CI

```yaml
# .gitlab-ci.yml
stages:
  - test
  - integration

test:
  stage: test
  image: golang:1.25.3
  script:
    - go test -v -race -coverprofile=coverage.out ./...
    - go tool cover -html=coverage.out -o coverage.html
  artifacts:
    paths:
      - coverage.html
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml

integration:
  stage: integration
  image: golang:1.25.3
  services:
    - postgres:15
    - redis:7
  variables:
    POSTGRES_DB: testdb
    POSTGRES_USER: test
    POSTGRES_PASSWORD: test
  script:
    - go test -tags=integration -v ./test/integration/...
```

---

### Makefile

```makefile
.PHONY: test test-unit test-integration test-e2e test-coverage

# 运行所有测试
test:
	go test -v -race ./...

# 单元测试
test-unit:
	go test -v -short ./...

# 集成测试
test-integration:
	go test -v -tags=integration ./test/integration/...

# E2E测试
test-e2e:
	go test -v -tags=e2e ./test/e2e/...

# 覆盖率
test-coverage:
	go test -v -race -coverprofile=coverage.out ./...
	go tool cover -html=coverage.out -o coverage.html
	go tool cover -func=coverage.out

# 性能测试
test-bench:
	go test -bench=. -benchmem ./...

# 所有质量检查
qa: lint test test-coverage
	@echo "Quality assurance completed"

# Lint
lint:
	golangci-lint run ./...
```

---

## 3. 测试报告

### 生成HTML报告

```bash
# 覆盖率报告
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out -o coverage.html

# 使用gotestsum生成更好的报告
go install gotest.tools/gotestsum@latest
gotestsum --format testname --junitfile report.xml
```

---

### 集成Codecov

```yaml
# .github/workflows/test.yml
- name: Upload coverage to Codecov
  uses: codecov/codecov-action@v3
  with:
    files: ./coverage.out
    flags: unittests
    name: codecov-umbrella
```

---

### SonarQube集成

```bash
# 安装sonar-scanner
# 运行分析
sonar-scanner \
  -Dsonar.projectKey=myproject \
  -Dsonar.sources=. \
  -Dsonar.go.coverage.reportPaths=coverage.out
```

---

## 4. 质量门禁

### 覆盖率门禁

```bash
# 脚本：check-coverage.sh
#!/bin/bash

COVERAGE=$(go test -coverprofile=coverage.out ./... | \
           grep "coverage:" | \
           awk '{print $NF}' | \
           sed 's/%//')

THRESHOLD=80

if (( $(echo "$COVERAGE < $THRESHOLD" | bc -l) )); then
    echo "Coverage $COVERAGE% is below threshold $THRESHOLD%"
    exit 1
fi

echo "Coverage $COVERAGE% meets threshold"
```

---

### 代码质量检查

```yaml
# .github/workflows/qa.yml
name: Quality Assurance

on: [push, pull_request]

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: golangci/golangci-lint-action@v3
      with:
        version: latest
        args: --timeout=5m

  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Run tests
      run: |
        go test -v -race -coverprofile=coverage.out ./...
        bash check-coverage.sh
```

---

### 性能回归检测

```go
// benchstat比较
// 运行基准测试两次
go test -bench=. -count=5 > old.txt
# 修改代码
go test -bench=. -count=5 > new.txt

// 使用benchstat比较
go install golang.org/x/perf/cmd/benchstat@latest
benchstat old.txt new.txt
```

---

## 5. 最佳实践

### 1. 测试金字塔

```
        ┌────────┐
        │  E2E   │  10%
        ├────────┤
        │ Integr │  20%
        ├────────┤
        │  Unit  │  70%
        └────────┘
```

**建议比例**:
- 单元测试: 70%
- 集成测试: 20%
- E2E测试: 10%

---

### 2. 快速反馈循环

```bash
# 本地开发：只运行单元测试
make test-unit  # < 10秒

# PR检查：单元测试 + 集成测试
make test-integration  # < 1分钟

# 发布前：所有测试
make test  # < 5分钟
```

---

### 3. 并行测试

```go
func TestParallel(t *testing.T) {
    tests := []struct {
        name string
        // ...
    }{
        // test cases
    }
    
    for _, tt := range tests {
        tt := tt  // 捕获变量
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()  // 并行运行
            // 测试代码
        })
    }
}
```

---

### 4. 测试数据管理

```
test/
└── testdata/
    ├── fixtures/
    │   ├── users.json
    │   └── products.json
    ├── golden/
    │   └── output.golden
    └── mocks/
        └── api_responses.json
```

```go
func loadTestData(t *testing.T, filename string) []byte {
    data, err := os.ReadFile(filepath.Join("testdata", filename))
    if err != nil {
        t.Fatal(err)
    }
    return data
}
```

---

### 5. 测试环境隔离

```go
func TestWithDocker(t *testing.T) {
    // 使用testcontainers启动依赖
    ctx := context.Background()
    
    req := testcontainers.ContainerRequest{
        Image:        "postgres:15",
        ExposedPorts: []string{"5432/tcp"},
        Env: map[string]string{
            "POSTGRES_PASSWORD": "test",
        },
    }
    
    postgres, _ := testcontainers.GenericContainer(ctx, 
        testcontainers.GenericContainerRequest{
            ContainerRequest: req,
            Started:          true,
        })
    defer postgres.Terminate(ctx)
    
    // 运行测试
}
```

---

## 🔗 相关资源

- [单元测试](./01-单元测试.md)
- [集成测试](./03-集成测试.md)
- [测试覆盖率](./05-测试覆盖率.md)
- [CI/CD流程](../../deployment/04-CI-CD流程.md)

---

**最后更新**: 2025-10-28  
**Go版本**: 1.25.3

