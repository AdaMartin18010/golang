# 单元测试

**难度**: 中级 | **预计阅读**: 20分钟 | **前置知识**: Go基础语法、testing包

---

## 📋 目录

- [1. 📖 概念介绍](#1--概念介绍)
- [2. 🎯 核心知识点](#2--核心知识点)
  - [2.1 基础测试编写](#21-基础测试编写)
  - [2.2 表格驱动测试](#22-表格驱动测试)
  - [2.3 测试辅助函数](#23-测试辅助函数)
  - [2.4 Setup和Teardown](#24-setup和teardown)
  - [2.5 错误场景测试](#25-错误场景测试)
- [3. 🏗️ 实战案例](#3-️-实战案例)
- [4. ⚠️ 常见问题](#4-️-常见问题)
- [5. 💡 最佳实践](#5--最佳实践)
- [6. 📚 相关资源](#6--相关资源)

---

## 1. 📖 概念介绍

单元测试是Go测试体系的基础，用于验证单个函数或方法的行为是否符合预期。Go内置的testing包提供了简洁而强大的测试支持，无需第三方框架即可编写高质量的单元测试。

---

## 2. 🎯 核心知识点

### 2.1 基础测试编写

```go
// math.go
package math

func Add(a, b int) int {
    return a + b
}

func Multiply(a, b int) int {
    return a * b
}
```

```go
// math_test.go
package math

import "testing"

// 测试函数必须以Test开头，参数为*testing.T
func TestAdd(t *testing.T) {
    result := Add(2, 3)
    expected := 5
    
    if result != expected {
        t.Errorf("Add(2, 3) = %d; want %d", result, expected)
    }
}

func TestMultiply(t *testing.T) {
    result := Multiply(3, 4)
    expected := 12
    
    if result != expected {
        t.Errorf("Multiply(3, 4) = %d; want %d", result, expected)
    }
}
```

运行测试：
```bash
go test
go test -v  # 详细输出
go test -run TestAdd  # 运行特定测试
```

---

### 2.2 表格驱动测试

```go
func TestAddTableDriven(t *testing.T) {
    tests := []struct {
        name     string
        a, b     int
        expected int
    }{
        {"正数相加", 2, 3, 5},
        {"负数相加", -1, -2, -3},
        {"零值", 0, 5, 5},
        {"大数", 1000000, 2000000, 3000000},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := Add(tt.a, tt.b)
            if result != tt.expected {
                t.Errorf("Add(%d, %d) = %d; want %d", 
                    tt.a, tt.b, result, tt.expected)
            }
        })
    }
}
```

---

### 2.3 测试辅助函数

```go
// helper.go
package math

func assertEqual(t *testing.T, got, want int) {
    t.Helper() // 标记为辅助函数
    if got != want {
        t.Errorf("got %d, want %d", got, want)
    }
}

func TestWithHelper(t *testing.T) {
    result := Add(2, 3)
    assertEqual(t, result, 5)
}
```

---

### 2.4 Setup和Teardown

```go
func TestMain(m *testing.M) {
    // Setup
    fmt.Println("Before tests")
    
    // 运行测试
    code := m.Run()
    
    // Teardown
    fmt.Println("After tests")
    
    os.Exit(code)
}

func TestWithSetup(t *testing.T) {
    // 每个测试的setup
    t.Cleanup(func() {
        fmt.Println("Cleanup for this test")
    })
    
    // 测试逻辑
    result := Add(1, 1)
    if result != 2 {
        t.Error("expected 2")
    }
}
```

---

### 2.5 错误场景测试

```go
// 带错误返回的函数
func Divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

func TestDivide(t *testing.T) {
    tests := []struct {
        name      string
        a, b      float64
        want      float64
        wantError bool
    }{
        {"正常除法", 10, 2, 5, false},
        {"除以零", 10, 0, 0, true},
        {"负数", -10, 2, -5, false},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := Divide(tt.a, tt.b)
            
            if tt.wantError {
                if err == nil {
                    t.Error("expected error, got nil")
                }
                return
            }
            
            if err != nil {
                t.Errorf("unexpected error: %v", err)
            }
            
            if got != tt.want {
                t.Errorf("got %.2f, want %.2f", got, tt.want)
            }
        })
    }
}
```

---

## 3. 🏗️ 实战案例

### 3.1 案例：测试用户服务

```go
// user.go
package user

import "errors"

type User struct {
    ID    int
    Name  string
    Email string
}

type UserService struct {
    users map[int]*User
}

func NewUserService() *UserService {
    return &UserService{
        users: make(map[int]*User),
    }
}

func (s *UserService) Create(user *User) error {
    if user.Name == "" {
        return errors.New("name is required")
    }
    if user.Email == "" {
        return errors.New("email is required")
    }
    s.users[user.ID] = user
    return nil
}

func (s *UserService) Get(id int) (*User, error) {
    user, ok := s.users[id]
    if !ok {
        return nil, errors.New("user not found")
    }
    return user, nil
}
```

```go
// user_test.go
package user

import (
    "testing"
)

func TestUserService_Create(t *testing.T) {
    tests := []struct {
        name      string
        user      *User
        wantError bool
        errorMsg  string
    }{
        {
            name: "有效用户",
            user: &User{ID: 1, Name: "Alice", Email: "alice@example.com"},
            wantError: false,
        },
        {
            name: "缺少名字",
            user: &User{ID: 2, Email: "bob@example.com"},
            wantError: true,
            errorMsg: "name is required",
        },
        {
            name: "缺少邮箱",
            user: &User{ID: 3, Name: "Charlie"},
            wantError: true,
            errorMsg: "email is required",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            service := NewUserService()
            err := service.Create(tt.user)
            
            if tt.wantError {
                if err == nil {
                    t.Error("expected error, got nil")
                } else if err.Error() != tt.errorMsg {
                    t.Errorf("got error %q, want %q", err.Error(), tt.errorMsg)
                }
            } else {
                if err != nil {
                    t.Errorf("unexpected error: %v", err)
                }
                
                // 验证用户已创建
                got, err := service.Get(tt.user.ID)
                if err != nil {
                    t.Errorf("failed to get user: %v", err)
                }
                if got.Name != tt.user.Name {
                    t.Errorf("got name %s, want %s", got.Name, tt.user.Name)
                }
            }
        })
    }
}
```

---

## 4. ⚠️ 常见问题

### Q1: 测试文件应该放在哪里？
- 与被测试的代码放在同一个包
- 文件名：`xxx_test.go`
- 例如：`math.go` → `math_test.go`

### Q2: 什么时候使用t.Error vs t.Fatal？
- `t.Error` / `t.Errorf`: 记录错误，继续执行
- `t.Fatal` / `t.Fatalf`: 记录错误，立即停止当前测试

### Q3: 如何测试私有函数？
- 方法1：通过测试公有函数间接测试
- 方法2：在test文件中定义（同包测试可访问私有成员）

### Q4: 测试覆盖率多少合适？
- 核心逻辑：80-90%
- 工具代码：70-80%
- 不要盲目追求100%

---

## 5. 💡 最佳实践

1. **测试命名清晰**
   ```go
   // ✅ 好
   func TestAdd_PositiveNumbers_ReturnsSum(t *testing.T)
   
   // ❌ 差
   func TestAdd1(t *testing.T)
   ```

2. **一个测试一个关注点**
   ```go
   // ✅ 好：专注测试一个功能
   func TestUserCreate(t *testing.T)
   func TestUserUpdate(t *testing.T)
   
   // ❌ 差：一个测试测多个功能
   func TestUserOperations(t *testing.T)
   ```

3. **使用t.Helper()标记辅助函数**

4. **测试要快速**
   - 避免sleep
   - 使用mock而非真实依赖
   - 并行运行：`t.Parallel()`

5. **测试要独立**
   - 每个测试互不依赖
   - 不依赖执行顺序
   - 清理测试数据

---

## 6. 📚 相关资源

- [testing Package](https://pkg.go.dev/testing)
- [Go Testing Style Guide](https://github.com/golang/go/wiki/TestComments)
- [Table Driven Tests](https://go.dev/wiki/TableDrivenTests)

---

**最后更新**: 2025-10-27  
**作者**: Documentation Team

