# Go单元测试

> **简介**: Go单元测试完整指南，包括testing包、测试编写、断言和最佳实践

> **版本**: Go 1.25.3  
> **难度**: ⭐⭐⭐  
> **标签**: #测试 #单元测试 #testing #TDD

---

## 📋 目录

- [1. 单元测试基础](#1-单元测试基础)
  - [测试文件命名](#测试文件命名)
  - [基本测试函数](#基本测试函数)
  - [运行测试](#运行测试)
- [2. 测试函数编写](#2-测试函数编写)
  - [测试函数签名](#测试函数签名)
  - [错误报告方法](#错误报告方法)
  - [子测试](#子测试)
  - [并行测试](#并行测试)
- [3. 测试辅助函数](#3-测试辅助函数)
  - [Setup和Teardown](#setup和teardown)
  - [Helper函数](#helper函数)
  - [临时目录](#临时目录)
- [4. 测试覆盖率](#4-测试覆盖率)
  - [生成覆盖率报告](#生成覆盖率报告)
  - [覆盖率示例](#覆盖率示例)
- [5. 测试技巧](#5-测试技巧)
  - [表格驱动测试](#表格驱动测试)
  - [测试私有函数](#测试私有函数)
  - [Mock和Stub](#mock和stub)
- [6. 最佳实践](#6-最佳实践)
  - [1. 命名规范](#1-命名规范)
  - [2. 一个测试一个功能](#2-一个测试一个功能)
  - [3. 使用表格驱动测试](#3-使用表格驱动测试)
  - [4. 清理资源](#4-清理资源)
  - [5. 快速失败](#5-快速失败)
- [🔗 相关资源](#-相关资源)

## 1. 单元测试基础

### 测试文件命名

```go
// 源文件
math.go

// 测试文件（在同一目录）
math_test.go
```

---

### 基本测试函数

```go
// math.go
package math

func Add(a, b int) int {
    return a + b
}

// math_test.go
package math

import "testing"

func TestAdd(t *testing.T) {
    result := Add(2, 3)
    expected := 5
    
    if result != expected {
        t.Errorf("Add(2, 3) = %d; want %d", result, expected)
    }
}
```

---

### 运行测试

```bash
# 运行当前目录的测试
go test

# 运行所有包的测试
go test ./...

# 详细输出
go test -v

# 运行特定测试
go test -run TestAdd

# 运行匹配模式的测试
go test -run Test.*Add
```

---

## 2. 测试函数编写

### 测试函数签名

```go
func TestXxx(t *testing.T) {
    // 测试代码
}
```

**规则**:
- 函数名必须以`Test`开头
- 接受`*testing.T`参数
- 在`_test.go`文件中

---

### 错误报告方法

```go
func TestMethods(t *testing.T) {
    // Error: 记录错误，继续执行
    if condition {
        t.Error("error message")
    }
    
    // Errorf: 格式化错误
    if result != expected {
        t.Errorf("got %v, want %v", result, expected)
    }
    
    // Fatal: 记录错误并立即停止
    if criticalError {
        t.Fatal("fatal error")
    }
    
    // Fatalf: 格式化的Fatal
    if criticalError {
        t.Fatalf("fatal: %v", err)
    }
    
    // Fail: 标记测试失败，继续执行
    if condition {
        t.Fail()
    }
    
    // FailNow: 标记测试失败，立即停止
    if criticalError {
        t.FailNow()
    }
}
```

---

### 子测试

```go
func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"positive", 2, 3, 5},
        {"negative", -1, -1, -2},
        {"zero", 0, 0, 0},
        {"mixed", -1, 1, 0},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := Add(tt.a, tt.b)
            if got != tt.want {
                t.Errorf("Add(%d, %d) = %d; want %d", 
                    tt.a, tt.b, got, tt.want)
            }
        })
    }
}
```

**运行特定子测试**:
```bash
go test -run TestAdd/positive
```

---

### 并行测试

```go
func TestParallel(t *testing.T) {
    tests := []struct {
        name string
        // ...
    }{
        // test cases
    }
    
    for _, tt := range tests {
        tt := tt  // 捕获变量
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()  // 标记为并行
            
            // 测试代码
        })
    }
}
```

---

## 3. 测试辅助函数

### Setup和Teardown

```go
func TestMain(m *testing.M) {
    // Setup
    setup()
    
    // 运行测试
    code := m.Run()
    
    // Teardown
    teardown()
    
    os.Exit(code)
}

func setup() {
    // 初始化数据库、配置等
}

func teardown() {
    // 清理资源
}
```

---

### Helper函数

```go
func assertEqual(t *testing.T, got, want interface{}) {
    t.Helper()  // 标记为辅助函数
    
    if got != want {
        t.Errorf("got %v, want %v", got, want)
    }
}

func TestWithHelper(t *testing.T) {
    result := Add(2, 3)
    assertEqual(t, result, 5)  // 错误会指向这一行，而不是assertEqual内部
}
```

---

### 临时目录

```go
func TestWithTempDir(t *testing.T) {
    // 创建临时目录
    dir := t.TempDir()  // 测试结束后自动清理
    
    // 使用临时目录
    file := filepath.Join(dir, "test.txt")
    os.WriteFile(file, []byte("test"), 0644)
    
    // 测试代码
}
```

---

## 4. 测试覆盖率

### 生成覆盖率报告

```bash
# 生成覆盖率文件
go test -coverprofile=coverage.out

# 查看覆盖率
go tool cover -func=coverage.out

# 生成HTML报告
go tool cover -html=coverage.out -o coverage.html
```

---

### 覆盖率示例

```go
// math.go
func Divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

// math_test.go
func TestDivide(t *testing.T) {
    // 测试正常情况
    result, err := Divide(10, 2)
    if err != nil {
        t.Fatal(err)
    }
    if result != 5 {
        t.Errorf("got %d, want 5", result)
    }
    
    // 测试除零错误
    _, err = Divide(10, 0)
    if err == nil {
        t.Error("expected error for division by zero")
    }
}
```

---

## 5. 测试技巧

### 表格驱动测试

```go
func TestCalculate(t *testing.T) {
    tests := []struct {
        name     string
        op       string
        a, b     int
        want     int
        wantErr  bool
    }{
        {"add", "+", 2, 3, 5, false},
        {"subtract", "-", 5, 3, 2, false},
        {"multiply", "*", 2, 3, 6, false},
        {"divide", "/", 6, 2, 3, false},
        {"divide by zero", "/", 6, 0, 0, true},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := Calculate(tt.op, tt.a, tt.b)
            
            if tt.wantErr {
                if err == nil {
                    t.Error("expected error but got none")
                }
                return
            }
            
            if err != nil {
                t.Fatalf("unexpected error: %v", err)
            }
            
            if got != tt.want {
                t.Errorf("got %d, want %d", got, tt.want)
            }
        })
    }
}
```

---

### 测试私有函数

```go
// 通过导出函数测试
func TestPrivateFunction(t *testing.T) {
    // 通过公共API间接测试私有函数
    result := PublicFunction()
    // 验证结果
}

// 或在测试文件中重新声明
func privateFunction(x int) int {
    // 测试需要时可以在测试文件中访问
}
```

---

### Mock和Stub

```go
// 接口定义
type Database interface {
    GetUser(id int) (*User, error)
}

// Mock实现
type MockDatabase struct {
    GetUserFunc func(id int) (*User, error)
}

func (m *MockDatabase) GetUser(id int) (*User, error) {
    if m.GetUserFunc != nil {
        return m.GetUserFunc(id)
    }
    return nil, errors.New("not implemented")
}

// 测试
func TestUserService(t *testing.T) {
    mockDB := &MockDatabase{
        GetUserFunc: func(id int) (*User, error) {
            return &User{ID: id, Name: "Test"}, nil
        },
    }
    
    service := NewUserService(mockDB)
    user, err := service.GetUser(1)
    
    if err != nil {
        t.Fatal(err)
    }
    
    if user.Name != "Test" {
        t.Errorf("got %s, want Test", user.Name)
    }
}
```

---

## 6. 最佳实践

### 1. 命名规范

```go
// ✅ 推荐
func TestAdd(t *testing.T) {}
func TestAdd_Positive(t *testing.T) {}
func TestAdd_WithZero(t *testing.T) {}

// ❌ 不推荐
func Test_add(t *testing.T) {}
func testAdd(t *testing.T) {}
```

---

### 2. 一个测试一个功能

```go
// ✅ 推荐：每个测试专注一个功能
func TestAdd(t *testing.T) {
    result := Add(2, 3)
    if result != 5 {
        t.Errorf("got %d, want 5", result)
    }
}

func TestAddNegative(t *testing.T) {
    result := Add(-1, -1)
    if result != -2 {
        t.Errorf("got %d, want -2", result)
    }
}

// ❌ 不推荐：一个测试测多个功能
func TestAddAll(t *testing.T) {
    if Add(2, 3) != 5 {
        t.Error("positive failed")
    }
    if Add(-1, -1) != -2 {
        t.Error("negative failed")
    }
    // ...
}
```

---

### 3. 使用表格驱动测试

```go
// ✅ 推荐
func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"positive", 2, 3, 5},
        {"negative", -1, -1, -2},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := Add(tt.a, tt.b)
            if got != tt.want {
                t.Errorf("got %d, want %d", got, tt.want)
            }
        })
    }
}
```

---

### 4. 清理资源

```go
// ✅ 推荐：使用defer清理
func TestWithResource(t *testing.T) {
    resource := setup()
    defer cleanup(resource)
    
    // 测试代码
}

// ✅ 推荐：使用t.Cleanup
func TestWithCleanup(t *testing.T) {
    resource := setup()
    t.Cleanup(func() {
        cleanup(resource)
    })
    
    // 测试代码
}
```

---

### 5. 快速失败

```go
// ✅ 推荐：使用Fatal快速失败
func TestCritical(t *testing.T) {
    resource, err := setup()
    if err != nil {
        t.Fatalf("setup failed: %v", err)  // 立即停止
    }
    
    // 继续测试
}

// ❌ 不推荐：使用Error继续执行
func TestCritical(t *testing.T) {
    resource, err := setup()
    if err != nil {
        t.Errorf("setup failed: %v", err)  // 继续执行
    }
    
    // resource可能为nil，会panic
    resource.DoSomething()
}
```

---

## 🔗 相关资源

- [表格驱动测试](./02-表格驱动测试.md)
- [集成测试](./03-集成测试.md)
- [Mock与Stub](./06-Mock与Stub.md)

---

**最后更新**: 2025-10-28  
**Go版本**: 1.25.3
