# 常见问题与技巧

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---

## 📋 目录


- [1. 📖 概念介绍](#1.-概念介绍)
- [2. ⚠️ 常见问题](#2.-常见问题)
  - [2.1 Q1: 如何测试unexported函数？](#2.1-q1-如何测试unexported函数)
  - [2.2 Q2: 如何处理time.Now()？](#2.2-q2-如何处理time.now)
  - [2.3 Q3: 测试panic怎么办？](#2.3-q3-测试panic怎么办)
  - [2.4 Q4: 如何测试goroutine？](#2.4-q4-如何测试goroutine)
  - [2.5 Q5: 并发测试如何检测竞态？](#2.5-q5-并发测试如何检测竞态)
  - [2.6 Q6: 如何跳过长时间测试？](#2.6-q6-如何跳过长时间测试)
  - [2.7 Q7: 测试文件应该放哪里？](#2.7-q7-测试文件应该放哪里)
  - [2.8 Q8: 如何测试标准输出？](#2.8-q8-如何测试标准输出)
- [3. 💡 实用技巧](#3.-实用技巧)
  - [3.1 技巧1: 使用TestMain自定义测试流程](#3.1-技巧1-使用testmain自定义测试流程)
  - [3.2 技巧2: 生成测试数据](#3.2-技巧2-生成测试数据)
  - [3.3 技巧3: 并行测试](#3.3-技巧3-并行测试)
  - [3.4 技巧4: 临时目录](#3.4-技巧4-临时目录)
  - [3.5 技巧5: 条件编译测试](#3.5-技巧5-条件编译测试)
  - [3.6 技巧6: 测试特定函数](#3.6-技巧6-测试特定函数)
  - [3.7 技巧7: 详细输出](#3.7-技巧7-详细输出)
  - [3.8 技巧8: 测试超时](#3.8-技巧8-测试超时)
- [4. 🔧 调试技巧](#4.-调试技巧)
  - [4.1 打印调试信息](#4.1-打印调试信息)
  - [4.2 使用Delve调试器](#4.2-使用delve调试器)
  - [4.3 生成测试失败报告](#4.3-生成测试失败报告)
- [5. 📊 性能分析技巧](#5.-性能分析技巧)
  - [5.1 查找慢测试](#5.1-查找慢测试)
  - [5.2 分析测试覆盖率](#5.2-分析测试覆盖率)
- [6. 📚 工具推荐](#6.-工具推荐)
- [7. 🎯 测试优化清单](#7.-测试优化清单)
- [8. 📚 相关资源](#8.-相关资源)

## 1. 📖 概念介绍

本文汇总Go测试中的常见问题、解决方案和实用技巧，帮助你快速解决测试中遇到的问题。

---

## 2. ⚠️ 常见问题

### 2.1 Q1: 如何测试unexported函数？

**问题**: 私有函数无法在_test.go中访问

**解决方案**:
```go
// 方案1：通过公有函数间接测试（推荐）
func TestPublicFunc(t *testing.T) {
    // 公有函数内部调用私有函数
}

// 方案2：在同包的_test.go中测试（可访问私有成员）
// math.go
package math

func add(a, b int) int { return a + b }

// math_test.go
package math // 同包，可访问私有函数

func TestAdd(t *testing.T) {
    result := add(2, 3)
    if result != 5 {
        t.Error("failed")
    }
}

// 方案3：使用export_test.go（特殊情况）
// export_test.go
package math

var Add = add // 导出私有函数供测试使用
```

---

### 2.2 Q2: 如何处理time.Now()？

**问题**: 时间相关代码难以测试

**解决方案**:
```go
// 定义时间接口
type Clock interface {
    Now() time.Time
}

type RealClock struct{}
func (RealClock) Now() time.Time { return time.Now() }

type MockClock struct{ T time.Time }
func (m MockClock) Now() time.Time { return m.T }

// 使用依赖注入
type Service struct {
    clock Clock
}

// 测试
func TestService(t *testing.T) {
    fixedTime := time.Date(2025, 10, 28, 12, 0, 0, 0, time.UTC)
    service := &Service{clock: MockClock{T: fixedTime}}
    // 测试逻辑
}
```

---

### 2.3 Q3: 测试panic怎么办？

```go
func TestPanic(t *testing.T) {
    defer func() {
        if r := recover(); r == nil {
            t.Error("Expected panic")
        }
    }()
    
    FunctionThatPanics()
}

// 或使用testify
func TestPanicWithTestify(t *testing.T) {
    assert.Panics(t, func() {
        FunctionThatPanics()
    })
}
```

---

### 2.4 Q4: 如何测试goroutine？

```go
func TestGoroutine(t *testing.T) {
    done := make(chan bool)
    
    go func() {
        // goroutine逻辑
        result := doWork()
        
        if result != expected {
            t.Error("failed")
        }
        done <- true
    }()
    
    select {
    case <-done:
        // 测试完成
    case <-time.After(2 * time.Second):
        t.Fatal("timeout")
    }
}
```

---

### 2.5 Q5: 并发测试如何检测竞态？

```bash
# 使用-race标志
go test -race

# 示例
func TestConcurrent(t *testing.T) {
    counter := 0
    var wg sync.WaitGroup
    
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            counter++ // 竞态条件！
            wg.Done()
        }()
    }
    wg.Wait()
}
```

---

### 2.6 Q6: 如何跳过长时间测试？

```go
func TestLongRunning(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping in short mode")
    }
    
    // 长时间测试逻辑
}

// 运行：
// go test        # 运行所有测试
// go test -short # 跳过长时间测试
```

---

### 2.7 Q7: 测试文件应该放哪里？

```go
// 方案1：同包测试（推荐）
package mypackage
// mypackage_test.go 可以访问私有成员

// 方案2：黑盒测试
package mypackage_test  // 注意后缀_test
// 只能访问公有接口
```

---

### 2.8 Q8: 如何测试标准输出？

```go
func TestPrint(t *testing.T) {
    // 捕获stdout
    old := os.Stdout
    r, w, _ := os.Pipe()
    os.Stdout = w
    
    // 执行打印
    fmt.Println("Hello")
    
    // 恢复stdout
    w.Close()
    os.Stdout = old
    
    // 读取输出
    var buf bytes.Buffer
    io.Copy(&buf, r)
    
    output := buf.String()
    if output != "Hello\n" {
        t.Errorf("got %q", output)
    }
}
```

---

## 3. 💡 实用技巧

### 3.1 技巧1: 使用TestMain自定义测试流程

```go
func TestMain(m *testing.M) {
    // Setup
    fmt.Println("Before all tests")
    setupDatabase()
    
    // 运行测试
    code := m.Run()
    
    // Teardown
    fmt.Println("After all tests")
    teardownDatabase()
    
    os.Exit(code)
}
```

---

### 3.2 技巧2: 生成测试数据

```go
// 使用testing/quick生成随机测试数据
func TestQuick(t *testing.T) {
    f := func(x int) bool {
        return Abs(x) >= 0
    }
    
    if err := quick.Check(f, nil); err != nil {
        t.Error(err)
    }
}
```

---

### 3.3 技巧3: 并行测试

```go
func TestParallel(t *testing.T) {
    tests := []struct {
        name string
        // ...
    }{
        // test cases
    }
    
    for _, tt := range tests {
        tt := tt // 捕获range变量
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel() // 并行运行
            // 测试逻辑
        })
    }
}
```

---

### 3.4 技巧4: 临时目录

```go
func TestWithTempDir(t *testing.T) {
    dir := t.TempDir() // 自动创建临时目录
    
    // 使用临时目录
    file := filepath.Join(dir, "test.txt")
    os.WriteFile(file, []byte("data"), 0644)
    
    // 测试结束后自动清理
}
```

---

### 3.5 技巧5: 条件编译测试

```go
// +build integration

package mypackage

import "testing"

func TestIntegration(t *testing.T) {
    // 只在integration tag时运行
}

// 运行：go test -tags=integration
```

---

### 3.6 技巧6: 测试特定函数

```bash
# 运行特定测试
go test -run TestAdd

# 运行特定子测试
go test -run TestAdd/positive

# 使用正则表达式
go test -run "Test.*Positive"
```

---

### 3.7 技巧7: 详细输出

```bash
# 详细输出
go test -v

# 显示每个测试的时间
go test -v -json | jq '.Elapsed'

# 显示覆盖率
go test -v -cover
```

---

### 3.8 技巧8: 测试超时

```bash
# 设置整体超时
go test -timeout 30s

# 单个测试超时
func TestTimeout(t *testing.T) {
    timer := time.After(5 * time.Second)
    done := make(chan bool)
    
    go func() {
        // 测试逻辑
        done <- true
    }()
    
    select {
    case <-done:
        // 完成
    case <-timer:
        t.Fatal("timeout")
    }
}
```

---

## 4. 🔧 调试技巧

### 4.1 打印调试信息

```go
func TestDebug(t *testing.T) {
    t.Log("Debug info")  // 只在-v时显示
    t.Logf("Value: %v", value)
    
    // 调试时临时使用
    fmt.Printf("Debug: %+v\n", obj)
}
```

---

### 4.2 使用Delve调试器

```bash
# 安装Delve
go install github.com/go-delve/delve/cmd/dlv@latest

# 调试测试
dlv test -- -test.run TestSomething

# 设置断点
(dlv) break TestSomething
(dlv) continue
(dlv) print variable
```

---

### 4.3 生成测试失败报告

```bash
# 生成JSON报告
go test -json > test-report.json

# 生成XML报告（需要go-junit-report）
go test -v 2>&1 | go-junit-report > report.xml
```

---

## 5. 📊 性能分析技巧

### 5.1 查找慢测试

```bash
# 显示每个测试的时间
go test -v | grep -E "PASS|FAIL"

# 使用go test json
go test -json | jq 'select(.Action=="pass") | {Test, Elapsed}'
```

---

### 5.2 分析测试覆盖率

```bash
# 生成覆盖率报告
go test -coverprofile=coverage.out
go tool cover -html=coverage.out

# 查看未覆盖的代码
go tool cover -func=coverage.out | grep -v "100.0%"
```

---

## 6. 📚 工具推荐

1. **testify** - 断言库
   ```bash
   go get github.com/stretchr/testify
   ```

2. **gomock** - Mock生成
   ```bash
   go install github.com/golang/mock/mockgen@latest
   ```

3. **gotests** - 测试生成
   ```bash
   go install github.com/cweill/gotests/...@latest
   gotests -all -w file.go
   ```

4. **go-cmp** - 深度比较
   ```bash
   go get github.com/google/go-cmp/cmp
   ```

---

## 7. 🎯 测试优化清单

- [ ] 移除不必要的sleep
- [ ] 使用t.Parallel()加速
- [ ] 复用昂贵的setup
- [ ] 减少外部依赖
- [ ] 使用-short标志跳过慢测试
- [ ] 优化表格驱动测试的数据量
- [ ] 考虑使用缓存（go test -cache）

---

## 8. 📚 相关资源

- [Go Testing Tips](https://github.com/golang/go/wiki/TestComments)
- [Advanced Testing](https://dave.cheney.net/2019/05/07/prefer-table-driven-tests)

---

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3
