# Go日志系统最佳实践完全指南

> **简介**: Go语言日志系统设计和使用的完整指南，包括log/slog、Zap、Logrus等主流日志库

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---


---

## 📋 目录


- [1. 日志系统概述](#1.-日志系统概述)
  - [日志级别](#日志级别)
  - [日志格式对比](#日志格式对比)
- [2. log/slog标准库](#2.-logslog标准库)
  - [基本使用](#基本使用)
  - [高级特性](#高级特性)
    - [With() - 添加上下文字段](#with-添加上下文字段)
    - [Group() - 字段分组](#group-字段分组)
    - [LogValuer - 自定义类型日志](#logvaluer-自定义类型日志)
  - [Web应用集成](#web应用集成)
- [3. Zap高性能日志](#3.-zap高性能日志)
  - [3.1 安装](#31-安装)
  - [3.2 基本使用](#32-基本使用)
  - [3.3 高级特性](#33-高级特性)
    - [SugaredLogger - 便捷API](#sugaredlogger-便捷api)
    - [多输出源](#多输出源)
    - [性能对比](#性能对比)
- [4. Logrus结构化日志](#4.-logrus结构化日志)
  - [4.1 安装](#41-安装)
  - [4.2 基本使用](#42-基本使用)
  - [Hook机制](#hook机制)
- [5. 日志最佳实践](#5.-日志最佳实践)
  - [DO's ✅](#dos)
    - [1. 使用结构化日志](#1.-使用结构化日志)
    - [2. 合适的日志级别](#2.-合适的日志级别)
    - [3. 记录关键业务流程](#3.-记录关键业务流程)
    - [4. 记录错误上下文](#4.-记录错误上下文)
    - [5. 敏感信息保护](#5.-敏感信息保护)
  - [DON'Ts ❌](#donts)
- [6. 日志聚合和分析](#6.-日志聚合和分析)
  - [ELK Stack集成](#elk-stack集成)
  - [日志轮转](#日志轮转)
- [7. 生产环境实战](#7.-生产环境实战)
  - [完整日志系统架构](#完整日志系统架构)

## 1. 日志系统概述

### 日志级别

| 级别 | 用途 | 使用场景 |
|------|------|---------|
| **DEBUG** | 调试信息 | 开发环境详细调试 |
| **INFO** | 一般信息 | 业务流程记录 |
| **WARN** | 警告信息 | 可恢复的异常情况 |
| **ERROR** | 错误信息 | 需要关注的错误 |
| **FATAL** | 致命错误 | 导致程序退出的错误 |

### 日志格式对比

```go
// 非结构化日志（不推荐）
log.Printf("User %s login from %s", username, ip)

// 结构化日志（推荐）
logger.Info("user login",
    "username", username,
    "ip", ip,
    "timestamp", time.Now(),
)
```

---

## 2. log/slog标准库

### 基本使用

```go
package main

import (
    "log/slog"
    "os"
)

func main() {
    // 1. 使用默认logger（文本格式）
    slog.Info("application started", "port", 8080, "env", "production")
    slog.Warn("high memory usage", "usage", "85%")
    slog.Error("database connection failed", "error", "timeout")
    
    // 2. JSON格式logger
    jsonLogger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
    jsonLogger.Info("user action", "user_id", 123, "action", "login")
    
    // 3. 自定义选项
    opts := &slog.HandlerOptions{
        Level: slog.LevelDebug,  // 设置最低日志级别
        AddSource: true,          // 添加源文件信息
    }
    logger := slog.New(slog.NewJSONHandler(os.Stdout, opts))
    logger.Debug("debug info", "detail", "some details")
}
```

### 高级特性

#### With() - 添加上下文字段

```go
// 创建带有固定字段的logger
baseLogger := slog.Default()

// 数据库logger
dbLogger := baseLogger.With("module", "database", "connection", "primary")
dbLogger.Info("query executed", "duration", "150ms", "rows", 100)
// 输出: ... module=database connection=primary duration=150ms rows=100

// API logger
apiLogger := baseLogger.With("module", "api", "version", "v1")
apiLogger.Info("request handled", "path", "/users", "status", 200)
// 输出: ... module=api version=v1 path=/users status=200
```

#### Group() - 字段分组

```go
logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))

logger.Info("HTTP request",
    slog.Group("http",
        slog.String("method", "GET"),
        slog.String("path", "/api/users"),
        slog.Int("status", 200),
        slog.Duration("duration", 150*time.Millisecond),
    ),
    slog.Group("client",
        slog.String("ip", "192.168.1.1"),
        slog.String("user_agent", "Mozilla/5.0"),
    ),
)

// JSON输出:
// {
//   "time": "2025-10-24T10:00:00Z",
//   "level": "INFO",
//   "msg": "HTTP request",
//   "http": {
//     "method": "GET",
//     "path": "/api/users",
//     "status": 200,
//     "duration": 150000000
//   },
//   "client": {
//     "ip": "192.168.1.1",
//     "user_agent": "Mozilla/5.0"
//   }
// }
```

#### LogValuer - 自定义类型日志

```go
type User struct {
    ID       int
    Username string
    Email    string
    Password string  // 敏感信息
}

// 实现LogValuer接口，控制日志输出
func (u User) LogValue() slog.Value {
    return slog.GroupValue(
        slog.Int("id", u.ID),
        slog.String("username", u.Username),
        // 不输出Email和Password
    )
}

func main() {
    logger := slog.Default()
    
    user := User{
        ID:       123,
        Username: "alice",
        Email:    "alice@example.com",
        Password: "secret123",
    }
    
    logger.Info("user login", "user", user)
    // 输出: ... user.id=123 user.username=alice
    // Email和Password被自动过滤
}
```

### Web应用集成

```go
package main

import (
    "context"
    "log/slog"
    "net/http"
    "os"
    "time"
    
    "github.com/google/uuid"
)

// Logger中间件
func LoggerMiddleware(logger *slog.Logger) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()
            
            // 生成请求ID
            requestID := uuid.New().String()
            
            // 创建请求特定的logger
            reqLogger := logger.With(
                "request_id", requestID,
                "method", r.Method,
                "path", r.URL.Path,
                "remote_addr", r.RemoteAddr,
            )
            
            // 将logger放入context
            ctx := context.WithValue(r.Context(), "logger", reqLogger)
            
            // 记录请求开始
            reqLogger.Info("request started")
            
            // 包装ResponseWriter以捕获状态码
            wrw := &responseWriterWrapper{ResponseWriter: w, statusCode: 200}
            
            // 处理请求
            next.ServeHTTP(wrw, r.WithContext(ctx))
            
            // 记录请求完成
            duration := time.Since(start)
            reqLogger.Info("request completed",
                "status", wrw.statusCode,
                "duration_ms", duration.Milliseconds(),
            )
        })
    }
}

type responseWriterWrapper struct {
    http.ResponseWriter
    statusCode int
}

func (w *responseWriterWrapper) WriteHeader(statusCode int) {
    w.statusCode = statusCode
    w.ResponseWriter.WriteHeader(statusCode)
}

// 从context获取logger
func GetLogger(ctx context.Context) *slog.Logger {
    if logger, ok := ctx.Value("logger").(*slog.Logger); ok {
        return logger
    }
    return slog.Default()
}

func main() {
    // 创建JSON logger用于生产环境
    logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
        Level: slog.LevelInfo,
    }))
    
    mux := http.NewServeMux()
    
    mux.HandleFunc("/api/users", func(w http.ResponseWriter, r *http.Request) {
        logger := GetLogger(r.Context())
        
        // 业务逻辑
        logger.Info("fetching users")
        
        w.Header().Set("Content-Type", "application/json")
        w.Write([]byte(`{"users": []}`))
    })
    
    // 应用中间件
    handler := LoggerMiddleware(logger)(mux)
    
    logger.Info("server starting", "port", 8080)
    http.ListenAndServe(":8080", handler)
}
```

---

## 3. Zap高性能日志

### 3.1 安装

```bash
go get -u go.uber.org/zap
```

### 3.2 基本使用

```go
package main

import (
    "go.uber.org/zap"
    "go.uber.org/zap/zapcore"
)

func main() {
    // 1. 预设配置（开发环境）
    devLogger, _ := zap.NewDevelopment()
    defer devLogger.Sync()
    
    devLogger.Info("development logger",
        zap.String("key", "value"),
        zap.Int("number", 123),
    )
    
    // 2. 预设配置（生产环境）
    prodLogger, _ := zap.NewProduction()
    defer prodLogger.Sync()
    
    prodLogger.Info("production logger",
        zap.String("env", "prod"),
        zap.Int("port", 8080),
    )
    
    // 3. 自定义配置
    config := zap.Config{
        Level:       zap.NewAtomicLevelAt(zap.InfoLevel),
        Development: false,
        Encoding:    "json",
        EncoderConfig: zapcore.EncoderConfig{
            TimeKey:        "timestamp",
            LevelKey:       "level",
            NameKey:        "logger",
            CallerKey:      "caller",
            MessageKey:     "message",
            StacktraceKey:  "stacktrace",
            LineEnding:     zapcore.DefaultLineEnding,
            EncodeLevel:    zapcore.LowercaseLevelEncoder,
            EncodeTime:     zapcore.ISO8601TimeEncoder,
            EncodeDuration: zapcore.SecondsDurationEncoder,
            EncodeCaller:   zapcore.ShortCallerEncoder,
        },
        OutputPaths:      []string{"stdout"},
        ErrorOutputPaths: []string{"stderr"},
    }
    
    logger, _ := config.Build()
    defer logger.Sync()
    
    logger.Info("custom logger started")
}
```

### 3.3 高级特性

#### SugaredLogger - 便捷API

```go
logger, _ := zap.NewProduction()
sugar := logger.Sugar()
defer sugar.Sync()

// 支持printf风格
sugar.Infof("User %s logged in from %s", "alice", "192.168.1.1")

// 支持键值对
sugar.Infow("user login",
    "username", "alice",
    "ip", "192.168.1.1",
    "timestamp", time.Now(),
)
```

#### 多输出源

```go
// 同时输出到文件和控制台
func NewLogger() (*zap.Logger, error) {
    // 文件输出配置
    fileWriter := zapcore.AddSync(&lumberjack.Logger{
        Filename:   "./logs/app.log",
        MaxSize:    100, // MB
        MaxBackups: 3,
        MaxAge:     28, // days
        Compress:   true,
    })
    
    // 控制台输出配置
    consoleWriter := zapcore.AddSync(os.Stdout)
    
    // 编码器配置
    encoderConfig := zap.NewProductionEncoderConfig()
    encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
    
    // 创建core
    core := zapcore.NewTee(
        zapcore.NewCore(
            zapcore.NewJSONEncoder(encoderConfig),
            fileWriter,
            zap.InfoLevel,
        ),
        zapcore.NewCore(
            zapcore.NewConsoleEncoder(encoderConfig),
            consoleWriter,
            zap.DebugLevel,
        ),
    )
    
    logger := zap.New(core, zap.AddCaller(), zap.AddCallerSkip(1))
    return logger, nil
}
```

#### 性能对比

```go
// Benchmark测试
func BenchmarkZap(b *testing.B) {
    logger, _ := zap.NewProduction()
    defer logger.Sync()
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        logger.Info("benchmark test",
            zap.Int("iteration", i),
            zap.String("key", "value"),
        )
    }
}

// 结果:
// BenchmarkZap-8    1000000    1200 ns/op    0 B/op    0 allocs/op
// Zap性能优秀，零内存分配
```

---

## 4. Logrus结构化日志

### 4.1 安装

```bash
go get -u github.com/sirupsen/logrus
```

### 4.2 基本使用

```go
package main

import (
    "os"
    
    log "github.com/sirupsen/logrus"
)

func main() {
    // 1. 基础配置
    log.SetFormatter(&log.JSONFormatter{})
    log.SetOutput(os.Stdout)
    log.SetLevel(log.InfoLevel)
    
    // 2. 结构化日志
    log.WithFields(log.Fields{
        "username": "alice",
        "ip":       "192.168.1.1",
        "action":   "login",
    }).Info("user login")
    
    // 3. 自定义logger
    logger := log.New()
    logger.SetFormatter(&log.TextFormatter{
        FullTimestamp: true,
    })
    
    logger.WithFields(log.Fields{
        "module": "database",
        "query":  "SELECT * FROM users",
    }).Info("database query")
}
```

### Hook机制

```go
// 自定义Hook - 发送错误到告警系统
type AlertHook struct {
    alertClient *AlertClient
}

func (hook *AlertHook) Levels() []log.Level {
    return []log.Level{log.ErrorLevel, log.FatalLevel, log.PanicLevel}
}

func (hook *AlertHook) Fire(entry *log.Entry) error {
    // 发送告警
    return hook.alertClient.Send(entry.Message, entry.Data)
}

func main() {
    logger := log.New()
    
    // 添加Hook
    logger.AddHook(&AlertHook{
        alertClient: NewAlertClient(),
    })
    
    logger.Error("critical error occurred")
    // 自动触发告警
}
```

---

## 5. 日志最佳实践

### DO's ✅

#### 1. 使用结构化日志

```go
// ❌ 不推荐 - 字符串拼接
log.Printf("User %s login from %s with result %s", user, ip, result)

// ✅ 推荐 - 结构化字段
logger.Info("user login",
    "user", user,
    "ip", ip,
    "result", result,
)
```

#### 2. 合适的日志级别

```go
// ✅ 正确使用日志级别
logger.Debug("entering function", "name", "ProcessOrder")      // 调试
logger.Info("order created", "order_id", 123)                   // 一般信息
logger.Warn("retry attempt", "attempt", 3, "max", 5)           // 警告
logger.Error("failed to save", "error", err)                    // 错误
logger.Fatal("database unreachable", "error", err)              // 致命错误
```

#### 3. 记录关键业务流程

```go
func ProcessPayment(orderID int, amount float64) error {
    logger := GetLogger()
    
    logger.Info("payment processing started",
        "order_id", orderID,
        "amount", amount,
    )
    
    // 业务逻辑
    if err := validatePayment(orderID, amount); err != nil {
        logger.Error("payment validation failed",
            "order_id", orderID,
            "error", err,
        )
        return err
    }
    
    logger.Info("payment processing completed",
        "order_id", orderID,
        "status", "success",
    )
    
    return nil
}
```

#### 4. 记录错误上下文

```go
// ❌ 不推荐 - 缺少上下文
logger.Error("save failed", "error", err)

// ✅ 推荐 - 完整上下文
logger.Error("failed to save user",
    "user_id", user.ID,
    "operation", "create",
    "error", err.Error(),
    "stack", string(debug.Stack()),
)
```

#### 5. 敏感信息保护

```go
// ❌ 不推荐 - 记录敏感信息
logger.Info("user created",
    "username", username,
    "password", password,      // 不应记录密码
    "credit_card", cardNumber,  // 不应记录信用卡号
)

// ✅ 推荐 - 过滤敏感信息
logger.Info("user created",
    "username", username,
    "email", maskEmail(email),  // 脱敏处理
)

func maskEmail(email string) string {
    parts := strings.Split(email, "@")
    if len(parts) != 2 {
        return "***"
    }
    return parts[0][:2] + "***@" + parts[1]
}
```

### DON'Ts ❌

```go
// ❌ 1. 不要在循环中大量打印日志
for i := 0; i < 1000000; i++ {
    logger.Debug("processing", "index", i)  // 性能问题
}

// ✅ 改进：采样或批量记录
if i%10000 == 0 {
    logger.Debug("processing batch", "index", i)
}

// ❌ 2. 不要记录过长的内容
logger.Info("data", "content", longString)  // 可能有几MB

// ✅ 改进：截断或只记录摘要
logger.Info("data received", "length", len(longString), "hash", hash(longString))

// ❌ 3. 不要忽略日志错误
logger.Sync()  // 忽略错误

// ✅ 改进：检查错误
if err := logger.Sync(); err != nil {
    fmt.Fprintf(os.Stderr, "failed to sync logger: %v\n", err)
}
```

---

## 6. 日志聚合和分析

### ELK Stack集成

```go
// Logstash格式输出
type LogstashFormatter struct{}

func (f *LogstashFormatter) Format(entry *log.Entry) ([]byte, error) {
    data := make(log.Fields)
    for k, v := range entry.Data {
        data[k] = v
    }
    
    data["@timestamp"] = entry.Time.Format(time.RFC3339)
    data["message"] = entry.Message
    data["level"] = entry.Level.String()
    
    serialized, err := json.Marshal(data)
    if err != nil {
        return nil, err
    }
    return append(serialized, '\n'), nil
}

// 使用
logger := logrus.New()
logger.SetFormatter(&LogstashFormatter{})
```

### 日志轮转

```go
import "gopkg.in/natefinch/lumberjack.v2"

// 配置日志轮转
logger := &lumberjack.Logger{
    Filename:   "/var/log/myapp/app.log",
    MaxSize:    100,   // MB
    MaxBackups: 3,     // 保留旧文件数量
    MaxAge:     28,    // 天
    Compress:   true,  // 压缩旧文件
}

log.SetOutput(logger)
```

---

## 7. 生产环境实战

### 完整日志系统架构

```go
package logger

import (
    "context"
    "os"
    
    "go.uber.org/zap"
    "go.uber.org/zap/zapcore"
    "gopkg.in/natefinch/lumberjack.v2"
)

type Logger struct {
    *zap.Logger
}

func NewLogger(env string) (*Logger, error) {
    var config zap.Config
    
    if env == "production" {
        config = zap.NewProductionConfig()
    } else {
        config = zap.NewDevelopmentConfig()
    }
    
    // 文件输出
    fileWriter := zapcore.AddSync(&lumberjack.Logger{
        Filename:   "./logs/app.log",
        MaxSize:    100,
        MaxBackups: 3,
        MaxAge:     28,
        Compress:   true,
    })
    
    // 控制台输出
    consoleWriter := zapcore.AddSync(os.Stdout)
    
    // 编码器
    encoderConfig := zap.NewProductionEncoderConfig()
    encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
    
    // 创建core
    core := zapcore.NewTee(
        zapcore.NewCore(
            zapcore.NewJSONEncoder(encoderConfig),
            fileWriter,
            config.Level,
        ),
        zapcore.NewCore(
            zapcore.NewConsoleEncoder(encoderConfig),
            consoleWriter,
            config.Level,
        ),
    )
    
    logger := zap.New(core,
        zap.AddCaller(),
        zap.AddCallerSkip(1),
        zap.AddStacktrace(zapcore.ErrorLevel),
    )
    
    return &Logger{logger}, nil
}

// Context相关方法
func (l *Logger) WithContext(ctx context.Context) *Logger {
    // 从context提取trace_id等信息
    if traceID, ok := ctx.Value("trace_id").(string); ok {
        return &Logger{l.With(zap.String("trace_id", traceID))}
    }
    return l
}
```

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025-10-29  
**文档状态**: ✅ 完成  
**适用版本**: Go 1.21+
