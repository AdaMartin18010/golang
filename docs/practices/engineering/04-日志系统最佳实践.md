# Goæ—¥å¿—ç³»ç»Ÿæœ€ä½³å®è·µå®Œå…¨æŒ‡å—

> **ç®€ä»‹**: Goè¯­è¨€æ—¥å¿—ç³»ç»Ÿè®¾è®¡å’Œä½¿ç”¨çš„å®Œæ•´æŒ‡å—ï¼ŒåŒ…æ‹¬log/slogã€Zapã€Logrusç­‰ä¸»æµæ—¥å¿—åº“

---

## ğŸ“‹ ç›®å½•


- [1. æ—¥å¿—ç³»ç»Ÿæ¦‚è¿°](#1-æ—¥å¿—ç³»ç»Ÿæ¦‚è¿°)
  - [æ—¥å¿—çº§åˆ«](#æ—¥å¿—çº§åˆ«)
  - [æ—¥å¿—æ ¼å¼å¯¹æ¯”](#æ—¥å¿—æ ¼å¼å¯¹æ¯”)
- [2. log/slogæ ‡å‡†åº“](#2-logslogæ ‡å‡†åº“)
  - [åŸºæœ¬ä½¿ç”¨](#åŸºæœ¬ä½¿ç”¨)
  - [é«˜çº§ç‰¹æ€§](#é«˜çº§ç‰¹æ€§)
    - [With() - æ·»åŠ ä¸Šä¸‹æ–‡å­—æ®µ](#with---æ·»åŠ ä¸Šä¸‹æ–‡å­—æ®µ)
    - [Group() - å­—æ®µåˆ†ç»„](#group---å­—æ®µåˆ†ç»„)
    - [LogValuer - è‡ªå®šä¹‰ç±»å‹æ—¥å¿—](#logvaluer---è‡ªå®šä¹‰ç±»å‹æ—¥å¿—)
  - [Webåº”ç”¨é›†æˆ](#webåº”ç”¨é›†æˆ)
- [3. Zapé«˜æ€§èƒ½æ—¥å¿—](#3-zapé«˜æ€§èƒ½æ—¥å¿—)
  - [3.1 å®‰è£…](#31-å®‰è£…)
  - [3.2 åŸºæœ¬ä½¿ç”¨](#32-åŸºæœ¬ä½¿ç”¨)
  - [3.3 é«˜çº§ç‰¹æ€§](#33-é«˜çº§ç‰¹æ€§)
    - [SugaredLogger - ä¾¿æ·API](#sugaredlogger---ä¾¿æ·api)
    - [å¤šè¾“å‡ºæº](#å¤šè¾“å‡ºæº)
    - [æ€§èƒ½å¯¹æ¯”](#æ€§èƒ½å¯¹æ¯”)
- [4. Logrusç»“æ„åŒ–æ—¥å¿—](#4-logrusç»“æ„åŒ–æ—¥å¿—)
  - [4.1 å®‰è£…](#41-å®‰è£…)
  - [4.2 åŸºæœ¬ä½¿ç”¨](#42-åŸºæœ¬ä½¿ç”¨)
  - [Hookæœºåˆ¶](#hookæœºåˆ¶)
- [5. æ—¥å¿—æœ€ä½³å®è·µ](#5-æ—¥å¿—æœ€ä½³å®è·µ)
  - [DO's âœ…](#dos-)
    - [1. ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—](#1-ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—)
    - [2. åˆé€‚çš„æ—¥å¿—çº§åˆ«](#2-åˆé€‚çš„æ—¥å¿—çº§åˆ«)
    - [3. è®°å½•å…³é”®ä¸šåŠ¡æµç¨‹](#3-è®°å½•å…³é”®ä¸šåŠ¡æµç¨‹)
    - [4. è®°å½•é”™è¯¯ä¸Šä¸‹æ–‡](#4-è®°å½•é”™è¯¯ä¸Šä¸‹æ–‡)
    - [5. æ•æ„Ÿä¿¡æ¯ä¿æŠ¤](#5-æ•æ„Ÿä¿¡æ¯ä¿æŠ¤)
  - [DON'Ts âŒ](#donts-)
- [6. æ—¥å¿—èšåˆå’Œåˆ†æ](#6-æ—¥å¿—èšåˆå’Œåˆ†æ)
  - [ELK Stacké›†æˆ](#elk-stacké›†æˆ)
  - [æ—¥å¿—è½®è½¬](#æ—¥å¿—è½®è½¬)
- [7. ç”Ÿäº§ç¯å¢ƒå®æˆ˜](#7-ç”Ÿäº§ç¯å¢ƒå®æˆ˜)
  - [å®Œæ•´æ—¥å¿—ç³»ç»Ÿæ¶æ„](#å®Œæ•´æ—¥å¿—ç³»ç»Ÿæ¶æ„)

## 1. æ—¥å¿—ç³»ç»Ÿæ¦‚è¿°

### æ—¥å¿—çº§åˆ«

| çº§åˆ« | ç”¨é€” | ä½¿ç”¨åœºæ™¯ |
|------|------|---------|
| **DEBUG** | è°ƒè¯•ä¿¡æ¯ | å¼€å‘ç¯å¢ƒè¯¦ç»†è°ƒè¯• |
| **INFO** | ä¸€èˆ¬ä¿¡æ¯ | ä¸šåŠ¡æµç¨‹è®°å½• |
| **WARN** | è­¦å‘Šä¿¡æ¯ | å¯æ¢å¤çš„å¼‚å¸¸æƒ…å†µ |
| **ERROR** | é”™è¯¯ä¿¡æ¯ | éœ€è¦å…³æ³¨çš„é”™è¯¯ |
| **FATAL** | è‡´å‘½é”™è¯¯ | å¯¼è‡´ç¨‹åºé€€å‡ºçš„é”™è¯¯ |

### æ—¥å¿—æ ¼å¼å¯¹æ¯”

```go
// éç»“æ„åŒ–æ—¥å¿—ï¼ˆä¸æ¨èï¼‰
log.Printf("User %s login from %s", username, ip)

// ç»“æ„åŒ–æ—¥å¿—ï¼ˆæ¨èï¼‰
logger.Info("user login",
    "username", username,
    "ip", ip,
    "timestamp", time.Now(),
)
```

---

## 2. log/slogæ ‡å‡†åº“

### åŸºæœ¬ä½¿ç”¨

```go
package main

import (
    "log/slog"
    "os"
)

func main() {
    // 1. ä½¿ç”¨é»˜è®¤loggerï¼ˆæ–‡æœ¬æ ¼å¼ï¼‰
    slog.Info("application started", "port", 8080, "env", "production")
    slog.Warn("high memory usage", "usage", "85%")
    slog.Error("database connection failed", "error", "timeout")
    
    // 2. JSONæ ¼å¼logger
    jsonLogger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
    jsonLogger.Info("user action", "user_id", 123, "action", "login")
    
    // 3. è‡ªå®šä¹‰é€‰é¡¹
    opts := &slog.HandlerOptions{
        Level: slog.LevelDebug,  // è®¾ç½®æœ€ä½æ—¥å¿—çº§åˆ«
        AddSource: true,          // æ·»åŠ æºæ–‡ä»¶ä¿¡æ¯
    }
    logger := slog.New(slog.NewJSONHandler(os.Stdout, opts))
    logger.Debug("debug info", "detail", "some details")
}
```

### é«˜çº§ç‰¹æ€§

#### With() - æ·»åŠ ä¸Šä¸‹æ–‡å­—æ®µ

```go
// åˆ›å»ºå¸¦æœ‰å›ºå®šå­—æ®µçš„logger
baseLogger := slog.Default()

// æ•°æ®åº“logger
dbLogger := baseLogger.With("module", "database", "connection", "primary")
dbLogger.Info("query executed", "duration", "150ms", "rows", 100)
// è¾“å‡º: ... module=database connection=primary duration=150ms rows=100

// API logger
apiLogger := baseLogger.With("module", "api", "version", "v1")
apiLogger.Info("request handled", "path", "/users", "status", 200)
// è¾“å‡º: ... module=api version=v1 path=/users status=200
```

#### Group() - å­—æ®µåˆ†ç»„

```go
logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))

logger.Info("HTTP request",
    slog.Group("http",
        slog.String("method", "GET"),
        slog.String("path", "/api/users"),
        slog.Int("status", 200),
        slog.Duration("duration", 150*time.Millisecond),
    ),
    slog.Group("client",
        slog.String("ip", "192.168.1.1"),
        slog.String("user_agent", "Mozilla/5.0"),
    ),
)

// JSONè¾“å‡º:
// {
//   "time": "2025-10-24T10:00:00Z",
//   "level": "INFO",
//   "msg": "HTTP request",
//   "http": {
//     "method": "GET",
//     "path": "/api/users",
//     "status": 200,
//     "duration": 150000000
//   },
//   "client": {
//     "ip": "192.168.1.1",
//     "user_agent": "Mozilla/5.0"
//   }
// }
```

#### LogValuer - è‡ªå®šä¹‰ç±»å‹æ—¥å¿—

```go
type User struct {
    ID       int
    Username string
    Email    string
    Password string  // æ•æ„Ÿä¿¡æ¯
}

// å®ç°LogValueræ¥å£ï¼Œæ§åˆ¶æ—¥å¿—è¾“å‡º
func (u User) LogValue() slog.Value {
    return slog.GroupValue(
        slog.Int("id", u.ID),
        slog.String("username", u.Username),
        // ä¸è¾“å‡ºEmailå’ŒPassword
    )
}

func main() {
    logger := slog.Default()
    
    user := User{
        ID:       123,
        Username: "alice",
        Email:    "alice@example.com",
        Password: "secret123",
    }
    
    logger.Info("user login", "user", user)
    // è¾“å‡º: ... user.id=123 user.username=alice
    // Emailå’ŒPasswordè¢«è‡ªåŠ¨è¿‡æ»¤
}
```

### Webåº”ç”¨é›†æˆ

```go
package main

import (
    "context"
    "log/slog"
    "net/http"
    "os"
    "time"
    
    "github.com/google/uuid"
)

// Loggerä¸­é—´ä»¶
func LoggerMiddleware(logger *slog.Logger) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()
            
            // ç”Ÿæˆè¯·æ±‚ID
            requestID := uuid.New().String()
            
            // åˆ›å»ºè¯·æ±‚ç‰¹å®šçš„logger
            reqLogger := logger.With(
                "request_id", requestID,
                "method", r.Method,
                "path", r.URL.Path,
                "remote_addr", r.RemoteAddr,
            )
            
            // å°†loggeræ”¾å…¥context
            ctx := context.WithValue(r.Context(), "logger", reqLogger)
            
            // è®°å½•è¯·æ±‚å¼€å§‹
            reqLogger.Info("request started")
            
            // åŒ…è£…ResponseWriterä»¥æ•è·çŠ¶æ€ç 
            wrw := &responseWriterWrapper{ResponseWriter: w, statusCode: 200}
            
            // å¤„ç†è¯·æ±‚
            next.ServeHTTP(wrw, r.WithContext(ctx))
            
            // è®°å½•è¯·æ±‚å®Œæˆ
            duration := time.Since(start)
            reqLogger.Info("request completed",
                "status", wrw.statusCode,
                "duration_ms", duration.Milliseconds(),
            )
        })
    }
}

type responseWriterWrapper struct {
    http.ResponseWriter
    statusCode int
}

func (w *responseWriterWrapper) WriteHeader(statusCode int) {
    w.statusCode = statusCode
    w.ResponseWriter.WriteHeader(statusCode)
}

// ä»contextè·å–logger
func GetLogger(ctx context.Context) *slog.Logger {
    if logger, ok := ctx.Value("logger").(*slog.Logger); ok {
        return logger
    }
    return slog.Default()
}

func main() {
    // åˆ›å»ºJSON loggerç”¨äºç”Ÿäº§ç¯å¢ƒ
    logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
        Level: slog.LevelInfo,
    }))
    
    mux := http.NewServeMux()
    
    mux.HandleFunc("/api/users", func(w http.ResponseWriter, r *http.Request) {
        logger := GetLogger(r.Context())
        
        // ä¸šåŠ¡é€»è¾‘
        logger.Info("fetching users")
        
        w.Header().Set("Content-Type", "application/json")
        w.Write([]byte(`{"users": []}`))
    })
    
    // åº”ç”¨ä¸­é—´ä»¶
    handler := LoggerMiddleware(logger)(mux)
    
    logger.Info("server starting", "port", 8080)
    http.ListenAndServe(":8080", handler)
}
```

---

## 3. Zapé«˜æ€§èƒ½æ—¥å¿—

### 3.1 å®‰è£…

```bash
go get -u go.uber.org/zap
```

### 3.2 åŸºæœ¬ä½¿ç”¨

```go
package main

import (
    "go.uber.org/zap"
    "go.uber.org/zap/zapcore"
)

func main() {
    // 1. é¢„è®¾é…ç½®ï¼ˆå¼€å‘ç¯å¢ƒï¼‰
    devLogger, _ := zap.NewDevelopment()
    defer devLogger.Sync()
    
    devLogger.Info("development logger",
        zap.String("key", "value"),
        zap.Int("number", 123),
    )
    
    // 2. é¢„è®¾é…ç½®ï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰
    prodLogger, _ := zap.NewProduction()
    defer prodLogger.Sync()
    
    prodLogger.Info("production logger",
        zap.String("env", "prod"),
        zap.Int("port", 8080),
    )
    
    // 3. è‡ªå®šä¹‰é…ç½®
    config := zap.Config{
        Level:       zap.NewAtomicLevelAt(zap.InfoLevel),
        Development: false,
        Encoding:    "json",
        EncoderConfig: zapcore.EncoderConfig{
            TimeKey:        "timestamp",
            LevelKey:       "level",
            NameKey:        "logger",
            CallerKey:      "caller",
            MessageKey:     "message",
            StacktraceKey:  "stacktrace",
            LineEnding:     zapcore.DefaultLineEnding,
            EncodeLevel:    zapcore.LowercaseLevelEncoder,
            EncodeTime:     zapcore.ISO8601TimeEncoder,
            EncodeDuration: zapcore.SecondsDurationEncoder,
            EncodeCaller:   zapcore.ShortCallerEncoder,
        },
        OutputPaths:      []string{"stdout"},
        ErrorOutputPaths: []string{"stderr"},
    }
    
    logger, _ := config.Build()
    defer logger.Sync()
    
    logger.Info("custom logger started")
}
```

### 3.3 é«˜çº§ç‰¹æ€§

#### SugaredLogger - ä¾¿æ·API

```go
logger, _ := zap.NewProduction()
sugar := logger.Sugar()
defer sugar.Sync()

// æ”¯æŒprintfé£æ ¼
sugar.Infof("User %s logged in from %s", "alice", "192.168.1.1")

// æ”¯æŒé”®å€¼å¯¹
sugar.Infow("user login",
    "username", "alice",
    "ip", "192.168.1.1",
    "timestamp", time.Now(),
)
```

#### å¤šè¾“å‡ºæº

```go
// åŒæ—¶è¾“å‡ºåˆ°æ–‡ä»¶å’Œæ§åˆ¶å°
func NewLogger() (*zap.Logger, error) {
    // æ–‡ä»¶è¾“å‡ºé…ç½®
    fileWriter := zapcore.AddSync(&lumberjack.Logger{
        Filename:   "./logs/app.log",
        MaxSize:    100, // MB
        MaxBackups: 3,
        MaxAge:     28, // days
        Compress:   true,
    })
    
    // æ§åˆ¶å°è¾“å‡ºé…ç½®
    consoleWriter := zapcore.AddSync(os.Stdout)
    
    // ç¼–ç å™¨é…ç½®
    encoderConfig := zap.NewProductionEncoderConfig()
    encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
    
    // åˆ›å»ºcore
    core := zapcore.NewTee(
        zapcore.NewCore(
            zapcore.NewJSONEncoder(encoderConfig),
            fileWriter,
            zap.InfoLevel,
        ),
        zapcore.NewCore(
            zapcore.NewConsoleEncoder(encoderConfig),
            consoleWriter,
            zap.DebugLevel,
        ),
    )
    
    logger := zap.New(core, zap.AddCaller(), zap.AddCallerSkip(1))
    return logger, nil
}
```

#### æ€§èƒ½å¯¹æ¯”

```go
// Benchmarkæµ‹è¯•
func BenchmarkZap(b *testing.B) {
    logger, _ := zap.NewProduction()
    defer logger.Sync()
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        logger.Info("benchmark test",
            zap.Int("iteration", i),
            zap.String("key", "value"),
        )
    }
}

// ç»“æœ:
// BenchmarkZap-8    1000000    1200 ns/op    0 B/op    0 allocs/op
// Zapæ€§èƒ½ä¼˜ç§€ï¼Œé›¶å†…å­˜åˆ†é…
```

---

## 4. Logrusç»“æ„åŒ–æ—¥å¿—

### 4.1 å®‰è£…

```bash
go get -u github.com/sirupsen/logrus
```

### 4.2 åŸºæœ¬ä½¿ç”¨

```go
package main

import (
    "os"
    
    log "github.com/sirupsen/logrus"
)

func main() {
    // 1. åŸºç¡€é…ç½®
    log.SetFormatter(&log.JSONFormatter{})
    log.SetOutput(os.Stdout)
    log.SetLevel(log.InfoLevel)
    
    // 2. ç»“æ„åŒ–æ—¥å¿—
    log.WithFields(log.Fields{
        "username": "alice",
        "ip":       "192.168.1.1",
        "action":   "login",
    }).Info("user login")
    
    // 3. è‡ªå®šä¹‰logger
    logger := log.New()
    logger.SetFormatter(&log.TextFormatter{
        FullTimestamp: true,
    })
    
    logger.WithFields(log.Fields{
        "module": "database",
        "query":  "SELECT * FROM users",
    }).Info("database query")
}
```

### Hookæœºåˆ¶

```go
// è‡ªå®šä¹‰Hook - å‘é€é”™è¯¯åˆ°å‘Šè­¦ç³»ç»Ÿ
type AlertHook struct {
    alertClient *AlertClient
}

func (hook *AlertHook) Levels() []log.Level {
    return []log.Level{log.ErrorLevel, log.FatalLevel, log.PanicLevel}
}

func (hook *AlertHook) Fire(entry *log.Entry) error {
    // å‘é€å‘Šè­¦
    return hook.alertClient.Send(entry.Message, entry.Data)
}

func main() {
    logger := log.New()
    
    // æ·»åŠ Hook
    logger.AddHook(&AlertHook{
        alertClient: NewAlertClient(),
    })
    
    logger.Error("critical error occurred")
    // è‡ªåŠ¨è§¦å‘å‘Šè­¦
}
```

---

## 5. æ—¥å¿—æœ€ä½³å®è·µ

### DO's âœ…

#### 1. ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—

```go
// âŒ ä¸æ¨è - å­—ç¬¦ä¸²æ‹¼æ¥
log.Printf("User %s login from %s with result %s", user, ip, result)

// âœ… æ¨è - ç»“æ„åŒ–å­—æ®µ
logger.Info("user login",
    "user", user,
    "ip", ip,
    "result", result,
)
```

#### 2. åˆé€‚çš„æ—¥å¿—çº§åˆ«

```go
// âœ… æ­£ç¡®ä½¿ç”¨æ—¥å¿—çº§åˆ«
logger.Debug("entering function", "name", "ProcessOrder")      // è°ƒè¯•
logger.Info("order created", "order_id", 123)                   // ä¸€èˆ¬ä¿¡æ¯
logger.Warn("retry attempt", "attempt", 3, "max", 5)           // è­¦å‘Š
logger.Error("failed to save", "error", err)                    // é”™è¯¯
logger.Fatal("database unreachable", "error", err)              // è‡´å‘½é”™è¯¯
```

#### 3. è®°å½•å…³é”®ä¸šåŠ¡æµç¨‹

```go
func ProcessPayment(orderID int, amount float64) error {
    logger := GetLogger()
    
    logger.Info("payment processing started",
        "order_id", orderID,
        "amount", amount,
    )
    
    // ä¸šåŠ¡é€»è¾‘
    if err := validatePayment(orderID, amount); err != nil {
        logger.Error("payment validation failed",
            "order_id", orderID,
            "error", err,
        )
        return err
    }
    
    logger.Info("payment processing completed",
        "order_id", orderID,
        "status", "success",
    )
    
    return nil
}
```

#### 4. è®°å½•é”™è¯¯ä¸Šä¸‹æ–‡

```go
// âŒ ä¸æ¨è - ç¼ºå°‘ä¸Šä¸‹æ–‡
logger.Error("save failed", "error", err)

// âœ… æ¨è - å®Œæ•´ä¸Šä¸‹æ–‡
logger.Error("failed to save user",
    "user_id", user.ID,
    "operation", "create",
    "error", err.Error(),
    "stack", string(debug.Stack()),
)
```

#### 5. æ•æ„Ÿä¿¡æ¯ä¿æŠ¤

```go
// âŒ ä¸æ¨è - è®°å½•æ•æ„Ÿä¿¡æ¯
logger.Info("user created",
    "username", username,
    "password", password,      // ä¸åº”è®°å½•å¯†ç 
    "credit_card", cardNumber,  // ä¸åº”è®°å½•ä¿¡ç”¨å¡å·
)

// âœ… æ¨è - è¿‡æ»¤æ•æ„Ÿä¿¡æ¯
logger.Info("user created",
    "username", username,
    "email", maskEmail(email),  // è„±æ•å¤„ç†
)

func maskEmail(email string) string {
    parts := strings.Split(email, "@")
    if len(parts) != 2 {
        return "***"
    }
    return parts[0][:2] + "***@" + parts[1]
}
```

### DON'Ts âŒ

```go
// âŒ 1. ä¸è¦åœ¨å¾ªç¯ä¸­å¤§é‡æ‰“å°æ—¥å¿—
for i := 0; i < 1000000; i++ {
    logger.Debug("processing", "index", i)  // æ€§èƒ½é—®é¢˜
}

// âœ… æ”¹è¿›ï¼šé‡‡æ ·æˆ–æ‰¹é‡è®°å½•
if i%10000 == 0 {
    logger.Debug("processing batch", "index", i)
}

// âŒ 2. ä¸è¦è®°å½•è¿‡é•¿çš„å†…å®¹
logger.Info("data", "content", longString)  // å¯èƒ½æœ‰å‡ MB

// âœ… æ”¹è¿›ï¼šæˆªæ–­æˆ–åªè®°å½•æ‘˜è¦
logger.Info("data received", "length", len(longString), "hash", hash(longString))

// âŒ 3. ä¸è¦å¿½ç•¥æ—¥å¿—é”™è¯¯
logger.Sync()  // å¿½ç•¥é”™è¯¯

// âœ… æ”¹è¿›ï¼šæ£€æŸ¥é”™è¯¯
if err := logger.Sync(); err != nil {
    fmt.Fprintf(os.Stderr, "failed to sync logger: %v\n", err)
}
```

---

## 6. æ—¥å¿—èšåˆå’Œåˆ†æ

### ELK Stacké›†æˆ

```go
// Logstashæ ¼å¼è¾“å‡º
type LogstashFormatter struct{}

func (f *LogstashFormatter) Format(entry *log.Entry) ([]byte, error) {
    data := make(log.Fields)
    for k, v := range entry.Data {
        data[k] = v
    }
    
    data["@timestamp"] = entry.Time.Format(time.RFC3339)
    data["message"] = entry.Message
    data["level"] = entry.Level.String()
    
    serialized, err := json.Marshal(data)
    if err != nil {
        return nil, err
    }
    return append(serialized, '\n'), nil
}

// ä½¿ç”¨
logger := logrus.New()
logger.SetFormatter(&LogstashFormatter{})
```

### æ—¥å¿—è½®è½¬

```go
import "gopkg.in/natefinch/lumberjack.v2"

// é…ç½®æ—¥å¿—è½®è½¬
logger := &lumberjack.Logger{
    Filename:   "/var/log/myapp/app.log",
    MaxSize:    100,   // MB
    MaxBackups: 3,     // ä¿ç•™æ—§æ–‡ä»¶æ•°é‡
    MaxAge:     28,    // å¤©
    Compress:   true,  // å‹ç¼©æ—§æ–‡ä»¶
}

log.SetOutput(logger)
```

---

## 7. ç”Ÿäº§ç¯å¢ƒå®æˆ˜

### å®Œæ•´æ—¥å¿—ç³»ç»Ÿæ¶æ„

```go
package logger

import (
    "context"
    "os"
    
    "go.uber.org/zap"
    "go.uber.org/zap/zapcore"
    "gopkg.in/natefinch/lumberjack.v2"
)

type Logger struct {
    *zap.Logger
}

func NewLogger(env string) (*Logger, error) {
    var config zap.Config
    
    if env == "production" {
        config = zap.NewProductionConfig()
    } else {
        config = zap.NewDevelopmentConfig()
    }
    
    // æ–‡ä»¶è¾“å‡º
    fileWriter := zapcore.AddSync(&lumberjack.Logger{
        Filename:   "./logs/app.log",
        MaxSize:    100,
        MaxBackups: 3,
        MaxAge:     28,
        Compress:   true,
    })
    
    // æ§åˆ¶å°è¾“å‡º
    consoleWriter := zapcore.AddSync(os.Stdout)
    
    // ç¼–ç å™¨
    encoderConfig := zap.NewProductionEncoderConfig()
    encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
    
    // åˆ›å»ºcore
    core := zapcore.NewTee(
        zapcore.NewCore(
            zapcore.NewJSONEncoder(encoderConfig),
            fileWriter,
            config.Level,
        ),
        zapcore.NewCore(
            zapcore.NewConsoleEncoder(encoderConfig),
            consoleWriter,
            config.Level,
        ),
    )
    
    logger := zap.New(core,
        zap.AddCaller(),
        zap.AddCallerSkip(1),
        zap.AddStacktrace(zapcore.ErrorLevel),
    )
    
    return &Logger{logger}, nil
}

// Contextç›¸å…³æ–¹æ³•
func (l *Logger) WithContext(ctx context.Context) *Logger {
    // ä»contextæå–trace_idç­‰ä¿¡æ¯
    if traceID, ok := ctx.Value("trace_id").(string); ok {
        return &Logger{l.With(zap.String("trace_id", traceID))}
    }
    return l
}
```

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ24æ—¥  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.21+
