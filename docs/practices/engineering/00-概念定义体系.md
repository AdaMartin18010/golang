# 概念定义体系

**版本**: v1.0
**更新日期**: 2025-11-11
**适用于**: Go 1.25.3
**文件夹**: practices/engineering

---

## 📋 目录

- [概念定义体系](#概念定义体系)
  - [1. 测试相关概念](#1-测试相关概念)
- [生成覆盖率报告](#生成覆盖率报告)
- [查看覆盖率](#查看覆盖率)
- [生成HTML报告](#生成html报告)
- [仅显示未覆盖代码](#仅显示未覆盖代码)
  - [2. 代码质量概念](#2-代码质量概念)
- [基础检查](#基础检查)
- [综合Linter](#综合linter)
- [安全扫描](#安全扫描)
- [复杂度检查](#复杂度检查)
- [依赖分析](#依赖分析)
  - [功能性](#功能性)
  - [代码质量](#代码质量)
  - [测试](#测试)
  - [安全性](#安全性)
  - [性能](#性能)
  - [3. CI/CD概念](#3-cicd概念)
  - [4. 日志相关概念](#4-日志相关概念)
  - [5. 错误处理概念](#5-错误处理概念)
  - [6. 项目组织概念](#6-项目组织概念)
  - [🔗 相关文档](#相关文档)

---

## 1. 测试相关概念

### 1.1 测试金字塔 (Test Pyramid)

**定义**: 测试策略的可视化模型，表示不同层次测试的理想比例分布。

**形式化定义**:

```text
TestPyramid = {
    底层: UnitTests (70-80%),
    中层: IntegrationTests (15-20%),
    顶层: E2ETests (5-10%)
}
```

**核心原则**:

1. **数量分布**: 单元测试最多，E2E测试最少
2. **速度**: 底层快，顶层慢
3. **成本**: 底层低，顶层高
4. **稳定性**: 底层稳定，顶层脆弱

**Go实践**:

```go
// 单元测试 (快速,隔离)
func TestAdd(t *testing.T) {
    result := Add(2, 3)
    assert.Equal(t, 5, result)
}

// 集成测试 (与外部系统交互)
func TestDatabaseIntegration(t *testing.T) {
    db := setupTestDB(t)
    defer db.Close()
    // 测试数据库操作
}

// E2E测试 (完整用户流程)
func TestUserJourney(t *testing.T) {
    // 启动完整应用
    // 模拟用户操作
}
```

---

### 1.2 表格驱动测试 (Table-Driven Tests)

**定义**: Go语言推荐的测试模式，使用数据表定义测试用例。

**形式化定义**:

```text
TableDrivenTest = {
    TestCases: []TestCase,
    Execute: foreach case in TestCases { run(case) }
}

TestCase = {
    name: string,
    input: interface{},
    expected: interface{},
    setup: func(),
    teardown: func()
}
```

**优点**:

- ✅ 易于添加新用例
- ✅ 代码简洁
- ✅ 易于维护
- ✅ 清晰的失败信息

**Go实践**:

```go
func TestCalculate(t *testing.T) {
    tests := []struct {
        name     string
        a, b     int
        op       string
        want     int
        wantErr  bool
    }{
        {"add", 2, 3, "+", 5, false},
        {"subtract", 5, 3, "-", 2, false},
        {"divide by zero", 5, 0, "/", 0, true},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := Calculate(tt.a, tt.b, tt.op)
            if (err != nil) != tt.wantErr {
                t.Errorf("wantErr %v, got err %v", tt.wantErr, err)
            }
            if got != tt.want {
                t.Errorf("want %d, got %d", tt.want, got)
            }
        })
    }
}
```

---

### 1.3 Mock (模拟对象)

**定义**: 用于隔离被测试代码的测试替身，用于模拟依赖的行为。

**形式化定义**:

```text
Mock = {
    Interface: Type,
    Expectations: []Expectation,
    Verify: func() error
}

Expectation = {
    Method: string,
    Args: []interface{},
    Returns: []interface{},
    Times: int
}
```

**类型**:

1. **Dummy**: 占位对象（不使用）
2. **Stub**: 提供固定响应
3. **Mock**: 验证行为
4. **Spy**: 记录调用
5. **Fake**: 简化实现

**Go实践 (gomock)**:

```go
// 定义接口
type Database interface {
    Get(key string) (string, error)
    Set(key, value string) error
}

// 生成Mock
//go:generate mockgen -source=db.go -destination=db_mock.go

// 使用Mock
func TestService(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()

    db := NewMockDatabase(ctrl)
    db.EXPECT().Get("key").Return("value", nil).Times(1)

    service := NewService(db)
    result, err := service.Process("key")
    // 断言...
}
```

---

### 1.4 测试覆盖率 (Test Coverage)

**定义**: 代码被测试执行的比例，衡量测试完整性的指标。

**形式化定义**:

```text
Coverage = (ExecutedLines / TotalLines) × 100%

CoverageTypes = {
    Line: 行覆盖率,
    Branch: 分支覆盖率,
    Function: 函数覆盖率,
    Statement: 语句覆盖率
}
```

**目标设定**:

- **核心业务逻辑**: 100%
- **工具类函数**: >90%
- **项目整体**: >80%
- **UI层**: >60%

**Go实践**:

```bash
# 生成覆盖率报告
go test -coverprofile=coverage.out ./...

# 查看覆盖率
go tool cover -func=coverage.out

# 生成HTML报告
go tool cover -html=coverage.out -o coverage.html

# 仅显示未覆盖代码
go test -cover -covermode=count -coverprofile=coverage.out
go tool cover -func=coverage.out | grep -v "100.0%"
```

---

## 2. 代码质量概念

### 2.1 静态分析 (Static Analysis)

**定义**: 不执行代码的情况下，通过分析源代码检测潜在问题。

**形式化定义**:

```text
StaticAnalysis = {
    Input: SourceCode,
    Analyze: AST → Issues,
    Output: []Issue
}

Issue = {
    Type: ErrorType,
    Severity: Level,
    Location: Position,
    Message: string
}
```

**检查类型**:

1. **语法错误**: 编译错误
2. **语义错误**: 类型不匹配
3. **风格问题**: 不符合规范
4. **潜在bug**: 逻辑错误
5. **安全问题**: 安全漏洞
6. **性能问题**: 性能瓶颈

**Go工具链**:

```bash
# 基础检查
go vet ./...

# 综合Linter
golangci-lint run

# 安全扫描
gosec ./...

# 复杂度检查
gocyclo -over 15 .

# 依赖分析
go mod graph | grep vulnerable
```

---

### 2.2 代码审查 (Code Review)

**定义**: 团队成员对代码变更进行系统性检查的过程。

**形式化流程**:

```text
CodeReview = {
    1. Submit: PR创建,
    2. Assign: 分配审查者,
    3. Review: 审查代码,
    4. Comment: 提出意见,
    5. Revise: 修改代码,
    6. Approve: 批准合并
}
```

**审查清单**:

```markdown
    ## 功能性
    - [ ] 实现符合需求
    - [ ] 边界条件处理正确
    - [ ] 错误处理完整

    ## 代码质量
    - [ ] 代码清晰易读
    - [ ] 命名规范
    - [ ] 无重复代码
    - [ ] 复杂度合理

    ## 测试
    - [ ] 单元测试完整
    - [ ] 测试覆盖率达标
    - [ ] 测试用例充分

    ## 安全性
    - [ ] 无安全漏洞
    - [ ] 输入验证
    - [ ] 权限检查

    ## 性能
    - [ ] 无性能问题
    - [ ] 资源使用合理
    - [ ] 并发安全
```

---

## 3. CI/CD概念

### 3.1 持续集成 (Continuous Integration)

**定义**: 频繁地将代码集成到主分支，并自动运行测试和检查。

**形式化定义**:

```text
CI = {
    Trigger: CodeCommit,
    Pipeline: [
        Build,
        Test,
        StaticAnalysis,
        SecurityScan
    ],
    Result: Success | Failure
}
```

**核心原则**:

1. **频繁提交**: 每天多次
2. **自动构建**: 每次提交触发
3. **自动测试**: 全量测试
4. **快速反馈**: <10分钟
5. **保持主干可部署**: 永远可发布

**GitHub Actions示例**:

```yaml
name: CI
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-go@v4
        with:
          go-version: '1.25'

      - name: Test
        run: go test -v -race -coverprofile=coverage.txt ./...

      - name: Lint
        uses: golangci/golangci-lint-action@v3
```

---

### 3.2 持续部署 (Continuous Deployment)

**定义**: 通过自动化流程将代码变更部署到生产环境。

**形式化定义**:

```text
CD = {
    Trigger: CI_Success,
    Stages: [
        Build_Artifact,
        Deploy_Staging,
        Run_Tests,
        Deploy_Production
    ],
    Rollback: On_Failure
}
```

**部署策略**:

1. **蓝绿部署**: 两套环境切换
2. **金丝雀发布**: 逐步放量
3. **滚动更新**: 逐个更新
4. **A/B测试**: 并行对比

---

## 4. 日志相关概念

### 4.1 结构化日志 (Structured Logging)

**定义**: 以结构化格式（如JSON）记录日志，便于机器解析和分析。

**形式化定义**:

```text
StructuredLog = {
    timestamp: Time,
    level: Level,
    message: string,
    fields: Map[string]interface{}
}
```

**优点**:

- ✅ 易于解析
- ✅ 便于查询
- ✅ 支持聚合分析
- ✅ 机器友好

**Go实践 (zap)**:

```go
logger, _ := zap.NewProduction()
defer logger.Sync()

logger.Info("user login",
    zap.String("user_id", "12345"),
    zap.String("ip", "192.168.1.1"),
    zap.Duration("latency", 50*time.Millisecond),
)

// JSON输出:
// {"level":"info","ts":1698765432,"msg":"user login",
//  "user_id":"12345","ip":"192.168.1.1","latency":0.05}
```

---

### 4.2 日志级别 (Log Levels)

**定义**: 日志消息的重要性分级，用于过滤和管理日志输出。

**标准级别**:

```text
Levels = {
    TRACE:  最详细 (开发调试),
    DEBUG:  调试信息,
    INFO:   一般信息 ⭐,
    WARN:   警告信息 ⚠️,
    ERROR:  错误信息 ❌,
    FATAL:  致命错误 💀,
    PANIC:  恐慌错误 🚨
}
```

**使用建议**:

- **DEBUG**: 开发环境详细日志
- **INFO**: 生产环境关键操作
- **WARN**: 潜在问题，需关注
- **ERROR**: 错误，需处理
- **FATAL**: 严重错误，程序退出

---

## 5. 错误处理概念

### 5.1 错误包装 (Error Wrapping)

**定义**: 在错误传播过程中添加上下文信息，形成错误链。

**形式化定义**:

```text
WrappedError = {
    message: string,
    cause: error,
    stack: StackTrace
}
```

**Go 1.13+实践**:

```go
// 包装错误
if err != nil {
    return fmt.Errorf("failed to read file %s: %w", filename, err)
}

// 错误判断
if errors.Is(err, os.ErrNotExist) {
    // 文件不存在
}

// 错误类型断言
var perr *os.PathError
if errors.As(err, &perr) {
    fmt.Println("Path error:", perr.Path)
}
```

---

### 5.2 哨兵错误 (Sentinel Errors)

**定义**: 预定义的错误变量，用于表示特定错误条件。

**定义方式**:

```go
var (
    ErrNotFound     = errors.New("not found")
    ErrInvalidInput = errors.New("invalid input")
    ErrUnauthorized = errors.New("unauthorized")
)

// 使用
func Get(id string) (*User, error) {
    if id == "" {
        return nil, ErrInvalidInput
    }
    // ...
    return nil, ErrNotFound
}
```

**优点**:

- ✅ 易于判断
- ✅ 文档清晰
- ✅ 可比较性

**缺点**:

- ⚠️ 缺乏上下文
- ⚠️ 全局变量

---

## 6. 项目组织概念

### 6.1 标准项目布局

**定义**: Go项目的推荐目录结构，促进代码组织和可维护性。

**标准布局**:

```text
project/
├── cmd/           # 主程序入口
│   └── myapp/
│       └── main.go
├── internal/      # 私有代码
│   ├── service/
│   └── repository/
├── pkg/           # 公共库
│   └── utils/
├── api/           # API定义(proto/swagger)
├── configs/       # 配置文件
├── scripts/       # 脚本
├── docs/          # 文档
├── test/          # 测试数据/工具
├── go.mod
└── go.sum
```

**关键目录说明**:

- **`/cmd`**: 可执行程序，每个子目录一个
- **`/internal`**: 不可导入的私有代码
- **`/pkg`**: 可供外部使用的库
- **`/api`**: API规范定义

---

### 6.2 分层架构 (Layered Architecture)

**定义**: 将应用分为多个逻辑层，每层有明确职责。

**标准分层**:

```text
Application
├── Handler Layer    (HTTP/gRPC handlers)
├── Service Layer    (业务逻辑)
├── Repository Layer (数据访问)
└── Model Layer      (数据模型)
```

**Go实践**:

```go
// Handler层
type UserHandler struct {
    service UserService
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
    user, err := h.service.GetUser(id)
    // 返回HTTP响应
}

// Service层
type UserService interface {
    GetUser(id string) (*User, error)
}

func (s *userService) GetUser(id string) (*User, error) {
    return s.repo.FindByID(id)
}

// Repository层
type UserRepository interface {
    FindByID(id string) (*User, error)
}

func (r *userRepo) FindByID(id string) (*User, error) {
    // 数据库查询
}
```

---

## 🔗 相关文档
