# Go 1.25.3 测试工程完整实战

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---

## 📋 目录

- [📖 文档说明](#文档说明)
- [目录](#目录)
- [1. 单元测试基础](#1.-单元测试基础)
  - [1.1 基础测试结构](#1.1-基础测试结构)
  - [1.2 使用testify/assert](#1.2-使用testifyassert)
  - [1.3 子测试（Subtests）](#1.3-子测试subtests)
- [2. 表格驱动测试](#2.-表格驱动测试)
  - [2.1 基础表格驱动](#2.1-基础表格驱动)
  - [2.2 复杂场景表格驱动](#2.2-复杂场景表格驱动)
- [3. Mock与桩测试](#3.-mock与桩测试)
  - [3.1 使用接口进行Mock](#3.1-使用接口进行mock)
  - [3.2 使用testify/mock](#3.2-使用testifymock)
  - [3.3 使用gomock](#3.3-使用gomock)
- [4. 集成测试](#4.-集成测试)
  - [4.1 数据库集成测试（sqlmock）](#4.1-数据库集成测试sqlmock)
  - [4.2 使用testcontainers真实数据库测试](#4.2-使用testcontainers真实数据库测试)
- [5. E2E测试](#e2e测试)
  - [5.1 HTTP API端到端测试](#5.1-http-api端到端测试)
- [6. 性能测试](#性能测试)
  - [6.1 基准测试](#6.1-基准测试)
  - [6.2 并发基准测试](#6.2-并发基准测试)
- [7. 测试覆盖率](#7.-测试覆盖率)
  - [7.1 生成覆盖率报告](#7.1-生成覆盖率报告)
  - [7.2 覆盖率配置](#7.2-覆盖率配置)
- [8. 测试最佳实践](#8.-测试最佳实践)
  - [8.1 测试文件组织](#8.1-测试文件组织)
  - [8.2 测试命名规范](#8.2-测试命名规范)
  - [8.3 测试隔离](#8.3-测试隔离)
  - [8.4 并行测试](#8.4-并行测试)
- [📚 测试清单](#测试清单)
  - [单元测试](#单元测试)
  - [集成测试](#集成测试)
  - [E2E测试](#e2e测试)
  - [性能测试](#性能测试)
- [🎯 总结](#总结)

## 📖 文档说明

本文档展示Go 1.25.3的**测试工程完整方案**，从单元测试到E2E测试的全方位覆盖：

- ✅ 单元测试最佳实践
- ✅ 表格驱动测试
- ✅ Mock与桩测试
- ✅ 集成测试
- ✅ E2E端到端测试
- ✅ 性能测试与基准测试
- ✅ 测试覆盖率分析

---

## 1. 单元测试基础

### 1.1 基础测试结构

```go
package math

import "testing"

// Add 加法函数
func Add(a, b int) int {
 return a + b
}

// TestAdd 基础测试
func TestAdd(t *testing.T) {
 result := Add(2, 3)
 expected := 5
 
 if result != expected {
  t.Errorf("Add(2, 3) = %d; want %d", result, expected)
 }
}

// TestAdd_Negative 负数测试
func TestAdd_Negative(t *testing.T) {
 result := Add(-1, -2)
 expected := -3
 
 if result != expected {
  t.Errorf("Add(-1, -2) = %d; want %d", result, expected)
 }
}
```

### 1.2 使用testify/assert

```go
package math

import (
 "testing"
 "github.com/stretchr/testify/assert"
)

func TestAddWithAssert(t *testing.T) {
 // 基础断言
 assert.Equal(t, 5, Add(2, 3), "2 + 3 should equal 5")
 assert.NotEqual(t, 6, Add(2, 3))
 
 // 多个断言
 assert := assert.New(t)
 assert.Equal(5, Add(2, 3))
 assert.Equal(-3, Add(-1, -2))
 assert.Equal(0, Add(0, 0))
}
```

### 1.3 子测试（Subtests）

```go
func TestMathOperations(t *testing.T) {
 t.Run("Addition", func(t *testing.T) {
  assert.Equal(t, 5, Add(2, 3))
 })
 
 t.Run("Subtraction", func(t *testing.T) {
  assert.Equal(t, -1, Subtract(2, 3))
 })
 
 t.Run("Multiplication", func(t *testing.T) {
  assert.Equal(t, 6, Multiply(2, 3))
 })
}

// 运行特定子测试：
// go test -run TestMathOperations/Addition
```

---

## 2. 表格驱动测试

### 2.1 基础表格驱动

```go
func TestAdd_TableDriven(t *testing.T) {
 tests := []struct {
  name     string
  a, b     int
  expected int
 }{
  {"positive numbers", 2, 3, 5},
  {"negative numbers", -1, -2, -3},
  {"zero", 0, 0, 0},
  {"positive and negative", 5, -3, 2},
  {"large numbers", 1000000, 2000000, 3000000},
 }
 
 for _, tt := range tests {
  t.Run(tt.name, func(t *testing.T) {
   result := Add(tt.a, tt.b)
   assert.Equal(t, tt.expected, result)
  })
 }
}
```

### 2.2 复杂场景表格驱动

```go
package user

import (
 "errors"
 "testing"
 "github.com/stretchr/testify/assert"
)

type User struct {
 Name  string
 Email string
 Age   int
}

func ValidateUser(u *User) error {
 if u.Name == "" {
  return errors.New("name is required")
 }
 if u.Age < 0 || u.Age > 150 {
  return errors.New("invalid age")
 }
 if u.Email == "" {
  return errors.New("email is required")
 }
 return nil
}

func TestValidateUser(t *testing.T) {
 tests := []struct {
  name    string
  user    *User
  wantErr bool
  errMsg  string
 }{
  {
   name: "valid user",
   user: &User{
    Name:  "John",
    Email: "john@example.com",
    Age:   30,
   },
   wantErr: false,
  },
  {
   name: "missing name",
   user: &User{
    Name:  "",
    Email: "john@example.com",
    Age:   30,
   },
   wantErr: true,
   errMsg:  "name is required",
  },
  {
   name: "invalid age - negative",
   user: &User{
    Name:  "John",
    Email: "john@example.com",
    Age:   -5,
   },
   wantErr: true,
   errMsg:  "invalid age",
  },
  {
   name: "invalid age - too high",
   user: &User{
    Name:  "John",
    Email: "john@example.com",
    Age:   200,
   },
   wantErr: true,
   errMsg:  "invalid age",
  },
  {
   name: "missing email",
   user: &User{
    Name:  "John",
    Email: "",
    Age:   30,
   },
   wantErr: true,
   errMsg:  "email is required",
  },
 }
 
 for _, tt := range tests {
  t.Run(tt.name, func(t *testing.T) {
   err := ValidateUser(tt.user)
   
   if tt.wantErr {
    assert.Error(t, err)
    assert.Contains(t, err.Error(), tt.errMsg)
   } else {
    assert.NoError(t, err)
   }
  })
 }
}
```

---

## 3. Mock与桩测试

### 3.1 使用接口进行Mock

```go
package service

import (
 "context"
 "errors"
)

// UserRepository 用户仓库接口
type UserRepository interface {
 GetByID(ctx context.Context, id string) (*User, error)
 Create(ctx context.Context, user *User) error
}

// UserService 用户服务
type UserService struct {
 repo UserRepository
}

func NewUserService(repo UserRepository) *UserService {
 return &UserService{repo: repo}
}

func (s *UserService) GetUser(ctx context.Context, id string) (*User, error) {
 if id == "" {
  return nil, errors.New("id is required")
 }
 
 return s.repo.GetByID(ctx, id)
}

// Mock实现
type MockUserRepository struct {
 GetByIDFunc func(ctx context.Context, id string) (*User, error)
 CreateFunc  func(ctx context.Context, user *User) error
}

func (m *MockUserRepository) GetByID(ctx context.Context, id string) (*User, error) {
 if m.GetByIDFunc != nil {
  return m.GetByIDFunc(ctx, id)
 }
 return nil, errors.New("not implemented")
}

func (m *MockUserRepository) Create(ctx context.Context, user *User) error {
 if m.CreateFunc != nil {
  return m.CreateFunc(ctx, user)
 }
 return errors.New("not implemented")
}

// 测试
func TestUserService_GetUser(t *testing.T) {
 tests := []struct {
  name    string
  id      string
  mock    *MockUserRepository
  want    *User
  wantErr bool
 }{
  {
   name: "success",
   id:   "123",
   mock: &MockUserRepository{
    GetByIDFunc: func(ctx context.Context, id string) (*User, error) {
     return &User{ID: "123", Name: "John"}, nil
    },
   },
   want:    &User{ID: "123", Name: "John"},
   wantErr: false,
  },
  {
   name:    "empty id",
   id:      "",
   mock:    &MockUserRepository{},
   want:    nil,
   wantErr: true,
  },
  {
   name: "repository error",
   id:   "123",
   mock: &MockUserRepository{
    GetByIDFunc: func(ctx context.Context, id string) (*User, error) {
     return nil, errors.New("database error")
    },
   },
   want:    nil,
   wantErr: true,
  },
 }
 
 for _, tt := range tests {
  t.Run(tt.name, func(t *testing.T) {
   service := NewUserService(tt.mock)
   got, err := service.GetUser(context.Background(), tt.id)
   
   if tt.wantErr {
    assert.Error(t, err)
   } else {
    assert.NoError(t, err)
    assert.Equal(t, tt.want, got)
   }
  })
 }
}
```

### 3.2 使用testify/mock

```go
package service

import (
 "context"
 "testing"
 "github.com/stretchr/testify/mock"
 "github.com/stretchr/testify/assert"
)

// MockUserRepository using testify/mock
type MockUserRepositoryTestify struct {
 mock.Mock
}

func (m *MockUserRepositoryTestify) GetByID(ctx context.Context, id string) (*User, error) {
 args := m.Called(ctx, id)
 if args.Get(0) == nil {
  return nil, args.Error(1)
 }
 return args.Get(0).(*User), args.Error(1)
}

func (m *MockUserRepositoryTestify) Create(ctx context.Context, user *User) error {
 args := m.Called(ctx, user)
 return args.Error(0)
}

func TestUserService_GetUser_WithTestify(t *testing.T) {
 // 创建mock
 mockRepo := new(MockUserRepositoryTestify)
 
 // 设置期望
 expectedUser := &User{ID: "123", Name: "John"}
 mockRepo.On("GetByID", mock.Anything, "123").Return(expectedUser, nil)
 
 // 执行测试
 service := NewUserService(mockRepo)
 user, err := service.GetUser(context.Background(), "123")
 
 // 断言
 assert.NoError(t, err)
 assert.Equal(t, expectedUser, user)
 
 // 验证mock调用
 mockRepo.AssertExpectations(t)
 mockRepo.AssertCalled(t, "GetByID", mock.Anything, "123")
}
```

### 3.3 使用gomock

```go
// 生成mock：mockgen -source=repository.go -destination=mocks/mock_repository.go

package service

import (
 "context"
 "testing"
 "github.com/golang/mock/gomock"
 "github.com/stretchr/testify/assert"
)

func TestUserService_GetUser_WithGomock(t *testing.T) {
 ctrl := gomock.NewController(t)
 defer ctrl.Finish()
 
 // 创建mock
 mockRepo := NewMockUserRepository(ctrl)
 
 // 设置期望
 expectedUser := &User{ID: "123", Name: "John"}
 mockRepo.EXPECT().
  GetByID(gomock.Any(), "123").
  Return(expectedUser, nil).
  Times(1)
 
 // 执行测试
 service := NewUserService(mockRepo)
 user, err := service.GetUser(context.Background(), "123")
 
 // 断言
 assert.NoError(t, err)
 assert.Equal(t, expectedUser, user)
}
```

---

## 4. 集成测试

### 4.1 数据库集成测试（sqlmock）

```go
package repository

import (
 "context"
 "database/sql"
 "testing"
 "github.com/DATA-DOG/go-sqlmock"
 "github.com/stretchr/testify/assert"
)

type UserRepository struct {
 db *sql.DB
}

func (r *UserRepository) GetByID(ctx context.Context, id string) (*User, error) {
 var user User
 err := r.db.QueryRowContext(ctx, "SELECT id, name, email FROM users WHERE id = ?", id).
  Scan(&user.ID, &user.Name, &user.Email)
 if err != nil {
  return nil, err
 }
 return &user, nil
}

func TestUserRepository_GetByID(t *testing.T) {
 // 创建mock数据库
 db, mock, err := sqlmock.New()
 assert.NoError(t, err)
 defer db.Close()
 
 // 设置期望查询
 rows := sqlmock.NewRows([]string{"id", "name", "email"}).
  AddRow("123", "John", "john@example.com")
 
 mock.ExpectQuery("SELECT id, name, email FROM users WHERE id = ?").
  WithArgs("123").
  WillReturnRows(rows)
 
 // 执行测试
 repo := &UserRepository{db: db}
 user, err := repo.GetByID(context.Background(), "123")
 
 // 断言
 assert.NoError(t, err)
 assert.Equal(t, "123", user.ID)
 assert.Equal(t, "John", user.Name)
 assert.Equal(t, "john@example.com", user.Email)
 
 // 验证所有期望都被满足
 assert.NoError(t, mock.ExpectationsWereMet())
}
```

### 4.2 使用testcontainers真实数据库测试

```go
package repository

import (
 "context"
 "database/sql"
 "fmt"
 "testing"
 "github.com/testcontainers/testcontainers-go"
 "github.com/testcontainers/testcontainers-go/wait"
 _ "github.com/lib/pq"
)

func setupTestDB(t *testing.T) (*sql.DB, func()) {
 ctx := context.Background()
 
 // 启动PostgreSQL容器
 req := testcontainers.ContainerRequest{
  Image:        "postgres:16-alpine",
  ExposedPorts: []string{"5432/tcp"},
  Env: map[string]string{
   "POSTGRES_USER":     "test",
   "POSTGRES_PASSWORD": "test",
   "POSTGRES_DB":       "testdb",
  },
  WaitingFor: wait.ForLog("database system is ready to accept connections"),
 }
 
 container, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
  ContainerRequest: req,
  Started:          true,
 })
 if err != nil {
  t.Fatalf("Failed to start container: %v", err)
 }
 
 // 获取容器端口
 host, err := container.Host(ctx)
 if err != nil {
  t.Fatalf("Failed to get container host: %v", err)
 }
 
 port, err := container.MappedPort(ctx, "5432")
 if err != nil {
  t.Fatalf("Failed to get container port: %v", err)
 }
 
 // 连接数据库
 dsn := fmt.Sprintf("host=%s port=%s user=test password=test dbname=testdb sslmode=disable",
  host, port.Port())
 db, err := sql.Open("postgres", dsn)
 if err != nil {
  t.Fatalf("Failed to connect to database: %v", err)
 }
 
 // 初始化表结构
 _, err = db.Exec(`
  CREATE TABLE users (
   id VARCHAR(50) PRIMARY KEY,
   name VARCHAR(100),
   email VARCHAR(100)
  )
 `)
 if err != nil {
  t.Fatalf("Failed to create table: %v", err)
 }
 
 // 返回清理函数
 cleanup := func() {
  db.Close()
  container.Terminate(ctx)
 }
 
 return db, cleanup
}

func TestUserRepository_Integration(t *testing.T) {
 if testing.Short() {
  t.Skip("Skipping integration test")
 }
 
 db, cleanup := setupTestDB(t)
 defer cleanup()
 
 repo := &UserRepository{db: db}
 ctx := context.Background()
 
 // 测试创建用户
 t.Run("Create", func(t *testing.T) {
  user := &User{
   ID:    "123",
   Name:  "John",
   Email: "john@example.com",
  }
  
  err := repo.Create(ctx, user)
  assert.NoError(t, err)
 })
 
 // 测试查询用户
 t.Run("GetByID", func(t *testing.T) {
  user, err := repo.GetByID(ctx, "123")
  assert.NoError(t, err)
  assert.Equal(t, "123", user.ID)
  assert.Equal(t, "John", user.Name)
 })
}

// 运行集成测试：
// go test -v ./... (运行所有测试)
// go test -short ./... (跳过集成测试)
```

---

## 5. E2E测试

### 5.1 HTTP API端到端测试

```go
package e2e

import (
 "bytes"
 "encoding/json"
 "net/http"
 "net/http/httptest"
 "testing"
 "github.com/stretchr/testify/assert"
)

func TestUserAPI_E2E(t *testing.T) {
 // 启动测试服务器
 server := setupTestServer()
 defer server.Close()
 
 client := &http.Client{}
 
 // 测试创建用户
 t.Run("CreateUser", func(t *testing.T) {
  user := map[string]interface{}{
   "name":  "John",
   "email": "john@example.com",
   "age":   30,
  }
  
  body, _ := json.Marshal(user)
  req, _ := http.NewRequest("POST", server.URL+"/users", bytes.NewBuffer(body))
  req.Header.Set("Content-Type", "application/json")
  
  resp, err := client.Do(req)
  assert.NoError(t, err)
  assert.Equal(t, http.StatusCreated, resp.StatusCode)
  
  var result map[string]interface{}
  json.NewDecoder(resp.Body).Decode(&result)
  assert.NotEmpty(t, result["id"])
 })
 
 // 测试获取用户
 t.Run("GetUser", func(t *testing.T) {
  req, _ := http.NewRequest("GET", server.URL+"/users/123", nil)
  
  resp, err := client.Do(req)
  assert.NoError(t, err)
  assert.Equal(t, http.StatusOK, resp.StatusCode)
  
  var user map[string]interface{}
  json.NewDecoder(resp.Body).Decode(&user)
  assert.Equal(t, "John", user["name"])
 })
 
 // 测试更新用户
 t.Run("UpdateUser", func(t *testing.T) {
  update := map[string]interface{}{
   "name": "John Doe",
  }
  
  body, _ := json.Marshal(update)
  req, _ := http.NewRequest("PUT", server.URL+"/users/123", bytes.NewBuffer(body))
  req.Header.Set("Content-Type", "application/json")
  
  resp, err := client.Do(req)
  assert.NoError(t, err)
  assert.Equal(t, http.StatusOK, resp.StatusCode)
 })
 
 // 测试删除用户
 t.Run("DeleteUser", func(t *testing.T) {
  req, _ := http.NewRequest("DELETE", server.URL+"/users/123", nil)
  
  resp, err := client.Do(req)
  assert.NoError(t, err)
  assert.Equal(t, http.StatusNoContent, resp.StatusCode)
 })
}

func setupTestServer() *httptest.Server {
 // 设置完整的测试服务器
 // 包括数据库、Redis等依赖
 return httptest.NewServer(handler)
}
```

---

## 6. 性能测试

### 6.1 基准测试

```go
package performance

import (
 "testing"
)

func BenchmarkStringConcat(b *testing.B) {
 b.ReportAllocs()
 
 for i := 0; i < b.N; i++ {
  s := ""
  for j := 0; j < 100; j++ {
   s += "a"
  }
 }
}

func BenchmarkStringBuilder(b *testing.B) {
 b.ReportAllocs()
 
 for i := 0; i < b.N; i++ {
  var builder strings.Builder
  for j := 0; j < 100; j++ {
   builder.WriteString("a")
  }
  _ = builder.String()
 }
}

// 运行基准测试：
// go test -bench=. -benchmem
// go test -bench=BenchmarkStringBuilder -benchtime=10s
```

### 6.2 并发基准测试

```go
func BenchmarkConcurrentMap(b *testing.B) {
 m := NewSafeMap()
 
 b.RunParallel(func(pb *testing.PB) {
  i := 0
  for pb.Next() {
   key := fmt.Sprintf("key%d", i)
   m.Set(key, i)
   m.Get(key)
   i++
  }
 })
}
```

---

## 7. 测试覆盖率

### 7.1 生成覆盖率报告

```bash
# 生成覆盖率文件
go test -coverprofile=coverage.out ./...

# 查看覆盖率
go tool cover -func=coverage.out

# 生成HTML报告
go tool cover -html=coverage.out -o coverage.html

# 按包查看覆盖率
go test -cover ./...
```

### 7.2 覆盖率配置

```yaml
# .codecov.yml
coverage:
  precision: 2
  round: down
  range: "70...100"
  
  status:
    project:
      default:
        target: 80%
        threshold: 5%
    patch:
      default:
        target: 80%

ignore:
  - "**/*_test.go"
  - "mocks/**"
  - "vendor/**"
```

---

## 8. 测试最佳实践

### 8.1 测试文件组织

```text
myproject/
├── user/
│   ├── user.go
│   ├── user_test.go          # 单元测试
│   ├── user_integration_test.go  # 集成测试
│   └── mocks/
│       └── mock_repository.go
└── e2e/
    └── user_e2e_test.go      # E2E测试
```

### 8.2 测试命名规范

```go
// ✅ 好的命名
func TestUserService_Create_Success(t *testing.T) {}
func TestUserService_Create_InvalidInput(t *testing.T) {}
func TestUserService_Create_DatabaseError(t *testing.T) {}

// ❌ 差的命名
func TestUserService(t *testing.T) {}
func Test1(t *testing.T) {}
```

### 8.3 测试隔离

```go
func TestWithCleanup(t *testing.T) {
 // 设置
 db := setupTestDB(t)
 
 // 注册清理函数
 t.Cleanup(func() {
  cleanupDB(db)
 })
 
 // 测试逻辑
 // ...
}
```

### 8.4 并行测试

```go
func TestParallel(t *testing.T) {
 tests := []struct {
  name string
  // ...
 }{
  // test cases
 }
 
 for _, tt := range tests {
  tt := tt // 捕获循环变量
  t.Run(tt.name, func(t *testing.T) {
   t.Parallel() // 并行执行
   
   // 测试逻辑
  })
 }
}
```

---

## 📚 测试清单

### 单元测试

- ✅ 每个公共函数都有测试
- ✅ 使用表格驱动测试
- ✅ 测试边界条件
- ✅ 测试错误情况
- ✅ 使用Mock隔离依赖

### 集成测试

- ✅ 测试组件间交互
- ✅ 使用真实依赖（数据库等）
- ✅ 使用testcontainers
- ✅ 可以跳过（-short标志）

### E2E测试

- ✅ 测试完整用户场景
- ✅ 测试API端点
- ✅ 测试关键业务流程

### 性能测试

- ✅ 关键路径基准测试
- ✅ 并发基准测试
- ✅ 内存分配分析

---

## 🎯 总结

Go 1.25.3测试工程关键点：

1. **单元测试**: 表格驱动、Mock、断言
2. **集成测试**: sqlmock、testcontainers
3. **E2E测试**: 完整场景、真实环境
4. **性能测试**: 基准测试、并发测试
5. **覆盖率**: 80%+目标、CI集成
6. **最佳实践**: 命名规范、测试隔离、并行执行

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

[📚 返回目录](../README.md) | [📖 下一章](06-Go最佳实践.md)

Made with ❤️ for Go Developers

</div>

---

**文档版本**: v1.0  
**最后更新**: 2025-10-29  
**Go版本**: Go 1.25.3  
**生产就绪**: ✅
