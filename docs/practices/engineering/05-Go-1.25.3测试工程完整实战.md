# Go 1.25.3 æµ‹è¯•å·¥ç¨‹å®Œæ•´å®æˆ˜

**æ–‡æ¡£ç±»å‹**: æµ‹è¯•å·¥ç¨‹æŒ‡å—  
**Goç‰ˆæœ¬**: Go 1.25.3  
**éš¾åº¦ç­‰çº§**: â­â­â­â­ (é«˜çº§)  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ22æ—¥

---


## ğŸ“‹ ç›®å½•


- [ğŸ“– æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
- [ç›®å½•](#ç›®å½•)
- [1. å•å…ƒæµ‹è¯•åŸºç¡€](#1-å•å…ƒæµ‹è¯•åŸºç¡€)
  - [1.1 åŸºç¡€æµ‹è¯•ç»“æ„](#11-åŸºç¡€æµ‹è¯•ç»“æ„)
  - [1.2 ä½¿ç”¨testify/assert](#12-ä½¿ç”¨testifyassert)
  - [1.3 å­æµ‹è¯•ï¼ˆSubtestsï¼‰](#13-å­æµ‹è¯•subtests)
- [2. è¡¨æ ¼é©±åŠ¨æµ‹è¯•](#2-è¡¨æ ¼é©±åŠ¨æµ‹è¯•)
  - [2.1 åŸºç¡€è¡¨æ ¼é©±åŠ¨](#21-åŸºç¡€è¡¨æ ¼é©±åŠ¨)
  - [2.2 å¤æ‚åœºæ™¯è¡¨æ ¼é©±åŠ¨](#22-å¤æ‚åœºæ™¯è¡¨æ ¼é©±åŠ¨)
- [3. Mockä¸æ¡©æµ‹è¯•](#3-mockä¸æ¡©æµ‹è¯•)
  - [3.1 ä½¿ç”¨æ¥å£è¿›è¡ŒMock](#31-ä½¿ç”¨æ¥å£è¿›è¡Œmock)
  - [3.2 ä½¿ç”¨testify/mock](#32-ä½¿ç”¨testifymock)
  - [3.3 ä½¿ç”¨gomock](#33-ä½¿ç”¨gomock)
- [4. é›†æˆæµ‹è¯•](#4-é›†æˆæµ‹è¯•)
  - [4.1 æ•°æ®åº“é›†æˆæµ‹è¯•ï¼ˆsqlmockï¼‰](#41-æ•°æ®åº“é›†æˆæµ‹è¯•sqlmock)
  - [4.2 ä½¿ç”¨testcontainersçœŸå®æ•°æ®åº“æµ‹è¯•](#42-ä½¿ç”¨testcontainersçœŸå®æ•°æ®åº“æµ‹è¯•)
- [5. E2Eæµ‹è¯•](#5-e2eæµ‹è¯•)
  - [5.1 HTTP APIç«¯åˆ°ç«¯æµ‹è¯•](#51-http-apiç«¯åˆ°ç«¯æµ‹è¯•)
- [6. æ€§èƒ½æµ‹è¯•](#6-æ€§èƒ½æµ‹è¯•)
  - [6.1 åŸºå‡†æµ‹è¯•](#61-åŸºå‡†æµ‹è¯•)
  - [6.2 å¹¶å‘åŸºå‡†æµ‹è¯•](#62-å¹¶å‘åŸºå‡†æµ‹è¯•)
- [7. æµ‹è¯•è¦†ç›–ç‡](#7-æµ‹è¯•è¦†ç›–ç‡)
  - [7.1 ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š](#71-ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š)
  - [7.2 è¦†ç›–ç‡é…ç½®](#72-è¦†ç›–ç‡é…ç½®)
- [8. æµ‹è¯•æœ€ä½³å®è·µ](#8-æµ‹è¯•æœ€ä½³å®è·µ)
  - [8.1 æµ‹è¯•æ–‡ä»¶ç»„ç»‡](#81-æµ‹è¯•æ–‡ä»¶ç»„ç»‡)
  - [8.2 æµ‹è¯•å‘½åè§„èŒƒ](#82-æµ‹è¯•å‘½åè§„èŒƒ)
  - [8.3 æµ‹è¯•éš”ç¦»](#83-æµ‹è¯•éš”ç¦»)
  - [8.4 å¹¶è¡Œæµ‹è¯•](#84-å¹¶è¡Œæµ‹è¯•)
- [ğŸ“š æµ‹è¯•æ¸…å•](#-æµ‹è¯•æ¸…å•)
  - [å•å…ƒæµ‹è¯•](#å•å…ƒæµ‹è¯•)
  - [é›†æˆæµ‹è¯•](#é›†æˆæµ‹è¯•)
  - [E2Eæµ‹è¯•](#e2eæµ‹è¯•)
  - [æ€§èƒ½æµ‹è¯•](#æ€§èƒ½æµ‹è¯•)
- [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

## ğŸ“– æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£å±•ç¤ºGo 1.25.3çš„**æµ‹è¯•å·¥ç¨‹å®Œæ•´æ–¹æ¡ˆ**ï¼Œä»å•å…ƒæµ‹è¯•åˆ°E2Eæµ‹è¯•çš„å…¨æ–¹ä½è¦†ç›–ï¼š

- âœ… å•å…ƒæµ‹è¯•æœ€ä½³å®è·µ
- âœ… è¡¨æ ¼é©±åŠ¨æµ‹è¯•
- âœ… Mockä¸æ¡©æµ‹è¯•
- âœ… é›†æˆæµ‹è¯•
- âœ… E2Eç«¯åˆ°ç«¯æµ‹è¯•
- âœ… æ€§èƒ½æµ‹è¯•ä¸åŸºå‡†æµ‹è¯•
- âœ… æµ‹è¯•è¦†ç›–ç‡åˆ†æ

---

## ç›®å½•

- [Go 1.25.3 æµ‹è¯•å·¥ç¨‹å®Œæ•´å®æˆ˜](#go-1253-æµ‹è¯•å·¥ç¨‹å®Œæ•´å®æˆ˜)
  - [ğŸ“– æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. å•å…ƒæµ‹è¯•åŸºç¡€](#1-å•å…ƒæµ‹è¯•åŸºç¡€)
    - [1.1 åŸºç¡€æµ‹è¯•ç»“æ„](#11-åŸºç¡€æµ‹è¯•ç»“æ„)
    - [1.2 ä½¿ç”¨testify/assert](#12-ä½¿ç”¨testifyassert)
    - [1.3 å­æµ‹è¯•ï¼ˆSubtestsï¼‰](#13-å­æµ‹è¯•subtests)
  - [2. è¡¨æ ¼é©±åŠ¨æµ‹è¯•](#2-è¡¨æ ¼é©±åŠ¨æµ‹è¯•)
    - [2.1 åŸºç¡€è¡¨æ ¼é©±åŠ¨](#21-åŸºç¡€è¡¨æ ¼é©±åŠ¨)
    - [2.2 å¤æ‚åœºæ™¯è¡¨æ ¼é©±åŠ¨](#22-å¤æ‚åœºæ™¯è¡¨æ ¼é©±åŠ¨)
  - [3. Mockä¸æ¡©æµ‹è¯•](#3-mockä¸æ¡©æµ‹è¯•)
    - [3.1 ä½¿ç”¨æ¥å£è¿›è¡ŒMock](#31-ä½¿ç”¨æ¥å£è¿›è¡Œmock)
    - [3.2 ä½¿ç”¨testify/mock](#32-ä½¿ç”¨testifymock)
    - [3.3 ä½¿ç”¨gomock](#33-ä½¿ç”¨gomock)
  - [4. é›†æˆæµ‹è¯•](#4-é›†æˆæµ‹è¯•)
    - [4.1 æ•°æ®åº“é›†æˆæµ‹è¯•ï¼ˆsqlmockï¼‰](#41-æ•°æ®åº“é›†æˆæµ‹è¯•sqlmock)
    - [4.2 ä½¿ç”¨testcontainersçœŸå®æ•°æ®åº“æµ‹è¯•](#42-ä½¿ç”¨testcontainersçœŸå®æ•°æ®åº“æµ‹è¯•)
  - [5. E2Eæµ‹è¯•](#5-e2eæµ‹è¯•)
    - [5.1 HTTP APIç«¯åˆ°ç«¯æµ‹è¯•](#51-http-apiç«¯åˆ°ç«¯æµ‹è¯•)
  - [6. æ€§èƒ½æµ‹è¯•](#6-æ€§èƒ½æµ‹è¯•)
    - [6.1 åŸºå‡†æµ‹è¯•](#61-åŸºå‡†æµ‹è¯•)
    - [6.2 å¹¶å‘åŸºå‡†æµ‹è¯•](#62-å¹¶å‘åŸºå‡†æµ‹è¯•)
  - [7. æµ‹è¯•è¦†ç›–ç‡](#7-æµ‹è¯•è¦†ç›–ç‡)
    - [7.1 ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š](#71-ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š)
    - [7.2 è¦†ç›–ç‡é…ç½®](#72-è¦†ç›–ç‡é…ç½®)
  - [8. æµ‹è¯•æœ€ä½³å®è·µ](#8-æµ‹è¯•æœ€ä½³å®è·µ)
    - [8.1 æµ‹è¯•æ–‡ä»¶ç»„ç»‡](#81-æµ‹è¯•æ–‡ä»¶ç»„ç»‡)
    - [8.2 æµ‹è¯•å‘½åè§„èŒƒ](#82-æµ‹è¯•å‘½åè§„èŒƒ)
    - [8.3 æµ‹è¯•éš”ç¦»](#83-æµ‹è¯•éš”ç¦»)
    - [8.4 å¹¶è¡Œæµ‹è¯•](#84-å¹¶è¡Œæµ‹è¯•)
  - [ğŸ“š æµ‹è¯•æ¸…å•](#-æµ‹è¯•æ¸…å•)
    - [å•å…ƒæµ‹è¯•](#å•å…ƒæµ‹è¯•)
    - [é›†æˆæµ‹è¯•](#é›†æˆæµ‹è¯•)
    - [E2Eæµ‹è¯•](#e2eæµ‹è¯•)
    - [æ€§èƒ½æµ‹è¯•](#æ€§èƒ½æµ‹è¯•)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

---

## 1. å•å…ƒæµ‹è¯•åŸºç¡€

### 1.1 åŸºç¡€æµ‹è¯•ç»“æ„

```go
package math

import "testing"

// Add åŠ æ³•å‡½æ•°
func Add(a, b int) int {
 return a + b
}

// TestAdd åŸºç¡€æµ‹è¯•
func TestAdd(t *testing.T) {
 result := Add(2, 3)
 expected := 5
 
 if result != expected {
  t.Errorf("Add(2, 3) = %d; want %d", result, expected)
 }
}

// TestAdd_Negative è´Ÿæ•°æµ‹è¯•
func TestAdd_Negative(t *testing.T) {
 result := Add(-1, -2)
 expected := -3
 
 if result != expected {
  t.Errorf("Add(-1, -2) = %d; want %d", result, expected)
 }
}
```

### 1.2 ä½¿ç”¨testify/assert

```go
package math

import (
 "testing"
 "github.com/stretchr/testify/assert"
)

func TestAddWithAssert(t *testing.T) {
 // åŸºç¡€æ–­è¨€
 assert.Equal(t, 5, Add(2, 3), "2 + 3 should equal 5")
 assert.NotEqual(t, 6, Add(2, 3))
 
 // å¤šä¸ªæ–­è¨€
 assert := assert.New(t)
 assert.Equal(5, Add(2, 3))
 assert.Equal(-3, Add(-1, -2))
 assert.Equal(0, Add(0, 0))
}
```

### 1.3 å­æµ‹è¯•ï¼ˆSubtestsï¼‰

```go
func TestMathOperations(t *testing.T) {
 t.Run("Addition", func(t *testing.T) {
  assert.Equal(t, 5, Add(2, 3))
 })
 
 t.Run("Subtraction", func(t *testing.T) {
  assert.Equal(t, -1, Subtract(2, 3))
 })
 
 t.Run("Multiplication", func(t *testing.T) {
  assert.Equal(t, 6, Multiply(2, 3))
 })
}

// è¿è¡Œç‰¹å®šå­æµ‹è¯•ï¼š
// go test -run TestMathOperations/Addition
```

---

## 2. è¡¨æ ¼é©±åŠ¨æµ‹è¯•

### 2.1 åŸºç¡€è¡¨æ ¼é©±åŠ¨

```go
func TestAdd_TableDriven(t *testing.T) {
 tests := []struct {
  name     string
  a, b     int
  expected int
 }{
  {"positive numbers", 2, 3, 5},
  {"negative numbers", -1, -2, -3},
  {"zero", 0, 0, 0},
  {"positive and negative", 5, -3, 2},
  {"large numbers", 1000000, 2000000, 3000000},
 }
 
 for _, tt := range tests {
  t.Run(tt.name, func(t *testing.T) {
   result := Add(tt.a, tt.b)
   assert.Equal(t, tt.expected, result)
  })
 }
}
```

### 2.2 å¤æ‚åœºæ™¯è¡¨æ ¼é©±åŠ¨

```go
package user

import (
 "errors"
 "testing"
 "github.com/stretchr/testify/assert"
)

type User struct {
 Name  string
 Email string
 Age   int
}

func ValidateUser(u *User) error {
 if u.Name == "" {
  return errors.New("name is required")
 }
 if u.Age < 0 || u.Age > 150 {
  return errors.New("invalid age")
 }
 if u.Email == "" {
  return errors.New("email is required")
 }
 return nil
}

func TestValidateUser(t *testing.T) {
 tests := []struct {
  name    string
  user    *User
  wantErr bool
  errMsg  string
 }{
  {
   name: "valid user",
   user: &User{
    Name:  "John",
    Email: "john@example.com",
    Age:   30,
   },
   wantErr: false,
  },
  {
   name: "missing name",
   user: &User{
    Name:  "",
    Email: "john@example.com",
    Age:   30,
   },
   wantErr: true,
   errMsg:  "name is required",
  },
  {
   name: "invalid age - negative",
   user: &User{
    Name:  "John",
    Email: "john@example.com",
    Age:   -5,
   },
   wantErr: true,
   errMsg:  "invalid age",
  },
  {
   name: "invalid age - too high",
   user: &User{
    Name:  "John",
    Email: "john@example.com",
    Age:   200,
   },
   wantErr: true,
   errMsg:  "invalid age",
  },
  {
   name: "missing email",
   user: &User{
    Name:  "John",
    Email: "",
    Age:   30,
   },
   wantErr: true,
   errMsg:  "email is required",
  },
 }
 
 for _, tt := range tests {
  t.Run(tt.name, func(t *testing.T) {
   err := ValidateUser(tt.user)
   
   if tt.wantErr {
    assert.Error(t, err)
    assert.Contains(t, err.Error(), tt.errMsg)
   } else {
    assert.NoError(t, err)
   }
  })
 }
}
```

---

## 3. Mockä¸æ¡©æµ‹è¯•

### 3.1 ä½¿ç”¨æ¥å£è¿›è¡ŒMock

```go
package service

import (
 "context"
 "errors"
)

// UserRepository ç”¨æˆ·ä»“åº“æ¥å£
type UserRepository interface {
 GetByID(ctx context.Context, id string) (*User, error)
 Create(ctx context.Context, user *User) error
}

// UserService ç”¨æˆ·æœåŠ¡
type UserService struct {
 repo UserRepository
}

func NewUserService(repo UserRepository) *UserService {
 return &UserService{repo: repo}
}

func (s *UserService) GetUser(ctx context.Context, id string) (*User, error) {
 if id == "" {
  return nil, errors.New("id is required")
 }
 
 return s.repo.GetByID(ctx, id)
}

// Mockå®ç°
type MockUserRepository struct {
 GetByIDFunc func(ctx context.Context, id string) (*User, error)
 CreateFunc  func(ctx context.Context, user *User) error
}

func (m *MockUserRepository) GetByID(ctx context.Context, id string) (*User, error) {
 if m.GetByIDFunc != nil {
  return m.GetByIDFunc(ctx, id)
 }
 return nil, errors.New("not implemented")
}

func (m *MockUserRepository) Create(ctx context.Context, user *User) error {
 if m.CreateFunc != nil {
  return m.CreateFunc(ctx, user)
 }
 return errors.New("not implemented")
}

// æµ‹è¯•
func TestUserService_GetUser(t *testing.T) {
 tests := []struct {
  name    string
  id      string
  mock    *MockUserRepository
  want    *User
  wantErr bool
 }{
  {
   name: "success",
   id:   "123",
   mock: &MockUserRepository{
    GetByIDFunc: func(ctx context.Context, id string) (*User, error) {
     return &User{ID: "123", Name: "John"}, nil
    },
   },
   want:    &User{ID: "123", Name: "John"},
   wantErr: false,
  },
  {
   name:    "empty id",
   id:      "",
   mock:    &MockUserRepository{},
   want:    nil,
   wantErr: true,
  },
  {
   name: "repository error",
   id:   "123",
   mock: &MockUserRepository{
    GetByIDFunc: func(ctx context.Context, id string) (*User, error) {
     return nil, errors.New("database error")
    },
   },
   want:    nil,
   wantErr: true,
  },
 }
 
 for _, tt := range tests {
  t.Run(tt.name, func(t *testing.T) {
   service := NewUserService(tt.mock)
   got, err := service.GetUser(context.Background(), tt.id)
   
   if tt.wantErr {
    assert.Error(t, err)
   } else {
    assert.NoError(t, err)
    assert.Equal(t, tt.want, got)
   }
  })
 }
}
```

### 3.2 ä½¿ç”¨testify/mock

```go
package service

import (
 "context"
 "testing"
 "github.com/stretchr/testify/mock"
 "github.com/stretchr/testify/assert"
)

// MockUserRepository using testify/mock
type MockUserRepositoryTestify struct {
 mock.Mock
}

func (m *MockUserRepositoryTestify) GetByID(ctx context.Context, id string) (*User, error) {
 args := m.Called(ctx, id)
 if args.Get(0) == nil {
  return nil, args.Error(1)
 }
 return args.Get(0).(*User), args.Error(1)
}

func (m *MockUserRepositoryTestify) Create(ctx context.Context, user *User) error {
 args := m.Called(ctx, user)
 return args.Error(0)
}

func TestUserService_GetUser_WithTestify(t *testing.T) {
 // åˆ›å»ºmock
 mockRepo := new(MockUserRepositoryTestify)
 
 // è®¾ç½®æœŸæœ›
 expectedUser := &User{ID: "123", Name: "John"}
 mockRepo.On("GetByID", mock.Anything, "123").Return(expectedUser, nil)
 
 // æ‰§è¡Œæµ‹è¯•
 service := NewUserService(mockRepo)
 user, err := service.GetUser(context.Background(), "123")
 
 // æ–­è¨€
 assert.NoError(t, err)
 assert.Equal(t, expectedUser, user)
 
 // éªŒè¯mockè°ƒç”¨
 mockRepo.AssertExpectations(t)
 mockRepo.AssertCalled(t, "GetByID", mock.Anything, "123")
}
```

### 3.3 ä½¿ç”¨gomock

```go
// ç”Ÿæˆmockï¼šmockgen -source=repository.go -destination=mocks/mock_repository.go

package service

import (
 "context"
 "testing"
 "github.com/golang/mock/gomock"
 "github.com/stretchr/testify/assert"
)

func TestUserService_GetUser_WithGomock(t *testing.T) {
 ctrl := gomock.NewController(t)
 defer ctrl.Finish()
 
 // åˆ›å»ºmock
 mockRepo := NewMockUserRepository(ctrl)
 
 // è®¾ç½®æœŸæœ›
 expectedUser := &User{ID: "123", Name: "John"}
 mockRepo.EXPECT().
  GetByID(gomock.Any(), "123").
  Return(expectedUser, nil).
  Times(1)
 
 // æ‰§è¡Œæµ‹è¯•
 service := NewUserService(mockRepo)
 user, err := service.GetUser(context.Background(), "123")
 
 // æ–­è¨€
 assert.NoError(t, err)
 assert.Equal(t, expectedUser, user)
}
```

---

## 4. é›†æˆæµ‹è¯•

### 4.1 æ•°æ®åº“é›†æˆæµ‹è¯•ï¼ˆsqlmockï¼‰

```go
package repository

import (
 "context"
 "database/sql"
 "testing"
 "github.com/DATA-DOG/go-sqlmock"
 "github.com/stretchr/testify/assert"
)

type UserRepository struct {
 db *sql.DB
}

func (r *UserRepository) GetByID(ctx context.Context, id string) (*User, error) {
 var user User
 err := r.db.QueryRowContext(ctx, "SELECT id, name, email FROM users WHERE id = ?", id).
  Scan(&user.ID, &user.Name, &user.Email)
 if err != nil {
  return nil, err
 }
 return &user, nil
}

func TestUserRepository_GetByID(t *testing.T) {
 // åˆ›å»ºmockæ•°æ®åº“
 db, mock, err := sqlmock.New()
 assert.NoError(t, err)
 defer db.Close()
 
 // è®¾ç½®æœŸæœ›æŸ¥è¯¢
 rows := sqlmock.NewRows([]string{"id", "name", "email"}).
  AddRow("123", "John", "john@example.com")
 
 mock.ExpectQuery("SELECT id, name, email FROM users WHERE id = ?").
  WithArgs("123").
  WillReturnRows(rows)
 
 // æ‰§è¡Œæµ‹è¯•
 repo := &UserRepository{db: db}
 user, err := repo.GetByID(context.Background(), "123")
 
 // æ–­è¨€
 assert.NoError(t, err)
 assert.Equal(t, "123", user.ID)
 assert.Equal(t, "John", user.Name)
 assert.Equal(t, "john@example.com", user.Email)
 
 // éªŒè¯æ‰€æœ‰æœŸæœ›éƒ½è¢«æ»¡è¶³
 assert.NoError(t, mock.ExpectationsWereMet())
}
```

### 4.2 ä½¿ç”¨testcontainersçœŸå®æ•°æ®åº“æµ‹è¯•

```go
package repository

import (
 "context"
 "database/sql"
 "fmt"
 "testing"
 "github.com/testcontainers/testcontainers-go"
 "github.com/testcontainers/testcontainers-go/wait"
 _ "github.com/lib/pq"
)

func setupTestDB(t *testing.T) (*sql.DB, func()) {
 ctx := context.Background()
 
 // å¯åŠ¨PostgreSQLå®¹å™¨
 req := testcontainers.ContainerRequest{
  Image:        "postgres:16-alpine",
  ExposedPorts: []string{"5432/tcp"},
  Env: map[string]string{
   "POSTGRES_USER":     "test",
   "POSTGRES_PASSWORD": "test",
   "POSTGRES_DB":       "testdb",
  },
  WaitingFor: wait.ForLog("database system is ready to accept connections"),
 }
 
 container, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
  ContainerRequest: req,
  Started:          true,
 })
 if err != nil {
  t.Fatalf("Failed to start container: %v", err)
 }
 
 // è·å–å®¹å™¨ç«¯å£
 host, err := container.Host(ctx)
 if err != nil {
  t.Fatalf("Failed to get container host: %v", err)
 }
 
 port, err := container.MappedPort(ctx, "5432")
 if err != nil {
  t.Fatalf("Failed to get container port: %v", err)
 }
 
 // è¿æ¥æ•°æ®åº“
 dsn := fmt.Sprintf("host=%s port=%s user=test password=test dbname=testdb sslmode=disable",
  host, port.Port())
 db, err := sql.Open("postgres", dsn)
 if err != nil {
  t.Fatalf("Failed to connect to database: %v", err)
 }
 
 // åˆå§‹åŒ–è¡¨ç»“æ„
 _, err = db.Exec(`
  CREATE TABLE users (
   id VARCHAR(50) PRIMARY KEY,
   name VARCHAR(100),
   email VARCHAR(100)
  )
 `)
 if err != nil {
  t.Fatalf("Failed to create table: %v", err)
 }
 
 // è¿”å›æ¸…ç†å‡½æ•°
 cleanup := func() {
  db.Close()
  container.Terminate(ctx)
 }
 
 return db, cleanup
}

func TestUserRepository_Integration(t *testing.T) {
 if testing.Short() {
  t.Skip("Skipping integration test")
 }
 
 db, cleanup := setupTestDB(t)
 defer cleanup()
 
 repo := &UserRepository{db: db}
 ctx := context.Background()
 
 // æµ‹è¯•åˆ›å»ºç”¨æˆ·
 t.Run("Create", func(t *testing.T) {
  user := &User{
   ID:    "123",
   Name:  "John",
   Email: "john@example.com",
  }
  
  err := repo.Create(ctx, user)
  assert.NoError(t, err)
 })
 
 // æµ‹è¯•æŸ¥è¯¢ç”¨æˆ·
 t.Run("GetByID", func(t *testing.T) {
  user, err := repo.GetByID(ctx, "123")
  assert.NoError(t, err)
  assert.Equal(t, "123", user.ID)
  assert.Equal(t, "John", user.Name)
 })
}

// è¿è¡Œé›†æˆæµ‹è¯•ï¼š
// go test -v ./... (è¿è¡Œæ‰€æœ‰æµ‹è¯•)
// go test -short ./... (è·³è¿‡é›†æˆæµ‹è¯•)
```

---

## 5. E2Eæµ‹è¯•

### 5.1 HTTP APIç«¯åˆ°ç«¯æµ‹è¯•

```go
package e2e

import (
 "bytes"
 "encoding/json"
 "net/http"
 "net/http/httptest"
 "testing"
 "github.com/stretchr/testify/assert"
)

func TestUserAPI_E2E(t *testing.T) {
 // å¯åŠ¨æµ‹è¯•æœåŠ¡å™¨
 server := setupTestServer()
 defer server.Close()
 
 client := &http.Client{}
 
 // æµ‹è¯•åˆ›å»ºç”¨æˆ·
 t.Run("CreateUser", func(t *testing.T) {
  user := map[string]interface{}{
   "name":  "John",
   "email": "john@example.com",
   "age":   30,
  }
  
  body, _ := json.Marshal(user)
  req, _ := http.NewRequest("POST", server.URL+"/users", bytes.NewBuffer(body))
  req.Header.Set("Content-Type", "application/json")
  
  resp, err := client.Do(req)
  assert.NoError(t, err)
  assert.Equal(t, http.StatusCreated, resp.StatusCode)
  
  var result map[string]interface{}
  json.NewDecoder(resp.Body).Decode(&result)
  assert.NotEmpty(t, result["id"])
 })
 
 // æµ‹è¯•è·å–ç”¨æˆ·
 t.Run("GetUser", func(t *testing.T) {
  req, _ := http.NewRequest("GET", server.URL+"/users/123", nil)
  
  resp, err := client.Do(req)
  assert.NoError(t, err)
  assert.Equal(t, http.StatusOK, resp.StatusCode)
  
  var user map[string]interface{}
  json.NewDecoder(resp.Body).Decode(&user)
  assert.Equal(t, "John", user["name"])
 })
 
 // æµ‹è¯•æ›´æ–°ç”¨æˆ·
 t.Run("UpdateUser", func(t *testing.T) {
  update := map[string]interface{}{
   "name": "John Doe",
  }
  
  body, _ := json.Marshal(update)
  req, _ := http.NewRequest("PUT", server.URL+"/users/123", bytes.NewBuffer(body))
  req.Header.Set("Content-Type", "application/json")
  
  resp, err := client.Do(req)
  assert.NoError(t, err)
  assert.Equal(t, http.StatusOK, resp.StatusCode)
 })
 
 // æµ‹è¯•åˆ é™¤ç”¨æˆ·
 t.Run("DeleteUser", func(t *testing.T) {
  req, _ := http.NewRequest("DELETE", server.URL+"/users/123", nil)
  
  resp, err := client.Do(req)
  assert.NoError(t, err)
  assert.Equal(t, http.StatusNoContent, resp.StatusCode)
 })
}

func setupTestServer() *httptest.Server {
 // è®¾ç½®å®Œæ•´çš„æµ‹è¯•æœåŠ¡å™¨
 // åŒ…æ‹¬æ•°æ®åº“ã€Redisç­‰ä¾èµ–
 return httptest.NewServer(handler)
}
```

---

## 6. æ€§èƒ½æµ‹è¯•

### 6.1 åŸºå‡†æµ‹è¯•

```go
package performance

import (
 "testing"
)

func BenchmarkStringConcat(b *testing.B) {
 b.ReportAllocs()
 
 for i := 0; i < b.N; i++ {
  s := ""
  for j := 0; j < 100; j++ {
   s += "a"
  }
 }
}

func BenchmarkStringBuilder(b *testing.B) {
 b.ReportAllocs()
 
 for i := 0; i < b.N; i++ {
  var builder strings.Builder
  for j := 0; j < 100; j++ {
   builder.WriteString("a")
  }
  _ = builder.String()
 }
}

// è¿è¡ŒåŸºå‡†æµ‹è¯•ï¼š
// go test -bench=. -benchmem
// go test -bench=BenchmarkStringBuilder -benchtime=10s
```

### 6.2 å¹¶å‘åŸºå‡†æµ‹è¯•

```go
func BenchmarkConcurrentMap(b *testing.B) {
 m := NewSafeMap()
 
 b.RunParallel(func(pb *testing.PB) {
  i := 0
  for pb.Next() {
   key := fmt.Sprintf("key%d", i)
   m.Set(key, i)
   m.Get(key)
   i++
  }
 })
}
```

---

## 7. æµ‹è¯•è¦†ç›–ç‡

### 7.1 ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š

```bash
# ç”Ÿæˆè¦†ç›–ç‡æ–‡ä»¶
go test -coverprofile=coverage.out ./...

# æŸ¥çœ‹è¦†ç›–ç‡
go tool cover -func=coverage.out

# ç”ŸæˆHTMLæŠ¥å‘Š
go tool cover -html=coverage.out -o coverage.html

# æŒ‰åŒ…æŸ¥çœ‹è¦†ç›–ç‡
go test -cover ./...
```

### 7.2 è¦†ç›–ç‡é…ç½®

```yaml
# .codecov.yml
coverage:
  precision: 2
  round: down
  range: "70...100"
  
  status:
    project:
      default:
        target: 80%
        threshold: 5%
    patch:
      default:
        target: 80%

ignore:
  - "**/*_test.go"
  - "mocks/**"
  - "vendor/**"
```

---

## 8. æµ‹è¯•æœ€ä½³å®è·µ

### 8.1 æµ‹è¯•æ–‡ä»¶ç»„ç»‡

```text
myproject/
â”œâ”€â”€ user/
â”‚   â”œâ”€â”€ user.go
â”‚   â”œâ”€â”€ user_test.go          # å•å…ƒæµ‹è¯•
â”‚   â”œâ”€â”€ user_integration_test.go  # é›†æˆæµ‹è¯•
â”‚   â””â”€â”€ mocks/
â”‚       â””â”€â”€ mock_repository.go
â””â”€â”€ e2e/
    â””â”€â”€ user_e2e_test.go      # E2Eæµ‹è¯•
```

### 8.2 æµ‹è¯•å‘½åè§„èŒƒ

```go
// âœ… å¥½çš„å‘½å
func TestUserService_Create_Success(t *testing.T) {}
func TestUserService_Create_InvalidInput(t *testing.T) {}
func TestUserService_Create_DatabaseError(t *testing.T) {}

// âŒ å·®çš„å‘½å
func TestUserService(t *testing.T) {}
func Test1(t *testing.T) {}
```

### 8.3 æµ‹è¯•éš”ç¦»

```go
func TestWithCleanup(t *testing.T) {
 // è®¾ç½®
 db := setupTestDB(t)
 
 // æ³¨å†Œæ¸…ç†å‡½æ•°
 t.Cleanup(func() {
  cleanupDB(db)
 })
 
 // æµ‹è¯•é€»è¾‘
 // ...
}
```

### 8.4 å¹¶è¡Œæµ‹è¯•

```go
func TestParallel(t *testing.T) {
 tests := []struct {
  name string
  // ...
 }{
  // test cases
 }
 
 for _, tt := range tests {
  tt := tt // æ•è·å¾ªç¯å˜é‡
  t.Run(tt.name, func(t *testing.T) {
   t.Parallel() // å¹¶è¡Œæ‰§è¡Œ
   
   // æµ‹è¯•é€»è¾‘
  })
 }
}
```

---

## ğŸ“š æµ‹è¯•æ¸…å•

### å•å…ƒæµ‹è¯•

- âœ… æ¯ä¸ªå…¬å…±å‡½æ•°éƒ½æœ‰æµ‹è¯•
- âœ… ä½¿ç”¨è¡¨æ ¼é©±åŠ¨æµ‹è¯•
- âœ… æµ‹è¯•è¾¹ç•Œæ¡ä»¶
- âœ… æµ‹è¯•é”™è¯¯æƒ…å†µ
- âœ… ä½¿ç”¨Mockéš”ç¦»ä¾èµ–

### é›†æˆæµ‹è¯•

- âœ… æµ‹è¯•ç»„ä»¶é—´äº¤äº’
- âœ… ä½¿ç”¨çœŸå®ä¾èµ–ï¼ˆæ•°æ®åº“ç­‰ï¼‰
- âœ… ä½¿ç”¨testcontainers
- âœ… å¯ä»¥è·³è¿‡ï¼ˆ-shortæ ‡å¿—ï¼‰

### E2Eæµ‹è¯•

- âœ… æµ‹è¯•å®Œæ•´ç”¨æˆ·åœºæ™¯
- âœ… æµ‹è¯•APIç«¯ç‚¹
- âœ… æµ‹è¯•å…³é”®ä¸šåŠ¡æµç¨‹

### æ€§èƒ½æµ‹è¯•

- âœ… å…³é”®è·¯å¾„åŸºå‡†æµ‹è¯•
- âœ… å¹¶å‘åŸºå‡†æµ‹è¯•
- âœ… å†…å­˜åˆ†é…åˆ†æ

---

## ğŸ¯ æ€»ç»“

Go 1.25.3æµ‹è¯•å·¥ç¨‹å…³é”®ç‚¹ï¼š

1. **å•å…ƒæµ‹è¯•**: è¡¨æ ¼é©±åŠ¨ã€Mockã€æ–­è¨€
2. **é›†æˆæµ‹è¯•**: sqlmockã€testcontainers
3. **E2Eæµ‹è¯•**: å®Œæ•´åœºæ™¯ã€çœŸå®ç¯å¢ƒ
4. **æ€§èƒ½æµ‹è¯•**: åŸºå‡†æµ‹è¯•ã€å¹¶å‘æµ‹è¯•
5. **è¦†ç›–ç‡**: 80%+ç›®æ ‡ã€CIé›†æˆ
6. **æœ€ä½³å®è·µ**: å‘½åè§„èŒƒã€æµ‹è¯•éš”ç¦»ã€å¹¶è¡Œæ‰§è¡Œ

**é«˜è´¨é‡æµ‹è¯•=é«˜è´¨é‡ä»£ç ï¼**

---

<div align="center">

**æŒæ¡æµ‹è¯•å·¥ç¨‹ï¼Œæ„å»ºå¯é ç³»ç»Ÿ**:

[ğŸ“š è¿”å›ç›®å½•](../README.md) | [ğŸ“– ä¸‹ä¸€ç« ](06-Goæœ€ä½³å®è·µ.md)

Made with â¤ï¸ for Go Developers

</div>

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-10-22  
**Goç‰ˆæœ¬**: Go 1.25.3  
**ç”Ÿäº§å°±ç»ª**: âœ…
