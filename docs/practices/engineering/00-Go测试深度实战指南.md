# Goæµ‹è¯•

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.23+

---

**å­—æ•°**: ~30,000å­—
**ä»£ç ç¤ºä¾‹**: 80+ä¸ªå®Œæ•´ç¤ºä¾‹
**å®æˆ˜æ¡ˆä¾‹**: 9ä¸ªç«¯åˆ°ç«¯æ¡ˆä¾‹
**é€‚ç”¨äººç¾¤**: åˆçº§åˆ°é«˜çº§Goå¼€å‘è€…

---

## ğŸ“‹ ç›®å½•

- [ç¬¬ä¸€éƒ¨åˆ†ï¼šå•å…ƒæµ‹è¯•åŸºç¡€](#ç¬¬ä¸€éƒ¨åˆ†å•å…ƒæµ‹è¯•åŸºç¡€)
  - [ä¸ºä»€ä¹ˆè¦å†™æµ‹è¯•ï¼Ÿ](#ä¸ºä»€ä¹ˆè¦å†™æµ‹è¯•)
  - [Goæµ‹è¯•æ ¸å¿ƒæ¦‚å¿µ](#goæµ‹è¯•æ ¸å¿ƒæ¦‚å¿µ)
  - [å®æˆ˜æ¡ˆä¾‹1ï¼šå•å…ƒæµ‹è¯•å®Œæ•´ç¤ºä¾‹](#å®æˆ˜æ¡ˆä¾‹1å•å…ƒæµ‹è¯•å®Œæ•´ç¤ºä¾‹)
- [ç¬¬äºŒéƒ¨åˆ†ï¼šè¡¨é©±åŠ¨æµ‹è¯•æ·±åº¦å®æˆ˜](#ç¬¬äºŒéƒ¨åˆ†è¡¨é©±åŠ¨æµ‹è¯•æ·±åº¦å®æˆ˜)
  - [ä»€ä¹ˆæ˜¯è¡¨é©±åŠ¨æµ‹è¯•ï¼Ÿ](#ä»€ä¹ˆæ˜¯è¡¨é©±åŠ¨æµ‹è¯•)
  - [å®æˆ˜æ¡ˆä¾‹2ï¼šè¡¨é©±åŠ¨æµ‹è¯•å®Œæ•´ç¤ºä¾‹](#å®æˆ˜æ¡ˆä¾‹2è¡¨é©±åŠ¨æµ‹è¯•å®Œæ•´ç¤ºä¾‹)
- [ç¬¬ä¸‰éƒ¨åˆ†ï¼šMockä¸ä¾èµ–æ³¨å…¥](#ç¬¬ä¸‰éƒ¨åˆ†mockä¸ä¾èµ–æ³¨å…¥)
  - [ä¸ºä»€ä¹ˆéœ€è¦Mockï¼Ÿ](#ä¸ºä»€ä¹ˆéœ€è¦mock)
  - [å®æˆ˜æ¡ˆä¾‹3ï¼šæ¥å£ä¸Mock](#å®æˆ˜æ¡ˆä¾‹3æ¥å£ä¸mock)
  - [ä½¿ç”¨gomockï¼ˆæ¨èï¼‰](#ä½¿ç”¨gomockæ¨è)
- [ç¬¬å››éƒ¨åˆ†ï¼šé›†æˆæµ‹è¯•æ·±åº¦å®æˆ˜](#ç¬¬å››éƒ¨åˆ†é›†æˆæµ‹è¯•æ·±åº¦å®æˆ˜)
  - [ä»€ä¹ˆæ˜¯é›†æˆæµ‹è¯•ï¼Ÿ](#ä»€ä¹ˆæ˜¯é›†æˆæµ‹è¯•)
  - [å®æˆ˜æ¡ˆä¾‹4ï¼šæ•°æ®åº“é›†æˆæµ‹è¯•](#å®æˆ˜æ¡ˆä¾‹4æ•°æ®åº“é›†æˆæµ‹è¯•)
- [ç¬¬äº”éƒ¨åˆ†ï¼šBenchmarkæ·±åº¦å®æˆ˜](#ç¬¬äº”éƒ¨åˆ†benchmarkæ·±åº¦å®æˆ˜)
  - [ä¸ºä»€ä¹ˆè¦å†™Benchmarkï¼Ÿ](#ä¸ºä»€ä¹ˆè¦å†™benchmark)
  - [å®æˆ˜æ¡ˆä¾‹5ï¼šBenchmarkå®Œæ•´ç¤ºä¾‹](#å®æˆ˜æ¡ˆä¾‹5benchmarkå®Œæ•´ç¤ºä¾‹)
- [ç¬¬å…­éƒ¨åˆ†ï¼šæµ‹è¯•è¦†ç›–ç‡ä¸åˆ†æ](#ç¬¬å…­éƒ¨åˆ†æµ‹è¯•è¦†ç›–ç‡ä¸åˆ†æ)
  - [ä»€ä¹ˆæ˜¯æµ‹è¯•è¦†ç›–ç‡ï¼Ÿ](#ä»€ä¹ˆæ˜¯æµ‹è¯•è¦†ç›–ç‡)
  - [å®æˆ˜æ¡ˆä¾‹6ï¼šæµ‹è¯•è¦†ç›–ç‡åˆ†æ](#å®æˆ˜æ¡ˆä¾‹6æµ‹è¯•è¦†ç›–ç‡åˆ†æ)
- [ç¬¬ä¸ƒéƒ¨åˆ†ï¼šHTTPæµ‹è¯•æœ€ä½³å®è·µ](#ç¬¬ä¸ƒéƒ¨åˆ†httpæµ‹è¯•æœ€ä½³å®è·µ)
  - [å®æˆ˜æ¡ˆä¾‹7ï¼šHTTP Handleræµ‹è¯•](#å®æˆ˜æ¡ˆä¾‹7http-handleræµ‹è¯•)
- [ç¬¬å…«éƒ¨åˆ†ï¼šæ•°æ®åº“æµ‹è¯•æœ€ä½³å®è·µ](#ç¬¬å…«éƒ¨åˆ†æ•°æ®åº“æµ‹è¯•æœ€ä½³å®è·µ)
  - [å®æˆ˜æ¡ˆä¾‹8ï¼šæ•°æ®åº“æµ‹è¯•ç­–ç•¥](#å®æˆ˜æ¡ˆä¾‹8æ•°æ®åº“æµ‹è¯•ç­–ç•¥)
- [ç¬¬ä¹éƒ¨åˆ†ï¼šå®Œæ•´é¡¹ç›®æµ‹è¯•](#ç¬¬ä¹éƒ¨åˆ†å®Œæ•´é¡¹ç›®æµ‹è¯•)
  - [é¡¹ç›®ç»“æ„](#é¡¹ç›®ç»“æ„)
  - [Makefileæµ‹è¯•å‘½ä»¤](#makefileæµ‹è¯•å‘½ä»¤)
- [ğŸ¯ æ€»ç»“](#æ€»ç»“)
  - [æµ‹è¯•æ ¸å¿ƒè¦ç‚¹](#æµ‹è¯•æ ¸å¿ƒè¦ç‚¹)
  - [æœ€ä½³å®è·µæ¸…å•](#æœ€ä½³å®è·µæ¸…å•)
  - [æµ‹è¯•é‡‘å­—å¡”](#æµ‹è¯•é‡‘å­—å¡”)

## ç¬¬ä¸€éƒ¨åˆ†ï¼šå•å…ƒæµ‹è¯•åŸºç¡€

### ä¸ºä»€ä¹ˆè¦å†™æµ‹è¯•ï¼Ÿ

```text
âœ… è´¨é‡ä¿è¯ - åŠæ—©å‘ç°Bug
âœ… é‡æ„ä¿¡å¿ƒ - å®‰å…¨é‡æ„ä»£ç 
âœ… æ–‡æ¡£ä½œç”¨ - ä»£ç å³æ–‡æ¡£
âœ… è®¾è®¡æ”¹è¿› - ä¿ƒè¿›æ¨¡å—åŒ–è®¾è®¡
âœ… å›å½’æµ‹è¯• - é˜²æ­¢åŠŸèƒ½é€€åŒ–
```

---

### Goæµ‹è¯•æ ¸å¿ƒæ¦‚å¿µ

| æ¦‚å¿µ | è¯´æ˜ | ç¤ºä¾‹ |
|------|------|------|
| **æµ‹è¯•æ–‡ä»¶** | `*_test.go` | `user_test.go` |
| **æµ‹è¯•å‡½æ•°** | `Test*` | `TestCreateUser` |
| **åŸºå‡†æµ‹è¯•** | `Benchmark*` | `BenchmarkQuery` |
| **ç¤ºä¾‹æµ‹è¯•** | `Example*` | `ExampleAdd` |
| **t.Run** | å­æµ‹è¯• | åˆ†ç»„è¿è¡Œ |
| **t.Parallel** | å¹¶å‘æµ‹è¯• | æå‡é€Ÿåº¦ |

---

### å®æˆ˜æ¡ˆä¾‹1ï¼šå•å…ƒæµ‹è¯•å®Œæ•´ç¤ºä¾‹

```go
// calculator.go
package calculator

import "errors"

func Add(a, b int) int {
    return a + b
}

func Divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

type Calculator struct {
    memory float64
}

func (c *Calculator) Add(value float64) {
    c.memory += value
}

func (c *Calculator) Get() float64 {
    return c.memory
}

func (c *Calculator) Clear() {
    c.memory = 0
}
```

```go
// calculator_test.go
package calculator

import (
    "testing"
)

// TestAdd æµ‹è¯•Addå‡½æ•°
func TestAdd(t *testing.T) {
    got := Add(2, 3)
    want := 5

    if got != want {
        t.Errorf("Add(2, 3) = %d; want %d", got, want)
    }
}

// TestDivide æµ‹è¯•Divideå‡½æ•°
func TestDivide(t *testing.T) {
    // æµ‹è¯•æ­£å¸¸æƒ…å†µ
    t.Run("normal case", func(t *testing.T) {
        got, err := Divide(10, 2)
        if err != nil {
            t.Fatalf("unexpected error: %v", err)
        }

        want := 5.0
        if got != want {
            t.Errorf("Divide(10, 2) = %f; want %f", got, want)
        }
    })

    // æµ‹è¯•é™¤é›¶é”™è¯¯
    t.Run("division by zero", func(t *testing.T) {
        _, err := Divide(10, 0)
        if err == nil {
            t.Error("expected error, got nil")
        }

        expectedMsg := "division by zero"
        if err.Error() != expectedMsg {
            t.Errorf("error message = %q; want %q", err.Error(), expectedMsg)
        }
    })
}

// TestCalculator æµ‹è¯•Calculatorç»“æ„ä½“
func TestCalculator(t *testing.T) {
    calc := &Calculator{}

    // æµ‹è¯•åˆå§‹å€¼
    if got := calc.Get(); got != 0 {
        t.Errorf("initial value = %f; want 0", got)
    }

    // æµ‹è¯•Add
    calc.Add(10)
    calc.Add(5)

    if got := calc.Get(); got != 15 {
        t.Errorf("after adding 10 and 5, value = %f; want 15", got)
    }

    // æµ‹è¯•Clear
    calc.Clear()
    if got := calc.Get(); got != 0 {
        t.Errorf("after clear, value = %f; want 0", got)
    }
}

// æµ‹è¯•è¾…åŠ©å‡½æ•°
func assertEqual(t *testing.T, got, want interface{}) {
    t.Helper() // æ ‡è®°ä¸ºè¾…åŠ©å‡½æ•°ï¼Œé”™è¯¯ä¼šæŠ¥å‘Šåˆ°è°ƒç”¨å¤„

    if got != want {
        t.Errorf("got %v; want %v", got, want)
    }
}

func TestWithHelper(t *testing.T) {
    result := Add(2, 3)
    assertEqual(t, result, 5) // å¦‚æœå¤±è´¥ï¼Œä¼šæŠ¥å‘Šåˆ°è¿™ä¸€è¡Œ
}
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šè¡¨é©±åŠ¨æµ‹è¯•æ·±åº¦å®æˆ˜

### ä»€ä¹ˆæ˜¯è¡¨é©±åŠ¨æµ‹è¯•ï¼Ÿ

**è¡¨é©±åŠ¨æµ‹è¯•ï¼ˆTable-Driven Testï¼‰**æ˜¯Goç¤¾åŒºæ¨èçš„æµ‹è¯•æ¨¡å¼ï¼š

- å°†æµ‹è¯•ç”¨ä¾‹ç»„ç»‡æˆè¡¨æ ¼ï¼ˆslice of structsï¼‰
- å¾ªç¯éå†æ‰§è¡Œ
- æ˜“äºæ·»åŠ æ–°ç”¨ä¾‹
- ç»“æ„æ¸…æ™°

---

### å®æˆ˜æ¡ˆä¾‹2ï¼šè¡¨é©±åŠ¨æµ‹è¯•å®Œæ•´ç¤ºä¾‹

```go
// string_utils.go
package stringutils

import (
    "strings"
    "unicode"
)

func IsPalindrome(s string) bool {
    s = strings.ToLower(s)
    var letters []rune
    for _, r := range s {
        if unicode.IsLetter(r) {
            letters = append(letters, r)
        }
    }

    for i := 0; i < len(letters)/2; i++ {
        if letters[i] != letters[len(letters)-1-i] {
            return false
        }
    }

    return true
}

func Reverse(s string) string {
    runes := []rune(s)
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}
```

```go
// string_utils_test.go
package stringutils

import "testing"

func TestIsPalindrome(t *testing.T) {
    tests := []struct {
        name string
        input string
        want bool
    }{
        {"empty string", "", true},
        {"single character", "a", true},
        {"simple palindrome", "racecar", true},
        {"palindrome with spaces", "race car", true},
        {"palindrome with punctuation", "A man, a plan, a canal: Panama", true},
        {"not palindrome", "hello", false},
        {"case insensitive", "RaceCar", true},
        {"numbers", "12321", false}, // åªè€ƒè™‘å­—æ¯
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := IsPalindrome(tt.input)
            if got != tt.want {
                t.Errorf("IsPalindrome(%q) = %v; want %v",
                    tt.input, got, tt.want)
            }
        })
    }
}

func TestReverse(t *testing.T) {
    tests := []struct {
        name string
        input string
        want string
    }{
        {"empty", "", ""},
        {"single", "a", "a"},
        {"simple", "hello", "olleh"},
        {"unicode", "ä½ å¥½", "å¥½ä½ "},
        {"mixed", "Goè¯­è¨€", "è¨€è¯­oG"},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := Reverse(tt.input)
            if got != tt.want {
                t.Errorf("Reverse(%q) = %q; want %q",
                    tt.input, got, tt.want)
            }
        })
    }
}

// å¹¶å‘è¡¨é©±åŠ¨æµ‹è¯•
func TestIsPalindromeConcurrent(t *testing.T) {
    tests := []struct {
        input string
        want  bool
    }{
        {"racecar", true},
        {"hello", false},
        {"A man, a plan, a canal: Panama", true},
    }

    for _, tt := range tests {
        tt := tt // æ•è·å¾ªç¯å˜é‡ï¼ˆGo 1.22ä¹‹å‰éœ€è¦ï¼‰

        t.Run(tt.input, func(t *testing.T) {
            t.Parallel() // å¹¶å‘è¿è¡Œ

            got := IsPalindrome(tt.input)
            if got != tt.want {
                t.Errorf("got %v; want %v", got, tt.want)
            }
        })
    }
}
```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šMockä¸ä¾èµ–æ³¨å…¥

### ä¸ºä»€ä¹ˆéœ€è¦Mockï¼Ÿ

```text
âœ… éš”ç¦»ä¾èµ– - æµ‹è¯•ä¸ä¾èµ–å¤–éƒ¨ç³»ç»Ÿ
âœ… å¯æ§ç¯å¢ƒ - æ¨¡æ‹Ÿå„ç§åœºæ™¯
âœ… æå‡é€Ÿåº¦ - æ— éœ€çœŸå®I/O
âœ… è¾¹ç•Œæµ‹è¯• - æ¨¡æ‹Ÿé”™è¯¯ã€è¶…æ—¶
```

---

### å®æˆ˜æ¡ˆä¾‹3ï¼šæ¥å£ä¸Mock

```go
// user_service.go
package service

import (
    "context"
    "errors"
)

// User ç”¨æˆ·æ¨¡å‹
type User struct {
    ID    int64
    Name  string
    Email string
}

// UserRepository ç”¨æˆ·ä»“åº“æ¥å£
type UserRepository interface {
    GetByID(ctx context.Context, id int64) (*User, error)
    Create(ctx context.Context, user *User) error
    Update(ctx context.Context, user *User) error
    Delete(ctx context.Context, id int64) error
}

// EmailService é‚®ä»¶æœåŠ¡æ¥å£
type EmailService interface {
    SendWelcomeEmail(ctx context.Context, email string) error
}

// UserService ç”¨æˆ·æœåŠ¡
type UserService struct {
    repo  UserRepository
    email EmailService
}

func NewUserService(repo UserRepository, email EmailService) *UserService {
    return &UserService{
        repo:  repo,
        email: email,
    }
}

// CreateUser åˆ›å»ºç”¨æˆ·ï¼ˆå‘é€æ¬¢è¿é‚®ä»¶ï¼‰
func (s *UserService) CreateUser(ctx context.Context, name, email string) (*User, error) {
    // éªŒè¯
    if name == "" {
        return nil, errors.New("name is required")
    }
    if email == "" {
        return nil, errors.New("email is required")
    }

    // åˆ›å»ºç”¨æˆ·
    user := &User{
        Name:  name,
        Email: email,
    }

    if err := s.repo.Create(ctx, user); err != nil {
        return nil, err
    }

    // å‘é€æ¬¢è¿é‚®ä»¶ï¼ˆå¼‚æ­¥ï¼Œå¿½ç•¥é”™è¯¯ï¼‰
    go s.email.SendWelcomeEmail(context.Background(), email)

    return user, nil
}

// UpdateUserEmail æ›´æ–°ç”¨æˆ·é‚®ç®±
func (s *UserService) UpdateUserEmail(ctx context.Context, userID int64, newEmail string) error {
    user, err := s.repo.GetByID(ctx, userID)
    if err != nil {
        return err
    }

    user.Email = newEmail
    return s.repo.Update(ctx, user)
}
```

```go
// user_service_test.go
package service

import (
    "context"
    "errors"
    "testing"
)

// MockUserRepository ç”¨æˆ·ä»“åº“Mock
type MockUserRepository struct {
    GetByIDFunc func(ctx context.Context, id int64) (*User, error)
    CreateFunc  func(ctx context.Context, user *User) error
    UpdateFunc  func(ctx context.Context, user *User) error
    DeleteFunc  func(ctx context.Context, id int64) error
}

func (m *MockUserRepository) GetByID(ctx context.Context, id int64) (*User, error) {
    if m.GetByIDFunc != nil {
        return m.GetByIDFunc(ctx, id)
    }
    return nil, errors.New("not implemented")
}

func (m *MockUserRepository) Create(ctx context.Context, user *User) error {
    if m.CreateFunc != nil {
        return m.CreateFunc(ctx, user)
    }
    return errors.New("not implemented")
}

func (m *MockUserRepository) Update(ctx context.Context, user *User) error {
    if m.UpdateFunc != nil {
        return m.UpdateFunc(ctx, user)
    }
    return errors.New("not implemented")
}

func (m *MockUserRepository) Delete(ctx context.Context, id int64) error {
    if m.DeleteFunc != nil {
        return m.DeleteFunc(ctx, id)
    }
    return errors.New("not implemented")
}

// MockEmailService é‚®ä»¶æœåŠ¡Mock
type MockEmailService struct {
    SendWelcomeEmailFunc func(ctx context.Context, email string) error
}

func (m *MockEmailService) SendWelcomeEmail(ctx context.Context, email string) error {
    if m.SendWelcomeEmailFunc != nil {
        return m.SendWelcomeEmailFunc(ctx, email)
    }
    return nil
}

// TestCreateUser æµ‹è¯•åˆ›å»ºç”¨æˆ·
func TestCreateUser(t *testing.T) {
    tests := []struct {
        name      string
        inputName string
        inputEmail string
        mockRepo  *MockUserRepository
        mockEmail *MockEmailService
        wantErr   bool
        errMsg    string
    }{
        {
            name:       "æˆåŠŸåˆ›å»ºç”¨æˆ·",
            inputName:  "Alice",
            inputEmail: "alice@example.com",
            mockRepo: &MockUserRepository{
                CreateFunc: func(ctx context.Context, user *User) error {
                    user.ID = 1 // æ¨¡æ‹Ÿæ•°æ®åº“ç”ŸæˆID
                    return nil
                },
            },
            mockEmail: &MockEmailService{},
            wantErr:   false,
        },
        {
            name:       "åå­—ä¸ºç©º",
            inputName:  "",
            inputEmail: "alice@example.com",
            mockRepo:   &MockUserRepository{},
            mockEmail:  &MockEmailService{},
            wantErr:    true,
            errMsg:     "name is required",
        },
        {
            name:       "é‚®ç®±ä¸ºç©º",
            inputName:  "Alice",
            inputEmail: "",
            mockRepo:   &MockUserRepository{},
            mockEmail:  &MockEmailService{},
            wantErr:    true,
            errMsg:     "email is required",
        },
        {
            name:       "æ•°æ®åº“é”™è¯¯",
            inputName:  "Alice",
            inputEmail: "alice@example.com",
            mockRepo: &MockUserRepository{
                CreateFunc: func(ctx context.Context, user *User) error {
                    return errors.New("database error")
                },
            },
            mockEmail: &MockEmailService{},
            wantErr:   true,
            errMsg:    "database error",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            service := NewUserService(tt.mockRepo, tt.mockEmail)

            user, err := service.CreateUser(context.Background(), tt.inputName, tt.inputEmail)

            if tt.wantErr {
                if err == nil {
                    t.Error("expected error, got nil")
                } else if err.Error() != tt.errMsg {
                    t.Errorf("error message = %q; want %q", err.Error(), tt.errMsg)
                }
            } else {
                if err != nil {
                    t.Errorf("unexpected error: %v", err)
                }
                if user == nil {
                    t.Error("expected user, got nil")
                }
                if user != nil && user.Name != tt.inputName {
                    t.Errorf("user.Name = %q; want %q", user.Name, tt.inputName)
                }
            }
        })
    }
}

// TestUpdateUserEmail æµ‹è¯•æ›´æ–°ç”¨æˆ·é‚®ç®±
func TestUpdateUserEmail(t *testing.T) {
    mockRepo := &MockUserRepository{
        GetByIDFunc: func(ctx context.Context, id int64) (*User, error) {
            return &User{
                ID:    id,
                Name:  "Alice",
                Email: "alice@example.com",
            }, nil
        },
        UpdateFunc: func(ctx context.Context, user *User) error {
            return nil
        },
    }

    service := NewUserService(mockRepo, &MockEmailService{})

    err := service.UpdateUserEmail(context.Background(), 1, "alice.new@example.com")
    if err != nil {
        t.Errorf("unexpected error: %v", err)
    }
}
```

### ä½¿ç”¨gomockï¼ˆæ¨èï¼‰

```bash
# å®‰è£…gomock
go install github.com/golang/mock/mockgen@latest

# ç”ŸæˆMock
mockgen -source=user_repository.go -destination=mocks/mock_user_repository.go -package=mocks
```

---

## ç¬¬å››éƒ¨åˆ†ï¼šé›†æˆæµ‹è¯•æ·±åº¦å®æˆ˜

### ä»€ä¹ˆæ˜¯é›†æˆæµ‹è¯•ï¼Ÿ

```text
âœ… æµ‹è¯•å¤šä¸ªæ¨¡å—åä½œ
âœ… æµ‹è¯•ä¸å¤–éƒ¨ç³»ç»Ÿäº¤äº’ï¼ˆæ•°æ®åº“ã€APIç­‰ï¼‰
âœ… éªŒè¯ç«¯åˆ°ç«¯æµç¨‹
âœ… ä½¿ç”¨çœŸå®æˆ–æµ‹è¯•ç¯å¢ƒ
```

---

### å®æˆ˜æ¡ˆä¾‹4ï¼šæ•°æ®åº“é›†æˆæµ‹è¯•

```go
// user_repository_integration_test.go
// +build integration

package repository

import (
    "context"
    "database/sql"
    "testing"

    _ "github.com/mattn/go-sqlite3"
)

func setupTestDB(t *testing.T) *sql.DB {
    // ä½¿ç”¨å†…å­˜æ•°æ®åº“
    db, err := sql.Open("sqlite3", ":memory:")
    if err != nil {
        t.Fatalf("failed to open database: %v", err)
    }

    // åˆ›å»ºè¡¨
    _, err = db.Exec(`
        CREATE TABLE users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            email TEXT UNIQUE NOT NULL
        )
    `)
    if err != nil {
        t.Fatalf("failed to create table: %v", err)
    }

    return db
}

func TestUserRepository_Integration(t *testing.T) {
    // è·³è¿‡å•å…ƒæµ‹è¯•æ¨¡å¼
    if testing.Short() {
        t.Skip("skipping integration test in short mode")
    }

    db := setupTestDB(t)
    defer db.Close()

    repo := NewUserRepository(db)
    ctx := context.Background()

    // æµ‹è¯•Create
    t.Run("Create", func(t *testing.T) {
        user := &User{
            Name:  "Alice",
            Email: "alice@example.com",
        }

        err := repo.Create(ctx, user)
        if err != nil {
            t.Fatalf("Create failed: %v", err)
        }

        if user.ID == 0 {
            t.Error("expected ID to be set")
        }
    })

    // æµ‹è¯•GetByID
    t.Run("GetByID", func(t *testing.T) {
        user, err := repo.GetByID(ctx, 1)
        if err != nil {
            t.Fatalf("GetByID failed: %v", err)
        }

        if user.Name != "Alice" {
            t.Errorf("name = %q; want Alice", user.Name)
        }
        if user.Email != "alice@example.com" {
            t.Errorf("email = %q; want alice@example.com", user.Email)
        }
    })

    // æµ‹è¯•Update
    t.Run("Update", func(t *testing.T) {
        user := &User{
            ID:    1,
            Name:  "Alice Updated",
            Email: "alice.new@example.com",
        }

        err := repo.Update(ctx, user)
        if err != nil {
            t.Fatalf("Update failed: %v", err)
        }

        // éªŒè¯æ›´æ–°
        updated, err := repo.GetByID(ctx, 1)
        if err != nil {
            t.Fatalf("GetByID failed: %v", err)
        }

        if updated.Name != "Alice Updated" {
            t.Errorf("name not updated")
        }
    })

    // æµ‹è¯•Delete
    t.Run("Delete", func(t *testing.T) {
        err := repo.Delete(ctx, 1)
        if err != nil {
            t.Fatalf("Delete failed: %v", err)
        }

        // éªŒè¯åˆ é™¤
        _, err = repo.GetByID(ctx, 1)
        if err == nil {
            t.Error("expected error after delete")
        }
    })
}

// è¿è¡Œé›†æˆæµ‹è¯•
// go test -tags=integration
// è¿è¡Œå•å…ƒæµ‹è¯•ï¼ˆè·³è¿‡é›†æˆæµ‹è¯•ï¼‰
// go test -short
```

---

## ç¬¬äº”éƒ¨åˆ†ï¼šBenchmarkæ·±åº¦å®æˆ˜

### ä¸ºä»€ä¹ˆè¦å†™Benchmarkï¼Ÿ

```text
âœ… åº¦é‡æ€§èƒ½ - ç²¾ç¡®æµ‹é‡æ‰§è¡Œæ—¶é—´
âœ… å¯¹æ¯”æ–¹æ¡ˆ - é€‰æ‹©æœ€ä¼˜å®ç°
âœ… é˜²æ­¢é€€åŒ– - ç›‘æ§æ€§èƒ½å˜åŒ–
âœ… ä¼˜åŒ–æŒ‡å¯¼ - é…åˆpprofåˆ†æ
```

---

### å®æˆ˜æ¡ˆä¾‹5ï¼šBenchmarkå®Œæ•´ç¤ºä¾‹

```go
// string_concat_test.go
package stringutils

import (
    "bytes"
    "fmt"
    "strings"
    "testing"
)

// æ–¹æ¡ˆ1ï¼šä½¿ç”¨+æ‹¼æ¥
func ConcatWithPlus(strs []string) string {
    result := ""
    for _, s := range strs {
        result += s
    }
    return result
}

// æ–¹æ¡ˆ2ï¼šä½¿ç”¨fmt.Sprintf
func ConcatWithSprintf(strs []string) string {
    result := ""
    for _, s := range strs {
        result = fmt.Sprintf("%s%s", result, s)
    }
    return result
}

// æ–¹æ¡ˆ3ï¼šä½¿ç”¨strings.Builder
func ConcatWithBuilder(strs []string) string {
    var builder strings.Builder
    for _, s := range strs {
        builder.WriteString(s)
    }
    return builder.String()
}

// æ–¹æ¡ˆ4ï¼šä½¿ç”¨bytes.Buffer
func ConcatWithBuffer(strs []string) string {
    var buffer bytes.Buffer
    for _, s := range strs {
        buffer.WriteString(s)
    }
    return buffer.String()
}

// æ–¹æ¡ˆ5ï¼šä½¿ç”¨strings.Join
func ConcatWithJoin(strs []string) string {
    return strings.Join(strs, "")
}

// Benchmarkæµ‹è¯•
var testStrings = []string{"hello", "world", "go", "lang", "benchmark", "test"}

func BenchmarkConcatWithPlus(b *testing.B) {
    for i := 0; i < b.N; i++ {
        ConcatWithPlus(testStrings)
    }
}

func BenchmarkConcatWithSprintf(b *testing.B) {
    for i := 0; i < b.N; i++ {
        ConcatWithSprintf(testStrings)
    }
}

func BenchmarkConcatWithBuilder(b *testing.B) {
    for i := 0; i < b.N; i++ {
        ConcatWithBuilder(testStrings)
    }
}

func BenchmarkConcatWithBuffer(b *testing.B) {
    for i := 0; i < b.N; i++ {
        ConcatWithBuffer(testStrings)
    }
}

func BenchmarkConcatWithJoin(b *testing.B) {
    for i := 0; i < b.N; i++ {
        ConcatWithJoin(testStrings)
    }
}

// å¹¶å‘Benchmark
func BenchmarkConcatBuilderParallel(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            ConcatWithBuilder(testStrings)
        }
    })
}

// å¸¦å†…å­˜åˆ†æçš„Benchmark
func BenchmarkConcatWithAllocs(b *testing.B) {
    b.ReportAllocs() // æŠ¥å‘Šå†…å­˜åˆ†é…

    for i := 0; i < b.N; i++ {
        ConcatWithBuilder(testStrings)
    }
}

// å­Benchmark
func BenchmarkConcat(b *testing.B) {
    sizes := []int{10, 100, 1000}

    for _, size := range sizes {
        strs := make([]string, size)
        for i := 0; i < size; i++ {
            strs[i] = "test"
        }

        b.Run(fmt.Sprintf("Builder-%d", size), func(b *testing.B) {
            for i := 0; i < b.N; i++ {
                ConcatWithBuilder(strs)
            }
        })

        b.Run(fmt.Sprintf("Join-%d", size), func(b *testing.B) {
            for i := 0; i < b.N; i++ {
                ConcatWithJoin(strs)
            }
        })
    }
}

/*
è¿è¡ŒBenchmark:
go test -bench=. -benchmem

ç»“æœç¤ºä¾‹:
BenchmarkConcatWithPlus-8        1000000    1200 ns/op    512 B/op    5 allocs/op
BenchmarkConcatWithBuilder-8    10000000     120 ns/op     64 B/op    2 allocs/op
BenchmarkConcatWithJoin-8       15000000      80 ns/op     48 B/op    1 allocs/op

ç»“è®ºï¼šstrings.Join > strings.Builder > + æ‹¼æ¥
*/
```

---

## ç¬¬å…­éƒ¨åˆ†ï¼šæµ‹è¯•è¦†ç›–ç‡ä¸åˆ†æ

### ä»€ä¹ˆæ˜¯æµ‹è¯•è¦†ç›–ç‡ï¼Ÿ

**æµ‹è¯•è¦†ç›–ç‡ï¼ˆTest Coverageï¼‰**æ˜¯è¡¡é‡æµ‹è¯•å®Œæ•´æ€§çš„æŒ‡æ ‡ï¼š

- è¡Œè¦†ç›–ç‡ï¼šè¢«æµ‹è¯•æ‰§è¡Œçš„ä»£ç è¡Œæ¯”ä¾‹
- åˆ†æ”¯è¦†ç›–ç‡ï¼šè¢«æµ‹è¯•æ‰§è¡Œçš„åˆ†æ”¯æ¯”ä¾‹
- å‡½æ•°è¦†ç›–ç‡ï¼šè¢«æµ‹è¯•è°ƒç”¨çš„å‡½æ•°æ¯”ä¾‹

---

### å®æˆ˜æ¡ˆä¾‹6ï¼šæµ‹è¯•è¦†ç›–ç‡åˆ†æ

```bash
# è¿è¡Œæµ‹è¯•å¹¶ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
go test -cover

# ç”Ÿæˆè¯¦ç»†è¦†ç›–ç‡æ–‡ä»¶
go test -coverprofile=coverage.out

# æŸ¥çœ‹è¦†ç›–ç‡è¯¦æƒ…
go tool cover -func=coverage.out

# ç”ŸæˆHTMLå¯è§†åŒ–æŠ¥å‘Š
go tool cover -html=coverage.out -o coverage.html

# åˆ†åŒ…æŸ¥çœ‹è¦†ç›–ç‡
go test -coverprofile=coverage.out ./...
go tool cover -func=coverage.out
```

```go
// math.go
package math

func Abs(x int) int {
    if x < 0 {
        return -x
    }
    return x
}

func Max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func Min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

```go
// math_test.go
package math

import "testing"

func TestAbs(t *testing.T) {
    tests := []struct {
        input int
        want  int
    }{
        {5, 5},
        {-5, 5},
        {0, 0},
    }

    for _, tt := range tests {
        got := Abs(tt.input)
        if got != tt.want {
            t.Errorf("Abs(%d) = %d; want %d", tt.input, got, tt.want)
        }
    }
}

func TestMax(t *testing.T) {
    if Max(3, 5) != 5 {
        t.Error("Max(3, 5) should return 5")
    }
    if Max(5, 3) != 5 {
        t.Error("Max(5, 3) should return 5")
    }
}

// æ³¨æ„ï¼šMinå‡½æ•°æ²¡æœ‰æµ‹è¯•ï¼Œè¦†ç›–ç‡ä¼šæ˜¾ç¤ºæœªè¦†ç›–

/*
è¦†ç›–ç‡åˆ†æç»“æœ:
github.com/example/math/math.go:3:  Abs     100.0%
github.com/example/math/math.go:10: Max     100.0%
github.com/example/math/math.go:17: Min       0.0%  â† æœªæµ‹è¯•
total:                             (statements) 66.7%
*/
```

---

## ç¬¬ä¸ƒéƒ¨åˆ†ï¼šHTTPæµ‹è¯•æœ€ä½³å®è·µ

### å®æˆ˜æ¡ˆä¾‹7ï¼šHTTP Handleræµ‹è¯•

```go
// user_handler.go
package handler

import (
    "encoding/json"
    "net/http"
    "strconv"

    "github.com/gorilla/mux"
)

type User struct {
    ID   int    `json:"id"`
    Name string `json:"name"`
}

type UserHandler struct {
    users map[int]*User
    nextID int
}

func NewUserHandler() *UserHandler {
    return &UserHandler{
        users:  make(map[int]*User),
        nextID: 1,
    }
}

func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
    var user User
    if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
        http.Error(w, "Invalid request body", http.StatusBadRequest)
        return
    }

    user.ID = h.nextID
    h.nextID++
    h.users[user.ID] = &user

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(user)
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id, err := strconv.Atoi(vars["id"])
    if err != nil {
        http.Error(w, "Invalid user ID", http.StatusBadRequest)
        return
    }

    user, exists := h.users[id]
    if !exists {
        http.Error(w, "User not found", http.StatusNotFound)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}
```

```go
// user_handler_test.go
package handler

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/gorilla/mux"
)

func TestCreateUser(t *testing.T) {
    handler := NewUserHandler()

    // å‡†å¤‡è¯·æ±‚
    user := User{Name: "Alice"}
    body, _ := json.Marshal(user)

    req := httptest.NewRequest(http.MethodPost, "/users", bytes.NewBuffer(body))
    req.Header.Set("Content-Type", "application/json")

    // è®°å½•å“åº”
    rr := httptest.NewRecorder()

    // æ‰§è¡Œè¯·æ±‚
    handler.CreateUser(rr, req)

    // éªŒè¯çŠ¶æ€ç 
    if status := rr.Code; status != http.StatusCreated {
        t.Errorf("status = %d; want %d", status, http.StatusCreated)
    }

    // éªŒè¯å“åº”
    var created User
    if err := json.NewDecoder(rr.Body).Decode(&created); err != nil {
        t.Fatalf("failed to decode response: %v", err)
    }

    if created.ID == 0 {
        t.Error("expected ID to be set")
    }
    if created.Name != "Alice" {
        t.Errorf("name = %q; want Alice", created.Name)
    }

    // éªŒè¯å“åº”å¤´
    if ct := rr.Header().Get("Content-Type"); ct != "application/json" {
        t.Errorf("Content-Type = %q; want application/json", ct)
    }
}

func TestGetUser(t *testing.T) {
    handler := NewUserHandler()

    // å…ˆåˆ›å»ºä¸€ä¸ªç”¨æˆ·
    handler.users[1] = &User{ID: 1, Name: "Bob"}

    // æµ‹è¯•è·å–å­˜åœ¨çš„ç”¨æˆ·
    t.Run("existing user", func(t *testing.T) {
        req := httptest.NewRequest(http.MethodGet, "/users/1", nil)
        rr := httptest.NewRecorder()

        // ä½¿ç”¨muxè®¾ç½®è·¯å¾„å‚æ•°
        req = mux.SetURLVars(req, map[string]string{"id": "1"})

        handler.GetUser(rr, req)

        if status := rr.Code; status != http.StatusOK {
            t.Errorf("status = %d; want %d", status, http.StatusOK)
        }

        var user User
        json.NewDecoder(rr.Body).Decode(&user)

        if user.Name != "Bob" {
            t.Errorf("name = %q; want Bob", user.Name)
        }
    })

    // æµ‹è¯•è·å–ä¸å­˜åœ¨çš„ç”¨æˆ·
    t.Run("non-existing user", func(t *testing.T) {
        req := httptest.NewRequest(http.MethodGet, "/users/999", nil)
        req = mux.SetURLVars(req, map[string]string{"id": "999"})
        rr := httptest.NewRecorder()

        handler.GetUser(rr, req)

        if status := rr.Code; status != http.StatusNotFound {
            t.Errorf("status = %d; want %d", status, http.StatusNotFound)
        }
    })
}

// æµ‹è¯•å®Œæ•´HTTPæœåŠ¡å™¨
func TestHTTPServer(t *testing.T) {
    handler := NewUserHandler()

    // åˆ›å»ºè·¯ç”±
    router := mux.NewRouter()
    router.HandleFunc("/users", handler.CreateUser).Methods(http.MethodPost)
    router.HandleFunc("/users/{id}", handler.GetUser).Methods(http.MethodGet)

    // åˆ›å»ºæµ‹è¯•æœåŠ¡å™¨
    server := httptest.NewServer(router)
    defer server.Close()

    // æµ‹è¯•åˆ›å»ºç”¨æˆ·
    user := User{Name: "Charlie"}
    body, _ := json.Marshal(user)

    resp, err := http.Post(server.URL+"/users", "application/json", bytes.NewBuffer(body))
    if err != nil {
        t.Fatalf("failed to post: %v", err)
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusCreated {
        t.Errorf("status = %d; want %d", resp.StatusCode, http.StatusCreated)
    }

    var created User
    json.NewDecoder(resp.Body).Decode(&created)

    // æµ‹è¯•è·å–ç”¨æˆ·
    resp, err = http.Get(server.URL + "/users/1")
    if err != nil {
        t.Fatalf("failed to get: %v", err)
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        t.Errorf("status = %d; want %d", resp.StatusCode, http.StatusOK)
    }
}
```

---

## ç¬¬å…«éƒ¨åˆ†ï¼šæ•°æ®åº“æµ‹è¯•æœ€ä½³å®è·µ

### å®æˆ˜æ¡ˆä¾‹8ï¼šæ•°æ®åº“æµ‹è¯•ç­–ç•¥

```go
// user_repository_test.go
package repository

import (
    "context"
    "database/sql"
    "testing"

    "github.com/DATA-DOG/go-sqlmock"
)

func TestUserRepository_Create_WithMock(t *testing.T) {
    // åˆ›å»ºmockæ•°æ®åº“
    db, mock, err := sqlmock.New()
    if err != nil {
        t.Fatalf("failed to create mock: %v", err)
    }
    defer db.Close()

    repo := NewUserRepository(db)

    // è®¾ç½®æœŸæœ›
    mock.ExpectExec("INSERT INTO users").
        WithArgs("Alice", "alice@example.com").
        WillReturnResult(sqlmock.NewResult(1, 1))

    // æ‰§è¡Œæµ‹è¯•
    user := &User{Name: "Alice", Email: "alice@example.com"}
    err = repo.Create(context.Background(), user)

    if err != nil {
        t.Errorf("unexpected error: %v", err)
    }

    if user.ID != 1 {
        t.Errorf("ID = %d; want 1", user.ID)
    }

    // éªŒè¯æ‰€æœ‰æœŸæœ›éƒ½è¢«æ»¡è¶³
    if err := mock.ExpectationsWereMet(); err != nil {
        t.Errorf("unfulfilled expectations: %v", err)
    }
}

func TestUserRepository_GetByID_WithMock(t *testing.T) {
    db, mock, err := sqlmock.New()
    if err != nil {
        t.Fatalf("failed to create mock: %v", err)
    }
    defer db.Close()

    repo := NewUserRepository(db)

    // è®¾ç½®æœŸæœ›
    rows := sqlmock.NewRows([]string{"id", "name", "email"}).
        AddRow(1, "Bob", "bob@example.com")

    mock.ExpectQuery("SELECT (.+) FROM users WHERE id = ?").
        WithArgs(1).
        WillReturnRows(rows)

    // æ‰§è¡Œæµ‹è¯•
    user, err := repo.GetByID(context.Background(), 1)

    if err != nil {
        t.Errorf("unexpected error: %v", err)
    }

    if user.Name != "Bob" {
        t.Errorf("Name = %q; want Bob", user.Name)
    }

    if err := mock.ExpectationsWereMet(); err != nil {
        t.Errorf("unfulfilled expectations: %v", err)
    }
}

// æµ‹è¯•äº‹åŠ¡
func TestUserRepository_WithTransaction(t *testing.T) {
    db, mock, err := sqlmock.New()
    if err != nil {
        t.Fatalf("failed to create mock: %v", err)
    }
    defer db.Close()

    repo := NewUserRepository(db)

    // è®¾ç½®äº‹åŠ¡æœŸæœ›
    mock.ExpectBegin()
    mock.ExpectExec("INSERT INTO users").
        WithArgs("Charlie", "charlie@example.com").
        WillReturnResult(sqlmock.NewResult(1, 1))
    mock.ExpectCommit()

    // æ‰§è¡Œæµ‹è¯•
    tx, _ := db.Begin()
    user := &User{Name: "Charlie", Email: "charlie@example.com"}
    err = repo.CreateWithTx(context.Background(), tx, user)

    if err != nil {
        tx.Rollback()
        t.Errorf("unexpected error: %v", err)
    } else {
        tx.Commit()
    }

    if err := mock.ExpectationsWereMet(); err != nil {
        t.Errorf("unfulfilled expectations: %v", err)
    }
}
```

---

## ç¬¬ä¹éƒ¨åˆ†ï¼šå®Œæ•´é¡¹ç›®æµ‹è¯•

### é¡¹ç›®ç»“æ„

```text
blog-api/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ main.go
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ repository/
â”‚   â”‚   â”œâ”€â”€ user_repository.go
â”‚   â”‚   â””â”€â”€ user_repository_test.go
â”‚   â”œâ”€â”€ service/
â”‚   â”‚   â”œâ”€â”€ user_service.go
â”‚   â”‚   â””â”€â”€ user_service_test.go
â”‚   â””â”€â”€ handler/
â”‚       â”œâ”€â”€ user_handler.go
â”‚       â””â”€â”€ user_handler_test.go
â”œâ”€â”€ test/
â”‚   â”œâ”€â”€ integration/
â”‚   â”‚   â””â”€â”€ user_integration_test.go
â”‚   â””â”€â”€ e2e/
â”‚       â””â”€â”€ api_test.go
â””â”€â”€ Makefile
```

---

### Makefileæµ‹è¯•å‘½ä»¤

```makefile
.PHONY: test test-unit test-integration test-coverage test-bench

# è¿è¡Œæ‰€æœ‰æµ‹è¯•
test:
 go test -v ./...

# è¿è¡Œå•å…ƒæµ‹è¯•ï¼ˆæ’é™¤é›†æˆæµ‹è¯•ï¼‰
test-unit:
 go test -short -v ./...

# è¿è¡Œé›†æˆæµ‹è¯•
test-integration:
 go test -tags=integration -v ./test/integration/...

# ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
test-coverage:
 go test -coverprofile=coverage.out ./...
 go tool cover -html=coverage.out -o coverage.html
 @echo "Coverage report generated: coverage.html"

# è¿è¡ŒBenchmark
test-bench:
 go test -bench=. -benchmem ./...

# è¿è¡Œæ‰€æœ‰æµ‹è¯•å¹¶ç”ŸæˆæŠ¥å‘Š
test-all: test-unit test-integration test-coverage test-bench
 @echo "All tests completed!"
```

---

## ğŸ¯ æ€»ç»“

### æµ‹è¯•æ ¸å¿ƒè¦ç‚¹

1. **å•å…ƒæµ‹è¯•** - æµ‹è¯•æœ€å°åŠŸèƒ½å•å…ƒ
2. **è¡¨é©±åŠ¨æµ‹è¯•** - Goæ¨èçš„æµ‹è¯•æ¨¡å¼
3. **Mockä¸ä¾èµ–æ³¨å…¥** - éš”ç¦»å¤–éƒ¨ä¾èµ–
4. **é›†æˆæµ‹è¯•** - æµ‹è¯•å¤šä¸ªæ¨¡å—åä½œ
5. **Benchmark** - åº¦é‡å’Œä¼˜åŒ–æ€§èƒ½
6. **æµ‹è¯•è¦†ç›–ç‡** - è¡¡é‡æµ‹è¯•å®Œæ•´æ€§
7. **HTTPæµ‹è¯•** - httpteståŒ…å®Œæ•´æ”¯æŒ
8. **æ•°æ®åº“æµ‹è¯•** - sqlmockæ¨¡æ‹Ÿæ•°æ®åº“

### æœ€ä½³å®è·µæ¸…å•

```text
âœ… æ¯ä¸ªåŒ…éƒ½åº”æœ‰æµ‹è¯•
âœ… ä½¿ç”¨è¡¨é©±åŠ¨æµ‹è¯•ç»„ç»‡ç”¨ä¾‹
âœ… æµ‹è¯•ç”¨ä¾‹åº”ç‹¬ç«‹ã€å¯å¤ç°
âœ… ä½¿ç”¨Mockéš”ç¦»å¤–éƒ¨ä¾èµ–
âœ… åŒºåˆ†å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
âœ… ä¿æŒæµ‹è¯•è¦†ç›–ç‡â‰¥80%
âœ… å…³é”®è·¯å¾„å¿…é¡»æœ‰Benchmark
âœ… æµ‹è¯•å‘½åæ¸…æ™°ï¼ˆTest + åŠŸèƒ½ + åœºæ™¯ï¼‰
âœ… ä½¿ç”¨t.Helper()æ ‡è®°è¾…åŠ©å‡½æ•°
âœ… å¹¶å‘æµ‹è¯•ä½¿ç”¨t.Parallel()
âœ… é›†æˆæµ‹è¯•ä½¿ç”¨build tag
âœ… CI/CDè‡ªåŠ¨è¿è¡Œæµ‹è¯•
```

### æµ‹è¯•é‡‘å­—å¡”

```text
      E2Eæµ‹è¯•
        /\
       /  \
      /    \
     / é›†æˆ  \
    /  æµ‹è¯•  \
   /          \
  /   å•å…ƒæµ‹è¯•  \
 /              \
/______________\

æ¯”ä¾‹å»ºè®®ï¼š
- å•å…ƒæµ‹è¯•ï¼š70%
- é›†æˆæµ‹è¯•ï¼š20%
- E2Eæµ‹è¯•ï¼š10%
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v9.0

<div align="center">

Made with â¤ï¸ for Go Test Developers

[â¬† å›åˆ°é¡¶éƒ¨](#å›åˆ°é¡¶éƒ¨)

</div>

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team
**æœ€åæ›´æ–°**: 2025-10-29
**æ–‡æ¡£çŠ¶æ€**: å®Œæˆ
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
