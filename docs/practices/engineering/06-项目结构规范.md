# Go项目结构规范完全指南

> **简介**: Go项目目录结构的最佳实践，包括标准布局、目录说明和实战案例

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---

## 📋 目录

- [1. 标准项目布局](#1-标准项目布局)
  - [Standard Go Project Layout](#standard-go-project-layout)
- [2. 目录结构详解](#2-目录结构详解)
  - [`/cmd` - 主应用程序](#cmd-主应用程序)
  - [`/internal` - 私有代码](#internal-私有代码)
  - [`/pkg` - 公共库代码](#pkg-公共库代码)
  - [`/api` - API定义](#api-api定义)
  - [`/configs` - 配置文件](#configs-配置文件)
  - [`/scripts` - 脚本](#scripts-脚本)
  - [`/deployments` - 部署配置](#deployments-部署配置)
- [3. 不同规模项目结构](#3-不同规模项目结构)
  - [小型项目（单体应用）](#小型项目单体应用)
  - [中型项目（分层架构）](#中型项目分层架构)
  - [大型项目（微服务架构）](#大型项目微服务架构)
- [4. 最佳实践](#4-最佳实践)
  - [DO's ✅](#dos)
    - [1. 合理分层](#1-合理分层)
    - [2. 依赖注入](#2-依赖注入)
    - [3. 接口定义](#3-接口定义)
    - [4. 配置管理](#4-配置管理)
  - [DON'Ts ❌](#donts)
- [5. 实战案例](#5-实战案例)
  - [RESTful API项目](#restful-api项目)
  - [Makefile](#makefile)

## 1. 标准项目布局

### Standard Go Project Layout

基于[golang-standards/project-layout](https://github.com/golang-standards/project-layout)的标准布局：

```text
myproject/
├── cmd/                    # 主应用程序
│   ├── server/
│   │   └── main.go
│   └── cli/
│       └── main.go
├── internal/               # 私有应用和库代码
│   ├── app/
│   ├── pkg/
│   └── config/
├── pkg/                    # 可被外部应用使用的库代码
│   ├── api/
│   └── utils/
├── api/                    # API定义文件
│   ├── openapi/
│   ├── protobuf/
│   └── graphql/
├── web/                    # Web应用特定组件
│   ├── static/
│   └── templates/
├── configs/                # 配置文件
│   ├── config.yaml
│   └── config.prod.yaml
├── scripts/                # 各种构建、安装、分析等脚本
│   ├── build.sh
│   └── deploy.sh
├── build/                  # 打包和持续集成
│   ├── ci/
│   └── package/
├── deployments/            # 部署配置和模板
│   ├── docker/
│   └── kubernetes/
├── test/                   # 额外的外部测试应用和测试数据
│   ├── integration/
│   └── e2e/
├── docs/                   # 设计和用户文档
│   ├── architecture.md
│   └── api.md
├── tools/                  # 项目的支持工具
├── vendor/                 # 应用依赖（可选）
├── go.mod
├── go.sum
├── Makefile
├── Dockerfile
├── README.md
└── LICENSE
```

---

## 2. 目录结构详解

### `/cmd` - 主应用程序

每个应用程序一个子目录，目录名应该与可执行文件名称匹配。

```text
cmd/
├── server/              # Web服务器
│   └── main.go
├── worker/              # 后台任务worker
│   └── main.go
├── cli/                 # CLI工具
│   └── main.go
└── migrator/            # 数据库迁移工具
    └── main.go
```

**main.go示例**:

```go
// cmd/server/main.go
package main

import (
    "log"
    "myproject/internal/app"
    "myproject/internal/config"
)

func main() {
    // 加载配置
    cfg, err := config.Load()
    if err != nil {
        log.Fatal(err)
    }
    
    // 创建应用
    app := app.New(cfg)
    
    // 启动服务器
    if err := app.Run(); err != nil {
        log.Fatal(err)
    }
}
```

### `/internal` - 私有代码

Go编译器强制：其他项目不能导入`internal`目录中的代码。

```text
internal/
├── app/                 # 应用核心逻辑
│   ├── server.go        # 服务器初始化
│   └── app.go
├── handler/             # HTTP处理器
│   ├── user.go
│   └── product.go
├── service/             # 业务逻辑层
│   ├── user.go
│   └── product.go
├── repository/          # 数据访问层
│   ├── user.go
│   └── product.go
├── model/               # 数据模型
│   ├── user.go
│   └── product.go
├── middleware/          # 中间件
│   ├── auth.go
│   └── logging.go
├── config/              # 配置加载
│   └── config.go
└── pkg/                 # 内部共享库
    ├── errors/
    ├── logger/
    └── validator/
```

### `/pkg` - 公共库代码

可以被外部项目安全导入的代码。

```text
pkg/
├── api/                 # API客户端
│   └── client.go
├── auth/                # 认证库
│   └── jwt.go
├── cache/               # 缓存库
│   └── redis.go
└── utils/               # 工具函数
    ├── strings.go
    └── time.go
```

**⚠️ 注意**: 只放置真正可重用的、稳定的代码。

### `/api` - API定义

```text
api/
├── openapi/
│   └── api.yaml         # OpenAPI/Swagger规范
├── protobuf/
│   ├── user.proto       # Protocol Buffers定义
│   └── product.proto
└── graphql/
    └── schema.graphql   # GraphQL Schema
```

### `/configs` - 配置文件

```text
configs/
├── config.yaml          # 默认配置
├── config.dev.yaml      # 开发环境
├── config.staging.yaml  # 测试环境
└── config.prod.yaml     # 生产环境
```

### `/scripts` - 脚本

```text
scripts/
├── build.sh             # 构建脚本
├── test.sh              # 测试脚本
├── deploy.sh            # 部署脚本
├── migration.sh         # 数据库迁移
└── lint.sh              # 代码检查
```

### `/deployments` - 部署配置

```text
deployments/
├── docker/
│   ├── Dockerfile
│   └── docker-compose.yml
└── kubernetes/
    ├── deployment.yaml
    ├── service.yaml
    └── ingress.yaml
```

---

## 3. 不同规模项目结构

### 小型项目（单体应用）

```text
simple-app/
├── main.go              # 主入口
├── handler.go           # HTTP处理器
├── model.go             # 数据模型
├── service.go           # 业务逻辑
├── go.mod
└── README.md
```

### 中型项目（分层架构）

```text
medium-app/
├── cmd/
│   └── server/
│       └── main.go
├── internal/
│   ├── handler/
│   │   ├── user_handler.go
│   │   └── product_handler.go
│   ├── service/
│   │   ├── user_service.go
│   │   └── product_service.go
│   ├── repository/
│   │   ├── user_repository.go
│   │   └── product_repository.go
│   └── model/
│       ├── user.go
│       └── product.go
├── pkg/
│   └── database/
│       └── postgres.go
├── configs/
│   └── config.yaml
├── go.mod
└── README.md
```

### 大型项目（微服务架构）

```text
large-app/
├── services/
│   ├── user-service/
│   │   ├── cmd/
│   │   ├── internal/
│   │   ├── go.mod
│   │   └── README.md
│   ├── product-service/
│   │   ├── cmd/
│   │   ├── internal/
│   │   ├── go.mod
│   │   └── README.md
│   └── order-service/
│       ├── cmd/
│       ├── internal/
│       ├── go.mod
│       └── README.md
├── shared/
│   ├── pkg/
│   │   ├── auth/
│   │   ├── logger/
│   │   └── errors/
│   └── proto/
│       ├── user.proto
│       └── product.proto
├── deployments/
│   └── kubernetes/
├── scripts/
└── README.md
```

---

## 4. 最佳实践

### DO's ✅

#### 1. 合理分层

```go
// 三层架构
// Handler -> Service -> Repository

// Handler层：处理HTTP请求
type UserHandler struct {
    userService *service.UserService
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
    id := getIDFromRequest(r)
    user, err := h.userService.GetUser(r.Context(), id)
    // ... 响应处理
}

// Service层：业务逻辑
type UserService struct {
    userRepo repository.UserRepository
}

func (s *UserService) GetUser(ctx context.Context, id int) (*model.User, error) {
    // 业务逻辑
    return s.userRepo.FindByID(ctx, id)
}

// Repository层：数据访问
type UserRepository interface {
    FindByID(ctx context.Context, id int) (*model.User, error)
}
```

#### 2. 依赖注入

```go
// 使用构造函数注入依赖
type UserService struct {
    userRepo  repository.UserRepository
    emailSvc  EmailService
    logger    *log.Logger
}

func NewUserService(
    userRepo repository.UserRepository,
    emailSvc EmailService,
    logger *log.Logger,
) *UserService {
    return &UserService{
        userRepo: userRepo,
        emailSvc: emailSvc,
        logger:   logger,
    }
}
```

#### 3. 接口定义

```go
// 在使用方定义接口（依赖倒置）
package service

// UserRepository 在service包中定义接口
type UserRepository interface {
    FindByID(ctx context.Context, id int) (*model.User, error)
    Save(ctx context.Context, user *model.User) error
}

// 在repository包中实现
package repository

type postgresUserRepo struct {
    db *sql.DB
}

func (r *postgresUserRepo) FindByID(ctx context.Context, id int) (*model.User, error) {
    // 实现
}
```

#### 4. 配置管理

```go
// internal/config/config.go
package config

import (
    "github.com/spf13/viper"
)

type Config struct {
    Server   ServerConfig
    Database DatabaseConfig
    Redis    RedisConfig
    Log      LogConfig
}

type ServerConfig struct {
    Port string
    Env  string
}

type DatabaseConfig struct {
    Host     string
    Port     int
    User     string
    Password string
    DBName   string
}

func Load() (*Config, error) {
    viper.SetConfigName("config")
    viper.SetConfigType("yaml")
    viper.AddConfigPath("./configs")
    viper.AutomaticEnv()
    
    if err := viper.ReadInConfig(); err != nil {
        return nil, err
    }
    
    var config Config
    if err := viper.Unmarshal(&config); err != nil {
        return nil, err
    }
    
    return &config, nil
}
```

### DON'Ts ❌

```go
// ❌ 1. 不要把所有代码放在main包
// main.go
package main

type User struct {...}
func GetUser() {...}
func SaveUser() {...}
// ... 1000行代码

// ❌ 2. 不要循环依赖
// package A imports B
// package B imports A

// ❌ 3. 不要在pkg中放置应用特定代码
pkg/
└── myapp_specific/  // 不应该在pkg中

// ❌ 4. 不要过度设计
// 小项目不需要复杂的目录结构

// ❌ 5. 不要忽略go.mod
// 应该提交go.mod和go.sum
```

---

## 5. 实战案例

### RESTful API项目

```text
todo-api/
├── cmd/
│   └── server/
│       └── main.go
├── internal/
│   ├── handler/
│   │   └── todo.go
│   ├── service/
│   │   └── todo.go
│   ├── repository/
│   │   └── todo.go
│   ├── model/
│   │   └── todo.go
│   ├── middleware/
│   │   ├── auth.go
│   │   └── logging.go
│   └── config/
│       └── config.go
├── pkg/
│   ├── database/
│   │   └── postgres.go
│   └── validator/
│       └── validator.go
├── migrations/
│   ├── 001_create_todos.up.sql
│   └── 001_create_todos.down.sql
├── configs/
│   ├── config.yaml
│   └── config.prod.yaml
├── scripts/
│   ├── migrate.sh
│   └── seed.sh
├── deployments/
│   ├── Dockerfile
│   └── docker-compose.yml
├── go.mod
├── go.sum
├── Makefile
└── README.md
```

**main.go**:

```go
// cmd/server/main.go
package main

import (
    "context"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
    
    "todo-api/internal/config"
    "todo-api/internal/handler"
    "todo-api/internal/middleware"
    "todo-api/internal/repository"
    "todo-api/internal/service"
    "todo-api/pkg/database"
)

func main() {
    // 加载配置
    cfg, err := config.Load()
    if err != nil {
        log.Fatal("Failed to load config:", err)
    }
    
    // 初始化数据库
    db, err := database.NewPostgres(cfg.Database)
    if err != nil {
        log.Fatal("Failed to connect database:", err)
    }
    defer db.Close()
    
    // 初始化Repository
    todoRepo := repository.NewTodoRepository(db)
    
    // 初始化Service
    todoService := service.NewTodoService(todoRepo)
    
    // 初始化Handler
    todoHandler := handler.NewTodoHandler(todoService)
    
    // 设置路由
    mux := http.NewServeMux()
    mux.HandleFunc("/api/todos", todoHandler.ListTodos)
    mux.HandleFunc("/api/todos/", todoHandler.HandleTodo)
    
    // 应用中间件
    handler := middleware.Logging(
        middleware.Auth(mux, cfg.JWT.Secret),
    )
    
    // 创建服务器
    srv := &http.Server{
        Addr:         cfg.Server.Port,
        Handler:      handler,
        ReadTimeout:  15 * time.Second,
        WriteTimeout: 15 * time.Second,
        IdleTimeout:  60 * time.Second,
    }
    
    // 优雅关闭
    go func() {
        log.Printf("Server starting on %s", cfg.Server.Port)
        if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatal("Server failed:", err)
        }
    }()
    
    // 等待中断信号
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Println("Server shutting down...")
    
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    if err := srv.Shutdown(ctx); err != nil {
        log.Fatal("Server forced to shutdown:", err)
    }
    
    log.Println("Server exited")
}
```

### Makefile

```makefile
# Makefile
.PHONY: build run test lint docker-build

# 变量
APP_NAME=todo-api
VERSION=$(shell git describe --tags --always --dirty)
BUILD_TIME=$(shell date -u '+%Y-%m-%d_%H:%M:%S')
LDFLAGS=-ldflags "-X main.Version=${VERSION} -X main.BuildTime=${BUILD_TIME}"

# 构建
build:
 go build ${LDFLAGS} -o bin/${APP_NAME} cmd/server/main.go

# 运行
run:
 go run cmd/server/main.go

# 测试
test:
 go test -v -race -coverprofile=coverage.out ./...
 go tool cover -html=coverage.out -o coverage.html

# 代码检查
lint:
 golangci-lint run --timeout 5m

# 格式化
fmt:
 go fmt ./...
 goimports -w .

# 依赖
deps:
 go mod download
 go mod tidy

# 数据库迁移
migrate-up:
 migrate -path migrations -database "${DATABASE_URL}" up

migrate-down:
 migrate -path migrations -database "${DATABASE_URL}" down

# Docker构建
docker-build:
 docker build -t ${APP_NAME}:${VERSION} .

# 清理
clean:
 rm -rf bin/ coverage.out coverage.html

# 帮助
help:
 @echo "Available targets:"
 @echo "  build        - Build the application"
 @echo "  run          - Run the application"
 @echo "  test         - Run tests"
 @echo "  lint         - Run linters"
 @echo "  docker-build - Build Docker image"
```

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025-10-29  
**文档状态**: ✅ 完成  
**适用版本**: Go 1.21+
