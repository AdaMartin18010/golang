# Goé”™è¯¯å¤„ç†æœ€ä½³å®è·µå®Œå…¨æŒ‡å—

> **ç®€ä»‹**: Goè¯­è¨€é”™è¯¯å¤„ç†çš„å®Œæ•´å®è·µæŒ‡å—ï¼ŒåŒ…æ‹¬erroræ¥å£ã€é”™è¯¯åŒ…è£…ã€è‡ªå®šä¹‰é”™è¯¯å’Œé”™è¯¯å¤„ç†æ¨¡å¼

---

## ğŸ“‹ ç›®å½•


- [1. é”™è¯¯å¤„ç†åŸºç¡€](#1-é”™è¯¯å¤„ç†åŸºç¡€)
  - [erroræ¥å£](#erroræ¥å£)
  - [åˆ›å»ºé”™è¯¯](#åˆ›å»ºé”™è¯¯)
  - [é”™è¯¯æ£€æŸ¥](#é”™è¯¯æ£€æŸ¥)
- [2. é”™è¯¯åŒ…è£…å’Œè§£åŒ…](#2-é”™è¯¯åŒ…è£…å’Œè§£åŒ…)
  - [é”™è¯¯åŒ…è£…ï¼ˆWrapping)](#é”™è¯¯åŒ…è£…wrapping)
  - [é”™è¯¯è§£åŒ…ï¼ˆUnwrapping)](#é”™è¯¯è§£åŒ…unwrapping)
  - [å®Œæ•´ç¤ºä¾‹](#å®Œæ•´ç¤ºä¾‹)
- [3. è‡ªå®šä¹‰é”™è¯¯ç±»å‹](#3-è‡ªå®šä¹‰é”™è¯¯ç±»å‹)
  - [ç®€å•è‡ªå®šä¹‰é”™è¯¯](#ç®€å•è‡ªå®šä¹‰é”™è¯¯)
  - [å¤æ‚è‡ªå®šä¹‰é”™è¯¯](#å¤æ‚è‡ªå®šä¹‰é”™è¯¯)
  - [é”™è¯¯ç»„ï¼ˆMultiple Errors)](#é”™è¯¯ç»„multiple-errors)
- [4. é”™è¯¯å¤„ç†æ¨¡å¼](#4-é”™è¯¯å¤„ç†æ¨¡å¼)
  - [å“¨å…µé”™è¯¯ï¼ˆSentinel Errors)](#å“¨å…µé”™è¯¯sentinel-errors)
  - [é”™è¯¯ç±»å‹æ–­è¨€](#é”™è¯¯ç±»å‹æ–­è¨€)
  - [Panicå’ŒRecover](#panicå’Œrecover)
- [5. é”™è¯¯å¤„ç†æœ€ä½³å®è·µ](#5-é”™è¯¯å¤„ç†æœ€ä½³å®è·µ)
  - [DO's âœ…](#dos-)
    - [1. å°½æ—©è¿”å›é”™è¯¯](#1-å°½æ—©è¿”å›é”™è¯¯)
    - [2. æ·»åŠ ä¸Šä¸‹æ–‡ä¿¡æ¯](#2-æ·»åŠ ä¸Šä¸‹æ–‡ä¿¡æ¯)
    - [3. é”™è¯¯å¤„ç†ä¸€è‡´æ€§](#3-é”™è¯¯å¤„ç†ä¸€è‡´æ€§)
    - [4. é€‚å½“çš„é”™è¯¯ç²’åº¦](#4-é€‚å½“çš„é”™è¯¯ç²’åº¦)
    - [5. é”™è¯¯æ—¥å¿—è®°å½•](#5-é”™è¯¯æ—¥å¿—è®°å½•)
  - [DON'Ts âŒ](#donts-)
- [6. ç”Ÿäº§ç¯å¢ƒå®æˆ˜](#6-ç”Ÿäº§ç¯å¢ƒå®æˆ˜)
  - [å®Œæ•´é”™è¯¯å¤„ç†æ¶æ„](#å®Œæ•´é”™è¯¯å¤„ç†æ¶æ„)
  - [ä½¿ç”¨ç¤ºä¾‹](#ä½¿ç”¨ç¤ºä¾‹)

## 1. é”™è¯¯å¤„ç†åŸºç¡€

### erroræ¥å£

```go
// erroræ˜¯Goçš„å†…ç½®æ¥å£
type error interface {
    Error() string
}
```

### åˆ›å»ºé”™è¯¯

```go
import (
    "errors"
    "fmt"
)

// 1. errors.New
err1 := errors.New("something went wrong")

// 2. fmt.Errorf
err2 := fmt.Errorf("failed to connect to %s", host)

// 3. è‡ªå®šä¹‰errorç±»å‹
type CustomError struct {
    Code    int
    Message string
}

func (e *CustomError) Error() string {
    return fmt.Sprintf("error %d: %s", e.Code, e.Message)
}

err3 := &CustomError{Code: 500, Message: "internal error"}
```

### é”™è¯¯æ£€æŸ¥

```go
// âœ… æ ‡å‡†æ¨¡å¼
result, err := someFunction()
if err != nil {
    // å¤„ç†é”™è¯¯
    return err
}
// ä½¿ç”¨result

// âŒ ä¸æ¨è - å¿½ç•¥é”™è¯¯
result, _ := someFunction()  // å±é™©ï¼

// âŒ ä¸æ¨è - å»¶è¿Ÿæ£€æŸ¥
result1, err1 := func1()
result2, err2 := func2()
if err1 != nil || err2 != nil {  // å¤ªæ™šäº†
    // ...
}
```

---

## 2. é”™è¯¯åŒ…è£…å’Œè§£åŒ…

### é”™è¯¯åŒ…è£…ï¼ˆWrapping)

```go
import (
    "errors"
    "fmt"
)

func ReadConfig(filename string) (*Config, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        // ä½¿ç”¨%wåŒ…è£…é”™è¯¯ï¼Œä¿ç•™åŸå§‹é”™è¯¯
        return nil, fmt.Errorf("failed to read config file: %w", err)
    }
    
    var config Config
    if err := json.Unmarshal(data, &config); err != nil {
        return nil, fmt.Errorf("failed to parse config: %w", err)
    }
    
    return &config, nil
}
```

### é”™è¯¯è§£åŒ…ï¼ˆUnwrapping)

```go
// errors.Is - æ£€æŸ¥é”™è¯¯é“¾ä¸­æ˜¯å¦åŒ…å«ç‰¹å®šé”™è¯¯
if errors.Is(err, os.ErrNotExist) {
    fmt.Println("file does not exist")
}

// errors.As - æå–é”™è¯¯é“¾ä¸­çš„ç‰¹å®šç±»å‹
var pathError *os.PathError
if errors.As(err, &pathError) {
    fmt.Printf("failed path: %s\n", pathError.Path)
}
```

### å®Œæ•´ç¤ºä¾‹

```go
package main

import (
    "errors"
    "fmt"
    "os"
)

var (
    ErrInvalidInput = errors.New("invalid input")
    ErrNotFound     = errors.New("not found")
)

func GetUser(id int) (*User, error) {
    if id <= 0 {
        return nil, fmt.Errorf("get user: %w", ErrInvalidInput)
    }
    
    user, err := db.FindUser(id)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, fmt.Errorf("get user %d: %w", id, ErrNotFound)
        }
        return nil, fmt.Errorf("get user %d: %w", id, err)
    }
    
    return user, nil
}

func main() {
    user, err := GetUser(-1)
    if err != nil {
        if errors.Is(err, ErrInvalidInput) {
            fmt.Println("Invalid user ID")
        } else if errors.Is(err, ErrNotFound) {
            fmt.Println("User not found")
        } else {
            fmt.Printf("Unexpected error: %v\n", err)
        }
        return
    }
    
    fmt.Printf("User: %+v\n", user)
}
```

---

## 3. è‡ªå®šä¹‰é”™è¯¯ç±»å‹

### ç®€å•è‡ªå®šä¹‰é”™è¯¯

```go
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation failed for field '%s': %s", e.Field, e.Message)
}

// ä½¿ç”¨
func ValidateUser(user *User) error {
    if user.Email == "" {
        return &ValidationError{
            Field:   "email",
            Message: "email is required",
        }
    }
    return nil
}
```

### å¤æ‚è‡ªå®šä¹‰é”™è¯¯

```go
// HTTPé”™è¯¯
type HTTPError struct {
    StatusCode int
    Message    string
    Err        error  // åŒ…è£…åŸå§‹é”™è¯¯
}

func (e *HTTPError) Error() string {
    if e.Err != nil {
        return fmt.Sprintf("HTTP %d: %s: %v", e.StatusCode, e.Message, e.Err)
    }
    return fmt.Sprintf("HTTP %d: %s", e.StatusCode, e.Message)
}

func (e *HTTPError) Unwrap() error {
    return e.Err
}

// ä¸šåŠ¡é”™è¯¯
type BusinessError struct {
    Code    string
    Message string
    Details map[string]interface{}
}

func (e *BusinessError) Error() string {
    return fmt.Sprintf("[%s] %s", e.Code, e.Message)
}

func (e *BusinessError) WithDetails(key string, value interface{}) *BusinessError {
    if e.Details == nil {
        e.Details = make(map[string]interface{})
    }
    e.Details[key] = value
    return e
}

// ä½¿ç”¨
func ProcessOrder(order *Order) error {
    if order.Amount <= 0 {
        return &BusinessError{
            Code:    "INVALID_AMOUNT",
            Message: "order amount must be greater than 0",
        }.WithDetails("order_id", order.ID).WithDetails("amount", order.Amount)
    }
    return nil
}
```

### é”™è¯¯ç»„ï¼ˆMultiple Errors)

```go
// æ–¹æ¡ˆ1: ä½¿ç”¨slice
type MultiError struct {
    Errors []error
}

func (m *MultiError) Error() string {
    var messages []string
    for _, err := range m.Errors {
        messages = append(messages, err.Error())
    }
    return strings.Join(messages, "; ")
}

func (m *MultiError) Add(err error) {
    if err != nil {
        m.Errors = append(m.Errors, err)
    }
}

func (m *MultiError) HasErrors() bool {
    return len(m.Errors) > 0
}

// ä½¿ç”¨
func ValidateUser(user *User) error {
    var errs MultiError
    
    if user.Name == "" {
        errs.Add(errors.New("name is required"))
    }
    if user.Email == "" {
        errs.Add(errors.New("email is required"))
    }
    if !strings.Contains(user.Email, "@") {
        errs.Add(errors.New("invalid email format"))
    }
    
    if errs.HasErrors() {
        return &errs
    }
    return nil
}

// æ–¹æ¡ˆ2: ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“
import "github.com/hashicorp/go-multierror"

func ProcessBatch(items []Item) error {
    var result error
    
    for _, item := range items {
        if err := processItem(item); err != nil {
            result = multierror.Append(result, err)
        }
    }
    
    return result
}
```

---

## 4. é”™è¯¯å¤„ç†æ¨¡å¼

### å“¨å…µé”™è¯¯ï¼ˆSentinel Errors)

```go
package user

import "errors"

// å®šä¹‰åŒ…çº§åˆ«çš„é”™è¯¯å¸¸é‡
var (
    ErrUserNotFound      = errors.New("user not found")
    ErrInvalidCredentials = errors.New("invalid credentials")
    ErrUserAlreadyExists = errors.New("user already exists")
    ErrPermissionDenied  = errors.New("permission denied")
)

// ä½¿ç”¨
func GetUser(id int) (*User, error) {
    user, err := db.FindUser(id)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, ErrUserNotFound
        }
        return nil, fmt.Errorf("failed to get user: %w", err)
    }
    return user, nil
}

// è°ƒç”¨æ–¹
user, err := GetUser(123)
if errors.Is(err, user.ErrUserNotFound) {
    // ç‰¹å®šå¤„ç†
}
```

### é”™è¯¯ç±»å‹æ–­è¨€

```go
// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
type TemporaryError interface {
    error
    Temporary() bool
}

type NetworkError struct {
    Op  string
    Err error
}

func (e *NetworkError) Error() string {
    return fmt.Sprintf("network error during %s: %v", e.Op, e.Err)
}

func (e *NetworkError) Temporary() bool {
    return true
}

func (e *NetworkError) Unwrap() error {
    return e.Err
}

// ä½¿ç”¨
func DoRequest() error {
    err := makeHTTPRequest()
    if err != nil {
        var tempErr TemporaryError
        if errors.As(err, &tempErr) && tempErr.Temporary() {
            // å¯ä»¥é‡è¯•
            return retry(makeHTTPRequest)
        }
        return err
    }
    return nil
}
```

### Panicå’ŒRecover

```go
// âœ… åˆç†ä½¿ç”¨panic - åˆå§‹åŒ–å¤±è´¥
func MustLoadConfig() *Config {
    config, err := LoadConfig()
    if err != nil {
        panic(fmt.Sprintf("failed to load config: %v", err))
    }
    return config
}

// âœ… ä½¿ç”¨recoverä¿æŠ¤goroutine
func SafeGoroutine(fn func()) {
    go func() {
        defer func() {
            if r := recover(); r != nil {
                log.Printf("Recovered from panic: %v\n%s", r, debug.Stack())
            }
        }()
        fn()
    }()
}

// âœ… HTTP handlerä¸­çš„recover
func RecoverMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                log.Printf("Panic: %v\n%s", err, debug.Stack())
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
            }
        }()
        next.ServeHTTP(w, r)
    })
}

// âŒ ä¸è¦åœ¨ä¸šåŠ¡é€»è¾‘ä¸­ä½¿ç”¨panic/recoveråšæµç¨‹æ§åˆ¶
func ProcessOrder(order *Order) (err error) {
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("processing failed: %v", r)  // ä¸æ¨è
        }
    }()
    
    if order.Amount <= 0 {
        panic("invalid amount")  // ä¸æ¨è
    }
    return nil
}
```

---

## 5. é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

### DO's âœ…

#### 1. å°½æ—©è¿”å›é”™è¯¯

```go
// âœ… æ¨è - Guardå­å¥ï¼Œå‡å°‘åµŒå¥—
func ProcessUser(user *User) error {
    if user == nil {
        return errors.New("user is nil")
    }
    
    if user.ID <= 0 {
        return errors.New("invalid user ID")
    }
    
    if user.Email == "" {
        return errors.New("email is required")
    }
    
    // ä¸»è¦é€»è¾‘
    return saveUser(user)
}

// âŒ ä¸æ¨è - è¿‡å¤šåµŒå¥—
func ProcessUser(user *User) error {
    if user != nil {
        if user.ID > 0 {
            if user.Email != "" {
                // ä¸»è¦é€»è¾‘
                return saveUser(user)
            } else {
                return errors.New("email is required")
            }
        } else {
            return errors.New("invalid user ID")
        }
    } else {
        return errors.New("user is nil")
    }
}
```

#### 2. æ·»åŠ ä¸Šä¸‹æ–‡ä¿¡æ¯

```go
// âŒ ä¸æ¨è - ç¼ºå°‘ä¸Šä¸‹æ–‡
func GetUser(id int) (*User, error) {
    user, err := db.Query(...)
    if err != nil {
        return nil, err  // ä¸çŸ¥é“åœ¨å“ªé‡Œå‡ºé”™
    }
    return user, nil
}

// âœ… æ¨è - æ·»åŠ ä¸Šä¸‹æ–‡
func GetUser(id int) (*User, error) {
    user, err := db.Query(...)
    if err != nil {
        return nil, fmt.Errorf("failed to get user %d: %w", id, err)
    }
    return user, nil
}
```

#### 3. é”™è¯¯å¤„ç†ä¸€è‡´æ€§

```go
// å®šä¹‰ç»Ÿä¸€çš„é”™è¯¯å“åº”ç»“æ„
type ErrorResponse struct {
    Code    string `json:"code"`
    Message string `json:"message"`
    Details map[string]interface{} `json:"details,omitempty"`
}

// ç»Ÿä¸€çš„é”™è¯¯å¤„ç†å‡½æ•°
func HandleError(w http.ResponseWriter, err error) {
    var httpErr *HTTPError
    var bizErr *BusinessError
    
    var response ErrorResponse
    var statusCode int
    
    switch {
    case errors.As(err, &httpErr):
        statusCode = httpErr.StatusCode
        response.Code = fmt.Sprintf("HTTP_%d", httpErr.StatusCode)
        response.Message = httpErr.Message
        
    case errors.As(err, &bizErr):
        statusCode = http.StatusBadRequest
        response.Code = bizErr.Code
        response.Message = bizErr.Message
        response.Details = bizErr.Details
        
    case errors.Is(err, ErrUserNotFound):
        statusCode = http.StatusNotFound
        response.Code = "USER_NOT_FOUND"
        response.Message = "User not found"
        
    default:
        statusCode = http.StatusInternalServerError
        response.Code = "INTERNAL_ERROR"
        response.Message = "An internal error occurred"
        
        // è®°å½•è¯¦ç»†é”™è¯¯
        log.Printf("Internal error: %+v", err)
    }
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(statusCode)
    json.NewEncoder(w).Encode(response)
}
```

#### 4. é€‚å½“çš„é”™è¯¯ç²’åº¦

```go
// âœ… åˆé€‚çš„ç²’åº¦
var (
    ErrInvalidInput = errors.New("invalid input")
    ErrNotFound     = errors.New("resource not found")
    ErrConflict     = errors.New("resource conflict")
    ErrUnauthorized = errors.New("unauthorized")
)

// âŒ è¿‡äºç»†ç²’åº¦
var (
    ErrUserNameEmpty = errors.New("username is empty")
    ErrUserNameTooShort = errors.New("username is too short")
    ErrUserNameTooLong = errors.New("username is too long")
    ErrUserNameInvalidChar = errors.New("username contains invalid characters")
    // ... 100+ é”™è¯¯å®šä¹‰
)

// âœ… æ›´å¥½çš„æ–¹å¼ - ä½¿ç”¨è‡ªå®šä¹‰é”™è¯¯ç±»å‹
type ValidationError struct {
    Field   string
    Value   interface{}
    Message string
}
```

#### 5. é”™è¯¯æ—¥å¿—è®°å½•

```go
func ProcessOrder(ctx context.Context, order *Order) error {
    logger := GetLogger(ctx)
    
    if err := validateOrder(order); err != nil {
        // ä¸šåŠ¡é”™è¯¯ï¼ŒINFOçº§åˆ«
        logger.Info("order validation failed",
            "order_id", order.ID,
            "error", err.Error(),
        )
        return err
    }
    
    if err := saveOrder(order); err != nil {
        // ç³»ç»Ÿé”™è¯¯ï¼ŒERRORçº§åˆ«
        logger.Error("failed to save order",
            "order_id", order.ID,
            "error", err.Error(),
            "stack", string(debug.Stack()),
        )
        return fmt.Errorf("failed to save order: %w", err)
    }
    
    return nil
}
```

### DON'Ts âŒ

```go
// âŒ 1. ä¸è¦åæ‰é”™è¯¯
func BadExample1() {
    data, _ := fetchData()  // å¿½ç•¥é”™è¯¯
    process(data)
}

// âŒ 2. ä¸è¦é‡å¤åŒ…è£…é”™è¯¯
func BadExample2() error {
    err := doSomething()
    if err != nil {
        log.Printf("error: %v", err)           // è®°å½•
        return fmt.Errorf("failed: %w", err)   // åŒ…è£…
    }
    return nil
}
// è°ƒç”¨æ–¹ä¹Ÿè®°å½•å’ŒåŒ…è£…ï¼Œå¯¼è‡´é‡å¤

// âŒ 3. ä¸è¦åœ¨é”™è¯¯ä¸­åŒ…å«æ•æ„Ÿä¿¡æ¯
func BadExample3(password string) error {
    return fmt.Errorf("authentication failed for password: %s", password)
}

// âŒ 4. ä¸è¦ä½¿ç”¨panicå¤„ç†ä¸šåŠ¡é€»è¾‘
func BadExample4(amount float64) {
    if amount <= 0 {
        panic("invalid amount")  // åº”è¯¥è¿”å›error
    }
}

// âŒ 5. ä¸è¦å¿½ç•¥deferä¸­çš„é”™è¯¯
func BadExample5() error {
    f, err := os.Open("file.txt")
    if err != nil {
        return err
    }
    defer f.Close()  // å¿½ç•¥Closeçš„é”™è¯¯
    
    return process(f)
}

// âœ… æ­£ç¡®å¤„ç†deferä¸­çš„é”™è¯¯
func GoodExample5() (err error) {
    f, err := os.Open("file.txt")
    if err != nil {
        return err
    }
    defer func() {
        if closeErr := f.Close(); closeErr != nil && err == nil {
            err = closeErr
        }
    }()
    
    return process(f)
}
```

---

## 6. ç”Ÿäº§ç¯å¢ƒå®æˆ˜

### å®Œæ•´é”™è¯¯å¤„ç†æ¶æ„

```go
package errors

import (
    "fmt"
    "runtime"
)

// é”™è¯¯ä»£ç 
type ErrorCode string

const (
    CodeValidation   ErrorCode = "VALIDATION_ERROR"
    CodeNotFound     ErrorCode = "NOT_FOUND"
    CodeConflict     ErrorCode = "CONFLICT"
    CodeUnauthorized ErrorCode = "UNAUTHORIZED"
    CodeInternal     ErrorCode = "INTERNAL_ERROR"
)

// åº”ç”¨é”™è¯¯
type AppError struct {
    Code    ErrorCode
    Message string
    Err     error
    Stack   []uintptr
    Details map[string]interface{}
}

func (e *AppError) Error() string {
    if e.Err != nil {
        return fmt.Sprintf("[%s] %s: %v", e.Code, e.Message, e.Err)
    }
    return fmt.Sprintf("[%s] %s", e.Code, e.Message)
}

func (e *AppError) Unwrap() error {
    return e.Err
}

// æ„é€ å‡½æ•°
func New(code ErrorCode, message string) *AppError {
    return &AppError{
        Code:    code,
        Message: message,
        Stack:   captureStack(),
        Details: make(map[string]interface{}),
    }
}

func Wrap(err error, code ErrorCode, message string) *AppError {
    return &AppError{
        Code:    code,
        Message: message,
        Err:     err,
        Stack:   captureStack(),
        Details: make(map[string]interface{}),
    }
}

// é“¾å¼æ–¹æ³•
func (e *AppError) WithDetail(key string, value interface{}) *AppError {
    e.Details[key] = value
    return e
}

// æ•è·å †æ ˆ
func captureStack() []uintptr {
    const depth = 32
    var pcs [depth]uintptr
    n := runtime.Callers(3, pcs[:])
    return pcs[0:n]
}

// HTTPçŠ¶æ€ç æ˜ å°„
func (e *AppError) HTTPStatus() int {
    switch e.Code {
    case CodeValidation:
        return 400
    case CodeUnauthorized:
        return 401
    case CodeNotFound:
        return 404
    case CodeConflict:
        return 409
    default:
        return 500
    }
}
```

### ä½¿ç”¨ç¤ºä¾‹

```go
package service

import (
    "myapp/errors"
)

func GetUser(id int) (*User, error) {
    if id <= 0 {
        return nil, errors.New(errors.CodeValidation, "invalid user ID").
            WithDetail("user_id", id)
    }
    
    user, err := db.FindUser(id)
    if err != nil {
        if isNotFoundError(err) {
            return nil, errors.Wrap(err, errors.CodeNotFound, "user not found").
                WithDetail("user_id", id)
        }
        return nil, errors.Wrap(err, errors.CodeInternal, "failed to query user").
            WithDetail("user_id", id)
    }
    
    return user, nil
}

// HTTP Handler
func UserHandler(w http.ResponseWriter, r *http.Request) {
    id := getIDFromRequest(r)
    
    user, err := GetUser(id)
    if err != nil {
        handleHTTPError(w, err)
        return
    }
    
    json.NewEncoder(w).Encode(user)
}

func handleHTTPError(w http.ResponseWriter, err error) {
    var appErr *errors.AppError
    if errors.As(err, &appErr) {
        w.WriteHeader(appErr.HTTPStatus())
        json.NewEncoder(w).Encode(map[string]interface{}{
            "code":    appErr.Code,
            "message": appErr.Message,
            "details": appErr.Details,
        })
        return
    }
    
    // æœªçŸ¥é”™è¯¯
    w.WriteHeader(500)
    json.NewEncoder(w).Encode(map[string]interface{}{
        "code":    "INTERNAL_ERROR",
        "message": "An internal error occurred",
    })
}
```

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ24æ—¥  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.21+
