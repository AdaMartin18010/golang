# Go错误处理最佳实践完全指南

> **简介**: Go语言错误处理的完整实践指南，包括error接口、错误包装、自定义错误和错误处理模式

---

## 📋 目录


- [1. 错误处理基础](#1-错误处理基础)
  - [error接口](#error接口)
  - [创建错误](#创建错误)
  - [错误检查](#错误检查)
- [2. 错误包装和解包](#2-错误包装和解包)
  - [错误包装（Wrapping)](#错误包装wrapping)
  - [错误解包（Unwrapping)](#错误解包unwrapping)
  - [完整示例](#完整示例)
- [3. 自定义错误类型](#3-自定义错误类型)
  - [简单自定义错误](#简单自定义错误)
  - [复杂自定义错误](#复杂自定义错误)
  - [错误组（Multiple Errors)](#错误组multiple-errors)
- [4. 错误处理模式](#4-错误处理模式)
  - [哨兵错误（Sentinel Errors)](#哨兵错误sentinel-errors)
  - [错误类型断言](#错误类型断言)
  - [Panic和Recover](#panic和recover)
- [5. 错误处理最佳实践](#5-错误处理最佳实践)
  - [DO's ✅](#dos-)
    - [1. 尽早返回错误](#1-尽早返回错误)
    - [2. 添加上下文信息](#2-添加上下文信息)
    - [3. 错误处理一致性](#3-错误处理一致性)
    - [4. 适当的错误粒度](#4-适当的错误粒度)
    - [5. 错误日志记录](#5-错误日志记录)
  - [DON'Ts ❌](#donts-)
- [6. 生产环境实战](#6-生产环境实战)
  - [完整错误处理架构](#完整错误处理架构)
  - [使用示例](#使用示例)

## 1. 错误处理基础

### error接口

```go
// error是Go的内置接口
type error interface {
    Error() string
}
```

### 创建错误

```go
import (
    "errors"
    "fmt"
)

// 1. errors.New
err1 := errors.New("something went wrong")

// 2. fmt.Errorf
err2 := fmt.Errorf("failed to connect to %s", host)

// 3. 自定义error类型
type CustomError struct {
    Code    int
    Message string
}

func (e *CustomError) Error() string {
    return fmt.Sprintf("error %d: %s", e.Code, e.Message)
}

err3 := &CustomError{Code: 500, Message: "internal error"}
```

### 错误检查

```go
// ✅ 标准模式
result, err := someFunction()
if err != nil {
    // 处理错误
    return err
}
// 使用result

// ❌ 不推荐 - 忽略错误
result, _ := someFunction()  // 危险！

// ❌ 不推荐 - 延迟检查
result1, err1 := func1()
result2, err2 := func2()
if err1 != nil || err2 != nil {  // 太晚了
    // ...
}
```

---

## 2. 错误包装和解包

### 错误包装（Wrapping)

```go
import (
    "errors"
    "fmt"
)

func ReadConfig(filename string) (*Config, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        // 使用%w包装错误，保留原始错误
        return nil, fmt.Errorf("failed to read config file: %w", err)
    }
    
    var config Config
    if err := json.Unmarshal(data, &config); err != nil {
        return nil, fmt.Errorf("failed to parse config: %w", err)
    }
    
    return &config, nil
}
```

### 错误解包（Unwrapping)

```go
// errors.Is - 检查错误链中是否包含特定错误
if errors.Is(err, os.ErrNotExist) {
    fmt.Println("file does not exist")
}

// errors.As - 提取错误链中的特定类型
var pathError *os.PathError
if errors.As(err, &pathError) {
    fmt.Printf("failed path: %s\n", pathError.Path)
}
```

### 完整示例

```go
package main

import (
    "errors"
    "fmt"
    "os"
)

var (
    ErrInvalidInput = errors.New("invalid input")
    ErrNotFound     = errors.New("not found")
)

func GetUser(id int) (*User, error) {
    if id <= 0 {
        return nil, fmt.Errorf("get user: %w", ErrInvalidInput)
    }
    
    user, err := db.FindUser(id)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, fmt.Errorf("get user %d: %w", id, ErrNotFound)
        }
        return nil, fmt.Errorf("get user %d: %w", id, err)
    }
    
    return user, nil
}

func main() {
    user, err := GetUser(-1)
    if err != nil {
        if errors.Is(err, ErrInvalidInput) {
            fmt.Println("Invalid user ID")
        } else if errors.Is(err, ErrNotFound) {
            fmt.Println("User not found")
        } else {
            fmt.Printf("Unexpected error: %v\n", err)
        }
        return
    }
    
    fmt.Printf("User: %+v\n", user)
}
```

---

## 3. 自定义错误类型

### 简单自定义错误

```go
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation failed for field '%s': %s", e.Field, e.Message)
}

// 使用
func ValidateUser(user *User) error {
    if user.Email == "" {
        return &ValidationError{
            Field:   "email",
            Message: "email is required",
        }
    }
    return nil
}
```

### 复杂自定义错误

```go
// HTTP错误
type HTTPError struct {
    StatusCode int
    Message    string
    Err        error  // 包装原始错误
}

func (e *HTTPError) Error() string {
    if e.Err != nil {
        return fmt.Sprintf("HTTP %d: %s: %v", e.StatusCode, e.Message, e.Err)
    }
    return fmt.Sprintf("HTTP %d: %s", e.StatusCode, e.Message)
}

func (e *HTTPError) Unwrap() error {
    return e.Err
}

// 业务错误
type BusinessError struct {
    Code    string
    Message string
    Details map[string]interface{}
}

func (e *BusinessError) Error() string {
    return fmt.Sprintf("[%s] %s", e.Code, e.Message)
}

func (e *BusinessError) WithDetails(key string, value interface{}) *BusinessError {
    if e.Details == nil {
        e.Details = make(map[string]interface{})
    }
    e.Details[key] = value
    return e
}

// 使用
func ProcessOrder(order *Order) error {
    if order.Amount <= 0 {
        return &BusinessError{
            Code:    "INVALID_AMOUNT",
            Message: "order amount must be greater than 0",
        }.WithDetails("order_id", order.ID).WithDetails("amount", order.Amount)
    }
    return nil
}
```

### 错误组（Multiple Errors)

```go
// 方案1: 使用slice
type MultiError struct {
    Errors []error
}

func (m *MultiError) Error() string {
    var messages []string
    for _, err := range m.Errors {
        messages = append(messages, err.Error())
    }
    return strings.Join(messages, "; ")
}

func (m *MultiError) Add(err error) {
    if err != nil {
        m.Errors = append(m.Errors, err)
    }
}

func (m *MultiError) HasErrors() bool {
    return len(m.Errors) > 0
}

// 使用
func ValidateUser(user *User) error {
    var errs MultiError
    
    if user.Name == "" {
        errs.Add(errors.New("name is required"))
    }
    if user.Email == "" {
        errs.Add(errors.New("email is required"))
    }
    if !strings.Contains(user.Email, "@") {
        errs.Add(errors.New("invalid email format"))
    }
    
    if errs.HasErrors() {
        return &errs
    }
    return nil
}

// 方案2: 使用第三方库
import "github.com/hashicorp/go-multierror"

func ProcessBatch(items []Item) error {
    var result error
    
    for _, item := range items {
        if err := processItem(item); err != nil {
            result = multierror.Append(result, err)
        }
    }
    
    return result
}
```

---

## 4. 错误处理模式

### 哨兵错误（Sentinel Errors)

```go
package user

import "errors"

// 定义包级别的错误常量
var (
    ErrUserNotFound      = errors.New("user not found")
    ErrInvalidCredentials = errors.New("invalid credentials")
    ErrUserAlreadyExists = errors.New("user already exists")
    ErrPermissionDenied  = errors.New("permission denied")
)

// 使用
func GetUser(id int) (*User, error) {
    user, err := db.FindUser(id)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, ErrUserNotFound
        }
        return nil, fmt.Errorf("failed to get user: %w", err)
    }
    return user, nil
}

// 调用方
user, err := GetUser(123)
if errors.Is(err, user.ErrUserNotFound) {
    // 特定处理
}
```

### 错误类型断言

```go
// 自定义错误类型
type TemporaryError interface {
    error
    Temporary() bool
}

type NetworkError struct {
    Op  string
    Err error
}

func (e *NetworkError) Error() string {
    return fmt.Sprintf("network error during %s: %v", e.Op, e.Err)
}

func (e *NetworkError) Temporary() bool {
    return true
}

func (e *NetworkError) Unwrap() error {
    return e.Err
}

// 使用
func DoRequest() error {
    err := makeHTTPRequest()
    if err != nil {
        var tempErr TemporaryError
        if errors.As(err, &tempErr) && tempErr.Temporary() {
            // 可以重试
            return retry(makeHTTPRequest)
        }
        return err
    }
    return nil
}
```

### Panic和Recover

```go
// ✅ 合理使用panic - 初始化失败
func MustLoadConfig() *Config {
    config, err := LoadConfig()
    if err != nil {
        panic(fmt.Sprintf("failed to load config: %v", err))
    }
    return config
}

// ✅ 使用recover保护goroutine
func SafeGoroutine(fn func()) {
    go func() {
        defer func() {
            if r := recover(); r != nil {
                log.Printf("Recovered from panic: %v\n%s", r, debug.Stack())
            }
        }()
        fn()
    }()
}

// ✅ HTTP handler中的recover
func RecoverMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                log.Printf("Panic: %v\n%s", err, debug.Stack())
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
            }
        }()
        next.ServeHTTP(w, r)
    })
}

// ❌ 不要在业务逻辑中使用panic/recover做流程控制
func ProcessOrder(order *Order) (err error) {
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("processing failed: %v", r)  // 不推荐
        }
    }()
    
    if order.Amount <= 0 {
        panic("invalid amount")  // 不推荐
    }
    return nil
}
```

---

## 5. 错误处理最佳实践

### DO's ✅

#### 1. 尽早返回错误

```go
// ✅ 推荐 - Guard子句，减少嵌套
func ProcessUser(user *User) error {
    if user == nil {
        return errors.New("user is nil")
    }
    
    if user.ID <= 0 {
        return errors.New("invalid user ID")
    }
    
    if user.Email == "" {
        return errors.New("email is required")
    }
    
    // 主要逻辑
    return saveUser(user)
}

// ❌ 不推荐 - 过多嵌套
func ProcessUser(user *User) error {
    if user != nil {
        if user.ID > 0 {
            if user.Email != "" {
                // 主要逻辑
                return saveUser(user)
            } else {
                return errors.New("email is required")
            }
        } else {
            return errors.New("invalid user ID")
        }
    } else {
        return errors.New("user is nil")
    }
}
```

#### 2. 添加上下文信息

```go
// ❌ 不推荐 - 缺少上下文
func GetUser(id int) (*User, error) {
    user, err := db.Query(...)
    if err != nil {
        return nil, err  // 不知道在哪里出错
    }
    return user, nil
}

// ✅ 推荐 - 添加上下文
func GetUser(id int) (*User, error) {
    user, err := db.Query(...)
    if err != nil {
        return nil, fmt.Errorf("failed to get user %d: %w", id, err)
    }
    return user, nil
}
```

#### 3. 错误处理一致性

```go
// 定义统一的错误响应结构
type ErrorResponse struct {
    Code    string `json:"code"`
    Message string `json:"message"`
    Details map[string]interface{} `json:"details,omitempty"`
}

// 统一的错误处理函数
func HandleError(w http.ResponseWriter, err error) {
    var httpErr *HTTPError
    var bizErr *BusinessError
    
    var response ErrorResponse
    var statusCode int
    
    switch {
    case errors.As(err, &httpErr):
        statusCode = httpErr.StatusCode
        response.Code = fmt.Sprintf("HTTP_%d", httpErr.StatusCode)
        response.Message = httpErr.Message
        
    case errors.As(err, &bizErr):
        statusCode = http.StatusBadRequest
        response.Code = bizErr.Code
        response.Message = bizErr.Message
        response.Details = bizErr.Details
        
    case errors.Is(err, ErrUserNotFound):
        statusCode = http.StatusNotFound
        response.Code = "USER_NOT_FOUND"
        response.Message = "User not found"
        
    default:
        statusCode = http.StatusInternalServerError
        response.Code = "INTERNAL_ERROR"
        response.Message = "An internal error occurred"
        
        // 记录详细错误
        log.Printf("Internal error: %+v", err)
    }
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(statusCode)
    json.NewEncoder(w).Encode(response)
}
```

#### 4. 适当的错误粒度

```go
// ✅ 合适的粒度
var (
    ErrInvalidInput = errors.New("invalid input")
    ErrNotFound     = errors.New("resource not found")
    ErrConflict     = errors.New("resource conflict")
    ErrUnauthorized = errors.New("unauthorized")
)

// ❌ 过于细粒度
var (
    ErrUserNameEmpty = errors.New("username is empty")
    ErrUserNameTooShort = errors.New("username is too short")
    ErrUserNameTooLong = errors.New("username is too long")
    ErrUserNameInvalidChar = errors.New("username contains invalid characters")
    // ... 100+ 错误定义
)

// ✅ 更好的方式 - 使用自定义错误类型
type ValidationError struct {
    Field   string
    Value   interface{}
    Message string
}
```

#### 5. 错误日志记录

```go
func ProcessOrder(ctx context.Context, order *Order) error {
    logger := GetLogger(ctx)
    
    if err := validateOrder(order); err != nil {
        // 业务错误，INFO级别
        logger.Info("order validation failed",
            "order_id", order.ID,
            "error", err.Error(),
        )
        return err
    }
    
    if err := saveOrder(order); err != nil {
        // 系统错误，ERROR级别
        logger.Error("failed to save order",
            "order_id", order.ID,
            "error", err.Error(),
            "stack", string(debug.Stack()),
        )
        return fmt.Errorf("failed to save order: %w", err)
    }
    
    return nil
}
```

### DON'Ts ❌

```go
// ❌ 1. 不要吞掉错误
func BadExample1() {
    data, _ := fetchData()  // 忽略错误
    process(data)
}

// ❌ 2. 不要重复包装错误
func BadExample2() error {
    err := doSomething()
    if err != nil {
        log.Printf("error: %v", err)           // 记录
        return fmt.Errorf("failed: %w", err)   // 包装
    }
    return nil
}
// 调用方也记录和包装，导致重复

// ❌ 3. 不要在错误中包含敏感信息
func BadExample3(password string) error {
    return fmt.Errorf("authentication failed for password: %s", password)
}

// ❌ 4. 不要使用panic处理业务逻辑
func BadExample4(amount float64) {
    if amount <= 0 {
        panic("invalid amount")  // 应该返回error
    }
}

// ❌ 5. 不要忽略defer中的错误
func BadExample5() error {
    f, err := os.Open("file.txt")
    if err != nil {
        return err
    }
    defer f.Close()  // 忽略Close的错误
    
    return process(f)
}

// ✅ 正确处理defer中的错误
func GoodExample5() (err error) {
    f, err := os.Open("file.txt")
    if err != nil {
        return err
    }
    defer func() {
        if closeErr := f.Close(); closeErr != nil && err == nil {
            err = closeErr
        }
    }()
    
    return process(f)
}
```

---

## 6. 生产环境实战

### 完整错误处理架构

```go
package errors

import (
    "fmt"
    "runtime"
)

// 错误代码
type ErrorCode string

const (
    CodeValidation   ErrorCode = "VALIDATION_ERROR"
    CodeNotFound     ErrorCode = "NOT_FOUND"
    CodeConflict     ErrorCode = "CONFLICT"
    CodeUnauthorized ErrorCode = "UNAUTHORIZED"
    CodeInternal     ErrorCode = "INTERNAL_ERROR"
)

// 应用错误
type AppError struct {
    Code    ErrorCode
    Message string
    Err     error
    Stack   []uintptr
    Details map[string]interface{}
}

func (e *AppError) Error() string {
    if e.Err != nil {
        return fmt.Sprintf("[%s] %s: %v", e.Code, e.Message, e.Err)
    }
    return fmt.Sprintf("[%s] %s", e.Code, e.Message)
}

func (e *AppError) Unwrap() error {
    return e.Err
}

// 构造函数
func New(code ErrorCode, message string) *AppError {
    return &AppError{
        Code:    code,
        Message: message,
        Stack:   captureStack(),
        Details: make(map[string]interface{}),
    }
}

func Wrap(err error, code ErrorCode, message string) *AppError {
    return &AppError{
        Code:    code,
        Message: message,
        Err:     err,
        Stack:   captureStack(),
        Details: make(map[string]interface{}),
    }
}

// 链式方法
func (e *AppError) WithDetail(key string, value interface{}) *AppError {
    e.Details[key] = value
    return e
}

// 捕获堆栈
func captureStack() []uintptr {
    const depth = 32
    var pcs [depth]uintptr
    n := runtime.Callers(3, pcs[:])
    return pcs[0:n]
}

// HTTP状态码映射
func (e *AppError) HTTPStatus() int {
    switch e.Code {
    case CodeValidation:
        return 400
    case CodeUnauthorized:
        return 401
    case CodeNotFound:
        return 404
    case CodeConflict:
        return 409
    default:
        return 500
    }
}
```

### 使用示例

```go
package service

import (
    "myapp/errors"
)

func GetUser(id int) (*User, error) {
    if id <= 0 {
        return nil, errors.New(errors.CodeValidation, "invalid user ID").
            WithDetail("user_id", id)
    }
    
    user, err := db.FindUser(id)
    if err != nil {
        if isNotFoundError(err) {
            return nil, errors.Wrap(err, errors.CodeNotFound, "user not found").
                WithDetail("user_id", id)
        }
        return nil, errors.Wrap(err, errors.CodeInternal, "failed to query user").
            WithDetail("user_id", id)
    }
    
    return user, nil
}

// HTTP Handler
func UserHandler(w http.ResponseWriter, r *http.Request) {
    id := getIDFromRequest(r)
    
    user, err := GetUser(id)
    if err != nil {
        handleHTTPError(w, err)
        return
    }
    
    json.NewEncoder(w).Encode(user)
}

func handleHTTPError(w http.ResponseWriter, err error) {
    var appErr *errors.AppError
    if errors.As(err, &appErr) {
        w.WriteHeader(appErr.HTTPStatus())
        json.NewEncoder(w).Encode(map[string]interface{}{
            "code":    appErr.Code,
            "message": appErr.Message,
            "details": appErr.Details,
        })
        return
    }
    
    // 未知错误
    w.WriteHeader(500)
    json.NewEncoder(w).Encode(map[string]interface{}{
        "code":    "INTERNAL_ERROR",
        "message": "An internal error occurred",
    })
}
```

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025年10月24日  
**文档状态**: ✅ 完成  
**适用版本**: Go 1.21+
