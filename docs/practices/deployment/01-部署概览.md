# 部署概览

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---

## 📋 目录

- [1. 📖 概念介绍](#1.-概念介绍)
- [2. 🎯 部署策略](#2.-部署策略)
  - [2.1 蓝绿部署](#21-蓝绿部署)
  - [2.2 金丝雀发布](#22-金丝雀发布)
  - [2.3 滚动更新](#23-滚动更新)
- [3. 🏗️ 部署架构](#3.-部署架构)
  - [3.1 单体应用部署](#31-单体应用部署)
  - [3.2 微服务部署](#32-微服务部署)
- [4. 🌍 环境管理](#4.-环境管理)
  - [4.1 环境分离](#41-环境分离)
  - [4.2 环境配置](#42-环境配置)
- [5. 📝 配置管理](#5.-配置管理)
  - [5.1 环境变量](#51-环境变量)
  - [5.2 配置文件](#52-配置文件)
  - [5.3 配置中心](#53-配置中心)
- [6. 🔐 Secret管理](#6.-secret管理)
  - [6.1 环境变量](#61-环境变量)
  - [6.2 Kubernetes Secrets](#62-kubernetes-secrets)
  - [6.3 Vault集成](#63-vault集成)
- [7. 📊 健康检查](#7.-健康检查)
- [8. 🚀 优雅关闭](#8.-优雅关闭)
- [9. 💡 最佳实践](#9.-最佳实践)
- [10. 📚 相关资源](#10.-相关资源)

## 1. 📖 概念介绍

部署是将Go应用交付到生产环境的过程。本文介绍Go应用的各种部署策略、环境管理和配置管理方法。

---

## 2. 🎯 部署策略

### 2.1 蓝绿部署

```text
生产流量 → 蓝色环境(当前版本)
            绿色环境(新版本) ← 准备就绪

切换后:
生产流量 → 绿色环境(新版本)
            蓝色环境(旧版本) ← 保留回滚
```

**优势**: 零停机、快速回滚  
**适用**: 关键业务系统

---

### 2.2 金丝雀发布

```text
100%流量 → V1

金丝雀阶段:
90%流量 → V1
10%流量 → V2 (观察指标)

逐步扩大:
50%流量 → V1
50%流量 → V2

最终:
100%流量 → V2
```

**优势**: 风险可控、渐进式  
**适用**: 大规模系统

---

### 2.3 滚动更新

```text
初始: [V1] [V1] [V1] [V1]
步骤1: [V2] [V1] [V1] [V1]
步骤2: [V2] [V2] [V1] [V1]
步骤3: [V2] [V2] [V2] [V1]
完成:  [V2] [V2] [V2] [V2]
```

**优势**: 平滑过渡  
**适用**: Kubernetes环境

---

## 3. 🏗️ 部署架构

### 3.1 单体应用部署

```go
// main.go
package main

import (
    "log"
    "net/http"
    "os"
)

func main() {
    port := os.Getenv("PORT")
    if port == "" {
        port = "8080"
    }
    
    http.HandleFunc("/health", healthCheck)
    http.HandleFunc("/", handler)
    
    log.Printf("Server starting on :%s", port)
    log.Fatal(http.ListenAndServe(":"+port, nil))
}

func healthCheck(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
    w.Write([]byte("OK"))
}
```

---

### 3.2 微服务部署

```yaml
# docker-compose.yml
version: '3'
services:
  api:
    image: myapp/api:latest
    ports:
      - "8080:8080"
    environment:
      - DATABASE_URL=postgres://...
      - REDIS_URL=redis://...
    depends_on:
      - db
      - redis
    
  db:
    image: postgres:15
    environment:
      - POSTGRES_PASSWORD=secret
    
  redis:
    image: redis:7-alpine
```

---

## 4. 🌍 环境管理

### 4.1 环境分离

```text
development (本地开发)
    ↓
testing (测试环境)
    ↓
staging (预发布)
    ↓
production (生产环境)
```

---

### 4.2 环境配置

```go
// config/config.go
package config

import (
    "os"
    "github.com/joho/godotenv"
)

type Config struct {
    Env         string
    Port        string
    DatabaseURL string
    RedisURL    string
}

func Load() (*Config, error) {
    // 加载.env文件
    if err := godotenv.Load(); err != nil {
        // 生产环境可能不需要.env
    }
    
    return &Config{
        Env:         getEnv("ENV", "development"),
        Port:        getEnv("PORT", "8080"),
        DatabaseURL: getEnv("DATABASE_URL", ""),
        RedisURL:    getEnv("REDIS_URL", ""),
    }, nil
}

func getEnv(key, defaultVal string) string {
    if val := os.Getenv(key); val != "" {
        return val
    }
    return defaultVal
}
```

---

## 5. 📝 配置管理

### 5.1 环境变量

```bash
# .env.production
PORT=8080
DATABASE_URL=postgres://prod-db:5432/myapp
REDIS_URL=redis://prod-redis:6379
LOG_LEVEL=info
```

---

### 5.2 配置文件

```yaml
# config.yaml
server:
  port: 8080
  timeout: 30s

database:
  host: localhost
  port: 5432
  name: myapp
  
redis:
  host: localhost
  port: 6379
```

```go
// 读取配置
import "gopkg.in/yaml.v3"

type ServerConfig struct {
    Server struct {
        Port    int    `yaml:"port"`
        Timeout string `yaml:"timeout"`
    } `yaml:"server"`
}

func LoadConfig(path string) (*ServerConfig, error) {
    data, err := os.ReadFile(path)
    if err != nil {
        return nil, err
    }
    
    var cfg ServerConfig
    if err := yaml.Unmarshal(data, &cfg); err != nil {
        return nil, err
    }
    
    return &cfg, nil
}
```

---

### 5.3 配置中心

```go
// 使用Consul
import "github.com/hashicorp/consul/api"

func loadFromConsul() (map[string]string, error) {
    client, _ := api.NewClient(api.DefaultConfig())
    kv := client.KV()
    
    pair, _, err := kv.Get("myapp/config", nil)
    if err != nil {
        return nil, err
    }
    
    // 解析配置
    config := make(map[string]string)
    // ...
    return config, nil
}
```

---

## 6. 🔐 Secret管理

### 6.1 环境变量

```bash
# 从Secret Manager获取
export DB_PASSWORD=$(aws secretsmanager get-secret-value --secret-id db-password --query SecretString --output text)
```

---

### 6.2 Kubernetes Secrets

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
type: Opaque
data:
  database-password: <base64-encoded>
  api-key: <base64-encoded>
```

---

### 6.3 Vault集成

```go
import "github.com/hashicorp/vault/api"

func getSecret(path string) (string, error) {
    client, _ := api.NewClient(nil)
    
    secret, err := client.Logical().Read(path)
    if err != nil {
        return "", err
    }
    
    return secret.Data["value"].(string), nil
}
```

---

## 7. 📊 健康检查

```go
// health/health.go
package health

import (
    "context"
    "database/sql"
    "encoding/json"
    "net/http"
    "time"
)

type HealthCheck struct {
    Status string            `json:"status"`
    Checks map[string]string `json:"checks"`
}

func Handler(db *sql.DB) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        checks := make(map[string]string)
        status := "healthy"
        
        // 检查数据库
        ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
        defer cancel()
        
        if err := db.PingContext(ctx); err != nil {
            checks["database"] = "unhealthy: " + err.Error()
            status = "unhealthy"
        } else {
            checks["database"] = "healthy"
        }
        
        // 响应
        health := HealthCheck{
            Status: status,
            Checks: checks,
        }
        
        w.Header().Set("Content-Type", "application/json")
        if status != "healthy" {
            w.WriteHeader(http.StatusServiceUnavailable)
        }
        json.NewEncoder(w).Encode(health)
    }
}
```

---

## 8. 🚀 优雅关闭

```go
func main() {
    srv := &http.Server{
        Addr:    ":8080",
        Handler: router,
    }
    
    // 启动服务器
    go func() {
        if err := srv.ListenAndServe(); err != http.ErrServerClosed {
            log.Fatal(err)
        }
    }()
    
    // 等待中断信号
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Println("Shutting down server...")
    
    // 优雅关闭（最多30秒）
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    if err := srv.Shutdown(ctx); err != nil {
        log.Fatal("Server forced to shutdown:", err)
    }
    
    log.Println("Server exited")
}
```

---

## 9. 💡 最佳实践

1. **12-Factor App原则**
   - 代码库：一份代码，多处部署
   - 依赖：显式声明依赖
   - 配置：存储在环境中
   - 后端服务：当作附加资源
   - 构建、发布、运行：严格分离

2. **环境一致性**
   - 使用容器确保环境一致
   - 版本锁定依赖
   - Infrastructure as Code

3. **监控和日志**
   - 结构化日志
   - 指标收集
   - 分布式追踪
   - 告警配置

4. **安全性**
   - 最小权限原则
   - Secret加密存储
   - 定期更新依赖
   - 安全扫描

---

## 10. 📚 相关资源

- [12-Factor App](https://12factor.net/)
- [Cloud Native](https://www.cncf.io/)

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3

---

**最后更新**: 2025-10-29
