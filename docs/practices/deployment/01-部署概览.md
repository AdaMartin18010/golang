# éƒ¨ç½²æ¦‚è§ˆ

**éš¾åº¦**: ä¸­çº§ | **é¢„è®¡é˜…è¯»**: 15åˆ†é’Ÿ | **å‰ç½®çŸ¥è¯†**: GoåŸºç¡€ã€DockeråŸºç¡€

---

## ğŸ“– æ¦‚å¿µä»‹ç»

éƒ¨ç½²æ˜¯å°†Goåº”ç”¨äº¤ä»˜åˆ°ç”Ÿäº§ç¯å¢ƒçš„è¿‡ç¨‹ã€‚æœ¬æ–‡ä»‹ç»Goåº”ç”¨çš„å„ç§éƒ¨ç½²ç­–ç•¥ã€ç¯å¢ƒç®¡ç†å’Œé…ç½®ç®¡ç†æ–¹æ³•ã€‚

---

## ğŸ¯ éƒ¨ç½²ç­–ç•¥

### 1. è“ç»¿éƒ¨ç½²

```
ç”Ÿäº§æµé‡ â†’ è“è‰²ç¯å¢ƒ(å½“å‰ç‰ˆæœ¬)
            ç»¿è‰²ç¯å¢ƒ(æ–°ç‰ˆæœ¬) â† å‡†å¤‡å°±ç»ª

åˆ‡æ¢å:
ç”Ÿäº§æµé‡ â†’ ç»¿è‰²ç¯å¢ƒ(æ–°ç‰ˆæœ¬)
            è“è‰²ç¯å¢ƒ(æ—§ç‰ˆæœ¬) â† ä¿ç•™å›æ»š
```

**ä¼˜åŠ¿**: é›¶åœæœºã€å¿«é€Ÿå›æ»š  
**é€‚ç”¨**: å…³é”®ä¸šåŠ¡ç³»ç»Ÿ

---

### 2. é‡‘ä¸é›€å‘å¸ƒ

```
100%æµé‡ â†’ V1

é‡‘ä¸é›€é˜¶æ®µ:
90%æµé‡ â†’ V1
10%æµé‡ â†’ V2 (è§‚å¯ŸæŒ‡æ ‡)

é€æ­¥æ‰©å¤§:
50%æµé‡ â†’ V1
50%æµé‡ â†’ V2

æœ€ç»ˆ:
100%æµé‡ â†’ V2
```

**ä¼˜åŠ¿**: é£é™©å¯æ§ã€æ¸è¿›å¼  
**é€‚ç”¨**: å¤§è§„æ¨¡ç³»ç»Ÿ

---

### 3. æ»šåŠ¨æ›´æ–°

```
åˆå§‹: [V1] [V1] [V1] [V1]
æ­¥éª¤1: [V2] [V1] [V1] [V1]
æ­¥éª¤2: [V2] [V2] [V1] [V1]
æ­¥éª¤3: [V2] [V2] [V2] [V1]
å®Œæˆ:  [V2] [V2] [V2] [V2]
```

**ä¼˜åŠ¿**: å¹³æ»‘è¿‡æ¸¡  
**é€‚ç”¨**: Kubernetesç¯å¢ƒ

---

## ğŸ—ï¸ éƒ¨ç½²æ¶æ„

### å•ä½“åº”ç”¨éƒ¨ç½²

```go
// main.go
package main

import (
    "log"
    "net/http"
    "os"
)

func main() {
    port := os.Getenv("PORT")
    if port == "" {
        port = "8080"
    }
    
    http.HandleFunc("/health", healthCheck)
    http.HandleFunc("/", handler)
    
    log.Printf("Server starting on :%s", port)
    log.Fatal(http.ListenAndServe(":"+port, nil))
}

func healthCheck(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
    w.Write([]byte("OK"))
}
```

---

### å¾®æœåŠ¡éƒ¨ç½²

```yaml
# docker-compose.yml
version: '3'
services:
  api:
    image: myapp/api:latest
    ports:
      - "8080:8080"
    environment:
      - DATABASE_URL=postgres://...
      - REDIS_URL=redis://...
    depends_on:
      - db
      - redis
    
  db:
    image: postgres:15
    environment:
      - POSTGRES_PASSWORD=secret
    
  redis:
    image: redis:7-alpine
```

---

## ğŸŒ ç¯å¢ƒç®¡ç†

### ç¯å¢ƒåˆ†ç¦»

```
development (æœ¬åœ°å¼€å‘)
    â†“
testing (æµ‹è¯•ç¯å¢ƒ)
    â†“
staging (é¢„å‘å¸ƒ)
    â†“
production (ç”Ÿäº§ç¯å¢ƒ)
```

---

### ç¯å¢ƒé…ç½®

```go
// config/config.go
package config

import (
    "os"
    "github.com/joho/godotenv"
)

type Config struct {
    Env         string
    Port        string
    DatabaseURL string
    RedisURL    string
}

func Load() (*Config, error) {
    // åŠ è½½.envæ–‡ä»¶
    if err := godotenv.Load(); err != nil {
        // ç”Ÿäº§ç¯å¢ƒå¯èƒ½ä¸éœ€è¦.env
    }
    
    return &Config{
        Env:         getEnv("ENV", "development"),
        Port:        getEnv("PORT", "8080"),
        DatabaseURL: getEnv("DATABASE_URL", ""),
        RedisURL:    getEnv("REDIS_URL", ""),
    }, nil
}

func getEnv(key, defaultVal string) string {
    if val := os.Getenv(key); val != "" {
        return val
    }
    return defaultVal
}
```

---

## ğŸ“ é…ç½®ç®¡ç†

### 1. ç¯å¢ƒå˜é‡

```bash
# .env.production
PORT=8080
DATABASE_URL=postgres://prod-db:5432/myapp
REDIS_URL=redis://prod-redis:6379
LOG_LEVEL=info
```

---

### 2. é…ç½®æ–‡ä»¶

```yaml
# config.yaml
server:
  port: 8080
  timeout: 30s

database:
  host: localhost
  port: 5432
  name: myapp
  
redis:
  host: localhost
  port: 6379
```

```go
// è¯»å–é…ç½®
import "gopkg.in/yaml.v3"

type ServerConfig struct {
    Server struct {
        Port    int    `yaml:"port"`
        Timeout string `yaml:"timeout"`
    } `yaml:"server"`
}

func LoadConfig(path string) (*ServerConfig, error) {
    data, err := os.ReadFile(path)
    if err != nil {
        return nil, err
    }
    
    var cfg ServerConfig
    if err := yaml.Unmarshal(data, &cfg); err != nil {
        return nil, err
    }
    
    return &cfg, nil
}
```

---

### 3. é…ç½®ä¸­å¿ƒ

```go
// ä½¿ç”¨Consul
import "github.com/hashicorp/consul/api"

func loadFromConsul() (map[string]string, error) {
    client, _ := api.NewClient(api.DefaultConfig())
    kv := client.KV()
    
    pair, _, err := kv.Get("myapp/config", nil)
    if err != nil {
        return nil, err
    }
    
    // è§£æé…ç½®
    config := make(map[string]string)
    // ...
    return config, nil
}
```

---

## ğŸ” Secretç®¡ç†

### 1. ç¯å¢ƒå˜é‡

```bash
# ä»Secret Managerè·å–
export DB_PASSWORD=$(aws secretsmanager get-secret-value --secret-id db-password --query SecretString --output text)
```

---

### 2. Kubernetes Secrets

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
type: Opaque
data:
  database-password: <base64-encoded>
  api-key: <base64-encoded>
```

---

### 3. Vaulté›†æˆ

```go
import "github.com/hashicorp/vault/api"

func getSecret(path string) (string, error) {
    client, _ := api.NewClient(nil)
    
    secret, err := client.Logical().Read(path)
    if err != nil {
        return "", err
    }
    
    return secret.Data["value"].(string), nil
}
```

---

## ğŸ“Š å¥åº·æ£€æŸ¥

```go
// health/health.go
package health

import (
    "context"
    "database/sql"
    "encoding/json"
    "net/http"
    "time"
)

type HealthCheck struct {
    Status string            `json:"status"`
    Checks map[string]string `json:"checks"`
}

func Handler(db *sql.DB) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        checks := make(map[string]string)
        status := "healthy"
        
        // æ£€æŸ¥æ•°æ®åº“
        ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
        defer cancel()
        
        if err := db.PingContext(ctx); err != nil {
            checks["database"] = "unhealthy: " + err.Error()
            status = "unhealthy"
        } else {
            checks["database"] = "healthy"
        }
        
        // å“åº”
        health := HealthCheck{
            Status: status,
            Checks: checks,
        }
        
        w.Header().Set("Content-Type", "application/json")
        if status != "healthy" {
            w.WriteHeader(http.StatusServiceUnavailable)
        }
        json.NewEncoder(w).Encode(health)
    }
}
```

---

## ğŸš€ ä¼˜é›…å…³é—­

```go
func main() {
    srv := &http.Server{
        Addr:    ":8080",
        Handler: router,
    }
    
    // å¯åŠ¨æœåŠ¡å™¨
    go func() {
        if err := srv.ListenAndServe(); err != http.ErrServerClosed {
            log.Fatal(err)
        }
    }()
    
    // ç­‰å¾…ä¸­æ–­ä¿¡å·
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Println("Shutting down server...")
    
    // ä¼˜é›…å…³é—­ï¼ˆæœ€å¤š30ç§’ï¼‰
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    if err := srv.Shutdown(ctx); err != nil {
        log.Fatal("Server forced to shutdown:", err)
    }
    
    log.Println("Server exited")
}
```

---

## ğŸ’¡ æœ€ä½³å®è·µ

1. **12-Factor AppåŸåˆ™**
   - ä»£ç åº“ï¼šä¸€ä»½ä»£ç ï¼Œå¤šå¤„éƒ¨ç½²
   - ä¾èµ–ï¼šæ˜¾å¼å£°æ˜ä¾èµ–
   - é…ç½®ï¼šå­˜å‚¨åœ¨ç¯å¢ƒä¸­
   - åç«¯æœåŠ¡ï¼šå½“ä½œé™„åŠ èµ„æº
   - æ„å»ºã€å‘å¸ƒã€è¿è¡Œï¼šä¸¥æ ¼åˆ†ç¦»

2. **ç¯å¢ƒä¸€è‡´æ€§**
   - ä½¿ç”¨å®¹å™¨ç¡®ä¿ç¯å¢ƒä¸€è‡´
   - ç‰ˆæœ¬é”å®šä¾èµ–
   - Infrastructure as Code

3. **ç›‘æ§å’Œæ—¥å¿—**
   - ç»“æ„åŒ–æ—¥å¿—
   - æŒ‡æ ‡æ”¶é›†
   - åˆ†å¸ƒå¼è¿½è¸ª
   - å‘Šè­¦é…ç½®

4. **å®‰å…¨æ€§**
   - æœ€å°æƒé™åŸåˆ™
   - SecretåŠ å¯†å­˜å‚¨
   - å®šæœŸæ›´æ–°ä¾èµ–
   - å®‰å…¨æ‰«æ

---

## ğŸ“š ç›¸å…³èµ„æº

- [12-Factor App](https://12factor.net/)
- [Cloud Native](https://www.cncf.io/)

**ä¸‹ä¸€æ­¥**: [02-Dockeréƒ¨ç½²](./02-Dockeréƒ¨ç½².md)

---

**æœ€åæ›´æ–°**: 2025-10-28

