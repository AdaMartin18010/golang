# 容器化最佳实践

**版本**: v1.0
**更新日期**: 2025-11-11
**适用于**: Go 1.25.3

---
## 📋 目录

- [容器化最佳实践](#容器化最佳实践)
  - [1. Dockerfile最佳实践](#1-dockerfile最佳实践)
- [❌ 不推荐](#不推荐)
- [✅ 推荐: 多阶段构建](#推荐-多阶段构建)
- [阶段1: 构建](#阶段1-构建)
- [安装必要的构建工具](#安装必要的构建工具)
- [1. 先复制依赖文件（充分利用Docker缓存）](#1-先复制依赖文件充分利用docker缓存)
- [2. 再复制源代码](#2-再复制源代码)
- [3. 构建](#3-构建)
- [阶段2: 运行](#阶段2-运行)
- [安装运行时依赖](#安装运行时依赖)
- [创建非root用户](#创建非root用户)
- [从builder复制必要文件](#从builder复制必要文件)
- [复制配置文件](#复制配置文件)
- [设置时区](#设置时区)
- [切换到非root用户](#切换到非root用户)
- [健康检查](#健康检查)
- [✅ 最佳: 使用Distroless](#最佳-使用distroless)
- [使用Google Distroless（最小化镜像）](#使用google-distroless最小化镜像)
  - [2. 镜像优化](#2-镜像优化)
- [❌ 不好: 一次性复制所有文件](#不好-一次性复制所有文件)
- [✅ 好: 分层复制，充分利用缓存](#好-分层复制充分利用缓存)
- [.dockerignore](#dockerignore)
- [版本控制](#版本控制)
- [IDE](#ide)
- [测试和文档](#测试和文档)
- [依赖](#依赖)
- [构建产物](#构建产物)
- [日志和临时文件](#日志和临时文件)
- [CI/CD](#cicd)
- [❌ 每个RUN都会创建一层](#每个run都会创建一层)
- [✅ 合并为一层，并清理缓存](#合并为一层并清理缓存)
  - [3. 安全加固](#3-安全加固)
- [✅ 创建并使用非root用户](#创建并使用非root用户)
- [设置文件权限](#设置文件权限)
- [使用Trivy扫描镜像](#使用trivy扫描镜像)
- [输出示例](#输出示例)
- [扫描并阻止高危漏洞](#扫描并阻止高危漏洞)
- [✅ 只安装必要的包](#只安装必要的包)
- [✅ 删除shell（distroless自动实现）](#删除shelldistroless自动实现)
- [✅ 只读文件系统](#只读文件系统)
- [✅ 限制capabilities](#限制capabilities)
- [❌ 不要: 硬编码密钥](#不要-硬编码密钥)
- [✅ 使用secrets](#使用secrets)
- [✅ 使用环境变量](#使用环境变量)
  - [4. 多架构构建](#4-多架构构建)
- [创建builder](#创建builder)
- [构建多架构镜像](#构建多架构镜像)
- [多架构构建](#多架构构建)
- [根据目标平台构建](#根据目标平台构建)
  - [5. Docker Compose](#5-docker-compose)
- [docker-compose.yml](#docker-composeyml)
- [应用服务](#应用服务)
- [数据库](#数据库)
- [Redis](#redis)
- [Nginx](#nginx)
- [docker-compose.prod.yml](#docker-composeprodyml)
  - [6. 健康检查](#6-健康检查)
- [基础健康检查](#基础健康检查)
- [使用自定义命令](#使用自定义命令)
- [禁用继承的健康检查](#禁用继承的健康检查)
  - [7. 日志管理](#7-日志管理)
- [docker-compose.yml](#docker-composeyml)
- [使用fluentd](#使用fluentd)
- [使用ELK Stack](#使用elk-stack)
  - [8. 性能优化](#8-性能优化)
- [docker-compose.yml](#docker-composeyml)
- [使用host网络（性能最优，但失去隔离性）](#使用host网络性能最优但失去隔离性)
- [使用自定义网络（推荐）](#使用自定义网络推荐)
- [使用tmpfs提升性能（临时数据）](#使用tmpfs提升性能临时数据)
- [使用volume（持久化数据）](#使用volume持久化数据)
  - [💼 实战案例](#实战案例)
- [Dockerfile (共享基础)](#dockerfile-共享基础)
- [API服务](#api服务)
- [Worker服务](#worker服务)
- [Cron服务](#cron服务)
- [构建特定服务](#构建特定服务)
  - [📋 检查清单](#检查清单)
  - [🔗 相关资源](#相关资源)

---

## 1. Dockerfile最佳实践

### 基础Dockerfile

```dockerfile
# ❌ 不推荐
FROM golang:latest
WORKDIR /app
COPY . .
RUN go build -o app
CMD ["./app"]
```

**问题**:

- 使用latest标签（不可复现）
- 镜像体积大（>800MB）
- 构建缓存效率低
- 运行时包含构建工具

---

### 多阶段构建（推荐）

```dockerfile
# ✅ 推荐: 多阶段构建
# 阶段1: 构建
FROM golang:1.25.3-alpine AS builder

# 安装必要的构建工具
RUN apk add --no-cache git make ca-certificates tzdata

WORKDIR /build

# 1. 先复制依赖文件（充分利用Docker缓存）
COPY go.mod go.sum ./
RUN go mod download && go mod verify

# 2. 再复制源代码
COPY . .

# 3. 构建
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
    -ldflags="-w -s \
    -X main.version=${VERSION:-dev} \
    -X main.commit=${COMMIT:-unknown} \
    -X main.buildTime=$(date -u '+%Y-%m-%d_%H:%M:%S')" \
    -trimpath \
    -o app \
    ./cmd/app

# 阶段2: 运行
FROM alpine:3.19

# 安装运行时依赖
RUN apk --no-cache add ca-certificates tzdata && \
    # 创建非root用户
    addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser

WORKDIR /app

# 从builder复制必要文件
COPY --from=builder /build/app ./
COPY --from=builder /usr/share/zoneinfo /usr/share/zoneinfo
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

# 复制配置文件
COPY configs/ ./configs/

# 设置时区
ENV TZ=Asia/Shanghai

# 切换到非root用户
USER appuser

EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD ["/app/app", "healthcheck"] || exit 1

ENTRYPOINT ["/app/app"]
CMD ["serve"]
```

**优势**:

- 镜像大小: 800MB → 15MB (53x减少)
- 构建缓存优化
- 安全：非root用户运行
- 可复现：使用固定版本标签

---

### 最小化镜像（Distroless）

```dockerfile
# ✅ 最佳: 使用Distroless
FROM golang:1.25.3-alpine AS builder

WORKDIR /build

COPY go.mod go.sum ./
RUN go mod download

COPY . .

RUN CGO_ENABLED=0 go build -ldflags="-w -s" -o app ./cmd/app

# 使用Google Distroless（最小化镜像）
FROM gcr.io/distroless/static:nonroot

WORKDIR /app

COPY --from=builder /build/app ./
COPY --from=builder --chown=nonroot:nonroot /build/configs ./configs

USER nonroot:nonroot

EXPOSE 8080

ENTRYPOINT ["/app/app"]
```

**镜像大小对比**:

- golang:1.25.3: 820MB
- alpine: 15MB
- distroless: 5MB ❤️

---

## 2. 镜像优化

### 层缓存优化

```dockerfile
# ❌ 不好: 一次性复制所有文件
COPY . .
RUN go mod download
RUN go build

# ✅ 好: 分层复制，充分利用缓存
COPY go.mod go.sum ./
RUN go mod download  # 只有依赖变化时才重新执行

COPY . .
RUN go build         # 只有代码变化时才重新执行
```

### .dockerignore

```text
# .dockerignore
# 版本控制
.git
.gitignore

# IDE
.vscode
.idea
*.swp

# 测试和文档
*_test.go
*.md
docs/

# 依赖
vendor/

# 构建产物
*.exe
*.dll
*.so
*.dylib
dist/
bin/

# 日志和临时文件
*.log
tmp/
*.tmp

# CI/CD
.github
.gitlab-ci.yml
Jenkinsfile
```

### 压缩技巧

```dockerfile
# ❌ 每个RUN都会创建一层
RUN apk add --no-cache git
RUN apk add --no-cache make
RUN apk add --no-cache curl

# ✅ 合并为一层，并清理缓存
RUN apk add --no-cache \
    git \
    make \
    curl && \
    rm -rf /var/cache/apk/*
```

### 性能对比

| 优化项 | 构建时间 | 镜像大小 | 层数 |
|--------|----------|----------|------|
| 原始 | 5min | 820MB | 15 |
| 多阶段 | 3min | 15MB | 8 |
| +缓存优化 | 30s | 15MB | 8 |
| +distroless | 30s | 5MB | 5 |

---

## 3. 安全加固

### 非root用户

```dockerfile
# ✅ 创建并使用非root用户
RUN addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser

# 设置文件权限
COPY --chown=appuser:appuser app /app/

USER appuser
```

### 扫描漏洞

```bash
# 使用Trivy扫描镜像
trivy image myapp:latest

# 输出示例
HIGH: 2
MEDIUM: 5
LOW: 10

# 扫描并阻止高危漏洞
trivy image --severity HIGH,CRITICAL --exit-code 1 myapp:latest
```

### 最小化攻击面

```dockerfile
# ✅ 只安装必要的包
RUN apk add --no-cache ca-certificates

# ✅ 删除shell（distroless自动实现）
FROM gcr.io/distroless/static  # 无shell

# ✅ 只读文件系统
docker run --read-only myapp

# ✅ 限制capabilities
docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE myapp
```

### 敏感信息处理

```dockerfile
# ❌ 不要: 硬编码密钥
ENV API_KEY=secret123

# ✅ 使用secrets
docker run --secret id=api_key,src=./api_key.txt myapp

# ✅ 使用环境变量
docker run -e API_KEY=$API_KEY myapp
```

---

## 4. 多架构构建

### 使用Docker Buildx

```bash
# 创建builder
docker buildx create --name multiarch --use

# 构建多架构镜像
docker buildx build \
    --platform linux/amd64,linux/arm64,linux/arm/v7 \
    -t myapp:latest \
    --push \
    .
```

### Dockerfile多架构

```dockerfile
# 多架构构建
FROM --platform=$BUILDPLATFORM golang:1.25.3-alpine AS builder

ARG TARGETOS
ARG TARGETARCH

WORKDIR /build

COPY go.mod go.sum ./
RUN go mod download

COPY . .

# 根据目标平台构建
RUN CGO_ENABLED=0 GOOS=$TARGETOS GOARCH=$TARGETARCH \
    go build -o app ./cmd/app

FROM alpine:3.19

COPY --from=builder /build/app /app/

ENTRYPOINT ["/app/app"]
```

---

## 5. Docker Compose

### 开发环境配置

```yaml
# docker-compose.yml
version: '3.9'

services:
  # 应用服务
  app:
    build:
      Context: .
      dockerfile: Dockerfile
      target: development
    ports:
      - "8080:8080"
    volumes:
      - .:/app
      - go-mod-cache:/go/pkg/mod
    environment:
      - DATABASE_URL=postgres://user:pass@db:5432/myapp
      - REDIS_URL=redis://redis:6379
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
    networks:
      - app-network

  # 数据库
  db:
    image: postgres:15-alpine
    ports:
      - "5432:5432"
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - app-network

  # Redis
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    networks:
      - app-network

  # Nginx
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - app
    networks:
      - app-network

volumes:
  postgres-data:
  redis-data:
  go-mod-cache:

networks:
  app-network:
    driver: bridge
```

### 生产环境配置

```yaml
# docker-compose.prod.yml
version: '3.9'

services:
  app:
    image: registry.example.com/myapp:${VERSION}
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '1'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 256M
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
    environment:
      - ENV=production
    secrets:
      - db_password
      - api_key
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

secrets:
  db_password:
    external: true
  api_key:
    external: true
```

---

## 6. 健康检查

### 应用层健康检查

```go
// healthcheck.go
package main

import (
    "Context"
    "fmt"
    "net/http"
    "os"
    "time"
)

func main() {
    if len(os.Args) > 1 && os.Args[1] == "healthcheck" {
        if err := healthcheck(); err != nil {
            fmt.Fprintf(os.Stderr, "Health check failed: %v\n", err)
            os.Exit(1)
        }
        os.Exit(0)
    }

    // 正常启动...
}

func healthcheck() error {
    ctx, cancel := Context.WithTimeout(Context.Background(), 3*time.Second)
    defer cancel()

    req, _ := http.NewRequestWithContext(ctx, "GET", "http://localhost:8080/health", nil)
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("unexpected status: %d", resp.StatusCode)
    }

    return nil
}
```

### Dockerfile健康检查

```dockerfile
# 基础健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# 使用自定义命令
HEALTHCHECK --interval=30s --timeout=3s \
    CMD ["/app/app", "healthcheck"]

# 禁用继承的健康检查
HEALTHCHECK NONE
```

### Docker Compose健康检查

```yaml
services:
  app:
    healthcheck:
      test: ["CMD", "/app/app", "healthcheck"]
      interval: 30s
      timeout: 3s
      start_period: 40s
      retries: 3

  db:
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user"]
      interval: 10s
      timeout: 5s
      retries: 5
```

---

## 7. 日志管理

### 日志输出

```go
// ✅ 输出到stdout/stderr
func main() {
    // 标准日志输出到stdout
    log.SetOutput(os.Stdout)

    // 错误日志输出到stderr
    errorLog := log.New(os.Stderr, "ERROR: ", log.LstdFlags)

    // 结构化日志
    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
    logger.Info("Server started", "port", 8080)
}
```

### Docker日志配置

```yaml
# docker-compose.yml
services:
  app:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
        labels: "service=app"

  # 使用fluentd
  app-with-fluentd:
    logging:
      driver: "fluentd"
      options:
        fluentd-address: localhost:24224
        tag: app
```

### 日志聚合

```yaml
# 使用ELK Stack
version: '3.9'

services:
  app:
    logging:
      driver: "fluentd"
      options:
        fluentd-address: fluentd:24224

  fluentd:
    image: fluent/fluentd:latest
    volumes:
      - ./fluentd.conf:/fluentd/etc/fluent.conf
    ports:
      - "24224:24224"
    depends_on:
      - elasticsearch

  elasticsearch:
    image: elasticsearch:8.11.0
    environment:
      - discovery.type=single-node
    ports:
      - "9200:9200"

  kibana:
    image: kibana:8.11.0
    ports:
      - "5601:5601"
    depends_on:
      - elasticsearch
```

---

## 8. 性能优化

### 资源限制

```yaml
# docker-compose.yml
services:
  app:
    deploy:
      resources:
        limits:
          cpus: '1.0'      # 最多1个CPU
          memory: 512M     # 最多512MB内存
        reservations:
          cpus: '0.5'      # 保证0.5个CPU
          memory: 256M     # 保证256MB内存
```

### 网络优化

```dockerfile
# 使用host网络（性能最优，但失去隔离性）
docker run --network host myapp

# 使用自定义网络（推荐）
docker network create --driver bridge myapp-net
docker run --network myapp-net myapp
```

### 存储优化

```yaml
services:
  app:
    volumes:
      # 使用tmpfs提升性能（临时数据）
      - type: tmpfs
        target: /tmp
        tmpfs:
          size: 100M

      # 使用volume（持久化数据）
      - type: volume
        source: app-data
        target: /data
```

### 性能对比1

| 配置 | 启动时间 | 内存使用 | QPS |
|------|----------|----------|-----|
| 默认配置 | 5s | 200MB | 5000 |
| +资源限制 | 5s | 150MB | 4800 |
| +网络优化 | 3s | 150MB | 6000 |
| +存储优化 | 3s | 120MB | 6500 |

---

## 💼 实战案例

### 案例: 微服务容器化

**项目结构**:

```text
myapp/
├── cmd/
│   ├── api/
│   ├── worker/
│   └── cron/
├── Dockerfile
├── docker-compose.yml
└── deployments/
    ├── api.dockerfile
    ├── worker.dockerfile
    └── k8s/
```

**多服务Dockerfile**:

```dockerfile
# Dockerfile (共享基础)
FROM golang:1.25.3-alpine AS base

WORKDIR /build
COPY go.mod go.sum ./
RUN go mod download
COPY . .

# API服务
FROM base AS api-builder
RUN CGO_ENABLED=0 go build -o api ./cmd/api

FROM alpine:3.19 AS api
COPY --from=api-builder /build/api /app/api
ENTRYPOINT ["/app/api"]

# Worker服务
FROM base AS worker-builder
RUN CGO_ENABLED=0 go build -o worker ./cmd/worker

FROM alpine:3.19 AS worker
COPY --from=worker-builder /build/worker /app/worker
ENTRYPOINT ["/app/worker"]

# Cron服务
FROM base AS cron-builder
RUN CGO_ENABLED=0 go build -o cron ./cmd/cron

FROM alpine:3.19 AS cron
COPY --from=cron-builder /build/cron /app/cron
ENTRYPOINT ["/app/cron"]
```

**构建命令**:

```bash
# 构建特定服务
docker build --target api -t myapp-api:latest .
docker build --target worker -t myapp-worker:latest .
docker build --target cron -t myapp-cron:latest .
```

---

## 📋 检查清单

### 构建检查

- [ ] 使用多阶段构建
- [ ] 使用固定版本标签
- [ ] 优化层缓存
- [ ] 添加.dockerignore
- [ ] 镜像大小<50MB

### 安全检查

- [ ] 使用非root用户
- [ ] 扫描漏洞
- [ ] 不包含敏感信息
- [ ] 最小化攻击面
- [ ] 使用secrets管理密钥

### 运行时检查

- [ ] 配置健康检查
- [ ] 设置资源限制
- [ ] 配置日志输出
- [ ] 优雅关闭
- [ ] 监控和告警

---

## 🔗 相关资源
