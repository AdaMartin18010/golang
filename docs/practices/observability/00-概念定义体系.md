# 概念定义体系

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3  
**文件夹**: practices/observability

---

## 📋 目录



- [1. 可观测性核心概念](#1.-可观测性核心概念)
  - [1.1 可观测性 (Observability)](#1.1-可观测性-observability)
  - [1.2 可观测性三支柱](#1.2-可观测性三支柱)
- [2. Metrics概念](#2.-metrics概念)
  - [2.1 RED指标](#2.1-red指标)
  - [2.2 USE方法论](#2.2-use方法论)
  - [2.3 四个黄金指标](#2.3-四个黄金指标)
- [3. Logging概念](#3.-logging概念)
  - [3.1 结构化日志](#3.1-结构化日志)
  - [3.2 日志级别](#3.2-日志级别)
  - [3.3 TraceID关联](#3.3-traceid关联)
- [4. Tracing概念](#4.-tracing概念)
  - [4.1 Span (跨度)](#4.1-span-跨度)
  - [4.2 Context传播](#4.2-context传播)
  - [4.3 采样策略](#4.3-采样策略)
- [5. SRE概念](#5.-sre概念)
  - [5.1 SLI/SLO/SLA](#5.1-slislosla)
  - [5.2 错误预算](#5.2-错误预算)
- [🔗 相关文档](#相关文档)

## 1. 可观测性核心概念

### 1.1 可观测性 (Observability)

**定义**: 通过系统的外部输出推断其内部状态的能力。

**形式化定义**:
```text
Observability = f(Metrics, Logging, Tracing)

其中:
- Metrics: 量化指标数据
- Logging: 离散事件记录
- Tracing: 请求链路追踪

判断标准:
可观测性程度 = Σ(可回答问题数 / 总问题数)
```

**三支柱作用**:
- **Metrics** (What): 告诉你"什么"出问题了
- **Logging** (Why): 告诉你"为什么"出问题
- **Tracing** (Where): 告诉你问题出在"哪里"

**Go实践**:
```go
// 统一可观测性上下文
type ObservabilityContext struct {
    TraceID  string
    SpanID   string
    Logger   *zap.Logger
    Metrics  *prometheus.Registry
}

// 在请求处理中传递
func HandleRequest(ctx context.Context, obsCtx *ObservabilityContext) {
    // 记录指标
    obsCtx.Metrics.Counter("requests_total").Inc()
    
    // 记录日志
    obsCtx.Logger.Info("processing request",
        zap.String("trace_id", obsCtx.TraceID),
    )
    
    // 创建Span
    ctx, span := tracer.Start(ctx, "handle_request")
    defer span.End()
}
```

---

### 1.2 可观测性三支柱

**定义**: Metrics、Logging、Tracing三者构成的完整监控体系。

**关系模型**:
```text
ThreePillars = {
    Metrics: {
        Type: "Aggregated",
        Granularity: "Coarse",
        Cost: "Low",
        Query: "Fast"
    },
    Logging: {
        Type: "Event-based",
        Granularity: "Fine",
        Cost: "High",
        Query: "Slow"
    },
    Tracing: {
        Type: "Request-scoped",
        Granularity: "Medium",
        Cost: "Medium",
        Query: "Fast"
    }
}

互补性:
Metrics → 发现异常
Logging → 分析原因
Tracing → 定位位置
```

**协同工作流**:
```text
1. Metrics告警 → QPS突然下降
2. Logging查询 → 查看对应时间段错误日志
3. Tracing分析 → 定位到哪个服务超时
4. Metrics验证 → 确认该服务延迟指标
```

---

## 2. Metrics概念

### 2.1 RED指标

**定义**: 面向请求的三个黄金指标（Rate, Errors, Duration）。

**形式化定义**:
```text
RED = {
    Rate: 请求速率 (requests/second),
    Errors: 错误率 (errors/total),
    Duration: 响应时间 (latency in ms/s)
}

健康度评分:
Health = w1·Rate_score + w2·(1-Error_rate) + w3·Duration_score
其中: w1 + w2 + w3 = 1
```

**Go实践**:
```go
var (
    // Rate - 请求速率
    httpRequestsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total HTTP requests",
        },
        []string{"method", "endpoint"},
    )
    
    // Errors - 错误率
    httpErrorsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_errors_total",
            Help: "Total HTTP errors",
        },
        []string{"method", "endpoint", "code"},
    )
    
    // Duration - 响应时间
    httpDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_request_duration_seconds",
            Help:    "HTTP request duration",
            Buckets: []float64{.001, .005, .01, .05, .1, .5, 1, 5},
        },
        []string{"method", "endpoint"},
    )
)

func RecordRequest(method, endpoint string, duration time.Duration, err error) {
    httpRequestsTotal.WithLabelValues(method, endpoint).Inc()
    httpDuration.WithLabelValues(method, endpoint).Observe(duration.Seconds())
    if err != nil {
        httpErrorsTotal.WithLabelValues(method, endpoint, "500").Inc()
    }
}
```

---

### 2.2 USE方法论

**定义**: 面向资源的监控方法（Utilization, Saturation, Errors）。

**形式化定义**:
```text
USE = {
    Utilization: 资源使用率 (used/total),
    Saturation: 资源饱和度 (queue length),
    Errors: 错误次数 (error count)
}

应用对象:
- CPU
- Memory
- Disk
- Network
```

**Go实践**:
```go
// CPU使用率
var cpuUtilization = prometheus.NewGauge(
    prometheus.GaugeOpts{
        Name: "cpu_utilization_percent",
        Help: "CPU utilization in percent",
    },
)

// 内存使用率
var memUtilization = prometheus.NewGauge(
    prometheus.GaugeOpts{
        Name: "memory_utilization_percent",
        Help: "Memory utilization in percent",
    },
)

// Goroutine饱和度
var goroutineCount = prometheus.NewGauge(
    prometheus.GaugeOpts{
        Name: "goroutine_count",
        Help: "Current goroutine count",
    },
)

func RecordSystemMetrics() {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    memUtilization.Set(float64(m.Alloc) / float64(m.Sys) * 100)
    goroutineCount.Set(float64(runtime.NumGoroutine()))
}
```

---

### 2.3 四个黄金指标

**定义**: Google SRE提出的核心监控指标。

**形式化定义**:
```text
GoldenSignals = {
    Latency: 延迟分布 (P50, P95, P99),
    Traffic: 流量大小 (requests/second),
    Errors: 错误率 (errors/total),
    Saturation: 饱和度 (resource usage)
}

优先级: Errors > Latency > Traffic > Saturation
```

**关联关系**:
```text
Latency ↑ → 可能导致 → Saturation ↑
Traffic ↑ → 可能导致 → Latency ↑ 或 Errors ↑
Errors ↑ → 需要立即 → 告警处理
Saturation ↑ → 预示未来 → 性能问题
```

---

## 3. Logging概念

### 3.1 结构化日志

**定义**: 以结构化格式（JSON等）记录日志，便于机器解析。

**形式化定义**:
```text
StructuredLog = {
    timestamp: Time,
    level: LogLevel,
    message: string,
    fields: Map[string]interface{},
    context: {
        trace_id: string,
        span_id: string,
        service: string
    }
}

优势:
- 机器可解析
- 查询高效
- 支持聚合分析
```

**Go实践 (zap)**:
```go
logger, _ := zap.NewProduction()
defer logger.Sync()

logger.Info("user action",
    zap.String("action", "login"),
    zap.String("user_id", "12345"),
    zap.String("ip", "192.168.1.1"),
    zap.String("trace_id", traceID),
    zap.Duration("latency", latency),
)

// 输出JSON:
// {"level":"info","ts":1698765432.123,"msg":"user action",
//  "action":"login","user_id":"12345","ip":"192.168.1.1",
//  "trace_id":"abc123","latency":0.05}
```

---

### 3.2 日志级别

**定义**: 日志消息的严重程度分级。

**标准定义**:
```text
LogLevels = {
    TRACE: 0,   // 最详细的调试信息
    DEBUG: 1,   // 调试信息
    INFO:  2,   // 一般信息
    WARN:  3,   // 警告信息
    ERROR: 4,   // 错误信息
    FATAL: 5,   // 致命错误
    PANIC: 6    // 恐慌错误
}

过滤规则:
if log.Level >= config.MinLevel {
    output(log)
}
```

**使用原则**:
```text
- DEBUG: 开发环境详细日志，生产关闭
- INFO:  关键业务流程，适量使用
- WARN:  潜在问题，需关注但不紧急
- ERROR: 错误需处理，但程序继续
- FATAL: 严重错误，程序退出
- PANIC: 不可恢复错误，panic
```

---

### 3.3 TraceID关联

**定义**: 通过唯一ID关联同一请求的所有日志和追踪。

**形式化定义**:
```text
TraceContext = {
    trace_id: UUID,
    span_id: UUID,
    parent_span_id: UUID | null
}

传播机制:
1. 入口生成TraceID
2. 通过Context传递
3. 日志/Span记录TraceID
4. 跨服务通过HTTP Header传递
```

**Go实践**:
```go
type contextKey string

const traceIDKey contextKey = "trace_id"

// 生成TraceID
func GenerateTraceID() string {
    return uuid.New().String()
}

// 注入Context
func WithTraceID(ctx context.Context, traceID string) context.Context {
    return context.WithValue(ctx, traceIDKey, traceID)
}

// 提取TraceID
func GetTraceID(ctx context.Context) string {
    if traceID, ok := ctx.Value(traceIDKey).(string); ok {
        return traceID
    }
    return ""
}

// 日志记录
func LogWithTrace(ctx context.Context, msg string) {
    traceID := GetTraceID(ctx)
    logger.Info(msg, zap.String("trace_id", traceID))
}

// HTTP传播
func PropagateTrace(req *http.Request, ctx context.Context) {
    traceID := GetTraceID(ctx)
    req.Header.Set("X-Trace-ID", traceID)
}
```

---

## 4. Tracing概念

### 4.1 Span (跨度)

**定义**: 表示一个操作的时间段，是追踪的基本单元。

**形式化定义**:
```text
Span = {
    span_id: UUID,
    trace_id: UUID,
    parent_span_id: UUID | null,
    operation_name: string,
    start_time: Timestamp,
    end_time: Timestamp,
    duration: end_time - start_time,
    tags: Map[string]interface{},
    logs: []LogEntry
}

关系:
Trace = Tree<Span>
```

**Go实践 (OpenTelemetry)**:
```go
func ProcessOrder(ctx context.Context, orderID string) error {
    // 创建Span
    ctx, span := tracer.Start(ctx, "process_order")
    defer span.End()
    
    // 添加属性
    span.SetAttributes(
        attribute.String("order.id", orderID),
        attribute.Int("order.items", 5),
    )
    
    // 子Span
    if err := validateOrder(ctx, orderID); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    if err := saveOrder(ctx, orderID); err != nil {
        span.RecordError(err)
        return err
    }
    
    span.SetStatus(codes.Ok, "order processed")
    return nil
}

func validateOrder(ctx context.Context, orderID string) error {
    ctx, span := tracer.Start(ctx, "validate_order")
    defer span.End()
    // 验证逻辑
    return nil
}
```

---

### 4.2 Context传播

**定义**: 在分布式系统中传递追踪上下文的机制。

**传播格式**:
```text
W3C Trace Context:
traceparent: 00-{trace-id}-{span-id}-{flags}
tracestate: vendor1=value1,vendor2=value2

B3 (Zipkin):
X-B3-TraceId: {trace-id}
X-B3-SpanId: {span-id}
X-B3-ParentSpanId: {parent-span-id}
X-B3-Sampled: {0|1}
```

**Go实践**:
```go
// HTTP客户端注入
func DoRequest(ctx context.Context, url string) (*http.Response, error) {
    req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
    
    // OpenTelemetry自动注入
    // 或手动:
    span := trace.SpanFromContext(ctx)
    if span.SpanContext().IsValid() {
        traceID := span.SpanContext().TraceID().String()
        spanID := span.SpanContext().SpanID().String()
        req.Header.Set("traceparent",
            fmt.Sprintf("00-%s-%s-01", traceID, spanID))
    }
    
    return http.DefaultClient.Do(req)
}

// HTTP服务端提取
func ExtractTraceContext(r *http.Request) context.Context {
    ctx := r.Context()
    // OpenTelemetry自动提取
    // 或手动从Header提取并创建SpanContext
    return ctx
}
```

---

### 4.3 采样策略

**定义**: 决定哪些请求被记录追踪的策略。

**形式化定义**:
```text
SamplingStrategy = {
    rate: float64,  // 采样率 (0-1)
    decision: func(ctx) → bool
}

常见策略:
1. 固定采样率: P(sample) = rate
2. 自适应采样: rate = f(load, error_rate)
3. 尾部采样: decision after request completes
4. 错误采样: always sample if error
```

**Go实践**:
```go
// 固定采样率
sampler := trace.TraceIDRatioBased(0.1) // 10%采样

// 条件采样
type CustomSampler struct{}

func (s *CustomSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    // 错误必采样
    if hasError(p) {
        return trace.SamplingResult{
            Decision: trace.RecordAndSample,
        }
    }
    
    // 慢请求必采样
    if isSlow(p) {
        return trace.SamplingResult{
            Decision: trace.RecordAndSample,
        }
    }
    
    // 其他1%采样
    if rand.Float64() < 0.01 {
        return trace.SamplingResult{
            Decision: trace.RecordAndSample,
        }
    }
    
    return trace.SamplingResult{
        Decision: trace.Drop,
    }
}
```

---

## 5. SRE概念

### 5.1 SLI/SLO/SLA

**定义**: 服务质量的三个关键指标。

**形式化定义**:
```text
SLI (Service Level Indicator):
- 定义: 服务质量的量化指标
- 示例: 可用性 = 成功请求 / 总请求

SLO (Service Level Objective):
- 定义: SLI的目标值
- 示例: 可用性 ≥ 99.9%

SLA (Service Level Agreement):
- 定义: 与用户的服务协议
- 示例: 可用性 < 99.9%时赔偿

关系: SLI ≥ SLO → 满足 SLA
```

**Go监控示例**:
```go
// SLI计算
type SLI struct {
    totalRequests    int64
    successRequests  int64
}

func (s *SLI) Availability() float64 {
    if s.totalRequests == 0 {
        return 1.0
    }
    return float64(s.successRequests) / float64(s.totalRequests)
}

// SLO检查
type SLO struct {
    target float64 // 目标值 0.999
}

func (slo *SLO) Met(sli *SLI) bool {
    return sli.Availability() >= slo.target
}

// 错误预算
func (slo *SLO) ErrorBudget(sli *SLI) float64 {
    allowed := (1 - slo.target) * float64(sli.totalRequests)
    actual := float64(sli.totalRequests - sli.successRequests)
    return (allowed - actual) / allowed
}
```

---

### 5.2 错误预算

**定义**: 允许的最大失败率，用于平衡可靠性和创新速度。

**形式化定义**:
```text
ErrorBudget = (1 - SLO) × TotalRequests

示例:
SLO = 99.9%
每月请求 = 1,000,000
错误预算 = (1 - 0.999) × 1,000,000 = 1,000次

策略:
if ErrorBudget > 0:
    可以发布新功能
else:
    专注稳定性改进
```

**Go实践**:
```go
type ErrorBudget struct {
    slo           float64
    totalRequests int64
    errors        int64
}

func (eb *ErrorBudget) Remaining() float64 {
    allowedErrors := (1 - eb.slo) * float64(eb.totalRequests)
    return (allowedErrors - float64(eb.errors)) / allowedErrors
}

func (eb *ErrorBudget) CanDeploy() bool {
    return eb.Remaining() > 0.1 // 保留10%缓冲
}

func (eb *ErrorBudget) Status() string {
    remaining := eb.Remaining()
    switch {
    case remaining > 0.5:
        return "健康"
    case remaining > 0.1:
        return "警告"
    default:
        return "耗尽-冻结发布"
    }
}
```

---

## 🔗 相关文档

- [知识图谱](./00-知识图谱.md)
- [对比矩阵](./00-对比矩阵.md)
- [README.md](./README.md)

---

**最后更新**: 2025-10-29
