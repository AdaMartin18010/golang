# æ¦‚å¿µå®šä¹‰ä½“ç³»

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.25.3
**æ–‡ä»¶å¤¹**: practices/observability

---

## ğŸ“‹ ç›®å½•

- [æ¦‚å¿µå®šä¹‰ä½“ç³»](#æ¦‚å¿µå®šä¹‰ä½“ç³»)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å¯è§‚æµ‹æ€§æ ¸å¿ƒæ¦‚å¿µ](#1-å¯è§‚æµ‹æ€§æ ¸å¿ƒæ¦‚å¿µ)
    - [1.1 å¯è§‚æµ‹æ€§ (Observability)](#11-å¯è§‚æµ‹æ€§-observability)
    - [1.2 å¯è§‚æµ‹æ€§ä¸‰æ”¯æŸ±](#12-å¯è§‚æµ‹æ€§ä¸‰æ”¯æŸ±)
  - [2. Metricsæ¦‚å¿µ](#2-metricsæ¦‚å¿µ)
    - [2.1 REDæŒ‡æ ‡](#21-redæŒ‡æ ‡)
    - [2.2 USEæ–¹æ³•è®º](#22-useæ–¹æ³•è®º)
    - [2.3 å››ä¸ªé»„é‡‘æŒ‡æ ‡](#23-å››ä¸ªé»„é‡‘æŒ‡æ ‡)
  - [3. Loggingæ¦‚å¿µ](#3-loggingæ¦‚å¿µ)
    - [3.1 ç»“æ„åŒ–æ—¥å¿—](#31-ç»“æ„åŒ–æ—¥å¿—)
    - [3.2 æ—¥å¿—çº§åˆ«](#32-æ—¥å¿—çº§åˆ«)
    - [3.3 TraceIDå…³è”](#33-traceidå…³è”)
  - [4. Tracingæ¦‚å¿µ](#4-tracingæ¦‚å¿µ)
    - [4.1 Span (è·¨åº¦)](#41-span-è·¨åº¦)
    - [4.2 Contextä¼ æ’­](#42-contextä¼ æ’­)
    - [4.3 é‡‡æ ·ç­–ç•¥](#43-é‡‡æ ·ç­–ç•¥)
  - [5. SREæ¦‚å¿µ](#5-sreæ¦‚å¿µ)
    - [5.1 SLI/SLO/SLA](#51-slislosla)
    - [5.2 é”™è¯¯é¢„ç®—](#52-é”™è¯¯é¢„ç®—)
  - [ğŸ”— ç›¸å…³æ–‡æ¡£](#-ç›¸å…³æ–‡æ¡£)

## 1. å¯è§‚æµ‹æ€§æ ¸å¿ƒæ¦‚å¿µ

### 1.1 å¯è§‚æµ‹æ€§ (Observability)

**å®šä¹‰**: é€šè¿‡ç³»ç»Ÿçš„å¤–éƒ¨è¾“å‡ºæ¨æ–­å…¶å†…éƒ¨çŠ¶æ€çš„èƒ½åŠ›ã€‚

**å½¢å¼åŒ–å®šä¹‰**:

```text
Observability = f(Metrics, Logging, Tracing)

å…¶ä¸­:
- Metrics: é‡åŒ–æŒ‡æ ‡æ•°æ®
- Logging: ç¦»æ•£äº‹ä»¶è®°å½•
- Tracing: è¯·æ±‚é“¾è·¯è¿½è¸ª

åˆ¤æ–­æ ‡å‡†:
å¯è§‚æµ‹æ€§ç¨‹åº¦ = Î£(å¯å›ç­”é—®é¢˜æ•° / æ€»é—®é¢˜æ•°)
```

**ä¸‰æ”¯æŸ±ä½œç”¨**:

- **Metrics** (What): å‘Šè¯‰ä½ "ä»€ä¹ˆ"å‡ºé—®é¢˜äº†
- **Logging** (Why): å‘Šè¯‰ä½ "ä¸ºä»€ä¹ˆ"å‡ºé—®é¢˜
- **Tracing** (Where): å‘Šè¯‰ä½ é—®é¢˜å‡ºåœ¨"å“ªé‡Œ"

**Goå®è·µ**:

```go
// ç»Ÿä¸€å¯è§‚æµ‹æ€§ä¸Šä¸‹æ–‡
type ObservabilityContext struct {
    TraceID  string
    SpanID   string
    Logger   *zap.Logger
    Metrics  *prometheus.Registry
}

// åœ¨è¯·æ±‚å¤„ç†ä¸­ä¼ é€’
func HandleRequest(ctx context.Context, obsCtx *ObservabilityContext) {
    // è®°å½•æŒ‡æ ‡
    obsCtx.Metrics.Counter("requests_total").Inc()

    // è®°å½•æ—¥å¿—
    obsCtx.Logger.Info("processing request",
        zap.String("trace_id", obsCtx.TraceID),
    )

    // åˆ›å»ºSpan
    ctx, span := tracer.Start(ctx, "handle_request")
    defer span.End()
}
```

---

### 1.2 å¯è§‚æµ‹æ€§ä¸‰æ”¯æŸ±

**å®šä¹‰**: Metricsã€Loggingã€Tracingä¸‰è€…æ„æˆçš„å®Œæ•´ç›‘æ§ä½“ç³»ã€‚

**å…³ç³»æ¨¡å‹**:

```text
ThreePillars = {
    Metrics: {
        Type: "Aggregated",
        Granularity: "Coarse",
        Cost: "Low",
        Query: "Fast"
    },
    Logging: {
        Type: "Event-based",
        Granularity: "Fine",
        Cost: "High",
        Query: "Slow"
    },
    Tracing: {
        Type: "Request-scoped",
        Granularity: "Medium",
        Cost: "Medium",
        Query: "Fast"
    }
}

äº’è¡¥æ€§:
Metrics â†’ å‘ç°å¼‚å¸¸
Logging â†’ åˆ†æåŸå› 
Tracing â†’ å®šä½ä½ç½®
```

**ååŒå·¥ä½œæµ**:

```text
1. Metricså‘Šè­¦ â†’ QPSçªç„¶ä¸‹é™
2. LoggingæŸ¥è¯¢ â†’ æŸ¥çœ‹å¯¹åº”æ—¶é—´æ®µé”™è¯¯æ—¥å¿—
3. Tracingåˆ†æ â†’ å®šä½åˆ°å“ªä¸ªæœåŠ¡è¶…æ—¶
4. MetricséªŒè¯ â†’ ç¡®è®¤è¯¥æœåŠ¡å»¶è¿ŸæŒ‡æ ‡
```

---

## 2. Metricsæ¦‚å¿µ

### 2.1 REDæŒ‡æ ‡

**å®šä¹‰**: é¢å‘è¯·æ±‚çš„ä¸‰ä¸ªé»„é‡‘æŒ‡æ ‡ï¼ˆRate, Errors, Durationï¼‰ã€‚

**å½¢å¼åŒ–å®šä¹‰**:

```text
RED = {
    Rate: è¯·æ±‚é€Ÿç‡ (requests/second),
    Errors: é”™è¯¯ç‡ (errors/total),
    Duration: å“åº”æ—¶é—´ (latency in ms/s)
}

å¥åº·åº¦è¯„åˆ†:
Health = w1Â·Rate_score + w2Â·(1-Error_rate) + w3Â·Duration_score
å…¶ä¸­: w1 + w2 + w3 = 1
```

**Goå®è·µ**:

```go
var (
    // Rate - è¯·æ±‚é€Ÿç‡
    httpRequestsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total HTTP requests",
        },
        []string{"method", "endpoint"},
    )

    // Errors - é”™è¯¯ç‡
    httpErrorsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_errors_total",
            Help: "Total HTTP errors",
        },
        []string{"method", "endpoint", "code"},
    )

    // Duration - å“åº”æ—¶é—´
    httpDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_request_duration_seconds",
            Help:    "HTTP request duration",
            Buckets: []float64{.001, .005, .01, .05, .1, .5, 1, 5},
        },
        []string{"method", "endpoint"},
    )
)

func RecordRequest(method, endpoint string, duration time.Duration, err error) {
    httpRequestsTotal.WithLabelValues(method, endpoint).Inc()
    httpDuration.WithLabelValues(method, endpoint).Observe(duration.Seconds())
    if err != nil {
        httpErrorsTotal.WithLabelValues(method, endpoint, "500").Inc()
    }
}
```

---

### 2.2 USEæ–¹æ³•è®º

**å®šä¹‰**: é¢å‘èµ„æºçš„ç›‘æ§æ–¹æ³•ï¼ˆUtilization, Saturation, Errorsï¼‰ã€‚

**å½¢å¼åŒ–å®šä¹‰**:

```text
USE = {
    Utilization: èµ„æºä½¿ç”¨ç‡ (used/total),
    Saturation: èµ„æºé¥±å’Œåº¦ (queue length),
    Errors: é”™è¯¯æ¬¡æ•° (error count)
}

åº”ç”¨å¯¹è±¡:
- CPU
- Memory
- Disk
- Network
```

**Goå®è·µ**:

```go
// CPUä½¿ç”¨ç‡
var cpuUtilization = prometheus.NewGauge(
    prometheus.GaugeOpts{
        Name: "cpu_utilization_percent",
        Help: "CPU utilization in percent",
    },
)

// å†…å­˜ä½¿ç”¨ç‡
var memUtilization = prometheus.NewGauge(
    prometheus.GaugeOpts{
        Name: "memory_utilization_percent",
        Help: "Memory utilization in percent",
    },
)

// Goroutineé¥±å’Œåº¦
var goroutineCount = prometheus.NewGauge(
    prometheus.GaugeOpts{
        Name: "goroutine_count",
        Help: "Current goroutine count",
    },
)

func RecordSystemMetrics() {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)

    memUtilization.Set(float64(m.Alloc) / float64(m.Sys) * 100)
    goroutineCount.Set(float64(runtime.NumGoroutine()))
}
```

---

### 2.3 å››ä¸ªé»„é‡‘æŒ‡æ ‡

**å®šä¹‰**: Google SREæå‡ºçš„æ ¸å¿ƒç›‘æ§æŒ‡æ ‡ã€‚

**å½¢å¼åŒ–å®šä¹‰**:

```text
GoldenSignals = {
    Latency: å»¶è¿Ÿåˆ†å¸ƒ (P50, P95, P99),
    Traffic: æµé‡å¤§å° (requests/second),
    Errors: é”™è¯¯ç‡ (errors/total),
    Saturation: é¥±å’Œåº¦ (resource usage)
}

ä¼˜å…ˆçº§: Errors > Latency > Traffic > Saturation
```

**å…³è”å…³ç³»**:

```text
Latency â†‘ â†’ å¯èƒ½å¯¼è‡´ â†’ Saturation â†‘
Traffic â†‘ â†’ å¯èƒ½å¯¼è‡´ â†’ Latency â†‘ æˆ– Errors â†‘
Errors â†‘ â†’ éœ€è¦ç«‹å³ â†’ å‘Šè­¦å¤„ç†
Saturation â†‘ â†’ é¢„ç¤ºæœªæ¥ â†’ æ€§èƒ½é—®é¢˜
```

---

## 3. Loggingæ¦‚å¿µ

### 3.1 ç»“æ„åŒ–æ—¥å¿—

**å®šä¹‰**: ä»¥ç»“æ„åŒ–æ ¼å¼ï¼ˆJSONç­‰ï¼‰è®°å½•æ—¥å¿—ï¼Œä¾¿äºæœºå™¨è§£æã€‚

**å½¢å¼åŒ–å®šä¹‰**:

```text
StructuredLog = {
    timestamp: Time,
    level: LogLevel,
    message: string,
    fields: Map[string]interface{},
    context: {
        trace_id: string,
        span_id: string,
        service: string
    }
}

ä¼˜åŠ¿:
- æœºå™¨å¯è§£æ
- æŸ¥è¯¢é«˜æ•ˆ
- æ”¯æŒèšåˆåˆ†æ
```

**Goå®è·µ (zap)**:

```go
logger, _ := zap.NewProduction()
defer logger.Sync()

logger.Info("user action",
    zap.String("action", "login"),
    zap.String("user_id", "12345"),
    zap.String("ip", "192.168.1.1"),
    zap.String("trace_id", traceID),
    zap.Duration("latency", latency),
)

// è¾“å‡ºJSON:
// {"level":"info","ts":1698765432.123,"msg":"user action",
//  "action":"login","user_id":"12345","ip":"192.168.1.1",
//  "trace_id":"abc123","latency":0.05}
```

---

### 3.2 æ—¥å¿—çº§åˆ«

**å®šä¹‰**: æ—¥å¿—æ¶ˆæ¯çš„ä¸¥é‡ç¨‹åº¦åˆ†çº§ã€‚

**æ ‡å‡†å®šä¹‰**:

```text
LogLevels = {
    TRACE: 0,   // æœ€è¯¦ç»†çš„è°ƒè¯•ä¿¡æ¯
    DEBUG: 1,   // è°ƒè¯•ä¿¡æ¯
    INFO:  2,   // ä¸€èˆ¬ä¿¡æ¯
    WARN:  3,   // è­¦å‘Šä¿¡æ¯
    ERROR: 4,   // é”™è¯¯ä¿¡æ¯
    FATAL: 5,   // è‡´å‘½é”™è¯¯
    PANIC: 6    // ææ…Œé”™è¯¯
}

è¿‡æ»¤è§„åˆ™:
if log.Level >= config.MinLevel {
    output(log)
}
```

**ä½¿ç”¨åŸåˆ™**:

```text
- DEBUG: å¼€å‘ç¯å¢ƒè¯¦ç»†æ—¥å¿—ï¼Œç”Ÿäº§å…³é—­
- INFO:  å…³é”®ä¸šåŠ¡æµç¨‹ï¼Œé€‚é‡ä½¿ç”¨
- WARN:  æ½œåœ¨é—®é¢˜ï¼Œéœ€å…³æ³¨ä½†ä¸ç´§æ€¥
- ERROR: é”™è¯¯éœ€å¤„ç†ï¼Œä½†ç¨‹åºç»§ç»­
- FATAL: ä¸¥é‡é”™è¯¯ï¼Œç¨‹åºé€€å‡º
- PANIC: ä¸å¯æ¢å¤é”™è¯¯ï¼Œpanic
```

---

### 3.3 TraceIDå…³è”

**å®šä¹‰**: é€šè¿‡å”¯ä¸€IDå…³è”åŒä¸€è¯·æ±‚çš„æ‰€æœ‰æ—¥å¿—å’Œè¿½è¸ªã€‚

**å½¢å¼åŒ–å®šä¹‰**:

```text
TraceContext = {
    trace_id: UUID,
    span_id: UUID,
    parent_span_id: UUID | null
}

ä¼ æ’­æœºåˆ¶:
1. å…¥å£ç”ŸæˆTraceID
2. é€šè¿‡Contextä¼ é€’
3. æ—¥å¿—/Spanè®°å½•TraceID
4. è·¨æœåŠ¡é€šè¿‡HTTP Headerä¼ é€’
```

**Goå®è·µ**:

```go
type contextKey string

const traceIDKey contextKey = "trace_id"

// ç”ŸæˆTraceID
func GenerateTraceID() string {
    return uuid.New().String()
}

// æ³¨å…¥Context
func WithTraceID(ctx context.Context, traceID string) context.Context {
    return context.WithValue(ctx, traceIDKey, traceID)
}

// æå–TraceID
func GetTraceID(ctx context.Context) string {
    if traceID, ok := ctx.Value(traceIDKey).(string); ok {
        return traceID
    }
    return ""
}

// æ—¥å¿—è®°å½•
func LogWithTrace(ctx context.Context, msg string) {
    traceID := GetTraceID(ctx)
    logger.Info(msg, zap.String("trace_id", traceID))
}

// HTTPä¼ æ’­
func PropagateTrace(req *http.Request, ctx context.Context) {
    traceID := GetTraceID(ctx)
    req.Header.Set("X-Trace-ID", traceID)
}
```

---

## 4. Tracingæ¦‚å¿µ

### 4.1 Span (è·¨åº¦)

**å®šä¹‰**: è¡¨ç¤ºä¸€ä¸ªæ“ä½œçš„æ—¶é—´æ®µï¼Œæ˜¯è¿½è¸ªçš„åŸºæœ¬å•å…ƒã€‚

**å½¢å¼åŒ–å®šä¹‰**:

```text
Span = {
    span_id: UUID,
    trace_id: UUID,
    parent_span_id: UUID | null,
    operation_name: string,
    start_time: Timestamp,
    end_time: Timestamp,
    duration: end_time - start_time,
    tags: Map[string]interface{},
    logs: []LogEntry
}

å…³ç³»:
Trace = Tree<Span>
```

**Goå®è·µ (OpenTelemetry)**:

```go
func ProcessOrder(ctx context.Context, orderID string) error {
    // åˆ›å»ºSpan
    ctx, span := tracer.Start(ctx, "process_order")
    defer span.End()

    // æ·»åŠ å±æ€§
    span.SetAttributes(
        attribute.String("order.id", orderID),
        attribute.Int("order.items", 5),
    )

    // å­Span
    if err := validateOrder(ctx, orderID); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }

    if err := saveOrder(ctx, orderID); err != nil {
        span.RecordError(err)
        return err
    }

    span.SetStatus(codes.Ok, "order processed")
    return nil
}

func validateOrder(ctx context.Context, orderID string) error {
    ctx, span := tracer.Start(ctx, "validate_order")
    defer span.End()
    // éªŒè¯é€»è¾‘
    return nil
}
```

---

### 4.2 Contextä¼ æ’­

**å®šä¹‰**: åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ä¼ é€’è¿½è¸ªä¸Šä¸‹æ–‡çš„æœºåˆ¶ã€‚

**ä¼ æ’­æ ¼å¼**:

```text
W3C Trace Context:
traceparent: 00-{trace-id}-{span-id}-{flags}
tracestate: vendor1=value1,vendor2=value2

B3 (Zipkin):
X-B3-TraceId: {trace-id}
X-B3-SpanId: {span-id}
X-B3-ParentSpanId: {parent-span-id}
X-B3-Sampled: {0|1}
```

**Goå®è·µ**:

```go
// HTTPå®¢æˆ·ç«¯æ³¨å…¥
func DoRequest(ctx context.Context, url string) (*http.Response, error) {
    req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)

    // OpenTelemetryè‡ªåŠ¨æ³¨å…¥
    // æˆ–æ‰‹åŠ¨:
    span := trace.SpanFromContext(ctx)
    if span.SpanContext().IsValid() {
        traceID := span.SpanContext().TraceID().String()
        spanID := span.SpanContext().SpanID().String()
        req.Header.Set("traceparent",
            fmt.Sprintf("00-%s-%s-01", traceID, spanID))
    }

    return http.DefaultClient.Do(req)
}

// HTTPæœåŠ¡ç«¯æå–
func ExtractTraceContext(r *http.Request) context.Context {
    ctx := r.Context()
    // OpenTelemetryè‡ªåŠ¨æå–
    // æˆ–æ‰‹åŠ¨ä»Headeræå–å¹¶åˆ›å»ºSpanContext
    return ctx
}
```

---

### 4.3 é‡‡æ ·ç­–ç•¥

**å®šä¹‰**: å†³å®šå“ªäº›è¯·æ±‚è¢«è®°å½•è¿½è¸ªçš„ç­–ç•¥ã€‚

**å½¢å¼åŒ–å®šä¹‰**:

```text
SamplingStrategy = {
    rate: float64,  // é‡‡æ ·ç‡ (0-1)
    decision: func(ctx) â†’ bool
}

å¸¸è§ç­–ç•¥:
1. å›ºå®šé‡‡æ ·ç‡: P(sample) = rate
2. è‡ªé€‚åº”é‡‡æ ·: rate = f(load, error_rate)
3. å°¾éƒ¨é‡‡æ ·: decision after request completes
4. é”™è¯¯é‡‡æ ·: always sample if error
```

**Goå®è·µ**:

```go
// å›ºå®šé‡‡æ ·ç‡
sampler := trace.TraceIDRatioBased(0.1) // 10%é‡‡æ ·

// æ¡ä»¶é‡‡æ ·
type CustomSampler struct{}

func (s *CustomSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    // é”™è¯¯å¿…é‡‡æ ·
    if hasError(p) {
        return trace.SamplingResult{
            Decision: trace.RecordAndSample,
        }
    }

    // æ…¢è¯·æ±‚å¿…é‡‡æ ·
    if isSlow(p) {
        return trace.SamplingResult{
            Decision: trace.RecordAndSample,
        }
    }

    // å…¶ä»–1%é‡‡æ ·
    if rand.Float64() < 0.01 {
        return trace.SamplingResult{
            Decision: trace.RecordAndSample,
        }
    }

    return trace.SamplingResult{
        Decision: trace.Drop,
    }
}
```

---

## 5. SREæ¦‚å¿µ

### 5.1 SLI/SLO/SLA

**å®šä¹‰**: æœåŠ¡è´¨é‡çš„ä¸‰ä¸ªå…³é”®æŒ‡æ ‡ã€‚

**å½¢å¼åŒ–å®šä¹‰**:

```text
SLI (Service Level Indicator):
- å®šä¹‰: æœåŠ¡è´¨é‡çš„é‡åŒ–æŒ‡æ ‡
- ç¤ºä¾‹: å¯ç”¨æ€§ = æˆåŠŸè¯·æ±‚ / æ€»è¯·æ±‚

SLO (Service Level Objective):
- å®šä¹‰: SLIçš„ç›®æ ‡å€¼
- ç¤ºä¾‹: å¯ç”¨æ€§ â‰¥ 99.9%

SLA (Service Level Agreement):
- å®šä¹‰: ä¸ç”¨æˆ·çš„æœåŠ¡åè®®
- ç¤ºä¾‹: å¯ç”¨æ€§ < 99.9%æ—¶èµ”å¿

å…³ç³»: SLI â‰¥ SLO â†’ æ»¡è¶³ SLA
```

**Goç›‘æ§ç¤ºä¾‹**:

```go
// SLIè®¡ç®—
type SLI struct {
    totalRequests    int64
    successRequests  int64
}

func (s *SLI) Availability() float64 {
    if s.totalRequests == 0 {
        return 1.0
    }
    return float64(s.successRequests) / float64(s.totalRequests)
}

// SLOæ£€æŸ¥
type SLO struct {
    target float64 // ç›®æ ‡å€¼ 0.999
}

func (slo *SLO) Met(sli *SLI) bool {
    return sli.Availability() >= slo.target
}

// é”™è¯¯é¢„ç®—
func (slo *SLO) ErrorBudget(sli *SLI) float64 {
    allowed := (1 - slo.target) * float64(sli.totalRequests)
    actual := float64(sli.totalRequests - sli.successRequests)
    return (allowed - actual) / allowed
}
```

---

### 5.2 é”™è¯¯é¢„ç®—

**å®šä¹‰**: å…è®¸çš„æœ€å¤§å¤±è´¥ç‡ï¼Œç”¨äºå¹³è¡¡å¯é æ€§å’Œåˆ›æ–°é€Ÿåº¦ã€‚

**å½¢å¼åŒ–å®šä¹‰**:

```text
ErrorBudget = (1 - SLO) Ã— TotalRequests

ç¤ºä¾‹:
SLO = 99.9%
æ¯æœˆè¯·æ±‚ = 1,000,000
é”™è¯¯é¢„ç®— = (1 - 0.999) Ã— 1,000,000 = 1,000æ¬¡

ç­–ç•¥:
if ErrorBudget > 0:
    å¯ä»¥å‘å¸ƒæ–°åŠŸèƒ½
else:
    ä¸“æ³¨ç¨³å®šæ€§æ”¹è¿›
```

**Goå®è·µ**:

```go
type ErrorBudget struct {
    slo           float64
    totalRequests int64
    errors        int64
}

func (eb *ErrorBudget) Remaining() float64 {
    allowedErrors := (1 - eb.slo) * float64(eb.totalRequests)
    return (allowedErrors - float64(eb.errors)) / allowedErrors
}

func (eb *ErrorBudget) CanDeploy() bool {
    return eb.Remaining() > 0.1 // ä¿ç•™10%ç¼“å†²
}

func (eb *ErrorBudget) Status() string {
    remaining := eb.Remaining()
    switch {
    case remaining > 0.5:
        return "å¥åº·"
    case remaining > 0.1:
        return "è­¦å‘Š"
    default:
        return "è€—å°½-å†»ç»“å‘å¸ƒ"
    }
}
```

---

## ğŸ”— ç›¸å…³æ–‡æ¡£

- [çŸ¥è¯†å›¾è°±](./00-çŸ¥è¯†å›¾è°±.md)
- [å¯¹æ¯”çŸ©é˜µ](./00-å¯¹æ¯”çŸ©é˜µ.md)
- [README.md](./README.md)

---

**æœ€åæ›´æ–°**: 2025-10-29
