# 知识图谱

**版本**: v1.0
**更新日期**: 2025-11-11
**适用于**: Go 1.25.3
**文件夹**: practices/observability

---

## 📋 目录

- [知识图谱](#知识图谱)
  - [📋 目录](#-目录)
  - [1. 知识结构树](#1-知识结构树)
  - [2. 可观测性三支柱](#2-可观测性三支柱)
    - [2.1 三支柱关系](#21-三支柱关系)
    - [2.2 互补作用](#22-互补作用)
  - [3. 学习路径](#3-学习路径)
    - [🎯 初级路径 (1-2个月)](#-初级路径-1-2个月)
    - [🚀 中级路径 (2-3个月)](#-中级路径-2-3个月)
    - [💎 高级路径 (持续)](#-高级路径-持续)
  - [4. 核心概念清单](#4-核心概念清单)
    - [📊 Metrics (8个)](#-metrics-8个)
    - [📝 Logging (6个)](#-logging-6个)
    - [🔍 Tracing (7个)](#-tracing-7个)
    - [🚨 Alerting (5个)](#-alerting-5个)
  - [5. Go实践建议](#5-go实践建议)
    - [🎯 Metrics实践 (Prometheus)](#-metrics实践-prometheus)
    - [🎯 Logging实践 (zap)](#-logging实践-zap)
    - [🎯 Tracing实践 (OpenTelemetry)](#-tracing实践-opentelemetry)
    - [💡 最佳实践](#-最佳实践)
  - [🔗 相关文档](#-相关文档)

---

## 1. 知识结构树

```text
Go可观测性完整体系 (Observability)
│
├── 📊 Metrics (监控指标)
│   ├── 指标类型
│   │   ├── Counter (计数器)
│   │   ├── Gauge (仪表盘)
│   │   ├── Histogram (直方图)
│   │   └── Summary (摘要)
│   ├── 监控系统
│   │   ├── Prometheus
│   │   │   ├── 数据模型
│   │   │   ├── PromQL查询
│   │   │   ├── 抓取配置
│   │   │   └── 服务发现
│   │   ├── Grafana
│   │   │   ├── Dashboard设计
│   │   │   ├── Panel配置
│   │   │   ├── 告警规则
│   │   │   └── 数据源集成
│   │   ├── VictoriaMetrics
│   │   └── InfluxDB
│   ├── Go指标库
│   │   ├── prometheus/client_golang
│   │   ├── go-metrics
│   │   └── statsd
│   └── 关键指标
│       ├── RED (Rate, Errors, Duration)
│       ├── USE (Utilization, Saturation, Errors)
│       ├── 四个黄金指标
│       └── SLI/SLO/SLA
│
├── 📝 Logging (日志)
│   ├── 日志级别
│   │   ├── TRACE/DEBUG
│   │   ├── INFO
│   │   ├── WARN/ERROR
│   │   └── FATAL/PANIC
│   ├── 日志格式
│   │   ├── 结构化日志 (JSON)
│   │   ├── 日志字段标准化
│   │   ├── TraceID关联
│   │   └── 上下文传递
│   ├── 日志库
│   │   ├── slog (标准库 Go 1.21+)
│   │   ├── zap (高性能)
│   │   ├── logrus
│   │   └── zerolog
│   ├── 日志采集
│   │   ├── Filebeat
│   │   ├── Fluentd
│   │   ├── Logstash
│   │   └── Fluent Bit
│   ├── 日志聚合
│   │   ├── ELK Stack
│   │   │   ├── Elasticsearch
│   │   │   ├── Logstash
│   │   │   └── Kibana
│   │   ├── Loki + Grafana
│   │   ├── Splunk
│   │   └── CloudWatch Logs
│   └── 日志管理
│       ├── 日志采样
│       ├── 日志轮转
│       ├── 日志压缩
│       └── 日志保留策略
│
├── 🔍 Tracing (链路追踪)
│   ├── 追踪标准
│   │   ├── OpenTelemetry
│   │   ├── OpenTracing (已废弃)
│   │   └── Zipkin标准
│   ├── 追踪系统
│   │   ├── Jaeger
│   │   │   ├── Agent/Collector
│   │   │   ├── 存储后端
│   │   │   ├── UI查询
│   │   │   └── 采样策略
│   │   ├── Zipkin
│   │   ├── SkyWalking
│   │   └── AWS X-Ray
│   ├── Go追踪库
│   │   ├── opentelemetry-go
│   │   ├── jaeger-client-go
│   │   └── zipkin-go
│   ├── 追踪概念
│   │   ├── Trace (追踪)
│   │   ├── Span (跨度)
│   │   ├── Context传播
│   │   └── Baggage
│   └── 采样策略
│       ├── 头部采样
│       ├── 尾部采样
│       ├── 自适应采样
│       └── 错误采样
│
├── 🚨 Alerting (告警)
│   ├── 告警系统
│   │   ├── AlertManager (Prometheus)
│   │   ├── PagerDuty
│   │   ├── OpsGenie
│   │   └── 钉钉/企业微信
│   ├── 告警规则
│   │   ├── 阈值告警
│   │   ├── 趋势告警
│   │   ├── 异常检测
│   │   └── 复合条件
│   ├── 告警级别
│   │   ├── Critical (P0)
│   │   ├── High (P1)
│   │   ├── Medium (P2)
│   │   └── Low (P3)
│   ├── 告警策略
│   │   ├── 告警路由
│   │   ├── 告警静默
│   │   ├── 告警抑制
│   │   └── 告警聚合
│   └── On-Call管理
│       ├── 值班轮换
│       ├── 升级策略
│       └── 响应SLA
│
├── 📈 APM (应用性能监控)
│   ├── APM平台
│   │   ├── New Relic
│   │   ├── Datadog
│   │   ├── Dynatrace
│   │   ├── AppDynamics
│   │   └── SkyWalking
│   ├── 性能指标
│   │   ├── 响应时间
│   │   ├── 吞吐量
│   │   ├── 错误率
│   │   └── Apdex分数
│   ├── 事务追踪
│   │   ├── Web事务
│   │   ├── 后台任务
│   │   ├── 数据库查询
│   │   └── 外部调用
│   └── 性能分析
│       ├── CPU Profile
│       ├── Memory Profile
│       ├── Goroutine Profile
│       └── 火焰图
│
├── 🔧 实施工具
│   ├── OpenTelemetry (OTEL)
│   │   ├── Collector
│   │   ├── SDK
│   │   ├── 自动注入
│   │   └── 协议 (OTLP)
│   ├── 服务网格集成
│   │   ├── Istio
│   │   ├── Linkerd
│   │   └── Envoy
│   ├── 云原生工具
│   │   ├── K8s Dashboard
│   │   ├── Prometheus Operator
│   │   ├── Grafana Operator
│   │   └── Loki Operator
│   └── 开源方案
│       ├── 轻量级栈 (Prometheus+Loki+Tempo+Grafana)
│       ├── ELK栈
│       └── 完整OTEL栈
│
└── 🎯 最佳实践
    ├── SLI/SLO/SLA定义
    ├── 错误预算
    ├── 告警降噪
    ├── 成本优化
    ├── 数据保留策略
    └── 隐私合规
```

---

## 2. 可观测性三支柱

### 2.1 三支柱关系

```text
可观测性 = Metrics + Logging + Tracing

Metrics (What)     → 什么出问题了？
Logging (Why)      → 为什么出问题？
Tracing (Where)    → 哪里出问题了？

关联方式:
├── TraceID: 关联日志和追踪
├── 时间戳: 关联指标和日志
└── 标签: 统一维度查询
```

### 2.2 互补作用

| 支柱 | 优势 | 局限 | 互补 |
|------|------|------|------|
| **Metrics** | 高效聚合，趋势分析 | 缺乏细节 | + Logging查看详情 |
| **Logging** | 详细上下文，调试友好 | 成本高，查询慢 | + Metrics定位时间 |
| **Tracing** | 完整链路，性能瓶颈 | 采样限制 | + Logging查看日志 |

---

## 3. 学习路径

### 🎯 初级路径 (1-2个月)

```text
Phase 1: Metrics基础 (2-3周)
├── Prometheus基础
├── prometheus/client_golang
├── 基本指标采集
└── Grafana简单Dashboard

Phase 2: Logging实践 (2-3周)
├── zap/slog使用
├── 结构化日志
├── 日志级别管理
└── 基本日志收集

Phase 3: 基础监控 (2-3周)
├── RED指标监控
├── 基本告警规则
├── 简单Dashboard
└── 日志查询
```

### 🚀 中级路径 (2-3个月)

```text
Phase 4: 完整Metrics (3-4周)
├── 四个黄金指标
├── USE方法论
├── 自定义指标
└── 告警优化

Phase 5: 链路追踪 (3-4周)
├── Jaeger部署
├── OpenTelemetry集成
├── 跨服务追踪
└── 采样策略

Phase 6: 日志系统 (3-4周)
├── ELK/Loki部署
├── 日志采集管道
├── 日志查询优化
└── 成本优化
```

### 💎 高级路径 (持续)

```text
Phase 7: SRE实践 (持续)
├── SLI/SLO定义
├── 错误预算
├── 容量规划
└── 告警降噪

Phase 8: 成本与性能 (持续)
├── 采样优化
├── 存储优化
├── 查询优化
└── 成本控制
```

---

## 4. 核心概念清单

### 📊 Metrics (8个)

| # | 概念 | 重要度 | 难度 | Go实现 |
|---|------|--------|------|--------|
| 1 | RED指标 | ⭐⭐⭐⭐⭐ | ⭐⭐ | Prometheus |
| 2 | 四个黄金指标 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | Prometheus |
| 3 | Counter | ⭐⭐⭐⭐⭐ | ⭐⭐ | prometheus.Counter |
| 4 | Histogram | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | prometheus.Histogram |
| 5 | Gauge | ⭐⭐⭐⭐ | ⭐⭐ | prometheus.Gauge |
| 6 | Summary | ⭐⭐⭐ | ⭐⭐⭐⭐ | prometheus.Summary |
| 7 | PromQL | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 查询语言 |
| 8 | 服务发现 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | K8s/Consul |

### 📝 Logging (6个)

| # | 概念 | 重要度 | 难度 | Go库 |
|---|------|--------|------|------|
| 1 | 结构化日志 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | zap/slog |
| 2 | 日志级别 | ⭐⭐⭐⭐⭐ | ⭐⭐ | 标准实践 |
| 3 | TraceID关联 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | Context传播 |
| 4 | 日志采样 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 性能优化 |
| 5 | ELK Stack | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 日志平台 |
| 6 | Loki | ⭐⭐⭐⭐ | ⭐⭐⭐ | Grafana生态 |

### 🔍 Tracing (7个)

| # | 概念 | 重要度 | 难度 | Go实现 |
|---|------|--------|------|--------|
| 1 | OpenTelemetry | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | otel-go |
| 2 | Jaeger | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | jaeger-client-go |
| 3 | Span | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | 追踪单元 |
| 4 | Context传播 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | B3/W3C |
| 5 | 采样策略 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 性能vs精度 |
| 6 | 服务拓扑 | ⭐⭐⭐⭐ | ⭐⭐⭐ | 依赖分析 |
| 7 | 性能瓶颈 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 慢查询分析 |

### 🚨 Alerting (5个)

| # | 概念 | 重要度 | 难度 | 工具 |
|---|------|--------|------|------|
| 1 | SLI/SLO/SLA | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | SRE核心 |
| 2 | 错误预算 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | SRE |
| 3 | 告警路由 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | AlertManager |
| 4 | 告警降噪 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 聚合/抑制 |
| 5 | On-Call | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | PagerDuty |

---

## 5. Go实践建议

### 🎯 Metrics实践 (Prometheus)

```go
import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promhttp"
)

// 定义指标
var (
    httpRequestsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total number of HTTP requests",
        },
        []string{"method", "endpoint", "status"},
    )

    httpRequestDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_request_duration_seconds",
            Help:    "HTTP request duration in seconds",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method", "endpoint"},
    )
)

func init() {
    prometheus.MustRegister(httpRequestsTotal)
    prometheus.MustRegister(httpRequestDuration)
}

// 使用
func handler(w http.ResponseWriter, r *http.Request) {
    start := time.Now()
    defer func() {
        duration := time.Since(start).Seconds()
        httpRequestDuration.WithLabelValues(r.Method, r.URL.Path).Observe(duration)
        httpRequestsTotal.WithLabelValues(r.Method, r.URL.Path, "200").Inc()
    }()
    // 业务逻辑
}

// 暴露指标
http.Handle("/metrics", promhttp.Handler())
```

### 🎯 Logging实践 (zap)

```go
import "go.uber.org/zap"

logger, _ := zap.NewProduction()
defer logger.Sync()

// 带TraceID的日志
logger.Info("processing request",
    zap.String("trace_id", traceID),
    zap.String("user_id", userID),
    zap.Duration("latency", latency),
)

// 错误日志
if err != nil {
    logger.Error("failed to process",
        zap.String("trace_id", traceID),
        zap.Error(err),
        zap.Stack("stacktrace"),
    )
}
```

### 🎯 Tracing实践 (OpenTelemetry)

```go
import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

tracer := otel.Tracer("my-service")

func processRequest(ctx Context.Context) error {
    ctx, span := tracer.Start(ctx, "processRequest")
    defer span.End()

    // 添加属性
    span.SetAttributes(
        attribute.String("user.id", userID),
        attribute.Int("item.count", count),
    )

    // 嵌套Span
    ctx, childSpan := tracer.Start(ctx, "database-query")
    result, err := db.Query(ctx, sql)
    childSpan.End()

    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }

    return nil
}
```

### 💡 最佳实践

1. **统一TraceID**: 贯穿Metrics/Logs/Traces
2. **采样策略**: 生产环境1-10%采样
3. **告警分级**: 按影响范围和紧急程度
4. **成本控制**: 日志采样+数据保留策略
5. **隐私保护**: 敏感信息脱敏

---

## 🔗 相关文档
