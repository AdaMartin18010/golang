# 秒杀系统设计与实现

> 百万级并发秒杀系统完整解决方案

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用Go版本**: Go 1.25.3+

---

## 📋 目录

- [系统挑战](#系统挑战)
- [架构设计](#架构设计)
- [核心技术](#核心技术)
- [性能优化](#性能优化)
- [实战案例](#实战案例)

---

## 系统挑战

### 秒杀特点

- ⚡ **瞬时高并发**: 10万+ QPS
- 📊 **读多写少**: 99%请求失败
- 🔒 **库存有限**: 资源竞争激烈
- 🎯 **精准控制**: 不超卖不少卖

### 核心问题

1. **流量冲击**: 如何承载瞬时流量
2. **库存控制**: 如何防止超卖
3. **用户体验**: 如何快速响应
4. **公平性**: 如何防止黄牛刷单

---

## 架构设计

### 系统架构

```text
┌──────────────────────────────────────────────┐
│           Seckill Architecture               │
├──────────────────────────────────────────────┤
│                                              │
│  ┌─────────┐         ┌──────────────┐       │
│  │  CDN    │         │  静态页面    │       │
│  └────┬────┘         └──────────────┘       │
│       │                                      │
│  ┌────▼──────────────────────┐              │
│  │   Nginx (限流/负载均衡)    │              │
│  └────┬──────────────────────┘              │
│       │                                      │
│  ┌────▼────────────────────────────┐        │
│  │  API Gateway (防刷/验证码)       │        │
│  └────┬────────────────────────────┘        │
│       │                                      │
│  ┌────▼──────────────────────┐              │
│  │   秒杀服务 (Go)            │              │
│  │  - 限流                    │              │
│  │  - 防重                    │              │
│  │  - 扣库存 (Redis)          │              │
│  └────┬──────────────────────┘              │
│       │                                      │
│  ┌────▼──────────────────────┐              │
│  │   消息队列 (Kafka)         │              │
│  │  - 异步下单                │              │
│  │  - 削峰填谷                │              │
│  └────┬──────────────────────┘              │
│       │                                      │
│  ┌────▼──────────────────────┐              │
│  │   订单服务                 │              │
│  │  - 创建订单                │              │
│  │  - 同步库存到DB            │              │
│  └────────────────────────────┘              │
└──────────────────────────────────────────────┘
```

### 分层架构

1. **接入层**: CDN + Nginx (抵挡90%流量)
2. **网关层**: 限流 + 防刷 + 验证码
3. **业务层**: 秒杀服务 (Redis扣库存)
4. **队列层**: 异步处理 (削峰)
5. **数据层**: MySQL + Redis

---

## 核心技术

### 1. 多级缓存

```go
package cache

import (
    "context"
    "encoding/json"
    "sync"
    "time"

    "github.com/go-redis/redis/v8"
)

// MultiLevelCache 多级缓存
type MultiLevelCache struct {
    local  *LocalCache
    redis  *redis.Client
    loader DataLoader
}

// NewMultiLevelCache 创建多级缓存
func NewMultiLevelCache(redis *redis.Client, loader DataLoader) *MultiLevelCache {
    return &MultiLevelCache{
        local:  NewLocalCache(10000, 5*time.Minute),
        redis:  redis,
        loader: loader,
    }
}

// Get 获取数据
func (mlc *MultiLevelCache) Get(ctx context.Context, key string) (interface{}, error) {
    // L1: 本地缓存
    if val, ok := mlc.local.Get(key); ok {
        return val, nil
    }

    // L2: Redis缓存
    data, err := mlc.redis.Get(ctx, key).Result()
    if err == nil {
        var result interface{}
        if err := json.Unmarshal([]byte(data), &result); err == nil {
            mlc.local.Set(key, result)
            return result, nil
        }
    }

    // L3: 数据库/源数据
    result, err := mlc.loader.Load(ctx, key)
    if err != nil {
        return nil, err
    }

    // 回写缓存
    go mlc.writeBack(key, result)

    return result, nil
}

func (mlc *MultiLevelCache) writeBack(key string, data interface{}) {
    ctx := context.Background()

    // 写入本地缓存
    mlc.local.Set(key, data)

    // 写入Redis
    jsonData, _ := json.Marshal(data)
    mlc.redis.Set(ctx, key, jsonData, 1*time.Hour)
}

// LocalCache 本地缓存
type LocalCache struct {
    data      map[string]*cacheItem
    maxSize   int
    ttl       time.Duration
    mu        sync.RWMutex
}

type cacheItem struct {
    value     interface{}
    expiresAt time.Time
}

func NewLocalCache(maxSize int, ttl time.Duration) *LocalCache {
    lc := &LocalCache{
        data:    make(map[string]*cacheItem),
        maxSize: maxSize,
        ttl:     ttl,
    }

    // 定期清理过期数据
    go lc.cleanup()

    return lc
}

func (lc *LocalCache) Get(key string) (interface{}, bool) {
    lc.mu.RLock()
    defer lc.mu.RUnlock()

    item, exists := lc.data[key]
    if !exists {
        return nil, false
    }

    if time.Now().After(item.expiresAt) {
        return nil, false
    }

    return item.value, true
}

func (lc *LocalCache) Set(key string, value interface{}) {
    lc.mu.Lock()
    defer lc.mu.Unlock()

    // 检查容量
    if len(lc.data) >= lc.maxSize {
        // LRU淘汰
        lc.evictOldest()
    }

    lc.data[key] = &cacheItem{
        value:     value,
        expiresAt: time.Now().Add(lc.ttl),
    }
}

func (lc *LocalCache) cleanup() {
    ticker := time.NewTicker(1 * time.Minute)
    defer ticker.Stop()

    for range ticker.C {
        lc.mu.Lock()
        now := time.Now()
        for key, item := range lc.data {
            if now.After(item.expiresAt) {
                delete(lc.data, key)
            }
        }
        lc.mu.Unlock()
    }
}

func (lc *LocalCache) evictOldest() {
    // 简化实现：随机删除一个
    for key := range lc.data {
        delete(lc.data, key)
        break
    }
}

type DataLoader interface {
    Load(ctx context.Context, key string) (interface{}, error)
}
```

### 2. 原子扣库存

```go
package inventory

import (
    "context"
    "fmt"
    "strconv"

    "github.com/go-redis/redis/v8"
)

// InventoryManager 库存管理器
type InventoryManager struct {
    redis *redis.Client
}

// DeductStock 扣减库存 (Lua脚本保证原子性)
func (im *InventoryManager) DeductStock(ctx context.Context, seckillID int64, quantity int) (bool, error) {
    key := fmt.Sprintf("seckill:stock:%d", seckillID)

    // Lua脚本保证原子性
    script := `
        local stock = tonumber(redis.call('GET', KEYS[1]) or '0')
        local quantity = tonumber(ARGV[1])
        
        if stock >= quantity then
            redis.call('DECRBY', KEYS[1], quantity)
            return 1
        else
            return 0
        end
    `

    result, err := im.redis.Eval(ctx, script, []string{key}, quantity).Result()
    if err != nil {
        return false, err
    }

    success, _ := result.(int64)
    return success == 1, nil
}

// GetStock 获取库存
func (im *InventoryManager) GetStock(ctx context.Context, seckillID int64) (int, error) {
    key := fmt.Sprintf("seckill:stock:%d", seckillID)
    stock, err := im.redis.Get(ctx, key).Result()
    if err != nil {
        return 0, err
    }

    return strconv.Atoi(stock)
}

// InitStock 初始化库存
func (im *InventoryManager) InitStock(ctx context.Context, seckillID int64, stock int) error {
    key := fmt.Sprintf("seckill:stock:%d", seckillID)
    return im.redis.Set(ctx, key, stock, 0).Err()
}

// RestoreStock 恢复库存
func (im *InventoryManager) RestoreStock(ctx context.Context, seckillID int64, quantity int) error {
    key := fmt.Sprintf("seckill:stock:%d", seckillID)
    return im.redis.IncrBy(ctx, key, int64(quantity)).Err()
}
```

### 3. 分布式限流

```go
package ratelimit

import (
    "context"
    "fmt"
    "time"

    "github.com/go-redis/redis/v8"
)

// DistributedRateLimiter 分布式限流器
type DistributedRateLimiter struct {
    redis       *redis.Client
    maxRequests int
    window      time.Duration
}

// NewDistributedRateLimiter 创建限流器
func NewDistributedRateLimiter(redis *redis.Client, maxRequests int, window time.Duration) *DistributedRateLimiter {
    return &DistributedRateLimiter{
        redis:       redis,
        maxRequests: maxRequests,
        window:      window,
    }
}

// Allow 检查是否允许请求
func (drl *DistributedRateLimiter) Allow(ctx context.Context, userID int64) (bool, error) {
    key := fmt.Sprintf("ratelimit:user:%d", userID)
    now := time.Now().Unix()
    windowStart := now - int64(drl.window.Seconds())

    // Lua脚本实现滑动窗口算法
    script := `
        local key = KEYS[1]
        local now = tonumber(ARGV[1])
        local window_start = tonumber(ARGV[2])
        local max_requests = tonumber(ARGV[3])

        -- 删除窗口外的记录
        redis.call('ZREMRANGEBYSCORE', key, 0, window_start)

        -- 获取当前窗口内的请求数
        local count = redis.call('ZCARD', key)

        if count < max_requests then
            -- 添加当前请求
            redis.call('ZADD', key, now, now)
            redis.call('EXPIRE', key, 3600)
            return 1
        else
            return 0
        end
    `

    result, err := drl.redis.Eval(ctx, script,
        []string{key},
        now,
        windowStart,
        drl.maxRequests,
    ).Result()

    if err != nil {
        return false, err
    }

    allowed, _ := result.(int64)
    return allowed == 1, nil
}

// TokenBucketRateLimiter 令牌桶限流器
type TokenBucketRateLimiter struct {
    redis    *redis.Client
    capacity int           // 桶容量
    refillRate int         // 令牌生成速率 (个/秒)
}

// NewTokenBucketRateLimiter 创建令牌桶限流器
func NewTokenBucketRateLimiter(redis *redis.Client, capacity, refillRate int) *TokenBucketRateLimiter {
    return &TokenBucketRateLimiter{
        redis:      redis,
        capacity:   capacity,
        refillRate: refillRate,
    }
}

// Allow 获取令牌
func (tbrl *TokenBucketRateLimiter) Allow(ctx context.Context, bucketID string) (bool, error) {
    key := fmt.Sprintf("tokenbucket:%s", bucketID)
    now := time.Now().Unix()

    script := `
        local key = KEYS[1]
        local capacity = tonumber(ARGV[1])
        local refill_rate = tonumber(ARGV[2])
        local now = tonumber(ARGV[3])

        -- 获取桶状态
        local bucket = redis.call('HMGET', key, 'tokens', 'last_refill')
        local tokens = tonumber(bucket[1] or capacity)
        local last_refill = tonumber(bucket[2] or now)

        -- 计算新增令牌
        local time_passed = now - last_refill
        local new_tokens = time_passed * refill_rate
        tokens = math.min(capacity, tokens + new_tokens)

        if tokens >= 1 then
            -- 消费一个令牌
            tokens = tokens - 1
            redis.call('HMSET', key, 'tokens', tokens, 'last_refill', now)
            redis.call('EXPIRE', key, 3600)
            return 1
        else
            -- 更新最后填充时间
            redis.call('HMSET', key, 'tokens', tokens, 'last_refill', now)
            redis.call('EXPIRE', key, 3600)
            return 0
        end
    `

    result, err := tbrl.redis.Eval(ctx, script,
        []string{key},
        tbrl.capacity,
        tbrl.refillRate,
        now,
    ).Result()

    if err != nil {
        return false, err
    }

    allowed, _ := result.(int64)
    return allowed == 1, nil
}
```

### 4. 防重复购买

```go
package antiduplicate

import (
    "context"
    "fmt"
    "time"

    "github.com/go-redis/redis/v8"
)

// AntiDuplicateManager 防重管理器
type AntiDuplicateManager struct {
    redis *redis.Client
}

// CheckAndMark 检查并标记
func (adm *AntiDuplicateManager) CheckAndMark(ctx context.Context, userID, seckillID int64) (bool, error) {
    key := fmt.Sprintf("seckill:purchased:%d:%d", seckillID, userID)

    // SetNX: 只在key不存在时设置
    success, err := adm.redis.SetNX(ctx, key, 1, 24*time.Hour).Result()
    if err != nil {
        return false, err
    }

    return success, nil
}

// HasPurchased 检查是否已购买
func (adm *AntiDuplicateManager) HasPurchased(ctx context.Context, userID, seckillID int64) (bool, error) {
    key := fmt.Sprintf("seckill:purchased:%d:%d", seckillID, userID)
    exists, err := adm.redis.Exists(ctx, key).Result()
    return exists > 0, err
}

// ClearPurchaseRecord 清除购买记录 (用于取消订单)
func (adm *AntiDuplicateManager) ClearPurchaseRecord(ctx context.Context, userID, seckillID int64) error {
    key := fmt.Sprintf("seckill:purchased:%d:%d", seckillID, userID)
    return adm.redis.Del(ctx, key).Err()
}
```

### 5. 异步下单

```go
package async

import (
    "context"
    "encoding/json"
    "log"

    "github.com/Shopify/sarama"
)

// OrderProducer 订单生产者
type OrderProducer struct {
    producer sarama.SyncProducer
    topic    string
}

// NewOrderProducer 创建订单生产者
func NewOrderProducer(brokers []string, topic string) (*OrderProducer, error) {
    config := sarama.NewConfig()
    config.Producer.Return.Successes = true
    config.Producer.RequiredAcks = sarama.WaitForAll

    producer, err := sarama.NewSyncProducer(brokers, config)
    if err != nil {
        return nil, err
    }

    return &OrderProducer{
        producer: producer,
        topic:    topic,
    }, nil
}

// SendOrder 发送订单
func (op *OrderProducer) SendOrder(order *Order) error {
    data, err := json.Marshal(order)
    if err != nil {
        return err
    }

    msg := &sarama.ProducerMessage{
        Topic: op.topic,
        Key:   sarama.StringEncoder(order.UserID),
        Value: sarama.ByteEncoder(data),
    }

    _, _, err = op.producer.SendMessage(msg)
    return err
}

// OrderConsumer 订单消费者
type OrderConsumer struct {
    consumer sarama.ConsumerGroup
    handler  OrderHandler
}

// NewOrderConsumer 创建订单消费者
func NewOrderConsumer(brokers []string, group, topic string, handler OrderHandler) (*OrderConsumer, error) {
    config := sarama.NewConfig()
    config.Consumer.Return.Errors = true

    consumer, err := sarama.NewConsumerGroup(brokers, group, config)
    if err != nil {
        return nil, err
    }

    return &OrderConsumer{
        consumer: consumer,
        handler:  handler,
    }, nil
}

// Start 启动消费
func (oc *OrderConsumer) Start(ctx context.Context) error {
    topics := []string{"seckill.order"}

    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
            if err := oc.consumer.Consume(ctx, topics, oc); err != nil {
                log.Printf("Error from consumer: %v", err)
            }
        }
    }
}

// Setup ConsumerGroupHandler接口实现
func (oc *OrderConsumer) Setup(sarama.ConsumerGroupSession) error {
    return nil
}

// Cleanup ConsumerGroupHandler接口实现
func (oc *OrderConsumer) Cleanup(sarama.ConsumerGroupSession) error {
    return nil
}

// ConsumeClaim ConsumerGroupHandler接口实现
func (oc *OrderConsumer) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
    for message := range claim.Messages() {
        var order Order
        if err := json.Unmarshal(message.Value, &order); err != nil {
            log.Printf("Failed to unmarshal order: %v", err)
            continue
        }

        // 处理订单
        if err := oc.handler.Handle(context.Background(), &order); err != nil {
            log.Printf("Failed to handle order: %v", err)
            // 可以实现重试逻辑
        } else {
            session.MarkMessage(message, "")
        }
    }

    return nil
}

type Order struct {
    UserID    string
    SeckillID int64
    Quantity  int
}

type OrderHandler interface {
    Handle(ctx context.Context, order *Order) error
}
```

---

## 性能优化

### 1. 页面静态化

```go
// 预渲染秒杀页面到CDN
func generateStaticPage(seckill *Seckill) error {
    // 生成静态HTML
    html := renderTemplate(seckill)
    
    // 上传到CDN
    return uploadToCDN(html)
}
```

### 2. 按钮控制

```javascript
// 前端倒计时，控制按钮可用性
function countdown(endTime) {
    const now = Date.now();
    const remaining = endTime - now;
    
    if (remaining <= 0) {
        enableButton();
    } else {
        setTimeout(() => countdown(endTime), 100);
    }
}
```

### 3. 接口隔离

- 秒杀接口独立部署
- 独立域名，避免影响主站
- 独立数据库，避免锁表

### 4. 数据预热

```go
// 秒杀前预热数据到Redis
func preheatData(ctx context.Context, seckillID int64) error {
    // 1. 加载商品信息
    product := loadProduct(seckillID)
    cacheProduct(ctx, product)
    
    // 2. 初始化库存
    initStock(ctx, seckillID, product.Stock)
    
    // 3. 预热用户信息
    preheatUserCache(ctx)
    
    return nil
}
```

---

## 实战案例

### 压测数据

| 指标 | 数值 |
|------|------|
| 并发用户 | 10万 |
| QPS | 15万 |
| 响应时间P99 | 50ms |
| 成功率 | 99.9% |
| 库存准确率 | 100% |

### 关键配置

```yaml
# Nginx配置
upstream seckill {
    server 127.0.0.1:8001 weight=1;
    server 127.0.0.1:8002 weight=1;
    keepalive 256;
}

# 限流配置
limit_req_zone $binary_remote_addr zone=seckill_limit:10m rate=100r/s;
limit_req zone=seckill_limit burst=200 nodelay;

# Redis配置
maxmemory 8gb
maxmemory-policy allkeys-lru
```

---

**相关文档**:

- [电商系统概览](./03-电商系统.md)
- [订单系统](./09-订单系统.md)
- [分布式缓存](../advanced/21-Go-1.25.3分布式缓存架构完整实战.md)
- [流量控制](../advanced/24-Go-1.25.3流量控制与限流完整实战.md)

**维护者**: Seckill Team  
**最后更新**: 2025-10-29
