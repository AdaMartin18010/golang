# ç§’æ€ç³»ç»Ÿè®¾è®¡ä¸å®ç°

> ç™¾ä¸‡çº§å¹¶å‘ç§’æ€ç³»ç»Ÿå®Œæ•´è§£å†³æ–¹æ¡ˆ

**ç‰ˆæœ¬**: v1.0  
**æ›´æ–°æ—¥æœŸ**: 2025-10-29  
**é€‚ç”¨Goç‰ˆæœ¬**: Go 1.25.3+

---

## ğŸ“‹ ç›®å½•

- [ç³»ç»ŸæŒ‘æˆ˜](#ç³»ç»ŸæŒ‘æˆ˜)
- [æ¶æ„è®¾è®¡](#æ¶æ„è®¾è®¡)
- [æ ¸å¿ƒæŠ€æœ¯](#æ ¸å¿ƒæŠ€æœ¯)
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
- [å®æˆ˜æ¡ˆä¾‹](#å®æˆ˜æ¡ˆä¾‹)

---

## ç³»ç»ŸæŒ‘æˆ˜

### ç§’æ€ç‰¹ç‚¹

- âš¡ **ç¬æ—¶é«˜å¹¶å‘**: 10ä¸‡+ QPS
- ğŸ“Š **è¯»å¤šå†™å°‘**: 99%è¯·æ±‚å¤±è´¥
- ğŸ”’ **åº“å­˜æœ‰é™**: èµ„æºç«äº‰æ¿€çƒˆ
- ğŸ¯ **ç²¾å‡†æ§åˆ¶**: ä¸è¶…å–ä¸å°‘å–

### æ ¸å¿ƒé—®é¢˜

1. **æµé‡å†²å‡»**: å¦‚ä½•æ‰¿è½½ç¬æ—¶æµé‡
2. **åº“å­˜æ§åˆ¶**: å¦‚ä½•é˜²æ­¢è¶…å–
3. **ç”¨æˆ·ä½“éªŒ**: å¦‚ä½•å¿«é€Ÿå“åº”
4. **å…¬å¹³æ€§**: å¦‚ä½•é˜²æ­¢é»„ç‰›åˆ·å•

---

## æ¶æ„è®¾è®¡

### ç³»ç»Ÿæ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Seckill Architecture               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  CDN    â”‚         â”‚  é™æ€é¡µé¢    â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚       â”‚                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚   Nginx (é™æµ/è´Ÿè½½å‡è¡¡)    â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚       â”‚                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚  API Gateway (é˜²åˆ·/éªŒè¯ç )       â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚       â”‚                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚   ç§’æ€æœåŠ¡ (Go)            â”‚              â”‚
â”‚  â”‚  - é™æµ                    â”‚              â”‚
â”‚  â”‚  - é˜²é‡                    â”‚              â”‚
â”‚  â”‚  - æ‰£åº“å­˜ (Redis)          â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚       â”‚                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚   æ¶ˆæ¯é˜Ÿåˆ— (Kafka)         â”‚              â”‚
â”‚  â”‚  - å¼‚æ­¥ä¸‹å•                â”‚              â”‚
â”‚  â”‚  - å‰Šå³°å¡«è°·                â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚       â”‚                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚   è®¢å•æœåŠ¡                 â”‚              â”‚
â”‚  â”‚  - åˆ›å»ºè®¢å•                â”‚              â”‚
â”‚  â”‚  - åŒæ­¥åº“å­˜åˆ°DB            â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### åˆ†å±‚æ¶æ„

1. **æ¥å…¥å±‚**: CDN + Nginx (æŠµæŒ¡90%æµé‡)
2. **ç½‘å…³å±‚**: é™æµ + é˜²åˆ· + éªŒè¯ç 
3. **ä¸šåŠ¡å±‚**: ç§’æ€æœåŠ¡ (Redisæ‰£åº“å­˜)
4. **é˜Ÿåˆ—å±‚**: å¼‚æ­¥å¤„ç† (å‰Šå³°)
5. **æ•°æ®å±‚**: MySQL + Redis

---

## æ ¸å¿ƒæŠ€æœ¯

### 1. å¤šçº§ç¼“å­˜

```go
package cache

import (
    "context"
    "encoding/json"
    "sync"
    "time"

    "github.com/go-redis/redis/v8"
)

// MultiLevelCache å¤šçº§ç¼“å­˜
type MultiLevelCache struct {
    local  *LocalCache
    redis  *redis.Client
    loader DataLoader
}

// NewMultiLevelCache åˆ›å»ºå¤šçº§ç¼“å­˜
func NewMultiLevelCache(redis *redis.Client, loader DataLoader) *MultiLevelCache {
    return &MultiLevelCache{
        local:  NewLocalCache(10000, 5*time.Minute),
        redis:  redis,
        loader: loader,
    }
}

// Get è·å–æ•°æ®
func (mlc *MultiLevelCache) Get(ctx context.Context, key string) (interface{}, error) {
    // L1: æœ¬åœ°ç¼“å­˜
    if val, ok := mlc.local.Get(key); ok {
        return val, nil
    }

    // L2: Redisç¼“å­˜
    data, err := mlc.redis.Get(ctx, key).Result()
    if err == nil {
        var result interface{}
        if err := json.Unmarshal([]byte(data), &result); err == nil {
            mlc.local.Set(key, result)
            return result, nil
        }
    }

    // L3: æ•°æ®åº“/æºæ•°æ®
    result, err := mlc.loader.Load(ctx, key)
    if err != nil {
        return nil, err
    }

    // å›å†™ç¼“å­˜
    go mlc.writeBack(key, result)

    return result, nil
}

func (mlc *MultiLevelCache) writeBack(key string, data interface{}) {
    ctx := context.Background()

    // å†™å…¥æœ¬åœ°ç¼“å­˜
    mlc.local.Set(key, data)

    // å†™å…¥Redis
    jsonData, _ := json.Marshal(data)
    mlc.redis.Set(ctx, key, jsonData, 1*time.Hour)
}

// LocalCache æœ¬åœ°ç¼“å­˜
type LocalCache struct {
    data      map[string]*cacheItem
    maxSize   int
    ttl       time.Duration
    mu        sync.RWMutex
}

type cacheItem struct {
    value     interface{}
    expiresAt time.Time
}

func NewLocalCache(maxSize int, ttl time.Duration) *LocalCache {
    lc := &LocalCache{
        data:    make(map[string]*cacheItem),
        maxSize: maxSize,
        ttl:     ttl,
    }

    // å®šæœŸæ¸…ç†è¿‡æœŸæ•°æ®
    go lc.cleanup()

    return lc
}

func (lc *LocalCache) Get(key string) (interface{}, bool) {
    lc.mu.RLock()
    defer lc.mu.RUnlock()

    item, exists := lc.data[key]
    if !exists {
        return nil, false
    }

    if time.Now().After(item.expiresAt) {
        return nil, false
    }

    return item.value, true
}

func (lc *LocalCache) Set(key string, value interface{}) {
    lc.mu.Lock()
    defer lc.mu.Unlock()

    // æ£€æŸ¥å®¹é‡
    if len(lc.data) >= lc.maxSize {
        // LRUæ·˜æ±°
        lc.evictOldest()
    }

    lc.data[key] = &cacheItem{
        value:     value,
        expiresAt: time.Now().Add(lc.ttl),
    }
}

func (lc *LocalCache) cleanup() {
    ticker := time.NewTicker(1 * time.Minute)
    defer ticker.Stop()

    for range ticker.C {
        lc.mu.Lock()
        now := time.Now()
        for key, item := range lc.data {
            if now.After(item.expiresAt) {
                delete(lc.data, key)
            }
        }
        lc.mu.Unlock()
    }
}

func (lc *LocalCache) evictOldest() {
    // ç®€åŒ–å®ç°ï¼šéšæœºåˆ é™¤ä¸€ä¸ª
    for key := range lc.data {
        delete(lc.data, key)
        break
    }
}

type DataLoader interface {
    Load(ctx context.Context, key string) (interface{}, error)
}
```

### 2. åŸå­æ‰£åº“å­˜

```go
package inventory

import (
    "context"
    "fmt"
    "strconv"

    "github.com/go-redis/redis/v8"
)

// InventoryManager åº“å­˜ç®¡ç†å™¨
type InventoryManager struct {
    redis *redis.Client
}

// DeductStock æ‰£å‡åº“å­˜ (Luaè„šæœ¬ä¿è¯åŸå­æ€§)
func (im *InventoryManager) DeductStock(ctx context.Context, seckillID int64, quantity int) (bool, error) {
    key := fmt.Sprintf("seckill:stock:%d", seckillID)

    // Luaè„šæœ¬ä¿è¯åŸå­æ€§
    script := `
        local stock = tonumber(redis.call('GET', KEYS[1]) or '0')
        local quantity = tonumber(ARGV[1])
        
        if stock >= quantity then
            redis.call('DECRBY', KEYS[1], quantity)
            return 1
        else
            return 0
        end
    `

    result, err := im.redis.Eval(ctx, script, []string{key}, quantity).Result()
    if err != nil {
        return false, err
    }

    success, _ := result.(int64)
    return success == 1, nil
}

// GetStock è·å–åº“å­˜
func (im *InventoryManager) GetStock(ctx context.Context, seckillID int64) (int, error) {
    key := fmt.Sprintf("seckill:stock:%d", seckillID)
    stock, err := im.redis.Get(ctx, key).Result()
    if err != nil {
        return 0, err
    }

    return strconv.Atoi(stock)
}

// InitStock åˆå§‹åŒ–åº“å­˜
func (im *InventoryManager) InitStock(ctx context.Context, seckillID int64, stock int) error {
    key := fmt.Sprintf("seckill:stock:%d", seckillID)
    return im.redis.Set(ctx, key, stock, 0).Err()
}

// RestoreStock æ¢å¤åº“å­˜
func (im *InventoryManager) RestoreStock(ctx context.Context, seckillID int64, quantity int) error {
    key := fmt.Sprintf("seckill:stock:%d", seckillID)
    return im.redis.IncrBy(ctx, key, int64(quantity)).Err()
}
```

### 3. åˆ†å¸ƒå¼é™æµ

```go
package ratelimit

import (
    "context"
    "fmt"
    "time"

    "github.com/go-redis/redis/v8"
)

// DistributedRateLimiter åˆ†å¸ƒå¼é™æµå™¨
type DistributedRateLimiter struct {
    redis       *redis.Client
    maxRequests int
    window      time.Duration
}

// NewDistributedRateLimiter åˆ›å»ºé™æµå™¨
func NewDistributedRateLimiter(redis *redis.Client, maxRequests int, window time.Duration) *DistributedRateLimiter {
    return &DistributedRateLimiter{
        redis:       redis,
        maxRequests: maxRequests,
        window:      window,
    }
}

// Allow æ£€æŸ¥æ˜¯å¦å…è®¸è¯·æ±‚
func (drl *DistributedRateLimiter) Allow(ctx context.Context, userID int64) (bool, error) {
    key := fmt.Sprintf("ratelimit:user:%d", userID)
    now := time.Now().Unix()
    windowStart := now - int64(drl.window.Seconds())

    // Luaè„šæœ¬å®ç°æ»‘åŠ¨çª—å£ç®—æ³•
    script := `
        local key = KEYS[1]
        local now = tonumber(ARGV[1])
        local window_start = tonumber(ARGV[2])
        local max_requests = tonumber(ARGV[3])

        -- åˆ é™¤çª—å£å¤–çš„è®°å½•
        redis.call('ZREMRANGEBYSCORE', key, 0, window_start)

        -- è·å–å½“å‰çª—å£å†…çš„è¯·æ±‚æ•°
        local count = redis.call('ZCARD', key)

        if count < max_requests then
            -- æ·»åŠ å½“å‰è¯·æ±‚
            redis.call('ZADD', key, now, now)
            redis.call('EXPIRE', key, 3600)
            return 1
        else
            return 0
        end
    `

    result, err := drl.redis.Eval(ctx, script,
        []string{key},
        now,
        windowStart,
        drl.maxRequests,
    ).Result()

    if err != nil {
        return false, err
    }

    allowed, _ := result.(int64)
    return allowed == 1, nil
}

// TokenBucketRateLimiter ä»¤ç‰Œæ¡¶é™æµå™¨
type TokenBucketRateLimiter struct {
    redis    *redis.Client
    capacity int           // æ¡¶å®¹é‡
    refillRate int         // ä»¤ç‰Œç”Ÿæˆé€Ÿç‡ (ä¸ª/ç§’)
}

// NewTokenBucketRateLimiter åˆ›å»ºä»¤ç‰Œæ¡¶é™æµå™¨
func NewTokenBucketRateLimiter(redis *redis.Client, capacity, refillRate int) *TokenBucketRateLimiter {
    return &TokenBucketRateLimiter{
        redis:      redis,
        capacity:   capacity,
        refillRate: refillRate,
    }
}

// Allow è·å–ä»¤ç‰Œ
func (tbrl *TokenBucketRateLimiter) Allow(ctx context.Context, bucketID string) (bool, error) {
    key := fmt.Sprintf("tokenbucket:%s", bucketID)
    now := time.Now().Unix()

    script := `
        local key = KEYS[1]
        local capacity = tonumber(ARGV[1])
        local refill_rate = tonumber(ARGV[2])
        local now = tonumber(ARGV[3])

        -- è·å–æ¡¶çŠ¶æ€
        local bucket = redis.call('HMGET', key, 'tokens', 'last_refill')
        local tokens = tonumber(bucket[1] or capacity)
        local last_refill = tonumber(bucket[2] or now)

        -- è®¡ç®—æ–°å¢ä»¤ç‰Œ
        local time_passed = now - last_refill
        local new_tokens = time_passed * refill_rate
        tokens = math.min(capacity, tokens + new_tokens)

        if tokens >= 1 then
            -- æ¶ˆè´¹ä¸€ä¸ªä»¤ç‰Œ
            tokens = tokens - 1
            redis.call('HMSET', key, 'tokens', tokens, 'last_refill', now)
            redis.call('EXPIRE', key, 3600)
            return 1
        else
            -- æ›´æ–°æœ€åå¡«å……æ—¶é—´
            redis.call('HMSET', key, 'tokens', tokens, 'last_refill', now)
            redis.call('EXPIRE', key, 3600)
            return 0
        end
    `

    result, err := tbrl.redis.Eval(ctx, script,
        []string{key},
        tbrl.capacity,
        tbrl.refillRate,
        now,
    ).Result()

    if err != nil {
        return false, err
    }

    allowed, _ := result.(int64)
    return allowed == 1, nil
}
```

### 4. é˜²é‡å¤è´­ä¹°

```go
package antiduplicate

import (
    "context"
    "fmt"
    "time"

    "github.com/go-redis/redis/v8"
)

// AntiDuplicateManager é˜²é‡ç®¡ç†å™¨
type AntiDuplicateManager struct {
    redis *redis.Client
}

// CheckAndMark æ£€æŸ¥å¹¶æ ‡è®°
func (adm *AntiDuplicateManager) CheckAndMark(ctx context.Context, userID, seckillID int64) (bool, error) {
    key := fmt.Sprintf("seckill:purchased:%d:%d", seckillID, userID)

    // SetNX: åªåœ¨keyä¸å­˜åœ¨æ—¶è®¾ç½®
    success, err := adm.redis.SetNX(ctx, key, 1, 24*time.Hour).Result()
    if err != nil {
        return false, err
    }

    return success, nil
}

// HasPurchased æ£€æŸ¥æ˜¯å¦å·²è´­ä¹°
func (adm *AntiDuplicateManager) HasPurchased(ctx context.Context, userID, seckillID int64) (bool, error) {
    key := fmt.Sprintf("seckill:purchased:%d:%d", seckillID, userID)
    exists, err := adm.redis.Exists(ctx, key).Result()
    return exists > 0, err
}

// ClearPurchaseRecord æ¸…é™¤è´­ä¹°è®°å½• (ç”¨äºå–æ¶ˆè®¢å•)
func (adm *AntiDuplicateManager) ClearPurchaseRecord(ctx context.Context, userID, seckillID int64) error {
    key := fmt.Sprintf("seckill:purchased:%d:%d", seckillID, userID)
    return adm.redis.Del(ctx, key).Err()
}
```

### 5. å¼‚æ­¥ä¸‹å•

```go
package async

import (
    "context"
    "encoding/json"
    "log"

    "github.com/Shopify/sarama"
)

// OrderProducer è®¢å•ç”Ÿäº§è€…
type OrderProducer struct {
    producer sarama.SyncProducer
    topic    string
}

// NewOrderProducer åˆ›å»ºè®¢å•ç”Ÿäº§è€…
func NewOrderProducer(brokers []string, topic string) (*OrderProducer, error) {
    config := sarama.NewConfig()
    config.Producer.Return.Successes = true
    config.Producer.RequiredAcks = sarama.WaitForAll

    producer, err := sarama.NewSyncProducer(brokers, config)
    if err != nil {
        return nil, err
    }

    return &OrderProducer{
        producer: producer,
        topic:    topic,
    }, nil
}

// SendOrder å‘é€è®¢å•
func (op *OrderProducer) SendOrder(order *Order) error {
    data, err := json.Marshal(order)
    if err != nil {
        return err
    }

    msg := &sarama.ProducerMessage{
        Topic: op.topic,
        Key:   sarama.StringEncoder(order.UserID),
        Value: sarama.ByteEncoder(data),
    }

    _, _, err = op.producer.SendMessage(msg)
    return err
}

// OrderConsumer è®¢å•æ¶ˆè´¹è€…
type OrderConsumer struct {
    consumer sarama.ConsumerGroup
    handler  OrderHandler
}

// NewOrderConsumer åˆ›å»ºè®¢å•æ¶ˆè´¹è€…
func NewOrderConsumer(brokers []string, group, topic string, handler OrderHandler) (*OrderConsumer, error) {
    config := sarama.NewConfig()
    config.Consumer.Return.Errors = true

    consumer, err := sarama.NewConsumerGroup(brokers, group, config)
    if err != nil {
        return nil, err
    }

    return &OrderConsumer{
        consumer: consumer,
        handler:  handler,
    }, nil
}

// Start å¯åŠ¨æ¶ˆè´¹
func (oc *OrderConsumer) Start(ctx context.Context) error {
    topics := []string{"seckill.order"}

    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
            if err := oc.consumer.Consume(ctx, topics, oc); err != nil {
                log.Printf("Error from consumer: %v", err)
            }
        }
    }
}

// Setup ConsumerGroupHandleræ¥å£å®ç°
func (oc *OrderConsumer) Setup(sarama.ConsumerGroupSession) error {
    return nil
}

// Cleanup ConsumerGroupHandleræ¥å£å®ç°
func (oc *OrderConsumer) Cleanup(sarama.ConsumerGroupSession) error {
    return nil
}

// ConsumeClaim ConsumerGroupHandleræ¥å£å®ç°
func (oc *OrderConsumer) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
    for message := range claim.Messages() {
        var order Order
        if err := json.Unmarshal(message.Value, &order); err != nil {
            log.Printf("Failed to unmarshal order: %v", err)
            continue
        }

        // å¤„ç†è®¢å•
        if err := oc.handler.Handle(context.Background(), &order); err != nil {
            log.Printf("Failed to handle order: %v", err)
            // å¯ä»¥å®ç°é‡è¯•é€»è¾‘
        } else {
            session.MarkMessage(message, "")
        }
    }

    return nil
}

type Order struct {
    UserID    string
    SeckillID int64
    Quantity  int
}

type OrderHandler interface {
    Handle(ctx context.Context, order *Order) error
}
```

---

## æ€§èƒ½ä¼˜åŒ–

### 1. é¡µé¢é™æ€åŒ–

```go
// é¢„æ¸²æŸ“ç§’æ€é¡µé¢åˆ°CDN
func generateStaticPage(seckill *Seckill) error {
    // ç”Ÿæˆé™æ€HTML
    html := renderTemplate(seckill)
    
    // ä¸Šä¼ åˆ°CDN
    return uploadToCDN(html)
}
```

### 2. æŒ‰é’®æ§åˆ¶

```javascript
// å‰ç«¯å€’è®¡æ—¶ï¼Œæ§åˆ¶æŒ‰é’®å¯ç”¨æ€§
function countdown(endTime) {
    const now = Date.now();
    const remaining = endTime - now;
    
    if (remaining <= 0) {
        enableButton();
    } else {
        setTimeout(() => countdown(endTime), 100);
    }
}
```

### 3. æ¥å£éš”ç¦»

- ç§’æ€æ¥å£ç‹¬ç«‹éƒ¨ç½²
- ç‹¬ç«‹åŸŸåï¼Œé¿å…å½±å“ä¸»ç«™
- ç‹¬ç«‹æ•°æ®åº“ï¼Œé¿å…é”è¡¨

### 4. æ•°æ®é¢„çƒ­

```go
// ç§’æ€å‰é¢„çƒ­æ•°æ®åˆ°Redis
func preheatData(ctx context.Context, seckillID int64) error {
    // 1. åŠ è½½å•†å“ä¿¡æ¯
    product := loadProduct(seckillID)
    cacheProduct(ctx, product)
    
    // 2. åˆå§‹åŒ–åº“å­˜
    initStock(ctx, seckillID, product.Stock)
    
    // 3. é¢„çƒ­ç”¨æˆ·ä¿¡æ¯
    preheatUserCache(ctx)
    
    return nil
}
```

---

## å®æˆ˜æ¡ˆä¾‹

### å‹æµ‹æ•°æ®

| æŒ‡æ ‡ | æ•°å€¼ |
|------|------|
| å¹¶å‘ç”¨æˆ· | 10ä¸‡ |
| QPS | 15ä¸‡ |
| å“åº”æ—¶é—´P99 | 50ms |
| æˆåŠŸç‡ | 99.9% |
| åº“å­˜å‡†ç¡®ç‡ | 100% |

### å…³é”®é…ç½®

```yaml
# Nginxé…ç½®
upstream seckill {
    server 127.0.0.1:8001 weight=1;
    server 127.0.0.1:8002 weight=1;
    keepalive 256;
}

# é™æµé…ç½®
limit_req_zone $binary_remote_addr zone=seckill_limit:10m rate=100r/s;
limit_req zone=seckill_limit burst=200 nodelay;

# Redisé…ç½®
maxmemory 8gb
maxmemory-policy allkeys-lru
```

---

**ç›¸å…³æ–‡æ¡£**:

- [ç”µå•†ç³»ç»Ÿæ¦‚è§ˆ](./03-ç”µå•†ç³»ç»Ÿ.md)
- [è®¢å•ç³»ç»Ÿ](./09-è®¢å•ç³»ç»Ÿ.md)
- [åˆ†å¸ƒå¼ç¼“å­˜](../advanced/21-Go-1.25.3åˆ†å¸ƒå¼ç¼“å­˜æ¶æ„å®Œæ•´å®æˆ˜.md)
- [æµé‡æ§åˆ¶](../advanced/24-Go-1.25.3æµé‡æ§åˆ¶ä¸é™æµå®Œæ•´å®æˆ˜.md)

**ç»´æŠ¤è€…**: Seckill Team  
**æœ€åæ›´æ–°**: 2025-10-29
