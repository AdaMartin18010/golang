# é‡‘èç§‘æŠ€ (FinTech) - Goè¯­è¨€å®æˆ˜

> Goè¯­è¨€åœ¨é‡‘èç§‘æŠ€é¢†åŸŸçš„åº”ç”¨å®è·µæŒ‡å—

**ç‰ˆæœ¬**: v1.0  
**æ›´æ–°æ—¥æœŸ**: 2025-10-29  
**é€‚ç”¨Goç‰ˆæœ¬**: Go 1.25.3+

---

## ğŸ“‹ ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [æ ¸å¿ƒåº”ç”¨åœºæ™¯](#æ ¸å¿ƒåº”ç”¨åœºæ™¯)
- [é«˜å¹¶å‘äº¤æ˜“ç³»ç»Ÿ](#é«˜å¹¶å‘äº¤æ˜“ç³»ç»Ÿ)
- [é£æ§ç³»ç»Ÿ](#é£æ§ç³»ç»Ÿ)
- [æ”¯ä»˜ç³»ç»Ÿ](#æ”¯ä»˜ç³»ç»Ÿ)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
- [å‚è€ƒèµ„æº](#å‚è€ƒèµ„æº)

---

## æ¦‚è¿°

### ä¸ºä»€ä¹ˆé€‰æ‹©Go

é‡‘èç§‘æŠ€é¢†åŸŸé€‰æ‹©Goè¯­è¨€çš„æ ¸å¿ƒåŸå› ï¼š

- âš¡ **é«˜æ€§èƒ½**: åŸç”Ÿç¼–è¯‘ï¼Œæ¥è¿‘C++æ€§èƒ½
- ğŸ”’ **å¹¶å‘å®‰å…¨**: CSPå¹¶å‘æ¨¡å‹ï¼Œé€‚åˆé«˜å¹¶å‘åœºæ™¯
- ğŸ›¡ï¸ **ç±»å‹å®‰å…¨**: å¼ºç±»å‹ç³»ç»Ÿï¼Œå‡å°‘è¿è¡Œæ—¶é”™è¯¯
- ğŸ“¦ **æ˜“éƒ¨ç½²**: å•ä¸€äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œæ— ä¾èµ–
- ğŸ”§ **ç»´æŠ¤æ€§å¥½**: ä»£ç ç®€æ´ï¼Œå›¢é˜Ÿåä½œæ•ˆç‡é«˜

### Goåœ¨é‡‘èç§‘æŠ€çš„åº”ç”¨ç»Ÿè®¡

- **äº¤æ˜“ç³»ç»Ÿ**: 60%+ ä½¿ç”¨Goæ„å»ºæ ¸å¿ƒäº¤æ˜“å¼•æ“
- **æ”¯ä»˜ç½‘å…³**: 45%+ é‡‡ç”¨Goå¤„ç†æ”¯ä»˜è¯·æ±‚
- **é£æ§ç³»ç»Ÿ**: 70%+ å®æ—¶é£æ§é‡‡ç”¨Go
- **åŒºå—é“¾**: 80%+ åŒºå—é“¾é¡¹ç›®ä½¿ç”¨Go

---

## æ ¸å¿ƒåº”ç”¨åœºæ™¯

### 1. äº¤æ˜“ç³»ç»Ÿ

- é«˜é¢‘äº¤æ˜“å¼•æ“
- è®¢å•æ’®åˆç³»ç»Ÿ
- è¡Œæƒ…æ¨é€æœåŠ¡
- æ¸…ç®—ç»“ç®—ç³»ç»Ÿ

### 2. æ”¯ä»˜ç³»ç»Ÿ

- æ”¯ä»˜ç½‘å…³
- è´¦æˆ·ç³»ç»Ÿ
- èµ„é‡‘è·¯ç”±
- å¯¹è´¦ç³»ç»Ÿ

### 3. é£é™©æ§åˆ¶

- å®æ—¶åæ¬ºè¯ˆ
- ä¿¡ç”¨è¯„åˆ†
- å¼‚å¸¸æ£€æµ‹
- åˆè§„ç›‘æ§

### 4. æ•°æ®åˆ†æ

- å®æ—¶æ•°æ®å¤„ç†
- é£é™©å»ºæ¨¡
- é‡åŒ–äº¤æ˜“
- æŠ¥è¡¨ç”Ÿæˆ

---

## é«˜å¹¶å‘äº¤æ˜“ç³»ç»Ÿ

è¯¦ç»†å†…å®¹è¯·å‚è€ƒ: [é«˜å¹¶å‘äº¤æ˜“ç³»ç»Ÿè®¾è®¡](./04-é«˜å¹¶å‘äº¤æ˜“ç³»ç»Ÿ.md)

### ç³»ç»Ÿæ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å®¢æˆ·ç«¯    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        API Gateway (è®¤è¯/é™æµ)       â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      è®¢å•æœåŠ¡ (Order Service)        â”‚
â”‚  - è®¢å•éªŒè¯                          â”‚
â”‚  - é¢„å†»ç»“èµ„é‡‘                        â”‚
â”‚  - å‘é€åˆ°æ’®åˆå¼•æ“                    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    æ’®åˆå¼•æ“ (Matching Engine)        â”‚
â”‚  - è®¢å•é˜Ÿåˆ—ç®¡ç†                      â”‚
â”‚  - ä»·æ ¼åŒ¹é…                          â”‚
â”‚  - æˆäº¤å¤„ç†                          â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    æ¸…ç®—æœåŠ¡ (Settlement Service)     â”‚
â”‚  - èµ„é‡‘åˆ’è½¬                          â”‚
â”‚  - æŒä»“æ›´æ–°                          â”‚
â”‚  - æˆäº¤é€šçŸ¥                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒä»£ç ç¤ºä¾‹

```go
package trading

import (
    "context"
    "sync"
    "time"
)

// Order è®¢å•ç»“æ„
type Order struct {
    ID        string
    UserID    string
    Symbol    string
    Side      OrderSide // BUY/SELL
    Price     float64
    Quantity  float64
    Status    OrderStatus
    Timestamp time.Time
}

type OrderSide int

const (
    BUY OrderSide = iota
    SELL
)

type OrderStatus int

const (
    PENDING OrderStatus = iota
    FILLED
    PARTIALLY_FILLED
    CANCELLED
)

// MatchingEngine æ’®åˆå¼•æ“
type MatchingEngine struct {
    buyOrders  *OrderBook
    sellOrders *OrderBook
    mu         sync.RWMutex
    trades     chan *Trade
}

// OrderBook è®¢å•ç°¿
type OrderBook struct {
    orders map[float64][]*Order // price -> orders
    mu     sync.RWMutex
}

// Trade æˆäº¤è®°å½•
type Trade struct {
    BuyOrderID  string
    SellOrderID string
    Price       float64
    Quantity    float64
    Timestamp   time.Time
}

// NewMatchingEngine åˆ›å»ºæ’®åˆå¼•æ“
func NewMatchingEngine() *MatchingEngine {
    return &MatchingEngine{
        buyOrders:  NewOrderBook(),
        sellOrders: NewOrderBook(),
        trades:     make(chan *Trade, 1000),
    }
}

// SubmitOrder æäº¤è®¢å•
func (me *MatchingEngine) SubmitOrder(ctx context.Context, order *Order) error {
    me.mu.Lock()
    defer me.mu.Unlock()

    // å°è¯•æ’®åˆ
    trades := me.match(order)
    
    // å‘é€æˆäº¤é€šçŸ¥
    for _, trade := range trades {
        select {
        case me.trades <- trade:
        case <-ctx.Done():
            return ctx.Err()
        }
    }

    // å¦‚æœè®¢å•æœªå®Œå…¨æˆäº¤ï¼ŒåŠ å…¥è®¢å•ç°¿
    if order.Status != FILLED {
        me.addToOrderBook(order)
    }

    return nil
}

// match æ’®åˆé€»è¾‘
func (me *MatchingEngine) match(order *Order) []*Trade {
    trades := make([]*Trade, 0)
    
    var oppositeBook *OrderBook
    if order.Side == BUY {
        oppositeBook = me.sellOrders
    } else {
        oppositeBook = me.buyOrders
    }

    // ä»·æ ¼åŒ¹é…é€»è¾‘
    oppositeBook.mu.Lock()
    defer oppositeBook.mu.Unlock()

    // éå†å¯¹æ‰‹ç›˜è®¢å•
    for price, orders := range oppositeBook.orders {
        if !me.priceMatches(order, price) {
            continue
        }

        for i := 0; i < len(orders) && order.Quantity > 0; i++ {
            oppositeOrder := orders[i]
            
            // è®¡ç®—æˆäº¤é‡
            tradeQty := min(order.Quantity, oppositeOrder.Quantity)
            
            // åˆ›å»ºæˆäº¤è®°å½•
            trade := &Trade{
                Price:     price,
                Quantity:  tradeQty,
                Timestamp: time.Now(),
            }
            
            if order.Side == BUY {
                trade.BuyOrderID = order.ID
                trade.SellOrderID = oppositeOrder.ID
            } else {
                trade.BuyOrderID = oppositeOrder.ID
                trade.SellOrderID = order.ID
            }
            
            trades = append(trades, trade)

            // æ›´æ–°è®¢å•æ•°é‡
            order.Quantity -= tradeQty
            oppositeOrder.Quantity -= tradeQty

            // æ›´æ–°è®¢å•çŠ¶æ€
            if order.Quantity == 0 {
                order.Status = FILLED
            } else {
                order.Status = PARTIALLY_FILLED
            }

            if oppositeOrder.Quantity == 0 {
                oppositeOrder.Status = FILLED
            }
        }
    }

    return trades
}

// priceMatches ä»·æ ¼åŒ¹é…æ£€æŸ¥
func (me *MatchingEngine) priceMatches(order *Order, oppositePrice float64) bool {
    if order.Side == BUY {
        return order.Price >= oppositePrice
    }
    return order.Price <= oppositePrice
}

// addToOrderBook æ·»åŠ åˆ°è®¢å•ç°¿
func (me *MatchingEngine) addToOrderBook(order *Order) {
    var book *OrderBook
    if order.Side == BUY {
        book = me.buyOrders
    } else {
        book = me.sellOrders
    }

    book.mu.Lock()
    defer book.mu.Unlock()

    if book.orders[order.Price] == nil {
        book.orders[order.Price] = make([]*Order, 0)
    }
    book.orders[order.Price] = append(book.orders[order.Price], order)
}

// NewOrderBook åˆ›å»ºè®¢å•ç°¿
func NewOrderBook() *OrderBook {
    return &OrderBook{
        orders: make(map[float64][]*Order),
    }
}

func min(a, b float64) float64 {
    if a < b {
        return a
    }
    return b
}
```

### æ€§èƒ½ä¼˜åŒ–

1. **å†…å­˜æ± **: å‡å°‘GCå‹åŠ›
2. **æ— é”é˜Ÿåˆ—**: æé«˜å¹¶å‘æ€§èƒ½
3. **æ‰¹é‡å¤„ç†**: é™ä½ç³»ç»Ÿè°ƒç”¨å¼€é”€
4. **é¢„åˆ†é…**: é¿å…åŠ¨æ€æ‰©å®¹

### ç›‘æ§æŒ‡æ ‡

- è®¢å•å¤„ç†å»¶è¿Ÿ (P50/P95/P99)
- æ’®åˆTPS
- è®¢å•ç°¿æ·±åº¦
- æˆäº¤ç‡

---

## é£æ§ç³»ç»Ÿ

è¯¦ç»†å†…å®¹è¯·å‚è€ƒ: [é£æ§ç³»ç»Ÿè®¾è®¡](./05-é£æ§ç³»ç»Ÿ.md)

### å®æ—¶é£æ§æ¶æ„

```go
package riskcontrol

import (
    "context"
    "sync"
    "time"
)

// RiskEngine é£æ§å¼•æ“
type RiskEngine struct {
    rules    []RiskRule
    cache    *RiskCache
    mu       sync.RWMutex
    metrics  *RiskMetrics
}

// RiskRule é£æ§è§„åˆ™æ¥å£
type RiskRule interface {
    Name() string
    Check(ctx context.Context, req *TransactionRequest) (*RiskResult, error)
    Priority() int
}

// TransactionRequest äº¤æ˜“è¯·æ±‚
type TransactionRequest struct {
    UserID      string
    Amount      float64
    Currency    string
    Type        string
    IP          string
    DeviceID    string
    Timestamp   time.Time
    Metadata    map[string]interface{}
}

// RiskResult é£æ§ç»“æœ
type RiskResult struct {
    Passed      bool
    RiskLevel   RiskLevel
    RuleName    string
    Reason      string
    Score       float64
    Suggestions []string
}

type RiskLevel int

const (
    LOW RiskLevel = iota
    MEDIUM
    HIGH
    CRITICAL
)

// NewRiskEngine åˆ›å»ºé£æ§å¼•æ“
func NewRiskEngine(rules []RiskRule) *RiskEngine {
    return &RiskEngine{
        rules:   rules,
        cache:   NewRiskCache(),
        metrics: NewRiskMetrics(),
    }
}

// Evaluate è¯„ä¼°äº¤æ˜“é£é™©
func (re *RiskEngine) Evaluate(ctx context.Context, req *TransactionRequest) (*RiskResult, error) {
    re.mu.RLock()
    defer re.mu.RUnlock()

    // æ£€æŸ¥ç¼“å­˜
    if cached := re.cache.Get(req.UserID); cached != nil {
        if time.Since(cached.Timestamp) < 1*time.Minute {
            return cached, nil
        }
    }

    // å¹¶å‘æ‰§è¡Œæ‰€æœ‰è§„åˆ™
    results := make(chan *RiskResult, len(re.rules))
    errors := make(chan error, len(re.rules))

    var wg sync.WaitGroup
    for _, rule := range re.rules {
        wg.Add(1)
        go func(r RiskRule) {
            defer wg.Done()
            result, err := r.Check(ctx, req)
            if err != nil {
                errors <- err
                return
            }
            results <- result
        }(rule)
    }

    wg.Wait()
    close(results)
    close(errors)

    // æ”¶é›†é”™è¯¯
    for err := range errors {
        if err != nil {
            return nil, err
        }
    }

    // èšåˆç»“æœ
    finalResult := re.aggregateResults(results)
    
    // æ›´æ–°ç¼“å­˜
    re.cache.Set(req.UserID, finalResult)
    
    // æ›´æ–°æŒ‡æ ‡
    re.metrics.Record(finalResult)

    return finalResult, nil
}

// aggregateResults èšåˆé£æ§ç»“æœ
func (re *RiskEngine) aggregateResults(results chan *RiskResult) *RiskResult {
    var (
        maxRiskLevel RiskLevel
        totalScore   float64
        failedRules  []string
        suggestions  []string
    )

    count := 0
    for result := range results {
        count++
        totalScore += result.Score
        
        if result.RiskLevel > maxRiskLevel {
            maxRiskLevel = result.RiskLevel
        }
        
        if !result.Passed {
            failedRules = append(failedRules, result.RuleName)
        }
        
        suggestions = append(suggestions, result.Suggestions...)
    }

    avgScore := totalScore / float64(count)
    passed := len(failedRules) == 0

    return &RiskResult{
        Passed:      passed,
        RiskLevel:   maxRiskLevel,
        Score:       avgScore,
        Suggestions: suggestions,
    }
}

// RiskCache é£æ§ç¼“å­˜
type RiskCache struct {
    data map[string]*RiskResult
    mu   sync.RWMutex
}

func NewRiskCache() *RiskCache {
    return &RiskCache{
        data: make(map[string]*RiskResult),
    }
}

func (rc *RiskCache) Get(key string) *RiskResult {
    rc.mu.RLock()
    defer rc.mu.RUnlock()
    return rc.data[key]
}

func (rc *RiskCache) Set(key string, value *RiskResult) {
    rc.mu.Lock()
    defer rc.mu.Unlock()
    rc.data[key] = value
}

// RiskMetrics é£æ§æŒ‡æ ‡
type RiskMetrics struct {
    totalChecks   int64
    blockedCount  int64
    avgScore      float64
    mu            sync.RWMutex
}

func NewRiskMetrics() *RiskMetrics {
    return &RiskMetrics{}
}

func (rm *RiskMetrics) Record(result *RiskResult) {
    rm.mu.Lock()
    defer rm.mu.Unlock()
    
    rm.totalChecks++
    if !result.Passed {
        rm.blockedCount++
    }
    
    // æ›´æ–°å¹³å‡åˆ†æ•°
    rm.avgScore = (rm.avgScore*float64(rm.totalChecks-1) + result.Score) / float64(rm.totalChecks)
}

// ç¤ºä¾‹ï¼šé‡‘é¢é™åˆ¶è§„åˆ™
type AmountLimitRule struct {
    dailyLimit float64
    cache      map[string]float64
    mu         sync.RWMutex
}

func NewAmountLimitRule(limit float64) *AmountLimitRule {
    return &AmountLimitRule{
        dailyLimit: limit,
        cache:      make(map[string]float64),
    }
}

func (r *AmountLimitRule) Name() string {
    return "AmountLimitRule"
}

func (r *AmountLimitRule) Priority() int {
    return 1
}

func (r *AmountLimitRule) Check(ctx context.Context, req *TransactionRequest) (*RiskResult, error) {
    r.mu.Lock()
    defer r.mu.Unlock()

    // è·å–ä»Šæ—¥ç´¯è®¡é‡‘é¢
    todayAmount := r.cache[req.UserID]
    newTotal := todayAmount + req.Amount

    passed := newTotal <= r.dailyLimit
    riskLevel := LOW
    if newTotal > r.dailyLimit*0.8 {
        riskLevel = MEDIUM
    }
    if newTotal > r.dailyLimit {
        riskLevel = HIGH
    }

    // æ›´æ–°ç¼“å­˜
    if passed {
        r.cache[req.UserID] = newTotal
    }

    return &RiskResult{
        Passed:    passed,
        RiskLevel: riskLevel,
        RuleName:  r.Name(),
        Score:     newTotal / r.dailyLimit * 100,
        Suggestions: []string{
            "Consider increasing daily limit for verified users",
        },
    }, nil
}
```

### å¸¸è§é£æ§è§„åˆ™

1. **é‡‘é¢é™åˆ¶**: å•ç¬”/æ—¥ç´¯è®¡é™é¢
2. **é¢‘ç‡æ§åˆ¶**: é˜²æ­¢é«˜é¢‘åˆ·å•
3. **è®¾å¤‡æŒ‡çº¹**: è¯†åˆ«å¼‚å¸¸è®¾å¤‡
4. **IPé»‘åå•**: é˜»æ­¢æ¶æ„IP
5. **è¡Œä¸ºåˆ†æ**: æ£€æµ‹å¼‚å¸¸è¡Œä¸ºæ¨¡å¼
6. **ä¿¡ç”¨è¯„åˆ†**: ç”¨æˆ·ä¿¡ç”¨ç­‰çº§
7. **åœ°åŸŸé™åˆ¶**: é™åˆ¶é«˜é£é™©åœ°åŒº
8. **æ—¶é—´è§„åˆ™**: é™åˆ¶äº¤æ˜“æ—¶æ®µ

---

## æ”¯ä»˜ç³»ç»Ÿ

### æ”¯ä»˜ç½‘å…³æ¶æ„

```go
package payment

import (
    "context"
    "errors"
    "time"
)

// PaymentGateway æ”¯ä»˜ç½‘å…³
type PaymentGateway struct {
    processors map[string]PaymentProcessor
    router     *PaymentRouter
    logger     Logger
}

// PaymentProcessor æ”¯ä»˜å¤„ç†å™¨æ¥å£
type PaymentProcessor interface {
    Name() string
    Process(ctx context.Context, req *PaymentRequest) (*PaymentResponse, error)
    Refund(ctx context.Context, txID string, amount float64) error
    Query(ctx context.Context, txID string) (*TransactionStatus, error)
}

// PaymentRequest æ”¯ä»˜è¯·æ±‚
type PaymentRequest struct {
    OrderID     string
    UserID      string
    Amount      float64
    Currency    string
    Method      PaymentMethod
    CallbackURL string
    Metadata    map[string]string
}

type PaymentMethod string

const (
    CreditCard PaymentMethod = "credit_card"
    DebitCard  PaymentMethod = "debit_card"
    Alipay     PaymentMethod = "alipay"
    WeChat     PaymentMethod = "wechat"
    BankTransfer PaymentMethod = "bank_transfer"
)

// PaymentResponse æ”¯ä»˜å“åº”
type PaymentResponse struct {
    TransactionID string
    Status        TransactionStatus
    Message       string
    RedirectURL   string
    Timestamp     time.Time
}

type TransactionStatus string

const (
    StatusPending   TransactionStatus = "pending"
    StatusSuccess   TransactionStatus = "success"
    StatusFailed    TransactionStatus = "failed"
    StatusCancelled TransactionStatus = "cancelled"
)

// Process å¤„ç†æ”¯ä»˜
func (pg *PaymentGateway) Process(ctx context.Context, req *PaymentRequest) (*PaymentResponse, error) {
    // 1. è·¯ç”±åˆ°åˆé€‚çš„æ”¯ä»˜å¤„ç†å™¨
    processor, err := pg.router.Route(req)
    if err != nil {
        return nil, err
    }

    // 2. æ‰§è¡Œæ”¯ä»˜
    resp, err := processor.Process(ctx, req)
    if err != nil {
        pg.logger.Error("payment failed", "order_id", req.OrderID, "error", err)
        return nil, err
    }

    // 3. è®°å½•æ—¥å¿—
    pg.logger.Info("payment processed", "order_id", req.OrderID, "tx_id", resp.TransactionID)

    return resp, nil
}

// PaymentRouter æ”¯ä»˜è·¯ç”±å™¨
type PaymentRouter struct {
    rules []RoutingRule
}

type RoutingRule interface {
    Match(req *PaymentRequest) bool
    GetProcessor() string
}

func (pr *PaymentRouter) Route(req *PaymentRequest) (PaymentProcessor, error) {
    for _, rule := range pr.rules {
        if rule.Match(req) {
            // è¿”å›å¯¹åº”çš„å¤„ç†å™¨
            return nil, nil
        }
    }
    return nil, errors.New("no suitable processor found")
}

type Logger interface {
    Info(msg string, args ...interface{})
    Error(msg string, args ...interface{})
}
```

### å¯¹è´¦ç³»ç»Ÿ

```go
package reconciliation

import (
    "context"
    "time"
)

// ReconciliationService å¯¹è´¦æœåŠ¡
type ReconciliationService struct {
    internalTxRepo  TransactionRepository
    externalTxRepo  TransactionRepository
    diffHandler     DifferenceHandler
}

// Transaction äº¤æ˜“è®°å½•
type Transaction struct {
    ID        string
    OrderID   string
    Amount    float64
    Currency  string
    Status    string
    Timestamp time.Time
}

// Reconcile æ‰§è¡Œå¯¹è´¦
func (rs *ReconciliationService) Reconcile(ctx context.Context, date time.Time) (*ReconciliationReport, error) {
    // 1. è·å–å†…éƒ¨äº¤æ˜“è®°å½•
    internalTxs, err := rs.internalTxRepo.GetByDate(ctx, date)
    if err != nil {
        return nil, err
    }

    // 2. è·å–å¤–éƒ¨äº¤æ˜“è®°å½•
    externalTxs, err := rs.externalTxRepo.GetByDate(ctx, date)
    if err != nil {
        return nil, err
    }

    // 3. æ¯”å¯¹å·®å¼‚
    diffs := rs.compare(internalTxs, externalTxs)

    // 4. å¤„ç†å·®å¼‚
    for _, diff := range diffs {
        if err := rs.diffHandler.Handle(ctx, diff); err != nil {
            return nil, err
        }
    }

    // 5. ç”ŸæˆæŠ¥å‘Š
    report := &ReconciliationReport{
        Date:           date,
        TotalInternal:  len(internalTxs),
        TotalExternal:  len(externalTxs),
        Differences:    diffs,
        Timestamp:      time.Now(),
    }

    return report, nil
}

func (rs *ReconciliationService) compare(internal, external []*Transaction) []*Difference {
    // å¯¹è´¦é€»è¾‘å®ç°
    return nil
}

type Difference struct {
    Type        DiffType
    Transaction *Transaction
    Reason      string
}

type DiffType string

const (
    MissingInternal DiffType = "missing_internal"
    MissingExternal DiffType = "missing_external"
    AmountMismatch  DiffType = "amount_mismatch"
    StatusMismatch  DiffType = "status_mismatch"
)

type ReconciliationReport struct {
    Date           time.Time
    TotalInternal  int
    TotalExternal  int
    Differences    []*Difference
    Timestamp      time.Time
}

type TransactionRepository interface {
    GetByDate(ctx context.Context, date time.Time) ([]*Transaction, error)
}

type DifferenceHandler interface {
    Handle(ctx context.Context, diff *Difference) error
}
```

---

## æœ€ä½³å®è·µ

### 1. å®‰å…¨æ€§

- âœ… ä½¿ç”¨HTTPS/TLSåŠ å¯†é€šä¿¡
- âœ… å®æ–½ä¸¥æ ¼çš„èº«ä»½è®¤è¯
- âœ… æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨
- âœ… å®šæœŸå®‰å…¨å®¡è®¡
- âœ… å®æ–½è®¿é—®æ§åˆ¶ (RBAC)

### 2. å¯é æ€§

- âœ… å®ç°å¹‚ç­‰æ€§
- âœ… åˆ†å¸ƒå¼äº‹åŠ¡ç®¡ç†
- âœ… æ•…éšœè‡ªåŠ¨æ¢å¤
- âœ… æ•°æ®å¤‡ä»½ä¸æ¢å¤
- âœ… ç°åº¦å‘å¸ƒ

### 3. æ€§èƒ½

- âœ… æ•°æ®åº“è¿æ¥æ± ä¼˜åŒ–
- âœ… ç¼“å­˜ç­–ç•¥ (Redis)
- âœ… å¼‚æ­¥å¤„ç†
- âœ… æ‰¹é‡æ“ä½œ
- âœ… è´Ÿè½½å‡è¡¡

### 4. ç›‘æ§

- âœ… å®æ—¶ç›‘æ§æŒ‡æ ‡
- âœ… æ—¥å¿—èšåˆåˆ†æ
- âœ… å‘Šè­¦æœºåˆ¶
- âœ… é“¾è·¯è¿½è¸ª
- âœ… æ€§èƒ½åˆ†æ

### 5. åˆè§„æ€§

- âœ… éµå®ˆé‡‘èç›‘ç®¡è¦æ±‚
- âœ… æ•°æ®éšç§ä¿æŠ¤ (GDPR)
- âœ… å®¡è®¡æ—¥å¿—
- âœ… KYC/AMLå®æ–½
- âœ… æ•°æ®ç•™å­˜ç­–ç•¥

---

## å‚è€ƒèµ„æº

### å¼€æºé¡¹ç›®

- **go-payment**: å¤šæ¸ é“æ”¯ä»˜SDK
- **go-risk**: é£æ§è§„åˆ™å¼•æ“
- **go-trading**: äº¤æ˜“ç³»ç»Ÿæ¡†æ¶

### å­¦ä¹ èµ„æ–™

- [æ„å»ºé«˜æ€§èƒ½é‡‘èç³»ç»Ÿ](https://example.com/fintech-go)
- [Goè¯­è¨€é£æ§æœ€ä½³å®è·µ](https://example.com/risk-control)
- [åˆ†å¸ƒå¼äº¤æ˜“ç³»ç»Ÿè®¾è®¡](https://example.com/trading-system)

### ç›¸å…³æ–‡æ¡£

- [é«˜å¹¶å‘äº¤æ˜“ç³»ç»Ÿè®¾è®¡](./04-é«˜å¹¶å‘äº¤æ˜“ç³»ç»Ÿ.md)
- [é£æ§ç³»ç»Ÿè®¾è®¡](./05-é£æ§ç³»ç»Ÿ.md)
- [æ”¯ä»˜ç³»ç»Ÿæ¶æ„](./06-æ”¯ä»˜ç³»ç»Ÿæ¶æ„.md)

---

**ç»´æŠ¤è€…**: Go FinTech Community  
**æœ€åæ›´æ–°**: 2025-10-29  
**è®¸å¯è¯**: MIT
