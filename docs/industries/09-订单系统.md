# è®¢å•ç³»ç»Ÿè®¾è®¡ä¸å®ç°

> ç”µå•†è®¢å•ç³»ç»Ÿå®Œæ•´è§£å†³æ–¹æ¡ˆ

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨Goç‰ˆæœ¬**: Go 1.25.3+

---

## ğŸ“‹ ç›®å½•

- [è®¢å•ç³»ç»Ÿè®¾è®¡ä¸å®ç°](#è®¢å•ç³»ç»Ÿè®¾è®¡ä¸å®ç°)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ç³»ç»Ÿæ¦‚è¿°](#ç³»ç»Ÿæ¦‚è¿°)
    - [è®¢å•ç³»ç»ŸèŒè´£](#è®¢å•ç³»ç»ŸèŒè´£)
    - [ç³»ç»Ÿæ¶æ„](#ç³»ç»Ÿæ¶æ„)
  - [è®¢å•çŠ¶æ€æœº](#è®¢å•çŠ¶æ€æœº)
    - [çŠ¶æ€æµè½¬](#çŠ¶æ€æµè½¬)
    - [çŠ¶æ€æœºå®ç°](#çŠ¶æ€æœºå®ç°)
  - [æ ¸å¿ƒåŠŸèƒ½](#æ ¸å¿ƒåŠŸèƒ½)
    - [1. åˆ›å»ºè®¢å•](#1-åˆ›å»ºè®¢å•)
    - [2. è®¢å•åˆ†åº“åˆ†è¡¨](#2-è®¢å•åˆ†åº“åˆ†è¡¨)
    - [3. è®¢å•å·ç”Ÿæˆ](#3-è®¢å•å·ç”Ÿæˆ)
    - [4. è®¢å•æŸ¥è¯¢ä¼˜åŒ–](#4-è®¢å•æŸ¥è¯¢ä¼˜åŒ–)
  - [åˆ†å¸ƒå¼äº‹åŠ¡](#åˆ†å¸ƒå¼äº‹åŠ¡)
    - [Sagaæ¨¡å¼](#sagaæ¨¡å¼)
  - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
    - [1. è¯»å†™åˆ†ç¦»](#1-è¯»å†™åˆ†ç¦»)
    - [2. å¼‚æ­¥å¤„ç†](#2-å¼‚æ­¥å¤„ç†)
    - [3. æ‰¹é‡å¤„ç†](#3-æ‰¹é‡å¤„ç†)

---

## ç³»ç»Ÿæ¦‚è¿°

### è®¢å•ç³»ç»ŸèŒè´£

- ğŸ“ **è®¢å•ç®¡ç†**: åˆ›å»ºã€æŸ¥è¯¢ã€å–æ¶ˆè®¢å•
- ğŸ’° **æ”¯ä»˜å¯¹æ¥**: é›†æˆå¤šç§æ”¯ä»˜æ–¹å¼
- ğŸ“¦ **ç‰©æµè·Ÿè¸ª**: è®¢å•å±¥çº¦æµç¨‹
- ğŸ”„ **å”®åå¤„ç†**: é€€æ¬¾ã€é€€è´§ã€æ¢è´§
- ğŸ“Š **æ•°æ®åˆ†æ**: è®¢å•ç»Ÿè®¡åˆ†æ

### ç³»ç»Ÿæ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Order System Architecture      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ è®¢å•API    â”‚    â”‚  è®¢å•æŸ¥è¯¢    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚        â”‚                  â”‚          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚      è®¢å•æ ¸å¿ƒæœåŠ¡              â”‚  â”‚
â”‚  â”‚  - è®¢å•åˆ›å»º                    â”‚  â”‚
â”‚  â”‚  - è®¢å•æ”¯ä»˜                    â”‚  â”‚
â”‚  â”‚  - è®¢å•å–æ¶ˆ                    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚        â”‚                  â”‚          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  åº“å­˜æœåŠ¡  â”‚    â”‚  æ”¯ä»˜æœåŠ¡  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  è®¢å•æ•°æ®åº“ (åˆ†åº“åˆ†è¡¨)        â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## è®¢å•çŠ¶æ€æœº

### çŠ¶æ€æµè½¬

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å¾…æ”¯ä»˜  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚ æ”¯ä»˜
â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
â”‚ å·²æ”¯ä»˜  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚ å‘è´§
â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
â”‚ å·²å‘è´§  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚ ç­¾æ”¶
â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
â”‚ å·²å®Œæˆ  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### çŠ¶æ€æœºå®ç°

```go
package orderfsm

import (
    "errors"
)

// OrderStatus è®¢å•çŠ¶æ€
type OrderStatus int

const (
    StatusPending OrderStatus = iota       // å¾…æ”¯ä»˜
    StatusPaid                             // å·²æ”¯ä»˜
    StatusShipped                          // å·²å‘è´§
    StatusDelivered                        // å·²é€è¾¾
    StatusCompleted                        // å·²å®Œæˆ
    StatusCancelled                        // å·²å–æ¶ˆ
    StatusRefunding                        // é€€æ¬¾ä¸­
    StatusRefunded                         // å·²é€€æ¬¾
)

func (s OrderStatus) String() string {
    return [...]string{
        "Pending", "Paid", "Shipped", "Delivered",
        "Completed", "Cancelled", "Refunding", "Refunded",
    }[s]
}

// OrderEvent è®¢å•äº‹ä»¶
type OrderEvent int

const (
    EventPay OrderEvent = iota
    EventShip
    EventDeliver
    EventComplete
    EventCancel
    EventRefund
    EventConfirmRefund
)

// OrderFSM è®¢å•çŠ¶æ€æœº
type OrderFSM struct {
    currentState OrderStatus
    transitions  map[OrderStatus]map[OrderEvent]OrderStatus
}

// NewOrderFSM åˆ›å»ºè®¢å•çŠ¶æ€æœº
func NewOrderFSM(initialState OrderStatus) *OrderFSM {
    fsm := &OrderFSM{
        currentState: initialState,
        transitions:  make(map[OrderStatus]map[OrderEvent]OrderStatus),
    }

    // å®šä¹‰çŠ¶æ€è½¬æ¢è§„åˆ™
    fsm.defineTransitions()

    return fsm
}

func (fsm *OrderFSM) defineTransitions() {
    // å¾…æ”¯ä»˜ -> å·²æ”¯ä»˜/å·²å–æ¶ˆ
    fsm.transitions[StatusPending] = map[OrderEvent]OrderStatus{
        EventPay:    StatusPaid,
        EventCancel: StatusCancelled,
    }

    // å·²æ”¯ä»˜ -> å·²å‘è´§/é€€æ¬¾ä¸­
    fsm.transitions[StatusPaid] = map[OrderEvent]OrderStatus{
        EventShip:   StatusShipped,
        EventRefund: StatusRefunding,
    }

    // å·²å‘è´§ -> å·²é€è¾¾
    fsm.transitions[StatusShipped] = map[OrderEvent]OrderStatus{
        EventDeliver: StatusDelivered,
    }

    // å·²é€è¾¾ -> å·²å®Œæˆ
    fsm.transitions[StatusDelivered] = map[OrderEvent]OrderStatus{
        EventComplete: StatusCompleted,
    }

    // é€€æ¬¾ä¸­ -> å·²é€€æ¬¾
    fsm.transitions[StatusRefunding] = map[OrderEvent]OrderStatus{
        EventConfirmRefund: StatusRefunded,
    }
}

// Trigger è§¦å‘äº‹ä»¶
func (fsm *OrderFSM) Trigger(event OrderEvent) error {
    nextStateMap, exists := fsm.transitions[fsm.currentState]
    if !exists {
        return errors.New("no transitions defined for current state")
    }

    nextState, exists := nextStateMap[event]
    if !exists {
        return errors.New("invalid event for current state")
    }

    fsm.currentState = nextState
    return nil
}

// CurrentState è·å–å½“å‰çŠ¶æ€
func (fsm *OrderFSM) CurrentState() OrderStatus {
    return fsm.currentState
}

// CanTransition æ£€æŸ¥æ˜¯å¦å¯ä»¥è½¬æ¢
func (fsm *OrderFSM) CanTransition(event OrderEvent) bool {
    nextStateMap, exists := fsm.transitions[fsm.currentState]
    if !exists {
        return false
    }

    _, exists = nextStateMap[event]
    return exists
}
```

---

## æ ¸å¿ƒåŠŸèƒ½

### 1. åˆ›å»ºè®¢å•

è¯¦è§: [ç”µå•†ç³»ç»Ÿ - è®¢å•æµç¨‹](./03-ç”µå•†ç³»ç»Ÿ.md#è®¢å•æµç¨‹)

### 2. è®¢å•åˆ†åº“åˆ†è¡¨

```go
package sharding

import (
    "database/sql"
    "fmt"
)

// OrderShardingStrategy è®¢å•åˆ†ç‰‡ç­–ç•¥
type OrderShardingStrategy struct {
    dbCount    int
    tableCount int
}

// NewOrderShardingStrategy åˆ›å»ºåˆ†ç‰‡ç­–ç•¥
func NewOrderShardingStrategy(dbCount, tableCount int) *OrderShardingStrategy {
    return &OrderShardingStrategy{
        dbCount:    dbCount,
        tableCount: tableCount,
    }
}

// GetDBIndex è·å–æ•°æ®åº“ç´¢å¼•
func (oss *OrderShardingStrategy) GetDBIndex(orderID int64) int {
    return int(orderID % int64(oss.dbCount))
}

// GetTableIndex è·å–è¡¨ç´¢å¼•
func (oss *OrderShardingStrategy) GetTableIndex(orderID int64) int {
    return int(orderID % int64(oss.tableCount))
}

// GetTableName è·å–è¡¨å
func (oss *OrderShardingStrategy) GetTableName(orderID int64) string {
    tableIdx := oss.GetTableIndex(orderID)
    return fmt.Sprintf("order_%d", tableIdx)
}

// ShardingRouter åˆ†ç‰‡è·¯ç”±å™¨
type ShardingRouter struct {
    dbs      []*sql.DB
    strategy *OrderShardingStrategy
}

// NewShardingRouter åˆ›å»ºåˆ†ç‰‡è·¯ç”±å™¨
func NewShardingRouter(dbs []*sql.DB, strategy *OrderShardingStrategy) *ShardingRouter {
    return &ShardingRouter{
        dbs:      dbs,
        strategy: strategy,
    }
}

// GetDB è·å–æ•°æ®åº“è¿æ¥
func (sr *ShardingRouter) GetDB(orderID int64) *sql.DB {
    dbIdx := sr.strategy.GetDBIndex(orderID)
    return sr.dbs[dbIdx]
}

// GetTableName è·å–è¡¨å
func (sr *ShardingRouter) GetTableName(orderID int64) string {
    return sr.strategy.GetTableName(orderID)
}
```

### 3. è®¢å•å·ç”Ÿæˆ

```go
package idgen

import (
    "fmt"
    "sync"
    "time"
)

// SnowflakeIDGenerator é›ªèŠ±ç®—æ³•IDç”Ÿæˆå™¨
type SnowflakeIDGenerator struct {
    mu            sync.Mutex
    epoch         int64 // èµ·å§‹æ—¶é—´æˆ³ (æ¯«ç§’)
    workerID      int64 // æœºå™¨ID (10ä½)
    datacenterID  int64 // æ•°æ®ä¸­å¿ƒID (5ä½)
    sequence      int64 // åºåˆ—å· (12ä½)
    lastTimestamp int64 // ä¸Šæ¬¡ç”ŸæˆIDçš„æ—¶é—´æˆ³
}

const (
    workerIDBits     = 10
    datacenterIDBits = 5
    sequenceBits     = 12

    maxWorkerID     = -1 ^ (-1 << workerIDBits)
    maxDatacenterID = -1 ^ (-1 << datacenterIDBits)
    maxSequence     = -1 ^ (-1 << sequenceBits)

    workerIDShift      = sequenceBits
    datacenterIDShift  = sequenceBits + workerIDBits
    timestampLeftShift = sequenceBits + workerIDBits + datacenterIDBits
)

// NewSnowflakeIDGenerator åˆ›å»ºIDç”Ÿæˆå™¨
func NewSnowflakeIDGenerator(workerID, datacenterID int64) (*SnowflakeIDGenerator, error) {
    if workerID < 0 || workerID > maxWorkerID {
        return nil, fmt.Errorf("worker ID must be between 0 and %d", maxWorkerID)
    }

    if datacenterID < 0 || datacenterID > maxDatacenterID {
        return nil, fmt.Errorf("datacenter ID must be between 0 and %d", maxDatacenterID)
    }

    return &SnowflakeIDGenerator{
        epoch:        1609459200000, // 2021-01-01 00:00:00
        workerID:     workerID,
        datacenterID: datacenterID,
        sequence:     0,
    }, nil
}

// NextID ç”Ÿæˆä¸‹ä¸€ä¸ªID
func (g *SnowflakeIDGenerator) NextID() int64 {
    g.mu.Lock()
    defer g.mu.Unlock()

    timestamp := g.timeGen()

    if timestamp < g.lastTimestamp {
        // æ—¶é’Ÿå›æ‹¨
        panic("clock moved backwards")
    }

    if timestamp == g.lastTimestamp {
        // åŒä¸€æ¯«ç§’å†…ï¼Œåºåˆ—å·+1
        g.sequence = (g.sequence + 1) & maxSequence
        if g.sequence == 0 {
            // åºåˆ—å·æº¢å‡ºï¼Œç­‰å¾…ä¸‹ä¸€æ¯«ç§’
            timestamp = g.tilNextMillis(g.lastTimestamp)
        }
    } else {
        // ä¸åŒæ¯«ç§’ï¼Œåºåˆ—å·é‡ç½®
        g.sequence = 0
    }

    g.lastTimestamp = timestamp

    // ç”ŸæˆID
    id := ((timestamp - g.epoch) << timestampLeftShift) |
        (g.datacenterID << datacenterIDShift) |
        (g.workerID << workerIDShift) |
        g.sequence

    return id
}

func (g *SnowflakeIDGenerator) timeGen() int64 {
    return time.Now().UnixNano() / 1e6
}

func (g *SnowflakeIDGenerator) tilNextMillis(lastTimestamp int64) int64 {
    timestamp := g.timeGen()
    for timestamp <= lastTimestamp {
        timestamp = g.timeGen()
    }
    return timestamp
}
```

### 4. è®¢å•æŸ¥è¯¢ä¼˜åŒ–

```go
package query

import (
    "context"
    "database/sql"
    "encoding/json"
    "time"

    "github.com/go-redis/redis/v8"
)

// OrderQueryService è®¢å•æŸ¥è¯¢æœåŠ¡
type OrderQueryService struct {
    db    *sql.DB
    cache *redis.Client
}

// GetOrderByID æ ¹æ®IDæŸ¥è¯¢è®¢å•
func (oqs *OrderQueryService) GetOrderByID(ctx context.Context, orderID int64) (*Order, error) {
    // 1. æŸ¥è¯¢ç¼“å­˜
    cacheKey := oqs.orderCacheKey(orderID)
    cached, err := oqs.cache.Get(ctx, cacheKey).Result()
    if err == nil {
        var order Order
        if err := json.Unmarshal([]byte(cached), &order); err == nil {
            return &order, nil
        }
    }

    // 2. æŸ¥è¯¢æ•°æ®åº“
    order, err := oqs.queryOrderFromDB(ctx, orderID)
    if err != nil {
        return nil, err
    }

    // 3. å†™å…¥ç¼“å­˜
    data, _ := json.Marshal(order)
    oqs.cache.Set(ctx, cacheKey, data, 1*time.Hour)

    return order, nil
}

// ListUserOrders æŸ¥è¯¢ç”¨æˆ·è®¢å•åˆ—è¡¨
func (oqs *OrderQueryService) ListUserOrders(ctx context.Context, userID int64, page, pageSize int) ([]*Order, int, error) {
    // ä½¿ç”¨ESå®ç°é«˜æ•ˆæŸ¥è¯¢
    // è¿™é‡Œç®€åŒ–ä¸ºç›´æ¥æŸ¥è¯¢æ•°æ®åº“
    offset := (page - 1) * pageSize

    query := `
        SELECT id, user_id, status, total_amount, created_at
        FROM orders
        WHERE user_id = ?
        ORDER BY created_at DESC
        LIMIT ? OFFSET ?
    `

    rows, err := oqs.db.QueryContext(ctx, query, userID, pageSize, offset)
    if err != nil {
        return nil, 0, err
    }
    defer rows.Close()

    orders := make([]*Order, 0, pageSize)
    for rows.Next() {
        var order Order
        if err := rows.Scan(&order.ID, &order.UserID, &order.Status, &order.TotalAmount, &order.CreatedAt); err != nil {
            return nil, 0, err
        }
        orders = append(orders, &order)
    }

    // æŸ¥è¯¢æ€»æ•°
    var total int
    countQuery := "SELECT COUNT(*) FROM orders WHERE user_id = ?"
    oqs.db.QueryRowContext(ctx, countQuery, userID).Scan(&total)

    return orders, total, nil
}

func (oqs *OrderQueryService) orderCacheKey(orderID int64) string {
    return ""
}

func (oqs *OrderQueryService) queryOrderFromDB(ctx context.Context, orderID int64) (*Order, error) {
    return nil, nil
}

type Order struct {
    ID          int64
    UserID      int64
    Status      OrderStatus
    TotalAmount float64
    CreatedAt   time.Time
}
```

---

## åˆ†å¸ƒå¼äº‹åŠ¡

### Sagaæ¨¡å¼

```go
package saga

import (
    "context"
    "fmt"
)

// SagaOrchestrator Sagaç¼–æ’å™¨
type SagaOrchestrator struct {
    steps []*SagaStep
}

// NewSagaOrchestrator åˆ›å»ºSagaç¼–æ’å™¨
func NewSagaOrchestrator() *SagaOrchestrator {
    return &SagaOrchestrator{
        steps: make([]*SagaStep, 0),
    }
}

// AddStep æ·»åŠ æ­¥éª¤
func (so *SagaOrchestrator) AddStep(name string, action Action, compensate Compensate) *SagaOrchestrator {
    so.steps = append(so.steps, &SagaStep{
        Name:       name,
        Action:     action,
        Compensate: compensate,
    })
    return so
}

// Execute æ‰§è¡ŒSaga
func (so *SagaOrchestrator) Execute(ctx context.Context) error {
    executedSteps := make([]*SagaStep, 0)

    // æ‰§è¡Œæ‰€æœ‰æ­¥éª¤
    for _, step := range so.steps {
        if err := step.Action(ctx); err != nil {
            // æ‰§è¡Œå¤±è´¥ï¼Œå›æ»šå·²æ‰§è¡Œçš„æ­¥éª¤
            so.rollback(ctx, executedSteps)
            return fmt.Errorf("step %s failed: %w", step.Name, err)
        }
        executedSteps = append(executedSteps, step)
    }

    return nil
}

// rollback å›æ»š
func (so *SagaOrchestrator) rollback(ctx context.Context, executedSteps []*SagaStep) {
    // é€†åºå›æ»š
    for i := len(executedSteps) - 1; i >= 0; i-- {
        step := executedSteps[i]
        if err := step.Compensate(ctx); err != nil {
            // è®°å½•è¡¥å¿å¤±è´¥
            fmt.Printf("compensate %s failed: %v\n", step.Name, err)
        }
    }
}

// SagaStep Sagaæ­¥éª¤
type SagaStep struct {
    Name       string
    Action     Action
    Compensate Compensate
}

type Action func(ctx context.Context) error
type Compensate func(ctx context.Context) error

// ç¤ºä¾‹ï¼šè®¢å•Saga
func CreateOrderSaga(order *Order) *SagaOrchestrator {
    saga := NewSagaOrchestrator()

    // æ­¥éª¤1: åˆ›å»ºè®¢å•
    saga.AddStep("create_order",
        func(ctx context.Context) error {
            return createOrder(ctx, order)
        },
        func(ctx context.Context) error {
            return deleteOrder(ctx, order.ID)
        },
    )

    // æ­¥éª¤2: æ‰£å‡åº“å­˜
    saga.AddStep("deduct_inventory",
        func(ctx context.Context) error {
            return deductInventory(ctx, order.Items)
        },
        func(ctx context.Context) error {
            return restoreInventory(ctx, order.Items)
        },
    )

    // æ­¥éª¤3: æ‰£å‡ç§¯åˆ†
    saga.AddStep("deduct_points",
        func(ctx context.Context) error {
            return deductPoints(ctx, order.UserID, order.PointsUsed)
        },
        func(ctx context.Context) error {
            return restorePoints(ctx, order.UserID, order.PointsUsed)
        },
    )

    return saga
}

func createOrder(ctx context.Context, order *Order) error       { return nil }
func deleteOrder(ctx context.Context, orderID int64) error      { return nil }
func deductInventory(ctx context.Context, items []*OrderItem) error { return nil }
func restoreInventory(ctx context.Context, items []*OrderItem) error { return nil }
func deductPoints(ctx context.Context, userID int64, points int) error { return nil }
func restorePoints(ctx context.Context, userID int64, points int) error { return nil }

type OrderItem struct {
    ProductID int64
    Quantity  int
}
```

---

## æ€§èƒ½ä¼˜åŒ–

### 1. è¯»å†™åˆ†ç¦»

```go
// ä¸»åº“å†™å…¥ï¼Œä»åº“è¯»å–
type OrderRepository struct {
    masterDB *sql.DB
    slaveDB  *sql.DB
}

func (repo *OrderRepository) Create(order *Order) error {
    // å†™ä¸»åº“
    _, err := repo.masterDB.Exec("INSERT INTO orders ...")
    return err
}

func (repo *OrderRepository) Get(orderID int64) (*Order, error) {
    // è¯»ä»åº“
    row := repo.slaveDB.QueryRow("SELECT * FROM orders WHERE id = ?", orderID)
    // ...
    return nil, nil
}
```

### 2. å¼‚æ­¥å¤„ç†

```go
// è®¢å•åˆ›å»ºæˆåŠŸåå¼‚æ­¥å‘é€é€šçŸ¥
func (os *OrderService) CreateOrder(ctx context.Context, req *CreateOrderRequest) (*Order, error) {
    order, err := os.createOrderSync(ctx, req)
    if err != nil {
        return nil, err
    }

    // å¼‚æ­¥å‘é€é‚®ä»¶ã€çŸ­ä¿¡é€šçŸ¥
    go os.sendNotifications(order)

    // å¼‚æ­¥æ›´æ–°ç»Ÿè®¡æ•°æ®
    go os.updateStatistics(order)

    return order, nil
}
```

### 3. æ‰¹é‡å¤„ç†

```go
// æ‰¹é‡æŸ¥è¯¢è®¢å•è¯¦æƒ…
func (os *OrderService) BatchGetOrders(ctx context.Context, orderIDs []int64) ([]*Order, error) {
    // ä½¿ç”¨INæŸ¥è¯¢
    query := "SELECT * FROM orders WHERE id IN (?)"
    // ...
    return nil, nil
}
```

---

**ç›¸å…³æ–‡æ¡£**:

- [ç”µå•†ç³»ç»Ÿæ¦‚è§ˆ](./03-ç”µå•†ç³»ç»Ÿ.md)
- [ç§’æ€ç³»ç»Ÿ](./08-ç§’æ€ç³»ç»Ÿ.md)
- [åˆ†å¸ƒå¼äº‹åŠ¡](../advanced/26-Go-1.25.3åˆ†å¸ƒå¼äº‹åŠ¡å®Œæ•´å®æˆ˜.md)
- [æ•°æ®åº“ç¼–ç¨‹](../development/database/)

**ç»´æŠ¤è€…**: Order System Team
**æœ€åæ›´æ–°**: 2025-10-29
