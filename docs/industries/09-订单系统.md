# 订单系统设计与实现

**版本**: v1.0
**更新日期**: 2025-11-11
**适用于**: Go 1.25.3

---

## 📋 目录

- [订单系统设计与实现](#订单系统设计与实现)
  - [📋 目录](#-目录)
  - [系统概述](#系统概述)
    - [订单系统职责](#订单系统职责)
    - [系统架构](#系统架构)
  - [订单状态机](#订单状态机)
    - [状态流转](#状态流转)
    - [状态机实现](#状态机实现)
  - [核心功能](#核心功能)
    - [1. 创建订单](#1-创建订单)
    - [2. 订单分库分表](#2-订单分库分表)
    - [3. 订单号生成](#3-订单号生成)
    - [4. 订单查询优化](#4-订单查询优化)
  - [分布式事务](#分布式事务)
    - [Saga模式](#saga模式)
  - [性能优化](#性能优化)
    - [1. 读写分离](#1-读写分离)
    - [2. 异步处理](#2-异步处理)
    - [3. 批量处理](#3-批量处理)

---

## 系统概述

### 订单系统职责

- 📝 **订单管理**: 创建、查询、取消订单
- 💰 **支付对接**: 集成多种支付方式
- 📦 **物流跟踪**: 订单履约流程
- 🔄 **售后处理**: 退款、退货、换货
- 📊 **数据分析**: 订单统计分析

### 系统架构

```text
┌───────────────────────────────────────┐
│        Order System Architecture      │
├───────────────────────────────────────┤
│                                       │
│  ┌────────────┐    ┌──────────────┐  │
│  │ 订单API    │    │  订单查询    │  │
│  └─────┬──────┘    └──────┬───────┘  │
│        │                  │          │
│  ┌─────▼──────────────────▼───────┐  │
│  │      订单核心服务              │  │
│  │  - 订单创建                    │  │
│  │  - 订单支付                    │  │
│  │  - 订单取消                    │  │
│  └─────┬──────────────────┬───────┘  │
│        │                  │          │
│  ┌─────▼──────┐    ┌─────▼──────┐   │
│  │  库存服务  │    │  支付服务  │   │
│  └────────────┘    └────────────┘   │
│                                       │
│  ┌───────────────────────────────┐   │
│  │  订单数据库 (分库分表)        │   │
│  └───────────────────────────────┘   │
└───────────────────────────────────────┘
```

---

## 订单状态机

### 状态流转

```text
┌─────────┐
│  待支付  │
└────┬────┘
     │ 支付
┌────▼────┐
│ 已支付  │
└────┬────┘
     │ 发货
┌────▼────┐
│ 已发货  │
└────┬────┘
     │ 签收
┌────▼────┐
│ 已完成  │
└─────────┘
```

### 状态机实现

```go
package orderfsm

import (
    "errors"
)

// OrderStatus 订单状态
type OrderStatus int

const (
    StatusPending OrderStatus = iota       // 待支付
    StatusPaid                             // 已支付
    StatusShipped                          // 已发货
    StatusDelivered                        // 已送达
    StatusCompleted                        // 已完成
    StatusCancelled                        // 已取消
    StatusRefunding                        // 退款中
    StatusRefunded                         // 已退款
)

func (s OrderStatus) String() string {
    return [...]string{
        "Pending", "Paid", "Shipped", "Delivered",
        "Completed", "Cancelled", "Refunding", "Refunded",
    }[s]
}

// OrderEvent 订单事件
type OrderEvent int

const (
    EventPay OrderEvent = iota
    EventShip
    EventDeliver
    EventComplete
    EventCancel
    EventRefund
    EventConfirmRefund
)

// OrderFSM 订单状态机
type OrderFSM struct {
    currentState OrderStatus
    transitions  map[OrderStatus]map[OrderEvent]OrderStatus
}

// NewOrderFSM 创建订单状态机
func NewOrderFSM(initialState OrderStatus) *OrderFSM {
    fsm := &OrderFSM{
        currentState: initialState,
        transitions:  make(map[OrderStatus]map[OrderEvent]OrderStatus),
    }

    // 定义状态转换规则
    fsm.defineTransitions()

    return fsm
}

func (fsm *OrderFSM) defineTransitions() {
    // 待支付 -> 已支付/已取消
    fsm.transitions[StatusPending] = map[OrderEvent]OrderStatus{
        EventPay:    StatusPaid,
        EventCancel: StatusCancelled,
    }

    // 已支付 -> 已发货/退款中
    fsm.transitions[StatusPaid] = map[OrderEvent]OrderStatus{
        EventShip:   StatusShipped,
        EventRefund: StatusRefunding,
    }

    // 已发货 -> 已送达
    fsm.transitions[StatusShipped] = map[OrderEvent]OrderStatus{
        EventDeliver: StatusDelivered,
    }

    // 已送达 -> 已完成
    fsm.transitions[StatusDelivered] = map[OrderEvent]OrderStatus{
        EventComplete: StatusCompleted,
    }

    // 退款中 -> 已退款
    fsm.transitions[StatusRefunding] = map[OrderEvent]OrderStatus{
        EventConfirmRefund: StatusRefunded,
    }
}

// Trigger 触发事件
func (fsm *OrderFSM) Trigger(event OrderEvent) error {
    nextStateMap, exists := fsm.transitions[fsm.currentState]
    if !exists {
        return errors.New("no transitions defined for current state")
    }

    nextState, exists := nextStateMap[event]
    if !exists {
        return errors.New("invalid event for current state")
    }

    fsm.currentState = nextState
    return nil
}

// CurrentState 获取当前状态
func (fsm *OrderFSM) CurrentState() OrderStatus {
    return fsm.currentState
}

// CanTransition 检查是否可以转换
func (fsm *OrderFSM) CanTransition(event OrderEvent) bool {
    nextStateMap, exists := fsm.transitions[fsm.currentState]
    if !exists {
        return false
    }

    _, exists = nextStateMap[event]
    return exists
}
```

---

## 核心功能

### 1. 创建订单

详见: [电商系统 - 订单流程](./03-电商系统.md#订单流程)

### 2. 订单分库分表

```go
package sharding

import (
    "database/sql"
    "fmt"
)

// OrderShardingStrategy 订单分片策略
type OrderShardingStrategy struct {
    dbCount    int
    tableCount int
}

// NewOrderShardingStrategy 创建分片策略
func NewOrderShardingStrategy(dbCount, tableCount int) *OrderShardingStrategy {
    return &OrderShardingStrategy{
        dbCount:    dbCount,
        tableCount: tableCount,
    }
}

// GetDBIndex 获取数据库索引
func (oss *OrderShardingStrategy) GetDBIndex(orderID int64) int {
    return int(orderID % int64(oss.dbCount))
}

// GetTableIndex 获取表索引
func (oss *OrderShardingStrategy) GetTableIndex(orderID int64) int {
    return int(orderID % int64(oss.tableCount))
}

// GetTableName 获取表名
func (oss *OrderShardingStrategy) GetTableName(orderID int64) string {
    tableIdx := oss.GetTableIndex(orderID)
    return fmt.Sprintf("order_%d", tableIdx)
}

// ShardingRouter 分片路由器
type ShardingRouter struct {
    dbs      []*sql.DB
    strategy *OrderShardingStrategy
}

// NewShardingRouter 创建分片路由器
func NewShardingRouter(dbs []*sql.DB, strategy *OrderShardingStrategy) *ShardingRouter {
    return &ShardingRouter{
        dbs:      dbs,
        strategy: strategy,
    }
}

// GetDB 获取数据库连接
func (sr *ShardingRouter) GetDB(orderID int64) *sql.DB {
    dbIdx := sr.strategy.GetDBIndex(orderID)
    return sr.dbs[dbIdx]
}

// GetTableName 获取表名
func (sr *ShardingRouter) GetTableName(orderID int64) string {
    return sr.strategy.GetTableName(orderID)
}
```

### 3. 订单号生成

```go
package idgen

import (
    "fmt"
    "sync"
    "time"
)

// SnowflakeIDGenerator 雪花算法ID生成器
type SnowflakeIDGenerator struct {
    mu            sync.Mutex
    epoch         int64 // 起始时间戳 (毫秒)
    workerID      int64 // 机器ID (10位)
    datacenterID  int64 // 数据中心ID (5位)
    sequence      int64 // 序列号 (12位)
    lastTimestamp int64 // 上次生成ID的时间戳
}

const (
    workerIDBits     = 10
    datacenterIDBits = 5
    sequenceBits     = 12

    maxWorkerID     = -1 ^ (-1 << workerIDBits)
    maxDatacenterID = -1 ^ (-1 << datacenterIDBits)
    maxSequence     = -1 ^ (-1 << sequenceBits)

    workerIDShift      = sequenceBits
    datacenterIDShift  = sequenceBits + workerIDBits
    timestampLeftShift = sequenceBits + workerIDBits + datacenterIDBits
)

// NewSnowflakeIDGenerator 创建ID生成器
func NewSnowflakeIDGenerator(workerID, datacenterID int64) (*SnowflakeIDGenerator, error) {
    if workerID < 0 || workerID > maxWorkerID {
        return nil, fmt.Errorf("worker ID must be between 0 and %d", maxWorkerID)
    }

    if datacenterID < 0 || datacenterID > maxDatacenterID {
        return nil, fmt.Errorf("datacenter ID must be between 0 and %d", maxDatacenterID)
    }

    return &SnowflakeIDGenerator{
        epoch:        1609459200000, // 2021-01-01 00:00:00
        workerID:     workerID,
        datacenterID: datacenterID,
        sequence:     0,
    }, nil
}

// NextID 生成下一个ID
func (g *SnowflakeIDGenerator) NextID() int64 {
    g.mu.Lock()
    defer g.mu.Unlock()

    timestamp := g.timeGen()

    if timestamp < g.lastTimestamp {
        // 时钟回拨
        panic("clock moved backwards")
    }

    if timestamp == g.lastTimestamp {
        // 同一毫秒内，序列号+1
        g.sequence = (g.sequence + 1) & maxSequence
        if g.sequence == 0 {
            // 序列号溢出，等待下一毫秒
            timestamp = g.tilNextMillis(g.lastTimestamp)
        }
    } else {
        // 不同毫秒，序列号重置
        g.sequence = 0
    }

    g.lastTimestamp = timestamp

    // 生成ID
    id := ((timestamp - g.epoch) << timestampLeftShift) |
        (g.datacenterID << datacenterIDShift) |
        (g.workerID << workerIDShift) |
        g.sequence

    return id
}

func (g *SnowflakeIDGenerator) timeGen() int64 {
    return time.Now().UnixNano() / 1e6
}

func (g *SnowflakeIDGenerator) tilNextMillis(lastTimestamp int64) int64 {
    timestamp := g.timeGen()
    for timestamp <= lastTimestamp {
        timestamp = g.timeGen()
    }
    return timestamp
}
```

### 4. 订单查询优化

```go
package query

import (
    "Context"
    "database/sql"
    "encoding/json"
    "time"

    "github.com/go-redis/redis/v8"
)

// OrderQueryService 订单查询服务
type OrderQueryService struct {
    db    *sql.DB
    cache *redis.Client
}

// GetOrderByID 根据ID查询订单
func (oqs *OrderQueryService) GetOrderByID(ctx Context.Context, orderID int64) (*Order, error) {
    // 1. 查询缓存
    cacheKey := oqs.orderCacheKey(orderID)
    cached, err := oqs.cache.Get(ctx, cacheKey).Result()
    if err == nil {
        var order Order
        if err := json.Unmarshal([]byte(cached), &order); err == nil {
            return &order, nil
        }
    }

    // 2. 查询数据库
    order, err := oqs.queryOrderFromDB(ctx, orderID)
    if err != nil {
        return nil, err
    }

    // 3. 写入缓存
    data, _ := json.Marshal(order)
    oqs.cache.Set(ctx, cacheKey, data, 1*time.Hour)

    return order, nil
}

// ListUserOrders 查询用户订单列表
func (oqs *OrderQueryService) ListUserOrders(ctx Context.Context, userID int64, page, pageSize int) ([]*Order, int, error) {
    // 使用ES实现高效查询
    // 这里简化为直接查询数据库
    offset := (page - 1) * pageSize

    query := `
        SELECT id, user_id, status, total_amount, created_at
        FROM orders
        WHERE user_id = ?
        ORDER BY created_at DESC
        LIMIT ? OFFSET ?
    `

    rows, err := oqs.db.QueryContext(ctx, query, userID, pageSize, offset)
    if err != nil {
        return nil, 0, err
    }
    defer rows.Close()

    orders := make([]*Order, 0, pageSize)
    for rows.Next() {
        var order Order
        if err := rows.Scan(&order.ID, &order.UserID, &order.Status, &order.TotalAmount, &order.CreatedAt); err != nil {
            return nil, 0, err
        }
        orders = append(orders, &order)
    }

    // 查询总数
    var total int
    countQuery := "SELECT COUNT(*) FROM orders WHERE user_id = ?"
    oqs.db.QueryRowContext(ctx, countQuery, userID).Scan(&total)

    return orders, total, nil
}

func (oqs *OrderQueryService) orderCacheKey(orderID int64) string {
    return ""
}

func (oqs *OrderQueryService) queryOrderFromDB(ctx Context.Context, orderID int64) (*Order, error) {
    return nil, nil
}

type Order struct {
    ID          int64
    UserID      int64
    Status      OrderStatus
    TotalAmount float64
    CreatedAt   time.Time
}
```

---

## 分布式事务

### Saga模式

```go
package saga

import (
    "Context"
    "fmt"
)

// SagaOrchestrator Saga编排器
type SagaOrchestrator struct {
    steps []*SagaStep
}

// NewSagaOrchestrator 创建Saga编排器
func NewSagaOrchestrator() *SagaOrchestrator {
    return &SagaOrchestrator{
        steps: make([]*SagaStep, 0),
    }
}

// AddStep 添加步骤
func (so *SagaOrchestrator) AddStep(name string, action Action, compensate Compensate) *SagaOrchestrator {
    so.steps = append(so.steps, &SagaStep{
        Name:       name,
        Action:     action,
        Compensate: compensate,
    })
    return so
}

// Execute 执行Saga
func (so *SagaOrchestrator) Execute(ctx Context.Context) error {
    executedSteps := make([]*SagaStep, 0)

    // 执行所有步骤
    for _, step := range so.steps {
        if err := step.Action(ctx); err != nil {
            // 执行失败，回滚已执行的步骤
            so.rollback(ctx, executedSteps)
            return fmt.Errorf("step %s failed: %w", step.Name, err)
        }
        executedSteps = append(executedSteps, step)
    }

    return nil
}

// rollback 回滚
func (so *SagaOrchestrator) rollback(ctx Context.Context, executedSteps []*SagaStep) {
    // 逆序回滚
    for i := len(executedSteps) - 1; i >= 0; i-- {
        step := executedSteps[i]
        if err := step.Compensate(ctx); err != nil {
            // 记录补偿失败
            fmt.Printf("compensate %s failed: %v\n", step.Name, err)
        }
    }
}

// SagaStep Saga步骤
type SagaStep struct {
    Name       string
    Action     Action
    Compensate Compensate
}

type Action func(ctx Context.Context) error
type Compensate func(ctx Context.Context) error

// 示例：订单Saga
func CreateOrderSaga(order *Order) *SagaOrchestrator {
    saga := NewSagaOrchestrator()

    // 步骤1: 创建订单
    saga.AddStep("create_order",
        func(ctx Context.Context) error {
            return createOrder(ctx, order)
        },
        func(ctx Context.Context) error {
            return deleteOrder(ctx, order.ID)
        },
    )

    // 步骤2: 扣减库存
    saga.AddStep("deduct_inventory",
        func(ctx Context.Context) error {
            return deductInventory(ctx, order.Items)
        },
        func(ctx Context.Context) error {
            return restoreInventory(ctx, order.Items)
        },
    )

    // 步骤3: 扣减积分
    saga.AddStep("deduct_points",
        func(ctx Context.Context) error {
            return deductPoints(ctx, order.UserID, order.PointsUsed)
        },
        func(ctx Context.Context) error {
            return restorePoints(ctx, order.UserID, order.PointsUsed)
        },
    )

    return saga
}

func createOrder(ctx Context.Context, order *Order) error       { return nil }
func deleteOrder(ctx Context.Context, orderID int64) error      { return nil }
func deductInventory(ctx Context.Context, items []*OrderItem) error { return nil }
func restoreInventory(ctx Context.Context, items []*OrderItem) error { return nil }
func deductPoints(ctx Context.Context, userID int64, points int) error { return nil }
func restorePoints(ctx Context.Context, userID int64, points int) error { return nil }

type OrderItem struct {
    ProductID int64
    Quantity  int
}
```

---

## 性能优化

### 1. 读写分离

```go
// 主库写入，从库读取
type OrderRepository struct {
    masterDB *sql.DB
    slaveDB  *sql.DB
}

func (repo *OrderRepository) Create(order *Order) error {
    // 写主库
    _, err := repo.masterDB.Exec("INSERT INTO orders ...")
    return err
}

func (repo *OrderRepository) Get(orderID int64) (*Order, error) {
    // 读从库
    row := repo.slaveDB.QueryRow("SELECT * FROM orders WHERE id = ?", orderID)
    // ...
    return nil, nil
}
```

### 2. 异步处理

```go
// 订单创建成功后异步发送通知
func (os *OrderService) CreateOrder(ctx Context.Context, req *CreateOrderRequest) (*Order, error) {
    order, err := os.createOrderSync(ctx, req)
    if err != nil {
        return nil, err
    }

    // 异步发送邮件、短信通知
    go os.sendNotifications(order)

    // 异步更新统计数据
    go os.updateStatistics(order)

    return order, nil
}
```

### 3. 批量处理
