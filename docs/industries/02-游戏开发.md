# æ¸¸æˆå¼€å‘ - Goè¯­è¨€å®æˆ˜

> Goè¯­è¨€åœ¨æ¸¸æˆæœåŠ¡å™¨å¼€å‘ä¸­çš„åº”ç”¨å®è·µ

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨Goç‰ˆæœ¬**: Go 1.25.3+

---

## ğŸ“‹ ç›®å½•

- [æ¸¸æˆå¼€å‘ - Goè¯­è¨€å®æˆ˜](#æ¸¸æˆå¼€å‘---goè¯­è¨€å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [ä¸ºä»€ä¹ˆé€‰æ‹©Goå¼€å‘æ¸¸æˆæœåŠ¡å™¨](#ä¸ºä»€ä¹ˆé€‰æ‹©goå¼€å‘æ¸¸æˆæœåŠ¡å™¨)
    - [Goåœ¨æ¸¸æˆé¢†åŸŸçš„åº”ç”¨](#goåœ¨æ¸¸æˆé¢†åŸŸçš„åº”ç”¨)
  - [æ¸¸æˆæœåŠ¡å™¨æ¶æ„](#æ¸¸æˆæœåŠ¡å™¨æ¶æ„)
    - [å…¸å‹æ¶æ„](#å…¸å‹æ¶æ„)
    - [æ ¸å¿ƒç»„ä»¶](#æ ¸å¿ƒç»„ä»¶)
  - [å®æ—¶é€šä¿¡](#å®æ—¶é€šä¿¡)
    - [WebSocketæœåŠ¡å™¨](#websocketæœåŠ¡å™¨)
  - [çŠ¶æ€åŒæ­¥](#çŠ¶æ€åŒæ­¥)
    - [çŠ¶æ€åŒæ­¥ç­–ç•¥](#çŠ¶æ€åŒæ­¥ç­–ç•¥)
      - [1. å¸§åŒæ­¥](#1-å¸§åŒæ­¥)
      - [2. çŠ¶æ€åŒæ­¥](#2-çŠ¶æ€åŒæ­¥)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [1. æ€§èƒ½ä¼˜åŒ–](#1-æ€§èƒ½ä¼˜åŒ–)
    - [2. ç½‘ç»œä¼˜åŒ–](#2-ç½‘ç»œä¼˜åŒ–)
    - [3. å®‰å…¨æ€§](#3-å®‰å…¨æ€§)
    - [4. å¯æ‰©å±•æ€§](#4-å¯æ‰©å±•æ€§)

---

## æ¦‚è¿°

### ä¸ºä»€ä¹ˆé€‰æ‹©Goå¼€å‘æ¸¸æˆæœåŠ¡å™¨

- âš¡ **é«˜æ€§èƒ½**: æ”¯æŒç™¾ä¸‡çº§å¹¶å‘è¿æ¥
- ğŸ® **ä½å»¶è¿Ÿ**: é€‚åˆå®æ—¶æ¸¸æˆ
- ğŸ”§ **æ˜“ç»´æŠ¤**: ç®€æ´çš„è¯­æ³•ï¼Œä¾¿äºå›¢é˜Ÿåä½œ
- ğŸ“¦ **æ˜“éƒ¨ç½²**: å•ä¸€äºŒè¿›åˆ¶ï¼Œè·¨å¹³å°æ”¯æŒ
- ğŸ”„ **çƒ­æ›´æ–°**: æ”¯æŒå¹³æ»‘å‡çº§

### Goåœ¨æ¸¸æˆé¢†åŸŸçš„åº”ç”¨

- **MMOæ¸¸æˆ**: å¤§å‹å¤šäººåœ¨çº¿æ¸¸æˆæœåŠ¡å™¨
- **MOBAæ¸¸æˆ**: å®æ—¶å¯¹æˆ˜æ¸¸æˆ
- **å¡ç‰Œæ¸¸æˆ**: å›åˆåˆ¶ç­–ç•¥æ¸¸æˆ
- **æ£‹ç‰Œæ¸¸æˆ**: åœ¨çº¿æ¡Œæ¸¸å¹³å°

---

## æ¸¸æˆæœåŠ¡å™¨æ¶æ„

### å…¸å‹æ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Game Architecture              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Client 1â”‚    â”‚ Client 2 â”‚     â”‚Client Nâ”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â”‚
â”‚       â”‚               â”‚              â”‚      â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                       â”‚                     â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚              â”‚   Load Balancer  â”‚           â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                       â”‚                     â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚       â”‚               â”‚                â”‚    â”‚
â”‚  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”   â”‚
â”‚  â”‚Gateway 1 â”‚  â”‚Gateway 2 â”‚  â”‚Gateway 3 â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”˜   â”‚
â”‚       â”‚              â”‚               â”‚      â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                      â”‚                      â”‚
â”‚             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚             â”‚   Game Server    â”‚            â”‚
â”‚             â”‚   (Room/Match)   â”‚            â”‚
â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                      â”‚                      â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚       â”‚              â”‚              â”‚       â”‚
â”‚  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”     â”‚
â”‚  â”‚  Redis  â”‚  â”‚ Database â”‚  â”‚ Message â”‚     â”‚
â”‚  â”‚ (Cache) â”‚  â”‚(Persist) â”‚  â”‚  Queue  â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒç»„ä»¶

è¯¦ç»†å†…å®¹:

- [å®æ—¶é€šä¿¡ç³»ç»Ÿ](./06-å®æ—¶é€šä¿¡.md)
- [çŠ¶æ€åŒæ­¥æœºåˆ¶](./07-çŠ¶æ€åŒæ­¥.md)

---

## å®æ—¶é€šä¿¡

è¯¦ç»†å†…å®¹è¯·å‚è€ƒ: [å®æ—¶é€šä¿¡ç³»ç»Ÿ](./06-å®æ—¶é€šä¿¡.md)

### WebSocketæœåŠ¡å™¨

```go
package gameserver

import (
    "context"
    "encoding/json"
    "log"
    "sync"
    "time"

    "github.com/gorilla/websocket"
)

// GameServer æ¸¸æˆæœåŠ¡å™¨
type GameServer struct {
    clients    map[string]*Client
    rooms      map[string]*Room
    register   chan *Client
    unregister chan *Client
    broadcast  chan *Message
    mu         sync.RWMutex
}

// NewGameServer åˆ›å»ºæ¸¸æˆæœåŠ¡å™¨
func NewGameServer() *GameServer {
    return &GameServer{
        clients:    make(map[string]*Client),
        rooms:      make(map[string]*Room),
        register:   make(chan *Client, 100),
        unregister: make(chan *Client, 100),
        broadcast:  make(chan *Message, 1000),
    }
}

// Run è¿è¡ŒæœåŠ¡å™¨
func (gs *GameServer) Run(ctx context.Context) {
    for {
        select {
        case client := <-gs.register:
            gs.registerClient(client)
        case client := <-gs.unregister:
            gs.unregisterClient(client)
        case message := <-gs.broadcast:
            gs.broadcastMessage(message)
        case <-ctx.Done():
            return
        }
    }
}

// Client å®¢æˆ·ç«¯
type Client struct {
    ID       string
    UserID   string
    Conn     *websocket.Conn
    Send     chan *Message
    Server   *GameServer
    RoomID   string
    mu       sync.Mutex
}

// ReadPump è¯»å–æ¶ˆæ¯
func (c *Client) ReadPump() {
    defer func() {
        c.Server.unregister <- c
        c.Conn.Close()
    }()

    c.Conn.SetReadDeadline(time.Now().Add(60 * time.Second))
    c.Conn.SetPongHandler(func(string) error {
        c.Conn.SetReadDeadline(time.Now().Add(60 * time.Second))
        return nil
    })

    for {
        _, messageData, err := c.Conn.ReadMessage()
        if err != nil {
            if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
                log.Printf("error: %v", err)
            }
            break
        }

        var msg Message
        if err := json.Unmarshal(messageData, &msg); err != nil {
            log.Printf("unmarshal error: %v", err)
            continue
        }

        msg.FromClientID = c.ID
        msg.Timestamp = time.Now()

        // å¤„ç†æ¶ˆæ¯
        c.Server.handleMessage(c, &msg)
    }
}

// WritePump å‘é€æ¶ˆæ¯
func (c *Client) WritePump() {
    ticker := time.NewTicker(54 * time.Second)
    defer func() {
        ticker.Stop()
        c.Conn.Close()
    }()

    for {
        select {
        case message, ok := <-c.Send:
            c.Conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
            if !ok {
                c.Conn.WriteMessage(websocket.CloseMessage, []byte{})
                return
            }

            data, err := json.Marshal(message)
            if err != nil {
                log.Printf("marshal error: %v", err)
                continue
            }

            if err := c.Conn.WriteMessage(websocket.TextMessage, data); err != nil {
                return
            }

        case <-ticker.C:
            c.Conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
            if err := c.Conn.WriteMessage(websocket.PingMessage, nil); err != nil {
                return
            }
        }
    }
}

// Message æ¶ˆæ¯
type Message struct {
    Type         MessageType            `json:"type"`
    FromClientID string                 `json:"from_client_id,omitempty"`
    ToClientID   string                 `json:"to_client_id,omitempty"`
    RoomID       string                 `json:"room_id,omitempty"`
    Payload      map[string]interface{} `json:"payload"`
    Timestamp    time.Time              `json:"timestamp"`
}

type MessageType string

const (
    MessageTypeJoinRoom  MessageType = "join_room"
    MessageTypeLeaveRoom MessageType = "leave_room"
    MessageTypeGameAction MessageType = "game_action"
    MessageTypeChat      MessageType = "chat"
    MessageTypeSync      MessageType = "sync"
)

// Room æˆ¿é—´
type Room struct {
    ID          string
    Clients     map[string]*Client
    GameState   *GameState
    MaxPlayers  int
    mu          sync.RWMutex
    broadcast   chan *Message
}

// NewRoom åˆ›å»ºæˆ¿é—´
func NewRoom(id string, maxPlayers int) *Room {
    return &Room{
        ID:         id,
        Clients:    make(map[string]*Client),
        GameState:  NewGameState(),
        MaxPlayers: maxPlayers,
        broadcast:  make(chan *Message, 100),
    }
}

// AddClient æ·»åŠ å®¢æˆ·ç«¯åˆ°æˆ¿é—´
func (r *Room) AddClient(client *Client) error {
    r.mu.Lock()
    defer r.mu.Unlock()

    if len(r.Clients) >= r.MaxPlayers {
        return ErrRoomFull
    }

    r.Clients[client.ID] = client
    client.RoomID = r.ID

    return nil
}

// RemoveClient ä»æˆ¿é—´ç§»é™¤å®¢æˆ·ç«¯
func (r *Room) RemoveClient(clientID string) {
    r.mu.Lock()
    defer r.mu.Unlock()

    delete(r.Clients, clientID)
}

// Broadcast å¹¿æ’­æ¶ˆæ¯åˆ°æˆ¿é—´æ‰€æœ‰å®¢æˆ·ç«¯
func (r *Room) Broadcast(msg *Message) {
    r.mu.RLock()
    defer r.mu.RUnlock()

    for _, client := range r.Clients {
        select {
        case client.Send <- msg:
        default:
            close(client.Send)
            delete(r.Clients, client.ID)
        }
    }
}

// GameState æ¸¸æˆçŠ¶æ€
type GameState struct {
    Players    map[string]*Player
    StartTime  time.Time
    Status     GameStatus
    mu         sync.RWMutex
}

type GameStatus string

const (
    GameStatusWaiting  GameStatus = "waiting"
    GameStatusPlaying  GameStatus = "playing"
    GameStatusFinished GameStatus = "finished"
)

// Player ç©å®¶
type Player struct {
    ID       string
    Name     string
    Position Position
    Health   int
    Score    int
}

type Position struct {
    X float64 `json:"x"`
    Y float64 `json:"y"`
    Z float64 `json:"z"`
}

func NewGameState() *GameState {
    return &GameState{
        Players: make(map[string]*Player),
        Status:  GameStatusWaiting,
    }
}

// handleMessage å¤„ç†æ¶ˆæ¯
func (gs *GameServer) handleMessage(client *Client, msg *Message) {
    switch msg.Type {
    case MessageTypeJoinRoom:
        gs.handleJoinRoom(client, msg)
    case MessageTypeLeaveRoom:
        gs.handleLeaveRoom(client, msg)
    case MessageTypeGameAction:
        gs.handleGameAction(client, msg)
    case MessageTypeChat:
        gs.handleChat(client, msg)
    }
}

func (gs *GameServer) handleJoinRoom(client *Client, msg *Message) {
    roomID := msg.RoomID

    gs.mu.Lock()
    room, exists := gs.rooms[roomID]
    if !exists {
        room = NewRoom(roomID, 4)
        gs.rooms[roomID] = room
    }
    gs.mu.Unlock()

    if err := room.AddClient(client); err != nil {
        client.Send <- &Message{
            Type:    "error",
            Payload: map[string]interface{}{"message": err.Error()},
        }
        return
    }

    // é€šçŸ¥æˆ¿é—´å…¶ä»–ç©å®¶
    room.Broadcast(&Message{
        Type:   "player_joined",
        RoomID: roomID,
        Payload: map[string]interface{}{
            "player_id": client.UserID,
        },
        Timestamp: time.Now(),
    })
}

func (gs *GameServer) handleLeaveRoom(client *Client, msg *Message) {
    gs.mu.RLock()
    room := gs.rooms[client.RoomID]
    gs.mu.RUnlock()

    if room != nil {
        room.RemoveClient(client.ID)

        // é€šçŸ¥æˆ¿é—´å…¶ä»–ç©å®¶
        room.Broadcast(&Message{
            Type:   "player_left",
            RoomID: client.RoomID,
            Payload: map[string]interface{}{
                "player_id": client.UserID,
            },
            Timestamp: time.Now(),
        })
    }

    client.RoomID = ""
}

func (gs *GameServer) handleGameAction(client *Client, msg *Message) {
    gs.mu.RLock()
    room := gs.rooms[client.RoomID]
    gs.mu.RUnlock()

    if room == nil {
        return
    }

    // å¤„ç†æ¸¸æˆé€»è¾‘
    room.GameState.mu.Lock()
    player, exists := room.GameState.Players[client.UserID]
    if !exists {
        player = &Player{
            ID:     client.UserID,
            Health: 100,
            Score:  0,
        }
        room.GameState.Players[client.UserID] = player
    }

    // æ›´æ–°ç©å®¶çŠ¶æ€
    if action, ok := msg.Payload["action"].(string); ok {
        switch action {
        case "move":
            if pos, ok := msg.Payload["position"].(map[string]interface{}); ok {
                player.Position = Position{
                    X: pos["x"].(float64),
                    Y: pos["y"].(float64),
                    Z: pos["z"].(float64),
                }
            }
        case "attack":
            // å¤„ç†æ”»å‡»é€»è¾‘
        }
    }
    room.GameState.mu.Unlock()

    // å¹¿æ’­çŠ¶æ€æ›´æ–°
    room.Broadcast(&Message{
        Type:   MessageTypeSync,
        RoomID: client.RoomID,
        Payload: map[string]interface{}{
            "player_id": client.UserID,
            "state":     player,
        },
        Timestamp: time.Now(),
    })
}

func (gs *GameServer) handleChat(client *Client, msg *Message) {
    gs.mu.RLock()
    room := gs.rooms[client.RoomID]
    gs.mu.RUnlock()

    if room != nil {
        room.Broadcast(msg)
    }
}

func (gs *GameServer) registerClient(client *Client) {
    gs.mu.Lock()
    defer gs.mu.Unlock()
    gs.clients[client.ID] = client
}

func (gs *GameServer) unregisterClient(client *Client) {
    gs.mu.Lock()
    defer gs.mu.Unlock()

    if _, ok := gs.clients[client.ID]; ok {
        delete(gs.clients, client.ID)
        close(client.Send)

        // ä»æˆ¿é—´ç§»é™¤
        if client.RoomID != "" {
            if room := gs.rooms[client.RoomID]; room != nil {
                room.RemoveClient(client.ID)
            }
        }
    }
}

func (gs *GameServer) broadcastMessage(msg *Message) {
    gs.mu.RLock()
    defer gs.mu.RUnlock()

    for _, client := range gs.clients {
        select {
        case client.Send <- msg:
        default:
            close(client.Send)
            delete(gs.clients, client.ID)
        }
    }
}

var ErrRoomFull = &struct{ error }{}
```

---

## çŠ¶æ€åŒæ­¥

è¯¦ç»†å†…å®¹è¯·å‚è€ƒ: [çŠ¶æ€åŒæ­¥æœºåˆ¶](./07-çŠ¶æ€åŒæ­¥.md)

### çŠ¶æ€åŒæ­¥ç­–ç•¥

#### 1. å¸§åŒæ­¥

```go
package framesync

import (
    "context"
    "sync"
    "time"
)

// FrameSyncEngine å¸§åŒæ­¥å¼•æ“
type FrameSyncEngine struct {
    frameRate   int           // å¸§ç‡ (å¦‚ 30å¸§/ç§’)
    currentFrame int64         // å½“å‰å¸§å·
    inputs      map[int64][]*Input // å¸§å· -> è¾“å…¥åˆ—è¡¨
    clients     map[string]*Client
    mu          sync.RWMutex
}

// NewFrameSyncEngine åˆ›å»ºå¸§åŒæ­¥å¼•æ“
func NewFrameSyncEngine(frameRate int) *FrameSyncEngine {
    return &FrameSyncEngine{
        frameRate: frameRate,
        inputs:    make(map[int64][]*Input),
        clients:   make(map[string]*Client),
    }
}

// Run è¿è¡Œå¸§åŒæ­¥
func (fse *FrameSyncEngine) Run(ctx context.Context) {
    ticker := time.NewTicker(time.Second / time.Duration(fse.frameRate))
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            fse.processFrame()
        case <-ctx.Done():
            return
        }
    }
}

// SubmitInput æäº¤è¾“å…¥
func (fse *FrameSyncEngine) SubmitInput(clientID string, input *Input) {
    fse.mu.Lock()
    defer fse.mu.Unlock()

    frameNum := fse.currentFrame + 1
    input.FrameNum = frameNum
    input.ClientID = clientID

    fse.inputs[frameNum] = append(fse.inputs[frameNum], input)
}

// processFrame å¤„ç†å½“å‰å¸§
func (fse *FrameSyncEngine) processFrame() {
    fse.mu.Lock()
    defer fse.mu.Unlock()

    fse.currentFrame++

    // è·å–å½“å‰å¸§çš„æ‰€æœ‰è¾“å…¥
    frameInputs := fse.inputs[fse.currentFrame]

    // å¹¿æ’­ç»™æ‰€æœ‰å®¢æˆ·ç«¯
    frame := &Frame{
        FrameNum:  fse.currentFrame,
        Inputs:    frameInputs,
        Timestamp: time.Now(),
    }

    for _, client := range fse.clients {
        client.Send <- frame
    }

    // æ¸…ç†æ—§å¸§æ•°æ® (ä¿ç•™æœ€è¿‘100å¸§)
    if fse.currentFrame > 100 {
        delete(fse.inputs, fse.currentFrame-100)
    }
}

// Input è¾“å…¥
type Input struct {
    FrameNum  int64
    ClientID  string
    Action    string
    Data      map[string]interface{}
}

// Frame å¸§
type Frame struct {
    FrameNum  int64
    Inputs    []*Input
    Timestamp time.Time
}

type Client struct {
    ID   string
    Send chan *Frame
}
```

#### 2. çŠ¶æ€åŒæ­¥

```go
package statesync

import (
    "sync"
    "time"
)

// StateSyncEngine çŠ¶æ€åŒæ­¥å¼•æ“
type StateSyncEngine struct {
    state      *GameState
    snapshots  []*Snapshot
    mu         sync.RWMutex
    syncRate   int // åŒæ­¥é¢‘ç‡ (Hz)
}

// NewStateSyncEngine åˆ›å»ºçŠ¶æ€åŒæ­¥å¼•æ“
func NewStateSyncEngine(syncRate int) *StateSyncEngine {
    return &StateSyncEngine{
        state:     NewGameState(),
        snapshots: make([]*Snapshot, 0),
        syncRate:  syncRate,
    }
}

// UpdateState æ›´æ–°çŠ¶æ€
func (sse *StateSyncEngine) UpdateState(playerID string, update *StateUpdate) {
    sse.mu.Lock()
    defer sse.mu.Unlock()

    player := sse.state.Players[playerID]
    if player == nil {
        player = &Player{ID: playerID}
        sse.state.Players[playerID] = player
    }

    // åº”ç”¨çŠ¶æ€æ›´æ–°
    if update.Position != nil {
        player.Position = *update.Position
    }
    if update.Velocity != nil {
        player.Velocity = *update.Velocity
    }
    if update.Health != nil {
        player.Health = *update.Health
    }

    player.LastUpdate = time.Now()
}

// CreateSnapshot åˆ›å»ºå¿«ç…§
func (sse *StateSyncEngine) CreateSnapshot() *Snapshot {
    sse.mu.RLock()
    defer sse.mu.RUnlock()

    snapshot := &Snapshot{
        Timestamp: time.Now(),
        FrameNum:  int64(len(sse.snapshots)),
        Players:   make(map[string]*PlayerSnapshot),
    }

    for id, player := range sse.state.Players {
        snapshot.Players[id] = &PlayerSnapshot{
            Position: player.Position,
            Velocity: player.Velocity,
            Health:   player.Health,
        }
    }

    sse.snapshots = append(sse.snapshots, snapshot)

    // ä¿ç•™æœ€è¿‘100ä¸ªå¿«ç…§
    if len(sse.snapshots) > 100 {
        sse.snapshots = sse.snapshots[1:]
    }

    return snapshot
}

// Interpolate æ’å€¼è®¡ç®—
func (sse *StateSyncEngine) Interpolate(playerID string, t time.Time) *PlayerSnapshot {
    sse.mu.RLock()
    defer sse.mu.RUnlock()

    // æ‰¾åˆ°æ—¶é—´tå‰åçš„ä¸¤ä¸ªå¿«ç…§
    var prev, next *Snapshot
    for i := len(sse.snapshots) - 1; i >= 0; i-- {
        if sse.snapshots[i].Timestamp.Before(t) {
            prev = sse.snapshots[i]
            if i+1 < len(sse.snapshots) {
                next = sse.snapshots[i+1]
            }
            break
        }
    }

    if prev == nil || next == nil {
        // æ— æ³•æ’å€¼ï¼Œè¿”å›æœ€æ–°çŠ¶æ€
        if len(sse.snapshots) > 0 {
            return sse.snapshots[len(sse.snapshots)-1].Players[playerID]
        }
        return nil
    }

    prevPlayer := prev.Players[playerID]
    nextPlayer := next.Players[playerID]

    if prevPlayer == nil || nextPlayer == nil {
        return nil
    }

    // è®¡ç®—æ’å€¼å› å­
    totalDuration := next.Timestamp.Sub(prev.Timestamp)
    elapsed := t.Sub(prev.Timestamp)
    factor := float64(elapsed) / float64(totalDuration)

    // çº¿æ€§æ’å€¼
    return &PlayerSnapshot{
        Position: Position{
            X: prevPlayer.Position.X + (nextPlayer.Position.X-prevPlayer.Position.X)*factor,
            Y: prevPlayer.Position.Y + (nextPlayer.Position.Y-prevPlayer.Position.Y)*factor,
            Z: prevPlayer.Position.Z + (nextPlayer.Position.Z-prevPlayer.Position.Z)*factor,
        },
        Velocity: Velocity{
            X: prevPlayer.Velocity.X + (nextPlayer.Velocity.X-prevPlayer.Velocity.X)*factor,
            Y: prevPlayer.Velocity.Y + (nextPlayer.Velocity.Y-prevPlayer.Velocity.Y)*factor,
            Z: prevPlayer.Velocity.Z + (nextPlayer.Velocity.Z-prevPlayer.Velocity.Z)*factor,
        },
        Health: int(float64(prevPlayer.Health) + float64(nextPlayer.Health-prevPlayer.Health)*factor),
    }
}

type GameState struct {
    Players map[string]*Player
}

type Player struct {
    ID         string
    Position   Position
    Velocity   Velocity
    Health     int
    LastUpdate time.Time
}

type Position struct {
    X, Y, Z float64
}

type Velocity struct {
    X, Y, Z float64
}

type StateUpdate struct {
    Position *Position
    Velocity *Velocity
    Health   *int
}

type Snapshot struct {
    Timestamp time.Time
    FrameNum  int64
    Players   map[string]*PlayerSnapshot
}

type PlayerSnapshot struct {
    Position Position
    Velocity Velocity
    Health   int
}

func NewGameState() *GameState {
    return &GameState{
        Players: make(map[string]*Player),
    }
}
```

---

## æœ€ä½³å®è·µ

### 1. æ€§èƒ½ä¼˜åŒ–

- âœ… ä½¿ç”¨å¯¹è±¡æ± å‡å°‘GC
- âœ… ä¼˜åŒ–ç½‘ç»œåŒ…å¤§å°
- âœ… æ‰¹é‡å‘é€æ¶ˆæ¯
- âœ… ä½¿ç”¨äºŒè¿›åˆ¶åè®® (Protobuf)

### 2. ç½‘ç»œä¼˜åŒ–

- âœ… å®¢æˆ·ç«¯é¢„æµ‹
- âœ… æœåŠ¡å™¨å’Œè§£ (Server Reconciliation)
- âœ… å»¶è¿Ÿè¡¥å¿
- âœ… ä¸¢åŒ…é‡ä¼ 

### 3. å®‰å…¨æ€§

- âœ… è¾“å…¥éªŒè¯
- âœ… åä½œå¼Šæ£€æµ‹
- âœ… åŠ å¯†é€šä¿¡
- âœ… é™æµé˜²æŠ¤

### 4. å¯æ‰©å±•æ€§

- âœ… æ— çŠ¶æ€è®¾è®¡
- âœ… æˆ¿é—´åˆ†ç‰‡
- âœ… åŠ¨æ€æ‰©å®¹
- âœ… è´Ÿè½½å‡è¡¡

---

**ç›¸å…³æ–‡æ¡£**:

- [å®æ—¶é€šä¿¡ç³»ç»Ÿ](./06-å®æ—¶é€šä¿¡.md)
- [çŠ¶æ€åŒæ­¥æœºåˆ¶](./07-çŠ¶æ€åŒæ­¥.md)
- [WebSocketå®æˆ˜](../development/web/12-WebSocket.md)

**ç»´æŠ¤è€…**: Game Development Team
**æœ€åæ›´æ–°**: 2025-10-29
