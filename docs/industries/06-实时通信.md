# 实时通信系统

> 游戏实时通信系统设计与实现

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用Go版本**: Go 1.25.3+

---

## 📋 目录

- [系统概述](#系统概述)
- [WebSocket通信](#websocket通信)
- [消息协议设计](#消息协议设计)
- [连接管理](#连接管理)
- [性能优化](#性能优化)

---

## 系统概述

### 实时通信需求

- ⚡ **低延迟**: < 50ms
- 🔄 **双向通信**: 服务器主动推送
- 📊 **高并发**: 支持百万并发连接
- 🛡️ **可靠性**: 断线重连、消息去重

### 技术选型

| 技术 | 用途 | 优势 |
|------|------|------|
| WebSocket | 实时通信 | 双向通信，低延迟 |
| Protobuf | 序列化 | 高效，跨语言 |
| Redis | 消息队列 | 高性能，持久化 |

---

## WebSocket通信

### 服务器实现

详见: [游戏开发 - 实时通信部分](./02-游戏开发.md#实时通信)

### 客户端示例

```javascript
// JavaScript WebSocket客户端
class GameClient {
    constructor(serverUrl) {
        this.serverUrl = serverUrl;
        this.ws = null;
        this.reconnectInterval = 3000;
        this.messageHandlers = new Map();
    }

    connect() {
        this.ws = new WebSocket(this.serverUrl);

        this.ws.onopen = () => {
            console.log('Connected to server');
            this.onConnect();
        };

        this.ws.onmessage = (event) => {
            const message = JSON.parse(event.data);
            this.handleMessage(message);
        };

        this.ws.onerror = (error) => {
            console.error('WebSocket error:', error);
        };

        this.ws.onclose = () => {
            console.log('Disconnected from server');
            this.reconnect();
        };
    }

    reconnect() {
        setTimeout(() => {
            console.log('Reconnecting...');
            this.connect();
        }, this.reconnectInterval);
    }

    send(type, payload) {
        if (this.ws.readyState === WebSocket.OPEN) {
            const message = {
                type: type,
                payload: payload,
                timestamp: Date.now()
            };
            this.ws.send(JSON.stringify(message));
        }
    }

    handleMessage(message) {
        const handler = this.messageHandlers.get(message.type);
        if (handler) {
            handler(message);
        }
    }

    on(messageType, handler) {
        this.messageHandlers.set(messageType, handler);
    }

    joinRoom(roomId) {
        this.send('join_room', { room_id: roomId });
    }

    sendGameAction(action, data) {
        this.send('game_action', { action, ...data });
    }

    onConnect() {
        // 连接成功后的处理
    }
}

// 使用示例
const client = new GameClient('ws://localhost:8080/ws');
client.connect();

client.on('player_joined', (message) => {
    console.log('Player joined:', message.payload.player_id);
});

client.on('sync', (message) => {
    console.log('State update:', message.payload);
});

client.joinRoom('room-123');
```

---

## 消息协议设计

### 协议格式

```proto
syntax = "proto3";

package gameproto;

// 消息类型
enum MessageType {
    UNKNOWN = 0;
    JOIN_ROOM = 1;
    LEAVE_ROOM = 2;
    GAME_ACTION = 3;
    SYNC = 4;
    CHAT = 5;
}

// 通用消息
message Message {
    MessageType type = 1;
    string from_client_id = 2;
    string to_client_id = 3;
    string room_id = 4;
    bytes payload = 5;
    int64 timestamp = 6;
}

// 加入房间
message JoinRoomRequest {
    string room_id = 1;
    string user_id = 2;
    string nickname = 3;
}

// 游戏动作
message GameAction {
    string action = 1;
    Position position = 2;
    int32 target_id = 3;
    map<string, string> params = 4;
}

// 位置
message Position {
    double x = 1;
    double y = 2;
    double z = 3;
}

// 状态同步
message StateSync {
    int64 frame_num = 1;
    repeated PlayerState players = 2;
    int64 timestamp = 3;
}

// 玩家状态
message PlayerState {
    string player_id = 1;
    Position position = 2;
    Velocity velocity = 3;
    int32 health = 4;
    int32 score = 5;
}

// 速度
message Velocity {
    double x = 1;
    double y = 2;
    double z = 3;
}
```

---

## 连接管理

### 连接池

```go
package connection

import (
    "sync"
    "time"

    "github.com/gorilla/websocket"
)

// ConnectionPool 连接池
type ConnectionPool struct {
    connections map[string]*PooledConnection
    mu          sync.RWMutex
    maxIdle     time.Duration
    maxLifetime time.Duration
}

// NewConnectionPool 创建连接池
func NewConnectionPool() *ConnectionPool {
    return &ConnectionPool{
        connections: make(map[string]*PooledConnection),
        maxIdle:     5 * time.Minute,
        maxLifetime: 30 * time.Minute,
    }
}

// PooledConnection 池化连接
type PooledConnection struct {
    Conn       *websocket.Conn
    LastUsed   time.Time
    Created    time.Time
    InUse      bool
    mu         sync.Mutex
}

// Get 获取连接
func (cp *ConnectionPool) Get(clientID string) (*PooledConnection, bool) {
    cp.mu.RLock()
    defer cp.mu.RUnlock()

    conn, exists := cp.connections[clientID]
    if !exists {
        return nil, false
    }

    conn.mu.Lock()
    defer conn.mu.Unlock()

    // 检查连接是否有效
    if time.Since(conn.LastUsed) > cp.maxIdle {
        return nil, false
    }

    if time.Since(conn.Created) > cp.maxLifetime {
        return nil, false
    }

    conn.InUse = true
    conn.LastUsed = time.Now()

    return conn, true
}

// Put 放回连接
func (cp *ConnectionPool) Put(clientID string, conn *PooledConnection) {
    cp.mu.Lock()
    defer cp.mu.Unlock()

    conn.mu.Lock()
    defer conn.mu.Unlock()

    conn.InUse = false
    conn.LastUsed = time.Now()

    cp.connections[clientID] = conn
}

// Remove 移除连接
func (cp *ConnectionPool) Remove(clientID string) {
    cp.mu.Lock()
    defer cp.mu.Unlock()

    if conn, exists := cp.connections[clientID]; exists {
        conn.Conn.Close()
        delete(cp.connections, clientID)
    }
}

// Cleanup 清理过期连接
func (cp *ConnectionPool) Cleanup() {
    cp.mu.Lock()
    defer cp.mu.Unlock()

    now := time.Now()
    for clientID, conn := range cp.connections {
        if !conn.InUse && (now.Sub(conn.LastUsed) > cp.maxIdle || now.Sub(conn.Created) > cp.maxLifetime) {
            conn.Conn.Close()
            delete(cp.connections, clientID)
        }
    }
}
```

### 心跳检测

```go
package heartbeat

import (
    "context"
    "time"

    "github.com/gorilla/websocket"
)

// HeartbeatManager 心跳管理器
type HeartbeatManager struct {
    conn           *websocket.Conn
    pingInterval   time.Duration
    pongTimeout    time.Duration
    lastPongTime   time.Time
    disconnectChan chan struct{}
}

// NewHeartbeatManager 创建心跳管理器
func NewHeartbeatManager(conn *websocket.Conn) *HeartbeatManager {
    return &HeartbeatManager{
        conn:           conn,
        pingInterval:   30 * time.Second,
        pongTimeout:    60 * time.Second,
        lastPongTime:   time.Now(),
        disconnectChan: make(chan struct{}),
    }
}

// Start 启动心跳
func (hm *HeartbeatManager) Start(ctx context.Context) {
    // 设置pong处理器
    hm.conn.SetPongHandler(func(string) error {
        hm.lastPongTime = time.Now()
        return nil
    })

    // 发送ping
    pingTicker := time.NewTicker(hm.pingInterval)
    defer pingTicker.Stop()

    // 检查超时
    timeoutTicker := time.NewTicker(hm.pongTimeout / 2)
    defer timeoutTicker.Stop()

    for {
        select {
        case <-pingTicker.C:
            if err := hm.sendPing(); err != nil {
                return
            }

        case <-timeoutTicker.C:
            if time.Since(hm.lastPongTime) > hm.pongTimeout {
                close(hm.disconnectChan)
                return
            }

        case <-ctx.Done():
            return

        case <-hm.disconnectChan:
            return
        }
    }
}

func (hm *HeartbeatManager) sendPing() error {
    hm.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
    return hm.conn.WriteMessage(websocket.PingMessage, nil)
}

// DisconnectChan 返回断开连接通道
func (hm *HeartbeatManager) DisconnectChan() <-chan struct{} {
    return hm.disconnectChan
}
```

---

## 性能优化

### 1. 消息批量发送

```go
// MessageBatcher 消息批处理器
type MessageBatcher struct {
    messages []*Message
    maxSize  int
    maxWait  time.Duration
    sendFunc func([]*Message)
    mu       sync.Mutex
    timer    *time.Timer
}

func NewMessageBatcher(maxSize int, maxWait time.Duration, sendFunc func([]*Message)) *MessageBatcher {
    mb := &MessageBatcher{
        messages: make([]*Message, 0, maxSize),
        maxSize:  maxSize,
        maxWait:  maxWait,
        sendFunc: sendFunc,
    }
    mb.timer = time.AfterFunc(maxWait, mb.flush)
    return mb
}

func (mb *MessageBatcher) Add(msg *Message) {
    mb.mu.Lock()
    defer mb.mu.Unlock()

    mb.messages = append(mb.messages, msg)

    if len(mb.messages) >= mb.maxSize {
        mb.flush()
    }
}

func (mb *MessageBatcher) flush() {
    mb.mu.Lock()
    defer mb.mu.Unlock()

    if len(mb.messages) == 0 {
        return
    }

    mb.sendFunc(mb.messages)
    mb.messages = mb.messages[:0]

    mb.timer.Reset(mb.maxWait)
}
```

### 2. 对象池

```go
var messagePool = sync.Pool{
    New: func() interface{} {
        return &Message{
            Payload: make(map[string]interface{}),
        }
    },
}

func acquireMessage() *Message {
    return messagePool.Get().(*Message)
}

func releaseMessage(msg *Message) {
    msg.Reset()
    messagePool.Put(msg)
}

func (m *Message) Reset() {
    m.Type = ""
    m.FromClientID = ""
    m.ToClientID = ""
    m.RoomID = ""
    for k := range m.Payload {
        delete(m.Payload, k)
    }
}
```

### 3. 压缩

```go
import (
    "bytes"
    "compress/gzip"
    "io"
)

// CompressMessage 压缩消息
func CompressMessage(data []byte) ([]byte, error) {
    var buf bytes.Buffer
    gz := gzip.NewWriter(&buf)

    if _, err := gz.Write(data); err != nil {
        return nil, err
    }

    if err := gz.Close(); err != nil {
        return nil, err
    }

    return buf.Bytes(), nil
}

// DecompressMessage 解压消息
func DecompressMessage(data []byte) ([]byte, error) {
    buf := bytes.NewBuffer(data)
    gz, err := gzip.NewReader(buf)
    if err != nil {
        return nil, err
    }
    defer gz.Close()

    return io.ReadAll(gz)
}
```

---

**相关文档**:

- [游戏开发概览](./02-游戏开发.md)
- [状态同步](./07-状态同步.md)
- [WebSocket基础](../development/web/12-WebSocket.md)

**维护者**: Real-time Communication Team  
**最后更新**: 2025-10-29
