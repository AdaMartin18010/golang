# å®æ—¶é€šä¿¡ç³»ç»Ÿ

> æ¸¸æˆå®æ—¶é€šä¿¡ç³»ç»Ÿè®¾è®¡ä¸å®ç°

**ç‰ˆæœ¬**: v1.0  
**æ›´æ–°æ—¥æœŸ**: 2025-10-29  
**é€‚ç”¨Goç‰ˆæœ¬**: Go 1.25.3+

---

## ğŸ“‹ ç›®å½•

- [ç³»ç»Ÿæ¦‚è¿°](#ç³»ç»Ÿæ¦‚è¿°)
- [WebSocketé€šä¿¡](#websocketé€šä¿¡)
- [æ¶ˆæ¯åè®®è®¾è®¡](#æ¶ˆæ¯åè®®è®¾è®¡)
- [è¿æ¥ç®¡ç†](#è¿æ¥ç®¡ç†)
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)

---

## ç³»ç»Ÿæ¦‚è¿°

### å®æ—¶é€šä¿¡éœ€æ±‚

- âš¡ **ä½å»¶è¿Ÿ**: < 50ms
- ğŸ”„ **åŒå‘é€šä¿¡**: æœåŠ¡å™¨ä¸»åŠ¨æ¨é€
- ğŸ“Š **é«˜å¹¶å‘**: æ”¯æŒç™¾ä¸‡å¹¶å‘è¿æ¥
- ğŸ›¡ï¸ **å¯é æ€§**: æ–­çº¿é‡è¿ã€æ¶ˆæ¯å»é‡

### æŠ€æœ¯é€‰å‹

| æŠ€æœ¯ | ç”¨é€” | ä¼˜åŠ¿ |
|------|------|------|
| WebSocket | å®æ—¶é€šä¿¡ | åŒå‘é€šä¿¡ï¼Œä½å»¶è¿Ÿ |
| Protobuf | åºåˆ—åŒ– | é«˜æ•ˆï¼Œè·¨è¯­è¨€ |
| Redis | æ¶ˆæ¯é˜Ÿåˆ— | é«˜æ€§èƒ½ï¼ŒæŒä¹…åŒ– |

---

## WebSocketé€šä¿¡

### æœåŠ¡å™¨å®ç°

è¯¦è§: [æ¸¸æˆå¼€å‘ - å®æ—¶é€šä¿¡éƒ¨åˆ†](./02-æ¸¸æˆå¼€å‘.md#å®æ—¶é€šä¿¡)

### å®¢æˆ·ç«¯ç¤ºä¾‹

```javascript
// JavaScript WebSocketå®¢æˆ·ç«¯
class GameClient {
    constructor(serverUrl) {
        this.serverUrl = serverUrl;
        this.ws = null;
        this.reconnectInterval = 3000;
        this.messageHandlers = new Map();
    }

    connect() {
        this.ws = new WebSocket(this.serverUrl);

        this.ws.onopen = () => {
            console.log('Connected to server');
            this.onConnect();
        };

        this.ws.onmessage = (event) => {
            const message = JSON.parse(event.data);
            this.handleMessage(message);
        };

        this.ws.onerror = (error) => {
            console.error('WebSocket error:', error);
        };

        this.ws.onclose = () => {
            console.log('Disconnected from server');
            this.reconnect();
        };
    }

    reconnect() {
        setTimeout(() => {
            console.log('Reconnecting...');
            this.connect();
        }, this.reconnectInterval);
    }

    send(type, payload) {
        if (this.ws.readyState === WebSocket.OPEN) {
            const message = {
                type: type,
                payload: payload,
                timestamp: Date.now()
            };
            this.ws.send(JSON.stringify(message));
        }
    }

    handleMessage(message) {
        const handler = this.messageHandlers.get(message.type);
        if (handler) {
            handler(message);
        }
    }

    on(messageType, handler) {
        this.messageHandlers.set(messageType, handler);
    }

    joinRoom(roomId) {
        this.send('join_room', { room_id: roomId });
    }

    sendGameAction(action, data) {
        this.send('game_action', { action, ...data });
    }

    onConnect() {
        // è¿æ¥æˆåŠŸåçš„å¤„ç†
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const client = new GameClient('ws://localhost:8080/ws');
client.connect();

client.on('player_joined', (message) => {
    console.log('Player joined:', message.payload.player_id);
});

client.on('sync', (message) => {
    console.log('State update:', message.payload);
});

client.joinRoom('room-123');
```

---

## æ¶ˆæ¯åè®®è®¾è®¡

### åè®®æ ¼å¼

```proto
syntax = "proto3";

package gameproto;

// æ¶ˆæ¯ç±»å‹
enum MessageType {
    UNKNOWN = 0;
    JOIN_ROOM = 1;
    LEAVE_ROOM = 2;
    GAME_ACTION = 3;
    SYNC = 4;
    CHAT = 5;
}

// é€šç”¨æ¶ˆæ¯
message Message {
    MessageType type = 1;
    string from_client_id = 2;
    string to_client_id = 3;
    string room_id = 4;
    bytes payload = 5;
    int64 timestamp = 6;
}

// åŠ å…¥æˆ¿é—´
message JoinRoomRequest {
    string room_id = 1;
    string user_id = 2;
    string nickname = 3;
}

// æ¸¸æˆåŠ¨ä½œ
message GameAction {
    string action = 1;
    Position position = 2;
    int32 target_id = 3;
    map<string, string> params = 4;
}

// ä½ç½®
message Position {
    double x = 1;
    double y = 2;
    double z = 3;
}

// çŠ¶æ€åŒæ­¥
message StateSync {
    int64 frame_num = 1;
    repeated PlayerState players = 2;
    int64 timestamp = 3;
}

// ç©å®¶çŠ¶æ€
message PlayerState {
    string player_id = 1;
    Position position = 2;
    Velocity velocity = 3;
    int32 health = 4;
    int32 score = 5;
}

// é€Ÿåº¦
message Velocity {
    double x = 1;
    double y = 2;
    double z = 3;
}
```

---

## è¿æ¥ç®¡ç†

### è¿æ¥æ± 

```go
package connection

import (
    "sync"
    "time"

    "github.com/gorilla/websocket"
)

// ConnectionPool è¿æ¥æ± 
type ConnectionPool struct {
    connections map[string]*PooledConnection
    mu          sync.RWMutex
    maxIdle     time.Duration
    maxLifetime time.Duration
}

// NewConnectionPool åˆ›å»ºè¿æ¥æ± 
func NewConnectionPool() *ConnectionPool {
    return &ConnectionPool{
        connections: make(map[string]*PooledConnection),
        maxIdle:     5 * time.Minute,
        maxLifetime: 30 * time.Minute,
    }
}

// PooledConnection æ± åŒ–è¿æ¥
type PooledConnection struct {
    Conn       *websocket.Conn
    LastUsed   time.Time
    Created    time.Time
    InUse      bool
    mu         sync.Mutex
}

// Get è·å–è¿æ¥
func (cp *ConnectionPool) Get(clientID string) (*PooledConnection, bool) {
    cp.mu.RLock()
    defer cp.mu.RUnlock()

    conn, exists := cp.connections[clientID]
    if !exists {
        return nil, false
    }

    conn.mu.Lock()
    defer conn.mu.Unlock()

    // æ£€æŸ¥è¿æ¥æ˜¯å¦æœ‰æ•ˆ
    if time.Since(conn.LastUsed) > cp.maxIdle {
        return nil, false
    }

    if time.Since(conn.Created) > cp.maxLifetime {
        return nil, false
    }

    conn.InUse = true
    conn.LastUsed = time.Now()

    return conn, true
}

// Put æ”¾å›è¿æ¥
func (cp *ConnectionPool) Put(clientID string, conn *PooledConnection) {
    cp.mu.Lock()
    defer cp.mu.Unlock()

    conn.mu.Lock()
    defer conn.mu.Unlock()

    conn.InUse = false
    conn.LastUsed = time.Now()

    cp.connections[clientID] = conn
}

// Remove ç§»é™¤è¿æ¥
func (cp *ConnectionPool) Remove(clientID string) {
    cp.mu.Lock()
    defer cp.mu.Unlock()

    if conn, exists := cp.connections[clientID]; exists {
        conn.Conn.Close()
        delete(cp.connections, clientID)
    }
}

// Cleanup æ¸…ç†è¿‡æœŸè¿æ¥
func (cp *ConnectionPool) Cleanup() {
    cp.mu.Lock()
    defer cp.mu.Unlock()

    now := time.Now()
    for clientID, conn := range cp.connections {
        if !conn.InUse && (now.Sub(conn.LastUsed) > cp.maxIdle || now.Sub(conn.Created) > cp.maxLifetime) {
            conn.Conn.Close()
            delete(cp.connections, clientID)
        }
    }
}
```

### å¿ƒè·³æ£€æµ‹

```go
package heartbeat

import (
    "context"
    "time"

    "github.com/gorilla/websocket"
)

// HeartbeatManager å¿ƒè·³ç®¡ç†å™¨
type HeartbeatManager struct {
    conn           *websocket.Conn
    pingInterval   time.Duration
    pongTimeout    time.Duration
    lastPongTime   time.Time
    disconnectChan chan struct{}
}

// NewHeartbeatManager åˆ›å»ºå¿ƒè·³ç®¡ç†å™¨
func NewHeartbeatManager(conn *websocket.Conn) *HeartbeatManager {
    return &HeartbeatManager{
        conn:           conn,
        pingInterval:   30 * time.Second,
        pongTimeout:    60 * time.Second,
        lastPongTime:   time.Now(),
        disconnectChan: make(chan struct{}),
    }
}

// Start å¯åŠ¨å¿ƒè·³
func (hm *HeartbeatManager) Start(ctx context.Context) {
    // è®¾ç½®pongå¤„ç†å™¨
    hm.conn.SetPongHandler(func(string) error {
        hm.lastPongTime = time.Now()
        return nil
    })

    // å‘é€ping
    pingTicker := time.NewTicker(hm.pingInterval)
    defer pingTicker.Stop()

    // æ£€æŸ¥è¶…æ—¶
    timeoutTicker := time.NewTicker(hm.pongTimeout / 2)
    defer timeoutTicker.Stop()

    for {
        select {
        case <-pingTicker.C:
            if err := hm.sendPing(); err != nil {
                return
            }

        case <-timeoutTicker.C:
            if time.Since(hm.lastPongTime) > hm.pongTimeout {
                close(hm.disconnectChan)
                return
            }

        case <-ctx.Done():
            return

        case <-hm.disconnectChan:
            return
        }
    }
}

func (hm *HeartbeatManager) sendPing() error {
    hm.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
    return hm.conn.WriteMessage(websocket.PingMessage, nil)
}

// DisconnectChan è¿”å›æ–­å¼€è¿æ¥é€šé“
func (hm *HeartbeatManager) DisconnectChan() <-chan struct{} {
    return hm.disconnectChan
}
```

---

## æ€§èƒ½ä¼˜åŒ–

### 1. æ¶ˆæ¯æ‰¹é‡å‘é€

```go
// MessageBatcher æ¶ˆæ¯æ‰¹å¤„ç†å™¨
type MessageBatcher struct {
    messages []*Message
    maxSize  int
    maxWait  time.Duration
    sendFunc func([]*Message)
    mu       sync.Mutex
    timer    *time.Timer
}

func NewMessageBatcher(maxSize int, maxWait time.Duration, sendFunc func([]*Message)) *MessageBatcher {
    mb := &MessageBatcher{
        messages: make([]*Message, 0, maxSize),
        maxSize:  maxSize,
        maxWait:  maxWait,
        sendFunc: sendFunc,
    }
    mb.timer = time.AfterFunc(maxWait, mb.flush)
    return mb
}

func (mb *MessageBatcher) Add(msg *Message) {
    mb.mu.Lock()
    defer mb.mu.Unlock()

    mb.messages = append(mb.messages, msg)

    if len(mb.messages) >= mb.maxSize {
        mb.flush()
    }
}

func (mb *MessageBatcher) flush() {
    mb.mu.Lock()
    defer mb.mu.Unlock()

    if len(mb.messages) == 0 {
        return
    }

    mb.sendFunc(mb.messages)
    mb.messages = mb.messages[:0]

    mb.timer.Reset(mb.maxWait)
}
```

### 2. å¯¹è±¡æ± 

```go
var messagePool = sync.Pool{
    New: func() interface{} {
        return &Message{
            Payload: make(map[string]interface{}),
        }
    },
}

func acquireMessage() *Message {
    return messagePool.Get().(*Message)
}

func releaseMessage(msg *Message) {
    msg.Reset()
    messagePool.Put(msg)
}

func (m *Message) Reset() {
    m.Type = ""
    m.FromClientID = ""
    m.ToClientID = ""
    m.RoomID = ""
    for k := range m.Payload {
        delete(m.Payload, k)
    }
}
```

### 3. å‹ç¼©

```go
import (
    "bytes"
    "compress/gzip"
    "io"
)

// CompressMessage å‹ç¼©æ¶ˆæ¯
func CompressMessage(data []byte) ([]byte, error) {
    var buf bytes.Buffer
    gz := gzip.NewWriter(&buf)

    if _, err := gz.Write(data); err != nil {
        return nil, err
    }

    if err := gz.Close(); err != nil {
        return nil, err
    }

    return buf.Bytes(), nil
}

// DecompressMessage è§£å‹æ¶ˆæ¯
func DecompressMessage(data []byte) ([]byte, error) {
    buf := bytes.NewBuffer(data)
    gz, err := gzip.NewReader(buf)
    if err != nil {
        return nil, err
    }
    defer gz.Close()

    return io.ReadAll(gz)
}
```

---

**ç›¸å…³æ–‡æ¡£**:

- [æ¸¸æˆå¼€å‘æ¦‚è§ˆ](./02-æ¸¸æˆå¼€å‘.md)
- [çŠ¶æ€åŒæ­¥](./07-çŠ¶æ€åŒæ­¥.md)
- [WebSocketåŸºç¡€](../development/web/12-WebSocket.md)

**ç»´æŠ¤è€…**: Real-time Communication Team  
**æœ€åæ›´æ–°**: 2025-10-29
