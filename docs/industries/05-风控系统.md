# 风控系统设计与实现

> Go语言构建智能风控系统完整指南

**版本**: v1.0
**更新日期**: 2025-10-29
**适用Go版本**: Go 1.25.3+

---

## 📋 目录

- [风控系统设计与实现](#风控系统设计与实现)
  - [📋 目录](#-目录)
  - [系统概述](#系统概述)
    - [风控维度](#风控维度)
    - [核心功能](#核心功能)
  - [风控规则引擎](#风控规则引擎)
    - [规则引擎架构](#规则引擎架构)
    - [常用风控规则](#常用风控规则)
      - [1. 金额限制规则](#1-金额限制规则)
      - [2. 频率控制规则](#2-频率控制规则)
      - [3. 设备指纹规则](#3-设备指纹规则)
  - [反欺诈系统](#反欺诈系统)
    - [欺诈检测模型](#欺诈检测模型)
  - [信用评分](#信用评分)
    - [信用评分模型](#信用评分模型)
  - [实时监控](#实时监控)
    - [监控Dashboard](#监控dashboard)
  - [最佳实践](#最佳实践)
    - [1. 规则管理](#1-规则管理)
    - [2. 性能优化](#2-性能优化)
    - [3. 监控告警](#3-监控告警)
    - [4. 数据安全](#4-数据安全)

---

## 系统概述

### 风控维度

```text
┌─────────────────────────────────────────┐
│            风控体系架构                  │
├─────────────────────────────────────────┤
│                                         │
│  ┌──────────┐  ┌──────────┐  ┌────────┐ │
│  │ 事前防控  │  │ 事中监控 │  │事后审计 │ │
│  └─────┬────┘  └────┬─────┘  └───┬────┘ │
│        │            │            │      │
│  ┌─────▼────────────▼────────────▼───┐  │
│  │      规则引擎 + 机器学习模型        │  │
│  └────────────────┬──────────────────┘  │
│                   │                     │
│  ┌────────────────▼──────────────────┐  │
│  │  用户画像 | 行为分析 | 设备指纹     │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

### 核心功能

- 🔍 **实时风控**: 毫秒级风险评估
- 🎯 **精准拦截**: 低误杀率
- 📊 **智能学习**: 自适应规则优化
- 🛡️ **多维防护**: 全方位风险覆盖

---

## 风控规则引擎

### 规则引擎架构

```go
package riskengine

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// RiskEngine 风控引擎
type RiskEngine struct {
    rules       []Rule
    ruleCache   *RuleCache
    scorer      *RiskScorer
    logger      Logger
    metrics     *EngineMetrics
    mu          sync.RWMutex
}

// NewRiskEngine 创建风控引擎
func NewRiskEngine(rules []Rule, logger Logger) *RiskEngine {
    return &RiskEngine{
        rules:     rules,
        ruleCache: NewRuleCache(),
        scorer:    NewRiskScorer(),
        logger:    logger,
        metrics:   NewEngineMetrics(),
    }
}

// Evaluate 风险评估
func (re *RiskEngine) Evaluate(ctx context.Context, req *RiskRequest) (*RiskResponse, error) {
    startTime := time.Now()
    defer func() {
        re.metrics.EvalLatency.Observe(time.Since(startTime).Seconds())
    }()

    // 1. 快速检查黑名单
    if re.isBlacklisted(req.UserID, req.IP, req.DeviceID) {
        return re.rejectResponse("blacklisted"), nil
    }

    // 2. 并发执行规则检查
    results := make(chan *RuleResult, len(re.rules))
    errChan := make(chan error, len(re.rules))

    var wg sync.WaitGroup
    for _, rule := range re.rules {
        wg.Add(1)
        go func(r Rule) {
            defer wg.Done()

            result, err := r.Check(ctx, req)
            if err != nil {
                errChan <- err
                return
            }
            results <- result
        }(rule)
    }

    wg.Wait()
    close(results)
    close(errChan)

    // 3. 收集错误
    for err := range errChan {
        if err != nil {
            re.logger.Error("rule check failed", "error", err)
        }
    }

    // 4. 聚合结果
    response := re.aggregateResults(req, results)

    // 5. 记录审计日志
    re.audit(req, response)

    // 6. 更新指标
    re.metrics.TotalChecks.Inc()
    if !response.Allowed {
        re.metrics.BlockedCount.Inc()
    }

    return response, nil
}

// aggregateResults 聚合规则结果
func (re *RiskEngine) aggregateResults(req *RiskRequest, results chan *RuleResult) *RiskResponse {
    var (
        ruleResults   []*RuleResult
        totalScore    float64
        highestLevel  RiskLevel
        blockedRules  []string
    )

    for result := range results {
        ruleResults = append(ruleResults, result)
        totalScore += result.Score

        if result.Level > highestLevel {
            highestLevel = result.Level
        }

        if result.Action == ActionBlock {
            blockedRules = append(blockedRules, result.RuleName)
        }
    }

    // 计算最终风险分数
    finalScore := re.scorer.Calculate(ruleResults)

    // 决策
    allowed := len(blockedRules) == 0 && finalScore < 80

    return &RiskResponse{
        RequestID:    req.RequestID,
        Allowed:      allowed,
        RiskScore:    finalScore,
        RiskLevel:    highestLevel,
        BlockedRules: blockedRules,
        Details:      ruleResults,
        Timestamp:    time.Now(),
    }
}

// isBlacklisted 检查黑名单
func (re *RiskEngine) isBlacklisted(userID, ip, deviceID string) bool {
    re.mu.RLock()
    defer re.mu.RUnlock()

    // 检查用户黑名单
    if re.ruleCache.IsUserBlacklisted(userID) {
        return true
    }

    // 检查IP黑名单
    if re.ruleCache.IsIPBlacklisted(ip) {
        return true
    }

    // 检查设备黑名单
    if re.ruleCache.IsDeviceBlacklisted(deviceID) {
        return true
    }

    return false
}

func (re *RiskEngine) rejectResponse(reason string) *RiskResponse {
    return &RiskResponse{
        Allowed:   false,
        RiskScore: 100,
        RiskLevel: Critical,
        BlockedRules: []string{reason},
        Timestamp: time.Now(),
    }
}

func (re *RiskEngine) audit(req *RiskRequest, resp *RiskResponse) {
    re.logger.Info("risk check",
        "request_id", req.RequestID,
        "user_id", req.UserID,
        "allowed", resp.Allowed,
        "risk_score", resp.RiskScore,
        "risk_level", resp.RiskLevel,
    )
}

// RiskRequest 风控请求
type RiskRequest struct {
    RequestID   string
    UserID      string
    IP          string
    DeviceID    string
    Amount      float64
    Currency    string
    Action      string
    Timestamp   time.Time
    UserAgent   string
    Location    *Location
    Metadata    map[string]interface{}
}

type Location struct {
    Country string
    City    string
    Lat     float64
    Lng     float64
}

// RiskResponse 风控响应
type RiskResponse struct {
    RequestID    string
    Allowed      bool
    RiskScore    float64
    RiskLevel    RiskLevel
    BlockedRules []string
    Details      []*RuleResult
    Suggestions  []string
    Timestamp    time.Time
}

type RiskLevel int

const (
    Low RiskLevel = iota
    Medium
    High
    Critical
)

func (rl RiskLevel) String() string {
    return [...]string{"Low", "Medium", "High", "Critical"}[rl]
}

// Rule 风控规则接口
type Rule interface {
    Name() string
    Priority() int
    Check(ctx context.Context, req *RiskRequest) (*RuleResult, error)
}

// RuleResult 规则检查结果
type RuleResult struct {
    RuleName string
    Passed   bool
    Score    float64
    Level    RiskLevel
    Action   Action
    Reason   string
    Details  map[string]interface{}
}

type Action int

const (
    ActionAllow Action = iota
    ActionWarn
    ActionBlock
    ActionReview
)

// RiskScorer 风险评分器
type RiskScorer struct {
    weights map[string]float64
}

func NewRiskScorer() *RiskScorer {
    return &RiskScorer{
        weights: map[string]float64{
            "amount":    0.3,
            "frequency": 0.2,
            "device":    0.15,
            "location":  0.15,
            "behavior":  0.2,
        },
    }
}

func (rs *RiskScorer) Calculate(results []*RuleResult) float64 {
    var totalScore float64
    for _, result := range results {
        weight := rs.weights[result.RuleName]
        if weight == 0 {
            weight = 0.1 // 默认权重
        }
        totalScore += result.Score * weight
    }
    return totalScore
}

// RuleCache 规则缓存
type RuleCache struct {
    userBlacklist   map[string]bool
    ipBlacklist     map[string]bool
    deviceBlacklist map[string]bool
    mu              sync.RWMutex
}

func NewRuleCache() *RuleCache {
    return &RuleCache{
        userBlacklist:   make(map[string]bool),
        ipBlacklist:     make(map[string]bool),
        deviceBlacklist: make(map[string]bool),
    }
}

func (rc *RuleCache) IsUserBlacklisted(userID string) bool {
    rc.mu.RLock()
    defer rc.mu.RUnlock()
    return rc.userBlacklist[userID]
}

func (rc *RuleCache) IsIPBlacklisted(ip string) bool {
    rc.mu.RLock()
    defer rc.mu.RUnlock()
    return rc.ipBlacklist[ip]
}

func (rc *RuleCache) IsDeviceBlacklisted(deviceID string) bool {
    rc.mu.RLock()
    defer rc.mu.RUnlock()
    return rc.deviceBlacklist[deviceID]
}

// EngineMetrics 引擎指标
type EngineMetrics struct {
    TotalChecks  Counter
    BlockedCount Counter
    EvalLatency  Histogram
}

func NewEngineMetrics() *EngineMetrics {
    return &EngineMetrics{}
}

type Counter interface {
    Inc()
}

type Histogram interface {
    Observe(value float64)
}

type Logger interface {
    Info(msg string, args ...interface{})
    Error(msg string, args ...interface{})
}
```

### 常用风控规则

#### 1. 金额限制规则

```go
// AmountLimitRule 金额限制规则
type AmountLimitRule struct {
    singleLimit float64
    dailyLimit  float64
    cache       *AmountCache
}

func NewAmountLimitRule(single, daily float64) *AmountLimitRule {
    return &AmountLimitRule{
        singleLimit: single,
        dailyLimit:  daily,
        cache:       NewAmountCache(),
    }
}

func (r *AmountLimitRule) Name() string {
    return "AmountLimit"
}

func (r *AmountLimitRule) Priority() int {
    return 10
}

func (r *AmountLimitRule) Check(ctx context.Context, req *RiskRequest) (*RuleResult, error) {
    // 检查单笔限额
    if req.Amount > r.singleLimit {
        return &RuleResult{
            RuleName: r.Name(),
            Passed:   false,
            Score:    100,
            Level:    High,
            Action:   ActionBlock,
            Reason:   fmt.Sprintf("amount %.2f exceeds single limit %.2f", req.Amount, r.singleLimit),
        }, nil
    }

    // 检查日累计限额
    todayAmount := r.cache.GetTodayAmount(req.UserID)
    newTotal := todayAmount + req.Amount

    if newTotal > r.dailyLimit {
        return &RuleResult{
            RuleName: r.Name(),
            Passed:   false,
            Score:    90,
            Level:    High,
            Action:   ActionBlock,
            Reason:   fmt.Sprintf("daily total %.2f exceeds limit %.2f", newTotal, r.dailyLimit),
        }, nil
    }

    // 更新缓存
    r.cache.AddAmount(req.UserID, req.Amount)

    // 计算风险分数
    score := (newTotal / r.dailyLimit) * 100

    return &RuleResult{
        RuleName: r.Name(),
        Passed:   true,
        Score:    score,
        Level:    r.calculateLevel(score),
        Action:   ActionAllow,
    }, nil
}

func (r *AmountLimitRule) calculateLevel(score float64) RiskLevel {
    switch {
    case score >= 90:
        return High
    case score >= 70:
        return Medium
    default:
        return Low
    }
}

type AmountCache struct {
    data map[string]float64
    mu   sync.RWMutex
}

func NewAmountCache() *AmountCache {
    return &AmountCache{
        data: make(map[string]float64),
    }
}

func (ac *AmountCache) GetTodayAmount(userID string) float64 {
    ac.mu.RLock()
    defer ac.mu.RUnlock()
    return ac.data[userID]
}

func (ac *AmountCache) AddAmount(userID string, amount float64) {
    ac.mu.Lock()
    defer ac.mu.Unlock()
    ac.data[userID] += amount
}
```

#### 2. 频率控制规则

```go
// FrequencyRule 频率控制规则
type FrequencyRule struct {
    maxRequests int
    window      time.Duration
    cache       *FrequencyCache
}

func NewFrequencyRule(maxReq int, window time.Duration) *FrequencyRule {
    return &FrequencyRule{
        maxRequests: maxReq,
        window:      window,
        cache:       NewFrequencyCache(),
    }
}

func (r *FrequencyRule) Name() string {
    return "Frequency"
}

func (r *FrequencyRule) Priority() int {
    return 9
}

func (r *FrequencyRule) Check(ctx context.Context, req *RiskRequest) (*RuleResult, error) {
    count := r.cache.GetCount(req.UserID, r.window)
    count++ // 包含当前请求

    if count > r.maxRequests {
        return &RuleResult{
            RuleName: r.Name(),
            Passed:   false,
            Score:    100,
            Level:    Critical,
            Action:   ActionBlock,
            Reason:   fmt.Sprintf("frequency %d exceeds limit %d in %v", count, r.maxRequests, r.window),
        }, nil
    }

    r.cache.Increment(req.UserID)

    score := float64(count) / float64(r.maxRequests) * 100

    return &RuleResult{
        RuleName: r.Name(),
        Passed:   true,
        Score:    score,
        Level:    r.calculateLevel(score),
        Action:   ActionAllow,
    }, nil
}

func (r *FrequencyRule) calculateLevel(score float64) RiskLevel {
    switch {
    case score >= 80:
        return High
    case score >= 60:
        return Medium
    default:
        return Low
    }
}

type FrequencyCache struct {
    data map[string][]time.Time
    mu   sync.RWMutex
}

func NewFrequencyCache() *FrequencyCache {
    return &FrequencyCache{
        data: make(map[string][]time.Time),
    }
}

func (fc *FrequencyCache) GetCount(userID string, window time.Duration) int {
    fc.mu.RLock()
    defer fc.mu.RUnlock()

    timestamps := fc.data[userID]
    if len(timestamps) == 0 {
        return 0
    }

    cutoff := time.Now().Add(-window)
    count := 0
    for _, ts := range timestamps {
        if ts.After(cutoff) {
            count++
        }
    }

    return count
}

func (fc *FrequencyCache) Increment(userID string) {
    fc.mu.Lock()
    defer fc.mu.Unlock()

    fc.data[userID] = append(fc.data[userID], time.Now())

    // 清理过期数据
    if len(fc.data[userID]) > 1000 {
        fc.data[userID] = fc.data[userID][len(fc.data[userID])-100:]
    }
}
```

#### 3. 设备指纹规则

```go
// DeviceFingerprintRule 设备指纹规则
type DeviceFingerprintRule struct {
    maxDevicesPerUser int
    cache             *DeviceCache
}

func NewDeviceFingerprintRule(maxDevices int) *DeviceFingerprintRule {
    return &DeviceFingerprintRule{
        maxDevicesPerUser: maxDevices,
        cache:             NewDeviceCache(),
    }
}

func (r *DeviceFingerprintRule) Name() string {
    return "DeviceFingerprint"
}

func (r *DeviceFingerprintRule) Priority() int {
    return 8
}

func (r *DeviceFingerprintRule) Check(ctx context.Context, req *RiskRequest) (*RuleResult, error) {
    // 记录设备
    r.cache.AddDevice(req.UserID, req.DeviceID)

    // 检查设备数量
    deviceCount := r.cache.GetDeviceCount(req.UserID)

    if deviceCount > r.maxDevicesPerUser {
        return &RuleResult{
            RuleName: r.Name(),
            Passed:   false,
            Score:    80,
            Level:    High,
            Action:   ActionReview,
            Reason:   fmt.Sprintf("user has %d devices, limit is %d", deviceCount, r.maxDevicesPerUser),
            Details: map[string]interface{}{
                "device_count": deviceCount,
                "device_id":    req.DeviceID,
            },
        }, nil
    }

    // 检查设备是否是新设备
    isNew := r.cache.IsNewDevice(req.UserID, req.DeviceID)
    score := 30.0
    if isNew {
        score = 60.0
    }

    return &RuleResult{
        RuleName: r.Name(),
        Passed:   true,
        Score:    score,
        Level:    Medium,
        Action:   ActionAllow,
        Details: map[string]interface{}{
            "is_new_device":  isNew,
            "device_count":   deviceCount,
        },
    }, nil
}

type DeviceCache struct {
    userDevices map[string]map[string]time.Time // userID -> deviceID -> firstSeen
    mu          sync.RWMutex
}

func NewDeviceCache() *DeviceCache {
    return &DeviceCache{
        userDevices: make(map[string]map[string]time.Time),
    }
}

func (dc *DeviceCache) AddDevice(userID, deviceID string) {
    dc.mu.Lock()
    defer dc.mu.Unlock()

    if dc.userDevices[userID] == nil {
        dc.userDevices[userID] = make(map[string]time.Time)
    }

    if _, exists := dc.userDevices[userID][deviceID]; !exists {
        dc.userDevices[userID][deviceID] = time.Now()
    }
}

func (dc *DeviceCache) GetDeviceCount(userID string) int {
    dc.mu.RLock()
    defer dc.mu.RUnlock()
    return len(dc.userDevices[userID])
}

func (dc *DeviceCache) IsNewDevice(userID, deviceID string) bool {
    dc.mu.RLock()
    defer dc.mu.RUnlock()

    devices := dc.userDevices[userID]
    if devices == nil {
        return true
    }

    firstSeen, exists := devices[deviceID]
    if !exists {
        return true
    }

    // 如果设备首次出现在24小时内，认为是新设备
    return time.Since(firstSeen) < 24*time.Hour
}
```

---

## 反欺诈系统

### 欺诈检测模型

```go
package antifraud

import (
    "context"
    "math"
)

// FraudDetector 欺诈检测器
type FraudDetector struct {
    models    []DetectionModel
    threshold float64
}

// DetectionModel 检测模型接口
type DetectionModel interface {
    Name() string
    Predict(ctx context.Context, features *Features) (float64, error)
}

// Features 特征
type Features struct {
    UserFeatures     *UserFeatures
    TransactionFeatures *TransactionFeatures
    BehaviorFeatures *BehaviorFeatures
    DeviceFeatures   *DeviceFeatures
}

// UserFeatures 用户特征
type UserFeatures struct {
    AccountAge       int     // 账户年龄(天)
    TotalTransactions int     // 历史交易数
    AvgTransAmount   float64 // 平均交易金额
    CreditScore      float64 // 信用分
    IsVerified       bool    // 是否实名认证
}

// TransactionFeatures 交易特征
type TransactionFeatures struct {
    Amount            float64 // 交易金额
    Currency          string  // 币种
    IsLargeAmount     bool    // 是否大额
    TimeOfDay         int     // 交易时段
    IsWeekend         bool    // 是否周末
    DestinationCountry string  // 目的地国家
}

// BehaviorFeatures 行为特征
type BehaviorFeatures struct {
    LoginFrequency    float64 // 登录频率
    TransFrequency    float64 // 交易频率
    TypingSpeed       float64 // 打字速度
    MouseMovements    int     // 鼠标移动次数
    SessionDuration   int     // 会话时长
}

// DeviceFeatures 设备特征
type DeviceFeatures struct {
    DeviceID       string
    DeviceType     string
    OS             string
    Browser        string
    IsVPN          bool
    IsProxy        bool
    LocationChange bool // 位置是否变化
}

// Detect 欺诈检测
func (fd *FraudDetector) Detect(ctx context.Context, features *Features) (*FraudResult, error) {
    scores := make([]float64, len(fd.models))

    // 并发执行所有模型
    for i, model := range fd.models {
        score, err := model.Predict(ctx, features)
        if err != nil {
            return nil, err
        }
        scores[i] = score
    }

    // 集成多个模型的预测结果
    finalScore := fd.ensembleScores(scores)

    isFraud := finalScore >= fd.threshold

    return &FraudResult{
        IsFraud:    isFraud,
        Score:      finalScore,
        Confidence: fd.calculateConfidence(scores),
        Models:     fd.getModelScores(scores),
    }, nil
}

// ensembleScores 集成多个模型分数
func (fd *FraudDetector) ensembleScores(scores []float64) float64 {
    // 使用加权平均
    weights := []float64{0.3, 0.3, 0.2, 0.2}

    var weightedSum float64
    for i, score := range scores {
        weightedSum += score * weights[i]
    }

    return weightedSum
}

func (fd *FraudDetector) calculateConfidence(scores []float64) float64 {
    // 计算标准差作为置信度的逆指标
    mean := fd.ensembleScores(scores)

    var variance float64
    for _, score := range scores {
        variance += math.Pow(score-mean, 2)
    }
    variance /= float64(len(scores))

    stdDev := math.Sqrt(variance)

    // 标准差越小，置信度越高
    confidence := 1.0 - (stdDev / 100.0)
    if confidence < 0 {
        confidence = 0
    }

    return confidence
}

func (fd *FraudDetector) getModelScores(scores []float64) map[string]float64 {
    result := make(map[string]float64)
    for i, model := range fd.models {
        result[model.Name()] = scores[i]
    }
    return result
}

// FraudResult 欺诈检测结果
type FraudResult struct {
    IsFraud    bool
    Score      float64
    Confidence float64
    Models     map[string]float64
}
```

---

## 信用评分

### 信用评分模型

```go
package creditscore

// CreditScorer 信用评分器
type CreditScorer struct {
    weights map[string]float64
}

func NewCreditScorer() *CreditScorer {
    return &CreditScorer{
        weights: map[string]float64{
            "payment_history":    0.35,
            "credit_utilization": 0.30,
            "credit_age":         0.15,
            "credit_mix":         0.10,
            "new_credit":         0.10,
        },
    }
}

// Calculate 计算信用分
func (cs *CreditScorer) Calculate(profile *CreditProfile) float64 {
    score := 0.0

    // 支付历史
    score += cs.scorePaymentHistory(profile) * cs.weights["payment_history"]

    // 信用使用率
    score += cs.scoreCreditUtilization(profile) * cs.weights["credit_utilization"]

    // 信用年龄
    score += cs.scoreCreditAge(profile) * cs.weights["credit_age"]

    // 信用组合
    score += cs.scoreCreditMix(profile) * cs.weights["credit_mix"]

    // 新信用
    score += cs.scoreNewCredit(profile) * cs.weights["new_credit"]

    // 归一化到300-850分
    finalScore := 300 + score*5.5

    return finalScore
}

type CreditProfile struct {
    OnTimePayments    int
    LatePayments      int
    TotalCreditLimit  float64
    UsedCredit        float64
    AccountAgeDays    int
    NumberOfAccounts  int
    RecentInquiries   int
}

func (cs *CreditScorer) scorePaymentHistory(profile *CreditProfile) float64 {
    total := profile.OnTimePayments + profile.LatePayments
    if total == 0 {
        return 50.0 // 默认中等分数
    }

    ratio := float64(profile.OnTimePayments) / float64(total)
    return ratio * 100
}

func (cs *CreditScorer) scoreCreditUtilization(profile *CreditProfile) float64 {
    if profile.TotalCreditLimit == 0 {
        return 50.0
    }

    utilization := profile.UsedCredit / profile.TotalCreditLimit

    // 最佳使用率是10-30%
    switch {
    case utilization <= 0.10:
        return 90.0
    case utilization <= 0.30:
        return 100.0
    case utilization <= 0.50:
        return 70.0
    case utilization <= 0.75:
        return 40.0
    default:
        return 10.0
    }
}

func (cs *CreditScorer) scoreCreditAge(profile *CreditProfile) float64 {
    years := float64(profile.AccountAgeDays) / 365.0

    switch {
    case years >= 7:
        return 100.0
    case years >= 5:
        return 85.0
    case years >= 3:
        return 70.0
    case years >= 1:
        return 50.0
    default:
        return 30.0
    }
}

func (cs *CreditScorer) scoreCreditMix(profile *CreditProfile) float64 {
    // 账户多样性越高分数越高
    switch {
    case profile.NumberOfAccounts >= 10:
        return 100.0
    case profile.NumberOfAccounts >= 5:
        return 80.0
    case profile.NumberOfAccounts >= 3:
        return 60.0
    case profile.NumberOfAccounts >= 1:
        return 40.0
    default:
        return 0.0
    }
}

func (cs *CreditScorer) scoreNewCredit(profile *CreditProfile) float64 {
    // 最近查询次数越少越好
    switch {
    case profile.RecentInquiries == 0:
        return 100.0
    case profile.RecentInquiries <= 2:
        return 80.0
    case profile.RecentInquiries <= 5:
        return 50.0
    default:
        return 20.0
    }
}
```

---

## 实时监控

### 监控Dashboard

```go
package monitoring

import (
    "time"

    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    // 风控检查总数
    riskChecksTotal = promauto.NewCounter(prometheus.CounterOpts{
        Name: "risk_checks_total",
        Help: "Total number of risk checks",
    })

    // 拦截数量
    blockedTotal = promauto.NewCounterVec(prometheus.CounterOpts{
        Name: "risk_blocked_total",
        Help: "Total number of blocked requests",
    }, []string{"reason"})

    // 风险分数分布
    riskScoreDistribution = promauto.NewHistogram(prometheus.HistogramOpts{
        Name:    "risk_score_distribution",
        Help:    "Distribution of risk scores",
        Buckets: []float64{0, 20, 40, 60, 80, 100},
    })

    // 检查延迟
    riskCheckLatency = promauto.NewHistogram(prometheus.HistogramOpts{
        Name:    "risk_check_latency_seconds",
        Help:    "Risk check latency in seconds",
        Buckets: prometheus.DefBuckets,
    })

    // 规则执行时间
    ruleExecutionTime = promauto.NewHistogramVec(prometheus.HistogramOpts{
        Name:    "rule_execution_time_seconds",
        Help:    "Rule execution time in seconds",
        Buckets: prometheus.DefBuckets,
    }, []string{"rule_name"})
)

// RecordCheck 记录检查
func RecordCheck(score float64, blocked bool, reason string, latency time.Duration) {
    riskChecksTotal.Inc()
    riskScoreDistribution.Observe(score)
    riskCheckLatency.Observe(latency.Seconds())

    if blocked {
        blockedTotal.WithLabelValues(reason).Inc()
    }
}

// RecordRuleExecution 记录规则执行
func RecordRuleExecution(ruleName string, duration time.Duration) {
    ruleExecutionTime.WithLabelValues(ruleName).Observe(duration.Seconds())
}
```

---

## 最佳实践

### 1. 规则管理

- ✅ 规则版本控制
- ✅ 灰度发布新规则
- ✅ A/B测试规则效果
- ✅ 定期审查和优化规则

### 2. 性能优化

- ✅ 规则并发执行
- ✅ 结果缓存
- ✅ 异步处理非关键规则
- ✅ 数据预加载

### 3. 监控告警

- ✅ 实时监控风控指标
- ✅ 异常告警
- ✅ 定期风控报告
- ✅ 误杀率跟踪

### 4. 数据安全

- ✅ 敏感数据加密
- ✅ 审计日志
- ✅ 访问控制
- ✅ 合规性检查

---

**相关文档**:

- [金融科技概览](./01-金融科技-FinTech.md)
- [高并发交易系统](./04-高并发交易系统.md)
- [机器学习集成](../advanced/33-Go-1.25.3AI与机器学习集成完整实战.md)

**维护者**: Risk Control Team
**最后更新**: 2025-10-29
