# é£æ§ç³»ç»Ÿè®¾è®¡ä¸å®ç°

> Goè¯­è¨€æ„å»ºæ™ºèƒ½é£æ§ç³»ç»Ÿå®Œæ•´æŒ‡å—

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨Goç‰ˆæœ¬**: Go 1.25.3+

---

## ğŸ“‹ ç›®å½•

- [é£æ§ç³»ç»Ÿè®¾è®¡ä¸å®ç°](#é£æ§ç³»ç»Ÿè®¾è®¡ä¸å®ç°)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ç³»ç»Ÿæ¦‚è¿°](#ç³»ç»Ÿæ¦‚è¿°)
    - [é£æ§ç»´åº¦](#é£æ§ç»´åº¦)
    - [æ ¸å¿ƒåŠŸèƒ½](#æ ¸å¿ƒåŠŸèƒ½)
  - [é£æ§è§„åˆ™å¼•æ“](#é£æ§è§„åˆ™å¼•æ“)
    - [è§„åˆ™å¼•æ“æ¶æ„](#è§„åˆ™å¼•æ“æ¶æ„)
    - [å¸¸ç”¨é£æ§è§„åˆ™](#å¸¸ç”¨é£æ§è§„åˆ™)
      - [1. é‡‘é¢é™åˆ¶è§„åˆ™](#1-é‡‘é¢é™åˆ¶è§„åˆ™)
      - [2. é¢‘ç‡æ§åˆ¶è§„åˆ™](#2-é¢‘ç‡æ§åˆ¶è§„åˆ™)
      - [3. è®¾å¤‡æŒ‡çº¹è§„åˆ™](#3-è®¾å¤‡æŒ‡çº¹è§„åˆ™)
  - [åæ¬ºè¯ˆç³»ç»Ÿ](#åæ¬ºè¯ˆç³»ç»Ÿ)
    - [æ¬ºè¯ˆæ£€æµ‹æ¨¡å‹](#æ¬ºè¯ˆæ£€æµ‹æ¨¡å‹)
  - [ä¿¡ç”¨è¯„åˆ†](#ä¿¡ç”¨è¯„åˆ†)
    - [ä¿¡ç”¨è¯„åˆ†æ¨¡å‹](#ä¿¡ç”¨è¯„åˆ†æ¨¡å‹)
  - [å®æ—¶ç›‘æ§](#å®æ—¶ç›‘æ§)
    - [ç›‘æ§Dashboard](#ç›‘æ§dashboard)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [1. è§„åˆ™ç®¡ç†](#1-è§„åˆ™ç®¡ç†)
    - [2. æ€§èƒ½ä¼˜åŒ–](#2-æ€§èƒ½ä¼˜åŒ–)
    - [3. ç›‘æ§å‘Šè­¦](#3-ç›‘æ§å‘Šè­¦)
    - [4. æ•°æ®å®‰å…¨](#4-æ•°æ®å®‰å…¨)

---

## ç³»ç»Ÿæ¦‚è¿°

### é£æ§ç»´åº¦

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            é£æ§ä½“ç³»æ¶æ„                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ äº‹å‰é˜²æ§  â”‚  â”‚ äº‹ä¸­ç›‘æ§ â”‚  â”‚äº‹åå®¡è®¡ â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â”‚
â”‚        â”‚            â”‚            â”‚      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”  â”‚
â”‚  â”‚      è§„åˆ™å¼•æ“ + æœºå™¨å­¦ä¹ æ¨¡å‹        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                   â”‚                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  ç”¨æˆ·ç”»åƒ | è¡Œä¸ºåˆ†æ | è®¾å¤‡æŒ‡çº¹     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒåŠŸèƒ½

- ğŸ” **å®æ—¶é£æ§**: æ¯«ç§’çº§é£é™©è¯„ä¼°
- ğŸ¯ **ç²¾å‡†æ‹¦æˆª**: ä½è¯¯æ€ç‡
- ğŸ“Š **æ™ºèƒ½å­¦ä¹ **: è‡ªé€‚åº”è§„åˆ™ä¼˜åŒ–
- ğŸ›¡ï¸ **å¤šç»´é˜²æŠ¤**: å…¨æ–¹ä½é£é™©è¦†ç›–

---

## é£æ§è§„åˆ™å¼•æ“

### è§„åˆ™å¼•æ“æ¶æ„

```go
package riskengine

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// RiskEngine é£æ§å¼•æ“
type RiskEngine struct {
    rules       []Rule
    ruleCache   *RuleCache
    scorer      *RiskScorer
    logger      Logger
    metrics     *EngineMetrics
    mu          sync.RWMutex
}

// NewRiskEngine åˆ›å»ºé£æ§å¼•æ“
func NewRiskEngine(rules []Rule, logger Logger) *RiskEngine {
    return &RiskEngine{
        rules:     rules,
        ruleCache: NewRuleCache(),
        scorer:    NewRiskScorer(),
        logger:    logger,
        metrics:   NewEngineMetrics(),
    }
}

// Evaluate é£é™©è¯„ä¼°
func (re *RiskEngine) Evaluate(ctx context.Context, req *RiskRequest) (*RiskResponse, error) {
    startTime := time.Now()
    defer func() {
        re.metrics.EvalLatency.Observe(time.Since(startTime).Seconds())
    }()

    // 1. å¿«é€Ÿæ£€æŸ¥é»‘åå•
    if re.isBlacklisted(req.UserID, req.IP, req.DeviceID) {
        return re.rejectResponse("blacklisted"), nil
    }

    // 2. å¹¶å‘æ‰§è¡Œè§„åˆ™æ£€æŸ¥
    results := make(chan *RuleResult, len(re.rules))
    errChan := make(chan error, len(re.rules))

    var wg sync.WaitGroup
    for _, rule := range re.rules {
        wg.Add(1)
        go func(r Rule) {
            defer wg.Done()

            result, err := r.Check(ctx, req)
            if err != nil {
                errChan <- err
                return
            }
            results <- result
        }(rule)
    }

    wg.Wait()
    close(results)
    close(errChan)

    // 3. æ”¶é›†é”™è¯¯
    for err := range errChan {
        if err != nil {
            re.logger.Error("rule check failed", "error", err)
        }
    }

    // 4. èšåˆç»“æœ
    response := re.aggregateResults(req, results)

    // 5. è®°å½•å®¡è®¡æ—¥å¿—
    re.audit(req, response)

    // 6. æ›´æ–°æŒ‡æ ‡
    re.metrics.TotalChecks.Inc()
    if !response.Allowed {
        re.metrics.BlockedCount.Inc()
    }

    return response, nil
}

// aggregateResults èšåˆè§„åˆ™ç»“æœ
func (re *RiskEngine) aggregateResults(req *RiskRequest, results chan *RuleResult) *RiskResponse {
    var (
        ruleResults   []*RuleResult
        totalScore    float64
        highestLevel  RiskLevel
        blockedRules  []string
    )

    for result := range results {
        ruleResults = append(ruleResults, result)
        totalScore += result.Score

        if result.Level > highestLevel {
            highestLevel = result.Level
        }

        if result.Action == ActionBlock {
            blockedRules = append(blockedRules, result.RuleName)
        }
    }

    // è®¡ç®—æœ€ç»ˆé£é™©åˆ†æ•°
    finalScore := re.scorer.Calculate(ruleResults)

    // å†³ç­–
    allowed := len(blockedRules) == 0 && finalScore < 80

    return &RiskResponse{
        RequestID:    req.RequestID,
        Allowed:      allowed,
        RiskScore:    finalScore,
        RiskLevel:    highestLevel,
        BlockedRules: blockedRules,
        Details:      ruleResults,
        Timestamp:    time.Now(),
    }
}

// isBlacklisted æ£€æŸ¥é»‘åå•
func (re *RiskEngine) isBlacklisted(userID, ip, deviceID string) bool {
    re.mu.RLock()
    defer re.mu.RUnlock()

    // æ£€æŸ¥ç”¨æˆ·é»‘åå•
    if re.ruleCache.IsUserBlacklisted(userID) {
        return true
    }

    // æ£€æŸ¥IPé»‘åå•
    if re.ruleCache.IsIPBlacklisted(ip) {
        return true
    }

    // æ£€æŸ¥è®¾å¤‡é»‘åå•
    if re.ruleCache.IsDeviceBlacklisted(deviceID) {
        return true
    }

    return false
}

func (re *RiskEngine) rejectResponse(reason string) *RiskResponse {
    return &RiskResponse{
        Allowed:   false,
        RiskScore: 100,
        RiskLevel: Critical,
        BlockedRules: []string{reason},
        Timestamp: time.Now(),
    }
}

func (re *RiskEngine) audit(req *RiskRequest, resp *RiskResponse) {
    re.logger.Info("risk check",
        "request_id", req.RequestID,
        "user_id", req.UserID,
        "allowed", resp.Allowed,
        "risk_score", resp.RiskScore,
        "risk_level", resp.RiskLevel,
    )
}

// RiskRequest é£æ§è¯·æ±‚
type RiskRequest struct {
    RequestID   string
    UserID      string
    IP          string
    DeviceID    string
    Amount      float64
    Currency    string
    Action      string
    Timestamp   time.Time
    UserAgent   string
    Location    *Location
    Metadata    map[string]interface{}
}

type Location struct {
    Country string
    City    string
    Lat     float64
    Lng     float64
}

// RiskResponse é£æ§å“åº”
type RiskResponse struct {
    RequestID    string
    Allowed      bool
    RiskScore    float64
    RiskLevel    RiskLevel
    BlockedRules []string
    Details      []*RuleResult
    Suggestions  []string
    Timestamp    time.Time
}

type RiskLevel int

const (
    Low RiskLevel = iota
    Medium
    High
    Critical
)

func (rl RiskLevel) String() string {
    return [...]string{"Low", "Medium", "High", "Critical"}[rl]
}

// Rule é£æ§è§„åˆ™æ¥å£
type Rule interface {
    Name() string
    Priority() int
    Check(ctx context.Context, req *RiskRequest) (*RuleResult, error)
}

// RuleResult è§„åˆ™æ£€æŸ¥ç»“æœ
type RuleResult struct {
    RuleName string
    Passed   bool
    Score    float64
    Level    RiskLevel
    Action   Action
    Reason   string
    Details  map[string]interface{}
}

type Action int

const (
    ActionAllow Action = iota
    ActionWarn
    ActionBlock
    ActionReview
)

// RiskScorer é£é™©è¯„åˆ†å™¨
type RiskScorer struct {
    weights map[string]float64
}

func NewRiskScorer() *RiskScorer {
    return &RiskScorer{
        weights: map[string]float64{
            "amount":    0.3,
            "frequency": 0.2,
            "device":    0.15,
            "location":  0.15,
            "behavior":  0.2,
        },
    }
}

func (rs *RiskScorer) Calculate(results []*RuleResult) float64 {
    var totalScore float64
    for _, result := range results {
        weight := rs.weights[result.RuleName]
        if weight == 0 {
            weight = 0.1 // é»˜è®¤æƒé‡
        }
        totalScore += result.Score * weight
    }
    return totalScore
}

// RuleCache è§„åˆ™ç¼“å­˜
type RuleCache struct {
    userBlacklist   map[string]bool
    ipBlacklist     map[string]bool
    deviceBlacklist map[string]bool
    mu              sync.RWMutex
}

func NewRuleCache() *RuleCache {
    return &RuleCache{
        userBlacklist:   make(map[string]bool),
        ipBlacklist:     make(map[string]bool),
        deviceBlacklist: make(map[string]bool),
    }
}

func (rc *RuleCache) IsUserBlacklisted(userID string) bool {
    rc.mu.RLock()
    defer rc.mu.RUnlock()
    return rc.userBlacklist[userID]
}

func (rc *RuleCache) IsIPBlacklisted(ip string) bool {
    rc.mu.RLock()
    defer rc.mu.RUnlock()
    return rc.ipBlacklist[ip]
}

func (rc *RuleCache) IsDeviceBlacklisted(deviceID string) bool {
    rc.mu.RLock()
    defer rc.mu.RUnlock()
    return rc.deviceBlacklist[deviceID]
}

// EngineMetrics å¼•æ“æŒ‡æ ‡
type EngineMetrics struct {
    TotalChecks  Counter
    BlockedCount Counter
    EvalLatency  Histogram
}

func NewEngineMetrics() *EngineMetrics {
    return &EngineMetrics{}
}

type Counter interface {
    Inc()
}

type Histogram interface {
    Observe(value float64)
}

type Logger interface {
    Info(msg string, args ...interface{})
    Error(msg string, args ...interface{})
}
```

### å¸¸ç”¨é£æ§è§„åˆ™

#### 1. é‡‘é¢é™åˆ¶è§„åˆ™

```go
// AmountLimitRule é‡‘é¢é™åˆ¶è§„åˆ™
type AmountLimitRule struct {
    singleLimit float64
    dailyLimit  float64
    cache       *AmountCache
}

func NewAmountLimitRule(single, daily float64) *AmountLimitRule {
    return &AmountLimitRule{
        singleLimit: single,
        dailyLimit:  daily,
        cache:       NewAmountCache(),
    }
}

func (r *AmountLimitRule) Name() string {
    return "AmountLimit"
}

func (r *AmountLimitRule) Priority() int {
    return 10
}

func (r *AmountLimitRule) Check(ctx context.Context, req *RiskRequest) (*RuleResult, error) {
    // æ£€æŸ¥å•ç¬”é™é¢
    if req.Amount > r.singleLimit {
        return &RuleResult{
            RuleName: r.Name(),
            Passed:   false,
            Score:    100,
            Level:    High,
            Action:   ActionBlock,
            Reason:   fmt.Sprintf("amount %.2f exceeds single limit %.2f", req.Amount, r.singleLimit),
        }, nil
    }

    // æ£€æŸ¥æ—¥ç´¯è®¡é™é¢
    todayAmount := r.cache.GetTodayAmount(req.UserID)
    newTotal := todayAmount + req.Amount

    if newTotal > r.dailyLimit {
        return &RuleResult{
            RuleName: r.Name(),
            Passed:   false,
            Score:    90,
            Level:    High,
            Action:   ActionBlock,
            Reason:   fmt.Sprintf("daily total %.2f exceeds limit %.2f", newTotal, r.dailyLimit),
        }, nil
    }

    // æ›´æ–°ç¼“å­˜
    r.cache.AddAmount(req.UserID, req.Amount)

    // è®¡ç®—é£é™©åˆ†æ•°
    score := (newTotal / r.dailyLimit) * 100

    return &RuleResult{
        RuleName: r.Name(),
        Passed:   true,
        Score:    score,
        Level:    r.calculateLevel(score),
        Action:   ActionAllow,
    }, nil
}

func (r *AmountLimitRule) calculateLevel(score float64) RiskLevel {
    switch {
    case score >= 90:
        return High
    case score >= 70:
        return Medium
    default:
        return Low
    }
}

type AmountCache struct {
    data map[string]float64
    mu   sync.RWMutex
}

func NewAmountCache() *AmountCache {
    return &AmountCache{
        data: make(map[string]float64),
    }
}

func (ac *AmountCache) GetTodayAmount(userID string) float64 {
    ac.mu.RLock()
    defer ac.mu.RUnlock()
    return ac.data[userID]
}

func (ac *AmountCache) AddAmount(userID string, amount float64) {
    ac.mu.Lock()
    defer ac.mu.Unlock()
    ac.data[userID] += amount
}
```

#### 2. é¢‘ç‡æ§åˆ¶è§„åˆ™

```go
// FrequencyRule é¢‘ç‡æ§åˆ¶è§„åˆ™
type FrequencyRule struct {
    maxRequests int
    window      time.Duration
    cache       *FrequencyCache
}

func NewFrequencyRule(maxReq int, window time.Duration) *FrequencyRule {
    return &FrequencyRule{
        maxRequests: maxReq,
        window:      window,
        cache:       NewFrequencyCache(),
    }
}

func (r *FrequencyRule) Name() string {
    return "Frequency"
}

func (r *FrequencyRule) Priority() int {
    return 9
}

func (r *FrequencyRule) Check(ctx context.Context, req *RiskRequest) (*RuleResult, error) {
    count := r.cache.GetCount(req.UserID, r.window)
    count++ // åŒ…å«å½“å‰è¯·æ±‚

    if count > r.maxRequests {
        return &RuleResult{
            RuleName: r.Name(),
            Passed:   false,
            Score:    100,
            Level:    Critical,
            Action:   ActionBlock,
            Reason:   fmt.Sprintf("frequency %d exceeds limit %d in %v", count, r.maxRequests, r.window),
        }, nil
    }

    r.cache.Increment(req.UserID)

    score := float64(count) / float64(r.maxRequests) * 100

    return &RuleResult{
        RuleName: r.Name(),
        Passed:   true,
        Score:    score,
        Level:    r.calculateLevel(score),
        Action:   ActionAllow,
    }, nil
}

func (r *FrequencyRule) calculateLevel(score float64) RiskLevel {
    switch {
    case score >= 80:
        return High
    case score >= 60:
        return Medium
    default:
        return Low
    }
}

type FrequencyCache struct {
    data map[string][]time.Time
    mu   sync.RWMutex
}

func NewFrequencyCache() *FrequencyCache {
    return &FrequencyCache{
        data: make(map[string][]time.Time),
    }
}

func (fc *FrequencyCache) GetCount(userID string, window time.Duration) int {
    fc.mu.RLock()
    defer fc.mu.RUnlock()

    timestamps := fc.data[userID]
    if len(timestamps) == 0 {
        return 0
    }

    cutoff := time.Now().Add(-window)
    count := 0
    for _, ts := range timestamps {
        if ts.After(cutoff) {
            count++
        }
    }

    return count
}

func (fc *FrequencyCache) Increment(userID string) {
    fc.mu.Lock()
    defer fc.mu.Unlock()

    fc.data[userID] = append(fc.data[userID], time.Now())

    // æ¸…ç†è¿‡æœŸæ•°æ®
    if len(fc.data[userID]) > 1000 {
        fc.data[userID] = fc.data[userID][len(fc.data[userID])-100:]
    }
}
```

#### 3. è®¾å¤‡æŒ‡çº¹è§„åˆ™

```go
// DeviceFingerprintRule è®¾å¤‡æŒ‡çº¹è§„åˆ™
type DeviceFingerprintRule struct {
    maxDevicesPerUser int
    cache             *DeviceCache
}

func NewDeviceFingerprintRule(maxDevices int) *DeviceFingerprintRule {
    return &DeviceFingerprintRule{
        maxDevicesPerUser: maxDevices,
        cache:             NewDeviceCache(),
    }
}

func (r *DeviceFingerprintRule) Name() string {
    return "DeviceFingerprint"
}

func (r *DeviceFingerprintRule) Priority() int {
    return 8
}

func (r *DeviceFingerprintRule) Check(ctx context.Context, req *RiskRequest) (*RuleResult, error) {
    // è®°å½•è®¾å¤‡
    r.cache.AddDevice(req.UserID, req.DeviceID)

    // æ£€æŸ¥è®¾å¤‡æ•°é‡
    deviceCount := r.cache.GetDeviceCount(req.UserID)

    if deviceCount > r.maxDevicesPerUser {
        return &RuleResult{
            RuleName: r.Name(),
            Passed:   false,
            Score:    80,
            Level:    High,
            Action:   ActionReview,
            Reason:   fmt.Sprintf("user has %d devices, limit is %d", deviceCount, r.maxDevicesPerUser),
            Details: map[string]interface{}{
                "device_count": deviceCount,
                "device_id":    req.DeviceID,
            },
        }, nil
    }

    // æ£€æŸ¥è®¾å¤‡æ˜¯å¦æ˜¯æ–°è®¾å¤‡
    isNew := r.cache.IsNewDevice(req.UserID, req.DeviceID)
    score := 30.0
    if isNew {
        score = 60.0
    }

    return &RuleResult{
        RuleName: r.Name(),
        Passed:   true,
        Score:    score,
        Level:    Medium,
        Action:   ActionAllow,
        Details: map[string]interface{}{
            "is_new_device":  isNew,
            "device_count":   deviceCount,
        },
    }, nil
}

type DeviceCache struct {
    userDevices map[string]map[string]time.Time // userID -> deviceID -> firstSeen
    mu          sync.RWMutex
}

func NewDeviceCache() *DeviceCache {
    return &DeviceCache{
        userDevices: make(map[string]map[string]time.Time),
    }
}

func (dc *DeviceCache) AddDevice(userID, deviceID string) {
    dc.mu.Lock()
    defer dc.mu.Unlock()

    if dc.userDevices[userID] == nil {
        dc.userDevices[userID] = make(map[string]time.Time)
    }

    if _, exists := dc.userDevices[userID][deviceID]; !exists {
        dc.userDevices[userID][deviceID] = time.Now()
    }
}

func (dc *DeviceCache) GetDeviceCount(userID string) int {
    dc.mu.RLock()
    defer dc.mu.RUnlock()
    return len(dc.userDevices[userID])
}

func (dc *DeviceCache) IsNewDevice(userID, deviceID string) bool {
    dc.mu.RLock()
    defer dc.mu.RUnlock()

    devices := dc.userDevices[userID]
    if devices == nil {
        return true
    }

    firstSeen, exists := devices[deviceID]
    if !exists {
        return true
    }

    // å¦‚æœè®¾å¤‡é¦–æ¬¡å‡ºç°åœ¨24å°æ—¶å†…ï¼Œè®¤ä¸ºæ˜¯æ–°è®¾å¤‡
    return time.Since(firstSeen) < 24*time.Hour
}
```

---

## åæ¬ºè¯ˆç³»ç»Ÿ

### æ¬ºè¯ˆæ£€æµ‹æ¨¡å‹

```go
package antifraud

import (
    "context"
    "math"
)

// FraudDetector æ¬ºè¯ˆæ£€æµ‹å™¨
type FraudDetector struct {
    models    []DetectionModel
    threshold float64
}

// DetectionModel æ£€æµ‹æ¨¡å‹æ¥å£
type DetectionModel interface {
    Name() string
    Predict(ctx context.Context, features *Features) (float64, error)
}

// Features ç‰¹å¾
type Features struct {
    UserFeatures     *UserFeatures
    TransactionFeatures *TransactionFeatures
    BehaviorFeatures *BehaviorFeatures
    DeviceFeatures   *DeviceFeatures
}

// UserFeatures ç”¨æˆ·ç‰¹å¾
type UserFeatures struct {
    AccountAge       int     // è´¦æˆ·å¹´é¾„(å¤©)
    TotalTransactions int     // å†å²äº¤æ˜“æ•°
    AvgTransAmount   float64 // å¹³å‡äº¤æ˜“é‡‘é¢
    CreditScore      float64 // ä¿¡ç”¨åˆ†
    IsVerified       bool    // æ˜¯å¦å®åè®¤è¯
}

// TransactionFeatures äº¤æ˜“ç‰¹å¾
type TransactionFeatures struct {
    Amount            float64 // äº¤æ˜“é‡‘é¢
    Currency          string  // å¸ç§
    IsLargeAmount     bool    // æ˜¯å¦å¤§é¢
    TimeOfDay         int     // äº¤æ˜“æ—¶æ®µ
    IsWeekend         bool    // æ˜¯å¦å‘¨æœ«
    DestinationCountry string  // ç›®çš„åœ°å›½å®¶
}

// BehaviorFeatures è¡Œä¸ºç‰¹å¾
type BehaviorFeatures struct {
    LoginFrequency    float64 // ç™»å½•é¢‘ç‡
    TransFrequency    float64 // äº¤æ˜“é¢‘ç‡
    TypingSpeed       float64 // æ‰“å­—é€Ÿåº¦
    MouseMovements    int     // é¼ æ ‡ç§»åŠ¨æ¬¡æ•°
    SessionDuration   int     // ä¼šè¯æ—¶é•¿
}

// DeviceFeatures è®¾å¤‡ç‰¹å¾
type DeviceFeatures struct {
    DeviceID       string
    DeviceType     string
    OS             string
    Browser        string
    IsVPN          bool
    IsProxy        bool
    LocationChange bool // ä½ç½®æ˜¯å¦å˜åŒ–
}

// Detect æ¬ºè¯ˆæ£€æµ‹
func (fd *FraudDetector) Detect(ctx context.Context, features *Features) (*FraudResult, error) {
    scores := make([]float64, len(fd.models))

    // å¹¶å‘æ‰§è¡Œæ‰€æœ‰æ¨¡å‹
    for i, model := range fd.models {
        score, err := model.Predict(ctx, features)
        if err != nil {
            return nil, err
        }
        scores[i] = score
    }

    // é›†æˆå¤šä¸ªæ¨¡å‹çš„é¢„æµ‹ç»“æœ
    finalScore := fd.ensembleScores(scores)

    isFraud := finalScore >= fd.threshold

    return &FraudResult{
        IsFraud:    isFraud,
        Score:      finalScore,
        Confidence: fd.calculateConfidence(scores),
        Models:     fd.getModelScores(scores),
    }, nil
}

// ensembleScores é›†æˆå¤šä¸ªæ¨¡å‹åˆ†æ•°
func (fd *FraudDetector) ensembleScores(scores []float64) float64 {
    // ä½¿ç”¨åŠ æƒå¹³å‡
    weights := []float64{0.3, 0.3, 0.2, 0.2}

    var weightedSum float64
    for i, score := range scores {
        weightedSum += score * weights[i]
    }

    return weightedSum
}

func (fd *FraudDetector) calculateConfidence(scores []float64) float64 {
    // è®¡ç®—æ ‡å‡†å·®ä½œä¸ºç½®ä¿¡åº¦çš„é€†æŒ‡æ ‡
    mean := fd.ensembleScores(scores)

    var variance float64
    for _, score := range scores {
        variance += math.Pow(score-mean, 2)
    }
    variance /= float64(len(scores))

    stdDev := math.Sqrt(variance)

    // æ ‡å‡†å·®è¶Šå°ï¼Œç½®ä¿¡åº¦è¶Šé«˜
    confidence := 1.0 - (stdDev / 100.0)
    if confidence < 0 {
        confidence = 0
    }

    return confidence
}

func (fd *FraudDetector) getModelScores(scores []float64) map[string]float64 {
    result := make(map[string]float64)
    for i, model := range fd.models {
        result[model.Name()] = scores[i]
    }
    return result
}

// FraudResult æ¬ºè¯ˆæ£€æµ‹ç»“æœ
type FraudResult struct {
    IsFraud    bool
    Score      float64
    Confidence float64
    Models     map[string]float64
}
```

---

## ä¿¡ç”¨è¯„åˆ†

### ä¿¡ç”¨è¯„åˆ†æ¨¡å‹

```go
package creditscore

// CreditScorer ä¿¡ç”¨è¯„åˆ†å™¨
type CreditScorer struct {
    weights map[string]float64
}

func NewCreditScorer() *CreditScorer {
    return &CreditScorer{
        weights: map[string]float64{
            "payment_history":    0.35,
            "credit_utilization": 0.30,
            "credit_age":         0.15,
            "credit_mix":         0.10,
            "new_credit":         0.10,
        },
    }
}

// Calculate è®¡ç®—ä¿¡ç”¨åˆ†
func (cs *CreditScorer) Calculate(profile *CreditProfile) float64 {
    score := 0.0

    // æ”¯ä»˜å†å²
    score += cs.scorePaymentHistory(profile) * cs.weights["payment_history"]

    // ä¿¡ç”¨ä½¿ç”¨ç‡
    score += cs.scoreCreditUtilization(profile) * cs.weights["credit_utilization"]

    // ä¿¡ç”¨å¹´é¾„
    score += cs.scoreCreditAge(profile) * cs.weights["credit_age"]

    // ä¿¡ç”¨ç»„åˆ
    score += cs.scoreCreditMix(profile) * cs.weights["credit_mix"]

    // æ–°ä¿¡ç”¨
    score += cs.scoreNewCredit(profile) * cs.weights["new_credit"]

    // å½’ä¸€åŒ–åˆ°300-850åˆ†
    finalScore := 300 + score*5.5

    return finalScore
}

type CreditProfile struct {
    OnTimePayments    int
    LatePayments      int
    TotalCreditLimit  float64
    UsedCredit        float64
    AccountAgeDays    int
    NumberOfAccounts  int
    RecentInquiries   int
}

func (cs *CreditScorer) scorePaymentHistory(profile *CreditProfile) float64 {
    total := profile.OnTimePayments + profile.LatePayments
    if total == 0 {
        return 50.0 // é»˜è®¤ä¸­ç­‰åˆ†æ•°
    }

    ratio := float64(profile.OnTimePayments) / float64(total)
    return ratio * 100
}

func (cs *CreditScorer) scoreCreditUtilization(profile *CreditProfile) float64 {
    if profile.TotalCreditLimit == 0 {
        return 50.0
    }

    utilization := profile.UsedCredit / profile.TotalCreditLimit

    // æœ€ä½³ä½¿ç”¨ç‡æ˜¯10-30%
    switch {
    case utilization <= 0.10:
        return 90.0
    case utilization <= 0.30:
        return 100.0
    case utilization <= 0.50:
        return 70.0
    case utilization <= 0.75:
        return 40.0
    default:
        return 10.0
    }
}

func (cs *CreditScorer) scoreCreditAge(profile *CreditProfile) float64 {
    years := float64(profile.AccountAgeDays) / 365.0

    switch {
    case years >= 7:
        return 100.0
    case years >= 5:
        return 85.0
    case years >= 3:
        return 70.0
    case years >= 1:
        return 50.0
    default:
        return 30.0
    }
}

func (cs *CreditScorer) scoreCreditMix(profile *CreditProfile) float64 {
    // è´¦æˆ·å¤šæ ·æ€§è¶Šé«˜åˆ†æ•°è¶Šé«˜
    switch {
    case profile.NumberOfAccounts >= 10:
        return 100.0
    case profile.NumberOfAccounts >= 5:
        return 80.0
    case profile.NumberOfAccounts >= 3:
        return 60.0
    case profile.NumberOfAccounts >= 1:
        return 40.0
    default:
        return 0.0
    }
}

func (cs *CreditScorer) scoreNewCredit(profile *CreditProfile) float64 {
    // æœ€è¿‘æŸ¥è¯¢æ¬¡æ•°è¶Šå°‘è¶Šå¥½
    switch {
    case profile.RecentInquiries == 0:
        return 100.0
    case profile.RecentInquiries <= 2:
        return 80.0
    case profile.RecentInquiries <= 5:
        return 50.0
    default:
        return 20.0
    }
}
```

---

## å®æ—¶ç›‘æ§

### ç›‘æ§Dashboard

```go
package monitoring

import (
    "time"

    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    // é£æ§æ£€æŸ¥æ€»æ•°
    riskChecksTotal = promauto.NewCounter(prometheus.CounterOpts{
        Name: "risk_checks_total",
        Help: "Total number of risk checks",
    })

    // æ‹¦æˆªæ•°é‡
    blockedTotal = promauto.NewCounterVec(prometheus.CounterOpts{
        Name: "risk_blocked_total",
        Help: "Total number of blocked requests",
    }, []string{"reason"})

    // é£é™©åˆ†æ•°åˆ†å¸ƒ
    riskScoreDistribution = promauto.NewHistogram(prometheus.HistogramOpts{
        Name:    "risk_score_distribution",
        Help:    "Distribution of risk scores",
        Buckets: []float64{0, 20, 40, 60, 80, 100},
    })

    // æ£€æŸ¥å»¶è¿Ÿ
    riskCheckLatency = promauto.NewHistogram(prometheus.HistogramOpts{
        Name:    "risk_check_latency_seconds",
        Help:    "Risk check latency in seconds",
        Buckets: prometheus.DefBuckets,
    })

    // è§„åˆ™æ‰§è¡Œæ—¶é—´
    ruleExecutionTime = promauto.NewHistogramVec(prometheus.HistogramOpts{
        Name:    "rule_execution_time_seconds",
        Help:    "Rule execution time in seconds",
        Buckets: prometheus.DefBuckets,
    }, []string{"rule_name"})
)

// RecordCheck è®°å½•æ£€æŸ¥
func RecordCheck(score float64, blocked bool, reason string, latency time.Duration) {
    riskChecksTotal.Inc()
    riskScoreDistribution.Observe(score)
    riskCheckLatency.Observe(latency.Seconds())

    if blocked {
        blockedTotal.WithLabelValues(reason).Inc()
    }
}

// RecordRuleExecution è®°å½•è§„åˆ™æ‰§è¡Œ
func RecordRuleExecution(ruleName string, duration time.Duration) {
    ruleExecutionTime.WithLabelValues(ruleName).Observe(duration.Seconds())
}
```

---

## æœ€ä½³å®è·µ

### 1. è§„åˆ™ç®¡ç†

- âœ… è§„åˆ™ç‰ˆæœ¬æ§åˆ¶
- âœ… ç°åº¦å‘å¸ƒæ–°è§„åˆ™
- âœ… A/Bæµ‹è¯•è§„åˆ™æ•ˆæœ
- âœ… å®šæœŸå®¡æŸ¥å’Œä¼˜åŒ–è§„åˆ™

### 2. æ€§èƒ½ä¼˜åŒ–

- âœ… è§„åˆ™å¹¶å‘æ‰§è¡Œ
- âœ… ç»“æœç¼“å­˜
- âœ… å¼‚æ­¥å¤„ç†éå…³é”®è§„åˆ™
- âœ… æ•°æ®é¢„åŠ è½½

### 3. ç›‘æ§å‘Šè­¦

- âœ… å®æ—¶ç›‘æ§é£æ§æŒ‡æ ‡
- âœ… å¼‚å¸¸å‘Šè­¦
- âœ… å®šæœŸé£æ§æŠ¥å‘Š
- âœ… è¯¯æ€ç‡è·Ÿè¸ª

### 4. æ•°æ®å®‰å…¨

- âœ… æ•æ„Ÿæ•°æ®åŠ å¯†
- âœ… å®¡è®¡æ—¥å¿—
- âœ… è®¿é—®æ§åˆ¶
- âœ… åˆè§„æ€§æ£€æŸ¥

---

**ç›¸å…³æ–‡æ¡£**:

- [é‡‘èç§‘æŠ€æ¦‚è§ˆ](./01-é‡‘èç§‘æŠ€-FinTech.md)
- [é«˜å¹¶å‘äº¤æ˜“ç³»ç»Ÿ](./04-é«˜å¹¶å‘äº¤æ˜“ç³»ç»Ÿ.md)
- [æœºå™¨å­¦ä¹ é›†æˆ](../advanced/33-Go-1.25.3AIä¸æœºå™¨å­¦ä¹ é›†æˆå®Œæ•´å®æˆ˜.md)

**ç»´æŠ¤è€…**: Risk Control Team
**æœ€åæ›´æ–°**: 2025-10-29
