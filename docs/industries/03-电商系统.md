# 电商系统 - Go语言实战

**版本**: v1.0
**更新日期**: 2025-11-11
**适用于**: Go 1.25.3

---

## 📋 目录

- [电商系统 - Go语言实战](#电商系统---go语言实战)
  - [📋 目录](#-目录)
  - [系统概述](#系统概述)
    - [电商系统架构](#电商系统架构)
    - [技术栈](#技术栈)
  - [核心模块](#核心模块)
    - [1. 用户服务](#1-用户服务)
    - [2. 商品服务](#2-商品服务)
  - [秒杀系统](#秒杀系统)
    - [核心流程](#核心流程)
  - [订单系统](#订单系统)
    - [订单流程](#订单流程)
  - [最佳实践](#最佳实践)
    - [1. 高并发处理](#1-高并发处理)
    - [2. 数据一致性](#2-数据一致性)
    - [3. 安全性](#3-安全性)
    - [4. 可观测性](#4-可观测性)

---

## 系统概述

### 电商系统架构

```text
┌─────────────────────────────────────────────────┐
│            E-Commerce Architecture              │
├────────────────────────────────────────────────┤
│                                                 │
│  ┌─────────┐  ┌──────────┐  ┌────────────┐      │
│  │  CDN    │  │  前端    │  │   Mobile   │      │
│  └────┬────┘  └────┬─────┘  └──────┬─────┘     │
│       │            │               │           │
│       └────────────┼───────────────┘           │
│                    │                           │
│           ┌────────▼──────────┐                │
│           │   API Gateway     │                │
│           │  (Nginx/Kong)     │                │
│           └────────┬───────────┘                │
│                    │                           │
│       ┌────────────┼────────────┐              │
│       │            │            │              │
│  ┌────▼────┐ ┌────▼────┐ ┌────▼────┐         │
│  │  用户   │ │  商品   │ │  订单   │         │
│  │ 服务    │ │ 服务    │ │ 服务    │         │
│  └────┬────┘ └────┬────┘ └────┬────┘         │
│       │           │           │               │
│       │     ┌─────▼───────┐   │               │
│       │     │   支付服务   │   │               │
│       │     └─────┬───────┘   │               │
│       │           │           │               │
│       └───────────┼───────────┘               │
│                   │                           │
│       ┌───────────┼────────────┐              │
│       │           │            │              │
│  ┌────▼────┐ ┌───▼──────┐ ┌──▼──────┐         │
│  │  MySQL  │ │  Redis   │ │  Kafka  │       │
│  │(主从复制)│ │  (缓存)  │ │ (消息)  │       │
│  └─────────┘ └──────────┘ └─────────┘       │
└─────────────────────────────────────────────────┘
```

### 技术栈

| 层次 | 技术选型 | 说明 |
|------|----------|------|
| 应用层 | Go 1.25.3 + Gin | Web框架 |
| 缓存层 | Redis Cluster | 分布式缓存 |
| 数据库 | MySQL + MongoDB | 关系型+文档型 |
| 消息队列 | Kafka | 异步消息 |
| 搜索引擎 | Elasticsearch | 商品搜索 |
| 监控 | Prometheus + Grafana | 监控告警 |

---

## 核心模块

### 1. 用户服务

```go
package user

import (
    "context"
    "database/sql"
    "time"

    "github.com/go-redis/redis/v8"
)

// UserService 用户服务
type UserService struct {
    db    *sql.DB
    cache *redis.Client
}

// Register 用户注册
func (us *UserService) Register(ctx Context.Context, req *RegisterRequest) (*User, error) {
    // 1. 验证输入
    if err := req.Validate(); err != nil {
        return nil, err
    }

    // 2. 检查用户是否存在
    exists, err := us.userExists(ctx, req.Username, req.Email)
    if err != nil {
        return nil, err
    }
    if exists {
        return nil, ErrUserExists
    }

    // 3. 密码哈希
    hashedPassword, err := hashPassword(req.Password)
    if err != nil {
        return nil, err
    }

    // 4. 创建用户
    user := &User{
        Username:     req.Username,
        Email:        req.Email,
        PasswordHash: hashedPassword,
        CreatedAt:    time.Now(),
        UpdatedAt:    time.Now(),
    }

    if err := us.createUser(ctx, user); err != nil {
        return nil, err
    }

    return user, nil
}

// Login 用户登录
func (us *UserService) Login(ctx Context.Context, username, password string) (*Session, error) {
    // 1. 查询用户
    user, err := us.getUserByUsername(ctx, username)
    if err != nil {
        return nil, err
    }

    // 2. 验证密码
    if !verifyPassword(user.PasswordHash, password) {
        return nil, ErrInvalidCredentials
    }

    // 3. 创建会话
    session := &Session{
        UserID:    user.ID,
        Token:     generateToken(),
        ExpiresAt: time.Now().Add(24 * time.Hour),
    }

    // 4. 保存到Redis
    if err := us.saveSession(ctx, session); err != nil {
        return nil, err
    }

    return session, nil
}

type RegisterRequest struct {
    Username string `json:"username" binding:"required"`
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required,min=8"`
}

func (r *RegisterRequest) Validate() error {
    // 验证逻辑
    return nil
}

type User struct {
    ID           int64
    Username     string
    Email        string
    PasswordHash string
    CreatedAt    time.Time
    UpdatedAt    time.Time
}

type Session struct {
    UserID    int64
    Token     string
    ExpiresAt time.Time
}

func (us *UserService) userExists(ctx Context.Context, username, email string) (bool, error) {
    return false, nil
}

func (us *UserService) createUser(ctx Context.Context, user *User) error {
    return nil
}

func (us *UserService) getUserByUsername(ctx Context.Context, username string) (*User, error) {
    return nil, nil
}

func (us *UserService) saveSession(ctx Context.Context, session *Session) error {
    return nil
}

func hashPassword(password string) (string, error) {
    return "", nil
}

func verifyPassword(hash, password string) bool {
    return true
}

func generateToken() string {
    return ""
}

var (
    ErrUserExists          = &struct{ error }{}
    ErrInvalidCredentials  = &struct{ error }{}
)
```

### 2. 商品服务

```go
package product

import (
    "context"
    "encoding/json"
    "time"

    "github.com/go-redis/redis/v8"
)

// ProductService 商品服务
type ProductService struct {
    db          ProductRepository
    cache       *redis.Client
    searchIndex SearchIndex
}

// GetProduct 获取商品详情
func (ps *ProductService) GetProduct(ctx Context.Context, productID int64) (*Product, error) {
    // 1. 查询缓存
    cacheKey := ps.productCacheKey(productID)
    cached, err := ps.cache.Get(ctx, cacheKey).Result()
    if err == nil {
        var product Product
        if err := json.Unmarshal([]byte(cached), &product); err == nil {
            return &product, nil
        }
    }

    // 2. 查询数据库
    product, err := ps.db.GetByID(ctx, productID)
    if err != nil {
        return nil, err
    }

    // 3. 更新缓存
    data, _ := json.Marshal(product)
    ps.cache.Set(ctx, cacheKey, data, 1*time.Hour)

    return product, nil
}

// SearchProducts 搜索商品
func (ps *ProductService) SearchProducts(ctx Context.Context, query string, page, pageSize int) ([]*Product, int, error) {
    return ps.searchIndex.Search(ctx, query, page, pageSize)
}

// UpdateStock 更新库存
func (ps *ProductService) UpdateStock(ctx Context.Context, productID int64, delta int) error {
    // 使用Redis原子操作
    stockKey := ps.stockCacheKey(productID)
    newStock, err := ps.cache.IncrBy(ctx, stockKey, int64(delta)).Result()
    if err != nil {
        return err
    }

    if newStock < 0 {
        // 回滚
        ps.cache.IncrBy(ctx, stockKey, -int64(delta))
        return ErrInsufficientStock
    }

    // 异步同步到数据库
    go ps.syncStockToDB(productID, int(newStock))

    return nil
}

type Product struct {
    ID          int64
    Name        string
    Description string
    Price       float64
    Stock       int
    CategoryID  int64
    Images      []string
    CreatedAt   time.Time
    UpdatedAt   time.Time
}

func (ps *ProductService) productCacheKey(productID int64) string {
    return ""
}

func (ps *ProductService) stockCacheKey(productID int64) string {
    return ""
}

func (ps *ProductService) syncStockToDB(productID int64, stock int) {
    // 异步同步逻辑
}

type ProductRepository interface {
    GetByID(ctx Context.Context, id int64) (*Product, error)
    UpdateStock(ctx Context.Context, id int64, stock int) error
}

type SearchIndex interface {
    Search(ctx Context.Context, query string, page, pageSize int) ([]*Product, int, error)
    Index(ctx Context.Context, product *Product) error
}

var ErrInsufficientStock = &struct{ error }{}
```

---

## 秒杀系统

详细内容请参考: [秒杀系统设计](./08-秒杀系统.md)

### 核心流程

```go
package seckill

import (
    "context"
    "fmt"
    "time"

    "github.com/go-redis/redis/v8"
)

// SeckillService 秒杀服务
type SeckillService struct {
    redis       *redis.Client
    orderSvc    OrderService
    stockSvc    StockService
    rateLimiter *RateLimiter
}

// CreateSeckill 创建秒杀活动
func (ss *SeckillService) CreateSeckill(ctx Context.Context, req *CreateSeckillRequest) (*Seckill, error) {
    seckill := &Seckill{
        ProductID:   req.ProductID,
        Stock:       req.Stock,
        Price:       req.Price,
        StartTime:   req.StartTime,
        EndTime:     req.EndTime,
        Status:      SeckillStatusPending,
        CreatedAt:   time.Now(),
    }

    // 预热库存到Redis
    stockKey := ss.seckillStockKey(seckill.ProductID)
    if err := ss.redis.Set(ctx, stockKey, seckill.Stock, 0).Err(); err != nil {
        return nil, err
    }

    return seckill, nil
}

// Purchase 秒杀购买
func (ss *SeckillService) Purchase(ctx Context.Context, userID, seckillID int64) (*Order, error) {
    // 1. 限流检查
    if !ss.rateLimiter.Allow(userID) {
        return nil, ErrRateLimitExceeded
    }

    // 2. 防重复购买检查
    if ss.hasPurchased(ctx, userID, seckillID) {
        return nil, ErrAlreadyPurchased
    }

    // 3. 扣减库存 (Redis原子操作)
    stockKey := ss.seckillStockKey(seckillID)
    remaining, err := ss.redis.Decr(ctx, stockKey).Result()
    if err != nil {
        return nil, err
    }

    if remaining < 0 {
        // 库存不足，回滚
        ss.redis.Incr(ctx, stockKey)
        return nil, ErrSoldOut
    }

    // 4. 创建订单 (异步)
    order := &Order{
        UserID:     userID,
        SeckillID:  seckillID,
        Status:     OrderStatusPending,
        CreatedAt:  time.Now(),
    }

    // 发送到消息队列
    if err := ss.sendOrderToQueue(order); err != nil {
        // 回滚库存
        ss.redis.Incr(ctx, stockKey)
        return nil, err
    }

    // 5. 标记已购买
    ss.markPurchased(ctx, userID, seckillID)

    return order, nil
}

func (ss *SeckillService) seckillStockKey(seckillID int64) string {
    return fmt.Sprintf("seckill:stock:%d", seckillID)
}

func (ss *SeckillService) hasPurchased(ctx Context.Context, userID, seckillID int64) bool {
    key := fmt.Sprintf("seckill:purchased:%d:%d", seckillID, userID)
    exists, _ := ss.redis.Exists(ctx, key).Result()
    return exists > 0
}

func (ss *SeckillService) markPurchased(ctx Context.Context, userID, seckillID int64) {
    key := fmt.Sprintf("seckill:purchased:%d:%d", seckillID, userID)
    ss.redis.Set(ctx, key, 1, 24*time.Hour)
}

func (ss *SeckillService) sendOrderToQueue(order *Order) error {
    // 发送到Kafka
    return nil
}

type CreateSeckillRequest struct {
    ProductID int64
    Stock     int
    Price     float64
    StartTime time.Time
    EndTime   time.Time
}

type Seckill struct {
    ID        int64
    ProductID int64
    Stock     int
    Price     float64
    StartTime time.Time
    EndTime   time.Time
    Status    SeckillStatus
    CreatedAt time.Time
}

type SeckillStatus int

const (
    SeckillStatusPending SeckillStatus = iota
    SeckillStatusActive
    SeckillStatusEnded
)

type Order struct {
    UserID    int64
    SeckillID int64
    Status    OrderStatus
    CreatedAt time.Time
}

type OrderStatus int

const (
    OrderStatusPending OrderStatus = iota
    OrderStatusPaid
    OrderStatusCancelled
)

type OrderService interface{}
type StockService interface{}
type RateLimiter struct{}

func (rl *RateLimiter) Allow(userID int64) bool {
    return true
}

var (
    ErrRateLimitExceeded = &struct{ error }{}
    ErrAlreadyPurchased  = &struct{ error }{}
    ErrSoldOut           = &struct{ error }{}
)
```

---

## 订单系统

详细内容请参考: [订单系统设计](./09-订单系统.md)

### 订单流程

```go
package order

import (
    "context"
    "database/sql"
    "time"
)

// OrderService 订单服务
type OrderService struct {
    db           *sql.DB
    paymentSvc   PaymentService
    inventorySvc InventoryService
    messageMQ    MessageQueue
}

// CreateOrder 创建订单
func (os *OrderService) CreateOrder(ctx Context.Context, req *CreateOrderRequest) (*Order, error) {
    // 开启事务
    tx, err := os.db.BeginTx(ctx, nil)
    if err != nil {
        return nil, err
    }
    defer tx.Rollback()

    // 1. 创建订单
    order := &Order{
        UserID:      req.UserID,
        TotalAmount: req.TotalAmount,
        Status:      OrderStatusPending,
        CreatedAt:   time.Now(),
    }

    if err := os.insertOrder(ctx, tx, order); err != nil {
        return nil, err
    }

    // 2. 创建订单项
    for _, item := range req.Items {
        orderItem := &OrderItem{
            OrderID:   order.ID,
            ProductID: item.ProductID,
            Quantity:  item.Quantity,
            Price:     item.Price,
        }
        if err := os.insertOrderItem(ctx, tx, orderItem); err != nil {
            return nil, err
        }
    }

    // 3. 扣减库存
    for _, item := range req.Items {
        if err := os.inventorySvc.Deduct(ctx, item.ProductID, item.Quantity); err != nil {
            return nil, err
        }
    }

    // 提交事务
    if err := tx.Commit(); err != nil {
        return nil, err
    }

    // 4. 发送订单创建事件
    os.messageMQ.Publish("order.created", order)

    return order, nil
}

// PayOrder 支付订单
func (os *OrderService) PayOrder(ctx Context.Context, orderID int64, paymentMethod string) error {
    // 1. 查询订单
    order, err := os.getOrder(ctx, orderID)
    if err != nil {
        return err
    }

    if order.Status != OrderStatusPending {
        return ErrInvalidOrderStatus
    }

    // 2. 调用支付服务
    paymentReq := &PaymentRequest{
        OrderID: orderID,
        Amount:  order.TotalAmount,
        Method:  paymentMethod,
    }

    paymentResp, err := os.paymentSvc.Pay(ctx, paymentReq)
    if err != nil {
        return err
    }

    // 3. 更新订单状态
    if paymentResp.Success {
        order.Status = OrderStatusPaid
        order.PaidAt = time.Now()
    } else {
        order.Status = OrderStatusPaymentFailed
    }

    if err := os.updateOrder(ctx, order); err != nil {
        return err
    }

    // 4. 发送支付成功事件
    if paymentResp.Success {
        os.messageMQ.Publish("order.paid", order)
    }

    return nil
}

// CancelOrder 取消订单
func (os *OrderService) CancelOrder(ctx Context.Context, orderID int64) error {
    // 开启事务
    tx, err := os.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // 1. 查询订单
    order, err := os.getOrderForUpdate(ctx, tx, orderID)
    if err != nil {
        return err
    }

    // 2. 检查订单状态
    if order.Status != OrderStatusPending {
        return ErrCannotCancelOrder
    }

    // 3. 更新订单状态
    order.Status = OrderStatusCancelled
    order.CancelledAt = time.Now()
    if err := os.updateOrderInTx(ctx, tx, order); err != nil {
        return err
    }

    // 4. 恢复库存
    items, err := os.getOrderItems(ctx, orderID)
    if err != nil {
        return err
    }

    for _, item := range items {
        if err := os.inventorySvc.Restore(ctx, item.ProductID, item.Quantity); err != nil {
            return err
        }
    }

    // 提交事务
    if err := tx.Commit(); err != nil {
        return err
    }

    // 5. 发送订单取消事件
    os.messageMQ.Publish("order.cancelled", order)

    return nil
}

type CreateOrderRequest struct {
    UserID      int64
    Items       []*OrderItemRequest
    TotalAmount float64
}

type OrderItemRequest struct {
    ProductID int64
    Quantity  int
    Price     float64
}

type Order struct {
    ID          int64
    UserID      int64
    TotalAmount float64
    Status      OrderStatus
    CreatedAt   time.Time
    PaidAt      time.Time
    CancelledAt time.Time
}

type OrderItem struct {
    ID        int64
    OrderID   int64
    ProductID int64
    Quantity  int
    Price     float64
}

func (os *OrderService) insertOrder(ctx Context.Context, tx *sql.Tx, order *Order) error {
    return nil
}

func (os *OrderService) insertOrderItem(ctx Context.Context, tx *sql.Tx, item *OrderItem) error {
    return nil
}

func (os *OrderService) getOrder(ctx Context.Context, orderID int64) (*Order, error) {
    return nil, nil
}

func (os *OrderService) getOrderForUpdate(ctx Context.Context, tx *sql.Tx, orderID int64) (*Order, error) {
    return nil, nil
}

func (os *OrderService) updateOrder(ctx Context.Context, order *Order) error {
    return nil
}

func (os *OrderService) updateOrderInTx(ctx Context.Context, tx *sql.Tx, order *Order) error {
    return nil
}

func (os *OrderService) getOrderItems(ctx Context.Context, orderID int64) ([]*OrderItem, error) {
    return nil, nil
}

type PaymentService interface {
    Pay(ctx Context.Context, req *PaymentRequest) (*PaymentResponse, error)
}

type PaymentRequest struct {
    OrderID int64
    Amount  float64
    Method  string
}

type PaymentResponse struct {
    Success bool
}

type InventoryService interface {
    Deduct(ctx Context.Context, productID int64, quantity int) error
    Restore(ctx Context.Context, productID int64, quantity int) error
}

type MessageQueue interface {
    Publish(topic string, data interface{}) error
}

var (
    ErrInvalidOrderStatus = &struct{ error }{}
    ErrCannotCancelOrder  = &struct{ error }{}
)
```

---

## 最佳实践

### 1. 高并发处理

- ✅ Redis缓存热点数据
- ✅ 数据库读写分离
- ✅ 限流熔断
- ✅ CDN加速静态资源

### 2. 数据一致性

- ✅ 分布式事务 (Saga/TCC)
- ✅ 最终一致性
- ✅ 幂等性设计
- ✅ 补偿机制

### 3. 安全性

- ✅ 防刷限流
- ✅ 防重复提交
- ✅ 接口签名验证
- ✅ 敏感数据加密

### 4. 可观测性
