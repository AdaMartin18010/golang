# ç”µå•†ç³»ç»Ÿ - Goè¯­è¨€å®æˆ˜

> Goè¯­è¨€æ„å»ºé«˜æ€§èƒ½ç”µå•†ç³»ç»Ÿå®Œæ•´æŒ‡å—

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨Goç‰ˆæœ¬**: Go 1.25.3+

---

## ğŸ“‹ ç›®å½•

- [ç”µå•†ç³»ç»Ÿ - Goè¯­è¨€å®æˆ˜](#ç”µå•†ç³»ç»Ÿ---goè¯­è¨€å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ç³»ç»Ÿæ¦‚è¿°](#ç³»ç»Ÿæ¦‚è¿°)
    - [ç”µå•†ç³»ç»Ÿæ¶æ„](#ç”µå•†ç³»ç»Ÿæ¶æ„)
    - [æŠ€æœ¯æ ˆ](#æŠ€æœ¯æ ˆ)
  - [æ ¸å¿ƒæ¨¡å—](#æ ¸å¿ƒæ¨¡å—)
    - [1. ç”¨æˆ·æœåŠ¡](#1-ç”¨æˆ·æœåŠ¡)
    - [2. å•†å“æœåŠ¡](#2-å•†å“æœåŠ¡)
  - [ç§’æ€ç³»ç»Ÿ](#ç§’æ€ç³»ç»Ÿ)
    - [æ ¸å¿ƒæµç¨‹](#æ ¸å¿ƒæµç¨‹)
  - [è®¢å•ç³»ç»Ÿ](#è®¢å•ç³»ç»Ÿ)
    - [è®¢å•æµç¨‹](#è®¢å•æµç¨‹)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [1. é«˜å¹¶å‘å¤„ç†](#1-é«˜å¹¶å‘å¤„ç†)
    - [2. æ•°æ®ä¸€è‡´æ€§](#2-æ•°æ®ä¸€è‡´æ€§)
    - [3. å®‰å…¨æ€§](#3-å®‰å…¨æ€§)
    - [4. å¯è§‚æµ‹æ€§](#4-å¯è§‚æµ‹æ€§)

---

## ç³»ç»Ÿæ¦‚è¿°

### ç”µå•†ç³»ç»Ÿæ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            E-Commerce Architecture              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  CDN    â”‚  â”‚  å‰ç«¯    â”‚  â”‚   Mobile   â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜     â”‚
â”‚       â”‚            â”‚               â”‚           â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                    â”‚                           â”‚
â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚           â”‚   API Gateway     â”‚                â”‚
â”‚           â”‚  (Nginx/Kong)     â”‚                â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                    â”‚                           â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚       â”‚            â”‚            â”‚              â”‚
â”‚  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”         â”‚
â”‚  â”‚  ç”¨æˆ·   â”‚ â”‚  å•†å“   â”‚ â”‚  è®¢å•   â”‚         â”‚
â”‚  â”‚ æœåŠ¡    â”‚ â”‚ æœåŠ¡    â”‚ â”‚ æœåŠ¡    â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜         â”‚
â”‚       â”‚           â”‚           â”‚               â”‚
â”‚       â”‚     â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”   â”‚               â”‚
â”‚       â”‚     â”‚   æ”¯ä»˜æœåŠ¡   â”‚   â”‚               â”‚
â”‚       â”‚     â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚               â”‚
â”‚       â”‚           â”‚           â”‚               â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                   â”‚                           â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚       â”‚           â”‚            â”‚              â”‚
â”‚  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â” â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â–¼â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚  MySQL  â”‚ â”‚  Redis   â”‚ â”‚  Kafka  â”‚       â”‚
â”‚  â”‚(ä¸»ä»å¤åˆ¶)â”‚ â”‚  (ç¼“å­˜)  â”‚ â”‚ (æ¶ˆæ¯)  â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æŠ€æœ¯æ ˆ

| å±‚æ¬¡ | æŠ€æœ¯é€‰å‹ | è¯´æ˜ |
|------|----------|------|
| åº”ç”¨å±‚ | Go 1.25.3 + Gin | Webæ¡†æ¶ |
| ç¼“å­˜å±‚ | Redis Cluster | åˆ†å¸ƒå¼ç¼“å­˜ |
| æ•°æ®åº“ | MySQL + MongoDB | å…³ç³»å‹+æ–‡æ¡£å‹ |
| æ¶ˆæ¯é˜Ÿåˆ— | Kafka | å¼‚æ­¥æ¶ˆæ¯ |
| æœç´¢å¼•æ“ | Elasticsearch | å•†å“æœç´¢ |
| ç›‘æ§ | Prometheus + Grafana | ç›‘æ§å‘Šè­¦ |

---

## æ ¸å¿ƒæ¨¡å—

### 1. ç”¨æˆ·æœåŠ¡

```go
package user

import (
    "context"
    "database/sql"
    "time"

    "github.com/go-redis/redis/v8"
)

// UserService ç”¨æˆ·æœåŠ¡
type UserService struct {
    db    *sql.DB
    cache *redis.Client
}

// Register ç”¨æˆ·æ³¨å†Œ
func (us *UserService) Register(ctx context.Context, req *RegisterRequest) (*User, error) {
    // 1. éªŒè¯è¾“å…¥
    if err := req.Validate(); err != nil {
        return nil, err
    }

    // 2. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
    exists, err := us.userExists(ctx, req.Username, req.Email)
    if err != nil {
        return nil, err
    }
    if exists {
        return nil, ErrUserExists
    }

    // 3. å¯†ç å“ˆå¸Œ
    hashedPassword, err := hashPassword(req.Password)
    if err != nil {
        return nil, err
    }

    // 4. åˆ›å»ºç”¨æˆ·
    user := &User{
        Username:     req.Username,
        Email:        req.Email,
        PasswordHash: hashedPassword,
        CreatedAt:    time.Now(),
        UpdatedAt:    time.Now(),
    }

    if err := us.createUser(ctx, user); err != nil {
        return nil, err
    }

    return user, nil
}

// Login ç”¨æˆ·ç™»å½•
func (us *UserService) Login(ctx context.Context, username, password string) (*Session, error) {
    // 1. æŸ¥è¯¢ç”¨æˆ·
    user, err := us.getUserByUsername(ctx, username)
    if err != nil {
        return nil, err
    }

    // 2. éªŒè¯å¯†ç 
    if !verifyPassword(user.PasswordHash, password) {
        return nil, ErrInvalidCredentials
    }

    // 3. åˆ›å»ºä¼šè¯
    session := &Session{
        UserID:    user.ID,
        Token:     generateToken(),
        ExpiresAt: time.Now().Add(24 * time.Hour),
    }

    // 4. ä¿å­˜åˆ°Redis
    if err := us.saveSession(ctx, session); err != nil {
        return nil, err
    }

    return session, nil
}

type RegisterRequest struct {
    Username string `json:"username" binding:"required"`
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required,min=8"`
}

func (r *RegisterRequest) Validate() error {
    // éªŒè¯é€»è¾‘
    return nil
}

type User struct {
    ID           int64
    Username     string
    Email        string
    PasswordHash string
    CreatedAt    time.Time
    UpdatedAt    time.Time
}

type Session struct {
    UserID    int64
    Token     string
    ExpiresAt time.Time
}

func (us *UserService) userExists(ctx context.Context, username, email string) (bool, error) {
    return false, nil
}

func (us *UserService) createUser(ctx context.Context, user *User) error {
    return nil
}

func (us *UserService) getUserByUsername(ctx context.Context, username string) (*User, error) {
    return nil, nil
}

func (us *UserService) saveSession(ctx context.Context, session *Session) error {
    return nil
}

func hashPassword(password string) (string, error) {
    return "", nil
}

func verifyPassword(hash, password string) bool {
    return true
}

func generateToken() string {
    return ""
}

var (
    ErrUserExists          = &struct{ error }{}
    ErrInvalidCredentials  = &struct{ error }{}
)
```

### 2. å•†å“æœåŠ¡

```go
package product

import (
    "context"
    "encoding/json"
    "time"

    "github.com/go-redis/redis/v8"
)

// ProductService å•†å“æœåŠ¡
type ProductService struct {
    db          ProductRepository
    cache       *redis.Client
    searchIndex SearchIndex
}

// GetProduct è·å–å•†å“è¯¦æƒ…
func (ps *ProductService) GetProduct(ctx context.Context, productID int64) (*Product, error) {
    // 1. æŸ¥è¯¢ç¼“å­˜
    cacheKey := ps.productCacheKey(productID)
    cached, err := ps.cache.Get(ctx, cacheKey).Result()
    if err == nil {
        var product Product
        if err := json.Unmarshal([]byte(cached), &product); err == nil {
            return &product, nil
        }
    }

    // 2. æŸ¥è¯¢æ•°æ®åº“
    product, err := ps.db.GetByID(ctx, productID)
    if err != nil {
        return nil, err
    }

    // 3. æ›´æ–°ç¼“å­˜
    data, _ := json.Marshal(product)
    ps.cache.Set(ctx, cacheKey, data, 1*time.Hour)

    return product, nil
}

// SearchProducts æœç´¢å•†å“
func (ps *ProductService) SearchProducts(ctx context.Context, query string, page, pageSize int) ([]*Product, int, error) {
    return ps.searchIndex.Search(ctx, query, page, pageSize)
}

// UpdateStock æ›´æ–°åº“å­˜
func (ps *ProductService) UpdateStock(ctx context.Context, productID int64, delta int) error {
    // ä½¿ç”¨RedisåŸå­æ“ä½œ
    stockKey := ps.stockCacheKey(productID)
    newStock, err := ps.cache.IncrBy(ctx, stockKey, int64(delta)).Result()
    if err != nil {
        return err
    }

    if newStock < 0 {
        // å›æ»š
        ps.cache.IncrBy(ctx, stockKey, -int64(delta))
        return ErrInsufficientStock
    }

    // å¼‚æ­¥åŒæ­¥åˆ°æ•°æ®åº“
    go ps.syncStockToDB(productID, int(newStock))

    return nil
}

type Product struct {
    ID          int64
    Name        string
    Description string
    Price       float64
    Stock       int
    CategoryID  int64
    Images      []string
    CreatedAt   time.Time
    UpdatedAt   time.Time
}

func (ps *ProductService) productCacheKey(productID int64) string {
    return ""
}

func (ps *ProductService) stockCacheKey(productID int64) string {
    return ""
}

func (ps *ProductService) syncStockToDB(productID int64, stock int) {
    // å¼‚æ­¥åŒæ­¥é€»è¾‘
}

type ProductRepository interface {
    GetByID(ctx context.Context, id int64) (*Product, error)
    UpdateStock(ctx context.Context, id int64, stock int) error
}

type SearchIndex interface {
    Search(ctx context.Context, query string, page, pageSize int) ([]*Product, int, error)
    Index(ctx context.Context, product *Product) error
}

var ErrInsufficientStock = &struct{ error }{}
```

---

## ç§’æ€ç³»ç»Ÿ

è¯¦ç»†å†…å®¹è¯·å‚è€ƒ: [ç§’æ€ç³»ç»Ÿè®¾è®¡](./08-ç§’æ€ç³»ç»Ÿ.md)

### æ ¸å¿ƒæµç¨‹

```go
package seckill

import (
    "context"
    "fmt"
    "time"

    "github.com/go-redis/redis/v8"
)

// SeckillService ç§’æ€æœåŠ¡
type SeckillService struct {
    redis       *redis.Client
    orderSvc    OrderService
    stockSvc    StockService
    rateLimiter *RateLimiter
}

// CreateSeckill åˆ›å»ºç§’æ€æ´»åŠ¨
func (ss *SeckillService) CreateSeckill(ctx context.Context, req *CreateSeckillRequest) (*Seckill, error) {
    seckill := &Seckill{
        ProductID:   req.ProductID,
        Stock:       req.Stock,
        Price:       req.Price,
        StartTime:   req.StartTime,
        EndTime:     req.EndTime,
        Status:      SeckillStatusPending,
        CreatedAt:   time.Now(),
    }

    // é¢„çƒ­åº“å­˜åˆ°Redis
    stockKey := ss.seckillStockKey(seckill.ProductID)
    if err := ss.redis.Set(ctx, stockKey, seckill.Stock, 0).Err(); err != nil {
        return nil, err
    }

    return seckill, nil
}

// Purchase ç§’æ€è´­ä¹°
func (ss *SeckillService) Purchase(ctx context.Context, userID, seckillID int64) (*Order, error) {
    // 1. é™æµæ£€æŸ¥
    if !ss.rateLimiter.Allow(userID) {
        return nil, ErrRateLimitExceeded
    }

    // 2. é˜²é‡å¤è´­ä¹°æ£€æŸ¥
    if ss.hasPurchased(ctx, userID, seckillID) {
        return nil, ErrAlreadyPurchased
    }

    // 3. æ‰£å‡åº“å­˜ (RedisåŸå­æ“ä½œ)
    stockKey := ss.seckillStockKey(seckillID)
    remaining, err := ss.redis.Decr(ctx, stockKey).Result()
    if err != nil {
        return nil, err
    }

    if remaining < 0 {
        // åº“å­˜ä¸è¶³ï¼Œå›æ»š
        ss.redis.Incr(ctx, stockKey)
        return nil, ErrSoldOut
    }

    // 4. åˆ›å»ºè®¢å• (å¼‚æ­¥)
    order := &Order{
        UserID:     userID,
        SeckillID:  seckillID,
        Status:     OrderStatusPending,
        CreatedAt:  time.Now(),
    }

    // å‘é€åˆ°æ¶ˆæ¯é˜Ÿåˆ—
    if err := ss.sendOrderToQueue(order); err != nil {
        // å›æ»šåº“å­˜
        ss.redis.Incr(ctx, stockKey)
        return nil, err
    }

    // 5. æ ‡è®°å·²è´­ä¹°
    ss.markPurchased(ctx, userID, seckillID)

    return order, nil
}

func (ss *SeckillService) seckillStockKey(seckillID int64) string {
    return fmt.Sprintf("seckill:stock:%d", seckillID)
}

func (ss *SeckillService) hasPurchased(ctx context.Context, userID, seckillID int64) bool {
    key := fmt.Sprintf("seckill:purchased:%d:%d", seckillID, userID)
    exists, _ := ss.redis.Exists(ctx, key).Result()
    return exists > 0
}

func (ss *SeckillService) markPurchased(ctx context.Context, userID, seckillID int64) {
    key := fmt.Sprintf("seckill:purchased:%d:%d", seckillID, userID)
    ss.redis.Set(ctx, key, 1, 24*time.Hour)
}

func (ss *SeckillService) sendOrderToQueue(order *Order) error {
    // å‘é€åˆ°Kafka
    return nil
}

type CreateSeckillRequest struct {
    ProductID int64
    Stock     int
    Price     float64
    StartTime time.Time
    EndTime   time.Time
}

type Seckill struct {
    ID        int64
    ProductID int64
    Stock     int
    Price     float64
    StartTime time.Time
    EndTime   time.Time
    Status    SeckillStatus
    CreatedAt time.Time
}

type SeckillStatus int

const (
    SeckillStatusPending SeckillStatus = iota
    SeckillStatusActive
    SeckillStatusEnded
)

type Order struct {
    UserID    int64
    SeckillID int64
    Status    OrderStatus
    CreatedAt time.Time
}

type OrderStatus int

const (
    OrderStatusPending OrderStatus = iota
    OrderStatusPaid
    OrderStatusCancelled
)

type OrderService interface{}
type StockService interface{}
type RateLimiter struct{}

func (rl *RateLimiter) Allow(userID int64) bool {
    return true
}

var (
    ErrRateLimitExceeded = &struct{ error }{}
    ErrAlreadyPurchased  = &struct{ error }{}
    ErrSoldOut           = &struct{ error }{}
)
```

---

## è®¢å•ç³»ç»Ÿ

è¯¦ç»†å†…å®¹è¯·å‚è€ƒ: [è®¢å•ç³»ç»Ÿè®¾è®¡](./09-è®¢å•ç³»ç»Ÿ.md)

### è®¢å•æµç¨‹

```go
package order

import (
    "context"
    "database/sql"
    "time"
)

// OrderService è®¢å•æœåŠ¡
type OrderService struct {
    db           *sql.DB
    paymentSvc   PaymentService
    inventorySvc InventoryService
    messageMQ    MessageQueue
}

// CreateOrder åˆ›å»ºè®¢å•
func (os *OrderService) CreateOrder(ctx context.Context, req *CreateOrderRequest) (*Order, error) {
    // å¼€å¯äº‹åŠ¡
    tx, err := os.db.BeginTx(ctx, nil)
    if err != nil {
        return nil, err
    }
    defer tx.Rollback()

    // 1. åˆ›å»ºè®¢å•
    order := &Order{
        UserID:      req.UserID,
        TotalAmount: req.TotalAmount,
        Status:      OrderStatusPending,
        CreatedAt:   time.Now(),
    }

    if err := os.insertOrder(ctx, tx, order); err != nil {
        return nil, err
    }

    // 2. åˆ›å»ºè®¢å•é¡¹
    for _, item := range req.Items {
        orderItem := &OrderItem{
            OrderID:   order.ID,
            ProductID: item.ProductID,
            Quantity:  item.Quantity,
            Price:     item.Price,
        }
        if err := os.insertOrderItem(ctx, tx, orderItem); err != nil {
            return nil, err
        }
    }

    // 3. æ‰£å‡åº“å­˜
    for _, item := range req.Items {
        if err := os.inventorySvc.Deduct(ctx, item.ProductID, item.Quantity); err != nil {
            return nil, err
        }
    }

    // æäº¤äº‹åŠ¡
    if err := tx.Commit(); err != nil {
        return nil, err
    }

    // 4. å‘é€è®¢å•åˆ›å»ºäº‹ä»¶
    os.messageMQ.Publish("order.created", order)

    return order, nil
}

// PayOrder æ”¯ä»˜è®¢å•
func (os *OrderService) PayOrder(ctx context.Context, orderID int64, paymentMethod string) error {
    // 1. æŸ¥è¯¢è®¢å•
    order, err := os.getOrder(ctx, orderID)
    if err != nil {
        return err
    }

    if order.Status != OrderStatusPending {
        return ErrInvalidOrderStatus
    }

    // 2. è°ƒç”¨æ”¯ä»˜æœåŠ¡
    paymentReq := &PaymentRequest{
        OrderID: orderID,
        Amount:  order.TotalAmount,
        Method:  paymentMethod,
    }

    paymentResp, err := os.paymentSvc.Pay(ctx, paymentReq)
    if err != nil {
        return err
    }

    // 3. æ›´æ–°è®¢å•çŠ¶æ€
    if paymentResp.Success {
        order.Status = OrderStatusPaid
        order.PaidAt = time.Now()
    } else {
        order.Status = OrderStatusPaymentFailed
    }

    if err := os.updateOrder(ctx, order); err != nil {
        return err
    }

    // 4. å‘é€æ”¯ä»˜æˆåŠŸäº‹ä»¶
    if paymentResp.Success {
        os.messageMQ.Publish("order.paid", order)
    }

    return nil
}

// CancelOrder å–æ¶ˆè®¢å•
func (os *OrderService) CancelOrder(ctx context.Context, orderID int64) error {
    // å¼€å¯äº‹åŠ¡
    tx, err := os.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // 1. æŸ¥è¯¢è®¢å•
    order, err := os.getOrderForUpdate(ctx, tx, orderID)
    if err != nil {
        return err
    }

    // 2. æ£€æŸ¥è®¢å•çŠ¶æ€
    if order.Status != OrderStatusPending {
        return ErrCannotCancelOrder
    }

    // 3. æ›´æ–°è®¢å•çŠ¶æ€
    order.Status = OrderStatusCancelled
    order.CancelledAt = time.Now()
    if err := os.updateOrderInTx(ctx, tx, order); err != nil {
        return err
    }

    // 4. æ¢å¤åº“å­˜
    items, err := os.getOrderItems(ctx, orderID)
    if err != nil {
        return err
    }

    for _, item := range items {
        if err := os.inventorySvc.Restore(ctx, item.ProductID, item.Quantity); err != nil {
            return err
        }
    }

    // æäº¤äº‹åŠ¡
    if err := tx.Commit(); err != nil {
        return err
    }

    // 5. å‘é€è®¢å•å–æ¶ˆäº‹ä»¶
    os.messageMQ.Publish("order.cancelled", order)

    return nil
}

type CreateOrderRequest struct {
    UserID      int64
    Items       []*OrderItemRequest
    TotalAmount float64
}

type OrderItemRequest struct {
    ProductID int64
    Quantity  int
    Price     float64
}

type Order struct {
    ID          int64
    UserID      int64
    TotalAmount float64
    Status      OrderStatus
    CreatedAt   time.Time
    PaidAt      time.Time
    CancelledAt time.Time
}

type OrderItem struct {
    ID        int64
    OrderID   int64
    ProductID int64
    Quantity  int
    Price     float64
}

func (os *OrderService) insertOrder(ctx context.Context, tx *sql.Tx, order *Order) error {
    return nil
}

func (os *OrderService) insertOrderItem(ctx context.Context, tx *sql.Tx, item *OrderItem) error {
    return nil
}

func (os *OrderService) getOrder(ctx context.Context, orderID int64) (*Order, error) {
    return nil, nil
}

func (os *OrderService) getOrderForUpdate(ctx context.Context, tx *sql.Tx, orderID int64) (*Order, error) {
    return nil, nil
}

func (os *OrderService) updateOrder(ctx context.Context, order *Order) error {
    return nil
}

func (os *OrderService) updateOrderInTx(ctx context.Context, tx *sql.Tx, order *Order) error {
    return nil
}

func (os *OrderService) getOrderItems(ctx context.Context, orderID int64) ([]*OrderItem, error) {
    return nil, nil
}

type PaymentService interface {
    Pay(ctx context.Context, req *PaymentRequest) (*PaymentResponse, error)
}

type PaymentRequest struct {
    OrderID int64
    Amount  float64
    Method  string
}

type PaymentResponse struct {
    Success bool
}

type InventoryService interface {
    Deduct(ctx context.Context, productID int64, quantity int) error
    Restore(ctx context.Context, productID int64, quantity int) error
}

type MessageQueue interface {
    Publish(topic string, data interface{}) error
}

var (
    ErrInvalidOrderStatus = &struct{ error }{}
    ErrCannotCancelOrder  = &struct{ error }{}
)
```

---

## æœ€ä½³å®è·µ

### 1. é«˜å¹¶å‘å¤„ç†

- âœ… Redisç¼“å­˜çƒ­ç‚¹æ•°æ®
- âœ… æ•°æ®åº“è¯»å†™åˆ†ç¦»
- âœ… é™æµç†”æ–­
- âœ… CDNåŠ é€Ÿé™æ€èµ„æº

### 2. æ•°æ®ä¸€è‡´æ€§

- âœ… åˆ†å¸ƒå¼äº‹åŠ¡ (Saga/TCC)
- âœ… æœ€ç»ˆä¸€è‡´æ€§
- âœ… å¹‚ç­‰æ€§è®¾è®¡
- âœ… è¡¥å¿æœºåˆ¶

### 3. å®‰å…¨æ€§

- âœ… é˜²åˆ·é™æµ
- âœ… é˜²é‡å¤æäº¤
- âœ… æ¥å£ç­¾åéªŒè¯
- âœ… æ•æ„Ÿæ•°æ®åŠ å¯†

### 4. å¯è§‚æµ‹æ€§

- âœ… åˆ†å¸ƒå¼è¿½è¸ª
- âœ… å®æ—¶ç›‘æ§å‘Šè­¦
- âœ… æ—¥å¿—èšåˆåˆ†æ
- âœ… æ€§èƒ½æŒ‡æ ‡ç»Ÿè®¡

---

**ç›¸å…³æ–‡æ¡£**:

- [ç§’æ€ç³»ç»Ÿè®¾è®¡](./08-ç§’æ€ç³»ç»Ÿ.md)
- [è®¢å•ç³»ç»Ÿè®¾è®¡](./09-è®¢å•ç³»ç»Ÿ.md)
- [åˆ†å¸ƒå¼äº‹åŠ¡](../advanced/26-Go-1.25.3åˆ†å¸ƒå¼äº‹åŠ¡å®Œæ•´å®æˆ˜.md)
- [ç¼“å­˜æ¶æ„](../advanced/21-Go-1.25.3åˆ†å¸ƒå¼ç¼“å­˜æ¶æ„å®Œæ•´å®æˆ˜.md)

**ç»´æŠ¤è€…**: E-Commerce Team
**æœ€åæ›´æ–°**: 2025-10-29
