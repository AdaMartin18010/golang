# 状态同步机制

**版本**: v1.0
**更新日期**: 2025-11-11
**适用于**: Go 1.25.3

---
## 📋 目录

- [状态同步机制](#状态同步机制)
  - [同步策略](#同步策略)
  - [帧同步](#帧同步)
  - [状态同步](#状态同步)
  - [混合方案](#混合方案)
  - [优化技术](#优化技术)

---

## 同步策略

### 对比分析

| 特性 | 帧同步 | 状态同步 |
|------|--------|----------|
| 实现复杂度 | 低 | 高 |
| 带宽消耗 | 低 | 高 |
| 一致性 | 完全一致 | 可能不一致 |
| 延迟要求 | 较高 | 较低 |
| 适用场景 | RTS, MOBA | FPS, MMO |
| 回放支持 | 完美 | 困难 |

### 选择建议

- **帧同步**: 强一致性要求，带宽敏感
- **状态同步**: 实时性要求高，可容忍小误差
- **混合方案**: 结合两者优势

---

## 帧同步

详见: [游戏开发 - 帧同步](./02-游戏开发.md#1-帧同步)

### 实现细节

```go
package lockstep

import (
    "Context"
    "sync"
    "time"
)

// LockstepEngine 锁步同步引擎
type LockstepEngine struct {
    frameRate     int
    currentFrame  int64
    inputBuffer   map[string]map[int64]*Input // playerID -> frameNum -> input
    frameHistory  map[int64]*FrameData        // frameNum -> frame data
    players       map[string]*PlayerState
    confirmations map[int64]map[string]bool   // frameNum -> playerID -> confirmed
    mu            sync.RWMutex
    broadcaster   Broadcaster
}

// NewLockstepEngine 创建锁步引擎
func NewLockstepEngine(frameRate int, broadcaster Broadcaster) *LockstepEngine {
    return &LockstepEngine{
        frameRate:     frameRate,
        inputBuffer:   make(map[string]map[int64]*Input),
        frameHistory:  make(map[int64]*FrameData),
        players:       make(map[string]*PlayerState),
        confirmations: make(map[int64]map[string]bool),
        broadcaster:   broadcaster,
    }
}

// Start 启动引擎
func (le *LockstepEngine) Start(ctx Context.Context) {
    frameDuration := time.Second / time.Duration(le.frameRate)
    ticker := time.NewTicker(frameDuration)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            le.advanceFrame()
        case <-ctx.Done():
            return
        }
    }
}

// SubmitInput 提交玩家输入
func (le *LockstepEngine) SubmitInput(playerID string, input *Input) error {
    le.mu.Lock()
    defer le.mu.Unlock()

    targetFrame := le.currentFrame + 2 // 提前2帧提交

    if le.inputBuffer[playerID] == nil {
        le.inputBuffer[playerID] = make(map[int64]*Input)
    }

    le.inputBuffer[playerID][targetFrame] = input

    return nil
}

// advanceFrame 推进帧
func (le *LockstepEngine) advanceFrame() {
    le.mu.Lock()
    defer le.mu.Unlock()

    le.currentFrame++

    // 等待所有玩家输入
    if !le.allInputsReceived(le.currentFrame) {
        // 使用上一帧输入或默认输入
        le.fillMissingInputs(le.currentFrame)
    }

    // 收集当前帧所有输入
    frameInputs := le.collectFrameInputs(le.currentFrame)

    // 执行游戏逻辑
    le.executeFrame(frameInputs)

    // 创建帧数据
    frameData := &FrameData{
        FrameNum:  le.currentFrame,
        Inputs:    frameInputs,
        Timestamp: time.Now(),
    }

    le.frameHistory[le.currentFrame] = frameData

    // 广播帧数据给所有玩家
    le.broadcaster.BroadcastFrame(frameData)

    // 清理旧数据
    if le.currentFrame > 300 {
        delete(le.frameHistory, le.currentFrame-300)
    }
}

func (le *LockstepEngine) allInputsReceived(frameNum int64) bool {
    for playerID := range le.players {
        if le.inputBuffer[playerID] == nil || le.inputBuffer[playerID][frameNum] == nil {
            return false
        }
    }
    return true
}

func (le *LockstepEngine) fillMissingInputs(frameNum int64) {
    for playerID := range le.players {
        if le.inputBuffer[playerID] == nil || le.inputBuffer[playerID][frameNum] == nil {
            // 使用上一帧输入或空输入
            prevInput := le.getPlayerInput(playerID, frameNum-1)
            if prevInput == nil {
                prevInput = &Input{Action: "idle"}
            }

            if le.inputBuffer[playerID] == nil {
                le.inputBuffer[playerID] = make(map[int64]*Input)
            }
            le.inputBuffer[playerID][frameNum] = prevInput
        }
    }
}

func (le *LockstepEngine) getPlayerInput(playerID string, frameNum int64) *Input {
    if le.inputBuffer[playerID] == nil {
        return nil
    }
    return le.inputBuffer[playerID][frameNum]
}

func (le *LockstepEngine) collectFrameInputs(frameNum int64) []*PlayerInput {
    inputs := make([]*PlayerInput, 0, len(le.players))

    for playerID := range le.players {
        input := le.getPlayerInput(playerID, frameNum)
        if input != nil {
            inputs = append(inputs, &PlayerInput{
                PlayerID: playerID,
                Input:    input,
            })
        }
    }

    return inputs
}

func (le *LockstepEngine) executeFrame(inputs []*PlayerInput) {
    // 按确定性顺序执行输入
    for _, pi := range inputs {
        player := le.players[pi.PlayerID]
        if player == nil {
            continue
        }

        // 执行游戏逻辑
        switch pi.Input.Action {
        case "move":
            player.Position.X += pi.Input.DeltaX
            player.Position.Y += pi.Input.DeltaY
        case "attack":
            // 处理攻击逻辑
        case "idle":
            // 空闲状态
        }

        player.LastUpdate = time.Now()
    }
}

// GetGameState 获取游戏状态
func (le *LockstepEngine) GetGameState() *GameState {
    le.mu.RLock()
    defer le.mu.RUnlock()

    state := &GameState{
        FrameNum:  le.currentFrame,
        Players:   make(map[string]*PlayerState),
        Timestamp: time.Now(),
    }

    for id, player := range le.players {
        // 深拷贝玩家状态
        state.Players[id] = &PlayerState{
            Position: player.Position,
            Health:   player.Health,
            Score:    player.Score,
        }
    }

    return state
}

// Rollback 回滚到指定帧
func (le *LockstepEngine) Rollback(targetFrame int64) error {
    le.mu.Lock()
    defer le.mu.Unlock()

    if targetFrame > le.currentFrame {
        return ErrInvalidFrame
    }

    // 重置状态到目标帧之前
    le.resetToFrame(targetFrame - 1)

    // 重新执行从目标帧到当前帧的所有输入
    for frame := targetFrame; frame <= le.currentFrame; frame++ {
        inputs := le.collectFrameInputs(frame)
        le.executeFrame(inputs)
    }

    return nil
}

func (le *LockstepEngine) resetToFrame(frameNum int64) {
    // 这里应该从快照恢复状态
    // 简化实现，实际项目中需要保存定期快照
}

type Input struct {
    Action string
    DeltaX float64
    DeltaY float64
    Data   map[string]interface{}
}

type PlayerInput struct {
    PlayerID string
    Input    *Input
}

type FrameData struct {
    FrameNum  int64
    Inputs    []*PlayerInput
    Timestamp time.Time
}

type PlayerState struct {
    Position   Position
    Health     int
    Score      int
    LastUpdate time.Time
}

type Position struct {
    X, Y, Z float64
}

type GameState struct {
    FrameNum  int64
    Players   map[string]*PlayerState
    Timestamp time.Time
}

type Broadcaster interface {
    BroadcastFrame(frame *FrameData)
}

var ErrInvalidFrame = &struct{ error }{}
```

### 确定性模拟

```go
package deterministic

import (
    "math"
    "math/rand"
)

// DeterministicRandom 确定性随机数生成器
type DeterministicRandom struct {
    seed int64
    rng  *rand.Rand
}

// NewDeterministicRandom 创建确定性随机数生成器
func NewDeterministicRandom(seed int64) *DeterministicRandom {
    source := rand.NewSource(seed)
    return &DeterministicRandom{
        seed: seed,
        rng:  rand.New(source),
    }
}

// Next 生成下一个随机数
func (dr *DeterministicRandom) Next() int {
    return dr.rng.Int()
}

// NextFloat 生成浮点随机数
func (dr *DeterministicRandom) NextFloat() float64 {
    return dr.rng.Float64()
}

// Reset 重置随机数生成器
func (dr *DeterministicRandom) Reset() {
    source := rand.NewSource(dr.seed)
    dr.rng = rand.New(source)
}

// FixedPointMath 定点数数学运算
// 避免浮点数精度问题，确保跨平台一致性
type FixedPointMath struct {
    precision int64 // 精度，如 1000 表示3位小数
}

func NewFixedPointMath(decimalPlaces int) *FixedPointMath {
    return &FixedPointMath{
        precision: int64(math.Pow10(decimalPlaces)),
    }
}

// ToFixed 转换为定点数
func (fpm *FixedPointMath) ToFixed(f float64) int64 {
    return int64(f * float64(fpm.precision))
}

// ToFloat 转换为浮点数
func (fpm *FixedPointMath) ToFloat(i int64) float64 {
    return float64(i) / float64(fpm.precision)
}

// Add 定点数加法
func (fpm *FixedPointMath) Add(a, b int64) int64 {
    return a + b
}

// Multiply 定点数乘法
func (fpm *FixedPointMath) Multiply(a, b int64) int64 {
    return (a * b) / fpm.precision
}

// Divide 定点数除法
func (fpm *FixedPointMath) Divide(a, b int64) int64 {
    return (a * fpm.precision) / b
}
```

---

## 状态同步

详见: [游戏开发 - 状态同步](./02-游戏开发.md#2-状态同步)

### 快照与插值

```go
package snapshot

import (
    "sort"
    "sync"
    "time"
)

// SnapshotManager 快照管理器
type SnapshotManager struct {
    snapshots    []*Snapshot
    maxSnapshots int
    mu           sync.RWMutex
}

// NewSnapshotManager 创建快照管理器
func NewSnapshotManager(maxSnapshots int) *SnapshotManager {
    return &SnapshotManager{
        snapshots:    make([]*Snapshot, 0, maxSnapshots),
        maxSnapshots: maxSnapshots,
    }
}

// AddSnapshot 添加快照
func (sm *SnapshotManager) AddSnapshot(snapshot *Snapshot) {
    sm.mu.Lock()
    defer sm.mu.Unlock()

    sm.snapshots = append(sm.snapshots, snapshot)

    // 保持快照数量限制
    if len(sm.snapshots) > sm.maxSnapshots {
        sm.snapshots = sm.snapshots[1:]
    }

    // 保持时间顺序
    sort.Slice(sm.snapshots, func(i, j int) bool {
        return sm.snapshots[i].Timestamp.Before(sm.snapshots[j].Timestamp)
    })
}

// GetSnapshotAt 获取指定时间的快照
func (sm *SnapshotManager) GetSnapshotAt(t time.Time) *Snapshot {
    sm.mu.RLock()
    defer sm.mu.RUnlock()

    // 找到最接近的快照
    for i := len(sm.snapshots) - 1; i >= 0; i-- {
        if !sm.snapshots[i].Timestamp.After(t) {
            return sm.snapshots[i]
        }
    }

    return nil
}

// GetInterpolatedState 获取插值状态
func (sm *SnapshotManager) GetInterpolatedState(t time.Time, playerID string) *PlayerSnapshot {
    sm.mu.RLock()
    defer sm.mu.RUnlock()

    // 找到时间点前后的两个快照
    var prev, next *Snapshot
    for i := 0; i < len(sm.snapshots); i++ {
        if sm.snapshots[i].Timestamp.Before(t) {
            prev = sm.snapshots[i]
            if i+1 < len(sm.snapshots) {
                next = sm.snapshots[i+1]
            }
        }
    }

    if prev == nil {
        if len(sm.snapshots) > 0 {
            return sm.snapshots[0].Players[playerID]
        }
        return nil
    }

    if next == nil {
        return prev.Players[playerID]
    }

    // 执行插值
    return interpolatePlayerState(prev.Players[playerID], next.Players[playerID], prev.Timestamp, next.Timestamp, t)
}

// interpolatePlayerState 插值玩家状态
func interpolatePlayerState(prev, next *PlayerSnapshot, prevTime, nextTime, targetTime time.Time) *PlayerSnapshot {
    if prev == nil || next == nil {
        return prev
    }

    // 计算插值因子
    totalDuration := nextTime.Sub(prevTime).Seconds()
    elapsed := targetTime.Sub(prevTime).Seconds()
    factor := elapsed / totalDuration

    // 线性插值
    return &PlayerSnapshot{
        Position: Vector3{
            X: prev.Position.X + (next.Position.X-prev.Position.X)*factor,
            Y: prev.Position.Y + (next.Position.Y-prev.Position.Y)*factor,
            Z: prev.Position.Z + (next.Position.Z-prev.Position.Z)*factor,
        },
        Velocity: Vector3{
            X: prev.Velocity.X + (next.Velocity.X-prev.Velocity.X)*factor,
            Y: prev.Velocity.Y + (next.Velocity.Y-prev.Velocity.Y)*factor,
            Z: prev.Velocity.Z + (next.Velocity.Z-prev.Velocity.Z)*factor,
        },
        Rotation: Quaternion{
            X: prev.Rotation.X + (next.Rotation.X-prev.Rotation.X)*factor,
            Y: prev.Rotation.Y + (next.Rotation.Y-prev.Rotation.Y)*factor,
            Z: prev.Rotation.Z + (next.Rotation.Z-prev.Rotation.Z)*factor,
            W: prev.Rotation.W + (next.Rotation.W-prev.Rotation.W)*factor,
        },
        Health: int(float64(prev.Health) + float64(next.Health-prev.Health)*factor),
    }
}

type Snapshot struct {
    Timestamp time.Time
    FrameNum  int64
    Players   map[string]*PlayerSnapshot
}

type PlayerSnapshot struct {
    Position Vector3
    Velocity Vector3
    Rotation Quaternion
    Health   int
}

type Vector3 struct {
    X, Y, Z float64
}

type Quaternion struct {
    X, Y, Z, W float64
}
```

### 客户端预测

```go
package prediction

import (
    "sync"
    "time"
)

// ClientPredictor 客户端预测器
type ClientPredictor struct {
    localState      *LocalState
    predictedInputs []* PredictedInput
    confirmedFrame  int64
    mu              sync.RWMutex
}

// NewClientPredictor 创建客户端预测器
func NewClientPredictor() *ClientPredictor {
    return &ClientPredictor{
        localState:      NewLocalState(),
        predictedInputs: make([]*PredictedInput, 0),
    }
}

// PredictInput 预测输入
func (cp *ClientPredictor) PredictInput(input *Input) {
    cp.mu.Lock()
    defer cp.mu.Unlock()

    // 保存预测输入
    predicted := &PredictedInput{
        FrameNum:  cp.localState.CurrentFrame + 1,
        Input:     input,
        Timestamp: time.Now(),
    }

    cp.predictedInputs = append(cp.predictedInputs, predicted)

    // 立即应用到本地状态
    cp.applyInput(input)
    cp.localState.CurrentFrame++
}

// ReconcileWithServer 与服务器状态和解
func (cp *ClientPredictor) ReconcileWithServer(serverState *ServerState) {
    cp.mu.Lock()
    defer cp.mu.Unlock()

    // 检查本地预测是否正确
    if cp.localState.MatchesServer(serverState) {
        // 预测正确，更新确认帧
        cp.confirmedFrame = serverState.FrameNum
        cp.cleanupConfirmedInputs(serverState.FrameNum)
        return
    }

    // 预测错误，需要回滚
    cp.rollbackAndReplay(serverState)
}

func (cp *ClientPredictor) rollbackAndReplay(serverState *ServerState) {
    // 1. 回滚到服务器状态
    cp.localState.CopyFrom(serverState)

    // 2. 重新应用未确认的输入
    unconfirmedInputs := cp.getUnconfirmedInputs(serverState.FrameNum)
    for _, predicted := range unconfirmedInputs {
        cp.applyInput(predicted.Input)
        cp.localState.CurrentFrame++
    }
}

func (cp *ClientPredictor) applyInput(input *Input) {
    // 应用输入到本地状态
    switch input.Action {
    case "move":
        cp.localState.Player.Position.X += input.DeltaX
        cp.localState.Player.Position.Y += input.DeltaY
    case "jump":
        cp.localState.Player.Velocity.Y = input.JumpForce
    }
}

func (cp *ClientPredictor) getUnconfirmedInputs(confirmedFrame int64) []*PredictedInput {
    unconfirmed := make([]*PredictedInput, 0)
    for _, predicted := range cp.predictedInputs {
        if predicted.FrameNum > confirmedFrame {
            unconfirmed = append(unconfirmed, predicted)
        }
    }
    return unconfirmed
}

func (cp *ClientPredictor) cleanupConfirmedInputs(confirmedFrame int64) {
    newInputs := make([]*PredictedInput, 0)
    for _, predicted := range cp.predictedInputs {
        if predicted.FrameNum > confirmedFrame {
            newInputs = append(newInputs, predicted)
        }
    }
    cp.predictedInputs = newInputs
}

type LocalState struct {
    CurrentFrame int64
    Player       *PlayerState
}

func NewLocalState() *LocalState {
    return &LocalState{
        Player: &PlayerState{},
    }
}

func (ls *LocalState) MatchesServer(serverState *ServerState) bool {
    // 比较本地状态与服务器状态
    // 允许小误差
    threshold := 0.1

    if ls.CurrentFrame != serverState.FrameNum {
        return false
    }

    posDiff := ls.Player.Position.Distance(serverState.Player.Position)
    return posDiff < threshold
}

func (ls *LocalState) CopyFrom(serverState *ServerState) {
    ls.CurrentFrame = serverState.FrameNum
    ls.Player.Position = serverState.Player.Position
    ls.Player.Velocity = serverState.Player.Velocity
    ls.Player.Health = serverState.Player.Health
}

type PredictedInput struct {
    FrameNum  int64
    Input     *Input
    Timestamp time.Time
}

type Input struct {
    Action    string
    DeltaX    float64
    DeltaY    float64
    JumpForce float64
}

type PlayerState struct {
    Position Vector3
    Velocity Vector3
    Health   int
}

func (v Vector3) Distance(other Vector3) float64 {
    dx := v.X - other.X
    dy := v.Y - other.Y
    dz := v.Z - other.Z
    return dx*dx + dy*dy + dz*dz
}

type ServerState struct {
    FrameNum int64
    Player   *PlayerState
}
```

---

## 混合方案

### 分层同步

```go
package hybrid

// HybridSyncEngine 混合同步引擎
type HybridSyncEngine struct {
    lockstep *LockstepEngine // 关键逻辑用帧同步
    stateMgr *StateManager   // 表现用状态同步
}

// NewHybridSyncEngine 创建混合同步引擎
func NewHybridSyncEngine() *HybridSyncEngine {
    return &HybridSyncEngine{
        lockstep: NewLockstepEngine(10),  // 10帧/秒的逻辑帧
        stateMgr: NewStateManager(30),    // 30帧/秒的状态同步
    }
}

// Update 更新
func (hse *HybridSyncEngine) Update() {
    // 执行逻辑帧
    if hse.lockstep.ShouldUpdate() {
        hse.lockstep.Update()
    }

    // 同步表现状态
    if hse.stateMgr.ShouldSync() {
        state := hse.lockstep.GetState()
        hse.stateMgr.SyncState(state)
    }
}

type LockstepEngine struct {
    logicFrameRate int
    // ...
}

func NewLockstepEngine(frameRate int) *LockstepEngine {
    return &LockstepEngine{logicFrameRate: frameRate}
}

func (le *LockstepEngine) ShouldUpdate() bool {
    return true // 简化实现
}

func (le *LockstepEngine) Update() {
    // 执行确定性逻辑
}

func (le *LockstepEngine) GetState() interface{} {
    return nil
}

type StateManager struct {
    syncRate int
    // ...
}

func NewStateManager(syncRate int) *StateManager {
    return &StateManager{syncRate: syncRate}
}

func (sm *StateManager) ShouldSync() bool {
    return true // 简化实现
}

func (sm *StateManager) SyncState(state interface{}) {
    // 同步表现状态
}
```

---

## 优化技术

### 1. 差量更新

```go
// DeltaCompression 差量压缩
type DeltaCompression struct {
    lastState *GameState
}

func (dc *DeltaCompression) Compress(currentState *GameState) *DeltaUpdate {
    if dc.lastState == nil {
        dc.lastState = currentState
        return &DeltaUpdate{FullState: currentState}
    }

    delta := &DeltaUpdate{
        Changes: make(map[string]*StateChange),
    }

    // 只发送变化的部分
    for id, player := range currentState.Players {
        lastPlayer := dc.lastState.Players[id]
        if lastPlayer == nil || !player.Equals(lastPlayer) {
            delta.Changes[id] = &StateChange{
                PlayerID: id,
                NewState: player,
            }
        }
    }

    dc.lastState = currentState
    return delta
}

type DeltaUpdate struct {
    FullState *GameState
    Changes   map[string]*StateChange
}

type StateChange struct {
    PlayerID string
    NewState *PlayerState
}

func (ps *PlayerState) Equals(other *PlayerState) bool {
    return ps.Position == other.Position &&
        ps.Health == other.Health &&
        ps.Score == other.Score
}
```

### 2. 兴趣管理 (AOI)
