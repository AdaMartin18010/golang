# çŠ¶æ€åŒæ­¥æœºåˆ¶

> æ¸¸æˆçŠ¶æ€åŒæ­¥ç³»ç»Ÿè®¾è®¡ä¸å®ç°

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨Goç‰ˆæœ¬**: Go 1.25.3+

---

## ğŸ“‹ ç›®å½•

- [çŠ¶æ€åŒæ­¥æœºåˆ¶](#çŠ¶æ€åŒæ­¥æœºåˆ¶)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [åŒæ­¥ç­–ç•¥](#åŒæ­¥ç­–ç•¥)
    - [å¯¹æ¯”åˆ†æ](#å¯¹æ¯”åˆ†æ)
    - [é€‰æ‹©å»ºè®®](#é€‰æ‹©å»ºè®®)
  - [å¸§åŒæ­¥](#å¸§åŒæ­¥)
    - [å®ç°ç»†èŠ‚](#å®ç°ç»†èŠ‚)
    - [ç¡®å®šæ€§æ¨¡æ‹Ÿ](#ç¡®å®šæ€§æ¨¡æ‹Ÿ)
  - [çŠ¶æ€åŒæ­¥](#çŠ¶æ€åŒæ­¥)
    - [å¿«ç…§ä¸æ’å€¼](#å¿«ç…§ä¸æ’å€¼)
    - [å®¢æˆ·ç«¯é¢„æµ‹](#å®¢æˆ·ç«¯é¢„æµ‹)
  - [æ··åˆæ–¹æ¡ˆ](#æ··åˆæ–¹æ¡ˆ)
    - [åˆ†å±‚åŒæ­¥](#åˆ†å±‚åŒæ­¥)
  - [ä¼˜åŒ–æŠ€æœ¯](#ä¼˜åŒ–æŠ€æœ¯)
    - [1. å·®é‡æ›´æ–°](#1-å·®é‡æ›´æ–°)
    - [2. å…´è¶£ç®¡ç† (AOI)](#2-å…´è¶£ç®¡ç†-aoi)

---

## åŒæ­¥ç­–ç•¥

### å¯¹æ¯”åˆ†æ

| ç‰¹æ€§ | å¸§åŒæ­¥ | çŠ¶æ€åŒæ­¥ |
|------|--------|----------|
| å®ç°å¤æ‚åº¦ | ä½ | é«˜ |
| å¸¦å®½æ¶ˆè€— | ä½ | é«˜ |
| ä¸€è‡´æ€§ | å®Œå…¨ä¸€è‡´ | å¯èƒ½ä¸ä¸€è‡´ |
| å»¶è¿Ÿè¦æ±‚ | è¾ƒé«˜ | è¾ƒä½ |
| é€‚ç”¨åœºæ™¯ | RTS, MOBA | FPS, MMO |
| å›æ”¾æ”¯æŒ | å®Œç¾ | å›°éš¾ |

### é€‰æ‹©å»ºè®®

- **å¸§åŒæ­¥**: å¼ºä¸€è‡´æ€§è¦æ±‚ï¼Œå¸¦å®½æ•æ„Ÿ
- **çŠ¶æ€åŒæ­¥**: å®æ—¶æ€§è¦æ±‚é«˜ï¼Œå¯å®¹å¿å°è¯¯å·®
- **æ··åˆæ–¹æ¡ˆ**: ç»“åˆä¸¤è€…ä¼˜åŠ¿

---

## å¸§åŒæ­¥

è¯¦è§: [æ¸¸æˆå¼€å‘ - å¸§åŒæ­¥](./02-æ¸¸æˆå¼€å‘.md#1-å¸§åŒæ­¥)

### å®ç°ç»†èŠ‚

```go
package lockstep

import (
    "context"
    "sync"
    "time"
)

// LockstepEngine é”æ­¥åŒæ­¥å¼•æ“
type LockstepEngine struct {
    frameRate     int
    currentFrame  int64
    inputBuffer   map[string]map[int64]*Input // playerID -> frameNum -> input
    frameHistory  map[int64]*FrameData        // frameNum -> frame data
    players       map[string]*PlayerState
    confirmations map[int64]map[string]bool   // frameNum -> playerID -> confirmed
    mu            sync.RWMutex
    broadcaster   Broadcaster
}

// NewLockstepEngine åˆ›å»ºé”æ­¥å¼•æ“
func NewLockstepEngine(frameRate int, broadcaster Broadcaster) *LockstepEngine {
    return &LockstepEngine{
        frameRate:     frameRate,
        inputBuffer:   make(map[string]map[int64]*Input),
        frameHistory:  make(map[int64]*FrameData),
        players:       make(map[string]*PlayerState),
        confirmations: make(map[int64]map[string]bool),
        broadcaster:   broadcaster,
    }
}

// Start å¯åŠ¨å¼•æ“
func (le *LockstepEngine) Start(ctx context.Context) {
    frameDuration := time.Second / time.Duration(le.frameRate)
    ticker := time.NewTicker(frameDuration)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            le.advanceFrame()
        case <-ctx.Done():
            return
        }
    }
}

// SubmitInput æäº¤ç©å®¶è¾“å…¥
func (le *LockstepEngine) SubmitInput(playerID string, input *Input) error {
    le.mu.Lock()
    defer le.mu.Unlock()

    targetFrame := le.currentFrame + 2 // æå‰2å¸§æäº¤

    if le.inputBuffer[playerID] == nil {
        le.inputBuffer[playerID] = make(map[int64]*Input)
    }

    le.inputBuffer[playerID][targetFrame] = input

    return nil
}

// advanceFrame æ¨è¿›å¸§
func (le *LockstepEngine) advanceFrame() {
    le.mu.Lock()
    defer le.mu.Unlock()

    le.currentFrame++

    // ç­‰å¾…æ‰€æœ‰ç©å®¶è¾“å…¥
    if !le.allInputsReceived(le.currentFrame) {
        // ä½¿ç”¨ä¸Šä¸€å¸§è¾“å…¥æˆ–é»˜è®¤è¾“å…¥
        le.fillMissingInputs(le.currentFrame)
    }

    // æ”¶é›†å½“å‰å¸§æ‰€æœ‰è¾“å…¥
    frameInputs := le.collectFrameInputs(le.currentFrame)

    // æ‰§è¡Œæ¸¸æˆé€»è¾‘
    le.executeFrame(frameInputs)

    // åˆ›å»ºå¸§æ•°æ®
    frameData := &FrameData{
        FrameNum:  le.currentFrame,
        Inputs:    frameInputs,
        Timestamp: time.Now(),
    }

    le.frameHistory[le.currentFrame] = frameData

    // å¹¿æ’­å¸§æ•°æ®ç»™æ‰€æœ‰ç©å®¶
    le.broadcaster.BroadcastFrame(frameData)

    // æ¸…ç†æ—§æ•°æ®
    if le.currentFrame > 300 {
        delete(le.frameHistory, le.currentFrame-300)
    }
}

func (le *LockstepEngine) allInputsReceived(frameNum int64) bool {
    for playerID := range le.players {
        if le.inputBuffer[playerID] == nil || le.inputBuffer[playerID][frameNum] == nil {
            return false
        }
    }
    return true
}

func (le *LockstepEngine) fillMissingInputs(frameNum int64) {
    for playerID := range le.players {
        if le.inputBuffer[playerID] == nil || le.inputBuffer[playerID][frameNum] == nil {
            // ä½¿ç”¨ä¸Šä¸€å¸§è¾“å…¥æˆ–ç©ºè¾“å…¥
            prevInput := le.getPlayerInput(playerID, frameNum-1)
            if prevInput == nil {
                prevInput = &Input{Action: "idle"}
            }

            if le.inputBuffer[playerID] == nil {
                le.inputBuffer[playerID] = make(map[int64]*Input)
            }
            le.inputBuffer[playerID][frameNum] = prevInput
        }
    }
}

func (le *LockstepEngine) getPlayerInput(playerID string, frameNum int64) *Input {
    if le.inputBuffer[playerID] == nil {
        return nil
    }
    return le.inputBuffer[playerID][frameNum]
}

func (le *LockstepEngine) collectFrameInputs(frameNum int64) []*PlayerInput {
    inputs := make([]*PlayerInput, 0, len(le.players))

    for playerID := range le.players {
        input := le.getPlayerInput(playerID, frameNum)
        if input != nil {
            inputs = append(inputs, &PlayerInput{
                PlayerID: playerID,
                Input:    input,
            })
        }
    }

    return inputs
}

func (le *LockstepEngine) executeFrame(inputs []*PlayerInput) {
    // æŒ‰ç¡®å®šæ€§é¡ºåºæ‰§è¡Œè¾“å…¥
    for _, pi := range inputs {
        player := le.players[pi.PlayerID]
        if player == nil {
            continue
        }

        // æ‰§è¡Œæ¸¸æˆé€»è¾‘
        switch pi.Input.Action {
        case "move":
            player.Position.X += pi.Input.DeltaX
            player.Position.Y += pi.Input.DeltaY
        case "attack":
            // å¤„ç†æ”»å‡»é€»è¾‘
        case "idle":
            // ç©ºé—²çŠ¶æ€
        }

        player.LastUpdate = time.Now()
    }
}

// GetGameState è·å–æ¸¸æˆçŠ¶æ€
func (le *LockstepEngine) GetGameState() *GameState {
    le.mu.RLock()
    defer le.mu.RUnlock()

    state := &GameState{
        FrameNum:  le.currentFrame,
        Players:   make(map[string]*PlayerState),
        Timestamp: time.Now(),
    }

    for id, player := range le.players {
        // æ·±æ‹·è´ç©å®¶çŠ¶æ€
        state.Players[id] = &PlayerState{
            Position: player.Position,
            Health:   player.Health,
            Score:    player.Score,
        }
    }

    return state
}

// Rollback å›æ»šåˆ°æŒ‡å®šå¸§
func (le *LockstepEngine) Rollback(targetFrame int64) error {
    le.mu.Lock()
    defer le.mu.Unlock()

    if targetFrame > le.currentFrame {
        return ErrInvalidFrame
    }

    // é‡ç½®çŠ¶æ€åˆ°ç›®æ ‡å¸§ä¹‹å‰
    le.resetToFrame(targetFrame - 1)

    // é‡æ–°æ‰§è¡Œä»ç›®æ ‡å¸§åˆ°å½“å‰å¸§çš„æ‰€æœ‰è¾“å…¥
    for frame := targetFrame; frame <= le.currentFrame; frame++ {
        inputs := le.collectFrameInputs(frame)
        le.executeFrame(inputs)
    }

    return nil
}

func (le *LockstepEngine) resetToFrame(frameNum int64) {
    // è¿™é‡Œåº”è¯¥ä»å¿«ç…§æ¢å¤çŠ¶æ€
    // ç®€åŒ–å®ç°ï¼Œå®é™…é¡¹ç›®ä¸­éœ€è¦ä¿å­˜å®šæœŸå¿«ç…§
}

type Input struct {
    Action string
    DeltaX float64
    DeltaY float64
    Data   map[string]interface{}
}

type PlayerInput struct {
    PlayerID string
    Input    *Input
}

type FrameData struct {
    FrameNum  int64
    Inputs    []*PlayerInput
    Timestamp time.Time
}

type PlayerState struct {
    Position   Position
    Health     int
    Score      int
    LastUpdate time.Time
}

type Position struct {
    X, Y, Z float64
}

type GameState struct {
    FrameNum  int64
    Players   map[string]*PlayerState
    Timestamp time.Time
}

type Broadcaster interface {
    BroadcastFrame(frame *FrameData)
}

var ErrInvalidFrame = &struct{ error }{}
```

### ç¡®å®šæ€§æ¨¡æ‹Ÿ

```go
package deterministic

import (
    "math"
    "math/rand"
)

// DeterministicRandom ç¡®å®šæ€§éšæœºæ•°ç”Ÿæˆå™¨
type DeterministicRandom struct {
    seed int64
    rng  *rand.Rand
}

// NewDeterministicRandom åˆ›å»ºç¡®å®šæ€§éšæœºæ•°ç”Ÿæˆå™¨
func NewDeterministicRandom(seed int64) *DeterministicRandom {
    source := rand.NewSource(seed)
    return &DeterministicRandom{
        seed: seed,
        rng:  rand.New(source),
    }
}

// Next ç”Ÿæˆä¸‹ä¸€ä¸ªéšæœºæ•°
func (dr *DeterministicRandom) Next() int {
    return dr.rng.Int()
}

// NextFloat ç”Ÿæˆæµ®ç‚¹éšæœºæ•°
func (dr *DeterministicRandom) NextFloat() float64 {
    return dr.rng.Float64()
}

// Reset é‡ç½®éšæœºæ•°ç”Ÿæˆå™¨
func (dr *DeterministicRandom) Reset() {
    source := rand.NewSource(dr.seed)
    dr.rng = rand.New(source)
}

// FixedPointMath å®šç‚¹æ•°æ•°å­¦è¿ç®—
// é¿å…æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜ï¼Œç¡®ä¿è·¨å¹³å°ä¸€è‡´æ€§
type FixedPointMath struct {
    precision int64 // ç²¾åº¦ï¼Œå¦‚ 1000 è¡¨ç¤º3ä½å°æ•°
}

func NewFixedPointMath(decimalPlaces int) *FixedPointMath {
    return &FixedPointMath{
        precision: int64(math.Pow10(decimalPlaces)),
    }
}

// ToFixed è½¬æ¢ä¸ºå®šç‚¹æ•°
func (fpm *FixedPointMath) ToFixed(f float64) int64 {
    return int64(f * float64(fpm.precision))
}

// ToFloat è½¬æ¢ä¸ºæµ®ç‚¹æ•°
func (fpm *FixedPointMath) ToFloat(i int64) float64 {
    return float64(i) / float64(fpm.precision)
}

// Add å®šç‚¹æ•°åŠ æ³•
func (fpm *FixedPointMath) Add(a, b int64) int64 {
    return a + b
}

// Multiply å®šç‚¹æ•°ä¹˜æ³•
func (fpm *FixedPointMath) Multiply(a, b int64) int64 {
    return (a * b) / fpm.precision
}

// Divide å®šç‚¹æ•°é™¤æ³•
func (fpm *FixedPointMath) Divide(a, b int64) int64 {
    return (a * fpm.precision) / b
}
```

---

## çŠ¶æ€åŒæ­¥

è¯¦è§: [æ¸¸æˆå¼€å‘ - çŠ¶æ€åŒæ­¥](./02-æ¸¸æˆå¼€å‘.md#2-çŠ¶æ€åŒæ­¥)

### å¿«ç…§ä¸æ’å€¼

```go
package snapshot

import (
    "sort"
    "sync"
    "time"
)

// SnapshotManager å¿«ç…§ç®¡ç†å™¨
type SnapshotManager struct {
    snapshots    []*Snapshot
    maxSnapshots int
    mu           sync.RWMutex
}

// NewSnapshotManager åˆ›å»ºå¿«ç…§ç®¡ç†å™¨
func NewSnapshotManager(maxSnapshots int) *SnapshotManager {
    return &SnapshotManager{
        snapshots:    make([]*Snapshot, 0, maxSnapshots),
        maxSnapshots: maxSnapshots,
    }
}

// AddSnapshot æ·»åŠ å¿«ç…§
func (sm *SnapshotManager) AddSnapshot(snapshot *Snapshot) {
    sm.mu.Lock()
    defer sm.mu.Unlock()

    sm.snapshots = append(sm.snapshots, snapshot)

    // ä¿æŒå¿«ç…§æ•°é‡é™åˆ¶
    if len(sm.snapshots) > sm.maxSnapshots {
        sm.snapshots = sm.snapshots[1:]
    }

    // ä¿æŒæ—¶é—´é¡ºåº
    sort.Slice(sm.snapshots, func(i, j int) bool {
        return sm.snapshots[i].Timestamp.Before(sm.snapshots[j].Timestamp)
    })
}

// GetSnapshotAt è·å–æŒ‡å®šæ—¶é—´çš„å¿«ç…§
func (sm *SnapshotManager) GetSnapshotAt(t time.Time) *Snapshot {
    sm.mu.RLock()
    defer sm.mu.RUnlock()

    // æ‰¾åˆ°æœ€æ¥è¿‘çš„å¿«ç…§
    for i := len(sm.snapshots) - 1; i >= 0; i-- {
        if !sm.snapshots[i].Timestamp.After(t) {
            return sm.snapshots[i]
        }
    }

    return nil
}

// GetInterpolatedState è·å–æ’å€¼çŠ¶æ€
func (sm *SnapshotManager) GetInterpolatedState(t time.Time, playerID string) *PlayerSnapshot {
    sm.mu.RLock()
    defer sm.mu.RUnlock()

    // æ‰¾åˆ°æ—¶é—´ç‚¹å‰åçš„ä¸¤ä¸ªå¿«ç…§
    var prev, next *Snapshot
    for i := 0; i < len(sm.snapshots); i++ {
        if sm.snapshots[i].Timestamp.Before(t) {
            prev = sm.snapshots[i]
            if i+1 < len(sm.snapshots) {
                next = sm.snapshots[i+1]
            }
        }
    }

    if prev == nil {
        if len(sm.snapshots) > 0 {
            return sm.snapshots[0].Players[playerID]
        }
        return nil
    }

    if next == nil {
        return prev.Players[playerID]
    }

    // æ‰§è¡Œæ’å€¼
    return interpolatePlayerState(prev.Players[playerID], next.Players[playerID], prev.Timestamp, next.Timestamp, t)
}

// interpolatePlayerState æ’å€¼ç©å®¶çŠ¶æ€
func interpolatePlayerState(prev, next *PlayerSnapshot, prevTime, nextTime, targetTime time.Time) *PlayerSnapshot {
    if prev == nil || next == nil {
        return prev
    }

    // è®¡ç®—æ’å€¼å› å­
    totalDuration := nextTime.Sub(prevTime).Seconds()
    elapsed := targetTime.Sub(prevTime).Seconds()
    factor := elapsed / totalDuration

    // çº¿æ€§æ’å€¼
    return &PlayerSnapshot{
        Position: Vector3{
            X: prev.Position.X + (next.Position.X-prev.Position.X)*factor,
            Y: prev.Position.Y + (next.Position.Y-prev.Position.Y)*factor,
            Z: prev.Position.Z + (next.Position.Z-prev.Position.Z)*factor,
        },
        Velocity: Vector3{
            X: prev.Velocity.X + (next.Velocity.X-prev.Velocity.X)*factor,
            Y: prev.Velocity.Y + (next.Velocity.Y-prev.Velocity.Y)*factor,
            Z: prev.Velocity.Z + (next.Velocity.Z-prev.Velocity.Z)*factor,
        },
        Rotation: Quaternion{
            X: prev.Rotation.X + (next.Rotation.X-prev.Rotation.X)*factor,
            Y: prev.Rotation.Y + (next.Rotation.Y-prev.Rotation.Y)*factor,
            Z: prev.Rotation.Z + (next.Rotation.Z-prev.Rotation.Z)*factor,
            W: prev.Rotation.W + (next.Rotation.W-prev.Rotation.W)*factor,
        },
        Health: int(float64(prev.Health) + float64(next.Health-prev.Health)*factor),
    }
}

type Snapshot struct {
    Timestamp time.Time
    FrameNum  int64
    Players   map[string]*PlayerSnapshot
}

type PlayerSnapshot struct {
    Position Vector3
    Velocity Vector3
    Rotation Quaternion
    Health   int
}

type Vector3 struct {
    X, Y, Z float64
}

type Quaternion struct {
    X, Y, Z, W float64
}
```

### å®¢æˆ·ç«¯é¢„æµ‹

```go
package prediction

import (
    "sync"
    "time"
)

// ClientPredictor å®¢æˆ·ç«¯é¢„æµ‹å™¨
type ClientPredictor struct {
    localState      *LocalState
    predictedInputs []* PredictedInput
    confirmedFrame  int64
    mu              sync.RWMutex
}

// NewClientPredictor åˆ›å»ºå®¢æˆ·ç«¯é¢„æµ‹å™¨
func NewClientPredictor() *ClientPredictor {
    return &ClientPredictor{
        localState:      NewLocalState(),
        predictedInputs: make([]*PredictedInput, 0),
    }
}

// PredictInput é¢„æµ‹è¾“å…¥
func (cp *ClientPredictor) PredictInput(input *Input) {
    cp.mu.Lock()
    defer cp.mu.Unlock()

    // ä¿å­˜é¢„æµ‹è¾“å…¥
    predicted := &PredictedInput{
        FrameNum:  cp.localState.CurrentFrame + 1,
        Input:     input,
        Timestamp: time.Now(),
    }

    cp.predictedInputs = append(cp.predictedInputs, predicted)

    // ç«‹å³åº”ç”¨åˆ°æœ¬åœ°çŠ¶æ€
    cp.applyInput(input)
    cp.localState.CurrentFrame++
}

// ReconcileWithServer ä¸æœåŠ¡å™¨çŠ¶æ€å’Œè§£
func (cp *ClientPredictor) ReconcileWithServer(serverState *ServerState) {
    cp.mu.Lock()
    defer cp.mu.Unlock()

    // æ£€æŸ¥æœ¬åœ°é¢„æµ‹æ˜¯å¦æ­£ç¡®
    if cp.localState.MatchesServer(serverState) {
        // é¢„æµ‹æ­£ç¡®ï¼Œæ›´æ–°ç¡®è®¤å¸§
        cp.confirmedFrame = serverState.FrameNum
        cp.cleanupConfirmedInputs(serverState.FrameNum)
        return
    }

    // é¢„æµ‹é”™è¯¯ï¼Œéœ€è¦å›æ»š
    cp.rollbackAndReplay(serverState)
}

func (cp *ClientPredictor) rollbackAndReplay(serverState *ServerState) {
    // 1. å›æ»šåˆ°æœåŠ¡å™¨çŠ¶æ€
    cp.localState.CopyFrom(serverState)

    // 2. é‡æ–°åº”ç”¨æœªç¡®è®¤çš„è¾“å…¥
    unconfirmedInputs := cp.getUnconfirmedInputs(serverState.FrameNum)
    for _, predicted := range unconfirmedInputs {
        cp.applyInput(predicted.Input)
        cp.localState.CurrentFrame++
    }
}

func (cp *ClientPredictor) applyInput(input *Input) {
    // åº”ç”¨è¾“å…¥åˆ°æœ¬åœ°çŠ¶æ€
    switch input.Action {
    case "move":
        cp.localState.Player.Position.X += input.DeltaX
        cp.localState.Player.Position.Y += input.DeltaY
    case "jump":
        cp.localState.Player.Velocity.Y = input.JumpForce
    }
}

func (cp *ClientPredictor) getUnconfirmedInputs(confirmedFrame int64) []*PredictedInput {
    unconfirmed := make([]*PredictedInput, 0)
    for _, predicted := range cp.predictedInputs {
        if predicted.FrameNum > confirmedFrame {
            unconfirmed = append(unconfirmed, predicted)
        }
    }
    return unconfirmed
}

func (cp *ClientPredictor) cleanupConfirmedInputs(confirmedFrame int64) {
    newInputs := make([]*PredictedInput, 0)
    for _, predicted := range cp.predictedInputs {
        if predicted.FrameNum > confirmedFrame {
            newInputs = append(newInputs, predicted)
        }
    }
    cp.predictedInputs = newInputs
}

type LocalState struct {
    CurrentFrame int64
    Player       *PlayerState
}

func NewLocalState() *LocalState {
    return &LocalState{
        Player: &PlayerState{},
    }
}

func (ls *LocalState) MatchesServer(serverState *ServerState) bool {
    // æ¯”è¾ƒæœ¬åœ°çŠ¶æ€ä¸æœåŠ¡å™¨çŠ¶æ€
    // å…è®¸å°è¯¯å·®
    threshold := 0.1

    if ls.CurrentFrame != serverState.FrameNum {
        return false
    }

    posDiff := ls.Player.Position.Distance(serverState.Player.Position)
    return posDiff < threshold
}

func (ls *LocalState) CopyFrom(serverState *ServerState) {
    ls.CurrentFrame = serverState.FrameNum
    ls.Player.Position = serverState.Player.Position
    ls.Player.Velocity = serverState.Player.Velocity
    ls.Player.Health = serverState.Player.Health
}

type PredictedInput struct {
    FrameNum  int64
    Input     *Input
    Timestamp time.Time
}

type Input struct {
    Action    string
    DeltaX    float64
    DeltaY    float64
    JumpForce float64
}

type PlayerState struct {
    Position Vector3
    Velocity Vector3
    Health   int
}

func (v Vector3) Distance(other Vector3) float64 {
    dx := v.X - other.X
    dy := v.Y - other.Y
    dz := v.Z - other.Z
    return dx*dx + dy*dy + dz*dz
}

type ServerState struct {
    FrameNum int64
    Player   *PlayerState
}
```

---

## æ··åˆæ–¹æ¡ˆ

### åˆ†å±‚åŒæ­¥

```go
package hybrid

// HybridSyncEngine æ··åˆåŒæ­¥å¼•æ“
type HybridSyncEngine struct {
    lockstep *LockstepEngine // å…³é”®é€»è¾‘ç”¨å¸§åŒæ­¥
    stateMgr *StateManager   // è¡¨ç°ç”¨çŠ¶æ€åŒæ­¥
}

// NewHybridSyncEngine åˆ›å»ºæ··åˆåŒæ­¥å¼•æ“
func NewHybridSyncEngine() *HybridSyncEngine {
    return &HybridSyncEngine{
        lockstep: NewLockstepEngine(10),  // 10å¸§/ç§’çš„é€»è¾‘å¸§
        stateMgr: NewStateManager(30),    // 30å¸§/ç§’çš„çŠ¶æ€åŒæ­¥
    }
}

// Update æ›´æ–°
func (hse *HybridSyncEngine) Update() {
    // æ‰§è¡Œé€»è¾‘å¸§
    if hse.lockstep.ShouldUpdate() {
        hse.lockstep.Update()
    }

    // åŒæ­¥è¡¨ç°çŠ¶æ€
    if hse.stateMgr.ShouldSync() {
        state := hse.lockstep.GetState()
        hse.stateMgr.SyncState(state)
    }
}

type LockstepEngine struct {
    logicFrameRate int
    // ...
}

func NewLockstepEngine(frameRate int) *LockstepEngine {
    return &LockstepEngine{logicFrameRate: frameRate}
}

func (le *LockstepEngine) ShouldUpdate() bool {
    return true // ç®€åŒ–å®ç°
}

func (le *LockstepEngine) Update() {
    // æ‰§è¡Œç¡®å®šæ€§é€»è¾‘
}

func (le *LockstepEngine) GetState() interface{} {
    return nil
}

type StateManager struct {
    syncRate int
    // ...
}

func NewStateManager(syncRate int) *StateManager {
    return &StateManager{syncRate: syncRate}
}

func (sm *StateManager) ShouldSync() bool {
    return true // ç®€åŒ–å®ç°
}

func (sm *StateManager) SyncState(state interface{}) {
    // åŒæ­¥è¡¨ç°çŠ¶æ€
}
```

---

## ä¼˜åŒ–æŠ€æœ¯

### 1. å·®é‡æ›´æ–°

```go
// DeltaCompression å·®é‡å‹ç¼©
type DeltaCompression struct {
    lastState *GameState
}

func (dc *DeltaCompression) Compress(currentState *GameState) *DeltaUpdate {
    if dc.lastState == nil {
        dc.lastState = currentState
        return &DeltaUpdate{FullState: currentState}
    }

    delta := &DeltaUpdate{
        Changes: make(map[string]*StateChange),
    }

    // åªå‘é€å˜åŒ–çš„éƒ¨åˆ†
    for id, player := range currentState.Players {
        lastPlayer := dc.lastState.Players[id]
        if lastPlayer == nil || !player.Equals(lastPlayer) {
            delta.Changes[id] = &StateChange{
                PlayerID: id,
                NewState: player,
            }
        }
    }

    dc.lastState = currentState
    return delta
}

type DeltaUpdate struct {
    FullState *GameState
    Changes   map[string]*StateChange
}

type StateChange struct {
    PlayerID string
    NewState *PlayerState
}

func (ps *PlayerState) Equals(other *PlayerState) bool {
    return ps.Position == other.Position &&
        ps.Health == other.Health &&
        ps.Score == other.Score
}
```

### 2. å…´è¶£ç®¡ç† (AOI)

```go
// AOIManager Area Of Interest ç®¡ç†å™¨
type AOIManager struct {
    grid map[GridCell][]*Entity
    viewDistance float64
}

// GetVisibleEntities è·å–å¯è§å®ä½“
func (aoi *AOIManager) GetVisibleEntities(entity *Entity) []*Entity {
    cell := aoi.getCell(entity.Position)

    visible := make([]*Entity, 0)

    // æ£€æŸ¥å‘¨å›´9ä¸ªæ ¼å­
    for dx := -1; dx <= 1; dx++ {
        for dy := -1; dy <= 1; dy++ {
            neighborCell := GridCell{
                X: cell.X + dx,
                Y: cell.Y + dy,
            }

            for _, neighbor := range aoi.grid[neighborCell] {
                if entity.Position.Distance(neighbor.Position) <= aoi.viewDistance {
                    visible = append(visible, neighbor)
                }
            }
        }
    }

    return visible
}

type GridCell struct {
    X, Y int
}

type Entity struct {
    Position Vector3
}

func (aoi *AOIManager) getCell(pos Vector3) GridCell {
    cellSize := aoi.viewDistance
    return GridCell{
        X: int(pos.X / cellSize),
        Y: int(pos.Y / cellSize),
    }
}
```

---

**ç›¸å…³æ–‡æ¡£**:

- [æ¸¸æˆå¼€å‘æ¦‚è§ˆ](./02-æ¸¸æˆå¼€å‘.md)
- [å®æ—¶é€šä¿¡](./06-å®æ—¶é€šä¿¡.md)
- [æ€§èƒ½ä¼˜åŒ–](../advanced/performance/)

**ç»´æŠ¤è€…**: Game Sync Team
**æœ€åæ›´æ–°**: 2025-10-29
