# Goåœ¨æ•™è‚²ç§‘æŠ€ï¼ˆEdTechï¼‰ä¸­çš„åº”ç”¨

> **ç®€ä»‹**: ç³»ç»Ÿä»‹ç»Goè¯­è¨€åœ¨åœ¨çº¿æ•™è‚²ã€å­¦ä¹ ç®¡ç†ç³»ç»Ÿã€æ•™å­¦äº’åŠ¨å¹³å°ç­‰æ•™è‚²ç§‘æŠ€é¢†åŸŸçš„æ¶æ„è®¾è®¡ã€æŠ€æœ¯å®è·µä¸å·¥ç¨‹è½åœ°

---

## ğŸ“š ç›®å½•

- [Goåœ¨æ•™è‚²ç§‘æŠ€ï¼ˆEdTechï¼‰ä¸­çš„åº”ç”¨](#goåœ¨æ•™è‚²ç§‘æŠ€edtechä¸­çš„åº”ç”¨)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [1. æ•™è‚²ç§‘æŠ€æ¦‚è§ˆ](#1-æ•™è‚²ç§‘æŠ€æ¦‚è§ˆ)
    - [1.1 è¡Œä¸šç‰¹ç‚¹](#11-è¡Œä¸šç‰¹ç‚¹)
    - [1.2 Goçš„ä¼˜åŠ¿](#12-goçš„ä¼˜åŠ¿)
  - [2. åœ¨çº¿å­¦ä¹ å¹³å°æ¶æ„](#2-åœ¨çº¿å­¦ä¹ å¹³å°æ¶æ„)
    - [2.1 æ•´ä½“æ¶æ„](#21-æ•´ä½“æ¶æ„)
    - [2.2 å¾®æœåŠ¡åˆ’åˆ†](#22-å¾®æœåŠ¡åˆ’åˆ†)
  - [3. å­¦ä¹ ç®¡ç†ç³»ç»Ÿï¼ˆLMSï¼‰](#3-å­¦ä¹ ç®¡ç†ç³»ç»Ÿlms)
    - [3.1 è¯¾ç¨‹ç®¡ç†](#31-è¯¾ç¨‹ç®¡ç†)
    - [3.2 å­¦ä¹ è¿›åº¦è·Ÿè¸ª](#32-å­¦ä¹ è¿›åº¦è·Ÿè¸ª)
  - [4. å®æ—¶äº’åŠ¨æ•™å­¦](#4-å®æ—¶äº’åŠ¨æ•™å­¦)
    - [4.1 åœ¨çº¿é—®ç­”ç³»ç»Ÿ](#41-åœ¨çº¿é—®ç­”ç³»ç»Ÿ)
    - [4.2 å®æ—¶ç™½æ¿](#42-å®æ—¶ç™½æ¿)
  - [5. è¯¾ç¨‹å†…å®¹ç®¡ç†](#5-è¯¾ç¨‹å†…å®¹ç®¡ç†)
    - [5.1 è§†é¢‘å¤„ç†](#51-è§†é¢‘å¤„ç†)
  - [6. å­¦ä¹ æ•°æ®åˆ†æ](#6-å­¦ä¹ æ•°æ®åˆ†æ)
    - [6.1 å­¦ä¹ è¡Œä¸ºåˆ†æ](#61-å­¦ä¹ è¡Œä¸ºåˆ†æ)
  - [7. è€ƒè¯•è¯„æµ‹ç³»ç»Ÿ](#7-è€ƒè¯•è¯„æµ‹ç³»ç»Ÿ)
    - [7.1 åœ¨çº¿è€ƒè¯•](#71-åœ¨çº¿è€ƒè¯•)
  - [8. è§†é¢‘ç›´æ’­ä¸ç‚¹æ’­](#8-è§†é¢‘ç›´æ’­ä¸ç‚¹æ’­)
    - [8.1 ç›´æ’­ç³»ç»Ÿ](#81-ç›´æ’­ç³»ç»Ÿ)
  - [9. å®Œæ•´é¡¹ç›®ï¼šåœ¨çº¿å­¦ä¹ å¹³å°](#9-å®Œæ•´é¡¹ç›®åœ¨çº¿å­¦ä¹ å¹³å°)
    - [9.1 é¡¹ç›®ç»“æ„](#91-é¡¹ç›®ç»“æ„)
    - [9.2 æ ¸å¿ƒAPIå®ç°](#92-æ ¸å¿ƒapiå®ç°)
  - [ğŸ’¡ æ€»ç»“](#-æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [è¿›é˜¶æ–¹å‘](#è¿›é˜¶æ–¹å‘)
  - [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

---

## 1. æ•™è‚²ç§‘æŠ€æ¦‚è§ˆ

### 1.1 è¡Œä¸šç‰¹ç‚¹

**æ ¸å¿ƒéœ€æ±‚**:

- é«˜å¹¶å‘è®¿é—®ï¼ˆè¯¾ç¨‹ç›´æ’­ã€ä½œä¸šæäº¤ï¼‰
- ä½å»¶è¿Ÿäº’åŠ¨ï¼ˆåœ¨çº¿é—®ç­”ã€å®æ—¶æ‰¹æ³¨ï¼‰
- å¤§è§„æ¨¡å­˜å‚¨ï¼ˆè§†é¢‘ã€æ–‡æ¡£ã€ä½œä¸šï¼‰
- æ•°æ®å®‰å…¨ï¼ˆå­¦ç”Ÿä¿¡æ¯ã€æˆç»©è®°å½•ï¼‰
- ä¸ªæ€§åŒ–å­¦ä¹ ï¼ˆæ¨èç®—æ³•ã€å­¦ä¹ è·¯å¾„ï¼‰

**æŠ€æœ¯æŒ‘æˆ˜**:

- è§†é¢‘æµåª’ä½“å¤„ç†
- å¤§é‡ç”¨æˆ·å¹¶å‘å­¦ä¹ 
- å®æ—¶äº’åŠ¨ä½“éªŒ
- å­¦ä¹ æ•°æ®åˆ†æ
- è€ƒè¯•é˜²ä½œå¼Š

### 1.2 Goçš„ä¼˜åŠ¿

```go
// Goåœ¨EdTechä¸­çš„ä¼˜åŠ¿
ä¼˜åŠ¿ç‰¹æ€§:
âœ… é«˜å¹¶å‘å¤„ç† - æ”¯æŒå¤§é‡å­¦ç”ŸåŒæ—¶åœ¨çº¿
âœ… é«˜æ€§èƒ½ - å¿«é€Ÿå“åº”ç”¨æˆ·è¯·æ±‚
âœ… æ˜“äºéƒ¨ç½² - å•ä¸€äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œä¾¿äºåˆ†å‘
âœ… ä¸°å¯Œç”Ÿæ€ - å®Œå–„çš„Webæ¡†æ¶å’Œå·¥å…·é“¾
âœ… äº‘åŸç”Ÿ - å¤©ç„¶é€‚åˆå¾®æœåŠ¡å’Œå®¹å™¨åŒ–
```

---

## 2. åœ¨çº¿å­¦ä¹ å¹³å°æ¶æ„

### 2.1 æ•´ä½“æ¶æ„

```go
package architecture

/*
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      å‰ç«¯åº”ç”¨å±‚                               â”‚
â”‚  Webç«¯      ç§»åŠ¨ç«¯      å°ç¨‹åº      TVç«¯                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      API ç½‘å…³å±‚                               â”‚
â”‚  è®¤è¯æˆæƒ    è·¯ç”±åˆ†å‘    é™æµé™çº§    æ—¥å¿—ç›‘æ§                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ä¸šåŠ¡æœåŠ¡å±‚                               â”‚
â”‚  ç”¨æˆ·æœåŠ¡   è¯¾ç¨‹æœåŠ¡   å­¦ä¹ æœåŠ¡   è€ƒè¯•æœåŠ¡   äº’åŠ¨æœåŠ¡            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      åŸºç¡€è®¾æ–½å±‚                               â”‚
â”‚  æ•°æ®åº“     ç¼“å­˜      æ¶ˆæ¯é˜Ÿåˆ—    å¯¹è±¡å­˜å‚¨    CDN              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
*/
```

### 2.2 å¾®æœåŠ¡åˆ’åˆ†

```go
package services

// UserService ç”¨æˆ·æœåŠ¡
type UserService struct {
    repo UserRepository
}

// ç”¨æˆ·æ³¨å†Œ
func (s *UserService) Register(ctx context.Context, req RegisterRequest) (*User, error) {
    // éªŒè¯æ‰‹æœºå·/é‚®ç®±
    if err := s.validateContact(req.Contact); err != nil {
        return nil, err
    }

    // åŠ å¯†å¯†ç 
    hashedPassword, err := bcrypt.GenerateFromPassword(
        []byte(req.Password), 
        bcrypt.DefaultCost,
    )
    if err != nil {
        return nil, err
    }

    user := &User{
        ID:           generateID(),
        Username:     req.Username,
        Contact:      req.Contact,
        PasswordHash: string(hashedPassword),
        Role:         RoleStudent,
        Status:       StatusActive,
        CreatedAt:    time.Now(),
    }

    return s.repo.Create(ctx, user)
}

// CourseService è¯¾ç¨‹æœåŠ¡
type CourseService struct {
    repo    CourseRepository
    storage StorageClient
}

// åˆ›å»ºè¯¾ç¨‹
func (s *CourseService) CreateCourse(ctx context.Context, req CreateCourseRequest) (*Course, error) {
    course := &Course{
        ID:          generateID(),
        Title:       req.Title,
        Description: req.Description,
        TeacherID:   req.TeacherID,
        Category:    req.Category,
        Price:       req.Price,
        Status:      StatusDraft,
        CreatedAt:   time.Now(),
    }

    // ä¿å­˜è¯¾ç¨‹
    if err := s.repo.Create(ctx, course); err != nil {
        return nil, err
    }

    // ä¸Šä¼ å°é¢å›¾
    if req.CoverImage != nil {
        coverURL, err := s.storage.Upload(ctx, req.CoverImage)
        if err != nil {
            return nil, err
        }
        course.CoverURL = coverURL
        s.repo.Update(ctx, course)
    }

    return course, nil
}

// LearningService å­¦ä¹ æœåŠ¡
type LearningService struct {
    repo     LearningRepository
    progress ProgressTracker
}

// å¼€å§‹å­¦ä¹ 
func (s *LearningService) StartLearning(ctx context.Context, userID, courseID string) error {
    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²è´­ä¹°è¯¾ç¨‹
    enrolled, err := s.repo.IsEnrolled(ctx, userID, courseID)
    if err != nil {
        return err
    }
    if !enrolled {
        return ErrNotEnrolled
    }

    // åˆ›å»ºå­¦ä¹ è®°å½•
    record := &LearningRecord{
        UserID:    userID,
        CourseID:  courseID,
        StartTime: time.Now(),
        Progress:  0,
        Status:    StatusLearning,
    }

    return s.repo.CreateRecord(ctx, record)
}

// æ›´æ–°å­¦ä¹ è¿›åº¦
func (s *LearningService) UpdateProgress(
    ctx context.Context,
    userID, courseID, lessonID string,
    progress int,
) error {
    return s.progress.Update(ctx, &ProgressUpdate{
        UserID:   userID,
        CourseID: courseID,
        LessonID: lessonID,
        Progress: progress,
        UpdateAt: time.Now(),
    })
}
```

---

## 3. å­¦ä¹ ç®¡ç†ç³»ç»Ÿï¼ˆLMSï¼‰

### 3.1 è¯¾ç¨‹ç®¡ç†

```go
package lms

import (
    "context"
    "time"
)

// Course è¯¾ç¨‹æ¨¡å‹
type Course struct {
    ID          string    `json:"id"`
    Title       string    `json:"title"`
    Description string    `json:"description"`
    TeacherID   string    `json:"teacher_id"`
    Category    string    `json:"category"`
    Level       string    `json:"level"` // åˆçº§/ä¸­çº§/é«˜çº§
    Price       int64     `json:"price"` // ä»·æ ¼ï¼ˆåˆ†ï¼‰
    Status      string    `json:"status"`
    CoverURL    string    `json:"cover_url"`
    Duration    int       `json:"duration"` // æ€»æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
    Chapters    []Chapter `json:"chapters"`
    CreatedAt   time.Time `json:"created_at"`
    UpdatedAt   time.Time `json:"updated_at"`
}

// Chapter ç« èŠ‚
type Chapter struct {
    ID       string   `json:"id"`
    Title    string   `json:"title"`
    Order    int      `json:"order"`
    Lessons  []Lesson `json:"lessons"`
}

// Lesson è¯¾æ—¶
type Lesson struct {
    ID        string        `json:"id"`
    Title     string        `json:"title"`
    Type      string        `json:"type"` // video/doc/quiz
    Content   LessonContent `json:"content"`
    Duration  int           `json:"duration"`
    Order     int           `json:"order"`
    IsFree    bool          `json:"is_free"` // æ˜¯å¦è¯•å¬
}

// LessonContent è¯¾æ—¶å†…å®¹
type LessonContent struct {
    VideoURL     string   `json:"video_url,omitempty"`
    DocumentURL  string   `json:"document_url,omitempty"`
    QuizID       string   `json:"quiz_id,omitempty"`
    Attachments  []string `json:"attachments,omitempty"`
}

// CourseManager è¯¾ç¨‹ç®¡ç†å™¨
type CourseManager struct {
    repo    CourseRepository
    storage StorageClient
    cache   CacheClient
}

// GetCourseDetail è·å–è¯¾ç¨‹è¯¦æƒ…
func (m *CourseManager) GetCourseDetail(ctx context.Context, courseID string) (*Course, error) {
    // å…ˆä»ç¼“å­˜è·å–
    if course, err := m.cache.GetCourse(ctx, courseID); err == nil {
        return course, nil
    }

    // ä»æ•°æ®åº“è·å–
    course, err := m.repo.GetByID(ctx, courseID)
    if err != nil {
        return nil, err
    }

    // åŠ è½½ç« èŠ‚å’Œè¯¾æ—¶
    chapters, err := m.repo.GetChapters(ctx, courseID)
    if err != nil {
        return nil, err
    }

    for i := range chapters {
        lessons, err := m.repo.GetLessons(ctx, chapters[i].ID)
        if err != nil {
            return nil, err
        }
        chapters[i].Lessons = lessons
    }

    course.Chapters = chapters

    // ç¼“å­˜è¯¾ç¨‹ä¿¡æ¯
    m.cache.SetCourse(ctx, course, 1*time.Hour)

    return course, nil
}

// PublishCourse å‘å¸ƒè¯¾ç¨‹
func (m *CourseManager) PublishCourse(ctx context.Context, courseID string) error {
    course, err := m.repo.GetByID(ctx, courseID)
    if err != nil {
        return err
    }

    // éªŒè¯è¯¾ç¨‹å†…å®¹å®Œæ•´æ€§
    if err := m.validateCourse(course); err != nil {
        return err
    }

    // æ›´æ–°çŠ¶æ€ä¸ºå·²å‘å¸ƒ
    course.Status = StatusPublished
    course.UpdatedAt = time.Now()

    if err := m.repo.Update(ctx, course); err != nil {
        return err
    }

    // æ¸…é™¤ç¼“å­˜
    m.cache.DeleteCourse(ctx, courseID)

    return nil
}

func (m *CourseManager) validateCourse(course *Course) error {
    if course.Title == "" {
        return ErrMissingTitle
    }
    if course.CoverURL == "" {
        return ErrMissingCover
    }
    if len(course.Chapters) == 0 {
        return ErrNoChapters
    }
    return nil
}
```

### 3.2 å­¦ä¹ è¿›åº¦è·Ÿè¸ª

```go
package tracking

import (
    "context"
    "sync"
    "time"
)

// ProgressTracker è¿›åº¦è·Ÿè¸ªå™¨
type ProgressTracker struct {
    repo  ProgressRepository
    mu    sync.RWMutex
    cache map[string]*Progress // userID:courseID -> Progress
}

// Progress å­¦ä¹ è¿›åº¦
type Progress struct {
    UserID          string            `json:"user_id"`
    CourseID        string            `json:"course_id"`
    TotalLessons    int               `json:"total_lessons"`
    CompletedLessons int              `json:"completed_lessons"`
    Progress        int               `json:"progress"` // ç™¾åˆ†æ¯”
    LastLesson      string            `json:"last_lesson"`
    LessonProgress  map[string]int    `json:"lesson_progress"` // lessonID -> è¿›åº¦
    TotalDuration   int               `json:"total_duration"` // æ€»æ—¶é•¿ï¼ˆç§’ï¼‰
    LearnedDuration int               `json:"learned_duration"` // å·²å­¦æ—¶é•¿ï¼ˆç§’ï¼‰
    UpdatedAt       time.Time         `json:"updated_at"`
}

func NewProgressTracker(repo ProgressRepository) *ProgressTracker {
    return &ProgressTracker{
        repo:  repo,
        cache: make(map[string]*Progress),
    }
}

// GetProgress è·å–å­¦ä¹ è¿›åº¦
func (t *ProgressTracker) GetProgress(ctx context.Context, userID, courseID string) (*Progress, error) {
    key := userID + ":" + courseID

    // å…ˆä»å†…å­˜ç¼“å­˜è·å–
    t.mu.RLock()
    if progress, exists := t.cache[key]; exists {
        t.mu.RUnlock()
        return progress, nil
    }
    t.mu.RUnlock()

    // ä»æ•°æ®åº“è·å–
    progress, err := t.repo.GetProgress(ctx, userID, courseID)
    if err != nil {
        return nil, err
    }

    // ç¼“å­˜åˆ°å†…å­˜
    t.mu.Lock()
    t.cache[key] = progress
    t.mu.Unlock()

    return progress, nil
}

// UpdateLessonProgress æ›´æ–°è¯¾æ—¶è¿›åº¦
func (t *ProgressTracker) UpdateLessonProgress(
    ctx context.Context,
    userID, courseID, lessonID string,
    duration int, // å½“å‰è§‚çœ‹æ—¶é•¿
) error {
    progress, err := t.GetProgress(ctx, userID, courseID)
    if err != nil {
        return err
    }

    // æ›´æ–°è¯¾æ—¶è¿›åº¦
    if progress.LessonProgress == nil {
        progress.LessonProgress = make(map[string]int)
    }
    progress.LessonProgress[lessonID] = duration
    progress.LastLesson = lessonID
    progress.LearnedDuration += duration

    // æ£€æŸ¥è¯¾æ—¶æ˜¯å¦å®Œæˆï¼ˆè§‚çœ‹è¶…è¿‡90%ï¼‰
    if t.isLessonCompleted(lessonID, duration) {
        progress.CompletedLessons++
    }

    // è®¡ç®—æ•´ä½“è¿›åº¦
    progress.Progress = (progress.CompletedLessons * 100) / progress.TotalLessons
    progress.UpdatedAt = time.Now()

    // ä¿å­˜åˆ°æ•°æ®åº“
    if err := t.repo.UpdateProgress(ctx, progress); err != nil {
        return err
    }

    // æ›´æ–°ç¼“å­˜
    key := userID + ":" + courseID
    t.mu.Lock()
    t.cache[key] = progress
    t.mu.Unlock()

    return nil
}

func (t *ProgressTracker) isLessonCompleted(lessonID string, watchedDuration int) bool {
    // è·å–è¯¾æ—¶æ€»æ—¶é•¿
    lessonDuration := t.getLessonDuration(lessonID)
    if lessonDuration == 0 {
        return false
    }

    // åˆ¤æ–­æ˜¯å¦è§‚çœ‹è¶…è¿‡90%
    return float64(watchedDuration)/float64(lessonDuration) >= 0.9
}

func (t *ProgressTracker) getLessonDuration(lessonID string) int {
    // ä»æ•°æ®åº“æˆ–ç¼“å­˜è·å–è¯¾æ—¶æ—¶é•¿
    // è¿™é‡Œç®€åŒ–å¤„ç†
    return 600 // å‡è®¾10åˆ†é’Ÿ
}
```

---

## 4. å®æ—¶äº’åŠ¨æ•™å­¦

### 4.1 åœ¨çº¿é—®ç­”ç³»ç»Ÿ

```go
package interactive

import (
    "context"
    "sync"
    "time"

    "github.com/gorilla/websocket"
)

// QuestionAnswer é—®ç­”ç³»ç»Ÿ
type QuestionAnswer struct {
    clients   map[string]*Client // userID -> Client
    questions chan *Question
    answers   chan *Answer
    mu        sync.RWMutex
}

// Client WebSocketå®¢æˆ·ç«¯
type Client struct {
    ID       string
    UserID   string
    CourseID string
    Role     string // student/teacher
    Conn     *websocket.Conn
    Send     chan []byte
}

// Question é—®é¢˜
type Question struct {
    ID        string    `json:"id"`
    UserID    string    `json:"user_id"`
    Username  string    `json:"username"`
    CourseID  string    `json:"course_id"`
    Content   string    `json:"content"`
    Images    []string  `json:"images,omitempty"`
    CreatedAt time.Time `json:"created_at"`
}

// Answer ç­”æ¡ˆ
type Answer struct {
    ID         string    `json:"id"`
    QuestionID string    `json:"question_id"`
    UserID     string    `json:"user_id"`
    Username   string    `json:"username"`
    Content    string    `json:"content"`
    IsTeacher  bool      `json:"is_teacher"`
    CreatedAt  time.Time `json:"created_at"`
}

func NewQuestionAnswer() *QuestionAnswer {
    return &QuestionAnswer{
        clients:   make(map[string]*Client),
        questions: make(chan *Question, 100),
        answers:   make(chan *Answer, 100),
    }
}

// Run è¿è¡Œé—®ç­”ç³»ç»Ÿ
func (qa *QuestionAnswer) Run(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            return
        case question := <-qa.questions:
            qa.broadcastQuestion(question)
        case answer := <-qa.answers:
            qa.broadcastAnswer(answer)
        }
    }
}

// HandleClient å¤„ç†å®¢æˆ·ç«¯è¿æ¥
func (qa *QuestionAnswer) HandleClient(client *Client) {
    // æ³¨å†Œå®¢æˆ·ç«¯
    qa.mu.Lock()
    qa.clients[client.ID] = client
    qa.mu.Unlock()

    defer func() {
        // ç§»é™¤å®¢æˆ·ç«¯
        qa.mu.Lock()
        delete(qa.clients, client.ID)
        qa.mu.Unlock()
        client.Conn.Close()
    }()

    // è¯»å–æ¶ˆæ¯
    for {
        var msg Message
        err := client.Conn.ReadJSON(&msg)
        if err != nil {
            break
        }

        switch msg.Type {
        case "question":
            qa.handleQuestion(client, msg.Data)
        case "answer":
            qa.handleAnswer(client, msg.Data)
        }
    }
}

func (qa *QuestionAnswer) handleQuestion(client *Client, data interface{}) {
    question := &Question{
        ID:        generateID(),
        UserID:    client.UserID,
        CourseID:  client.CourseID,
        CreatedAt: time.Now(),
    }

    // è§£æé—®é¢˜å†…å®¹
    // ...

    qa.questions <- question
}

func (qa *QuestionAnswer) handleAnswer(client *Client, data interface{}) {
    answer := &Answer{
        ID:        generateID(),
        UserID:    client.UserID,
        IsTeacher: client.Role == "teacher",
        CreatedAt: time.Now(),
    }

    // è§£æç­”æ¡ˆå†…å®¹
    // ...

    qa.answers <- answer
}

func (qa *QuestionAnswer) broadcastQuestion(question *Question) {
    qa.mu.RLock()
    defer qa.mu.RUnlock()

    for _, client := range qa.clients {
        if client.CourseID == question.CourseID {
            client.Send <- encodeMessage("question", question)
        }
    }
}

func (qa *QuestionAnswer) broadcastAnswer(answer *Answer) {
    qa.mu.RLock()
    defer qa.mu.RUnlock()

    for _, client := range qa.clients {
        client.Send <- encodeMessage("answer", answer)
    }
}
```

### 4.2 å®æ—¶ç™½æ¿

```go
package whiteboard

import (
    "sync"
    "time"
)

// Whiteboard ç™½æ¿
type Whiteboard struct {
    ID        string
    CourseID  string
    Elements  []*Element
    History   []*Operation
    mu        sync.RWMutex
    clients   map[string]*Client
}

// Element ç™½æ¿å…ƒç´ 
type Element struct {
    ID      string      `json:"id"`
    Type    string      `json:"type"` // line/rect/circle/text/image
    Data    interface{} `json:"data"`
    Style   Style       `json:"style"`
    ZIndex  int         `json:"z_index"`
}

// Style æ ·å¼
type Style struct {
    Color       string  `json:"color"`
    StrokeWidth float64 `json:"stroke_width"`
    Fill        string  `json:"fill"`
    FontSize    int     `json:"font_size,omitempty"`
}

// Operation æ“ä½œè®°å½•
type Operation struct {
    Type      string    `json:"type"` // add/update/delete
    ElementID string    `json:"element_id"`
    Element   *Element  `json:"element,omitempty"`
    Timestamp time.Time `json:"timestamp"`
    UserID    string    `json:"user_id"`
}

// AddElement æ·»åŠ å…ƒç´ 
func (w *Whiteboard) AddElement(elem *Element) {
    w.mu.Lock()
    defer w.mu.Unlock()

    w.Elements = append(w.Elements, elem)

    // è®°å½•æ“ä½œ
    op := &Operation{
        Type:      "add",
        ElementID: elem.ID,
        Element:   elem,
        Timestamp: time.Now(),
    }
    w.History = append(w.History, op)

    // å¹¿æ’­ç»™æ‰€æœ‰å®¢æˆ·ç«¯
    w.broadcast(op)
}

// UpdateElement æ›´æ–°å…ƒç´ 
func (w *Whiteboard) UpdateElement(elemID string, elem *Element) error {
    w.mu.Lock()
    defer w.mu.Unlock()

    for i, e := range w.Elements {
        if e.ID == elemID {
            w.Elements[i] = elem

            op := &Operation{
                Type:      "update",
                ElementID: elemID,
                Element:   elem,
                Timestamp: time.Now(),
            }
            w.History = append(w.History, op)
            w.broadcast(op)

            return nil
        }
    }

    return ErrElementNotFound
}

// DeleteElement åˆ é™¤å…ƒç´ 
func (w *Whiteboard) DeleteElement(elemID string) error {
    w.mu.Lock()
    defer w.mu.Unlock()

    for i, e := range w.Elements {
        if e.ID == elemID {
            w.Elements = append(w.Elements[:i], w.Elements[i+1:]...)

            op := &Operation{
                Type:      "delete",
                ElementID: elemID,
                Timestamp: time.Now(),
            }
            w.History = append(w.History, op)
            w.broadcast(op)

            return nil
        }
    }

    return ErrElementNotFound
}

func (w *Whiteboard) broadcast(op *Operation) {
    for _, client := range w.clients {
        client.Send <- encodeMessage("operation", op)
    }
}

// Clear æ¸…ç©ºç™½æ¿
func (w *Whiteboard) Clear() {
    w.mu.Lock()
    defer w.mu.Unlock()

    w.Elements = []*Element{}

    op := &Operation{
        Type:      "clear",
        Timestamp: time.Now(),
    }
    w.History = append(w.History, op)
    w.broadcast(op)
}
```

---

## 5. è¯¾ç¨‹å†…å®¹ç®¡ç†

### 5.1 è§†é¢‘å¤„ç†

```go
package content

import (
    "context"
    "fmt"
    "os/exec"
)

// VideoProcessor è§†é¢‘å¤„ç†å™¨
type VideoProcessor struct {
    storage    StorageClient
    transcoder TranscoderClient
}

// ProcessVideo å¤„ç†è§†é¢‘
func (p *VideoProcessor) ProcessVideo(ctx context.Context, videoPath string) (*VideoResult, error) {
    // 1. è·å–è§†é¢‘ä¿¡æ¯
    info, err := p.getVideoInfo(videoPath)
    if err != nil {
        return nil, err
    }

    // 2. è½¬ç ä¸ºå¤šç§æ¸…æ™°åº¦
    qualities := []Quality{Quality360p, Quality480p, Quality720p, Quality1080p}
    var outputs []VideoOutput

    for _, quality := range qualities {
        output, err := p.transcode(ctx, videoPath, quality)
        if err != nil {
            continue // æŸä¸ªæ¸…æ™°åº¦å¤±è´¥ä¸å½±å“å…¶ä»–
        }
        outputs = append(outputs, output)
    }

    // 3. ç”Ÿæˆç¼©ç•¥å›¾
    thumbnail, err := p.generateThumbnail(videoPath)
    if err != nil {
        return nil, err
    }

    // 4. ä¸Šä¼ åˆ°äº‘å­˜å‚¨
    result := &VideoResult{
        VideoID:   generateID(),
        Duration:  info.Duration,
        Size:      info.Size,
        Outputs:   outputs,
        Thumbnail: thumbnail,
    }

    for i := range outputs {
        url, err := p.storage.Upload(ctx, outputs[i].Path)
        if err != nil {
            return nil, err
        }
        result.Outputs[i].URL = url
    }

    thumbnailURL, err := p.storage.Upload(ctx, thumbnail)
    if err != nil {
        return nil, err
    }
    result.Thumbnail = thumbnailURL

    return result, nil
}

// VideoInfo è§†é¢‘ä¿¡æ¯
type VideoInfo struct {
    Duration int64  // æ—¶é•¿ï¼ˆç§’ï¼‰
    Width    int    // å®½åº¦
    Height   int    // é«˜åº¦
    Size     int64  // æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
    Bitrate  int    // ç ç‡
    Format   string // æ ¼å¼
}

func (p *VideoProcessor) getVideoInfo(videoPath string) (*VideoInfo, error) {
    // ä½¿ç”¨ ffprobe è·å–è§†é¢‘ä¿¡æ¯
    cmd := exec.Command("ffprobe",
        "-v", "error",
        "-show_entries", "format=duration,size:stream=width,height,bit_rate",
        "-of", "json",
        videoPath,
    )

    output, err := cmd.Output()
    if err != nil {
        return nil, err
    }

    // è§£æ JSON è¾“å‡º
    var info VideoInfo
    // ... è§£æé€»è¾‘

    return &info, nil
}

// Quality è§†é¢‘æ¸…æ™°åº¦
type Quality string

const (
    Quality360p  Quality = "360p"
    Quality480p  Quality = "480p"
    Quality720p  Quality = "720p"
    Quality1080p Quality = "1080p"
)

// VideoOutput è§†é¢‘è¾“å‡º
type VideoOutput struct {
    Quality Quality `json:"quality"`
    Path    string  `json:"path"`
    URL     string  `json:"url"`
    Size    int64   `json:"size"`
    Bitrate int     `json:"bitrate"`
}

func (p *VideoProcessor) transcode(ctx context.Context, input string, quality Quality) (VideoOutput, error) {
    output := VideoOutput{
        Quality: quality,
    }

    // æ ¹æ®æ¸…æ™°åº¦è®¾ç½®å‚æ•°
    var width, height, bitrate int
    switch quality {
    case Quality360p:
        width, height, bitrate = 640, 360, 800
    case Quality480p:
        width, height, bitrate = 854, 480, 1200
    case Quality720p:
        width, height, bitrate = 1280, 720, 2500
    case Quality1080p:
        width, height, bitrate = 1920, 1080, 5000
    }

    outputPath := fmt.Sprintf("%s_%s.mp4", input, quality)

    // ä½¿ç”¨ ffmpeg è½¬ç 
    cmd := exec.CommandContext(ctx, "ffmpeg",
        "-i", input,
        "-vf", fmt.Sprintf("scale=%d:%d", width, height),
        "-b:v", fmt.Sprintf("%dk", bitrate),
        "-c:v", "libx264",
        "-preset", "fast",
        "-c:a", "aac",
        "-b:a", "128k",
        outputPath,
    )

    if err := cmd.Run(); err != nil {
        return output, err
    }

    output.Path = outputPath
    return output, nil
}

func (p *VideoProcessor) generateThumbnail(videoPath string) (string, error) {
    thumbnailPath := videoPath + "_thumbnail.jpg"

    // æˆªå–ç¬¬1ç§’çš„å¸§ä½œä¸ºç¼©ç•¥å›¾
    cmd := exec.Command("ffmpeg",
        "-i", videoPath,
        "-ss", "00:00:01",
        "-vframes", "1",
        "-vf", "scale=320:180",
        thumbnailPath,
    )

    if err := cmd.Run(); err != nil {
        return "", err
    }

    return thumbnailPath, nil
}

// VideoResult è§†é¢‘å¤„ç†ç»“æœ
type VideoResult struct {
    VideoID   string        `json:"video_id"`
    Duration  int64         `json:"duration"`
    Size      int64         `json:"size"`
    Outputs   []VideoOutput `json:"outputs"`
    Thumbnail string        `json:"thumbnail"`
}
```

---

## 6. å­¦ä¹ æ•°æ®åˆ†æ

### 6.1 å­¦ä¹ è¡Œä¸ºåˆ†æ

```go
package analytics

import (
    "context"
    "time"
)

// LearningAnalytics å­¦ä¹ åˆ†æ
type LearningAnalytics struct {
    repo AnalyticsRepository
}

// UserLearningStats ç”¨æˆ·å­¦ä¹ ç»Ÿè®¡
type UserLearningStats struct {
    UserID          string        `json:"user_id"`
    TotalCourses    int           `json:"total_courses"`
    CompletedCourses int          `json:"completed_courses"`
    TotalDuration   int           `json:"total_duration"` // æ€»å­¦ä¹ æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
    AvgDailyTime    int           `json:"avg_daily_time"` // å¹³å‡æ¯æ—¥å­¦ä¹ æ—¶é•¿
    LongestStreak   int           `json:"longest_streak"` // æœ€é•¿è¿ç»­å­¦ä¹ å¤©æ•°
    CurrentStreak   int           `json:"current_streak"` // å½“å‰è¿ç»­å­¦ä¹ å¤©æ•°
    WeakDays        []Weekday     `json:"weak_days"` // å­¦ä¹ è–„å¼±æ—¥
    PreferredTime   []TimeSlot    `json:"preferred_time"` // åå¥½å­¦ä¹ æ—¶æ®µ
    Categories      []CategoryStat `json:"categories"` // åˆ†ç±»ç»Ÿè®¡
}

// CategoryStat åˆ†ç±»ç»Ÿè®¡
type CategoryStat struct {
    Category string `json:"category"`
    Courses  int    `json:"courses"`
    Duration int    `json:"duration"`
    Progress int    `json:"progress"`
}

// GetUserStats è·å–ç”¨æˆ·ç»Ÿè®¡
func (a *LearningAnalytics) GetUserStats(ctx context.Context, userID string, period Period) (*UserLearningStats, error) {
    // è·å–ç”¨æˆ·å­¦ä¹ è®°å½•
    records, err := a.repo.GetLearningRecords(ctx, userID, period)
    if err != nil {
        return nil, err
    }

    stats := &UserLearningStats{
        UserID: userID,
    }

    // ç»Ÿè®¡æ€»è¯¾ç¨‹æ•°å’Œå®Œæˆæ•°
    courseMap := make(map[string]bool)
    completedMap := make(map[string]bool)
    totalDuration := 0

    for _, record := range records {
        courseMap[record.CourseID] = true
        totalDuration += record.Duration

        if record.Progress >= 100 {
            completedMap[record.CourseID] = true
        }
    }

    stats.TotalCourses = len(courseMap)
    stats.CompletedCourses = len(completedMap)
    stats.TotalDuration = totalDuration

    // è®¡ç®—å¹³å‡æ¯æ—¥å­¦ä¹ æ—¶é•¿
    days := period.Days()
    if days > 0 {
        stats.AvgDailyTime = totalDuration / days
    }

    // è®¡ç®—å­¦ä¹ è¿ç»­æ€§
    stats.LongestStreak, stats.CurrentStreak = a.calculateStreak(records)

    // åˆ†æå­¦ä¹ æ—¶æ®µåå¥½
    stats.PreferredTime = a.analyzeTimePreference(records)

    // åˆ†æè–„å¼±å­¦ä¹ æ—¥
    stats.WeakDays = a.analyzeWeakDays(records)

    // åˆ†ç±»ç»Ÿè®¡
    stats.Categories = a.analyzeCategoryStats(records)

    return stats, nil
}

func (a *LearningAnalytics) calculateStreak(records []LearningRecord) (longest, current int) {
    if len(records) == 0 {
        return 0, 0
    }

    // æŒ‰æ—¥æœŸåˆ†ç»„
    dateMap := make(map[string]bool)
    for _, record := range records {
        date := record.CreatedAt.Format("2006-01-02")
        dateMap[date] = true
    }

    // è®¡ç®—è¿ç»­å¤©æ•°
    today := time.Now()
    currentStreak := 0
    longestStreak := 0
    tempStreak := 0

    for i := 0; i < 365; i++ {
        date := today.AddDate(0, 0, -i).Format("2006-01-02")
        if dateMap[date] {
            tempStreak++
            if i == 0 || currentStreak > 0 {
                currentStreak++
            }
        } else {
            if tempStreak > longestStreak {
                longestStreak = tempStreak
            }
            tempStreak = 0
        }
    }

    return longestStreak, currentStreak
}

// TimeSlot æ—¶é—´æ®µ
type TimeSlot struct {
    Start time.Time `json:"start"`
    End   time.Time `json:"end"`
    Count int       `json:"count"`
}

func (a *LearningAnalytics) analyzeTimePreference(records []LearningRecord) []TimeSlot {
    // ç»Ÿè®¡å„æ—¶æ®µå­¦ä¹ æ¬¡æ•°
    slots := make(map[int]int) // hour -> count

    for _, record := range records {
        hour := record.CreatedAt.Hour()
        slots[hour]++
    }

    // æ‰¾å‡ºå­¦ä¹ é¢‘ç‡æœ€é«˜çš„æ—¶æ®µ
    var preferred []TimeSlot
    for hour, count := range slots {
        if count > 5 { // é˜ˆå€¼ï¼šè¶…è¿‡5æ¬¡
            slot := TimeSlot{
                Start: time.Date(0, 1, 1, hour, 0, 0, 0, time.UTC),
                End:   time.Date(0, 1, 1, hour+1, 0, 0, 0, time.UTC),
                Count: count,
            }
            preferred = append(preferred, slot)
        }
    }

    return preferred
}

// Weekday æ˜ŸæœŸ
type Weekday string

const (
    Monday    Weekday = "Monday"
    Tuesday   Weekday = "Tuesday"
    Wednesday Weekday = "Wednesday"
    Thursday  Weekday = "Thursday"
    Friday    Weekday = "Friday"
    Saturday  Weekday = "Saturday"
    Sunday    Weekday = "Sunday"
)

func (a *LearningAnalytics) analyzeWeakDays(records []LearningRecord) []Weekday {
    // ç»Ÿè®¡å„æ˜ŸæœŸçš„å­¦ä¹ æ¬¡æ•°
    weekdayCount := make(map[time.Weekday]int)

    for _, record := range records {
        weekday := record.CreatedAt.Weekday()
        weekdayCount[weekday]++
    }

    // æ‰¾å‡ºå­¦ä¹ æ¬¡æ•°æœ€å°‘çš„æ˜ŸæœŸ
    avgCount := len(records) / 7
    var weakDays []Weekday

    weekdayNames := map[time.Weekday]Weekday{
        time.Monday:    Monday,
        time.Tuesday:   Tuesday,
        time.Wednesday: Wednesday,
        time.Thursday:  Thursday,
        time.Friday:    Friday,
        time.Saturday:  Saturday,
        time.Sunday:    Sunday,
    }

    for wd := time.Monday; wd <= time.Sunday; wd++ {
        if weekdayCount[wd] < avgCount {
            weakDays = append(weakDays, weekdayNames[wd])
        }
    }

    return weakDays
}

func (a *LearningAnalytics) analyzeCategoryStats(records []LearningRecord) []CategoryStat {
    // æŒ‰åˆ†ç±»ç»Ÿè®¡
    categoryMap := make(map[string]*CategoryStat)

    for _, record := range records {
        stat, exists := categoryMap[record.Category]
        if !exists {
            stat = &CategoryStat{
                Category: record.Category,
            }
            categoryMap[record.Category] = stat
        }

        stat.Courses++
        stat.Duration += record.Duration
        stat.Progress += record.Progress
    }

    // è®¡ç®—å¹³å‡è¿›åº¦
    var stats []CategoryStat
    for _, stat := range categoryMap {
        stat.Progress /= stat.Courses
        stats = append(stats, *stat)
    }

    return stats
}

// LearningRecord å­¦ä¹ è®°å½•
type LearningRecord struct {
    UserID    string
    CourseID  string
    Category  string
    Duration  int
    Progress  int
    CreatedAt time.Time
}

// Period æ—¶é—´æ®µ
type Period struct {
    Start time.Time
    End   time.Time
}

func (p Period) Days() int {
    return int(p.End.Sub(p.Start).Hours() / 24)
}
```

---

## 7. è€ƒè¯•è¯„æµ‹ç³»ç»Ÿ

### 7.1 åœ¨çº¿è€ƒè¯•

```go
package exam

import (
    "context"
    "time"
)

// Exam è€ƒè¯•
type Exam struct {
    ID          string     `json:"id"`
    Title       string     `json:"title"`
    CourseID    string     `json:"course_id"`
    Duration    int        `json:"duration"` // è€ƒè¯•æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
    TotalScore  int        `json:"total_score"`
    PassScore   int        `json:"pass_score"` // åŠæ ¼åˆ†æ•°
    Questions   []Question `json:"questions"`
    StartTime   time.Time  `json:"start_time"`
    EndTime     time.Time  `json:"end_time"`
    Status      string     `json:"status"` // draft/published/closed
}

// Question è¯•é¢˜
type Question struct {
    ID      string        `json:"id"`
    Type    string        `json:"type"` // single/multiple/judge/fill/essay
    Content string        `json:"content"`
    Options []Option      `json:"options,omitempty"`
    Answer  interface{}   `json:"answer"` // æ­£ç¡®ç­”æ¡ˆ
    Score   int           `json:"score"`
    Analysis string       `json:"analysis"` // ç­”æ¡ˆè§£æ
}

// Option é€‰é¡¹
type Option struct {
    ID      string `json:"id"`
    Content string `json:"content"`
}

// ExamSession è€ƒè¯•ä¼šè¯
type ExamSession struct {
    ID          string              `json:"id"`
    ExamID      string              `json:"exam_id"`
    UserID      string              `json:"user_id"`
    Answers     map[string]interface{} `json:"answers"` // questionID -> answer
    Score       int                 `json:"score"`
    Status      string              `json:"status"` // in_progress/submitted/graded
    StartTime   time.Time           `json:"start_time"`
    SubmitTime  time.Time           `json:"submit_time,omitempty"`
    RemainingTime int               `json:"remaining_time"` // å‰©ä½™æ—¶é—´ï¼ˆç§’ï¼‰
}

// ExamService è€ƒè¯•æœåŠ¡
type ExamService struct {
    repo ExamRepository
}

// StartExam å¼€å§‹è€ƒè¯•
func (s *ExamService) StartExam(ctx context.Context, examID, userID string) (*ExamSession, error) {
    // è·å–è€ƒè¯•ä¿¡æ¯
    exam, err := s.repo.GetExam(ctx, examID)
    if err != nil {
        return nil, err
    }

    // æ£€æŸ¥è€ƒè¯•æ—¶é—´
    now := time.Now()
    if now.Before(exam.StartTime) {
        return nil, ErrExamNotStarted
    }
    if now.After(exam.EndTime) {
        return nil, ErrExamEnded
    }

    // æ£€æŸ¥æ˜¯å¦å·²å‚åŠ è¿‡
    if exists, _ := s.repo.HasSession(ctx, examID, userID); exists {
        return nil, ErrAlreadyTaken
    }

    // åˆ›å»ºè€ƒè¯•ä¼šè¯
    session := &ExamSession{
        ID:            generateID(),
        ExamID:        examID,
        UserID:        userID,
        Answers:       make(map[string]interface{}),
        Status:        "in_progress",
        StartTime:     now,
        RemainingTime: exam.Duration * 60,
    }

    if err := s.repo.CreateSession(ctx, session); err != nil {
        return nil, err
    }

    // å¯åŠ¨å€’è®¡æ—¶
    go s.countdown(session.ID, exam.Duration*60)

    return session, nil
}

// SubmitAnswer æäº¤ç­”æ¡ˆ
func (s *ExamService) SubmitAnswer(
    ctx context.Context,
    sessionID, questionID string,
    answer interface{},
) error {
    session, err := s.repo.GetSession(ctx, sessionID)
    if err != nil {
        return err
    }

    if session.Status != "in_progress" {
        return ErrSessionClosed
    }

    // ä¿å­˜ç­”æ¡ˆ
    session.Answers[questionID] = answer

    return s.repo.UpdateSession(ctx, session)
}

// SubmitExam æäº¤è€ƒè¯•
func (s *ExamService) SubmitExam(ctx context.Context, sessionID string) (*ExamResult, error) {
    session, err := s.repo.GetSession(ctx, sessionID)
    if err != nil {
        return nil, err
    }

    exam, err := s.repo.GetExam(ctx, session.ExamID)
    if err != nil {
        return nil, err
    }

    // è‡ªåŠ¨æ‰¹æ”¹
    result := s.gradeExam(exam, session)

    // æ›´æ–°ä¼šè¯çŠ¶æ€
    session.Status = "graded"
    session.Score = result.TotalScore
    session.SubmitTime = time.Now()
    s.repo.UpdateSession(ctx, session)

    return result, nil
}

// ExamResult è€ƒè¯•ç»“æœ
type ExamResult struct {
    SessionID     string                `json:"session_id"`
    UserID        string                `json:"user_id"`
    ExamID        string                `json:"exam_id"`
    TotalScore    int                   `json:"total_score"`
    PassScore     int                   `json:"pass_score"`
    IsPassed      bool                  `json:"is_passed"`
    QuestionResults []QuestionResult    `json:"question_results"`
    SubmitTime    time.Time             `json:"submit_time"`
}

// QuestionResult é¢˜ç›®ç»“æœ
type QuestionResult struct {
    QuestionID string      `json:"question_id"`
    UserAnswer interface{} `json:"user_answer"`
    IsCorrect  bool        `json:"is_correct"`
    Score      int         `json:"score"`
    Analysis   string      `json:"analysis"`
}

func (s *ExamService) gradeExam(exam *Exam, session *ExamSession) *ExamResult {
    result := &ExamResult{
        SessionID:  session.ID,
        UserID:     session.UserID,
        ExamID:     exam.ID,
        PassScore:  exam.PassScore,
        SubmitTime: time.Now(),
    }

    for _, question := range exam.Questions {
        userAnswer, exists := session.Answers[question.ID]
        if !exists {
            result.QuestionResults = append(result.QuestionResults, QuestionResult{
                QuestionID: question.ID,
                IsCorrect:  false,
                Score:      0,
                Analysis:   question.Analysis,
            })
            continue
        }

        // åˆ¤æ–­ç­”æ¡ˆæ˜¯å¦æ­£ç¡®
        isCorrect := s.checkAnswer(question, userAnswer)
        score := 0
        if isCorrect {
            score = question.Score
            result.TotalScore += score
        }

        result.QuestionResults = append(result.QuestionResults, QuestionResult{
            QuestionID: question.ID,
            UserAnswer: userAnswer,
            IsCorrect:  isCorrect,
            Score:      score,
            Analysis:   question.Analysis,
        })
    }

    result.IsPassed = result.TotalScore >= result.PassScore

    return result
}

func (s *ExamService) checkAnswer(question Question, userAnswer interface{}) bool {
    switch question.Type {
    case "single", "judge":
        return question.Answer == userAnswer
    case "multiple":
        // æ¯”è¾ƒæ•°ç»„
        correctAnswers, _ := question.Answer.([]string)
        userAnswers, _ := userAnswer.([]string)
        if len(correctAnswers) != len(userAnswers) {
            return false
        }
        for i := range correctAnswers {
            if correctAnswers[i] != userAnswers[i] {
                return false
            }
        }
        return true
    case "fill", "essay":
        // å¡«ç©ºé¢˜å’Œé—®ç­”é¢˜éœ€è¦äººå·¥æ‰¹æ”¹
        return false
    }
    return false
}

func (s *ExamService) countdown(sessionID string, duration int) {
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()

    remaining := duration

    for range ticker.C {
        remaining--
        if remaining <= 0 {
            // æ—¶é—´åˆ°ï¼Œè‡ªåŠ¨æäº¤
            s.SubmitExam(context.Background(), sessionID)
            break
        }
    }
}
```

---

## 8. è§†é¢‘ç›´æ’­ä¸ç‚¹æ’­

### 8.1 ç›´æ’­ç³»ç»Ÿ

```go
package streaming

import (
    "context"
    "sync"
    "time"
)

// LiveStream ç›´æ’­æµ
type LiveStream struct {
    ID          string    `json:"id"`
    Title       string    `json:"title"`
    TeacherID   string    `json:"teacher_id"`
    CourseID    string    `json:"course_id"`
    StreamKey   string    `json:"stream_key"` // æ¨æµå¯†é’¥
    PlayURL     string    `json:"play_url"` // æ’­æ”¾åœ°å€
    Status      string    `json:"status"` // preparing/live/ended
    Viewers     int       `json:"viewers"` // å½“å‰è§‚çœ‹äººæ•°
    MaxViewers  int       `json:"max_viewers"` // æœ€é«˜è§‚çœ‹äººæ•°
    StartTime   time.Time `json:"start_time"`
    EndTime     time.Time `json:"end_time,omitempty"`
}

// LiveStreamManager ç›´æ’­ç®¡ç†å™¨
type LiveStreamManager struct {
    streams map[string]*LiveStream
    viewers map[string]map[string]*Viewer // streamID -> userID -> Viewer
    mu      sync.RWMutex
}

// Viewer è§‚ä¼—
type Viewer struct {
    UserID    string
    JoinTime  time.Time
    HeartbeatTime time.Time
}

func NewLiveStreamManager() *LiveStreamManager {
    return &LiveStreamManager{
        streams: make(map[string]*LiveStream),
        viewers: make(map[string]map[string]*Viewer),
    }
}

// CreateStream åˆ›å»ºç›´æ’­
func (m *LiveStreamManager) CreateStream(ctx context.Context, req *CreateStreamRequest) (*LiveStream, error) {
    stream := &LiveStream{
        ID:        generateID(),
        Title:     req.Title,
        TeacherID: req.TeacherID,
        CourseID:  req.CourseID,
        StreamKey: generateStreamKey(),
        Status:    "preparing",
    }

    // ç”Ÿæˆæ’­æ”¾åœ°å€
    stream.PlayURL = fmt.Sprintf("rtmp://live.example.com/live/%s", stream.StreamKey)

    m.mu.Lock()
    m.streams[stream.ID] = stream
    m.viewers[stream.ID] = make(map[string]*Viewer)
    m.mu.Unlock()

    return stream, nil
}

// StartStream å¼€å§‹ç›´æ’­
func (m *LiveStreamManager) StartStream(ctx context.Context, streamID string) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    stream, exists := m.streams[streamID]
    if !exists {
        return ErrStreamNotFound
    }

    stream.Status = "live"
    stream.StartTime = time.Now()

    // é€šçŸ¥æ‰€æœ‰è§‚ä¼—
    go m.notifyViewers(streamID, "stream_started")

    return nil
}

// JoinStream åŠ å…¥ç›´æ’­
func (m *LiveStreamManager) JoinStream(ctx context.Context, streamID, userID string) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    stream, exists := m.streams[streamID]
    if !exists {
        return ErrStreamNotFound
    }

    if stream.Status != "live" {
        return ErrStreamNotLive
    }

    // æ·»åŠ è§‚ä¼—
    viewer := &Viewer{
        UserID:        userID,
        JoinTime:      time.Now(),
        HeartbeatTime: time.Now(),
    }

    m.viewers[streamID][userID] = viewer
    stream.Viewers++

    if stream.Viewers > stream.MaxViewers {
        stream.MaxViewers = stream.Viewers
    }

    return nil
}

// LeaveStream ç¦»å¼€ç›´æ’­
func (m *LiveStreamManager) LeaveStream(ctx context.Context, streamID, userID string) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    stream, exists := m.streams[streamID]
    if !exists {
        return ErrStreamNotFound
    }

    delete(m.viewers[streamID], userID)
    stream.Viewers--

    return nil
}

// Heartbeat å¿ƒè·³
func (m *LiveStreamManager) Heartbeat(ctx context.Context, streamID, userID string) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    viewers, exists := m.viewers[streamID]
    if !exists {
        return ErrStreamNotFound
    }

    viewer, exists := viewers[userID]
    if !exists {
        return ErrViewerNotFound
    }

    viewer.HeartbeatTime = time.Now()

    return nil
}

// CheckViewers æ£€æŸ¥è§‚ä¼—æ´»è·ƒçŠ¶æ€
func (m *LiveStreamManager) CheckViewers(ctx context.Context) {
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            m.removeInactiveViewers()
        }
    }
}

func (m *LiveStreamManager) removeInactiveViewers() {
    m.mu.Lock()
    defer m.mu.Unlock()

    now := time.Now()
    timeout := 60 * time.Second

    for streamID, viewers := range m.viewers {
        for userID, viewer := range viewers {
            if now.Sub(viewer.HeartbeatTime) > timeout {
                delete(viewers, userID)
                if stream, exists := m.streams[streamID]; exists {
                    stream.Viewers--
                }
            }
        }
    }
}

func (m *LiveStreamManager) notifyViewers(streamID, event string) {
    // é€šè¿‡WebSocketæˆ–æ¶ˆæ¯é˜Ÿåˆ—é€šçŸ¥è§‚ä¼—
}

// EndStream ç»“æŸç›´æ’­
func (m *LiveStreamManager) EndStream(ctx context.Context, streamID string) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    stream, exists := m.streams[streamID]
    if !exists {
        return ErrStreamNotFound
    }

    stream.Status = "ended"
    stream.EndTime = time.Now()

    // é€šçŸ¥æ‰€æœ‰è§‚ä¼—
    go m.notifyViewers(streamID, "stream_ended")

    return nil
}

// CreateStreamRequest åˆ›å»ºç›´æ’­è¯·æ±‚
type CreateStreamRequest struct {
    Title     string
    TeacherID string
    CourseID  string
}

func generateStreamKey() string {
    // ç”Ÿæˆå”¯ä¸€çš„æ¨æµå¯†é’¥
    return generateID()
}
```

---

## 9. å®Œæ•´é¡¹ç›®ï¼šåœ¨çº¿å­¦ä¹ å¹³å°

### 9.1 é¡¹ç›®ç»“æ„

```text
online-learning-platform/
â”œâ”€â”€ cmd/
â”‚   â”œâ”€â”€ api/              # APIæœåŠ¡
â”‚   â”œâ”€â”€ worker/           # åå°ä»»åŠ¡
â”‚   â””â”€â”€ admin/            # ç®¡ç†åå°
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ user/             # ç”¨æˆ·æ¨¡å—
â”‚   â”œâ”€â”€ course/           # è¯¾ç¨‹æ¨¡å—
â”‚   â”œâ”€â”€ learning/         # å­¦ä¹ æ¨¡å—
â”‚   â”œâ”€â”€ exam/             # è€ƒè¯•æ¨¡å—
â”‚   â”œâ”€â”€ interactive/      # äº’åŠ¨æ¨¡å—
â”‚   â”œâ”€â”€ analytics/        # åˆ†ææ¨¡å—
â”‚   â””â”€â”€ common/           # å…¬å…±æ¨¡å—
â”œâ”€â”€ pkg/
â”‚   â”œâ”€â”€ auth/             # è®¤è¯
â”‚   â”œâ”€â”€ storage/          # å­˜å‚¨
â”‚   â”œâ”€â”€ cache/            # ç¼“å­˜
â”‚   â””â”€â”€ queue/            # æ¶ˆæ¯é˜Ÿåˆ—
â”œâ”€â”€ web/                  # å‰ç«¯ä»£ç 
â”œâ”€â”€ migrations/           # æ•°æ®åº“è¿ç§»
â”œâ”€â”€ docs/                 # æ–‡æ¡£
â””â”€â”€ deploy/               # éƒ¨ç½²é…ç½®
```

### 9.2 æ ¸å¿ƒAPIå®ç°

```go
package api

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

// Server APIæœåŠ¡å™¨
type Server struct {
    router  *gin.Engine
    user    *UserService
    course  *CourseService
    learning *LearningService
    exam    *ExamService
}

func NewServer(
    user *UserService,
    course *CourseService,
    learning *LearningService,
    exam *ExamService,
) *Server {
    s := &Server{
        router:   gin.Default(),
        user:     user,
        course:   course,
        learning: learning,
        exam:     exam,
    }

    s.setupRoutes()
    return s
}

func (s *Server) setupRoutes() {
    // å…¬å¼€è·¯ç”±
    public := s.router.Group("/api/v1")
    {
        public.POST("/auth/register", s.handleRegister)
        public.POST("/auth/login", s.handleLogin)
        public.GET("/courses", s.handleListCourses)
        public.GET("/courses/:id", s.handleGetCourse)
    }

    // éœ€è¦è®¤è¯çš„è·¯ç”±
    auth := s.router.Group("/api/v1")
    auth.Use(AuthMiddleware())
    {
        // ç”¨æˆ·ç›¸å…³
        auth.GET("/user/profile", s.handleGetProfile)
        auth.PUT("/user/profile", s.handleUpdateProfile)

        // å­¦ä¹ ç›¸å…³
        auth.POST("/courses/:id/enroll", s.handleEnrollCourse)
        auth.POST("/learning/start", s.handleStartLearning)
        auth.POST("/learning/progress", s.handleUpdateProgress)
        auth.GET("/learning/stats", s.handleGetLearningStats)

        // è€ƒè¯•ç›¸å…³
        auth.POST("/exams/:id/start", s.handleStartExam)
        auth.POST("/exams/:id/answer", s.handleSubmitAnswer)
        auth.POST("/exams/:id/submit", s.handleSubmitExam)
        auth.GET("/exams/:id/result", s.handleGetExamResult)
    }

    // æ•™å¸ˆè·¯ç”±
    teacher := s.router.Group("/api/v1/teacher")
    teacher.Use(AuthMiddleware(), TeacherMiddleware())
    {
        teacher.POST("/courses", s.handleCreateCourse)
        teacher.PUT("/courses/:id", s.handleUpdateCourse)
        teacher.POST("/courses/:id/publish", s.handlePublishCourse)
        teacher.GET("/courses/:id/students", s.handleGetStudents)
    }
}

// handleRegister å¤„ç†æ³¨å†Œ
func (s *Server) handleRegister(c *gin.Context) {
    var req RegisterRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    user, err := s.user.Register(c.Request.Context(), req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, user)
}

// handleEnrollCourse å¤„ç†è¯¾ç¨‹æ³¨å†Œ
func (s *Server) handleEnrollCourse(c *gin.Context) {
    courseID := c.Param("id")
    userID := c.GetString("user_id")

    if err := s.course.Enroll(c.Request.Context(), userID, courseID); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, gin.H{"message": "enrolled successfully"})
}

// handleStartLearning å¤„ç†å¼€å§‹å­¦ä¹ 
func (s *Server) handleStartLearning(c *gin.Context) {
    var req StartLearningRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    userID := c.GetString("user_id")

    if err := s.learning.StartLearning(c.Request.Context(), userID, req.CourseID); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, gin.H{"message": "started"})
}

// Run å¯åŠ¨æœåŠ¡å™¨
func (s *Server) Run(addr string) error {
    return s.router.Run(addr)
}
```

---

## ğŸ’¡ æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **æŠ€æœ¯æ¶æ„**
   - å¾®æœåŠ¡æ¶æ„ï¼Œæ¨¡å—åŒ–è®¾è®¡
   - é«˜å¹¶å‘å¤„ç†ï¼Œæ”¯æŒå¤§é‡ç”¨æˆ·
   - å®æ—¶äº’åŠ¨ï¼ŒWebSocketé€šä¿¡
   - æ•°æ®åˆ†æï¼Œä¸ªæ€§åŒ–æ¨è

2. **å…³é”®æŠ€æœ¯**
   - è§†é¢‘å¤„ç†ï¼šffmpegè½¬ç ã€å¤šæ¸…æ™°åº¦
   - ç›´æ’­ç³»ç»Ÿï¼šRTMPæ¨æµã€HLS/RTMPæ’­æ”¾
   - å®æ—¶äº’åŠ¨ï¼šWebSocketã€é—®ç­”ã€ç™½æ¿
   - å­¦ä¹ åˆ†æï¼šè¡Œä¸ºè¿½è¸ªã€æ•°æ®æŒ–æ˜

3. **å·¥ç¨‹å®è·µ**
   - ä½¿ç”¨CDNåŠ é€Ÿå†…å®¹åˆ†å‘
   - å®ç°å¤šçº§ç¼“å­˜ç­–ç•¥
   - å¼‚æ­¥å¤„ç†è€—æ—¶ä»»åŠ¡
   - å®Œå–„çš„ç›‘æ§å‘Šè­¦ä½“ç³»

### è¿›é˜¶æ–¹å‘

1. **AIèµ‹èƒ½æ•™è‚²**
   - æ™ºèƒ½æ¨èè¯¾ç¨‹
   - è‡ªé€‚åº”å­¦ä¹ è·¯å¾„
   - è‡ªåŠ¨æ‰¹æ”¹ä½œä¸š
   - å­¦ä¹ æ•ˆæœé¢„æµ‹

2. **å¢å¼ºäº’åŠ¨ä½“éªŒ**
   - VR/ARè™šæ‹Ÿæ•™å®¤
   - å®æ—¶è¯­éŸ³è¯†åˆ«
   - æ™ºèƒ½ç­”ç–‘åŠ©æ‰‹
   - å¤šäººåä½œå­¦ä¹ 

3. **æ•°æ®é©±åŠ¨å†³ç­–**
   - å­¦ä¹ è¡Œä¸ºåˆ†æ
   - çŸ¥è¯†å›¾è°±æ„å»º
   - å­¦ä¹ æ•ˆæœè¯„ä¼°
   - ç²¾å‡†è¥é”€æ¨è

---

## ğŸ”— ç›¸å…³èµ„æº

**å¼€æºé¡¹ç›®**:

- [Moodle](https://github.com/moodle/moodle) - å¼€æºLMS
- [Open edX](https://github.com/openedx) - edXå¹³å°
- [Canvas LMS](https://github.com/instructure/canvas-lms)

**å‚è€ƒèµ„æ–™**:

- [åœ¨çº¿æ•™è‚²å¹³å°æ¶æ„è®¾è®¡](https://example.com)
- [è§†é¢‘ç›´æ’­æŠ€æœ¯å®è·µ](https://example.com)
- [å­¦ä¹ æ•°æ®åˆ†ææ–¹æ³•](https://example.com)

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ24æ—¥  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.21+
