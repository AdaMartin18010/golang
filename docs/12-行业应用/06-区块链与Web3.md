# GoåŒºå—é“¾ä¸Web3å¼€å‘å®Œå…¨æŒ‡å—

> **ç®€ä»‹**: Goè¯­è¨€åœ¨åŒºå—é“¾å’ŒWeb3é¢†åŸŸçš„å®Œæ•´å®è·µï¼Œæ¶µç›–æ™ºèƒ½åˆçº¦ã€åˆ†å¸ƒå¼å­˜å‚¨ã€å…±è¯†æœºåˆ¶ç­‰æ ¸å¿ƒåœºæ™¯

---

## ğŸ“š ç›®å½•

- [GoåŒºå—é“¾ä¸Web3å¼€å‘å®Œå…¨æŒ‡å—](#goåŒºå—é“¾ä¸web3å¼€å‘å®Œå…¨æŒ‡å—)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [1. åŒºå—é“¾åŸºç¡€](#1-åŒºå—é“¾åŸºç¡€)
    - [åŒºå—é“¾æ¶æ„](#åŒºå—é“¾æ¶æ„)
    - [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
    - [Goåœ¨åŒºå—é“¾ä¸­çš„åº”ç”¨](#goåœ¨åŒºå—é“¾ä¸­çš„åº”ç”¨)
  - [2. åŒºå—é“¾åŸºç¡€å®ç°](#2-åŒºå—é“¾åŸºç¡€å®ç°)
    - [åŒºå—ç»“æ„](#åŒºå—ç»“æ„)
    - [åŒºå—é“¾å®ç°](#åŒºå—é“¾å®ç°)
  - [3. å…±è¯†æœºåˆ¶](#3-å…±è¯†æœºåˆ¶)
    - [å·¥ä½œé‡è¯æ˜ï¼ˆPoWï¼‰](#å·¥ä½œé‡è¯æ˜pow)
    - [æƒç›Šè¯æ˜ï¼ˆPoSï¼‰](#æƒç›Šè¯æ˜pos)
  - [4. P2Pç½‘ç»œ](#4-p2pç½‘ç»œ)
    - [èŠ‚ç‚¹å‘ç°](#èŠ‚ç‚¹å‘ç°)
    - [æ¶ˆæ¯ä¼ æ’­](#æ¶ˆæ¯ä¼ æ’­)
  - [5. ä»¥å¤ªåŠé›†æˆ](#5-ä»¥å¤ªåŠé›†æˆ)
    - [è¿æ¥ä»¥å¤ªåŠèŠ‚ç‚¹](#è¿æ¥ä»¥å¤ªåŠèŠ‚ç‚¹)
    - [æ™ºèƒ½åˆçº¦äº¤äº’](#æ™ºèƒ½åˆçº¦äº¤äº’)
  - [6. æ™ºèƒ½åˆçº¦å¼€å‘](#6-æ™ºèƒ½åˆçº¦å¼€å‘)
    - [Solidityåˆçº¦ç¤ºä¾‹](#solidityåˆçº¦ç¤ºä¾‹)
    - [åˆçº¦éƒ¨ç½²](#åˆçº¦éƒ¨ç½²)
  - [7. DAppå¼€å‘](#7-dappå¼€å‘)
    - [Web3åç«¯](#web3åç«¯)
    - [é’±åŒ…é›†æˆ](#é’±åŒ…é›†æˆ)
  - [8. IPFSåˆ†å¸ƒå¼å­˜å‚¨](#8-ipfsåˆ†å¸ƒå¼å­˜å‚¨)
    - [IPFSå®¢æˆ·ç«¯](#ipfså®¢æˆ·ç«¯)
    - [NFTå…ƒæ•°æ®å­˜å‚¨](#nftå…ƒæ•°æ®å­˜å‚¨)
  - [9. DeFiåº”ç”¨](#9-defiåº”ç”¨)
    - [ä»·æ ¼é¢„è¨€æœº](#ä»·æ ¼é¢„è¨€æœº)
    - [æµåŠ¨æ€§æ± ç›‘æ§](#æµåŠ¨æ€§æ± ç›‘æ§)
  - [10. NFTå¼€å‘](#10-nftå¼€å‘)
    - [NFTåˆçº¦äº¤äº’](#nftåˆçº¦äº¤äº’)
    - [NFTå¸‚åœº](#nftå¸‚åœº)
  - [11. å®æˆ˜é¡¹ç›®ï¼šå»ä¸­å¿ƒåŒ–äº¤æ˜“æ‰€(DEX)](#11-å®æˆ˜é¡¹ç›®å»ä¸­å¿ƒåŒ–äº¤æ˜“æ‰€dex)
    - [ç³»ç»Ÿæ¶æ„](#ç³»ç»Ÿæ¶æ„)
    - [æ ¸å¿ƒå®ç°](#æ ¸å¿ƒå®ç°)
  - [12. å®‰å…¨ä¸æœ€ä½³å®è·µ](#12-å®‰å…¨ä¸æœ€ä½³å®è·µ)
  - [13. å¼€æºé¡¹ç›®æ¨è](#13-å¼€æºé¡¹ç›®æ¨è)

---

## 1. åŒºå—é“¾åŸºç¡€

### åŒºå—é“¾æ¶æ„

```mermaid
graph TB
    User[ç”¨æˆ·] --> Wallet[é’±åŒ…]
    Wallet --> Node[èŠ‚ç‚¹]
    Node --> Consensus[å…±è¯†å±‚]
    Node --> Network[ç½‘ç»œå±‚]
    Node --> Storage[å­˜å‚¨å±‚]
    
    Consensus --> SmartContract[æ™ºèƒ½åˆçº¦]
    SmartContract --> State[çŠ¶æ€æ•°æ®åº“]
    Storage --> Blockchain[åŒºå—é“¾æ•°æ®]
    
    style User fill:#e1f5fe
    style Node fill:#fff3e0
    style Consensus fill:#f3e5f5
    style SmartContract fill:#e8f5e9
```

### æ ¸å¿ƒæ¦‚å¿µ

- **åŒºå—ï¼ˆBlockï¼‰**: åŒ…å«äº¤æ˜“æ•°æ®çš„æ•°æ®ç»“æ„
- **é“¾ï¼ˆChainï¼‰**: åŒºå—é€šè¿‡å“ˆå¸Œå€¼é“¾æ¥å½¢æˆçš„é“¾å¼ç»“æ„
- **å…±è¯†ï¼ˆConsensusï¼‰**: ç½‘ç»œèŠ‚ç‚¹è¾¾æˆä¸€è‡´çš„æœºåˆ¶
- **æ™ºèƒ½åˆçº¦ï¼ˆSmart Contractï¼‰**: è‡ªåŠ¨æ‰§è¡Œçš„ä»£ç 
- **Gas**: æ‰§è¡Œæ“ä½œæ‰€éœ€çš„è®¡ç®—è´¹ç”¨
- **æŒ–çŸ¿ï¼ˆMiningï¼‰**: åˆ›å»ºæ–°åŒºå—çš„è¿‡ç¨‹
- **èŠ‚ç‚¹ï¼ˆNodeï¼‰**: ç½‘ç»œä¸­çš„å‚ä¸è€…

### Goåœ¨åŒºå—é“¾ä¸­çš„åº”ç”¨

- âœ… **é«˜æ€§èƒ½**: é€‚åˆå¤„ç†å¤§é‡å¹¶å‘äº¤æ˜“
- âœ… **ç®€æ´æ€§**: ä»£ç ç®€å•æ˜“äºå®¡è®¡
- âœ… **è·¨å¹³å°**: æ”¯æŒå¤šç§æ“ä½œç³»ç»Ÿ
- âœ… **å¹¶å‘æ”¯æŒ**: Goroutineé€‚åˆP2Pç½‘ç»œç¼–ç¨‹
- âœ… **æ ‡å‡†åº“**: å®Œå–„çš„åŠ å¯†å’Œç½‘ç»œåº“

---

## 2. åŒºå—é“¾åŸºç¡€å®ç°

### åŒºå—ç»“æ„

```go
package blockchain

import (
    "crypto/sha256"
    "encoding/hex"
    "encoding/json"
    "time"
)

// Block åŒºå—ç»“æ„
type Block struct {
    Index        int64         `json:"index"`
    Timestamp    int64         `json:"timestamp"`
    Transactions []Transaction `json:"transactions"`
    PrevHash     string        `json:"prev_hash"`
    Hash         string        `json:"hash"`
    Nonce        int64         `json:"nonce"`
    Difficulty   int           `json:"difficulty"`
}

// Transaction äº¤æ˜“ç»“æ„
type Transaction struct {
    From      string  `json:"from"`
    To        string  `json:"to"`
    Amount    float64 `json:"amount"`
    Timestamp int64   `json:"timestamp"`
    Signature string  `json:"signature"`
}

// NewBlock åˆ›å»ºæ–°åŒºå—
func NewBlock(index int64, transactions []Transaction, prevHash string, difficulty int) *Block {
    block := &Block{
        Index:        index,
        Timestamp:    time.Now().Unix(),
        Transactions: transactions,
        PrevHash:     prevHash,
        Difficulty:   difficulty,
        Nonce:        0,
    }
    
    return block
}

// CalculateHash è®¡ç®—åŒºå—å“ˆå¸Œ
func (b *Block) CalculateHash() string {
    data, _ := json.Marshal(struct {
        Index        int64
        Timestamp    int64
        Transactions []Transaction
        PrevHash     string
        Nonce        int64
    }{
        Index:        b.Index,
        Timestamp:    b.Timestamp,
        Transactions: b.Transactions,
        PrevHash:     b.PrevHash,
        Nonce:        b.Nonce,
    })
    
    hash := sha256.Sum256(data)
    return hex.EncodeToString(hash[:])
}

// Mine æŒ–çŸ¿ï¼ˆå·¥ä½œé‡è¯æ˜ï¼‰
func (b *Block) Mine() {
    target := strings.Repeat("0", b.Difficulty)
    
    for {
        b.Hash = b.CalculateHash()
        if strings.HasPrefix(b.Hash, target) {
            break
        }
        b.Nonce++
    }
    
    log.Printf("Block mined! Hash: %s, Nonce: %d", b.Hash, b.Nonce)
}

// Validate éªŒè¯åŒºå—
func (b *Block) Validate() bool {
    // éªŒè¯å“ˆå¸Œ
    if b.Hash != b.CalculateHash() {
        return false
    }
    
    // éªŒè¯éš¾åº¦
    target := strings.Repeat("0", b.Difficulty)
    if !strings.HasPrefix(b.Hash, target) {
        return false
    }
    
    return true
}
```

### åŒºå—é“¾å®ç°

```go
// Blockchain åŒºå—é“¾
type Blockchain struct {
    Blocks     []*Block
    Difficulty int
    mu         sync.RWMutex
}

// NewBlockchain åˆ›å»ºåŒºå—é“¾
func NewBlockchain(difficulty int) *Blockchain {
    // åˆ›å»ºåˆ›ä¸–åŒºå—
    genesisBlock := NewBlock(0, []Transaction{}, "", difficulty)
    genesisBlock.Mine()
    
    return &Blockchain{
        Blocks:     []*Block{genesisBlock},
        Difficulty: difficulty,
    }
}

// AddBlock æ·»åŠ åŒºå—
func (bc *Blockchain) AddBlock(transactions []Transaction) error {
    bc.mu.Lock()
    defer bc.mu.Unlock()
    
    prevBlock := bc.Blocks[len(bc.Blocks)-1]
    
    newBlock := NewBlock(
        prevBlock.Index+1,
        transactions,
        prevBlock.Hash,
        bc.Difficulty,
    )
    
    newBlock.Mine()
    
    if !bc.isValidNewBlock(newBlock, prevBlock) {
        return errors.New("invalid block")
    }
    
    bc.Blocks = append(bc.Blocks, newBlock)
    return nil
}

// isValidNewBlock éªŒè¯æ–°åŒºå—
func (bc *Blockchain) isValidNewBlock(newBlock, prevBlock *Block) bool {
    if prevBlock.Index+1 != newBlock.Index {
        return false
    }
    
    if prevBlock.Hash != newBlock.PrevHash {
        return false
    }
    
    if !newBlock.Validate() {
        return false
    }
    
    return true
}

// Validate éªŒè¯æ•´ä¸ªåŒºå—é“¾
func (bc *Blockchain) Validate() bool {
    bc.mu.RLock()
    defer bc.mu.RUnlock()
    
    for i := 1; i < len(bc.Blocks); i++ {
        if !bc.isValidNewBlock(bc.Blocks[i], bc.Blocks[i-1]) {
            return false
        }
    }
    
    return true
}

// GetLatestBlock è·å–æœ€æ–°åŒºå—
func (bc *Blockchain) GetLatestBlock() *Block {
    bc.mu.RLock()
    defer bc.mu.RUnlock()
    
    return bc.Blocks[len(bc.Blocks)-1]
}
```

---

## 3. å…±è¯†æœºåˆ¶

### å·¥ä½œé‡è¯æ˜ï¼ˆPoWï¼‰

```go
package consensus

import (
    "crypto/sha256"
    "encoding/hex"
    "math/big"
)

// ProofOfWork å·¥ä½œé‡è¯æ˜
type ProofOfWork struct {
    target *big.Int
}

func NewProofOfWork(difficulty int) *ProofOfWork {
    target := big.NewInt(1)
    target.Lsh(target, uint(256-difficulty))
    
    return &ProofOfWork{target: target}
}

// Run æ‰§è¡Œå·¥ä½œé‡è¯æ˜
func (pow *ProofOfWork) Run(data []byte, nonce int64) (int64, string) {
    var hashInt big.Int
    var hash [32]byte
    
    for nonce < math.MaxInt64 {
        dataWithNonce := append(data, []byte(fmt.Sprint(nonce))...)
        hash = sha256.Sum256(dataWithNonce)
        
        hashInt.SetBytes(hash[:])
        
        if hashInt.Cmp(pow.target) == -1 {
            break
        }
        
        nonce++
    }
    
    return nonce, hex.EncodeToString(hash[:])
}

// Validate éªŒè¯å·¥ä½œé‡è¯æ˜
func (pow *ProofOfWork) Validate(data []byte, nonce int64, hash string) bool {
    var hashInt big.Int
    
    dataWithNonce := append(data, []byte(fmt.Sprint(nonce))...)
    calculatedHash := sha256.Sum256(dataWithNonce)
    
    if hex.EncodeToString(calculatedHash[:]) != hash {
        return false
    }
    
    hashInt.SetBytes(calculatedHash[:])
    return hashInt.Cmp(pow.target) == -1
}
```

### æƒç›Šè¯æ˜ï¼ˆPoSï¼‰

```go
// ProofOfStake æƒç›Šè¯æ˜
type ProofOfStake struct {
    validators map[string]int64 // address -> stake
    mu         sync.RWMutex
}

func NewProofOfStake() *ProofOfStake {
    return &ProofOfStake{
        validators: make(map[string]int64),
    }
}

// AddValidator æ·»åŠ éªŒè¯è€…
func (pos *ProofOfStake) AddValidator(address string, stake int64) {
    pos.mu.Lock()
    defer pos.mu.Unlock()
    
    pos.validators[address] = stake
}

// SelectValidator é€‰æ‹©éªŒè¯è€…ï¼ˆåŸºäºæƒç›Šï¼‰
func (pos *ProofOfStake) SelectValidator() string {
    pos.mu.RLock()
    defer pos.mu.RUnlock()
    
    // è®¡ç®—æ€»æƒç›Š
    totalStake := int64(0)
    for _, stake := range pos.validators {
        totalStake += stake
    }
    
    // éšæœºé€‰æ‹©ï¼ˆæƒé‡åŸºäºæƒç›Šï¼‰
    rand.Seed(time.Now().UnixNano())
    randomPoint := rand.Int63n(totalStake)
    
    currentSum := int64(0)
    for address, stake := range pos.validators {
        currentSum += stake
        if currentSum > randomPoint {
            return address
        }
    }
    
    return ""
}

// Slash æƒ©ç½šæ¶æ„éªŒè¯è€…
func (pos *ProofOfStake) Slash(address string, amount int64) {
    pos.mu.Lock()
    defer pos.mu.Unlock()
    
    if stake, exists := pos.validators[address]; exists {
        pos.validators[address] = stake - amount
        if pos.validators[address] <= 0 {
            delete(pos.validators, address)
        }
    }
}
```

---

## 4. P2Pç½‘ç»œ

### èŠ‚ç‚¹å‘ç°

```go
package p2p

import (
    "context"
    "sync"
    
    "github.com/libp2p/go-libp2p"
    "github.com/libp2p/go-libp2p-core/host"
    "github.com/libp2p/go-libp2p-core/peer"
)

// P2PNode P2PèŠ‚ç‚¹
type P2PNode struct {
    host  host.Host
    peers map[peer.ID]*Peer
    mu    sync.RWMutex
}

type Peer struct {
    ID       peer.ID
    Address  string
    LastSeen time.Time
}

func NewP2PNode(ctx context.Context, port int) (*P2PNode, error) {
    h, err := libp2p.New(
        libp2p.ListenAddrStrings(
            fmt.Sprintf("/ip4/0.0.0.0/tcp/%d", port),
        ),
    )
    if err != nil {
        return nil, err
    }
    
    return &P2PNode{
        host:  h,
        peers: make(map[peer.ID]*Peer),
    }, nil
}

// Connect è¿æ¥åˆ°å…¶ä»–èŠ‚ç‚¹
func (n *P2PNode) Connect(ctx context.Context, peerAddr string) error {
    maddr, err := multiaddr.NewMultiaddr(peerAddr)
    if err != nil {
        return err
    }
    
    peerInfo, err := peer.AddrInfoFromP2pAddr(maddr)
    if err != nil {
        return err
    }
    
    if err := n.host.Connect(ctx, *peerInfo); err != nil {
        return err
    }
    
    n.mu.Lock()
    n.peers[peerInfo.ID] = &Peer{
        ID:       peerInfo.ID,
        Address:  peerAddr,
        LastSeen: time.Now(),
    }
    n.mu.Unlock()
    
    return nil
}

// GetPeers è·å–æ‰€æœ‰èŠ‚ç‚¹
func (n *P2PNode) GetPeers() []*Peer {
    n.mu.RLock()
    defer n.mu.RUnlock()
    
    peers := make([]*Peer, 0, len(n.peers))
    for _, peer := range n.peers {
        peers = append(peers, peer)
    }
    
    return peers
}

// Broadcast å¹¿æ’­æ¶ˆæ¯
func (n *P2PNode) Broadcast(ctx context.Context, msg []byte) error {
    n.mu.RLock()
    peers := make([]peer.ID, 0, len(n.peers))
    for id := range n.peers {
        peers = append(peers, id)
    }
    n.mu.RUnlock()
    
    for _, peerID := range peers {
        stream, err := n.host.NewStream(ctx, peerID, "/blockchain/1.0.0")
        if err != nil {
            log.Printf("Failed to open stream to %s: %v", peerID, err)
            continue
        }
        
        if _, err := stream.Write(msg); err != nil {
            log.Printf("Failed to send message to %s: %v", peerID, err)
        }
        
        stream.Close()
    }
    
    return nil
}
```

### æ¶ˆæ¯ä¼ æ’­

```go
// MessageHandler æ¶ˆæ¯å¤„ç†å™¨
type MessageHandler struct {
    blockchain *Blockchain
    node       *P2PNode
}

func NewMessageHandler(blockchain *Blockchain, node *P2PNode) *MessageHandler {
    return &MessageHandler{
        blockchain: blockchain,
        node:       node,
    }
}

// HandleNewBlock å¤„ç†æ–°åŒºå—
func (h *MessageHandler) HandleNewBlock(block *Block) error {
    // éªŒè¯åŒºå—
    latestBlock := h.blockchain.GetLatestBlock()
    if !h.blockchain.isValidNewBlock(block, latestBlock) {
        return errors.New("invalid block")
    }
    
    // æ·»åŠ åˆ°åŒºå—é“¾
    h.blockchain.mu.Lock()
    h.blockchain.Blocks = append(h.blockchain.Blocks, block)
    h.blockchain.mu.Unlock()
    
    // å¹¿æ’­ç»™å…¶ä»–èŠ‚ç‚¹
    data, _ := json.Marshal(block)
    h.node.Broadcast(context.Background(), data)
    
    return nil
}

// HandleNewTransaction å¤„ç†æ–°äº¤æ˜“
func (h *MessageHandler) HandleNewTransaction(tx Transaction) error {
    // éªŒè¯äº¤æ˜“
    if !h.validateTransaction(tx) {
        return errors.New("invalid transaction")
    }
    
    // å¹¿æ’­äº¤æ˜“
    data, _ := json.Marshal(tx)
    h.node.Broadcast(context.Background(), data)
    
    return nil
}

func (h *MessageHandler) validateTransaction(tx Transaction) bool {
    // ç®€åŒ–çš„äº¤æ˜“éªŒè¯
    if tx.Amount <= 0 {
        return false
    }
    
    if tx.From == "" || tx.To == "" {
        return false
    }
    
    return true
}
```

---

## 5. ä»¥å¤ªåŠé›†æˆ

### è¿æ¥ä»¥å¤ªåŠèŠ‚ç‚¹

```go
package ethereum

import (
    "context"
    "math/big"
    
    "github.com/ethereum/go-ethereum/ethclient"
    "github.com/ethereum/go-ethereum/common"
)

// EthereumClient ä»¥å¤ªåŠå®¢æˆ·ç«¯
type EthereumClient struct {
    client *ethclient.Client
}

func NewEthereumClient(nodeURL string) (*EthereumClient, error) {
    client, err := ethclient.Dial(nodeURL)
    if err != nil {
        return nil, err
    }
    
    return &EthereumClient{client: client}, nil
}

// GetBalance è·å–ä½™é¢
func (ec *EthereumClient) GetBalance(ctx context.Context, address string) (*big.Int, error) {
    account := common.HexToAddress(address)
    balance, err := ec.client.BalanceAt(ctx, account, nil)
    if err != nil {
        return nil, err
    }
    
    return balance, nil
}

// GetBlockNumber è·å–æœ€æ–°åŒºå—å·
func (ec *EthereumClient) GetBlockNumber(ctx context.Context) (uint64, error) {
    return ec.client.BlockNumber(ctx)
}

// GetBlock è·å–åŒºå—ä¿¡æ¯
func (ec *EthereumClient) GetBlock(ctx context.Context, blockNumber *big.Int) (*types.Block, error) {
    return ec.client.BlockByNumber(ctx, blockNumber)
}

// SendTransaction å‘é€äº¤æ˜“
func (ec *EthereumClient) SendTransaction(ctx context.Context, tx *types.Transaction) error {
    return ec.client.SendTransaction(ctx, tx)
}

func (ec *EthereumClient) Close() {
    ec.client.Close()
}
```

### æ™ºèƒ½åˆçº¦äº¤äº’

```go
// ContractClient åˆçº¦å®¢æˆ·ç«¯
type ContractClient struct {
    client   *ethclient.Client
    contract *bind.BoundContract
}

func NewContractClient(nodeURL, contractAddress string, abi string) (*ContractClient, error) {
    client, err := ethclient.Dial(nodeURL)
    if err != nil {
        return nil, err
    }
    
    parsedABI, err := abi.JSON(strings.NewReader(abi))
    if err != nil {
        return nil, err
    }
    
    address := common.HexToAddress(contractAddress)
    contract := bind.NewBoundContract(address, parsedABI, client, client, client)
    
    return &ContractClient{
        client:   client,
        contract: contract,
    }, nil
}

// Call è°ƒç”¨åªè¯»æ–¹æ³•
func (cc *ContractClient) Call(ctx context.Context, result interface{}, method string, args ...interface{}) error {
    return cc.contract.Call(&bind.CallOpts{Context: ctx}, result, method, args...)
}

// Transact è°ƒç”¨å†™å…¥æ–¹æ³•
func (cc *ContractClient) Transact(ctx context.Context, key *ecdsa.PrivateKey, method string, args ...interface{}) (*types.Transaction, error) {
    auth, err := bind.NewKeyedTransactorWithChainID(key, big.NewInt(1)) // Mainnet
    if err != nil {
        return nil, err
    }
    
    auth.Context = ctx
    
    return cc.contract.Transact(auth, method, args...)
}

// WatchLogs ç›‘å¬äº‹ä»¶
func (cc *ContractClient) WatchLogs(ctx context.Context, eventName string, handler func(log types.Log)) error {
    query := ethereum.FilterQuery{
        Addresses: []common.Address{cc.contract.Address()},
    }
    
    logs := make(chan types.Log)
    sub, err := cc.client.SubscribeFilterLogs(ctx, query, logs)
    if err != nil {
        return err
    }
    
    go func() {
        for {
            select {
            case err := <-sub.Err():
                log.Printf("Subscription error: %v", err)
                return
            case vLog := <-logs:
                handler(vLog)
            }
        }
    }()
    
    return nil
}
```

---

## 6. æ™ºèƒ½åˆçº¦å¼€å‘

### Solidityåˆçº¦ç¤ºä¾‹

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleToken {
    string public name = "SimpleToken";
    string public symbol = "STK";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    constructor(uint256 _initialSupply) {
        totalSupply = _initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }
    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, "Insufficient balance");
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from], "Insufficient balance");
        require(_value <= allowance[_from][msg.sender], "Allowance exceeded");
        
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        
        emit Transfer(_from, _to, _value);
        return true;
    }
}
```

### åˆçº¦éƒ¨ç½²

```go
package deploy

import (
    "context"
    "crypto/ecdsa"
    "math/big"
    
    "github.com/ethereum/go-ethereum/accounts/abi/bind"
    "github.com/ethereum/go-ethereum/crypto"
    "github.com/ethereum/go-ethereum/ethclient"
)

// DeployContract éƒ¨ç½²åˆçº¦
func DeployContract(ctx context.Context, nodeURL, privateKeyHex string) (common.Address, *types.Transaction, error) {
    client, err := ethclient.Dial(nodeURL)
    if err != nil {
        return common.Address{}, nil, err
    }
    defer client.Close()
    
    // åŠ è½½ç§é’¥
    privateKey, err := crypto.HexToECDSA(privateKeyHex)
    if err != nil {
        return common.Address{}, nil, err
    }
    
    publicKey := privateKey.Public()
    publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
    if !ok {
        return common.Address{}, nil, errors.New("invalid public key")
    }
    
    fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA)
    
    // è·å–nonce
    nonce, err := client.PendingNonceAt(ctx, fromAddress)
    if err != nil {
        return common.Address{}, nil, err
    }
    
    // è·å–gasä»·æ ¼
    gasPrice, err := client.SuggestGasPrice(ctx)
    if err != nil {
        return common.Address{}, nil, err
    }
    
    // åˆ›å»ºäº¤æ˜“é€‰é¡¹
    auth, err := bind.NewKeyedTransactorWithChainID(privateKey, big.NewInt(1))
    if err != nil {
        return common.Address{}, nil, err
    }
    
    auth.Nonce = big.NewInt(int64(nonce))
    auth.Value = big.NewInt(0)
    auth.GasLimit = uint64(3000000)
    auth.GasPrice = gasPrice
    auth.Context = ctx
    
    // éƒ¨ç½²åˆçº¦ï¼ˆè¿™é‡Œéœ€è¦ç”Ÿæˆçš„Goåˆçº¦ç»‘å®šä»£ç ï¼‰
    address, tx, _, err := DeploySimpleToken(auth, client, big.NewInt(1000000))
    if err != nil {
        return common.Address{}, nil, err
    }
    
    log.Printf("Contract deployed at: %s", address.Hex())
    log.Printf("Transaction hash: %s", tx.Hash().Hex())
    
    return address, tx, nil
}
```

---

## 7. DAppå¼€å‘

### Web3åç«¯

```go
package dapp

import (
    "encoding/json"
    "net/http"
    
    "github.com/gorilla/mux"
)

// DAppBackend DAppåç«¯
type DAppBackend struct {
    ethClient      *EthereumClient
    contractClient *ContractClient
}

func NewDAppBackend(nodeURL, contractAddress, abi string) (*DAppBackend, error) {
    ethClient, err := NewEthereumClient(nodeURL)
    if err != nil {
        return nil, err
    }
    
    contractClient, err := NewContractClient(nodeURL, contractAddress, abi)
    if err != nil {
        return nil, err
    }
    
    return &DAppBackend{
        ethClient:      ethClient,
        contractClient: contractClient,
    }, nil
}

// SetupRoutes è®¾ç½®è·¯ç”±
func (b *DAppBackend) SetupRoutes(router *mux.Router) {
    router.HandleFunc("/api/balance/{address}", b.handleGetBalance).Methods("GET")
    router.HandleFunc("/api/transfer", b.handleTransfer).Methods("POST")
    router.HandleFunc("/api/transactions/{address}", b.handleGetTransactions).Methods("GET")
}

func (b *DAppBackend) handleGetBalance(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    address := vars["address"]
    
    balance, err := b.ethClient.GetBalance(r.Context(), address)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    response := map[string]interface{}{
        "address": address,
        "balance": balance.String(),
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}

func (b *DAppBackend) handleTransfer(w http.ResponseWriter, r *http.Request) {
    var req struct {
        From       string `json:"from"`
        To         string `json:"to"`
        Amount     string `json:"amount"`
        PrivateKey string `json:"private_key"`
    }
    
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    // æ‰§è¡Œè½¬è´¦ï¼ˆéœ€è¦å®ç°ï¼‰
    // ...
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]string{
        "status": "success",
    })
}

func (b *DAppBackend) handleGetTransactions(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    address := vars["address"]
    
    // è·å–äº¤æ˜“å†å²ï¼ˆéœ€è¦å®ç°ï¼‰
    // ...
    
    transactions := []map[string]interface{}{
        {
            "hash":      "0x...",
            "from":      "0x...",
            "to":        address,
            "value":     "1000000000000000000",
            "timestamp": time.Now().Unix(),
        },
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(transactions)
}
```

### é’±åŒ…é›†æˆ

```go
// Wallet é’±åŒ…
type Wallet struct {
    privateKey *ecdsa.PrivateKey
    publicKey  *ecdsa.PublicKey
    address    common.Address
}

func NewWallet() (*Wallet, error) {
    privateKey, err := crypto.GenerateKey()
    if err != nil {
        return nil, err
    }
    
    publicKey := privateKey.Public()
    publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
    if !ok {
        return nil, errors.New("failed to cast public key")
    }
    
    address := crypto.PubkeyToAddress(*publicKeyECDSA)
    
    return &Wallet{
        privateKey: privateKey,
        publicKey:  publicKeyECDSA,
        address:    address,
    }, nil
}

// LoadWallet ä»ç§é’¥åŠ è½½é’±åŒ…
func LoadWallet(privateKeyHex string) (*Wallet, error) {
    privateKey, err := crypto.HexToECDSA(privateKeyHex)
    if err != nil {
        return nil, err
    }
    
    publicKey := privateKey.Public()
    publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
    if !ok {
        return nil, errors.New("failed to cast public key")
    }
    
    address := crypto.PubkeyToAddress(*publicKeyECDSA)
    
    return &Wallet{
        privateKey: privateKey,
        publicKey:  publicKeyECDSA,
        address:    address,
    }, nil
}

// GetAddress è·å–åœ°å€
func (w *Wallet) GetAddress() string {
    return w.address.Hex()
}

// GetPrivateKey è·å–ç§é’¥ï¼ˆ16è¿›åˆ¶ï¼‰
func (w *Wallet) GetPrivateKey() string {
    return hex.EncodeToString(crypto.FromECDSA(w.privateKey))
}

// SignMessage ç­¾åæ¶ˆæ¯
func (w *Wallet) SignMessage(message []byte) ([]byte, error) {
    hash := crypto.Keccak256Hash(message)
    signature, err := crypto.Sign(hash.Bytes(), w.privateKey)
    if err != nil {
        return nil, err
    }
    
    return signature, nil
}
```

---

## 8. IPFSåˆ†å¸ƒå¼å­˜å‚¨

### IPFSå®¢æˆ·ç«¯

```go
package ipfs

import (
    "bytes"
    "io"
    
    shell "github.com/ipfs/go-ipfs-api"
)

// IPFSClient IPFSå®¢æˆ·ç«¯
type IPFSClient struct {
    shell *shell.Shell
}

func NewIPFSClient(url string) *IPFSClient {
    return &IPFSClient{
        shell: shell.NewShell(url),
    }
}

// Add æ·»åŠ æ–‡ä»¶
func (c *IPFSClient) Add(data []byte) (string, error) {
    return c.shell.Add(bytes.NewReader(data))
}

// Get è·å–æ–‡ä»¶
func (c *IPFSClient) Get(hash string) ([]byte, error) {
    reader, err := c.shell.Cat(hash)
    if err != nil {
        return nil, err
    }
    defer reader.Close()
    
    return io.ReadAll(reader)
}

// AddFile æ·»åŠ æ–‡ä»¶
func (c *IPFSClient) AddFile(path string) (string, error) {
    return c.shell.AddDir(path)
}

// Pin å›ºå®šå†…å®¹
func (c *IPFSClient) Pin(hash string) error {
    return c.shell.Pin(hash)
}

// Unpin å–æ¶ˆå›ºå®š
func (c *IPFSClient) Unpin(hash string) error {
    return c.shell.Unpin(hash)
}
```

### NFTå…ƒæ•°æ®å­˜å‚¨

```go
// NFTMetadata NFTå…ƒæ•°æ®
type NFTMetadata struct {
    Name        string            `json:"name"`
    Description string            `json:"description"`
    Image       string            `json:"image"`
    Attributes  []NFTAttribute    `json:"attributes"`
    ExternalURL string            `json:"external_url,omitempty"`
}

type NFTAttribute struct {
    TraitType string      `json:"trait_type"`
    Value     interface{} `json:"value"`
}

// NFTStorage NFTå­˜å‚¨
type NFTStorage struct {
    ipfs *IPFSClient
}

func NewNFTStorage(ipfsURL string) *NFTStorage {
    return &NFTStorage{
        ipfs: NewIPFSClient(ipfsURL),
    }
}

// UploadImage ä¸Šä¼ å›¾ç‰‡
func (s *NFTStorage) UploadImage(imageData []byte) (string, error) {
    hash, err := s.ipfs.Add(imageData)
    if err != nil {
        return "", err
    }
    
    // å›ºå®šå†…å®¹
    if err := s.ipfs.Pin(hash); err != nil {
        return "", err
    }
    
    return fmt.Sprintf("ipfs://%s", hash), nil
}

// UploadMetadata ä¸Šä¼ å…ƒæ•°æ®
func (s *NFTStorage) UploadMetadata(metadata *NFTMetadata) (string, error) {
    data, err := json.Marshal(metadata)
    if err != nil {
        return "", err
    }
    
    hash, err := s.ipfs.Add(data)
    if err != nil {
        return "", err
    }
    
    // å›ºå®šå†…å®¹
    if err := s.ipfs.Pin(hash); err != nil {
        return "", err
    }
    
    return fmt.Sprintf("ipfs://%s", hash), nil
}

// GetMetadata è·å–å…ƒæ•°æ®
func (s *NFTStorage) GetMetadata(uri string) (*NFTMetadata, error) {
    // ç§»é™¤ ipfs:// å‰ç¼€
    hash := strings.TrimPrefix(uri, "ipfs://")
    
    data, err := s.ipfs.Get(hash)
    if err != nil {
        return nil, err
    }
    
    var metadata NFTMetadata
    if err := json.Unmarshal(data, &metadata); err != nil {
        return nil, err
    }
    
    return &metadata, nil
}
```

---

## 9. DeFiåº”ç”¨

### ä»·æ ¼é¢„è¨€æœº

```go
package defi

import (
    "encoding/json"
    "net/http"
    "time"
)

// PriceOracle ä»·æ ¼é¢„è¨€æœº
type PriceOracle struct {
    prices map[string]float64
    mu     sync.RWMutex
}

func NewPriceOracle() *PriceOracle {
    oracle := &PriceOracle{
        prices: make(map[string]float64),
    }
    
    go oracle.updatePrices()
    return oracle
}

// GetPrice è·å–ä»·æ ¼
func (o *PriceOracle) GetPrice(symbol string) (float64, error) {
    o.mu.RLock()
    defer o.mu.RUnlock()
    
    price, exists := o.prices[symbol]
    if !exists {
        return 0, errors.New("price not found")
    }
    
    return price, nil
}

func (o *PriceOracle) updatePrices() {
    ticker := time.NewTicker(1 * time.Minute)
    defer ticker.Stop()
    
    for range ticker.C {
        o.fetchPrices()
    }
}

func (o *PriceOracle) fetchPrices() {
    // ä»APIè·å–ä»·æ ¼
    resp, err := http.Get("https://api.coingecko.com/api/v3/simple/price?ids=ethereum,bitcoin&vs_currencies=usd")
    if err != nil {
        log.Printf("Failed to fetch prices: %v", err)
        return
    }
    defer resp.Body.Close()
    
    var data map[string]map[string]float64
    if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
        log.Printf("Failed to decode prices: %v", err)
        return
    }
    
    o.mu.Lock()
    defer o.mu.Unlock()
    
    if eth, ok := data["ethereum"]; ok {
        o.prices["ETH"] = eth["usd"]
    }
    
    if btc, ok := data["bitcoin"]; ok {
        o.prices["BTC"] = btc["usd"]
    }
    
    log.Printf("Prices updated: ETH=$%.2f, BTC=$%.2f", o.prices["ETH"], o.prices["BTC"])
}
```

### æµåŠ¨æ€§æ± ç›‘æ§

```go
// LiquidityPoolMonitor æµåŠ¨æ€§æ± ç›‘æ§
type LiquidityPoolMonitor struct {
    client         *ContractClient
    poolAddress    string
    updateInterval time.Duration
}

func NewLiquidityPoolMonitor(nodeURL, poolAddress, abi string, updateInterval time.Duration) (*LiquidityPoolMonitor, error) {
    client, err := NewContractClient(nodeURL, poolAddress, abi)
    if err != nil {
        return nil, err
    }
    
    return &LiquidityPoolMonitor{
        client:         client,
        poolAddress:    poolAddress,
        updateInterval: updateInterval,
    }, nil
}

// Start å¯åŠ¨ç›‘æ§
func (m *LiquidityPoolMonitor) Start(ctx context.Context) {
    ticker := time.NewTicker(m.updateInterval)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            m.update(ctx)
        }
    }
}

func (m *LiquidityPoolMonitor) update(ctx context.Context) {
    // è·å–æ± å­å‚¨å¤‡
    var reserves struct {
        Reserve0 *big.Int
        Reserve1 *big.Int
    }
    
    if err := m.client.Call(ctx, &reserves, "getReserves"); err != nil {
        log.Printf("Failed to get reserves: %v", err)
        return
    }
    
    log.Printf("Pool %s - Reserve0: %s, Reserve1: %s", 
        m.poolAddress, reserves.Reserve0.String(), reserves.Reserve1.String())
    
    // è®¡ç®—ä»·æ ¼
    price := new(big.Float).Quo(
        new(big.Float).SetInt(reserves.Reserve1),
        new(big.Float).SetInt(reserves.Reserve0),
    )
    
    priceFloat, _ := price.Float64()
    log.Printf("Current price: %.6f", priceFloat)
}
```

---

## 10. NFTå¼€å‘

### NFTåˆçº¦äº¤äº’

```go
package nft

import (
    "context"
    "math/big"
)

// NFTClient NFTå®¢æˆ·ç«¯
type NFTClient struct {
    contract *ContractClient
}

func NewNFTClient(nodeURL, contractAddress, abi string) (*NFTClient, error) {
    contract, err := NewContractClient(nodeURL, contractAddress, abi)
    if err != nil {
        return nil, err
    }
    
    return &NFTClient{contract: contract}, nil
}

// Mint é“¸é€ NFT
func (c *NFTClient) Mint(ctx context.Context, key *ecdsa.PrivateKey, to string, tokenURI string) (*types.Transaction, error) {
    return c.contract.Transact(ctx, key, "mint", common.HexToAddress(to), tokenURI)
}

// OwnerOf è·å–NFTæ‰€æœ‰è€…
func (c *NFTClient) OwnerOf(ctx context.Context, tokenID *big.Int) (string, error) {
    var owner common.Address
    if err := c.contract.Call(ctx, &owner, "ownerOf", tokenID); err != nil {
        return "", err
    }
    
    return owner.Hex(), nil
}

// TokenURI è·å–NFTå…ƒæ•°æ®URI
func (c *NFTClient) TokenURI(ctx context.Context, tokenID *big.Int) (string, error) {
    var uri string
    if err := c.contract.Call(ctx, &uri, "tokenURI", tokenID); err != nil {
        return "", err
    }
    
    return uri, nil
}

// Transfer è½¬ç§»NFT
func (c *NFTClient) Transfer(ctx context.Context, key *ecdsa.PrivateKey, from, to string, tokenID *big.Int) (*types.Transaction, error) {
    return c.contract.Transact(ctx, key, "transferFrom", 
        common.HexToAddress(from),
        common.HexToAddress(to),
        tokenID,
    )
}

// Approve æˆæƒNFT
func (c *NFTClient) Approve(ctx context.Context, key *ecdsa.PrivateKey, to string, tokenID *big.Int) (*types.Transaction, error) {
    return c.contract.Transact(ctx, key, "approve", common.HexToAddress(to), tokenID)
}
```

### NFTå¸‚åœº

```go
// NFTMarketplace NFTå¸‚åœº
type NFTMarketplace struct {
    nftClient      *NFTClient
    listings       map[string]*Listing
    mu             sync.RWMutex
}

type Listing struct {
    TokenID   *big.Int
    Seller    string
    Price     *big.Int
    Timestamp time.Time
}

func NewNFTMarketplace(nftClient *NFTClient) *NFTMarketplace {
    return &NFTMarketplace{
        nftClient: nftClient,
        listings:  make(map[string]*Listing),
    }
}

// List æŒ‚å•
func (m *NFTMarketplace) List(tokenID *big.Int, seller string, price *big.Int) error {
    m.mu.Lock()
    defer m.mu.Unlock()
    
    key := tokenID.String()
    m.listings[key] = &Listing{
        TokenID:   tokenID,
        Seller:    seller,
        Price:     price,
        Timestamp: time.Now(),
    }
    
    return nil
}

// Buy è´­ä¹°
func (m *NFTMarketplace) Buy(ctx context.Context, buyerKey *ecdsa.PrivateKey, tokenID *big.Int) error {
    m.mu.Lock()
    listing, exists := m.listings[tokenID.String()]
    if !exists {
        m.mu.Unlock()
        return errors.New("listing not found")
    }
    
    delete(m.listings, tokenID.String())
    m.mu.Unlock()
    
    // æ‰§è¡ŒNFTè½¬ç§»
    buyer := crypto.PubkeyToAddress(buyerKey.Public().(*ecdsa.PublicKey))
    _, err := m.nftClient.Transfer(ctx, buyerKey, listing.Seller, buyer.Hex(), tokenID)
    
    return err
}

// GetListings è·å–æ‰€æœ‰æŒ‚å•
func (m *NFTMarketplace) GetListings() []*Listing {
    m.mu.RLock()
    defer m.mu.RUnlock()
    
    listings := make([]*Listing, 0, len(m.listings))
    for _, listing := range m.listings {
        listings = append(listings, listing)
    }
    
    return listings
}
```

---

## 11. å®æˆ˜é¡¹ç›®ï¼šå»ä¸­å¿ƒåŒ–äº¤æ˜“æ‰€(DEX)

### ç³»ç»Ÿæ¶æ„

```mermaid
graph TB
    User[ç”¨æˆ·] --> Frontend[å‰ç«¯]
    Frontend --> Backend[åç«¯æœåŠ¡]
    Backend --> SmartContract[æ™ºèƒ½åˆçº¦]
    Backend --> PriceOracle[ä»·æ ¼é¢„è¨€æœº]
    Backend --> Database[(æ•°æ®åº“)]
    
    SmartContract --> Blockchain[åŒºå—é“¾]
    PriceOracle --> ExternalAPI[å¤–éƒ¨API]
    
    style Frontend fill:#e1f5fe
    style Backend fill:#fff3e0
    style SmartContract fill:#f3e5f5
    style Blockchain fill:#e8f5e9
```

### æ ¸å¿ƒå®ç°

```go
// cmd/dex/main.go
package main

import (
    "context"
    "log"
    "net/http"
    
    "dex/internal/api"
    "dex/internal/blockchain"
    "dex/internal/oracle"
    
    "github.com/gorilla/mux"
)

func main() {
    ctx := context.Background()
    
    // åˆå§‹åŒ–åŒºå—é“¾å®¢æˆ·ç«¯
    ethClient, err := blockchain.NewEthereumClient("https://mainnet.infura.io/v3/YOUR-PROJECT-ID")
    if err != nil {
        log.Fatal(err)
    }
    
    // åˆå§‹åŒ–ä»·æ ¼é¢„è¨€æœº
    priceOracle := oracle.NewPriceOracle()
    
    // åˆå§‹åŒ–APIæœåŠ¡
    dexAPI := api.NewDEXAPI(ethClient, priceOracle)
    
    // è®¾ç½®è·¯ç”±
    router := mux.NewRouter()
    dexAPI.SetupRoutes(router)
    
    // å¯åŠ¨æœåŠ¡å™¨
    log.Println("DEX server starting on :8080")
    if err := http.ListenAndServe(":8080", router); err != nil {
        log.Fatal(err)
    }
}
```

---

## 12. å®‰å…¨ä¸æœ€ä½³å®è·µ

1. **ç§é’¥ç®¡ç†**
   - âœ… ä½¿ç”¨ç¡¬ä»¶é’±åŒ…å­˜å‚¨ç§é’¥
   - âœ… ä¸è¦åœ¨ä»£ç ä¸­ç¡¬ç¼–ç ç§é’¥
   - âœ… ä½¿ç”¨ç¯å¢ƒå˜é‡æˆ–å¯†é’¥ç®¡ç†æœåŠ¡

2. **æ™ºèƒ½åˆçº¦å®‰å…¨**
   - âœ… è¿›è¡Œå®‰å…¨å®¡è®¡
   - âœ… ä½¿ç”¨OpenZeppelinç­‰ç»è¿‡å®¡è®¡çš„åº“
   - âœ… å®ç°ç´§æ€¥æš‚åœæœºåˆ¶
   - âœ… é™åˆ¶æƒé™å’Œè®¿é—®æ§åˆ¶

3. **äº¤æ˜“å®‰å…¨**
   - âœ… éªŒè¯äº¤æ˜“å‚æ•°
   - âœ… ä½¿ç”¨nonceé˜²æ­¢é‡æ”¾æ”»å‡»
   - âœ… è®¾ç½®åˆç†çš„gasé™åˆ¶
   - âœ… å®ç°äº¤æ˜“ç¡®è®¤æœºåˆ¶

4. **é”™è¯¯å¤„ç†**
   - âœ… å®Œæ•´çš„é”™è¯¯å¤„ç†
   - âœ… äº¤æ˜“å¤±è´¥é‡è¯•æœºåˆ¶
   - âœ… æ—¥å¿—è®°å½•å’Œç›‘æ§

5. **æ€§èƒ½ä¼˜åŒ–**
   - âœ… æ‰¹é‡å¤„ç†äº¤æ˜“
   - âœ… ä½¿ç”¨WebSocketç›‘å¬äº‹ä»¶
   - âœ… å®ç°ç¼“å­˜æœºåˆ¶
   - âœ… åˆç†è®¾ç½®Gasä»·æ ¼

---

## 13. å¼€æºé¡¹ç›®æ¨è

1. **go-ethereum (Geth)**
   - åœ°å€: <https://github.com/ethereum/go-ethereum>
   - è¯´æ˜: å®˜æ–¹Goå®ç°çš„ä»¥å¤ªåŠå®¢æˆ·ç«¯

2. **cosmos-sdk**
   - åœ°å€: <https://github.com/cosmos/cosmos-sdk>
   - è¯´æ˜: CosmosåŒºå—é“¾æ¡†æ¶

3. **Tendermint**
   - åœ°å€: <https://github.com/tendermint/tendermint>
   - è¯´æ˜: æ‹œå åº­å®¹é”™å…±è¯†å¼•æ“

4. **go-ipfs**
   - åœ°å€: <https://github.com/ipfs/go-ipfs>
   - è¯´æ˜: IPFSçš„Goå®ç°

5. **Prysm**
   - åœ°å€: <https://github.com/prysmaticlabs/prysm>
   - è¯´æ˜: ä»¥å¤ªåŠ2.0å®¢æˆ·ç«¯

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ24æ—¥  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.21+
