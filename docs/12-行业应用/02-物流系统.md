# ç‰©æµç³»ç»Ÿ - Go è¯­è¨€å®æˆ˜

> ä½¿ç”¨ Go è¯­è¨€æ„å»ºé«˜æ•ˆã€æ™ºèƒ½çš„ç°ä»£ç‰©æµç®¡ç†ç³»ç»Ÿ

---

## ğŸ“‹ ç›®å½•

- [ç‰©æµç³»ç»Ÿ - Go è¯­è¨€å®æˆ˜](#ç‰©æµç³»ç»Ÿ---go-è¯­è¨€å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ç³»ç»Ÿæ¦‚è¿°](#ç³»ç»Ÿæ¦‚è¿°)
    - [ä¸šåŠ¡åœºæ™¯](#ä¸šåŠ¡åœºæ™¯)
    - [Go è¯­è¨€ä¼˜åŠ¿](#go-è¯­è¨€ä¼˜åŠ¿)
  - [æ ¸å¿ƒä¸šåŠ¡æ¨¡å—](#æ ¸å¿ƒä¸šåŠ¡æ¨¡å—)
    - [ç³»ç»Ÿæ¶æ„å›¾](#ç³»ç»Ÿæ¶æ„å›¾)
      - [ç‰©æµç³»ç»Ÿæ¶æ„å¯è§†åŒ–](#ç‰©æµç³»ç»Ÿæ¶æ„å¯è§†åŒ–)
      - [è®¢å•å¤„ç†ä¸é…é€æµç¨‹æ—¶åºå›¾](#è®¢å•å¤„ç†ä¸é…é€æµç¨‹æ—¶åºå›¾)
      - [æ™ºèƒ½è°ƒåº¦ç®—æ³•æµç¨‹å›¾](#æ™ºèƒ½è°ƒåº¦ç®—æ³•æµç¨‹å›¾)
  - [è®¢å•ç®¡ç†ç³»ç»Ÿ](#è®¢å•ç®¡ç†ç³»ç»Ÿ)
    - [è®¢å•æ•°æ®æ¨¡å‹](#è®¢å•æ•°æ®æ¨¡å‹)
    - [è®¢å•æœåŠ¡å®ç°](#è®¢å•æœåŠ¡å®ç°)
  - [ä»“å‚¨ç®¡ç†ç³»ç»Ÿ](#ä»“å‚¨ç®¡ç†ç³»ç»Ÿ)
    - [åº“å­˜æ¨¡å‹](#åº“å­˜æ¨¡å‹)
    - [åº“å­˜æœåŠ¡](#åº“å­˜æœåŠ¡)
  - [è¿è¾“ç®¡ç†ç³»ç»Ÿ](#è¿è¾“ç®¡ç†ç³»ç»Ÿ)
    - [å¸æœºå’Œè½¦è¾†æ¨¡å‹](#å¸æœºå’Œè½¦è¾†æ¨¡å‹)
    - [è°ƒåº¦æœåŠ¡](#è°ƒåº¦æœåŠ¡)
  - [è·¯å¾„è§„åˆ’ç³»ç»Ÿ](#è·¯å¾„è§„åˆ’ç³»ç»Ÿ)
    - [å¤šç‚¹è·¯å¾„ä¼˜åŒ–](#å¤šç‚¹è·¯å¾„ä¼˜åŒ–)
  - [å®æ—¶è¿½è¸ªç³»ç»Ÿ](#å®æ—¶è¿½è¸ªç³»ç»Ÿ)
    - [GPSæ•°æ®ä¸ŠæŠ¥](#gpsæ•°æ®ä¸ŠæŠ¥)
  - [æ™ºèƒ½è°ƒåº¦ç³»ç»Ÿ](#æ™ºèƒ½è°ƒåº¦ç³»ç»Ÿ)
    - [è®¢å•æ‰¹é‡è°ƒåº¦](#è®¢å•æ‰¹é‡è°ƒåº¦)
  - [æ•°æ®åˆ†æä¸ä¼˜åŒ–](#æ•°æ®åˆ†æä¸ä¼˜åŒ–)
    - [é…é€æ•ˆç‡åˆ†æ](#é…é€æ•ˆç‡åˆ†æ)
  - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
    - [æ•°æ®åº“ä¼˜åŒ–](#æ•°æ®åº“ä¼˜åŒ–)
    - [Redis ç¼“å­˜ç­–ç•¥](#redis-ç¼“å­˜ç­–ç•¥)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [1. åˆ†å¸ƒå¼é”é˜²æ­¢é‡å¤è°ƒåº¦](#1-åˆ†å¸ƒå¼é”é˜²æ­¢é‡å¤è°ƒåº¦)
    - [2. å¹‚ç­‰æ€§è®¾è®¡](#2-å¹‚ç­‰æ€§è®¾è®¡)
    - [3. é™çº§ç­–ç•¥](#3-é™çº§ç­–ç•¥)
  - [æ€»ç»“](#æ€»ç»“)

---

## ç³»ç»Ÿæ¦‚è¿°

### ä¸šåŠ¡åœºæ™¯

ç°ä»£ç‰©æµç³»ç»Ÿæ¶‰åŠå¤šä¸ªç¯èŠ‚çš„ååŒç®¡ç†ï¼š

- **è®¢å•ç®¡ç†**: è®¢å•æ¥æ”¶ã€å¤„ç†ã€åˆ†é…
- **ä»“å‚¨ç®¡ç†**: å…¥åº“ã€å‡ºåº“ã€åº“å­˜ç®¡ç†ã€ç›˜ç‚¹
- **è¿è¾“ç®¡ç†**: é…é€è®¡åˆ’ã€å¸æœºè°ƒåº¦ã€è½¦è¾†ç®¡ç†
- **è·¯å¾„è§„åˆ’**: æœ€ä¼˜è·¯å¾„è®¡ç®—ã€å¤šç‚¹é…é€ä¼˜åŒ–
- **å®æ—¶è¿½è¸ª**: GPSå®šä½ã€ç”µå­å›´æ ã€å¼‚å¸¸å‘Šè­¦
- **æ•°æ®åˆ†æ**: é…é€æ•ˆç‡ã€æˆæœ¬åˆ†æã€é¢„æµ‹

### Go è¯­è¨€ä¼˜åŠ¿

```text
âœ… é«˜å¹¶å‘å¤„ç†èƒ½åŠ› (å¤„ç†æµ·é‡è®¢å•)
âœ… ä¼˜ç§€çš„ç½‘ç»œç¼–ç¨‹èƒ½åŠ› (GPSæ•°æ®ä¸ŠæŠ¥)
âœ… é«˜æ•ˆçš„å†…å­˜ç®¡ç† (å®æ—¶æ•°æ®å¤„ç†)
âœ… è·¨å¹³å°æ”¯æŒ (æœåŠ¡å™¨ã€è¾¹ç¼˜è®¾å¤‡)
âœ… ä¸°å¯Œçš„ç¬¬ä¸‰æ–¹åº“ (GISã€ç®—æ³•ç­‰)
```

---

## æ ¸å¿ƒä¸šåŠ¡æ¨¡å—

### ç³»ç»Ÿæ¶æ„å›¾

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Web/Mobile Client (å®¢æˆ·ç«¯)               â”‚
â”‚            ä¸‹å• | æŸ¥è¯¢ | è¿½è¸ª | è¯„ä»·                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    API Gateway (ç½‘å…³å±‚)                  â”‚
â”‚         è´Ÿè½½å‡è¡¡ | è®¤è¯é‰´æƒ | é™æµ | æ—¥å¿—                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â†“                 â†“                 â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   è®¢å•æœåŠ¡        â”‚ â”‚  ä»“å‚¨æœåŠ¡     â”‚ â”‚  è¿è¾“æœåŠ¡     â”‚
â”‚  - è®¢å•åˆ›å»º      â”‚ â”‚  - åº“å­˜ç®¡ç†   â”‚ â”‚  - è°ƒåº¦å¸æœº   â”‚
â”‚  - è®¢å•æ‹†åˆ†      â”‚ â”‚  - å‡ºå…¥åº“     â”‚ â”‚  - è·¯å¾„è§„åˆ’   â”‚
â”‚  - çŠ¶æ€æµè½¬      â”‚ â”‚  - ç›˜ç‚¹       â”‚ â”‚  - å®æ—¶è¿½è¸ª   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                 â”‚                 â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚  æ™ºèƒ½è°ƒåº¦å¼•æ“    â”‚
                   â”‚  - è®¢å•åˆ†é…     â”‚
                   â”‚  - è·¯å¾„ä¼˜åŒ–     â”‚
                   â”‚  - è´Ÿè½½å‡è¡¡     â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â†“                 â†“                 â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   PostgreSQL     â”‚ â”‚  Redis é›†ç¾¤   â”‚ â”‚  Kafka é›†ç¾¤   â”‚
â”‚  - è®¢å•æ•°æ®      â”‚ â”‚  - ç¼“å­˜       â”‚ â”‚  - æ¶ˆæ¯é˜Ÿåˆ—   â”‚
â”‚  - åº“å­˜æ•°æ®      â”‚ â”‚  - ä½ç½®æ•°æ®   â”‚ â”‚  - GPSä¸ŠæŠ¥    â”‚
â”‚  - PostGIS æ‰©å±•  â”‚ â”‚  - åˆ†å¸ƒå¼é”   â”‚ â”‚  - äº‹ä»¶æµ     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ç‰©æµç³»ç»Ÿæ¶æ„å¯è§†åŒ–

```mermaid
graph TB
    subgraph "ç”¨æˆ·å±‚"
        WebClient[ğŸ’» Webç«¯]
        MobileClient[ğŸ“± ç§»åŠ¨ç«¯]
        DriverApp[ğŸšš å¸æœºç«¯App]
    end
    
    subgraph "ç½‘å…³å±‚"
        Gateway[ğŸŒ API Gateway<br/>è´Ÿè½½å‡è¡¡ + è®¤è¯é‰´æƒ + é™æµ]
    end
    
    subgraph "ä¸šåŠ¡æœåŠ¡å±‚"
        OrderSvc[ğŸ“¦ è®¢å•æœåŠ¡<br/>åˆ›å»º/æ‹†åˆ†/çŠ¶æ€æµè½¬]
        WarehouseSvc[ğŸ­ ä»“å‚¨æœåŠ¡<br/>åº“å­˜ç®¡ç†/å‡ºå…¥åº“/ç›˜ç‚¹]
        TransportSvc[ğŸš› è¿è¾“æœåŠ¡<br/>è°ƒåº¦/è·¯å¾„è§„åˆ’/è¿½è¸ª]
    end
    
    subgraph "æ™ºèƒ½è°ƒåº¦å±‚"
        Scheduler[ğŸ¤– æ™ºèƒ½è°ƒåº¦å¼•æ“<br/>è®¢å•åˆ†é…/è·¯å¾„ä¼˜åŒ–/è´Ÿè½½å‡è¡¡]
    end
    
    subgraph "æ•°æ®å­˜å‚¨å±‚"
        PG[(ğŸ—„ï¸ PostgreSQL + PostGIS<br/>è®¢å•/åº“å­˜/åœ°ç†æ•°æ®)]
        Redis[(âš¡ Redisé›†ç¾¤<br/>ç¼“å­˜/ä½ç½®/åˆ†å¸ƒå¼é”)]
        Kafka[(ğŸ“Š Kafkaé›†ç¾¤<br/>æ¶ˆæ¯é˜Ÿåˆ—/GPSä¸ŠæŠ¥/äº‹ä»¶æµ)]
    end
    
    subgraph "ç›‘æ§ & åˆ†æ"
        Monitor[ğŸ“ˆ ç›‘æ§ç³»ç»Ÿ<br/>Prometheus + Grafana]
        Analytics[ğŸ“Š æ•°æ®åˆ†æ<br/>æ•ˆç‡åˆ†æ/æˆæœ¬ä¼˜åŒ–]
    end
    
    WebClient --> Gateway
    MobileClient --> Gateway
    DriverApp --> Gateway
    
    Gateway --> OrderSvc
    Gateway --> WarehouseSvc
    Gateway --> TransportSvc
    
    OrderSvc --> Scheduler
    WarehouseSvc --> Scheduler
    TransportSvc --> Scheduler
    
    OrderSvc --> PG
    WarehouseSvc --> PG
    TransportSvc --> PG
    
    OrderSvc --> Redis
    WarehouseSvc --> Redis
    TransportSvc --> Redis
    
    TransportSvc --> Kafka
    DriverApp -.GPSä¸ŠæŠ¥.-> Kafka
    
    Scheduler --> Analytics
    
    OrderSvc -.æŒ‡æ ‡.-> Monitor
    WarehouseSvc -.æŒ‡æ ‡.-> Monitor
    TransportSvc -.æŒ‡æ ‡.-> Monitor
    Scheduler -.æŒ‡æ ‡.-> Monitor
    
    style Gateway fill:#ffe1e1
    style OrderSvc fill:#e1ffe1
    style WarehouseSvc fill:#e1ffe1
    style TransportSvc fill:#e1ffe1
    style Scheduler fill:#fff4e1
    style PG fill:#e1f5ff
    style Redis fill:#e1f5ff
    style Kafka fill:#e1f5ff
    style Monitor fill:#f5e1ff
    style Analytics fill:#f5e1ff
```

#### è®¢å•å¤„ç†ä¸é…é€æµç¨‹æ—¶åºå›¾

```mermaid
sequenceDiagram
    participant Customer as ğŸ‘¤ å®¢æˆ·
    participant GW as ğŸŒ API Gateway
    participant Order as ğŸ“¦ è®¢å•æœåŠ¡
    participant Warehouse as ğŸ­ ä»“å‚¨æœåŠ¡
    participant Scheduler as ğŸ¤– æ™ºèƒ½è°ƒåº¦
    participant Transport as ğŸš› è¿è¾“æœåŠ¡
    participant Driver as ğŸšš å¸æœº
    participant DB as ğŸ—„ï¸ PostgreSQL
    participant Cache as âš¡ Redis
    participant MQ as ğŸ“Š Kafka
    
    Note over Customer,MQ: è®¢å•åˆ›å»ºåˆ°é…é€å®Œæˆå…¨æµç¨‹
    
    Customer->>GW: æäº¤è®¢å•<br/>(æ”¶è´§åœ°å€/å•†å“)
    GW->>Order: åˆ›å»ºè®¢å•
    
    Order->>DB: ä¿å­˜è®¢å•è®°å½•
    Order->>Cache: ç¼“å­˜è®¢å•ä¿¡æ¯
    
    rect rgb(250, 230, 220)
        Note over Order,Warehouse: åº“å­˜æ£€æŸ¥ä¸é”å®š
        Order->>Warehouse: æ£€æŸ¥åº“å­˜
        Warehouse->>DB: æŸ¥è¯¢åº“å­˜
        Warehouse-->>Order: åº“å­˜å……è¶³
        Order->>Warehouse: é”å®šåº“å­˜
        Warehouse->>DB: æ›´æ–°åº“å­˜çŠ¶æ€
    end
    
    Order->>MQ: å‘å¸ƒè®¢å•åˆ›å»ºäº‹ä»¶
    Order-->>GW: è¿”å›è®¢å•ID
    GW-->>Customer: è®¢å•åˆ›å»ºæˆåŠŸ
    
    rect rgb(220, 230, 250)
        Note over Scheduler,Transport: æ™ºèƒ½è°ƒåº¦
        MQ->>Scheduler: è®¢å•äº‹ä»¶
        Scheduler->>Scheduler: â‘  è®¢å•èšåˆ<br/>â‘¡ è·¯å¾„ä¼˜åŒ–<br/>â‘¢ å¸æœºåŒ¹é…
        Scheduler->>Transport: åˆ†é…è®¢å•
        Transport->>DB: ä¿å­˜è°ƒåº¦è®°å½•
        Transport->>Cache: æ›´æ–°å¸æœºçŠ¶æ€
    end
    
    Transport->>Driver: æ¨é€é…é€ä»»åŠ¡
    Driver->>Transport: ç¡®è®¤æ¥å•
    
    loop GPSå®æ—¶ä¸ŠæŠ¥
        Driver->>MQ: ä¸ŠæŠ¥GPSä½ç½®
        MQ->>Transport: æ›´æ–°ä½ç½®
        Transport->>Cache: æ›´æ–°å®æ—¶ä½ç½®
        Transport-->>Customer: æ¨é€ç‰©æµçŠ¶æ€
    end
    
    Driver->>Transport: åˆ°è¾¾ç›®çš„åœ°
    Driver->>Transport: ç¡®è®¤ç­¾æ”¶
    Transport->>Order: æ›´æ–°è®¢å•çŠ¶æ€
    Order->>DB: è®¢å•å®Œæˆ
    Order->>MQ: å‘å¸ƒå®Œæˆäº‹ä»¶
    
    Note over MQ: å¼‚æ­¥å¤„ç†:<br/>æ•°æ®åˆ†æ/ç»“ç®—/è¯„ä»·
```

#### æ™ºèƒ½è°ƒåº¦ç®—æ³•æµç¨‹å›¾

```mermaid
flowchart TD
    Start([å¼€å§‹è°ƒåº¦]) --> CheckOrders{æ˜¯å¦æœ‰<br/>å¾…è°ƒåº¦è®¢å•?}
    
    CheckOrders -->|å¦| Sleep[ç­‰å¾…æ–°è®¢å•]
    Sleep --> CheckOrders
    
    CheckOrders -->|æ˜¯| Aggregate[è®¢å•èšåˆ<br/>æŒ‰åŒºåŸŸ/æ—¶é—´çª—å£]
    
    Aggregate --> Cluster[K-Meansèšç±»<br/>è®¢å•åˆ†ç»„]
    
    Cluster --> OptimizePath[è·¯å¾„ä¼˜åŒ–<br/>é—ä¼ ç®—æ³•]
    
    OptimizePath --> MatchDriver{åŒ¹é…å¸æœº}
    
    MatchDriver -->|æŸ¥è¯¢å¯ç”¨å¸æœº| CheckAvailable[æ£€æŸ¥å¸æœºçŠ¶æ€]
    CheckAvailable -->|å¯ç”¨| CalculateScore[è®¡ç®—åŒ¹é…åº¦å¾—åˆ†<br/>è·ç¦»+è½½é‡+ä¼˜å…ˆçº§]
    
    CalculateScore --> SelectBest[é€‰æ‹©æœ€ä¼˜å¸æœº]
    
    SelectBest --> Lock{è·å–åˆ†å¸ƒå¼é”}
    Lock -->|å¤±è´¥| Retry[é‡è¯•/é€‰æ‹©å…¶ä»–å¸æœº]
    Lock -->|æˆåŠŸ| AssignOrder[åˆ†é…è®¢å•]
    
    Retry --> MatchDriver
    
    AssignOrder --> UpdateStatus[æ›´æ–°è®¢å•çŠ¶æ€<br/>æ›´æ–°å¸æœºçŠ¶æ€]
    
    UpdateStatus --> NotifyDriver[é€šçŸ¥å¸æœº]
    
    NotifyDriver --> CheckMore{è¿˜æœ‰è®¢å•?}
    
    CheckMore -->|æ˜¯| Aggregate
    CheckMore -->|å¦| End([è°ƒåº¦å®Œæˆ])
    
    MatchDriver -->|æ— å¯ç”¨å¸æœº| WaitDriver[ç­‰å¾…å¸æœºé‡Šæ”¾]
    WaitDriver --> MatchDriver
    
    style Start fill:#e1f5ff
    style Aggregate fill:#fff4e1
    style Cluster fill:#ffe1e1
    style OptimizePath fill:#ffe1e1
    style AssignOrder fill:#e1ffe1
    style End fill:#e1f5ff
```

---

## è®¢å•ç®¡ç†ç³»ç»Ÿ

### è®¢å•æ•°æ®æ¨¡å‹

```go
package order

import (
    "time"
)

// Order è®¢å•å®ä½“
type Order struct {
    ID            int64       `json:"id" db:"id"`
    OrderNo       string      `json:"order_no" db:"order_no"`
    CustomerID    int64       `json:"customer_id" db:"customer_id"`
    PickupAddr    *Address    `json:"pickup_addr"`     // å–ä»¶åœ°å€
    DeliveryAddr  *Address    `json:"delivery_addr"`   // é…é€åœ°å€
    GoodsType     GoodsType   `json:"goods_type" db:"goods_type"`
    Weight        float64     `json:"weight" db:"weight"`      // é‡é‡(kg)
    Volume        float64     `json:"volume" db:"volume"`      // ä½“ç§¯(mÂ³)
    DeclaredValue float64     `json:"declared_value" db:"declared_value"` // å£°æ˜ä»·å€¼
    ServiceType   ServiceType `json:"service_type" db:"service_type"`
    Status        OrderStatus `json:"status" db:"status"`
    WarehouseID   *int64      `json:"warehouse_id" db:"warehouse_id"`   // åˆ†é…ä»“åº“
    DriverID      *int64      `json:"driver_id" db:"driver_id"`         // åˆ†é…å¸æœº
    ExpectedTime  time.Time   `json:"expected_time" db:"expected_time"` // é¢„è®¡é€è¾¾
    ActualTime    *time.Time  `json:"actual_time" db:"actual_time"`     // å®é™…é€è¾¾
    CreatedAt     time.Time   `json:"created_at" db:"created_at"`
    UpdatedAt     time.Time   `json:"updated_at" db:"updated_at"`
}

// Address åœ°å€
type Address struct {
    Province   string  `json:"province"`
    City       string  `json:"city"`
    District   string  `json:"district"`
    Street     string  `json:"street"`
    Detail     string  `json:"detail"`
    Contact    string  `json:"contact"`      // è”ç³»äºº
    Phone      string  `json:"phone"`        // ç”µè¯
    Longitude  float64 `json:"longitude"`    // ç»åº¦
    Latitude   float64 `json:"latitude"`     // çº¬åº¦
}

// GoodsType è´§ç‰©ç±»å‹
type GoodsType int

const (
    GoodsTypeDocument  GoodsType = 1 // æ–‡ä»¶
    GoodsTypePackage   GoodsType = 2 // åŒ…è£¹
    GoodsTypeBulky     GoodsType = 3 // å¤§ä»¶
    GoodsTypePerishable GoodsType = 4 // ç”Ÿé²œ
    GoodsTypeFragile   GoodsType = 5 // æ˜“ç¢å“
)

// ServiceType æœåŠ¡ç±»å‹
type ServiceType int

const (
    ServiceTypeStandard ServiceType = 1 // æ ‡å‡†å¿«é€’
    ServiceTypeExpress  ServiceType = 2 // ç‰¹å¿«ä¸“é€’
    ServiceTypeSameDay  ServiceType = 3 // å½“æ—¥è¾¾
    ServiceTypeNextDay  ServiceType = 4 // æ¬¡æ—¥è¾¾
)

// OrderStatus è®¢å•çŠ¶æ€
type OrderStatus int

const (
    OrderStatusPending    OrderStatus = 1  // å¾…æ¥å•
    OrderStatusAccepted   OrderStatus = 2  // å·²æ¥å•
    OrderStatusPicked     OrderStatus = 3  // å·²æ½ä»¶
    OrderStatusInWarehouse OrderStatus = 4 // åœ¨åº“
    OrderStatusOutWarehouse OrderStatus = 5 // å·²å‡ºåº“
    OrderStatusInTransit  OrderStatus = 6  // è¿è¾“ä¸­
    OrderStatusDelivering OrderStatus = 7  // é…é€ä¸­
    OrderStatusDelivered  OrderStatus = 8  // å·²é€è¾¾
    OrderStatusCancelled  OrderStatus = 9  // å·²å–æ¶ˆ
)

// StatusHistory çŠ¶æ€å†å²
type StatusHistory struct {
    ID        int64       `json:"id" db:"id"`
    OrderID   int64       `json:"order_id" db:"order_id"`
    Status    OrderStatus `json:"status" db:"status"`
    Location  string      `json:"location" db:"location"`
    Remark    string      `json:"remark" db:"remark"`
    CreatedAt time.Time   `json:"created_at" db:"created_at"`
}
```

### è®¢å•æœåŠ¡å®ç°

```go
package order

import (
    "context"
    "database/sql"
    "errors"
    "fmt"
    "time"
)

var (
    ErrOrderNotFound = errors.New("è®¢å•ä¸å­˜åœ¨")
    ErrInvalidStatus = errors.New("è®¢å•çŠ¶æ€ä¸æ­£ç¡®")
)

// Service è®¢å•æœåŠ¡
type Service struct {
    db *sql.DB
}

// NewService åˆ›å»ºè®¢å•æœåŠ¡
func NewService(db *sql.DB) *Service {
    return &Service{db: db}
}

// CreateOrder åˆ›å»ºè®¢å•
func (s *Service) CreateOrder(ctx context.Context, req *CreateOrderRequest) (*Order, error) {
    order := &Order{
        OrderNo:       generateOrderNo(),
        CustomerID:    req.CustomerID,
        PickupAddr:    req.PickupAddr,
        DeliveryAddr:  req.DeliveryAddr,
        GoodsType:     req.GoodsType,
        Weight:        req.Weight,
        Volume:        req.Volume,
        DeclaredValue: req.DeclaredValue,
        ServiceType:   req.ServiceType,
        Status:        OrderStatusPending,
        ExpectedTime:  calculateExpectedTime(req.ServiceType),
    }
    
    // å¼€å¯äº‹åŠ¡
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return nil, err
    }
    defer tx.Rollback()
    
    // æ’å…¥è®¢å•
    query := `
        INSERT INTO orders (order_no, customer_id, pickup_addr, delivery_addr, goods_type, weight, volume, declared_value, service_type, status, expected_time, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
    `
    
    pickupAddrJSON, _ := json.Marshal(order.PickupAddr)
    deliveryAddrJSON, _ := json.Marshal(order.DeliveryAddr)
    
    result, err := tx.ExecContext(ctx, query,
        order.OrderNo, order.CustomerID, pickupAddrJSON, deliveryAddrJSON,
        order.GoodsType, order.Weight, order.Volume, order.DeclaredValue,
        order.ServiceType, order.Status, order.ExpectedTime,
    )
    if err != nil {
        return nil, err
    }
    
    id, _ := result.LastInsertId()
    order.ID = id
    
    // è®°å½•çŠ¶æ€å†å²
    err = s.addStatusHistory(ctx, tx, order.ID, OrderStatusPending, "è®¢å•åˆ›å»º", "")
    if err != nil {
        return nil, err
    }
    
    // è§¦å‘è®¢å•åˆ†é…
    go s.dispatchOrder(order.ID)
    
    if err := tx.Commit(); err != nil {
        return nil, err
    }
    
    return order, nil
}

// UpdateOrderStatus æ›´æ–°è®¢å•çŠ¶æ€
func (s *Service) UpdateOrderStatus(ctx context.Context, orderID int64, newStatus OrderStatus, location, remark string) error {
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    // é”å®šè®¢å•
    var currentStatus OrderStatus
    query := `SELECT status FROM orders WHERE id = ? FOR UPDATE`
    err = tx.QueryRowContext(ctx, query, orderID).Scan(&currentStatus)
    if err == sql.ErrNoRows {
        return ErrOrderNotFound
    }
    if err != nil {
        return err
    }
    
    // éªŒè¯çŠ¶æ€æµè½¬åˆæ³•æ€§
    if !isValidStatusTransition(currentStatus, newStatus) {
        return ErrInvalidStatus
    }
    
    // æ›´æ–°è®¢å•çŠ¶æ€
    updateQuery := `UPDATE orders SET status = ?, updated_at = NOW() WHERE id = ?`
    _, err = tx.ExecContext(ctx, updateQuery, newStatus, orderID)
    if err != nil {
        return err
    }
    
    // è®°å½•çŠ¶æ€å†å²
    err = s.addStatusHistory(ctx, tx, orderID, newStatus, location, remark)
    if err != nil {
        return err
    }
    
    // å¦‚æœæ˜¯å·²é€è¾¾çŠ¶æ€ï¼Œè®°å½•å®é™…é€è¾¾æ—¶é—´
    if newStatus == OrderStatusDelivered {
        now := time.Now()
        _, err = tx.ExecContext(ctx, `UPDATE orders SET actual_time = ? WHERE id = ?`, now, orderID)
        if err != nil {
            return err
        }
    }
    
    return tx.Commit()
}

// GetOrderTrace è·å–è®¢å•è½¨è¿¹
func (s *Service) GetOrderTrace(ctx context.Context, orderNo string) ([]StatusHistory, error) {
    query := `
        SELECT h.id, h.order_id, h.status, h.location, h.remark, h.created_at
        FROM status_history h
        INNER JOIN orders o ON h.order_id = o.id
        WHERE o.order_no = ?
        ORDER BY h.created_at ASC
    `
    
    rows, err := s.db.QueryContext(ctx, query, orderNo)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var history []StatusHistory
    for rows.Next() {
        var h StatusHistory
        err := rows.Scan(&h.ID, &h.OrderID, &h.Status, &h.Location, &h.Remark, &h.CreatedAt)
        if err != nil {
            return nil, err
        }
        history = append(history, h)
    }
    
    return history, nil
}

// addStatusHistory æ·»åŠ çŠ¶æ€å†å²è®°å½•
func (s *Service) addStatusHistory(ctx context.Context, tx *sql.Tx, orderID int64, status OrderStatus, location, remark string) error {
    query := `
        INSERT INTO status_history (order_id, status, location, remark, created_at)
        VALUES (?, ?, ?, ?, NOW())
    `
    _, err := tx.ExecContext(ctx, query, orderID, status, location, remark)
    return err
}

// isValidStatusTransition éªŒè¯çŠ¶æ€æµè½¬æ˜¯å¦åˆæ³•
func isValidStatusTransition(from, to OrderStatus) bool {
    validTransitions := map[OrderStatus][]OrderStatus{
        OrderStatusPending:      {OrderStatusAccepted, OrderStatusCancelled},
        OrderStatusAccepted:     {OrderStatusPicked, OrderStatusCancelled},
        OrderStatusPicked:       {OrderStatusInWarehouse},
        OrderStatusInWarehouse:  {OrderStatusOutWarehouse},
        OrderStatusOutWarehouse: {OrderStatusInTransit},
        OrderStatusInTransit:    {OrderStatusDelivering, OrderStatusInWarehouse},
        OrderStatusDelivering:   {OrderStatusDelivered},
    }
    
    allowed, exists := validTransitions[from]
    if !exists {
        return false
    }
    
    for _, status := range allowed {
        if status == to {
            return true
        }
    }
    return false
}

// calculateExpectedTime è®¡ç®—é¢„è®¡é€è¾¾æ—¶é—´
func calculateExpectedTime(serviceType ServiceType) time.Time {
    now := time.Now()
    switch serviceType {
    case ServiceTypeSameDay:
        return now.Add(8 * time.Hour)
    case ServiceTypeNextDay:
        return now.Add(24 * time.Hour)
    case ServiceTypeExpress:
        return now.Add(48 * time.Hour)
    default:
        return now.Add(72 * time.Hour)
    }
}

// generateOrderNo ç”Ÿæˆè®¢å•å·
func generateOrderNo() string {
    // æ ¼å¼: LO + æ—¥æœŸ(8ä½) + æ—¶é—´æˆ³å6ä½ + éšæœºæ•°(4ä½)
    return fmt.Sprintf("LO%s%06d%04d",
        time.Now().Format("20060102"),
        time.Now().Unix()%1000000,
        rand.Intn(10000),
    )
}

// dispatchOrder è®¢å•åˆ†é…ï¼ˆå¼‚æ­¥ï¼‰
func (s *Service) dispatchOrder(orderID int64) {
    // è°ƒç”¨æ™ºèƒ½è°ƒåº¦æœåŠ¡åˆ†é…ä»“åº“å’Œå¸æœº
    // å®ç°ç•¥
}

// CreateOrderRequest åˆ›å»ºè®¢å•è¯·æ±‚
type CreateOrderRequest struct {
    CustomerID    int64
    PickupAddr    *Address
    DeliveryAddr  *Address
    GoodsType     GoodsType
    Weight        float64
    Volume        float64
    DeclaredValue float64
    ServiceType   ServiceType
}
```

---

## ä»“å‚¨ç®¡ç†ç³»ç»Ÿ

### åº“å­˜æ¨¡å‹

```go
package warehouse

import (
    "time"
)

// Warehouse ä»“åº“
type Warehouse struct {
    ID        int64     `json:"id" db:"id"`
    Name      string    `json:"name" db:"name"`
    Code      string    `json:"code" db:"code"`
    Address   string    `json:"address" db:"address"`
    Longitude float64   `json:"longitude" db:"longitude"`
    Latitude  float64   `json:"latitude" db:"latitude"`
    Capacity  int       `json:"capacity" db:"capacity"`    // å®¹é‡
    Current   int       `json:"current" db:"current"`      // å½“å‰å­˜é‡
    Status    WHStatus  `json:"status" db:"status"`
    CreatedAt time.Time `json:"created_at" db:"created_at"`
}

// WHStatus ä»“åº“çŠ¶æ€
type WHStatus int

const (
    WHStatusActive   WHStatus = 1 // æ­£å¸¸
    WHStatusFull     WHStatus = 2 // å·²æ»¡
    WHStatusMaintain WHStatus = 3 // ç»´æŠ¤ä¸­
)

// Inventory åº“å­˜è®°å½•
type Inventory struct {
    ID          int64          `json:"id" db:"id"`
    WarehouseID int64          `json:"warehouse_id" db:"warehouse_id"`
    OrderID     int64          `json:"order_id" db:"order_id"`
    Location    string         `json:"location" db:"location"` // åº“ä½
    Operation   OperationType  `json:"operation" db:"operation"`
    Quantity    int            `json:"quantity" db:"quantity"`
    OperatorID  int64          `json:"operator_id" db:"operator_id"`
    Remark      string         `json:"remark" db:"remark"`
    CreatedAt   time.Time      `json:"created_at" db:"created_at"`
}

// OperationType æ“ä½œç±»å‹
type OperationType int

const (
    OperationTypeInbound  OperationType = 1 // å…¥åº“
    OperationTypeOutbound OperationType = 2 // å‡ºåº“
    OperationTypeAdjust   OperationType = 3 // è°ƒæ•´
)
```

### åº“å­˜æœåŠ¡

```go
package warehouse

import (
    "context"
    "database/sql"
    "errors"
)

var (
    ErrWarehouseFull    = errors.New("ä»“åº“å·²æ»¡")
    ErrInsufficientStock = errors.New("åº“å­˜ä¸è¶³")
)

// Service ä»“å‚¨æœåŠ¡
type Service struct {
    db *sql.DB
}

// Inbound å…¥åº“
func (s *Service) Inbound(ctx context.Context, warehouseID, orderID int64, location string, operatorID int64) error {
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    // é”å®šä»“åº“
    var warehouse Warehouse
    query := `SELECT id, capacity, current, status FROM warehouses WHERE id = ? FOR UPDATE`
    err = tx.QueryRowContext(ctx, query, warehouseID).Scan(&warehouse.ID, &warehouse.Capacity, &warehouse.Current, &warehouse.Status)
    if err != nil {
        return err
    }
    
    // æ£€æŸ¥ä»“åº“çŠ¶æ€
    if warehouse.Status != WHStatusActive {
        return errors.New("ä»“åº“ä¸å¯ç”¨")
    }
    
    // æ£€æŸ¥å®¹é‡
    if warehouse.Current >= warehouse.Capacity {
        return ErrWarehouseFull
    }
    
    // æ›´æ–°ä»“åº“å­˜é‡
    _, err = tx.ExecContext(ctx, `UPDATE warehouses SET current = current + 1, updated_at = NOW() WHERE id = ?`, warehouseID)
    if err != nil {
        return err
    }
    
    // è®°å½•åº“å­˜æ“ä½œ
    invQuery := `
        INSERT INTO inventory (warehouse_id, order_id, location, operation, quantity, operator_id, created_at)
        VALUES (?, ?, ?, ?, ?, ?, NOW())
    `
    _, err = tx.ExecContext(ctx, invQuery, warehouseID, orderID, location, OperationTypeInbound, 1, operatorID)
    if err != nil {
        return err
    }
    
    // æ›´æ–°è®¢å•çŠ¶æ€
    _, err = tx.ExecContext(ctx, `UPDATE orders SET warehouse_id = ?, status = ?, updated_at = NOW() WHERE id = ?`,
        warehouseID, order.OrderStatusInWarehouse, orderID)
    if err != nil {
        return err
    }
    
    return tx.Commit()
}

// Outbound å‡ºåº“
func (s *Service) Outbound(ctx context.Context, orderID int64, operatorID int64) error {
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    // æŸ¥è¯¢è®¢å•æ‰€åœ¨ä»“åº“
    var warehouseID int64
    var status order.OrderStatus
    query := `SELECT warehouse_id, status FROM orders WHERE id = ?`
    err = tx.QueryRowContext(ctx, query, orderID).Scan(&warehouseID, &status)
    if err != nil {
        return err
    }
    
    if status != order.OrderStatusInWarehouse {
        return errors.New("è®¢å•çŠ¶æ€ä¸æ­£ç¡®")
    }
    
    // é”å®šä»“åº“å¹¶å‡å°‘å­˜é‡
    _, err = tx.ExecContext(ctx, `UPDATE warehouses SET current = current - 1, updated_at = NOW() WHERE id = ? AND current > 0`, warehouseID)
    if err != nil {
        return err
    }
    
    // è®°å½•åº“å­˜æ“ä½œ
    invQuery := `
        INSERT INTO inventory (warehouse_id, order_id, operation, quantity, operator_id, created_at)
        VALUES (?, ?, ?, ?, ?, NOW())
    `
    _, err = tx.ExecContext(ctx, invQuery, warehouseID, orderID, OperationTypeOutbound, 1, operatorID)
    if err != nil {
        return err
    }
    
    // æ›´æ–°è®¢å•çŠ¶æ€
    _, err = tx.ExecContext(ctx, `UPDATE orders SET status = ?, updated_at = NOW() WHERE id = ?`,
        order.OrderStatusOutWarehouse, orderID)
    if err != nil {
        return err
    }
    
    return tx.Commit()
}

// GetNearestWarehouse è·å–æœ€è¿‘çš„ä»“åº“
func (s *Service) GetNearestWarehouse(ctx context.Context, longitude, latitude float64) (*Warehouse, error) {
    // ä½¿ç”¨ PostGIS è®¡ç®—è·ç¦»
    query := `
        SELECT id, name, code, address, longitude, latitude, capacity, current, status,
               ST_Distance(
                   ST_MakePoint(longitude, latitude)::geography,
                   ST_MakePoint(?, ?)::geography
               ) as distance
        FROM warehouses
        WHERE status = ?
        ORDER BY distance ASC
        LIMIT 1
    `
    
    var warehouse Warehouse
    var distance float64
    err := s.db.QueryRowContext(ctx, query, longitude, latitude, WHStatusActive).Scan(
        &warehouse.ID, &warehouse.Name, &warehouse.Code, &warehouse.Address,
        &warehouse.Longitude, &warehouse.Latitude, &warehouse.Capacity, &warehouse.Current,
        &warehouse.Status, &distance,
    )
    if err != nil {
        return nil, err
    }
    
    return &warehouse, nil
}
```

---

## è¿è¾“ç®¡ç†ç³»ç»Ÿ

### å¸æœºå’Œè½¦è¾†æ¨¡å‹

```go
package transport

import (
    "time"
)

// Driver å¸æœº
type Driver struct {
    ID           int64        `json:"id" db:"id"`
    Name         string       `json:"name" db:"name"`
    Phone        string       `json:"phone" db:"phone"`
    LicenseNo    string       `json:"license_no" db:"license_no"`      // é©¾ç…§å·
    VehicleID    int64        `json:"vehicle_id" db:"vehicle_id"`
    Status       DriverStatus `json:"status" db:"status"`
    CurrentLat   float64      `json:"current_lat" db:"current_lat"`    // å½“å‰çº¬åº¦
    CurrentLng   float64      `json:"current_lng" db:"current_lng"`    // å½“å‰ç»åº¦
    LastReportAt time.Time    `json:"last_report_at" db:"last_report_at"`
    CreatedAt    time.Time    `json:"created_at" db:"created_at"`
}

// DriverStatus å¸æœºçŠ¶æ€
type DriverStatus int

const (
    DriverStatusIdle      DriverStatus = 1 // ç©ºé—²
    DriverStatusBusy      DriverStatus = 2 // å¿™ç¢Œ
    DriverStatusOffline   DriverStatus = 3 // ç¦»çº¿
)

// Vehicle è½¦è¾†
type Vehicle struct {
    ID          int64         `json:"id" db:"id"`
    PlateNo     string        `json:"plate_no" db:"plate_no"`       // è½¦ç‰Œå·
    VehicleType VehicleType   `json:"vehicle_type" db:"vehicle_type"`
    LoadCapacity float64      `json:"load_capacity" db:"load_capacity"` // è½½é‡(kg)
    VolumeCapacity float64    `json:"volume_capacity" db:"volume_capacity"` // å®¹ç§¯(mÂ³)
    Status      VehicleStatus `json:"status" db:"status"`
    CreatedAt   time.Time     `json:"created_at" db:"created_at"`
}

// VehicleType è½¦è¾†ç±»å‹
type VehicleType int

const (
    VehicleTypeTricycle VehicleType = 1 // ä¸‰è½®è½¦
    VehicleTypeVan      VehicleType = 2 // é¢åŒ…è½¦
    VehicleTypeTruck    VehicleType = 3 // è´§è½¦
)

// VehicleStatus è½¦è¾†çŠ¶æ€
type VehicleStatus int

const (
    VehicleStatusAvailable VehicleStatus = 1 // å¯ç”¨
    VehicleStatusInUse     VehicleStatus = 2 // ä½¿ç”¨ä¸­
    VehicleStatusMaintain  VehicleStatus = 3 // ç»´æŠ¤ä¸­
)

// DeliveryTask é…é€ä»»åŠ¡
type DeliveryTask struct {
    ID          int64      `json:"id" db:"id"`
    DriverID    int64      `json:"driver_id" db:"driver_id"`
    VehicleID   int64      `json:"vehicle_id" db:"vehicle_id"`
    Orders      []int64    `json:"orders"`               // è®¢å•åˆ—è¡¨
    Route       []Location `json:"route"`                // è·¯å¾„
    TotalDistance float64  `json:"total_distance" db:"total_distance"` // æ€»è·ç¦»(km)
    EstimatedTime int      `json:"estimated_time" db:"estimated_time"` // é¢„è®¡è€—æ—¶(åˆ†é’Ÿ)
    Status      TaskStatus `json:"status" db:"status"`
    StartedAt   *time.Time `json:"started_at" db:"started_at"`
    CompletedAt *time.Time `json:"completed_at" db:"completed_at"`
    CreatedAt   time.Time  `json:"created_at" db:"created_at"`
}

// Location ä½ç½®
type Location struct {
    Longitude float64 `json:"longitude"`
    Latitude  float64 `json:"latitude"`
    Address   string  `json:"address"`
}

// TaskStatus ä»»åŠ¡çŠ¶æ€
type TaskStatus int

const (
    TaskStatusPending   TaskStatus = 1 // å¾…æ‰§è¡Œ
    TaskStatusInProgress TaskStatus = 2 // è¿›è¡Œä¸­
    TaskStatusCompleted TaskStatus = 3 // å·²å®Œæˆ
    TaskStatusCancelled TaskStatus = 4 // å·²å–æ¶ˆ
)
```

### è°ƒåº¦æœåŠ¡

```go
package transport

import (
    "context"
    "database/sql"
    "errors"
    "math"
)

// DispatchService è°ƒåº¦æœåŠ¡
type DispatchService struct {
    db *sql.DB
}

// AssignDriver åˆ†é…å¸æœº
func (s *DispatchService) AssignDriver(ctx context.Context, orderIDs []int64) (*DeliveryTask, error) {
    // 1. è·å–è®¢å•é…é€åœ°å€
    orders, err := s.getOrders(ctx, orderIDs)
    if err != nil {
        return nil, err
    }
    
    // 2. æŸ¥æ‰¾æœ€ä¼˜å¸æœºï¼ˆè·ç¦»æœ€è¿‘ + ç©ºé—²ï¼‰
    driver, err := s.findOptimalDriver(ctx, orders[0].DeliveryAddr.Latitude, orders[0].DeliveryAddr.Longitude)
    if err != nil {
        return nil, err
    }
    
    // 3. è®¡ç®—æœ€ä¼˜é…é€è·¯å¾„
    route, totalDistance := s.calculateOptimalRoute(orders)
    
    // 4. åˆ›å»ºé…é€ä»»åŠ¡
    task := &DeliveryTask{
        DriverID:      driver.ID,
        VehicleID:     driver.VehicleID,
        Orders:        orderIDs,
        Route:         route,
        TotalDistance: totalDistance,
        EstimatedTime: int(totalDistance / 40 * 60), // å‡è®¾å¹³å‡é€Ÿåº¦40km/h
        Status:        TaskStatusPending,
    }
    
    // 5. ä¿å­˜ä»»åŠ¡
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return nil, err
    }
    defer tx.Rollback()
    
    routeJSON, _ := json.Marshal(task.Route)
    ordersJSON, _ := json.Marshal(task.Orders)
    
    query := `
        INSERT INTO delivery_tasks (driver_id, vehicle_id, orders, route, total_distance, estimated_time, status, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, NOW())
    `
    result, err := tx.ExecContext(ctx, query,
        task.DriverID, task.VehicleID, ordersJSON, routeJSON, task.TotalDistance, task.EstimatedTime, task.Status,
    )
    if err != nil {
        return nil, err
    }
    
    taskID, _ := result.LastInsertId()
    task.ID = taskID
    
    // 6. æ›´æ–°å¸æœºçŠ¶æ€
    _, err = tx.ExecContext(ctx, `UPDATE drivers SET status = ? WHERE id = ?`, DriverStatusBusy, driver.ID)
    if err != nil {
        return nil, err
    }
    
    // 7. æ›´æ–°è®¢å•çŠ¶æ€å’Œå¸æœºä¿¡æ¯
    for _, orderID := range orderIDs {
        _, err = tx.ExecContext(ctx, `UPDATE orders SET driver_id = ?, status = ? WHERE id = ?`,
            driver.ID, order.OrderStatusDelivering, orderID)
        if err != nil {
            return nil, err
        }
    }
    
    if err := tx.Commit(); err != nil {
        return nil, err
    }
    
    // 8. é€šçŸ¥å¸æœº
    go s.notifyDriver(driver.ID, task)
    
    return task, nil
}

// findOptimalDriver æŸ¥æ‰¾æœ€ä¼˜å¸æœº
func (s *DispatchService) findOptimalDriver(ctx context.Context, lat, lng float64) (*Driver, error) {
    query := `
        SELECT id, name, phone, vehicle_id, status, current_lat, current_lng,
               ST_Distance(
                   ST_MakePoint(current_lng, current_lat)::geography,
                   ST_MakePoint(?, ?)::geography
               ) as distance
        FROM drivers
        WHERE status = ?
        ORDER BY distance ASC
        LIMIT 1
    `
    
    var driver Driver
    var distance float64
    err := s.db.QueryRowContext(ctx, query, lng, lat, DriverStatusIdle).Scan(
        &driver.ID, &driver.Name, &driver.Phone, &driver.VehicleID, &driver.Status,
        &driver.CurrentLat, &driver.CurrentLng, &distance,
    )
    if err == sql.ErrNoRows {
        return nil, errors.New("æ— å¯ç”¨å¸æœº")
    }
    if err != nil {
        return nil, err
    }
    
    return &driver, nil
}

// calculateOptimalRoute è®¡ç®—æœ€ä¼˜é…é€è·¯å¾„ï¼ˆTSPé—®é¢˜ï¼‰
func (s *DispatchService) calculateOptimalRoute(orders []*order.Order) ([]Location, float64) {
    // ç®€åŒ–å®ç°ï¼šä½¿ç”¨è´ªå¿ƒç®—æ³•ï¼ˆæœ€è¿‘é‚»ï¼‰
    // å®é™…åº”ç”¨ä¸­å¯ä»¥ä½¿ç”¨ï¼š
    // 1. é—ä¼ ç®—æ³•
    // 2. æ¨¡æ‹Ÿé€€ç«
    // 3. èšç¾¤ç®—æ³•
    // 4. è°ƒç”¨é«˜å¾·/ç™¾åº¦ç­‰åœ°å›¾API
    
    if len(orders) == 0 {
        return nil, 0
    }
    
    route := make([]Location, 0, len(orders))
    visited := make(map[int]bool)
    totalDistance := 0.0
    
    // ä»ç¬¬ä¸€ä¸ªè®¢å•å¼€å§‹
    current := 0
    route = append(route, Location{
        Longitude: orders[current].DeliveryAddr.Longitude,
        Latitude:  orders[current].DeliveryAddr.Latitude,
        Address:   orders[current].DeliveryAddr.Detail,
    })
    visited[current] = true
    
    // è´ªå¿ƒé€‰æ‹©æœ€è¿‘çš„ä¸‹ä¸€ä¸ªç‚¹
    for len(visited) < len(orders) {
        minDist := math.MaxFloat64
        nextIdx := -1
        
        for i, order := range orders {
            if visited[i] {
                continue
            }
            
            dist := calculateDistance(
                route[len(route)-1].Latitude, route[len(route)-1].Longitude,
                order.DeliveryAddr.Latitude, order.DeliveryAddr.Longitude,
            )
            
            if dist < minDist {
                minDist = dist
                nextIdx = i
            }
        }
        
        if nextIdx != -1 {
            route = append(route, Location{
                Longitude: orders[nextIdx].DeliveryAddr.Longitude,
                Latitude:  orders[nextIdx].DeliveryAddr.Latitude,
                Address:   orders[nextIdx].DeliveryAddr.Detail,
            })
            totalDistance += minDist
            visited[nextIdx] = true
        }
    }
    
    return route, totalDistance
}

// calculateDistance è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»ï¼ˆHaversineå…¬å¼ï¼‰
func calculateDistance(lat1, lng1, lat2, lng2 float64) float64 {
    const R = 6371 // åœ°çƒåŠå¾„(km)
    
    dLat := (lat2 - lat1) * math.Pi / 180
    dLng := (lng2 - lng1) * math.Pi / 180
    
    lat1Rad := lat1 * math.Pi / 180
    lat2Rad := lat2 * math.Pi / 180
    
    a := math.Sin(dLat/2)*math.Sin(dLat/2) +
        math.Cos(lat1Rad)*math.Cos(lat2Rad)*
            math.Sin(dLng/2)*math.Sin(dLng/2)
    
    c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))
    
    return R * c
}

// notifyDriver é€šçŸ¥å¸æœº
func (s *DispatchService) notifyDriver(driverID int64, task *DeliveryTask) {
    // é€šè¿‡æ¨é€ã€çŸ­ä¿¡ç­‰æ–¹å¼é€šçŸ¥å¸æœº
    // å®ç°ç•¥
}
```

---

## è·¯å¾„è§„åˆ’ç³»ç»Ÿ

### å¤šç‚¹è·¯å¾„ä¼˜åŒ–

```go
package routing

import (
    "math"
    "math/rand"
)

// GeneticAlgorithm é—ä¼ ç®—æ³•æ±‚è§£TSP
type GeneticAlgorithm struct {
    PopulationSize int     // ç§ç¾¤å¤§å°
    Generations    int     // è¿­ä»£æ¬¡æ•°
    MutationRate   float64 // å˜å¼‚ç‡
    CrossoverRate  float64 // äº¤å‰ç‡
}

// NewGeneticAlgorithm åˆ›å»ºé—ä¼ ç®—æ³•
func NewGeneticAlgorithm() *GeneticAlgorithm {
    return &GeneticAlgorithm{
        PopulationSize: 100,
        Generations:    1000,
        MutationRate:   0.01,
        CrossoverRate:  0.7,
    }
}

// Solve æ±‚è§£æœ€ä¼˜è·¯å¾„
func (ga *GeneticAlgorithm) Solve(locations []Location) ([]int, float64) {
    n := len(locations)
    if n <= 2 {
        return []int{0, 1}, calculateDistance(
            locations[0].Latitude, locations[0].Longitude,
            locations[1].Latitude, locations[1].Longitude,
        )
    }
    
    // è®¡ç®—è·ç¦»çŸ©é˜µ
    distMatrix := make([][]float64, n)
    for i := range distMatrix {
        distMatrix[i] = make([]float64, n)
        for j := range distMatrix[i] {
            if i != j {
                distMatrix[i][j] = calculateDistance(
                    locations[i].Latitude, locations[i].Longitude,
                    locations[j].Latitude, locations[j].Longitude,
                )
            }
        }
    }
    
    // åˆå§‹åŒ–ç§ç¾¤
    population := ga.initPopulation(n)
    
    // è¿­ä»£è¿›åŒ–
    for gen := 0; gen < ga.Generations; gen++ {
        // è¯„ä¼°é€‚åº”åº¦
        fitness := ga.evaluateFitness(population, distMatrix)
        
        // é€‰æ‹©
        selected := ga.selection(population, fitness)
        
        // äº¤å‰
        offspring := ga.crossover(selected)
        
        // å˜å¼‚
        ga.mutation(offspring)
        
        population = offspring
    }
    
    // è¿”å›æœ€ä¼˜è§£
    fitness := ga.evaluateFitness(population, distMatrix)
    bestIdx := 0
    bestFitness := fitness[0]
    for i, f := range fitness {
        if f < bestFitness {
            bestFitness = f
            bestIdx = i
        }
    }
    
    return population[bestIdx], bestFitness
}

// initPopulation åˆå§‹åŒ–ç§ç¾¤
func (ga *GeneticAlgorithm) initPopulation(n int) [][]int {
    population := make([][]int, ga.PopulationSize)
    for i := range population {
        population[i] = randomPermutation(n)
    }
    return population
}

// evaluateFitness è¯„ä¼°é€‚åº”åº¦ï¼ˆæ€»è·ç¦»ï¼‰
func (ga *GeneticAlgorithm) evaluateFitness(population [][]int, distMatrix [][]float64) []float64 {
    fitness := make([]float64, len(population))
    for i, individual := range population {
        distance := 0.0
        for j := 0; j < len(individual)-1; j++ {
            distance += distMatrix[individual[j]][individual[j+1]]
        }
        fitness[i] = distance
    }
    return fitness
}

// selection è½®ç›˜èµŒé€‰æ‹©
func (ga *GeneticAlgorithm) selection(population [][]int, fitness []float64) [][]int {
    // è½¬æ¢ä¸ºé€‚åº”åº¦å€¼ï¼ˆè·ç¦»è¶Šå°è¶Šå¥½ï¼‰
    maxFitness := 0.0
    for _, f := range fitness {
        if f > maxFitness {
            maxFitness = f
        }
    }
    
    probabilities := make([]float64, len(fitness))
    totalProb := 0.0
    for i, f := range fitness {
        probabilities[i] = maxFitness - f + 1
        totalProb += probabilities[i]
    }
    
    selected := make([][]int, ga.PopulationSize)
    for i := range selected {
        r := rand.Float64() * totalProb
        sum := 0.0
        for j, prob := range probabilities {
            sum += prob
            if sum >= r {
                selected[i] = make([]int, len(population[j]))
                copy(selected[i], population[j])
                break
            }
        }
    }
    
    return selected
}

// crossover é¡ºåºäº¤å‰
func (ga *GeneticAlgorithm) crossover(population [][]int) [][]int {
    offspring := make([][]int, len(population))
    for i := 0; i < len(population); i += 2 {
        if rand.Float64() < ga.CrossoverRate && i+1 < len(population) {
            parent1 := population[i]
            parent2 := population[i+1]
            
            child1, child2 := ga.orderCrossover(parent1, parent2)
            offspring[i] = child1
            offspring[i+1] = child2
        } else {
            offspring[i] = make([]int, len(population[i]))
            copy(offspring[i], population[i])
            if i+1 < len(population) {
                offspring[i+1] = make([]int, len(population[i+1]))
                copy(offspring[i+1], population[i+1])
            }
        }
    }
    return offspring
}

// orderCrossover é¡ºåºäº¤å‰æ“ä½œ
func (ga *GeneticAlgorithm) orderCrossover(parent1, parent2 []int) ([]int, []int) {
    n := len(parent1)
    child1 := make([]int, n)
    child2 := make([]int, n)
    
    // éšæœºé€‰æ‹©äº¤å‰ç‚¹
    point1 := rand.Intn(n)
    point2 := rand.Intn(n)
    if point1 > point2 {
        point1, point2 = point2, point1
    }
    
    // å¤åˆ¶ä¸­é—´æ®µ
    for i := point1; i <= point2; i++ {
        child1[i] = parent1[i]
        child2[i] = parent2[i]
    }
    
    // å¡«å……å‰©ä½™éƒ¨åˆ†
    ga.fillChild(child1, parent2, point1, point2)
    ga.fillChild(child2, parent1, point1, point2)
    
    return child1, child2
}

// fillChild å¡«å……å­ä»£
func (ga *GeneticAlgorithm) fillChild(child, parent []int, start, end int) {
    pos := (end + 1) % len(child)
    for _, gene := range parent {
        if !contains(child[start:end+1], gene) {
            child[pos] = gene
            pos = (pos + 1) % len(child)
            if pos == start {
                return
            }
        }
    }
}

// mutation å˜å¼‚æ“ä½œï¼ˆäº¤æ¢ä¸¤ä¸ªä½ç½®ï¼‰
func (ga *GeneticAlgorithm) mutation(population [][]int) {
    for i := range population {
        if rand.Float64() < ga.MutationRate {
            pos1 := rand.Intn(len(population[i]))
            pos2 := rand.Intn(len(population[i]))
            population[i][pos1], population[i][pos2] = population[i][pos2], population[i][pos1]
        }
    }
}

// randomPermutation ç”Ÿæˆéšæœºæ’åˆ—
func randomPermutation(n int) []int {
    perm := make([]int, n)
    for i := range perm {
        perm[i] = i
    }
    rand.Shuffle(n, func(i, j int) {
        perm[i], perm[j] = perm[j], perm[i]
    })
    return perm
}

// contains æ£€æŸ¥åˆ‡ç‰‡æ˜¯å¦åŒ…å«å…ƒç´ 
func contains(slice []int, val int) bool {
    for _, v := range slice {
        if v == val {
            return true
        }
    }
    return false
}
```

---

## å®æ—¶è¿½è¸ªç³»ç»Ÿ

### GPSæ•°æ®ä¸ŠæŠ¥

```go
package tracking

import (
    "context"
    "encoding/json"
    "time"
    "github.com/redis/go-redis/v9"
)

// GPSData GPSæ•°æ®
type GPSData struct {
    DriverID  int64     `json:"driver_id"`
    Longitude float64   `json:"longitude"`
    Latitude  float64   `json:"latitude"`
    Speed     float64   `json:"speed"`      // é€Ÿåº¦(km/h)
    Direction float64   `json:"direction"`  // æ–¹å‘(åº¦)
    Altitude  float64   `json:"altitude"`   // æµ·æ‹”(m)
    Accuracy  float64   `json:"accuracy"`   // ç²¾åº¦(m)
    Timestamp time.Time `json:"timestamp"`
}

// TrackingService è¿½è¸ªæœåŠ¡
type TrackingService struct {
    rdb *redis.Client
}

// NewTrackingService åˆ›å»ºè¿½è¸ªæœåŠ¡
func NewTrackingService(rdb *redis.Client) *TrackingService {
    return &TrackingService{rdb: rdb}
}

// ReportLocation ä¸ŠæŠ¥ä½ç½®
func (s *TrackingService) ReportLocation(ctx context.Context, data *GPSData) error {
    // 1. å­˜å‚¨åˆ°Redisï¼ˆå®æ—¶ä½ç½®ï¼‰
    key := fmt.Sprintf("driver:location:%d", data.DriverID)
    jsonData, _ := json.Marshal(data)
    
    err := s.rdb.Set(ctx, key, jsonData, 5*time.Minute).Err()
    if err != nil {
        return err
    }
    
    // 2. å­˜å‚¨åˆ°GEOç´¢å¼•ï¼ˆç”¨äºèŒƒå›´æŸ¥è¯¢ï¼‰
    geoKey := "drivers:geo"
    err = s.rdb.GeoAdd(ctx, geoKey, &redis.GeoLocation{
        Name:      fmt.Sprintf("%d", data.DriverID),
        Longitude: data.Longitude,
        Latitude:  data.Latitude,
    }).Err()
    if err != nil {
        return err
    }
    
    // 3. æ·»åŠ åˆ°è½¨è¿¹æµï¼ˆç”¨äºå†å²å›æ”¾ï¼‰
    trackKey := fmt.Sprintf("driver:track:%d:%s", data.DriverID, time.Now().Format("20060102"))
    s.rdb.XAdd(ctx, &redis.XAddArgs{
        Stream: trackKey,
        Values: map[string]interface{}{
            "longitude": data.Longitude,
            "latitude":  data.Latitude,
            "speed":     data.Speed,
            "timestamp": data.Timestamp.Unix(),
        },
    })
    
    // 4. æ£€æŸ¥æ˜¯å¦åç¦»è·¯çº¿
    go s.checkRouteDeviation(data.DriverID, data.Longitude, data.Latitude)
    
    return nil
}

// GetDriverLocation è·å–å¸æœºä½ç½®
func (s *TrackingService) GetDriverLocation(ctx context.Context, driverID int64) (*GPSData, error) {
    key := fmt.Sprintf("driver:location:%d", driverID)
    
    val, err := s.rdb.Get(ctx, key).Result()
    if err != nil {
        return nil, err
    }
    
    var data GPSData
    err = json.Unmarshal([]byte(val), &data)
    if err != nil {
        return nil, err
    }
    
    return &data, nil
}

// GetNearbyDrivers è·å–é™„è¿‘å¸æœº
func (s *TrackingService) GetNearbyDrivers(ctx context.Context, longitude, latitude, radiusKm float64) ([]int64, error) {
    geoKey := "drivers:geo"
    
    results, err := s.rdb.GeoRadius(ctx, geoKey, longitude, latitude, &redis.GeoRadiusQuery{
        Radius:      radiusKm,
        Unit:        "km",
        WithCoord:   true,
        WithDist:    true,
        Sort:        "ASC",
    }).Result()
    
    if err != nil {
        return nil, err
    }
    
    driverIDs := make([]int64, 0, len(results))
    for _, result := range results {
        driverID, _ := strconv.ParseInt(result.Name, 10, 64)
        driverIDs = append(driverIDs, driverID)
    }
    
    return driverIDs, nil
}

// GetDriverTrack è·å–å¸æœºè½¨è¿¹
func (s *TrackingService) GetDriverTrack(ctx context.Context, driverID int64, date time.Time) ([]GPSData, error) {
    trackKey := fmt.Sprintf("driver:track:%d:%s", driverID, date.Format("20060102"))
    
    results, err := s.rdb.XRange(ctx, trackKey, "-", "+").Result()
    if err != nil {
        return nil, err
    }
    
    tracks := make([]GPSData, 0, len(results))
    for _, result := range results {
        lng, _ := strconv.ParseFloat(result.Values["longitude"].(string), 64)
        lat, _ := strconv.ParseFloat(result.Values["latitude"].(string), 64)
        speed, _ := strconv.ParseFloat(result.Values["speed"].(string), 64)
        timestamp, _ := strconv.ParseInt(result.Values["timestamp"].(string), 10, 64)
        
        tracks = append(tracks, GPSData{
            DriverID:  driverID,
            Longitude: lng,
            Latitude:  lat,
            Speed:     speed,
            Timestamp: time.Unix(timestamp, 0),
        })
    }
    
    return tracks, nil
}

// checkRouteDeviation æ£€æŸ¥è·¯çº¿åç¦»
func (s *TrackingService) checkRouteDeviation(driverID int64, currentLng, currentLat float64) {
    // è·å–å¸æœºå½“å‰ä»»åŠ¡çš„è§„åˆ’è·¯çº¿
    // è®¡ç®—å½“å‰ä½ç½®åˆ°è·¯çº¿çš„æœ€çŸ­è·ç¦»
    // å¦‚æœè¶…è¿‡é˜ˆå€¼ï¼ˆå¦‚500ç±³ï¼‰ï¼Œå‘é€å‘Šè­¦
    // å®ç°ç•¥
}
```

---

## æ™ºèƒ½è°ƒåº¦ç³»ç»Ÿ

### è®¢å•æ‰¹é‡è°ƒåº¦

```go
package scheduler

import (
    "context"
    "sort"
    "sync"
    "time"
)

// Scheduler æ™ºèƒ½è°ƒåº¦å™¨
type Scheduler struct {
    orderQueue  chan int64
    workerPool  *WorkerPool
    mu          sync.RWMutex
}

// NewScheduler åˆ›å»ºè°ƒåº¦å™¨
func NewScheduler(workerCount int) *Scheduler {
    return &Scheduler{
        orderQueue: make(chan int64, 1000),
        workerPool: NewWorkerPool(workerCount),
    }
}

// Start å¯åŠ¨è°ƒåº¦å™¨
func (s *Scheduler) Start() {
    // å¯åŠ¨å·¥ä½œæ± 
    s.workerPool.Start()
    
    // å¯åŠ¨æ‰¹é‡è°ƒåº¦åç¨‹
    go s.batchDispatch()
}

// AddOrder æ·»åŠ è®¢å•åˆ°è°ƒåº¦é˜Ÿåˆ—
func (s *Scheduler) AddOrder(orderID int64) {
    s.orderQueue <- orderID
}

// batchDispatch æ‰¹é‡è°ƒåº¦
func (s *Scheduler) batchDispatch() {
    ticker := time.NewTicker(30 * time.Second) // æ¯30ç§’æ‰¹é‡å¤„ç†ä¸€æ¬¡
    defer ticker.Stop()
    
    buffer := make([]int64, 0, 100)
    
    for {
        select {
        case orderID := <-s.orderQueue:
            buffer = append(buffer, orderID)
            
            // ç¼“å†²åŒºæ»¡äº†ï¼Œç«‹å³å¤„ç†
            if len(buffer) >= 100 {
                s.dispatch(buffer)
                buffer = buffer[:0]
            }
            
        case <-ticker.C:
            // å®šæ—¶å¤„ç†ç¼“å†²åŒºä¸­çš„è®¢å•
            if len(buffer) > 0 {
                s.dispatch(buffer)
                buffer = buffer[:0]
            }
        }
    }
}

// dispatch è°ƒåº¦è®¢å•
func (s *Scheduler) dispatch(orderIDs []int64) {
    ctx := context.Background()
    
    // 1. è·å–æ‰€æœ‰è®¢å•ä¿¡æ¯
    orders, err := orderService.GetOrdersByIDs(ctx, orderIDs)
    if err != nil {
        return
    }
    
    // 2. æŒ‰é…é€åœ°å€èšç±»ï¼ˆåŒä¸€åŒºåŸŸçš„è®¢å•å°½é‡åˆå¹¶ï¼‰
    clusters := s.clusterOrders(orders)
    
    // 3. ä¸ºæ¯ä¸ªç°‡åˆ†é…å¸æœº
    for _, cluster := range clusters {
        s.workerPool.Submit(func() {
            orderIDs := make([]int64, len(cluster))
            for i, order := range cluster {
                orderIDs[i] = order.ID
            }
            
            _, err := dispatchService.AssignDriver(ctx, orderIDs)
            if err != nil {
                // è®°å½•å¤±è´¥ï¼Œç¨åé‡è¯•
                logger.Error("åˆ†é…å¸æœºå¤±è´¥", "error", err, "orders", orderIDs)
            }
        })
    }
}

// clusterOrders è®¢å•èšç±»ï¼ˆä½¿ç”¨K-Meansï¼‰
func (s *Scheduler) clusterOrders(orders []*order.Order) [][]*order.Order {
    if len(orders) <= 5 {
        return [][]*order.Order{orders}
    }
    
    // ç®€åŒ–å®ç°ï¼šæŒ‰è·ç¦»èšç±»
    // å®é™…åº”ç”¨ä¸­å¯ä½¿ç”¨æ›´å¤æ‚çš„èšç±»ç®—æ³•
    
    k := (len(orders) + 4) / 5 // æ¯ä¸ªç°‡æœ€å¤š5ä¸ªè®¢å•
    clusters := make([][]*order.Order, k)
    
    // éšæœºé€‰æ‹©kä¸ªä¸­å¿ƒç‚¹
    centers := make([]*order.Order, k)
    perm := rand.Perm(len(orders))
    for i := 0; i < k && i < len(orders); i++ {
        centers[i] = orders[perm[i]]
    }
    
    // è¿­ä»£èšç±»
    for iter := 0; iter < 10; iter++ {
        // æ¸…ç©ºç°‡
        for i := range clusters {
            clusters[i] = make([]*order.Order, 0)
        }
        
        // åˆ†é…è®¢å•åˆ°æœ€è¿‘çš„ç°‡
        for _, order := range orders {
            minDist := math.MaxFloat64
            clusterIdx := 0
            
            for i, center := range centers {
                dist := calculateDistance(
                    order.DeliveryAddr.Latitude, order.DeliveryAddr.Longitude,
                    center.DeliveryAddr.Latitude, center.DeliveryAddr.Longitude,
                )
                if dist < minDist {
                    minDist = dist
                    clusterIdx = i
                }
            }
            
            clusters[clusterIdx] = append(clusters[clusterIdx], order)
        }
        
        // æ›´æ–°ä¸­å¿ƒç‚¹
        for i, cluster := range clusters {
            if len(cluster) > 0 {
                avgLat := 0.0
                avgLng := 0.0
                for _, order := range cluster {
                    avgLat += order.DeliveryAddr.Latitude
                    avgLng += order.DeliveryAddr.Longitude
                }
                avgLat /= float64(len(cluster))
                avgLng /= float64(len(cluster))
                
                // æ‰¾åˆ°æœ€æ¥è¿‘å¹³å‡ä½ç½®çš„è®¢å•ä½œä¸ºæ–°ä¸­å¿ƒ
                minDist := math.MaxFloat64
                for _, order := range cluster {
                    dist := calculateDistance(
                        order.DeliveryAddr.Latitude, order.DeliveryAddr.Longitude,
                        avgLat, avgLng,
                    )
                    if dist < minDist {
                        minDist = dist
                        centers[i] = order
                    }
                }
            }
        }
    }
    
    return clusters
}

// WorkerPool å·¥ä½œæ± 
type WorkerPool struct {
    workerCount int
    taskQueue   chan func()
    wg          sync.WaitGroup
}

// NewWorkerPool åˆ›å»ºå·¥ä½œæ± 
func NewWorkerPool(workerCount int) *WorkerPool {
    return &WorkerPool{
        workerCount: workerCount,
        taskQueue:   make(chan func(), 100),
    }
}

// Start å¯åŠ¨å·¥ä½œæ± 
func (wp *WorkerPool) Start() {
    for i := 0; i < wp.workerCount; i++ {
        wp.wg.Add(1)
        go wp.worker()
    }
}

// worker å·¥ä½œåç¨‹
func (wp *WorkerPool) worker() {
    defer wp.wg.Done()
    
    for task := range wp.taskQueue {
        task()
    }
}

// Submit æäº¤ä»»åŠ¡
func (wp *WorkerPool) Submit(task func()) {
    wp.taskQueue <- task
}

// Stop åœæ­¢å·¥ä½œæ± 
func (wp *WorkerPool) Stop() {
    close(wp.taskQueue)
    wp.wg.Wait()
}
```

---

## æ•°æ®åˆ†æä¸ä¼˜åŒ–

### é…é€æ•ˆç‡åˆ†æ

```go
package analytics

import (
    "context"
    "database/sql"
    "time"
)

// DeliveryMetrics é…é€æŒ‡æ ‡
type DeliveryMetrics struct {
    Date              time.Time
    TotalOrders       int     // æ€»è®¢å•æ•°
    CompletedOrders   int     // å®Œæˆè®¢å•æ•°
    CancelledOrders   int     // å–æ¶ˆè®¢å•æ•°
    AvgDeliveryTime   float64 // å¹³å‡é…é€æ—¶é—´(åˆ†é’Ÿ)
    OnTimeRate        float64 // å‡†æ—¶ç‡
    AvgDistance       float64 // å¹³å‡é…é€è·ç¦»(km)
    AvgOrdersPerDriver int    // å¸æœºå¹³å‡è®¢å•æ•°
    DriverUtilization float64 // å¸æœºåˆ©ç”¨ç‡
}

// AnalyticsService åˆ†ææœåŠ¡
type AnalyticsService struct {
    db *sql.DB
}

// GetDailyMetrics è·å–æ¯æ—¥æŒ‡æ ‡
func (s *AnalyticsService) GetDailyMetrics(ctx context.Context, date time.Time) (*DeliveryMetrics, error) {
    query := `
        SELECT 
            DATE(created_at) as date,
            COUNT(*) as total_orders,
            SUM(CASE WHEN status = ? THEN 1 ELSE 0 END) as completed_orders,
            SUM(CASE WHEN status = ? THEN 1 ELSE 0 END) as cancelled_orders,
            AVG(CASE WHEN actual_time IS NOT NULL 
                THEN TIMESTAMPDIFF(MINUTE, created_at, actual_time) 
                ELSE NULL END) as avg_delivery_time,
            SUM(CASE WHEN actual_time <= expected_time THEN 1 ELSE 0 END) * 100.0 / 
                SUM(CASE WHEN actual_time IS NOT NULL THEN 1 ELSE 0 END) as on_time_rate
        FROM orders
        WHERE DATE(created_at) = DATE(?)
        GROUP BY DATE(created_at)
    `
    
    var metrics DeliveryMetrics
    err := s.db.QueryRowContext(ctx, query,
        order.OrderStatusDelivered,
        order.OrderStatusCancelled,
        date,
    ).Scan(
        &metrics.Date,
        &metrics.TotalOrders,
        &metrics.CompletedOrders,
        &metrics.CancelledOrders,
        &metrics.AvgDeliveryTime,
        &metrics.OnTimeRate,
    )
    
    if err != nil {
        return nil, err
    }
    
    // æŸ¥è¯¢å¹³å‡é…é€è·ç¦»
    distQuery := `
        SELECT AVG(total_distance)
        FROM delivery_tasks
        WHERE DATE(created_at) = DATE(?) AND status = ?
    `
    s.db.QueryRowContext(ctx, distQuery, date, transport.TaskStatusCompleted).Scan(&metrics.AvgDistance)
    
    // æŸ¥è¯¢å¸æœºæŒ‡æ ‡
    driverQuery := `
        SELECT 
            COUNT(DISTINCT driver_id) as active_drivers,
            COUNT(*) * 1.0 / COUNT(DISTINCT driver_id) as avg_orders_per_driver
        FROM delivery_tasks
        WHERE DATE(created_at) = DATE(?) AND status = ?
    `
    var activeDrivers int
    s.db.QueryRowContext(ctx, driverQuery, date, transport.TaskStatusCompleted).Scan(
        &activeDrivers,
        &metrics.AvgOrdersPerDriver,
    )
    
    // è®¡ç®—å¸æœºåˆ©ç”¨ç‡ï¼ˆå·¥ä½œæ—¶é—´/æ€»åœ¨çº¿æ—¶é—´ï¼‰
    // ç®€åŒ–å®ç°
    metrics.DriverUtilization = float64(metrics.CompletedOrders) / float64(activeDrivers) / 10.0 * 100
    if metrics.DriverUtilization > 100 {
        metrics.DriverUtilization = 100
    }
    
    return &metrics, nil
}

// GetDriverPerformance è·å–å¸æœºç»©æ•ˆ
func (s *AnalyticsService) GetDriverPerformance(ctx context.Context, driverID int64, startDate, endDate time.Time) (*DriverPerformance, error) {
    query := `
        SELECT 
            driver_id,
            COUNT(*) as total_tasks,
            SUM(CASE WHEN status = ? THEN 1 ELSE 0 END) as completed_tasks,
            AVG(total_distance) as avg_distance,
            AVG(TIMESTAMPDIFF(MINUTE, started_at, completed_at)) as avg_time
        FROM delivery_tasks
        WHERE driver_id = ? AND DATE(created_at) BETWEEN DATE(?) AND DATE(?)
        GROUP BY driver_id
    `
    
    var perf DriverPerformance
    err := s.db.QueryRowContext(ctx, query,
        transport.TaskStatusCompleted,
        driverID,
        startDate,
        endDate,
    ).Scan(
        &perf.DriverID,
        &perf.TotalTasks,
        &perf.CompletedTasks,
        &perf.AvgDistance,
        &perf.AvgTime,
    )
    
    if err != nil {
        return nil, err
    }
    
    perf.CompletionRate = float64(perf.CompletedTasks) / float64(perf.TotalTasks) * 100
    
    return &perf, nil
}

// DriverPerformance å¸æœºç»©æ•ˆ
type DriverPerformance struct {
    DriverID       int64
    TotalTasks     int
    CompletedTasks int
    CompletionRate float64
    AvgDistance    float64
    AvgTime        float64
}
```

---

## æ€§èƒ½ä¼˜åŒ–

### æ•°æ®åº“ä¼˜åŒ–

```sql
-- è®¢å•è¡¨ç´¢å¼•
CREATE INDEX idx_orders_customer_id ON orders(customer_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_created_at ON orders(created_at);
CREATE INDEX idx_orders_driver_id ON orders(driver_id);

-- ä½ç½®ç´¢å¼•ï¼ˆä½¿ç”¨PostGISï¼‰
CREATE INDEX idx_drivers_location ON drivers USING GIST(ST_MakePoint(current_lng, current_lat));
CREATE INDEX idx_warehouses_location ON warehouses USING GIST(ST_MakePoint(longitude, latitude));

-- åˆ†åŒºè¡¨ï¼ˆæŒ‰æœˆåˆ†åŒºï¼‰
CREATE TABLE orders_202501 PARTITION OF orders
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- ç‰©åŒ–è§†å›¾ï¼ˆæ¯æ—¥ç»Ÿè®¡ï¼‰
CREATE MATERIALIZED VIEW daily_metrics AS
SELECT 
    DATE(created_at) as date,
    COUNT(*) as total_orders,
    SUM(CASE WHEN status = 8 THEN 1 ELSE 0 END) as completed_orders,
    AVG(CASE WHEN actual_time IS NOT NULL 
        THEN EXTRACT(EPOCH FROM (actual_time - created_at))/60 
        ELSE NULL END) as avg_delivery_time
FROM orders
GROUP BY DATE(created_at);

-- å®šæ—¶åˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY daily_metrics;
```

### Redis ç¼“å­˜ç­–ç•¥

```go
// ç¼“å­˜å¸æœºä½ç½®ï¼ˆ5åˆ†é’Ÿè¿‡æœŸï¼‰
func (s *TrackingService) cacheDriverLocation(ctx context.Context, driverID int64, location *GPSData) {
    key := fmt.Sprintf("driver:loc:%d", driverID)
    data, _ := json.Marshal(location)
    s.rdb.Set(ctx, key, data, 5*time.Minute)
}

// ç¼“å­˜çƒ­é—¨è·¯çº¿ï¼ˆ1å°æ—¶è¿‡æœŸï¼‰
func cachePopularRoute(ctx context.Context, fromLat, fromLng, toLat, toLng float64, route []Location) {
    key := fmt.Sprintf("route:%f,%f-%f,%f", fromLat, fromLng, toLat, toLng)
    data, _ := json.Marshal(route)
    rdb.Set(ctx, key, data, 1*time.Hour)
}
```

---

## æœ€ä½³å®è·µ

### 1. åˆ†å¸ƒå¼é”é˜²æ­¢é‡å¤è°ƒåº¦

```go
func (s *Scheduler) dispatchWithLock(ctx context.Context, orderID int64) error {
    lockKey := fmt.Sprintf("lock:dispatch:%d", orderID)
    
    // è·å–åˆ†å¸ƒå¼é”
    ok, err := s.rdb.SetNX(ctx, lockKey, "1", 30*time.Second).Result()
    if err != nil || !ok {
        return errors.New("è®¢å•æ­£åœ¨è°ƒåº¦ä¸­")
    }
    defer s.rdb.Del(ctx, lockKey)
    
    // æ‰§è¡Œè°ƒåº¦é€»è¾‘
    return s.dispatch(orderID)
}
```

### 2. å¹‚ç­‰æ€§è®¾è®¡

```go
// ä½¿ç”¨è®¢å•å·ä½œä¸ºå¹‚ç­‰é”®
func (s *Service) CreateOrderIdempotent(ctx context.Context, req *CreateOrderRequest) (*Order, error) {
    // æ£€æŸ¥æ˜¯å¦å·²åˆ›å»º
    existingOrder, _ := s.GetOrderByNo(ctx, req.OrderNo)
    if existingOrder != nil {
        return existingOrder, nil
    }
    
    // åˆ›å»ºæ–°è®¢å•
    return s.CreateOrder(ctx, req)
}
```

### 3. é™çº§ç­–ç•¥

```go
// å½“è·¯å¾„è§„åˆ’æœåŠ¡ä¸å¯ç”¨æ—¶ï¼Œä½¿ç”¨ç®€å•çš„æœ€è¿‘é‚»ç®—æ³•
func (s *DispatchService) calculateRouteWithFallback(orders []*order.Order) []Location {
    defer func() {
        if r := recover(); r != nil {
            logger.Error("è·¯å¾„è§„åˆ’å¤±è´¥ï¼Œä½¿ç”¨é™çº§ç­–ç•¥", "error", r)
            return s.calculateOptimalRoute(orders) // é™çº§åˆ°ç®€å•ç®—æ³•
        }
    }()
    
    // å°è¯•è°ƒç”¨é«˜çº§è·¯å¾„è§„åˆ’æœåŠ¡
    return s.advancedRoutePlanning(orders)
}
```

---

## æ€»ç»“

ç‰©æµç³»ç»Ÿå¼€å‘çš„æ ¸å¿ƒè¦ç‚¹ï¼š

1. **å®æ—¶æ€§**: GPSæ•°æ®å®æ—¶ä¸ŠæŠ¥å’Œå¤„ç†ï¼Œä½¿ç”¨ WebSocket/MQTT
2. **å‡†ç¡®æ€§**: ä½ç½®è®¡ç®—ä½¿ç”¨ PostGISï¼Œè·¯å¾„è§„åˆ’ä½¿ç”¨ä¸“ä¸šç®—æ³•
3. **é«˜å¹¶å‘**: å¤§é‡è®¢å•å’ŒGPSæ•°æ®ï¼Œéœ€è¦æ¶ˆæ¯é˜Ÿåˆ—å’Œç¼“å­˜
4. **æ™ºèƒ½è°ƒåº¦**: ä½¿ç”¨AIç®—æ³•ä¼˜åŒ–é…é€è·¯çº¿å’Œå¸æœºåˆ†é…
5. **å¯è§†åŒ–**: æä¾›å®æ—¶åœ°å›¾è¿½è¸ªå’Œæ•°æ®å¤§å±
6. **å®¹é”™æ€§**: æœåŠ¡é™çº§ã€ç†”æ–­ä¿æŠ¤ã€é‡è¯•æœºåˆ¶

---

**ç»´æŠ¤è€…**: Documentation Team  
**åˆ›å»ºæ—¥æœŸ**: 2025-10-22  
**æœ€åæ›´æ–°**: 2025-10-22  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
