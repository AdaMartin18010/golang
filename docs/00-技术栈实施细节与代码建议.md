# æŠ€æœ¯æ ˆå®æ–½ç»†èŠ‚ä¸ä»£ç å»ºè®®

> **ç‰ˆæœ¬**: v1.0
> **æ—¥æœŸ**: 2025-01-XX
> **ç”¨é€”**: ä¸ºæŠ€æœ¯æ ˆæ”¹è¿›æä¾›è¯¦ç»†çš„å®æ–½ç»†èŠ‚å’Œä»£ç å»ºè®®

---

## ğŸ“‹ ç›®å½•

- [1. NATS å®ç°ç»†èŠ‚](#1-nats-å®ç°ç»†èŠ‚)
- [2. gRPC å®Œå–„ç»†èŠ‚](#2-grpc-å®Œå–„ç»†èŠ‚)
- [3. DDD æ¡†æ¶æŠ½è±¡ç»†èŠ‚](#3-ddd-æ¡†æ¶æŠ½è±¡ç»†èŠ‚)
- [4. ä»£ç ç”Ÿæˆå·¥å…·é“¾ç»†èŠ‚](#4-ä»£ç ç”Ÿæˆå·¥å…·é“¾ç»†èŠ‚)
- [5. ç»Ÿä¸€æ¥å£æŠ½è±¡ç»†èŠ‚](#5-ç»Ÿä¸€æ¥å£æŠ½è±¡ç»†èŠ‚)

---

## 1. NATS å®ç°ç»†èŠ‚

### 1.1 æ–‡ä»¶ç»“æ„

```text
internal/infrastructure/messaging/nats/
â”œâ”€â”€ client.go          # NATS å®¢æˆ·ç«¯å®ç°
â”œâ”€â”€ config.go          # NATS é…ç½®
â”œâ”€â”€ jetstream.go       # JetStream æ”¯æŒï¼ˆå¯é€‰ï¼‰
â””â”€â”€ README.md          # ä½¿ç”¨æ–‡æ¡£
```

### 1.2 å®ç°ä»£ç å»ºè®®

#### `client.go` æ ¸å¿ƒå®ç°

```go
package nats

import (
    "context"
    "encoding/json"
    "fmt"
    "time"

    "github.com/nats-io/nats.go"
)

// Client NATS å®¢æˆ·ç«¯å°è£…
type Client struct {
    conn *nats.Conn
}

// Config NATS é…ç½®
type Config struct {
    URL            string        // NATS æœåŠ¡å™¨åœ°å€ï¼Œä¾‹å¦‚: "nats://localhost:4222"
    MaxReconnects  int           // æœ€å¤§é‡è¿æ¬¡æ•°ï¼Œé»˜è®¤: -1 (æ— é™)
    ReconnectWait  time.Duration // é‡è¿ç­‰å¾…æ—¶é—´ï¼Œé»˜è®¤: 2ç§’
    Timeout        time.Duration // è¿æ¥è¶…æ—¶ï¼Œé»˜è®¤: 5ç§’
    Name           string        // å®¢æˆ·ç«¯åç§°
    Token          string        // è®¤è¯ Tokenï¼ˆå¯é€‰ï¼‰
    Username       string        // ç”¨æˆ·åï¼ˆå¯é€‰ï¼‰
    Password       string        // å¯†ç ï¼ˆå¯é€‰ï¼‰
}

// DefaultConfig è¿”å›é»˜è®¤é…ç½®
func DefaultConfig() Config {
    return Config{
        URL:           "nats://localhost:4222",
        MaxReconnects: -1,
        ReconnectWait: 2 * time.Second,
        Timeout:       5 * time.Second,
    }
}

// NewClient åˆ›å»º NATS å®¢æˆ·ç«¯
func NewClient(cfg Config) (*Client, error) {
    opts := []nats.Option{
        nats.Name(cfg.Name),
        nats.MaxReconnects(cfg.MaxReconnects),
        nats.ReconnectWait(cfg.ReconnectWait),
        nats.Timeout(cfg.Timeout),
        nats.DisconnectErrHandler(func(nc *nats.Conn, err error) {
            if err != nil {
                // è®°å½•æ–­å¼€è¿æ¥é”™è¯¯
            }
        }),
        nats.ReconnectHandler(func(nc *nats.Conn) {
            // è®°å½•é‡è¿æˆåŠŸ
        }),
    }

    // è®¤è¯é…ç½®
    if cfg.Token != "" {
        opts = append(opts, nats.Token(cfg.Token))
    } else if cfg.Username != "" && cfg.Password != "" {
        opts = append(opts, nats.UserInfo(cfg.Username, cfg.Password))
    }

    conn, err := nats.Connect(cfg.URL, opts...)
    if err != nil {
        return nil, fmt.Errorf("failed to connect to NATS: %w", err)
    }

    return &Client{conn: conn}, nil
}

// Publish å‘å¸ƒæ¶ˆæ¯åˆ°æŒ‡å®šä¸»é¢˜
func (c *Client) Publish(subject string, data interface{}) error {
    var payload []byte
    var err error

    switch v := data.(type) {
    case []byte:
        payload = v
    case string:
        payload = []byte(v)
    default:
        payload, err = json.Marshal(data)
        if err != nil {
            return fmt.Errorf("failed to marshal message: %w", err)
        }
    }

    return c.conn.Publish(subject, payload)
}

// Subscribe è®¢é˜…ä¸»é¢˜
func (c *Client) Subscribe(subject string, handler func(*nats.Msg)) (*nats.Subscription, error) {
    return c.conn.Subscribe(subject, handler)
}

// QueueSubscribe é˜Ÿåˆ—è®¢é˜…ï¼ˆè´Ÿè½½å‡è¡¡ï¼‰
func (c *Client) QueueSubscribe(subject, queue string, handler func(*nats.Msg)) (*nats.Subscription, error) {
    return c.conn.QueueSubscribe(subject, queue, handler)
}

// Request å‘é€è¯·æ±‚å¹¶ç­‰å¾…å“åº”ï¼ˆRequest-Reply æ¨¡å¼ï¼‰
func (c *Client) Request(subject string, data interface{}, timeout time.Duration) (*nats.Msg, error) {
    var payload []byte
    var err error

    switch v := data.(type) {
    case []byte:
        payload = v
    case string:
        payload = []byte(v)
    default:
        payload, err = json.Marshal(data)
        if err != nil {
            return nil, fmt.Errorf("failed to marshal message: %w", err)
        }
    }

    msg, err := c.conn.Request(subject, payload, timeout)
    if err != nil {
        return nil, fmt.Errorf("failed to send request: %w", err)
    }

    return msg, nil
}

// Close å…³é—­è¿æ¥
func (c *Client) Close() {
    c.conn.Close()
}

// IsConnected æ£€æŸ¥è¿æ¥çŠ¶æ€
func (c *Client) IsConnected() bool {
    return c.conn.IsConnected()
}

// Stats è·å–è¿æ¥ç»Ÿè®¡ä¿¡æ¯
func (c *Client) Stats() nats.Stats {
    return c.conn.Stats()
}
```

### 1.3 ä½¿ç”¨ç¤ºä¾‹

```go
// åˆ›å»ºå®¢æˆ·ç«¯
client, err := nats.NewClient(nats.DefaultConfig())
if err != nil {
    log.Fatal(err)
}
defer client.Close()

// å‘å¸ƒæ¶ˆæ¯
err = client.Publish("user.created", map[string]interface{}{
    "user_id": 123,
    "name":    "Alice",
})

// è®¢é˜…æ¶ˆæ¯
sub, err := client.Subscribe("user.created", func(msg *nats.Msg) {
    var data map[string]interface{}
    json.Unmarshal(msg.Data, &data)
    log.Printf("Received: %+v", data)
})

// Request-Reply
reply, err := client.Request("user.get", "123", 5*time.Second)
```

---

## 2. gRPC å®Œå–„ç»†èŠ‚

### 2.1 æ–‡ä»¶ç»“æ„

```text
internal/interfaces/grpc/
â”œâ”€â”€ proto/
â”‚   â”œâ”€â”€ user.proto          # ç”¨æˆ·æœåŠ¡ Proto å®šä¹‰
â”‚   â”œâ”€â”€ health.proto        # å¥åº·æ£€æŸ¥ Proto å®šä¹‰
â”‚   â””â”€â”€ common.proto        # é€šç”¨æ¶ˆæ¯å®šä¹‰
â”œâ”€â”€ handlers/
â”‚   â”œâ”€â”€ user_handler.go     # ç”¨æˆ·æœåŠ¡ Handler
â”‚   â””â”€â”€ health_handler.go   # å¥åº·æ£€æŸ¥ Handler
â”œâ”€â”€ interceptors/
â”‚   â”œâ”€â”€ auth.go             # è®¤è¯æ‹¦æˆªå™¨
â”‚   â”œâ”€â”€ logging.go          # æ—¥å¿—æ‹¦æˆªå™¨
â”‚   â””â”€â”€ tracing.go          # è¿½è¸ªæ‹¦æˆªå™¨
â””â”€â”€ server.go               # gRPC æœåŠ¡å™¨é…ç½®
```

### 2.2 Proto æ–‡ä»¶å®šä¹‰

#### `proto/user.proto`

```protobuf
syntax = "proto3";

package user.v1;

option go_package = "github.com/yourusername/golang/internal/interfaces/grpc/proto/userpb";

import "google/protobuf/timestamp.proto";

// ç”¨æˆ·æœåŠ¡
service UserService {
  // è·å–ç”¨æˆ·
  rpc GetUser(GetUserRequest) returns (GetUserResponse);
  // åˆ›å»ºç”¨æˆ·
  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);
  // æ›´æ–°ç”¨æˆ·
  rpc UpdateUser(UpdateUserRequest) returns (UpdateUserResponse);
  // åˆ é™¤ç”¨æˆ·
  rpc DeleteUser(DeleteUserRequest) returns (DeleteUserResponse);
  // åˆ—å‡ºç”¨æˆ·ï¼ˆæµå¼ï¼‰
  rpc ListUsers(ListUsersRequest) returns (stream User);
}

// ç”¨æˆ·æ¶ˆæ¯
message User {
  string id = 1;
  string name = 2;
  string email = 3;
  google.protobuf.Timestamp created_at = 4;
  google.protobuf.Timestamp updated_at = 5;
}

// è¯·æ±‚æ¶ˆæ¯
message GetUserRequest {
  string id = 1;
}

message GetUserResponse {
  User user = 1;
}

message CreateUserRequest {
  string name = 1;
  string email = 2;
}

message CreateUserResponse {
  User user = 1;
}

message UpdateUserRequest {
  string id = 1;
  string name = 2;
  string email = 3;
}

message UpdateUserResponse {
  User user = 1;
}

message DeleteUserRequest {
  string id = 1;
}

message DeleteUserResponse {
  bool success = 1;
}

message ListUsersRequest {
  int32 page = 1;
  int32 page_size = 2;
}
```

#### `proto/health.proto`

```protobuf
syntax = "proto3";

package health.v1;

option go_package = "github.com/yourusername/golang/internal/interfaces/grpc/proto/healthpb";

import "google/protobuf/empty.proto";

// å¥åº·æ£€æŸ¥æœåŠ¡
service HealthService {
  rpc Check(google.protobuf.Empty) returns (HealthResponse);
}

message HealthResponse {
  enum Status {
    UNKNOWN = 0;
    SERVING = 1;
    NOT_SERVING = 2;
  }
  Status status = 1;
}
```

### 2.3 ä»£ç ç”Ÿæˆè„šæœ¬

#### `scripts/grpc/generate.sh`

```bash
#!/bin/bash

set -e

PROTO_DIR="internal/interfaces/grpc/proto"
OUTPUT_DIR="internal/interfaces/grpc/proto"

# ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
mkdir -p "$OUTPUT_DIR"

# ç”Ÿæˆ Go ä»£ç 
protoc \
  --go_out="$OUTPUT_DIR" \
  --go_opt=paths=source_relative \
  --go-grpc_out="$OUTPUT_DIR" \
  --go-grpc_opt=paths=source_relative \
  -I="$PROTO_DIR" \
  "$PROTO_DIR"/*.proto

echo "gRPC code generation completed"
```

### 2.4 Handler å®ç°

#### `handlers/user_handler.go`

```go
package handlers

import (
    "context"

    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"

    "github.com/yourusername/golang/internal/application/user"
    userpb "github.com/yourusername/golang/internal/interfaces/grpc/proto/userpb"
    "google.golang.org/protobuf/types/known/timestamppb"
)

type UserHandler struct {
    userpb.UnimplementedUserServiceServer
    service *user.Service
}

func NewUserHandler(service *user.Service) *UserHandler {
    return &UserHandler{
        service: service,
    }
}

func (h *UserHandler) GetUser(ctx context.Context, req *userpb.GetUserRequest) (*userpb.GetUserResponse, error) {
    u, err := h.service.GetByID(ctx, req.Id)
    if err != nil {
        return nil, status.Error(codes.NotFound, err.Error())
    }

    return &userpb.GetUserResponse{
        User: toProtoUser(u),
    }, nil
}

func (h *UserHandler) CreateUser(ctx context.Context, req *userpb.CreateUserRequest) (*userpb.CreateUserResponse, error) {
    u, err := h.service.Create(ctx, req.Name, req.Email)
    if err != nil {
        return nil, status.Error(codes.Internal, err.Error())
    }

    return &userpb.CreateUserResponse{
        User: toProtoUser(u),
    }, nil
}

// toProtoUser è½¬æ¢é¢†åŸŸæ¨¡å‹åˆ° Proto æ¶ˆæ¯
func toProtoUser(u *user.User) *userpb.User {
    return &userpb.User{
        Id:        u.ID,
        Name:      u.Name,
        Email:     u.Email,
        CreatedAt: timestamppb.New(u.CreatedAt),
        UpdatedAt: timestamppb.New(u.UpdatedAt),
    }
}
```

### 2.5 æ‹¦æˆªå™¨å®ç°

#### `interceptors/tracing.go`

```go
package interceptors

import (
    "context"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
    "google.golang.org/grpc"
    "google.golang.org/grpc/metadata"
    "google.golang.org/grpc/status"
)

// TracingUnaryInterceptor è¿½è¸ªæ‹¦æˆªå™¨
func TracingUnaryInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
    tracer := otel.Tracer("grpc")
    ctx, span := tracer.Start(ctx, info.FullMethod,
        trace.WithSpanKind(trace.SpanKindServer),
    )
    defer span.End()

    // ä» metadata ä¸­æå–è¿½è¸ªä¿¡æ¯
    md, ok := metadata.FromIncomingContext(ctx)
    if ok {
        // æå– TraceContext
        // ...
    }

    resp, err := handler(ctx, req)

    if err != nil {
        s, _ := status.FromError(err)
        span.SetStatus(codes.Error, s.Message())
        span.RecordError(err)
    } else {
        span.SetStatus(codes.Ok, "success")
    }

    span.SetAttributes(
        attribute.String("grpc.method", info.FullMethod),
        attribute.String("grpc.status", status.Code(err).String()),
    )

    return resp, err
}
```

---

## 3. DDD æ¡†æ¶æŠ½è±¡ç»†èŠ‚

### 3.1 æ–‡ä»¶ç»“æ„

```text
internal/domain/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ aggregate.go        # èšåˆæ ¹æŠ½è±¡
â”‚   â”œâ”€â”€ value_object.go      # å€¼å¯¹è±¡æŠ½è±¡
â”‚   â”œâ”€â”€ domain_event.go     # é¢†åŸŸäº‹ä»¶æŠ½è±¡
â”‚   â”œâ”€â”€ repository.go       # ä»“å‚¨æ¥å£
â”‚   â””â”€â”€ entity.go           # å®ä½“æŠ½è±¡
â”œâ”€â”€ events/
â”‚   â”œâ”€â”€ bus.go              # äº‹ä»¶æ€»çº¿
â”‚   â””â”€â”€ handler.go          # äº‹ä»¶å¤„ç†å™¨
â””â”€â”€ README.md
```

### 3.2 æ ¸å¿ƒæŠ½è±¡å®ç°

#### `core/aggregate.go`

```go
package core

import (
    "time"
    "github.com/google/uuid"
)

// AggregateRoot èšåˆæ ¹æ¥å£
type AggregateRoot interface {
    ID() string
    Version() int64
    CreatedAt() time.Time
    UpdatedAt() time.Time
    DomainEvents() []DomainEvent
    ClearDomainEvents()
    IncrementVersion()
}

// BaseAggregate èšåˆæ ¹åŸºç±»
type BaseAggregate struct {
    id           string
    version      int64
    createdAt    time.Time
    updatedAt    time.Time
    domainEvents []DomainEvent
}

func NewBaseAggregate() *BaseAggregate {
    now := time.Now()
    return &BaseAggregate{
        id:        uuid.New().String(),
        version:   1,
        createdAt: now,
        updatedAt: now,
    }
}

func (a *BaseAggregate) ID() string {
    return a.id
}

func (a *BaseAggregate) Version() int64 {
    return a.version
}

func (a *BaseAggregate) CreatedAt() time.Time {
    return a.createdAt
}

func (a *BaseAggregate) UpdatedAt() time.Time {
    return a.updatedAt
}

func (a *BaseAggregate) DomainEvents() []DomainEvent {
    return a.domainEvents
}

func (a *BaseAggregate) ClearDomainEvents() {
    a.domainEvents = nil
}

func (a *BaseAggregate) IncrementVersion() {
    a.version++
    a.updatedAt = time.Now()
}

func (a *BaseAggregate) AddDomainEvent(event DomainEvent) {
    a.domainEvents = append(a.domainEvents, event)
    a.IncrementVersion()
}
```

#### `core/domain_event.go`

```go
package core

import (
    "time"
    "github.com/google/uuid"
)

// DomainEvent é¢†åŸŸäº‹ä»¶æ¥å£
type DomainEvent interface {
    EventID() string
    EventType() string
    AggregateID() string
    OccurredAt() time.Time
    Version() int64
}

// BaseDomainEvent é¢†åŸŸäº‹ä»¶åŸºç±»
type BaseDomainEvent struct {
    eventID     string
    eventType   string
    aggregateID string
    occurredAt  time.Time
    version     int64
}

func NewBaseDomainEvent(aggregateID string, eventType string) *BaseDomainEvent {
    return &BaseDomainEvent{
        eventID:     uuid.New().String(),
        eventType:   eventType,
        aggregateID: aggregateID,
        occurredAt:  time.Now(),
        version:     1,
    }
}

func (e *BaseDomainEvent) EventID() string {
    return e.eventID
}

func (e *BaseDomainEvent) EventType() string {
    return e.eventType
}

func (e *BaseDomainEvent) AggregateID() string {
    return e.aggregateID
}

func (e *BaseDomainEvent) OccurredAt() time.Time {
    return e.occurredAt
}

func (e *BaseDomainEvent) Version() int64 {
    return e.version
}
```

#### `core/repository.go`

```go
package core

import "context"

// Repository é€šç”¨ä»“å‚¨æ¥å£
type Repository[T AggregateRoot] interface {
    FindByID(ctx context.Context, id string) (T, error)
    FindAll(ctx context.Context) ([]T, error)
    Save(ctx context.Context, aggregate T) error
    Delete(ctx context.Context, id string) error
    Exists(ctx context.Context, id string) (bool, error)
}
```

#### `events/bus.go`

```go
package events

import (
    "context"
    "sync"
    "github.com/yourusername/golang/internal/domain/core"
)

// EventHandler äº‹ä»¶å¤„ç†å™¨æ¥å£
type EventHandler interface {
    Handle(ctx context.Context, event core.DomainEvent) error
    EventType() string
}

// EventBus äº‹ä»¶æ€»çº¿
type EventBus struct {
    handlers map[string][]EventHandler
    mu       sync.RWMutex
}

func NewEventBus() *EventBus {
    return &EventBus{
        handlers: make(map[string][]EventHandler),
    }
}

// Subscribe è®¢é˜…äº‹ä»¶
func (b *EventBus) Subscribe(handler EventHandler) {
    b.mu.Lock()
    defer b.mu.Unlock()

    eventType := handler.EventType()
    b.handlers[eventType] = append(b.handlers[eventType], handler)
}

// Publish å‘å¸ƒäº‹ä»¶
func (b *EventBus) Publish(ctx context.Context, event core.DomainEvent) error {
    b.mu.RLock()
    defer b.mu.RUnlock()

    handlers := b.handlers[event.EventType()]
    for _, handler := range handlers {
        if err := handler.Handle(ctx, event); err != nil {
            return err
        }
    }

    return nil
}
```

---

## 4. ä»£ç ç”Ÿæˆå·¥å…·é“¾ç»†èŠ‚

### 4.1 Makefile æ›´æ–°

```makefile
# gRPC ä»£ç ç”Ÿæˆ
.PHONY: generate-grpc
generate-grpc:
 @echo "Generating gRPC code..."
 @bash scripts/grpc/generate.sh

# OpenAPI ä»£ç ç”Ÿæˆ
.PHONY: generate-openapi
generate-openapi:
 @echo "Generating OpenAPI code..."
 @bash scripts/api/generate-openapi.sh

# AsyncAPI ä»£ç ç”Ÿæˆ
.PHONY: generate-asyncapi
generate-asyncapi:
 @echo "Generating AsyncAPI code..."
 @bash scripts/api/generate-asyncapi.sh

# GraphQL ä»£ç ç”Ÿæˆ
.PHONY: generate-graphql
generate-graphql:
 @echo "Generating GraphQL code..."
 @bash scripts/api/generate-graphql.sh

# ç”Ÿæˆæ‰€æœ‰ä»£ç 
.PHONY: generate-all
generate-all: generate-grpc generate-openapi generate-asyncapi generate-graphql
 @echo "All code generation completed"
```

### 4.2 OpenAPI ä»£ç ç”Ÿæˆè„šæœ¬

#### `scripts/api/generate-openapi.sh`

```bash
#!/bin/bash

set -e

OPENAPI_SPEC="api/openapi/openapi.yaml"
OUTPUT_DIR="internal/interfaces/http/openapi"

# ä½¿ç”¨ oapi-codegen ç”Ÿæˆä»£ç 
oapi-codegen \
  -generate types,server,chi-server,spec \
  -package openapi \
  -o "${OUTPUT_DIR}/server.gen.go" \
  "${OPENAPI_SPEC}"

echo "OpenAPI code generation completed"
```

---

## 5. ç»Ÿä¸€æ¥å£æŠ½è±¡ç»†èŠ‚

### 5.1 æ¶ˆæ¯é˜Ÿåˆ—ç»Ÿä¸€æ¥å£

#### `internal/infrastructure/messaging/interface.go`

```go
package messaging

import "context"

// MessageHandler æ¶ˆæ¯å¤„ç†å™¨
type MessageHandler func(ctx context.Context, topic string, payload []byte) error

// MessageQueue æ¶ˆæ¯é˜Ÿåˆ—ç»Ÿä¸€æ¥å£
type MessageQueue interface {
    // Publish å‘å¸ƒæ¶ˆæ¯
    Publish(ctx context.Context, topic string, message interface{}) error

    // Subscribe è®¢é˜…ä¸»é¢˜
    Subscribe(ctx context.Context, topic string, handler MessageHandler) error

    // QueueSubscribe é˜Ÿåˆ—è®¢é˜…ï¼ˆè´Ÿè½½å‡è¡¡ï¼‰
    QueueSubscribe(ctx context.Context, topic, queue string, handler MessageHandler) error

    // Close å…³é—­è¿æ¥
    Close() error

    // IsConnected æ£€æŸ¥è¿æ¥çŠ¶æ€
    IsConnected() bool
}
```

### 5.2 é€‚é…å™¨å®ç°

#### `internal/infrastructure/messaging/kafka/adapter.go`

```go
package kafka

import (
    "context"
    "github.com/yourusername/golang/internal/infrastructure/messaging"
)

// Adapter Kafka é€‚é…å™¨
type Adapter struct {
    producer *Producer
    consumer *Consumer
}

func NewAdapter(producer *Producer, consumer *Consumer) messaging.MessageQueue {
    return &Adapter{
        producer: producer,
        consumer: consumer,
    }
}

func (a *Adapter) Publish(ctx context.Context, topic string, message interface{}) error {
    return a.producer.SendMessage(ctx, topic, "", message)
}

func (a *Adapter) Subscribe(ctx context.Context, topic string, handler messaging.MessageHandler) error {
    return a.consumer.Consume(ctx, topic, func(msg *sarama.ConsumerMessage) error {
        return handler(ctx, topic, msg.Value)
    })
}

func (a *Adapter) QueueSubscribe(ctx context.Context, topic, queue string, handler messaging.MessageHandler) error {
    // Kafka ä½¿ç”¨ Consumer Group å®ç°é˜Ÿåˆ—è®¢é˜…
    return a.Subscribe(ctx, topic, handler)
}

func (a *Adapter) Close() error {
    // å…³é—­ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…
    return nil
}

func (a *Adapter) IsConnected() bool {
    return true // ç®€åŒ–å®ç°
}
```

---

## 6. å®æ–½æ£€æŸ¥æ¸…å•

### 6.1 NATS å®ç°æ£€æŸ¥æ¸…å•

- [ ] åˆ›å»º `internal/infrastructure/messaging/nats/` ç›®å½•
- [ ] å®ç° `client.go`
- [ ] å®ç° `config.go`
- [ ] æ·»åŠ ä¾èµ–åˆ° `go.mod`
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•
- [ ] ç¼–å†™é›†æˆæµ‹è¯•
- [ ] æ›´æ–°æ–‡æ¡£
- [ ] æ·»åŠ ä½¿ç”¨ç¤ºä¾‹

### 6.2 gRPC å®Œå–„æ£€æŸ¥æ¸…å•

- [ ] åˆ›å»º `internal/interfaces/grpc/proto/` ç›®å½•
- [ ] å®šä¹‰ `user.proto`
- [ ] å®šä¹‰ `health.proto`
- [ ] åˆ›å»ºä»£ç ç”Ÿæˆè„šæœ¬
- [ ] å®ç° Handler
- [ ] å®ç°æ‹¦æˆªå™¨
- [ ] æ›´æ–° `cmd/grpc-server/main.go`
- [ ] ç¼–å†™æµ‹è¯•
- [ ] æ›´æ–°æ–‡æ¡£

### 6.3 DDD æ¡†æ¶æ£€æŸ¥æ¸…å•

- [ ] åˆ›å»º `internal/domain/core/` ç›®å½•
- [ ] å®ç°èšåˆæ ¹æŠ½è±¡
- [ ] å®ç°å€¼å¯¹è±¡æŠ½è±¡
- [ ] å®ç°é¢†åŸŸäº‹ä»¶æŠ½è±¡
- [ ] å®ç°ä»“å‚¨æ¥å£
- [ ] å®ç°äº‹ä»¶æ€»çº¿
- [ ] ç¼–å†™ä½¿ç”¨ç¤ºä¾‹
- [ ] æ›´æ–°æ–‡æ¡£

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [æŠ€æœ¯æ ˆå¯¹æ ‡åˆ†æ](00-æŠ€æœ¯æ ˆå¯¹æ ‡åˆ†æä¸æ”¹è¿›è®¡åˆ’.md)
- [é¡¹ç›®ç»“æ„è§„èŒƒ](00-é¡¹ç›®ç»“æ„é‡æ„è®¡åˆ’.md)
- [æ¶æ„æ–‡æ¡£](architecture/README.md)

---

**æœ€åæ›´æ–°**: 2025-01-XX
