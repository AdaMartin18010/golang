# 常见性能陷阱

<!-- TOC START -->
- [5.1 常见性能陷阱](#51-常见性能陷阱)
  - [5.1.1 📚 **理论分析**](#511--理论分析)
  - [5.1.2 💻 **典型陷阱与代码示例**](#512--典型陷阱与代码示例)
    - [5.1.2.1 **切片扩容导致性能抖动**](#5121-切片扩容导致性能抖动)
    - [5.1.2.2 **map并发写导致崩溃**](#5122-map并发写导致崩溃)
    - [5.1.2.3 **Goroutine泄漏**](#5123-goroutine泄漏)
  - [5.1.3 🛠️ **分析与排查方法**](#513-️-分析与排查方法)
  - [5.1.4 🎯 **最佳实践**](#514--最佳实践)
  - [5.1.5 🔍 **常见问题**](#515--常见问题)
  - [5.1.6 📚 **扩展阅读**](#516--扩展阅读)
<!-- TOC END -->

## 📚 **理论分析**

- 性能陷阱常因误用语言特性、库、并发模型、I/O等导致。
- 典型陷阱：切片扩容、map并发写、Goroutine泄漏、过度GC、锁粒度过大、I/O阻塞等。

## 💻 **典型陷阱与代码示例**

### **切片扩容导致性能抖动**

```go
s := []int{}
for i := 0; i < 1e6; i++ {
    s = append(s, i) // 未预分配容量，频繁扩容
}

```

### **map并发写导致崩溃**

```go
m := make(map[int]int)
go func() { m[1] = 1 }() // 并发写，未加锁，panic

```

### **Goroutine泄漏**

```go
func leak() {
    ch := make(chan int)
    go func() { ch <- 1 }() // 未消费，Goroutine阻塞泄漏
}

```

## 🛠️ **分析与排查方法**

- 使用pprof、race detector、go tool trace定位问题
- 代码审查，关注资源释放与并发安全

## 🎯 **最佳实践**

- 预分配切片容量
- map并发写用sync.Map或加锁
- 控制Goroutine生命周期，及时回收
- 监控GC与内存分配
- 定期性能回归测试

## 🔍 **常见问题**

- Q: map并发写如何安全？
  A: 使用sync.Map或加锁
- Q: 如何避免Goroutine泄漏？
  A: 保证通道有消费方，及时关闭

## 📚 **扩展阅读**

- [Go性能陷阱与优化](https://geektutu.com/post/hpg-golang-trap.html)
- [Go官方FAQ](https://golang.org/doc/faq)

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025年10月20日  
**文档状态**: 完成  
**适用版本**: Go 1.25.3+
