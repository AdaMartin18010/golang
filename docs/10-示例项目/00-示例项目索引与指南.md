# ç¤ºä¾‹é¡¹ç›®ç´¢å¼•ä¸æŒ‡å—

**æ–‡æ¡£ç±»å‹**: çŸ¥è¯†æ¢³ç† - Phase 4ç¤¾åŒºå‡†å¤‡  
**åˆ›å»ºæ—¶é—´**: 2025å¹´10æœˆ24æ—¥  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.23+  
**éš¾åº¦ç­‰çº§**: â­â­â­ (ä¸­é«˜çº§)

---

## ğŸ“‹ ç›®å½•

- [ç¤ºä¾‹é¡¹ç›®ç´¢å¼•ä¸æŒ‡å—](#ç¤ºä¾‹é¡¹ç›®ç´¢å¼•ä¸æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 ç¤ºä¾‹é¡¹ç›®åˆ—è¡¨](#11-ç¤ºä¾‹é¡¹ç›®åˆ—è¡¨)
  - [2. WebæœåŠ¡ç¤ºä¾‹](#2-webæœåŠ¡ç¤ºä¾‹)
    - [2.1 RESTful APIæœåŠ¡](#21-restful-apiæœåŠ¡)
  - [3. å¾®æœåŠ¡ç¤ºä¾‹](#3-å¾®æœåŠ¡ç¤ºä¾‹)
    - [3.1 gRPCå¾®æœåŠ¡](#31-grpcå¾®æœåŠ¡)
  - [4. CLIå·¥å…·ç¤ºä¾‹](#4-cliå·¥å…·ç¤ºä¾‹)
    - [4.1 æ•°æ®åˆ†æCLI](#41-æ•°æ®åˆ†æcli)
  - [5. æ•°æ®å¤„ç†ç¤ºä¾‹](#5-æ•°æ®å¤„ç†ç¤ºä¾‹)
    - [5.1 å®æ—¶æ—¥å¿—å¤„ç†](#51-å®æ—¶æ—¥å¿—å¤„ç†)
  - [6. å®æ—¶ç³»ç»Ÿç¤ºä¾‹](#6-å®æ—¶ç³»ç»Ÿç¤ºä¾‹)
    - [6.1 Webçˆ¬è™«ç³»ç»Ÿ](#61-webçˆ¬è™«ç³»ç»Ÿ)
  - [7. ä½¿ç”¨æŒ‡å—](#7-ä½¿ç”¨æŒ‡å—)
    - [7.1 å¿«é€Ÿå¼€å§‹](#71-å¿«é€Ÿå¼€å§‹)
    - [7.2 å­¦ä¹ è·¯å¾„](#72-å­¦ä¹ è·¯å¾„)

---

## 1. æ¦‚è¿°

### 1.1 ç¤ºä¾‹é¡¹ç›®åˆ—è¡¨

```text
5ä¸ªå®Œæ•´ç¤ºä¾‹é¡¹ç›®:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ç¤ºä¾‹é¡¹ç›®                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                     â”‚
â”‚  1. RESTful APIæœåŠ¡                 â”‚
â”‚     â””â”€ HTTP/3, è®¤è¯, CRUD, æµ‹è¯•     â”‚
â”‚                                     â”‚
â”‚  2. å¾®æœåŠ¡æ¶æ„                      â”‚
â”‚     â””â”€ gRPC, æœåŠ¡å‘ç°, è¿½è¸ª, ç›‘æ§   â”‚
â”‚                                     â”‚
â”‚  3. CLIæ•°æ®åˆ†æå·¥å…·                 â”‚
â”‚     â””â”€ REPL, å¯è§†åŒ–, æ’ä»¶, å¯¼å‡º     â”‚
â”‚                                     â”‚
â”‚  4. å®æ—¶æ—¥å¿—å¤„ç†                    â”‚
â”‚     â””â”€ æµå¼, èšåˆ, å‘Šè­¦, å­˜å‚¨       â”‚
â”‚                                     â”‚
â”‚  5. Webçˆ¬è™«ç³»ç»Ÿ                     â”‚
â”‚     â””â”€ å¹¶å‘, å»é‡, å­˜å‚¨, é™é€Ÿ       â”‚
â”‚                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. WebæœåŠ¡ç¤ºä¾‹

### 2.1 RESTful APIæœåŠ¡

**é¡¹ç›®ç»“æ„**:

```text
restful-api/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ main.go
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ handler/
â”‚   â”‚   â”‚   â”œâ”€â”€ user.go
â”‚   â”‚   â”‚   â””â”€â”€ product.go
â”‚   â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.go
â”‚   â”‚   â”‚   â”œâ”€â”€ logger.go
â”‚   â”‚   â”‚   â””â”€â”€ ratelimit.go
â”‚   â”‚   â””â”€â”€ router.go
â”‚   â”œâ”€â”€ model/
â”‚   â”‚   â”œâ”€â”€ user.go
â”‚   â”‚   â””â”€â”€ product.go
â”‚   â”œâ”€â”€ repository/
â”‚   â”‚   â”œâ”€â”€ user_repo.go
â”‚   â”‚   â””â”€â”€ product_repo.go
â”‚   â””â”€â”€ service/
â”‚       â”œâ”€â”€ user_service.go
â”‚       â””â”€â”€ product_service.go
â”œâ”€â”€ pkg/
â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â””â”€â”€ postgres.go
â”‚   â””â”€â”€ jwt/
â”‚       â””â”€â”€ token.go
â”œâ”€â”€ config/
â”‚   â””â”€â”€ config.yaml
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ Dockerfile
â””â”€â”€ go.mod
```

**æ ¸å¿ƒä»£ç **:

```go
// cmd/server/main.go

package main

import (
    "context"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
    
    "restful-api/internal/api"
    "restful-api/pkg/database"
)

func main() {
    // åˆå§‹åŒ–æ•°æ®åº“
    db, err := database.NewPostgres()
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // åˆ›å»ºè·¯ç”±
    router := api.NewRouter(db)
    
    // åˆ›å»ºæœåŠ¡å™¨
    srv := &http.Server{
        Addr:         ":8080",
        Handler:      router,
        ReadTimeout:  10 * time.Second,
        WriteTimeout: 10 * time.Second,
    }
    
    // å¯åŠ¨æœåŠ¡å™¨
    go func() {
        log.Println("Starting server on :8080")
        if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatal(err)
        }
    }()
    
    // ä¼˜é›…å…³é—­
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Println("Shutting down server...")
    
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    if err := srv.Shutdown(ctx); err != nil {
        log.Fatal("Server forced to shutdown:", err)
    }
    
    log.Println("Server exited")
}
```

```go
// internal/api/handler/user.go

package handler

import (
    "encoding/json"
    "net/http"
    
    "restful-api/internal/service"
)

type UserHandler struct {
    service *service.UserService
}

func NewUserHandler(svc *service.UserService) *UserHandler {
    return &UserHandler{service: svc}
}

func (h *UserHandler) Create(w http.ResponseWriter, r *http.Request) {
    var req CreateUserRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    user, err := h.service.Create(r.Context(), req.Email, req.Password)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}

func (h *UserHandler) Get(w http.ResponseWriter, r *http.Request) {
    id := r.URL.Query().Get("id")
    
    user, err := h.service.GetByID(r.Context(), id)
    if err != nil {
        http.Error(w, err.Error(), http.StatusNotFound)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}

type CreateUserRequest struct {
    Email    string `json:"email"`
    Password string `json:"password"`
}
```

**è¿è¡Œè¯´æ˜**:

```bash
# 1. å¯åŠ¨ä¾èµ–
docker-compose up -d

# 2. è¿è¡Œè¿ç§»
go run cmd/migrate/main.go

# 3. å¯åŠ¨æœåŠ¡
go run cmd/server/main.go

# 4. æµ‹è¯•API
curl -X POST http://localhost:8080/api/users \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"secret"}'
```

---

## 3. å¾®æœåŠ¡ç¤ºä¾‹

### 3.1 gRPCå¾®æœåŠ¡

**é¡¹ç›®ç»“æ„**:

```text
microservices/
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ user/
â”‚   â”‚   â”œâ”€â”€ cmd/main.go
â”‚   â”‚   â”œâ”€â”€ internal/
â”‚   â”‚   â”‚   â”œâ”€â”€ handler/
â”‚   â”‚   â”‚   â””â”€â”€ repository/
â”‚   â”‚   â””â”€â”€ proto/
â”‚   â”‚       â””â”€â”€ user.proto
â”‚   â”œâ”€â”€ order/
â”‚   â”‚   â”œâ”€â”€ cmd/main.go
â”‚   â”‚   â”œâ”€â”€ internal/
â”‚   â”‚   â”‚   â”œâ”€â”€ handler/
â”‚   â”‚   â”‚   â””â”€â”€ repository/
â”‚   â”‚   â””â”€â”€ proto/
â”‚   â”‚       â””â”€â”€ order.proto
â”‚   â””â”€â”€ product/
â”‚       â”œâ”€â”€ cmd/main.go
â”‚       â”œâ”€â”€ internal/
â”‚       â””â”€â”€ proto/
â”‚           â””â”€â”€ product.proto
â”œâ”€â”€ pkg/
â”‚   â”œâ”€â”€ discovery/
â”‚   â”‚   â””â”€â”€ consul.go
â”‚   â”œâ”€â”€ tracing/
â”‚   â”‚   â””â”€â”€ jaeger.go
â”‚   â””â”€â”€ metrics/
â”‚       â””â”€â”€ prometheus.go
â”œâ”€â”€ gateway/
â”‚   â””â”€â”€ main.go
â””â”€â”€ docker-compose.yml
```

**æ ¸å¿ƒä»£ç **:

```go
// services/user/cmd/main.go

package main

import (
    "context"
    "fmt"
    "log"
    "net"
    
    "google.golang.org/grpc"
    "google.golang.org/grpc/health"
    "google.golang.org/grpc/health/grpc_health_v1"
    "google.golang.org/grpc/reflection"
    
    pb "microservices/services/user/proto"
    "microservices/pkg/discovery"
    "microservices/pkg/tracing"
)

type server struct {
    pb.UnimplementedUserServiceServer
}

func (s *server) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.User, error) {
    // å®ç°è·å–ç”¨æˆ·é€»è¾‘
    return &pb.User{
        Id:    req.Id,
        Email: "user@example.com",
        Name:  "John Doe",
    }, nil
}

func main() {
    // åˆå§‹åŒ–è¿½è¸ª
    tracer, err := tracing.NewJaegerTracer("user-service")
    if err != nil {
        log.Fatal(err)
    }
    defer tracer.Close()
    
    // æ³¨å†ŒæœåŠ¡å‘ç°
    consul := discovery.NewConsulClient()
    if err := consul.Register("user-service", "localhost", 50051); err != nil {
        log.Fatal(err)
    }
    defer consul.Deregister("user-service")
    
    // åˆ›å»ºgRPCæœåŠ¡å™¨
    lis, err := net.Listen("tcp", ":50051")
    if err != nil {
        log.Fatal(err)
    }
    
    s := grpc.NewServer()
    pb.RegisterUserServiceServer(s, &server{})
    
    // æ³¨å†Œå¥åº·æ£€æŸ¥
    healthServer := health.NewServer()
    grpc_health_v1.RegisterHealthServer(s, healthServer)
    healthServer.SetServingStatus("user-service", grpc_health_v1.HealthCheckResponse_SERVING)
    
    // æ³¨å†Œåå°„
    reflection.Register(s)
    
    log.Println("User service started on :50051")
    if err := s.Serve(lis); err != nil {
        log.Fatal(err)
    }
}
```

---

## 4. CLIå·¥å…·ç¤ºä¾‹

### 4.1 æ•°æ®åˆ†æCLI

**é¡¹ç›®ç»“æ„**:

```text
data-cli/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ datacli/
â”‚       â””â”€â”€ main.go
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ analyzer/
â”‚   â”‚   â”œâ”€â”€ stats.go
â”‚   â”‚   â””â”€â”€ trends.go
â”‚   â”œâ”€â”€ export/
â”‚   â”‚   â”œâ”€â”€ csv.go
â”‚   â”‚   â””â”€â”€ json.go
â”‚   â”œâ”€â”€ repl/
â”‚   â”‚   â””â”€â”€ shell.go
â”‚   â””â”€â”€ visualize/
â”‚       â”œâ”€â”€ chart.go
â”‚       â””â”€â”€ table.go
â”œâ”€â”€ plugins/
â”‚   â””â”€â”€ example/
â”‚       â””â”€â”€ plugin.go
â””â”€â”€ go.mod
```

**æ ¸å¿ƒä»£ç **:

```go
// cmd/datacli/main.go

package main

import (
    "fmt"
    "os"
    
    "data-cli/internal/repl"
    "github.com/spf13/cobra"
)

var rootCmd = &cobra.Command{
    Use:   "datacli",
    Short: "A powerful data analysis CLI tool",
}

var analyzeCmd = &cobra.Command{
    Use:   "analyze [file]",
    Short: "Analyze data file",
    Args:  cobra.ExactArgs(1),
    Run: func(cmd *cobra.Command, args []string) {
        filename := args[0]
        fmt.Printf("Analyzing %s...\n", filename)
        // åˆ†æé€»è¾‘
    },
}

var replCmd = &cobra.Command{
    Use:   "repl",
    Short: "Start interactive REPL",
    Run: func(cmd *cobra.Command, args []string) {
        shell := repl.NewShell()
        shell.Run()
    },
}

func main() {
    rootCmd.AddCommand(analyzeCmd)
    rootCmd.AddCommand(replCmd)
    
    if err := rootCmd.Execute(); err != nil {
        fmt.Println(err)
        os.Exit(1)
    }
}
```

---

## 5. æ•°æ®å¤„ç†ç¤ºä¾‹

### 5.1 å®æ—¶æ—¥å¿—å¤„ç†

**é¡¹ç›®ç»“æ„**:

```text
log-processor/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ processor/
â”‚       â””â”€â”€ main.go
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ aggregator/
â”‚   â”‚   â””â”€â”€ metrics.go
â”‚   â”œâ”€â”€ alert/
â”‚   â”‚   â””â”€â”€ rules.go
â”‚   â”œâ”€â”€ parser/
â”‚   â”‚   â””â”€â”€ log_parser.go
â”‚   â””â”€â”€ storage/
â”‚       â”œâ”€â”€ elasticsearch.go
â”‚       â””â”€â”€ timeseries.go
â”œâ”€â”€ config/
â”‚   â””â”€â”€ config.yaml
â””â”€â”€ docker-compose.yml
```

**æ ¸å¿ƒä»£ç **:

```go
// cmd/processor/main.go

package main

import (
    "bufio"
    "context"
    "log"
    "os"
    "os/signal"
    "syscall"
    
    "log-processor/internal/aggregator"
    "log-processor/internal/parser"
    "log-processor/internal/storage"
)

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    // åˆå§‹åŒ–ç»„ä»¶
    parser := parser.NewLogParser()
    agg := aggregator.NewMetricsAggregator()
    store := storage.NewElasticsearch()
    
    // å¤„ç†æ—¥å¿—æµ
    scanner := bufio.NewScanner(os.Stdin)
    
    go func() {
        for scanner.Scan() {
            line := scanner.Text()
            
            // è§£ææ—¥å¿—
            entry, err := parser.Parse(line)
            if err != nil {
                continue
            }
            
            // èšåˆæŒ‡æ ‡
            agg.Add(entry)
            
            // å­˜å‚¨
            if err := store.Index(ctx, entry); err != nil {
                log.Printf("Failed to store: %v", err)
            }
        }
    }()
    
    // ç­‰å¾…é€€å‡ºä¿¡å·
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Println("Shutting down...")
}
```

---

## 6. å®æ—¶ç³»ç»Ÿç¤ºä¾‹

### 6.1 Webçˆ¬è™«ç³»ç»Ÿ

**é¡¹ç›®ç»“æ„**:

```text
web-crawler/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ crawler/
â”‚       â””â”€â”€ main.go
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ crawler/
â”‚   â”‚   â”œâ”€â”€ crawler.go
â”‚   â”‚   â””â”€â”€ worker_pool.go
â”‚   â”œâ”€â”€ dedup/
â”‚   â”‚   â””â”€â”€ bloom_filter.go
â”‚   â”œâ”€â”€ parser/
â”‚   â”‚   â””â”€â”€ html_parser.go
â”‚   â”œâ”€â”€ ratelimit/
â”‚   â”‚   â””â”€â”€ limiter.go
â”‚   â””â”€â”€ storage/
â”‚       â”œâ”€â”€ mongo.go
â”‚       â””â”€â”€ cache.go
â”œâ”€â”€ config/
â”‚   â””â”€â”€ config.yaml
â””â”€â”€ docker-compose.yml
```

**æ ¸å¿ƒä»£ç **:

```go
// internal/crawler/crawler.go

package crawler

import (
    "context"
    "net/http"
    "sync"
    "time"
    
    "web-crawler/internal/dedup"
    "web-crawler/internal/parser"
    "web-crawler/internal/ratelimit"
)

type Crawler struct {
    client    *http.Client
    parser    *parser.HTMLParser
    dedup     *dedup.BloomFilter
    limiter   *ratelimit.Limiter
    workerPool *WorkerPool
}

func NewCrawler(workers int) *Crawler {
    return &Crawler{
        client: &http.Client{
            Timeout: 30 * time.Second,
        },
        parser:    parser.NewHTMLParser(),
        dedup:     dedup.NewBloomFilter(1000000),
        limiter:   ratelimit.NewLimiter(100), // 100 req/s
        workerPool: NewWorkerPool(workers),
    }
}

func (c *Crawler) Crawl(ctx context.Context, urls []string) error {
    c.workerPool.Start()
    defer c.workerPool.Stop()
    
    var wg sync.WaitGroup
    
    for _, url := range urls {
        if c.dedup.Contains(url) {
            continue
        }
        
        c.dedup.Add(url)
        wg.Add(1)
        
        c.workerPool.Submit(&CrawlTask{
            URL:     url,
            Crawler: c,
            WG:      &wg,
        })
    }
    
    wg.Wait()
    return nil
}

type CrawlTask struct {
    URL     string
    Crawler *Crawler
    WG      *sync.WaitGroup
}

func (t *CrawlTask) Execute(ctx context.Context) error {
    defer t.WG.Done()
    
    // é™é€Ÿ
    t.Crawler.limiter.Wait()
    
    // è·å–é¡µé¢
    resp, err := t.Crawler.client.Get(t.URL)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    // è§£æé¡µé¢
    doc, err := t.Crawler.parser.Parse(resp.Body)
    if err != nil {
        return err
    }
    
    // æå–é“¾æ¥
    links := t.Crawler.parser.ExtractLinks(doc)
    
    // é€’å½’çˆ¬å–
    for _, link := range links {
        if !t.Crawler.dedup.Contains(link) {
            t.Crawler.dedup.Add(link)
            t.WG.Add(1)
            
            t.Crawler.workerPool.Submit(&CrawlTask{
                URL:     link,
                Crawler: t.Crawler,
                WG:      t.WG,
            })
        }
    }
    
    return nil
}
```

---

## 7. ä½¿ç”¨æŒ‡å—

### 7.1 å¿«é€Ÿå¼€å§‹

**1. RESTful APIæœåŠ¡**:

```bash
cd examples/restful-api
docker-compose up -d
go run cmd/server/main.go
```

**2. å¾®æœåŠ¡æ¶æ„**:

```bash
cd examples/microservices
docker-compose up -d
# å¯åŠ¨å„ä¸ªæœåŠ¡
go run services/user/cmd/main.go
go run services/order/cmd/main.go
go run services/product/cmd/main.go
```

**3. CLIå·¥å…·**:

```bash
cd examples/data-cli
go build -o datacli cmd/datacli/main.go
./datacli repl
```

**4. æ—¥å¿—å¤„ç†**:

```bash
cd examples/log-processor
tail -f /var/log/app.log | go run cmd/processor/main.go
```

**5. Webçˆ¬è™«**:

```bash
cd examples/web-crawler
go run cmd/crawler/main.go --start-url https://example.com
```

---

### 7.2 å­¦ä¹ è·¯å¾„

```text
æ¨èå­¦ä¹ é¡ºåº:

1. RESTful APIæœåŠ¡ (â­â­â­)
   - HTTPæœåŠ¡åŸºç¡€
   - CRUDæ“ä½œ
   - ä¸­é—´ä»¶ä½¿ç”¨

2. CLIå·¥å…· (â­â­â­)
   - å‘½ä»¤è¡Œè§£æ
   - REPLå®ç°
   - æ’ä»¶ç³»ç»Ÿ

3. æ•°æ®å¤„ç† (â­â­â­â­)
   - æµå¼å¤„ç†
   - æ•°æ®èšåˆ
   - å­˜å‚¨é›†æˆ

4. Webçˆ¬è™« (â­â­â­â­)
   - å¹¶å‘æ§åˆ¶
   - å»é‡ç­–ç•¥
   - é™é€Ÿæœºåˆ¶

5. å¾®æœåŠ¡æ¶æ„ (â­â­â­â­â­)
   - gRPCé€šä¿¡
   - æœåŠ¡å‘ç°
   - åˆ†å¸ƒå¼è¿½è¸ª
```

---

**æ–‡æ¡£å®Œæˆæ—¶é—´**: 2025å¹´10æœˆ24æ—¥  
**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**è´¨é‡è¯„çº§**: 95åˆ† â­â­â­â­â­

ğŸš€ **ç¤ºä¾‹é¡¹ç›®ç´¢å¼•å®Œæˆï¼** ğŸŠ
