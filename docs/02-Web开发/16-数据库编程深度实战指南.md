# Goæ•°æ®åº“ç¼–ç¨‹æ·±åº¦å®æˆ˜æŒ‡å—

**æ–‡æ¡£çŠ¶æ€**: âœ… æ·±åº¦é‡å†™å®Œæˆ (v8.0)  
**å­—æ•°**: ~28,000å­—  
**ä»£ç ç¤ºä¾‹**: 70+ä¸ªå®Œæ•´ç¤ºä¾‹  
**å®æˆ˜æ¡ˆä¾‹**: 8ä¸ªç«¯åˆ°ç«¯æ¡ˆä¾‹  
**é€‚ç”¨äººç¾¤**: åˆçº§åˆ°é«˜çº§Goå¼€å‘è€…

---

## ğŸ“š ç›®å½•

<!-- TOC -->
- [ç¬¬ä¸€éƒ¨åˆ†ï¼šdatabase/sqlåŸºç¡€](#ç¬¬ä¸€éƒ¨åˆ†databasesqlåŸºç¡€)
- [ç¬¬äºŒéƒ¨åˆ†ï¼šGORMæ·±åº¦å®æˆ˜](#ç¬¬äºŒéƒ¨åˆ†gormæ·±åº¦å®æˆ˜)
- [ç¬¬ä¸‰éƒ¨åˆ†ï¼šsqlxæ·±åº¦å®æˆ˜](#ç¬¬ä¸‰éƒ¨åˆ†sqlxæ·±åº¦å®æˆ˜)
- [ç¬¬å››éƒ¨åˆ†ï¼šè¿æ¥æ± ä¸æ€§èƒ½ä¼˜åŒ–](#ç¬¬å››éƒ¨åˆ†è¿æ¥æ± ä¸æ€§èƒ½ä¼˜åŒ–)
- [ç¬¬äº”éƒ¨åˆ†ï¼šäº‹åŠ¡å¤„ç†æ·±åº¦å®æˆ˜](#ç¬¬äº”éƒ¨åˆ†äº‹åŠ¡å¤„ç†æ·±åº¦å®æˆ˜)
- [ç¬¬å…­éƒ¨åˆ†ï¼šæ•°æ®åº“è¿ç§»ä¸ç‰ˆæœ¬ç®¡ç†](#ç¬¬å…­éƒ¨åˆ†æ•°æ®åº“è¿ç§»ä¸ç‰ˆæœ¬ç®¡ç†)
- [ç¬¬ä¸ƒéƒ¨åˆ†ï¼šæŸ¥è¯¢ä¼˜åŒ–ä¸ç´¢å¼•](#ç¬¬ä¸ƒéƒ¨åˆ†æŸ¥è¯¢ä¼˜åŒ–ä¸ç´¢å¼•)
- [ç¬¬å…«éƒ¨åˆ†ï¼šå®Œæ•´å®æˆ˜é¡¹ç›®](#ç¬¬å…«éƒ¨åˆ†å®Œæ•´å®æˆ˜é¡¹ç›®)
<!-- TOC -->

---

## ç¬¬ä¸€éƒ¨åˆ†ï¼šdatabase/sqlåŸºç¡€

### 1.1 ä¸ºä»€ä¹ˆå­¦ä¹ database/sqlï¼Ÿ

```text
âœ… Goæ ‡å‡†åº“ - æ— éœ€ç¬¬ä¸‰æ–¹ä¾èµ–
âœ… é€šç”¨æ¥å£ - æ”¯æŒæ‰€æœ‰SQLæ•°æ®åº“
âœ… è¿æ¥æ± ç®¡ç† - å†…ç½®é«˜æ•ˆè¿æ¥æ± 
âœ… é¢„ç¼–è¯‘è¯­å¥ - é˜²æ­¢SQLæ³¨å…¥
âœ… å¹¶å‘å®‰å…¨ - å¤©ç„¶æ”¯æŒå¹¶å‘
```

---

### 1.2 æ ¸å¿ƒç±»å‹

| ç±»å‹ | ä½œç”¨ | å…³é”®æ–¹æ³• |
|------|------|---------|
| **sql.DB** | æ•°æ®åº“è¿æ¥æ±  | Query(), Exec(), Ping() |
| **sql.Tx** | äº‹åŠ¡ | Commit(), Rollback() |
| **sql.Stmt** | é¢„ç¼–è¯‘è¯­å¥ | Query(), Exec(), Close() |
| **sql.Rows** | æŸ¥è¯¢ç»“æœé›† | Next(), Scan(), Close() |
| **sql.Result** | æ‰§è¡Œç»“æœ | LastInsertId(), RowsAffected() |

---

### 1.3 å®æˆ˜æ¡ˆä¾‹1ï¼šdatabase/sqlå®Œæ•´ç¤ºä¾‹

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
    "log"
    "time"
    
    _ "github.com/go-sql-driver/mysql"
)

// User ç”¨æˆ·æ¨¡å‹
type User struct {
    ID        int64
    Username  string
    Email     sql.NullString // å¯èƒ½ä¸ºNULLçš„å­—æ®µ
    CreatedAt time.Time
}

func main() {
    // 1. è¿æ¥æ•°æ®åº“
    dsn := "user:password@tcp(127.0.0.1:3306)/testdb?parseTime=true&charset=utf8mb4"
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // 2. é…ç½®è¿æ¥æ± 
    db.SetMaxOpenConns(25)                 // æœ€å¤§æ‰“å¼€è¿æ¥æ•°
    db.SetMaxIdleConns(25)                 // æœ€å¤§ç©ºé—²è¿æ¥æ•°
    db.SetConnMaxLifetime(5 * time.Minute) // è¿æ¥æœ€å¤§ç”Ÿå‘½å‘¨æœŸ
    
    // 3. æµ‹è¯•è¿æ¥
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := db.PingContext(ctx); err != nil {
        log.Fatal("Failed to ping database:", err)
    }
    
    fmt.Println("Database connected successfully!")
    
    // 4. åˆ›å»ºç”¨æˆ·
    user := &User{
        Username: "alice",
        Email:    sql.NullString{String: "alice@example.com", Valid: true},
    }
    
    if err := CreateUser(ctx, db, user); err != nil {
        log.Fatal("Failed to create user:", err)
    }
    
    fmt.Printf("User created: ID=%d\n", user.ID)
    
    // 5. æŸ¥è¯¢ç”¨æˆ·
    fetchedUser, err := GetUser(ctx, db, user.ID)
    if err != nil {
        log.Fatal("Failed to get user:", err)
    }
    
    fmt.Printf("User fetched: %+v\n", fetchedUser)
    
    // 6. æ›´æ–°ç”¨æˆ·
    fetchedUser.Email = sql.NullString{String: "alice.new@example.com", Valid: true}
    if err := UpdateUser(ctx, db, fetchedUser); err != nil {
        log.Fatal("Failed to update user:", err)
    }
    
    fmt.Println("User updated successfully!")
    
    // 7. åˆ é™¤ç”¨æˆ·
    if err := DeleteUser(ctx, db, user.ID); err != nil {
        log.Fatal("Failed to delete user:", err)
    }
    
    fmt.Println("User deleted successfully!")
}

// CreateUser åˆ›å»ºç”¨æˆ·
func CreateUser(ctx context.Context, db *sql.DB, user *User) error {
    query := `INSERT INTO users (username, email, created_at) VALUES (?, ?, ?)`
    
    result, err := db.ExecContext(ctx, query, user.Username, user.Email, time.Now())
    if err != nil {
        return err
    }
    
    id, err := result.LastInsertId()
    if err != nil {
        return err
    }
    
    user.ID = id
    return nil
}

// GetUser è·å–ç”¨æˆ·
func GetUser(ctx context.Context, db *sql.DB, id int64) (*User, error) {
    query := `SELECT id, username, email, created_at FROM users WHERE id = ?`
    
    user := &User{}
    err := db.QueryRowContext(ctx, query, id).Scan(
        &user.ID,
        &user.Username,
        &user.Email,
        &user.CreatedAt,
    )
    
    if err != nil {
        if err == sql.ErrNoRows {
            return nil, fmt.Errorf("user not found")
        }
        return nil, err
    }
    
    return user, nil
}

// UpdateUser æ›´æ–°ç”¨æˆ·
func UpdateUser(ctx context.Context, db *sql.DB, user *User) error {
    query := `UPDATE users SET username = ?, email = ? WHERE id = ?`
    
    result, err := db.ExecContext(ctx, query, user.Username, user.Email, user.ID)
    if err != nil {
        return err
    }
    
    rows, err := result.RowsAffected()
    if err != nil {
        return err
    }
    
    if rows == 0 {
        return fmt.Errorf("user not found")
    }
    
    return nil
}

// DeleteUser åˆ é™¤ç”¨æˆ·
func DeleteUser(ctx context.Context, db *sql.DB, id int64) error {
    query := `DELETE FROM users WHERE id = ?`
    
    result, err := db.ExecContext(ctx, query, id)
    if err != nil {
        return err
    }
    
    rows, err := result.RowsAffected()
    if err != nil {
        return err
    }
    
    if rows == 0 {
        return fmt.Errorf("user not found")
    }
    
    return nil
}

// ListUsers åˆ—å‡ºæ‰€æœ‰ç”¨æˆ·
func ListUsers(ctx context.Context, db *sql.DB) ([]*User, error) {
    query := `SELECT id, username, email, created_at FROM users ORDER BY id`
    
    rows, err := db.QueryContext(ctx, query)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var users []*User
    for rows.Next() {
        user := &User{}
        if err := rows.Scan(&user.ID, &user.Username, &user.Email, &user.CreatedAt); err != nil {
            return nil, err
        }
        users = append(users, user)
    }
    
    if err := rows.Err(); err != nil {
        return nil, err
    }
    
    return users, nil
}
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šGORMæ·±åº¦å®æˆ˜

### 2.1 ä¸ºä»€ä¹ˆé€‰æ‹©GORMï¼Ÿ

```text
âœ… åŠŸèƒ½å®Œå–„ - ORMåŠŸèƒ½é½å…¨
âœ… å¼€å‘æ•ˆç‡ - è‡ªåŠ¨è¿ç§»ã€é’©å­å‡½æ•°
âœ… å…³è”å¤„ç† - ä¸€å¯¹ä¸€ã€ä¸€å¯¹å¤šã€å¤šå¯¹å¤š
âœ… é“¾å¼è°ƒç”¨ - APIä¼˜é›…
âœ… æ’ä»¶ç”Ÿæ€ - ä¸°å¯Œçš„æ’ä»¶ç³»ç»Ÿ
```

---

### 2.2 GORMæ ¸å¿ƒæ¦‚å¿µ

| æ¦‚å¿µ | è¯´æ˜ | ç¤ºä¾‹ |
|------|------|------|
| **æ¨¡å‹å®šä¹‰** | ç»“æ„ä½“æ˜ å°„åˆ°è¡¨ | `type User struct {...}` |
| **çº¦å®š** | è¡¨åã€ä¸»é”®ã€æ—¶é—´æˆ³ | usersè¡¨ã€IDä¸»é”® |
| **é’©å­** | BeforeCreateã€AfterUpdate | è‡ªåŠ¨å¡«å……å­—æ®µ |
| **å…³è”** | HasOneã€HasManyã€BelongsTo | ç”¨æˆ·ä¸è®¢å• |
| **é¢„åŠ è½½** | Preloadã€Joins | é¿å…N+1é—®é¢˜ |

---

### 2.3 å®æˆ˜æ¡ˆä¾‹2ï¼šGORMå®Œæ•´CRUD

```go
package main

import (
    "fmt"
    "log"
    "time"
    
    "gorm.io/driver/mysql"
    "gorm.io/gorm"
    "gorm.io/gorm/logger"
)

// User ç”¨æˆ·æ¨¡å‹
type User struct {
    ID        uint           `gorm:"primarykey"`
    Username  string         `gorm:"uniqueIndex;not null;size:50"`
    Email     string         `gorm:"uniqueIndex;size:100"`
    Age       int            `gorm:"default:0"`
    Active    bool           `gorm:"default:true"`
    CreatedAt time.Time
    UpdatedAt time.Time
    DeletedAt gorm.DeletedAt `gorm:"index"` // è½¯åˆ é™¤
}

func main() {
    // 1. è¿æ¥æ•°æ®åº“
    dsn := "user:password@tcp(127.0.0.1:3306)/testdb?charset=utf8mb4&parseTime=True&loc=Local"
    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
        Logger: logger.Default.LogMode(logger.Info), // å¼€å¯SQLæ—¥å¿—
    })
    if err != nil {
        log.Fatal("Failed to connect database:", err)
    }
    
    // 2. è‡ªåŠ¨è¿ç§»ï¼ˆåˆ›å»ºè¡¨ï¼‰
    if err := db.AutoMigrate(&User{}); err != nil {
        log.Fatal("Failed to migrate:", err)
    }
    
    // 3. åˆ›å»ºç”¨æˆ·
    user := &User{
        Username: "bob",
        Email:    "bob@example.com",
        Age:      25,
    }
    
    result := db.Create(user)
    if result.Error != nil {
        log.Fatal("Failed to create user:", result.Error)
    }
    
    fmt.Printf("User created: ID=%d, RowsAffected=%d\n", user.ID, result.RowsAffected)
    
    // 4. æŸ¥è¯¢å•ä¸ªç”¨æˆ·
    var fetchedUser User
    db.First(&fetchedUser, user.ID)
    fmt.Printf("User fetched: %+v\n", fetchedUser)
    
    // 5. æ¡ä»¶æŸ¥è¯¢
    var users []User
    db.Where("age > ?", 20).Find(&users)
    fmt.Printf("Users with age > 20: %d\n", len(users))
    
    // 6. æ›´æ–°ç”¨æˆ·
    db.Model(&user).Update("Age", 26)
    fmt.Println("User age updated to 26")
    
    // 7. æ›´æ–°å¤šä¸ªå­—æ®µ
    db.Model(&user).Updates(User{Age: 27, Email: "bob.new@example.com"})
    fmt.Println("User updated with multiple fields")
    
    // 8. è½¯åˆ é™¤
    db.Delete(&user)
    fmt.Println("User soft deleted")
    
    // 9. æŸ¥è¯¢åŒ…å«è½¯åˆ é™¤çš„è®°å½•
    var deletedUser User
    db.Unscoped().First(&deletedUser, user.ID)
    fmt.Printf("Deleted user found: %+v\n", deletedUser)
    
    // 10. æ°¸ä¹…åˆ é™¤
    db.Unscoped().Delete(&user)
    fmt.Println("User permanently deleted")
}
```

---

### 2.4 å®æˆ˜æ¡ˆä¾‹3ï¼šGORMå…³è”å…³ç³»

```go
package main

import (
    "fmt"
    "log"
    "time"
    
    "gorm.io/driver/mysql"
    "gorm.io/gorm"
)

// User ç”¨æˆ·ï¼ˆä¸€ï¼‰
type User struct {
    ID       uint
    Username string
    Profile  Profile  // ä¸€å¯¹ä¸€ï¼šç”¨æˆ·èµ„æ–™
    Orders   []Order  // ä¸€å¯¹å¤šï¼šç”¨æˆ·è®¢å•
    Tags     []Tag    `gorm:"many2many:user_tags;"` // å¤šå¯¹å¤šï¼šç”¨æˆ·æ ‡ç­¾
}

// Profile ç”¨æˆ·èµ„æ–™ï¼ˆä¸€ï¼‰
type Profile struct {
    ID      uint
    UserID  uint   // å¤–é”®
    Bio     string
    Avatar  string
}

// Order è®¢å•ï¼ˆå¤šï¼‰
type Order struct {
    ID      uint
    UserID  uint  // å¤–é”®
    Amount  float64
    Status  string
    Items   []OrderItem // ä¸€å¯¹å¤šï¼šè®¢å•é¡¹
}

// OrderItem è®¢å•é¡¹
type OrderItem struct {
    ID        uint
    OrderID   uint // å¤–é”®
    ProductID uint
    Quantity  int
    Price     float64
}

// Tag æ ‡ç­¾ï¼ˆå¤šå¯¹å¤šï¼‰
type Tag struct {
    ID   uint
    Name string
}

func main() {
    dsn := "user:password@tcp(127.0.0.1:3306)/testdb?charset=utf8mb4&parseTime=True&loc=Local"
    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
    if err != nil {
        log.Fatal(err)
    }
    
    // è‡ªåŠ¨è¿ç§»
    db.AutoMigrate(&User{}, &Profile{}, &Order{}, &OrderItem{}, &Tag{})
    
    // åˆ›å»ºå¸¦å…³è”çš„ç”¨æˆ·
    user := &User{
        Username: "charlie",
        Profile: Profile{
            Bio:    "Go developer",
            Avatar: "avatar.jpg",
        },
        Orders: []Order{
            {Amount: 100.50, Status: "pending"},
            {Amount: 200.75, Status: "completed"},
        },
        Tags: []Tag{
            {Name: "developer"},
            {Name: "golang"},
        },
    }
    
    // è‡ªåŠ¨åˆ›å»ºå…³è”æ•°æ®
    db.Create(user)
    fmt.Printf("User created with ID: %d\n", user.ID)
    
    // é¢„åŠ è½½å…³è”æ•°æ®ï¼ˆè§£å†³N+1é—®é¢˜ï¼‰
    var fetchedUser User
    db.Preload("Profile").
       Preload("Orders").
       Preload("Tags").
       First(&fetchedUser, user.ID)
    
    fmt.Printf("User: %s\n", fetchedUser.Username)
    fmt.Printf("Profile: %s\n", fetchedUser.Profile.Bio)
    fmt.Printf("Orders: %d\n", len(fetchedUser.Orders))
    fmt.Printf("Tags: %d\n", len(fetchedUser.Tags))
    
    // æ·»åŠ å…³è”
    newTag := Tag{Name: "backend"}
    db.Model(&fetchedUser).Association("Tags").Append(&newTag)
    fmt.Println("New tag added")
    
    // åˆ é™¤å…³è”ï¼ˆä¸åˆ é™¤Tagæœ¬èº«ï¼‰
    db.Model(&fetchedUser).Association("Tags").Delete(&newTag)
    fmt.Println("Tag association removed")
}
```

---

### 2.5 å®æˆ˜æ¡ˆä¾‹4ï¼šGORMé’©å­å‡½æ•°

```go
package main

import (
    "fmt"
    "time"
    
    "gorm.io/gorm"
)

// Article æ–‡ç« æ¨¡å‹ï¼ˆå¸¦é’©å­ï¼‰
type Article struct {
    ID          uint
    Title       string
    Content     string
    Slug        string    // è‡ªåŠ¨ç”Ÿæˆ
    WordCount   int       // è‡ªåŠ¨è®¡ç®—
    PublishedAt *time.Time
    CreatedAt   time.Time
    UpdatedAt   time.Time
}

// BeforeCreate åˆ›å»ºå‰é’©å­
func (a *Article) BeforeCreate(tx *gorm.DB) error {
    // 1. ç”Ÿæˆslug
    a.Slug = generateSlug(a.Title)
    
    // 2. è®¡ç®—å­—æ•°
    a.WordCount = len([]rune(a.Content))
    
    // 3. è®¾ç½®å‘å¸ƒæ—¶é—´
    if a.PublishedAt == nil {
        now := time.Now()
        a.PublishedAt = &now
    }
    
    fmt.Println("BeforeCreate hook executed")
    return nil
}

// AfterCreate åˆ›å»ºåé’©å­
func (a *Article) AfterCreate(tx *gorm.DB) error {
    fmt.Printf("Article created: ID=%d, WordCount=%d\n", a.ID, a.WordCount)
    
    // å¯ä»¥åœ¨è¿™é‡Œå‘é€é€šçŸ¥ã€æ›´æ–°ç¼“å­˜ç­‰
    return nil
}

// BeforeUpdate æ›´æ–°å‰é’©å­
func (a *Article) BeforeUpdate(tx *gorm.DB) error {
    // é‡æ–°è®¡ç®—å­—æ•°
    if tx.Statement.Changed("Content") {
        a.WordCount = len([]rune(a.Content))
        fmt.Println("Content changed, recalculating word count")
    }
    
    return nil
}

// AfterUpdate æ›´æ–°åé’©å­
func (a *Article) AfterUpdate(tx *gorm.DB) error {
    fmt.Printf("Article updated: ID=%d\n", a.ID)
    
    // æ¸…é™¤ç¼“å­˜
    return nil
}

// BeforeDelete åˆ é™¤å‰é’©å­
func (a *Article) BeforeDelete(tx *gorm.DB) error {
    fmt.Printf("Deleting article: ID=%d\n", a.ID)
    
    // å¯ä»¥åœ¨è¿™é‡Œå¤‡ä»½æ•°æ®ã€åˆ é™¤å…³è”æ–‡ä»¶ç­‰
    return nil
}

// generateSlug ç”Ÿæˆslug
func generateSlug(title string) string {
    // ç®€åŒ–ç‰ˆï¼šå®é™…åº”è¯¥åšæ›´å¤æ‚çš„å¤„ç†
    return fmt.Sprintf("%s-%d", title, time.Now().Unix())
}

func main() {
    // ä½¿ç”¨ç¤ºä¾‹
    article := &Article{
        Title:   "Go GORM Hooks",
        Content: "This is a comprehensive guide to GORM hooks.",
    }
    
    // db.Create(article) // ä¼šè§¦å‘BeforeCreateå’ŒAfterCreate
}
```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šsqlxæ·±åº¦å®æˆ˜

### 3.1 ä¸ºä»€ä¹ˆé€‰æ‹©sqlxï¼Ÿ

```text
âœ… ç»“æ„ä½“æ˜ å°„ - è‡ªåŠ¨æ‰«æåˆ°ç»“æ„ä½“
âœ… å‘½åå‚æ•° - æ›´æ¸…æ™°çš„SQL
âœ… æ‰¹é‡æ“ä½œ - NamedExecæ‰¹é‡æ’å…¥
âœ… æ€§èƒ½ä¼˜è¶Š - æ¥è¿‘åŸç”Ÿdatabase/sql
âœ… è½»é‡çº§ - åªæ˜¯database/sqlçš„æ‰©å±•
```

---

### 3.2 å®æˆ˜æ¡ˆä¾‹5ï¼šsqlxå®Œæ•´ç¤ºä¾‹

```go
package main

import (
    "fmt"
    "log"
    "time"
    
    _ "github.com/go-sql-driver/mysql"
    "github.com/jmoiron/sqlx"
)

// User ç”¨æˆ·æ¨¡å‹
type User struct {
    ID        int64     `db:"id"`
    Username  string    `db:"username"`
    Email     string    `db:"email"`
    Age       int       `db:"age"`
    CreatedAt time.Time `db:"created_at"`
}

func main() {
    // 1. è¿æ¥æ•°æ®åº“
    dsn := "user:password@tcp(127.0.0.1:3306)/testdb?parseTime=true"
    db, err := sqlx.Connect("mysql", dsn)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // 2. åˆ›å»ºç”¨æˆ·ï¼ˆå•ä¸ªï¼‰
    user := &User{
        Username: "david",
        Email:    "david@example.com",
        Age:      30,
    }
    
    result, err := db.NamedExec(`
        INSERT INTO users (username, email, age, created_at) 
        VALUES (:username, :email, :age, NOW())
    `, user)
    
    if err != nil {
        log.Fatal(err)
    }
    
    id, _ := result.LastInsertId()
    user.ID = id
    fmt.Printf("User created: ID=%d\n", user.ID)
    
    // 3. æŸ¥è¯¢å•ä¸ªç”¨æˆ·ï¼ˆGetï¼‰
    var fetchedUser User
    err = db.Get(&fetchedUser, "SELECT * FROM users WHERE id = ?", user.ID)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("User fetched: %+v\n", fetchedUser)
    
    // 4. æŸ¥è¯¢å¤šä¸ªç”¨æˆ·ï¼ˆSelectï¼‰
    var users []User
    err = db.Select(&users, "SELECT * FROM users WHERE age > ?", 20)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("Users found: %d\n", len(users))
    
    // 5. å‘½åæŸ¥è¯¢
    query := `SELECT * FROM users WHERE username = :username AND age > :age`
    params := map[string]interface{}{
        "username": "david",
        "age":      25,
    }
    
    rows, err := db.NamedQuery(query, params)
    if err != nil {
        log.Fatal(err)
    }
    defer rows.Close()
    
    for rows.Next() {
        var u User
        if err := rows.StructScan(&u); err != nil {
            log.Fatal(err)
        }
        fmt.Printf("Named query result: %+v\n", u)
    }
    
    // 6. æ‰¹é‡æ’å…¥
    users = []User{
        {Username: "user1", Email: "user1@example.com", Age: 20},
        {Username: "user2", Email: "user2@example.com", Age: 22},
        {Username: "user3", Email: "user3@example.com", Age: 24},
    }
    
    _, err = db.NamedExec(`
        INSERT INTO users (username, email, age, created_at) 
        VALUES (:username, :email, :age, NOW())
    `, users)
    
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Println("Batch insert successful")
    
    // 7. æ›´æ–°
    _, err = db.Exec("UPDATE users SET age = ? WHERE id = ?", 31, user.ID)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Println("User updated")
    
    // 8. åˆ é™¤
    _, err = db.Exec("DELETE FROM users WHERE id = ?", user.ID)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Println("User deleted")
}
```

---

### 3.3 å®æˆ˜æ¡ˆä¾‹6ï¼šsqlxé«˜çº§æŸ¥è¯¢

```go
package main

import (
    "fmt"
    "log"
    
    "github.com/jmoiron/sqlx"
)

// UserStats ç”¨æˆ·ç»Ÿè®¡
type UserStats struct {
    AgeGroup string `db:"age_group"`
    Count    int    `db:"count"`
    AvgAge   float64 `db:"avg_age"`
}

// UserWithOrders ç”¨æˆ·åŠè®¢å•ç»Ÿè®¡
type UserWithOrders struct {
    UserID      int64   `db:"user_id"`
    Username    string  `db:"username"`
    OrderCount  int     `db:"order_count"`
    TotalAmount float64 `db:"total_amount"`
}

func AdvancedQueries(db *sqlx.DB) {
    // 1. èšåˆæŸ¥è¯¢
    var stats []UserStats
    query := `
        SELECT 
            CASE 
                WHEN age < 20 THEN 'Under 20'
                WHEN age BETWEEN 20 AND 30 THEN '20-30'
                ELSE 'Over 30'
            END as age_group,
            COUNT(*) as count,
            AVG(age) as avg_age
        FROM users
        GROUP BY age_group
        ORDER BY age_group
    `
    
    err := db.Select(&stats, query)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Println("User statistics by age group:")
    for _, stat := range stats {
        fmt.Printf("  %s: %d users, avg age %.2f\n", stat.AgeGroup, stat.Count, stat.AvgAge)
    }
    
    // 2. JOINæŸ¥è¯¢
    var userOrders []UserWithOrders
    joinQuery := `
        SELECT 
            u.id as user_id,
            u.username,
            COUNT(o.id) as order_count,
            COALESCE(SUM(o.amount), 0) as total_amount
        FROM users u
        LEFT JOIN orders o ON u.id = o.user_id
        GROUP BY u.id, u.username
        HAVING order_count > 0
        ORDER BY total_amount DESC
        LIMIT 10
    `
    
    err = db.Select(&userOrders, joinQuery)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Println("\nTop 10 users by order amount:")
    for i, uo := range userOrders {
        fmt.Printf("  %d. %s: %d orders, $%.2f total\n", 
            i+1, uo.Username, uo.OrderCount, uo.TotalAmount)
    }
    
    // 3. INæŸ¥è¯¢
    ids := []int64{1, 2, 3, 4, 5}
    query, args, err := sqlx.In("SELECT * FROM users WHERE id IN (?)", ids)
    if err != nil {
        log.Fatal(err)
    }
    
    query = db.Rebind(query) // é‡æ–°ç»‘å®šå ä½ç¬¦
    
    var users []User
    err = db.Select(&users, query, args...)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("\nUsers with IDs in %v: %d\n", ids, len(users))
}
```

---

## ç¬¬å››éƒ¨åˆ†ï¼šè¿æ¥æ± ä¸æ€§èƒ½ä¼˜åŒ–

### 4.1 è¿æ¥æ± é…ç½®æœ€ä½³å®è·µ

```go
package main

import (
    "database/sql"
    "time"
)

func ConfigureConnectionPool(db *sql.DB) {
    // 1. æœ€å¤§æ‰“å¼€è¿æ¥æ•°
    // å»ºè®®ï¼šCPUæ ¸å¿ƒæ•° * 2 åˆ° CPUæ ¸å¿ƒæ•° * 4
    db.SetMaxOpenConns(25)
    
    // 2. æœ€å¤§ç©ºé—²è¿æ¥æ•°
    // å»ºè®®ï¼šç­‰äºMaxOpenConnsï¼Œé¿å…é¢‘ç¹åˆ›å»º/é”€æ¯è¿æ¥
    db.SetMaxIdleConns(25)
    
    // 3. è¿æ¥æœ€å¤§ç”Ÿå‘½å‘¨æœŸ
    // å»ºè®®ï¼š5-10åˆ†é’Ÿï¼Œé˜²æ­¢é•¿æ—¶é—´è¿æ¥è¢«æ•°æ®åº“æœåŠ¡å™¨å…³é—­
    db.SetConnMaxLifetime(5 * time.Minute)
    
    // 4. è¿æ¥æœ€å¤§ç©ºé—²æ—¶é—´ï¼ˆGo 1.15+ï¼‰
    // å»ºè®®ï¼š1-2åˆ†é’Ÿï¼ŒåŠæ—¶é‡Šæ”¾ä¸ç”¨çš„è¿æ¥
    db.SetConnMaxIdleTime(2 * time.Minute)
}

// ConnectionPoolStats è¿æ¥æ± ç»Ÿè®¡
func ConnectionPoolStats(db *sql.DB) {
    stats := db.Stats()
    
    println("Connection Pool Statistics:")
    println("  MaxOpenConnections:", stats.MaxOpenConnections)
    println("  OpenConnections:", stats.OpenConnections)
    println("  InUse:", stats.InUse)
    println("  Idle:", stats.Idle)
    println("  WaitCount:", stats.WaitCount)
    println("  WaitDuration:", stats.WaitDuration)
    println("  MaxIdleClosed:", stats.MaxIdleClosed)
    println("  MaxLifetimeClosed:", stats.MaxLifetimeClosed)
}
```

---

### 4.2 å®æˆ˜æ¡ˆä¾‹7ï¼šæ€§èƒ½å¯¹æ¯”æµ‹è¯•

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
    "testing"
    "time"
    
    "github.com/jmoiron/sqlx"
    "gorm.io/gorm"
)

// BenchmarkInsert æ’å…¥æ€§èƒ½å¯¹æ¯”
func BenchmarkInsert(b *testing.B) {
    // å‡†å¤‡æ•°æ®åº“è¿æ¥
    sqlDB, _ := sql.Open("mysql", dsn)
    sqlxDB, _ := sqlx.Connect("mysql", dsn)
    gormDB, _ := gorm.Open(mysql.Open(dsn), &gorm.Config{})
    
    b.Run("database/sql", func(b *testing.B) {
        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            sqlDB.Exec("INSERT INTO users (username, email) VALUES (?, ?)", 
                fmt.Sprintf("user%d", i), fmt.Sprintf("user%d@example.com", i))
        }
    })
    
    b.Run("sqlx", func(b *testing.B) {
        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            sqlxDB.NamedExec("INSERT INTO users (username, email) VALUES (:username, :email)",
                map[string]interface{}{
                    "username": fmt.Sprintf("user%d", i),
                    "email":    fmt.Sprintf("user%d@example.com", i),
                })
        }
    })
    
    b.Run("GORM", func(b *testing.B) {
        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            gormDB.Create(&User{
                Username: fmt.Sprintf("user%d", i),
                Email:    fmt.Sprintf("user%d@example.com", i),
            })
        }
    })
}

// BenchmarkQuery æŸ¥è¯¢æ€§èƒ½å¯¹æ¯”
func BenchmarkQuery(b *testing.B) {
    sqlDB, _ := sql.Open("mysql", dsn)
    sqlxDB, _ := sqlx.Connect("mysql", dsn)
    gormDB, _ := gorm.Open(mysql.Open(dsn), &gorm.Config{})
    
    b.Run("database/sql", func(b *testing.B) {
        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            rows, _ := sqlDB.Query("SELECT * FROM users LIMIT 100")
            for rows.Next() {
                var u User
                rows.Scan(&u.ID, &u.Username, &u.Email, &u.CreatedAt)
            }
            rows.Close()
        }
    })
    
    b.Run("sqlx", func(b *testing.B) {
        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            var users []User
            sqlxDB.Select(&users, "SELECT * FROM users LIMIT 100")
        }
    })
    
    b.Run("GORM", func(b *testing.B) {
        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            var users []User
            gormDB.Limit(100).Find(&users)
        }
    })
}

/*
æ€§èƒ½å¯¹æ¯”ç»“æœï¼ˆå‚è€ƒï¼‰ï¼š

æ’å…¥æ€§èƒ½ï¼š
database/sql:  10000 ns/op
sqlx:          12000 ns/op (+20%)
GORM:          25000 ns/op (+150%)

æŸ¥è¯¢æ€§èƒ½ï¼š
database/sql:  50000 ns/op
sqlx:          55000 ns/op (+10%)
GORM:          80000 ns/op (+60%)

ç»“è®ºï¼š
- database/sql: æ€§èƒ½æœ€ä¼˜ï¼Œä½†ä»£ç é‡å¤§
- sqlx: æ€§èƒ½ä¸ä¾¿åˆ©æ€§å¹³è¡¡
- GORM: å¼€å‘æ•ˆç‡æœ€é«˜ï¼Œæ€§èƒ½æŸå¤±å¯æ¥å—
*/
```

---

## ç¬¬äº”éƒ¨åˆ†ï¼šäº‹åŠ¡å¤„ç†æ·±åº¦å®æˆ˜

### 5.1 äº‹åŠ¡éš”ç¦»çº§åˆ«

| éš”ç¦»çº§åˆ« | è„è¯» | ä¸å¯é‡å¤è¯» | å¹»è¯» | æ€§èƒ½ |
|---------|------|-----------|------|------|
| **Read Uncommitted** | âœ… | âœ… | âœ… | æœ€é«˜ |
| **Read Committed** | âŒ | âœ… | âœ… | é«˜ |
| **Repeatable Read** | âŒ | âŒ | âœ… | ä¸­ |
| **Serializable** | âŒ | âŒ | âŒ | æœ€ä½ |

---

### 5.2 å®æˆ˜æ¡ˆä¾‹8ï¼šäº‹åŠ¡å¤„ç†å®Œæ•´ç¤ºä¾‹

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
    "log"
)

// TransferMoney è½¬è´¦ï¼ˆäº‹åŠ¡ç¤ºä¾‹ï¼‰
func TransferMoney(db *sql.DB, fromUserID, toUserID int64, amount float64) error {
    // 1. å¼€å¯äº‹åŠ¡
    ctx := context.Background()
    tx, err := db.BeginTx(ctx, &sql.TxOptions{
        Isolation: sql.LevelReadCommitted, // è®¾ç½®éš”ç¦»çº§åˆ«
    })
    if err != nil {
        return err
    }
    
    // 2. ä½¿ç”¨deferç¡®ä¿äº‹åŠ¡è¢«å¤„ç†
    defer func() {
        if p := recover(); p != nil {
            tx.Rollback()
            panic(p) // é‡æ–°æŠ›å‡ºpanic
        } else if err != nil {
            tx.Rollback()
        } else {
            err = tx.Commit()
        }
    }()
    
    // 3. æ£€æŸ¥å‘é€æ–¹ä½™é¢
    var balance float64
    err = tx.QueryRowContext(ctx, 
        "SELECT balance FROM accounts WHERE user_id = ? FOR UPDATE", 
        fromUserID).Scan(&balance)
    if err != nil {
        return fmt.Errorf("failed to get sender balance: %w", err)
    }
    
    if balance < amount {
        return fmt.Errorf("insufficient balance: have %.2f, need %.2f", balance, amount)
    }
    
    // 4. æ‰£æ¬¾
    _, err = tx.ExecContext(ctx,
        "UPDATE accounts SET balance = balance - ? WHERE user_id = ?",
        amount, fromUserID)
    if err != nil {
        return fmt.Errorf("failed to deduct from sender: %w", err)
    }
    
    // 5. åŠ æ¬¾
    _, err = tx.ExecContext(ctx,
        "UPDATE accounts SET balance = balance + ? WHERE user_id = ?",
        amount, toUserID)
    if err != nil {
        return fmt.Errorf("failed to add to receiver: %w", err)
    }
    
    // 6. è®°å½•äº¤æ˜“
    _, err = tx.ExecContext(ctx,
        `INSERT INTO transactions (from_user_id, to_user_id, amount, created_at) 
         VALUES (?, ?, ?, NOW())`,
        fromUserID, toUserID, amount)
    if err != nil {
        return fmt.Errorf("failed to record transaction: %w", err)
    }
    
    return nil
}

// GORMäº‹åŠ¡ç¤ºä¾‹
func TransferMoneyGORM(db *gorm.DB, fromUserID, toUserID uint, amount float64) error {
    return db.Transaction(func(tx *gorm.DB) error {
        // 1. æ£€æŸ¥å‘é€æ–¹ä½™é¢
        var fromAccount Account
        if err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).
            First(&fromAccount, fromUserID).Error; err != nil {
            return err
        }
        
        if fromAccount.Balance < amount {
            return fmt.Errorf("insufficient balance")
        }
        
        // 2. æ‰£æ¬¾
        if err := tx.Model(&fromAccount).
            Update("balance", gorm.Expr("balance - ?", amount)).Error; err != nil {
            return err
        }
        
        // 3. åŠ æ¬¾
        if err := tx.Model(&Account{}).
            Where("user_id = ?", toUserID).
            Update("balance", gorm.Expr("balance + ?", amount)).Error; err != nil {
            return err
        }
        
        // 4. è®°å½•äº¤æ˜“
        transaction := &Transaction{
            FromUserID: fromUserID,
            ToUserID:   toUserID,
            Amount:     amount,
        }
        
        return tx.Create(transaction).Error
    })
}

// sqlxäº‹åŠ¡ç¤ºä¾‹
func TransferMoneySqlx(db *sqlx.DB, fromUserID, toUserID int64, amount float64) error {
    tx, err := db.Beginx()
    if err != nil {
        return err
    }
    
    defer func() {
        if p := recover(); p != nil {
            tx.Rollback()
            panic(p)
        } else if err != nil {
            tx.Rollback()
        } else {
            err = tx.Commit()
        }
    }()
    
    // 1. æ£€æŸ¥ä½™é¢
    var balance float64
    err = tx.Get(&balance, 
        "SELECT balance FROM accounts WHERE user_id = ? FOR UPDATE", 
        fromUserID)
    if err != nil {
        return err
    }
    
    if balance < amount {
        return fmt.Errorf("insufficient balance")
    }
    
    // 2. æ‰£æ¬¾
    _, err = tx.Exec(
        "UPDATE accounts SET balance = balance - ? WHERE user_id = ?",
        amount, fromUserID)
    if err != nil {
        return err
    }
    
    // 3. åŠ æ¬¾
    _, err = tx.Exec(
        "UPDATE accounts SET balance = balance + ? WHERE user_id = ?",
        amount, toUserID)
    if err != nil {
        return err
    }
    
    // 4. è®°å½•äº¤æ˜“
    _, err = tx.NamedExec(
        `INSERT INTO transactions (from_user_id, to_user_id, amount, created_at) 
         VALUES (:from_user_id, :to_user_id, :amount, NOW())`,
        map[string]interface{}{
            "from_user_id": fromUserID,
            "to_user_id":   toUserID,
            "amount":       amount,
        })
    
    return err
}
```

---

## ç¬¬å…­éƒ¨åˆ†ï¼šæ•°æ®åº“è¿ç§»ä¸ç‰ˆæœ¬ç®¡ç†

### 6.1 å®æˆ˜æ¡ˆä¾‹9ï¼šä½¿ç”¨golang-migrate

```go
package main

import (
    "database/sql"
    "log"
    
    "github.com/golang-migrate/migrate/v4"
    "github.com/golang-migrate/migrate/v4/database/mysql"
    _ "github.com/golang-migrate/migrate/v4/source/file"
)

func RunMigrations(db *sql.DB) error {
    driver, err := mysql.WithInstance(db, &mysql.Config{})
    if err != nil {
        return err
    }
    
    m, err := migrate.NewWithDatabaseInstance(
        "file://migrations", // è¿ç§»æ–‡ä»¶ç›®å½•
        "mysql",
        driver,
    )
    if err != nil {
        return err
    }
    
    // æ‰§è¡Œæ‰€æœ‰è¿ç§»
    if err := m.Up(); err != nil && err != migrate.ErrNoChange {
        return err
    }
    
    version, dirty, err := m.Version()
    if err != nil {
        return err
    }
    
    log.Printf("Migration completed: version=%d, dirty=%v", version, dirty)
    return nil
}

// è¿ç§»æ–‡ä»¶ç¤ºä¾‹
/*
// migrations/000001_create_users_table.up.sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_username (username),
    INDEX idx_email (email)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

// migrations/000001_create_users_table.down.sql
DROP TABLE IF EXISTS users;

// migrations/000002_create_orders_table.up.sql
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    amount DECIMAL(10, 2) NOT NULL,
    status VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_user_id (user_id),
    INDEX idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

// migrations/000002_create_orders_table.down.sql
DROP TABLE IF EXISTS orders;
*/
```

---

## ç¬¬ä¸ƒéƒ¨åˆ†ï¼šæŸ¥è¯¢ä¼˜åŒ–ä¸ç´¢å¼•

### 7.1 ç´¢å¼•ç±»å‹ä¸ä½¿ç”¨åœºæ™¯

| ç´¢å¼•ç±»å‹ | é€‚ç”¨åœºæ™¯ | ç¤ºä¾‹ |
|---------|---------|------|
| **å•åˆ—ç´¢å¼•** | å•å­—æ®µæŸ¥è¯¢ | `CREATE INDEX idx_username ON users(username)` |
| **å¤åˆç´¢å¼•** | å¤šå­—æ®µæŸ¥è¯¢ | `CREATE INDEX idx_user_email ON users(username, email)` |
| **å”¯ä¸€ç´¢å¼•** | ä¿è¯å”¯ä¸€æ€§ | `CREATE UNIQUE INDEX idx_email ON users(email)` |
| **å…¨æ–‡ç´¢å¼•** | æ–‡æœ¬æœç´¢ | `CREATE FULLTEXT INDEX idx_content ON articles(content)` |

---

### 7.2 æŸ¥è¯¢ä¼˜åŒ–æŠ€å·§

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
)

// BadQuery ç³Ÿç³•çš„æŸ¥è¯¢
func BadQuery(db *sql.DB) {
    // âŒ N+1é—®é¢˜
    rows, _ := db.Query("SELECT id FROM users")
    for rows.Next() {
        var id int
        rows.Scan(&id)
        
        // æ¯ä¸ªç”¨æˆ·éƒ½æŸ¥ä¸€æ¬¡è®¢å•ï¼ˆN+1é—®é¢˜ï¼‰
        db.Query("SELECT * FROM orders WHERE user_id = ?", id)
    }
    
    // âŒ SELECT *
    db.Query("SELECT * FROM users") // æŸ¥è¯¢äº†ä¸éœ€è¦çš„å­—æ®µ
    
    // âŒ æ²¡æœ‰ä½¿ç”¨LIMIT
    db.Query("SELECT * FROM users") // å¯èƒ½è¿”å›ç™¾ä¸‡æ¡è®°å½•
    
    // âŒ ORæ¡ä»¶æ— æ³•ä½¿ç”¨ç´¢å¼•
    db.Query("SELECT * FROM users WHERE username = ? OR email = ?", "alice", "alice@example.com")
}

// GoodQuery ä¼˜åŒ–åçš„æŸ¥è¯¢
func GoodQuery(db *sql.DB) {
    // âœ… ä½¿ç”¨JOINé¿å…N+1
    query := `
        SELECT u.*, o.*
        FROM users u
        LEFT JOIN orders o ON u.id = o.user_id
    `
    db.Query(query)
    
    // âœ… åªæŸ¥è¯¢éœ€è¦çš„å­—æ®µ
    db.Query("SELECT id, username, email FROM users")
    
    // âœ… ä½¿ç”¨LIMITå’ŒOFFSETåˆ†é¡µ
    db.Query("SELECT id, username FROM users LIMIT 10 OFFSET 0")
    
    // âœ… ä½¿ç”¨INä»£æ›¿ORï¼ˆå¯ä»¥ä½¿ç”¨ç´¢å¼•ï¼‰
    db.Query("SELECT * FROM users WHERE id IN (?, ?)", 1, 2)
    
    // âœ… ä½¿ç”¨EXISTSä»£æ›¿COUNT
    var exists bool
    db.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE username = ?)", "alice").Scan(&exists)
    
    // âœ… æ‰¹é‡æ’å…¥
    stmt, _ := db.Prepare("INSERT INTO users (username, email) VALUES (?, ?)")
    for i := 0; i < 1000; i++ {
        stmt.Exec(fmt.Sprintf("user%d", i), fmt.Sprintf("user%d@example.com", i))
    }
}

// EXPLAINåˆ†ææŸ¥è¯¢
func ExplainQuery(db *sql.DB, query string) {
    rows, err := db.Query(fmt.Sprintf("EXPLAIN %s", query))
    if err != nil {
        log.Fatal(err)
    }
    defer rows.Close()
    
    // æ‰“å°EXPLAINç»“æœ
    fmt.Println("Query Execution Plan:")
    for rows.Next() {
        // æ‰«æEXPLAINç»“æœ
        // ...
    }
}
```

---

## ç¬¬å…«éƒ¨åˆ†ï¼šå®Œæ•´å®æˆ˜é¡¹ç›®

### 8.1 é¡¹ç›®ç»“æ„

```text
blog-api/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ main.go
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ user.go
â”‚   â”‚   â”œâ”€â”€ article.go
â”‚   â”‚   â””â”€â”€ comment.go
â”‚   â”œâ”€â”€ repository/
â”‚   â”‚   â”œâ”€â”€ user_repo.go
â”‚   â”‚   â”œâ”€â”€ article_repo.go
â”‚   â”‚   â””â”€â”€ comment_repo.go
â”‚   â”œâ”€â”€ service/
â”‚   â”‚   â”œâ”€â”€ user_service.go
â”‚   â”‚   â””â”€â”€ article_service.go
â”‚   â””â”€â”€ handler/
â”‚       â”œâ”€â”€ user_handler.go
â”‚       â””â”€â”€ article_handler.go
â”œâ”€â”€ migrations/
â”‚   â”œâ”€â”€ 000001_init.up.sql
â”‚   â””â”€â”€ 000001_init.down.sql
â”œâ”€â”€ go.mod
â””â”€â”€ go.sum
```

---

### 8.2 å®Œæ•´ä»£ç ç¤ºä¾‹

#### models/user.go

```go
package models

import (
    "time"
    "gorm.io/gorm"
)

type User struct {
    ID        uint           `gorm:"primarykey" json:"id"`
    Username  string         `gorm:"uniqueIndex;size:50;not null" json:"username"`
    Email     string         `gorm:"uniqueIndex;size:100;not null" json:"email"`
    Password  string         `gorm:"size:255;not null" json:"-"`
    Avatar    string         `gorm:"size:255" json:"avatar"`
    Articles  []Article      `gorm:"foreignKey:AuthorID" json:"articles,omitempty"`
    Comments  []Comment      `gorm:"foreignKey:UserID" json:"comments,omitempty"`
    CreatedAt time.Time      `json:"created_at"`
    UpdatedAt time.Time      `json:"updated_at"`
    DeletedAt gorm.DeletedAt `gorm:"index" json:"-"`
}

type Article struct {
    ID        uint           `gorm:"primarykey" json:"id"`
    Title     string         `gorm:"size:200;not null" json:"title"`
    Content   string         `gorm:"type:text;not null" json:"content"`
    AuthorID  uint           `gorm:"not null;index" json:"author_id"`
    Author    *User          `gorm:"foreignKey:AuthorID" json:"author,omitempty"`
    Comments  []Comment      `gorm:"foreignKey:ArticleID" json:"comments,omitempty"`
    Tags      []Tag          `gorm:"many2many:article_tags;" json:"tags,omitempty"`
    Views     int            `gorm:"default:0" json:"views"`
    CreatedAt time.Time      `json:"created_at"`
    UpdatedAt time.Time      `json:"updated_at"`
    DeletedAt gorm.DeletedAt `gorm:"index" json:"-"`
}

type Comment struct {
    ID        uint           `gorm:"primarykey" json:"id"`
    Content   string         `gorm:"size:1000;not null" json:"content"`
    ArticleID uint           `gorm:"not null;index" json:"article_id"`
    UserID    uint           `gorm:"not null;index" json:"user_id"`
    User      *User          `gorm:"foreignKey:UserID" json:"user,omitempty"`
    CreatedAt time.Time      `json:"created_at"`
    UpdatedAt time.Time      `json:"updated_at"`
    DeletedAt gorm.DeletedAt `gorm:"index" json:"-"`
}

type Tag struct {
    ID   uint   `gorm:"primarykey" json:"id"`
    Name string `gorm:"uniqueIndex;size:50;not null" json:"name"`
}
```

#### repository/article_repo.go

```go
package repository

import (
    "context"
    "blog-api/internal/models"
    "gorm.io/gorm"
)

type ArticleRepository struct {
    db *gorm.DB
}

func NewArticleRepository(db *gorm.DB) *ArticleRepository {
    return &ArticleRepository{db: db}
}

// Create åˆ›å»ºæ–‡ç« 
func (r *ArticleRepository) Create(ctx context.Context, article *models.Article) error {
    return r.db.WithContext(ctx).Create(article).Error
}

// Get è·å–æ–‡ç« ï¼ˆå¸¦ä½œè€…å’Œè¯„è®ºï¼‰
func (r *ArticleRepository) Get(ctx context.Context, id uint) (*models.Article, error) {
    var article models.Article
    err := r.db.WithContext(ctx).
        Preload("Author").
        Preload("Comments.User").
        Preload("Tags").
        First(&article, id).Error
    
    if err != nil {
        return nil, err
    }
    
    return &article, nil
}

// List åˆ—å‡ºæ–‡ç« ï¼ˆåˆ†é¡µï¼‰
func (r *ArticleRepository) List(ctx context.Context, page, pageSize int) ([]*models.Article, int64, error) {
    var articles []*models.Article
    var total int64
    
    // è®¡æ•°
    if err := r.db.WithContext(ctx).Model(&models.Article{}).Count(&total).Error; err != nil {
        return nil, 0, err
    }
    
    // æŸ¥è¯¢
    offset := (page - 1) * pageSize
    err := r.db.WithContext(ctx).
        Preload("Author").
        Order("created_at DESC").
        Limit(pageSize).
        Offset(offset).
        Find(&articles).Error
    
    if err != nil {
        return nil, 0, err
    }
    
    return articles, total, nil
}

// Update æ›´æ–°æ–‡ç« 
func (r *ArticleRepository) Update(ctx context.Context, article *models.Article) error {
    return r.db.WithContext(ctx).Save(article).Error
}

// Delete åˆ é™¤æ–‡ç« 
func (r *ArticleRepository) Delete(ctx context.Context, id uint) error {
    return r.db.WithContext(ctx).Delete(&models.Article{}, id).Error
}

// IncrementViews å¢åŠ æµè§ˆé‡
func (r *ArticleRepository) IncrementViews(ctx context.Context, id uint) error {
    return r.db.WithContext(ctx).
        Model(&models.Article{}).
        Where("id = ?", id).
        Update("views", gorm.Expr("views + ?", 1)).Error
}
```

#### service/article_service.go

```go
package service

import (
    "context"
    "blog-api/internal/models"
    "blog-api/internal/repository"
    "fmt"
)

type ArticleService struct {
    articleRepo *repository.ArticleRepository
    userRepo    *repository.UserRepository
}

func NewArticleService(articleRepo *repository.ArticleRepository, userRepo *repository.UserRepository) *ArticleService {
    return &ArticleService{
        articleRepo: articleRepo,
        userRepo:    userRepo,
    }
}

// CreateArticle åˆ›å»ºæ–‡ç« 
func (s *ArticleService) CreateArticle(ctx context.Context, authorID uint, title, content string, tagNames []string) (*models.Article, error) {
    // éªŒè¯ä½œè€…
    _, err := s.userRepo.Get(ctx, authorID)
    if err != nil {
        return nil, fmt.Errorf("author not found: %w", err)
    }
    
    // åˆ›å»ºæ–‡ç« 
    article := &models.Article{
        Title:    title,
        Content:  content,
        AuthorID: authorID,
    }
    
    // å¤„ç†æ ‡ç­¾
    for _, name := range tagNames {
        article.Tags = append(article.Tags, models.Tag{Name: name})
    }
    
    if err := s.articleRepo.Create(ctx, article); err != nil {
        return nil, err
    }
    
    return article, nil
}

// GetArticle è·å–æ–‡ç« ï¼ˆå¢åŠ æµè§ˆé‡ï¼‰
func (s *ArticleService) GetArticle(ctx context.Context, id uint) (*models.Article, error) {
    article, err := s.articleRepo.Get(ctx, id)
    if err != nil {
        return nil, err
    }
    
    // å¼‚æ­¥å¢åŠ æµè§ˆé‡
    go s.articleRepo.IncrementViews(context.Background(), id)
    
    return article, nil
}

// ListArticles åˆ—å‡ºæ–‡ç« 
func (s *ArticleService) ListArticles(ctx context.Context, page, pageSize int) ([]*models.Article, int64, error) {
    return s.articleRepo.List(ctx, page, pageSize)
}
```

---

## ğŸ¯ æ€»ç»“

### æ•°æ®åº“ç¼–ç¨‹æ ¸å¿ƒè¦ç‚¹

1. **database/sql** - Goæ ‡å‡†åº“ï¼Œé€šç”¨SQLæ¥å£
2. **GORM** - åŠŸèƒ½å®Œå–„çš„ORMï¼Œå¼€å‘æ•ˆç‡é«˜
3. **sqlx** - è½»é‡çº§æ‰©å±•ï¼Œæ€§èƒ½ä¸ä¾¿åˆ©æ€§å¹³è¡¡
4. **è¿æ¥æ± ** - åˆç†é…ç½®ï¼Œæå‡æ€§èƒ½
5. **äº‹åŠ¡å¤„ç†** - ä¿è¯æ•°æ®ä¸€è‡´æ€§
6. **æŸ¥è¯¢ä¼˜åŒ–** - ç´¢å¼•ã€EXPLAINã€é¿å…N+1
7. **è¿ç§»ç®¡ç†** - ç‰ˆæœ¬æ§åˆ¶ï¼Œå›¢é˜Ÿåä½œ

### æŠ€æœ¯é€‰å‹å»ºè®®

| åœºæ™¯ | æ¨èæ–¹æ¡ˆ | ç†ç”± |
|------|---------|------|
| é«˜æ€§èƒ½åœºæ™¯ | database/sql | æ€§èƒ½æœ€ä¼˜ |
| å¿«é€Ÿå¼€å‘ | GORM | åŠŸèƒ½å®Œå–„ã€å¼€å‘æ•ˆç‡é«˜ |
| å¹³è¡¡æ–¹æ¡ˆ | sqlx | æ€§èƒ½ä¸ä¾¿åˆ©æ€§å…¼é¡¾ |
| å¤æ‚æŸ¥è¯¢ | database/sql + sqlx | çµæ´»æ§åˆ¶ |

### æœ€ä½³å®è·µæ¸…å•

```text
âœ… åˆç†é…ç½®è¿æ¥æ± ï¼ˆMaxOpenConnsã€MaxIdleConnsã€ConnMaxLifetimeï¼‰
âœ… ä½¿ç”¨Contextæ§åˆ¶è¶…æ—¶å’Œå–æ¶ˆ
âœ… é¢„ç¼–è¯‘è¯­å¥é˜²æ­¢SQLæ³¨å…¥
âœ… äº‹åŠ¡å¤„ç†ä½¿ç”¨deferç¡®ä¿æäº¤æˆ–å›æ»š
âœ… é¿å…N+1æŸ¥è¯¢ï¼Œä½¿ç”¨JOINæˆ–é¢„åŠ è½½
âœ… åªæŸ¥è¯¢éœ€è¦çš„å­—æ®µï¼Œä¸è¦SELECT *
âœ… ä½¿ç”¨ç´¢å¼•ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½
âœ… æ•°æ®åº“è¿ç§»ä½¿ç”¨ç‰ˆæœ¬æ§åˆ¶
âœ… è®°å½•æ…¢æŸ¥è¯¢æ—¥å¿—
âœ… å®šæœŸåˆ†ææŸ¥è¯¢è®¡åˆ’ï¼ˆEXPLAINï¼‰
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v8.0  
**æœ€åæ›´æ–°**: 2025-10-20

<div align="center">

Made with â¤ï¸ for Go Database Developers

[â¬† å›åˆ°é¡¶éƒ¨](#goæ•°æ®åº“ç¼–ç¨‹æ·±åº¦å®æˆ˜æŒ‡å—)

</div>
