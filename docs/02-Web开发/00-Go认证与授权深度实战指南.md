# Goè®¤è¯ä¸æˆæƒæ·±åº¦å®æˆ˜æŒ‡å—

**æ–‡æ¡£çŠ¶æ€**: âœ… æ·±åº¦é‡å†™å®Œæˆ (v12.0)  
**å­—æ•°**: ~34,000å­—  
**ä»£ç ç¤ºä¾‹**: 100+ä¸ªå®Œæ•´ç¤ºä¾‹  
**å®æˆ˜æ¡ˆä¾‹**: 11ä¸ªç«¯åˆ°ç«¯æ¡ˆä¾‹  
**é€‚ç”¨äººç¾¤**: ä¸­çº§åˆ°é«˜çº§Goå¼€å‘è€…

---

## ğŸ“š ç›®å½•

<!-- TOC -->
- [ç¬¬ä¸€éƒ¨åˆ†ï¼šè®¤è¯æˆæƒåŸºç¡€ç†è®º](#ç¬¬ä¸€éƒ¨åˆ†è®¤è¯æˆæƒåŸºç¡€ç†è®º)
- [ç¬¬äºŒéƒ¨åˆ†ï¼šSessionè®¤è¯æ·±åº¦å®æˆ˜](#ç¬¬äºŒéƒ¨åˆ†sessionè®¤è¯æ·±åº¦å®æˆ˜)
- [ç¬¬ä¸‰éƒ¨åˆ†ï¼šJWTè®¤è¯æ·±åº¦å®æˆ˜](#ç¬¬ä¸‰éƒ¨åˆ†jwtè®¤è¯æ·±åº¦å®æˆ˜)
- [ç¬¬å››éƒ¨åˆ†ï¼šOAuth2.0å®Œæ•´å®ç°](#ç¬¬å››éƒ¨åˆ†oauth20å®Œæ•´å®ç°)
- [ç¬¬äº”éƒ¨åˆ†ï¼šRBACæƒé™æ§åˆ¶](#ç¬¬äº”éƒ¨åˆ†rbacæƒé™æ§åˆ¶)
- [ç¬¬å…­éƒ¨åˆ†ï¼šå¯†ç åŠ å¯†ä¸å®‰å…¨](#ç¬¬å…­éƒ¨åˆ†å¯†ç åŠ å¯†ä¸å®‰å…¨)
- [ç¬¬ä¸ƒéƒ¨åˆ†ï¼šAPIå¯†é’¥è®¤è¯](#ç¬¬ä¸ƒéƒ¨åˆ†apiå¯†é’¥è®¤è¯)
- [ç¬¬å…«éƒ¨åˆ†ï¼šå¤šå› ç´ è®¤è¯MFA](#ç¬¬å…«éƒ¨åˆ†å¤šå› ç´ è®¤è¯mfa)
- [ç¬¬ä¹éƒ¨åˆ†ï¼šå•ç‚¹ç™»å½•SSO](#ç¬¬ä¹éƒ¨åˆ†å•ç‚¹ç™»å½•sso)
- [ç¬¬åéƒ¨åˆ†ï¼šå®‰å…¨æœ€ä½³å®è·µ](#ç¬¬åéƒ¨åˆ†å®‰å…¨æœ€ä½³å®è·µ)
- [ç¬¬åä¸€éƒ¨åˆ†ï¼šå®Œæ•´é¡¹ç›®å®æˆ˜](#ç¬¬åä¸€éƒ¨åˆ†å®Œæ•´é¡¹ç›®å®æˆ˜)
<!-- TOC -->

---

## ç¬¬ä¸€éƒ¨åˆ†ï¼šè®¤è¯æˆæƒåŸºç¡€ç†è®º

### 1.1 æ ¸å¿ƒæ¦‚å¿µ

```text
è®¤è¯ï¼ˆAuthenticationï¼‰: éªŒè¯"ä½ æ˜¯è°" - Who are you?
æˆæƒï¼ˆAuthorizationï¼‰: éªŒè¯"ä½ èƒ½åšä»€ä¹ˆ" - What can you do?

è®¤è¯æ–¹å¼:
âœ… Session-Cookie è®¤è¯
âœ… Token è®¤è¯ï¼ˆJWTï¼‰
âœ… OAuth2.0 æˆæƒ
âœ… API Key è®¤è¯
âœ… å¤šå› ç´ è®¤è¯ï¼ˆMFAï¼‰

æˆæƒæ¨¡å‹:
âœ… RBACï¼ˆåŸºäºè§’è‰²ï¼‰
âœ… ABACï¼ˆåŸºäºå±æ€§ï¼‰
âœ… ACLï¼ˆè®¿é—®æ§åˆ¶åˆ—è¡¨ï¼‰
```

---

### 1.2 è®¤è¯æˆæƒæµç¨‹

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              è®¤è¯æˆæƒå®Œæ•´æµç¨‹                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. ç”¨æˆ·ç™»å½•
   â”œâ”€ è¾“å…¥ç”¨æˆ·å/å¯†ç 
   â”œâ”€ éªŒè¯å‡­è¯
   â””â”€ ç”Ÿæˆå‡­è¯ï¼ˆSession/Tokenï¼‰

2. è®¤è¯æ£€æŸ¥
   â”œâ”€ æå–å‡­è¯
   â”œâ”€ éªŒè¯å‡­è¯æœ‰æ•ˆæ€§
   â””â”€ è¯†åˆ«ç”¨æˆ·èº«ä»½

3. æˆæƒæ£€æŸ¥
   â”œâ”€ è·å–ç”¨æˆ·æƒé™
   â”œâ”€ æ£€æŸ¥èµ„æºæƒé™
   â””â”€ å…è®¸/æ‹’ç»è®¿é—®

4. æ³¨é”€
   â””â”€ é”€æ¯å‡­è¯
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šSessionè®¤è¯æ·±åº¦å®æˆ˜

### 2.1 Sessionå·¥ä½œåŸç†

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”          1. Login          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚ Server â”‚
â”‚        â”‚                             â”‚        â”‚
â”‚        â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚        â”‚
â”‚        â”‚   2. Set-Cookie: sid=xxx    â”‚        â”‚
â”‚        â”‚                             â”‚        â”‚
â”‚        â”‚   3. Cookie: sid=xxx        â”‚        â”‚
â”‚        â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚        â”‚
â”‚        â”‚                             â”‚        â”‚
â”‚        â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜   4. Response with data    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                       â”‚
                                       â”œâ”€ Memory Store
                                       â”œâ”€ Redis Store
                                       â””â”€ Database Store
```

---

### 2.2 å®æˆ˜æ¡ˆä¾‹1ï¼šSessionè®¤è¯å®Œæ•´å®ç°

```go
package main

import (
    "crypto/rand"
    "encoding/base64"
    "fmt"
    "net/http"
    "sync"
    "time"
    
    "github.com/gin-gonic/gin"
)

// ===== Sessionå­˜å‚¨æ¥å£ =====
type SessionStore interface {
    Set(sid string, data map[string]interface{}, expiration time.Duration) error
    Get(sid string) (map[string]interface{}, error)
    Delete(sid string) error
    Exists(sid string) bool
}

// ===== å†…å­˜Sessionå­˜å‚¨ =====
type MemoryStore struct {
    mu       sync.RWMutex
    sessions map[string]*Session
}

type Session struct {
    Data      map[string]interface{}
    ExpiresAt time.Time
}

func NewMemoryStore() *MemoryStore {
    store := &MemoryStore{
        sessions: make(map[string]*Session),
    }
    
    // å®šæœŸæ¸…ç†è¿‡æœŸsession
    go store.cleanup()
    
    return store
}

func (s *MemoryStore) Set(sid string, data map[string]interface{}, expiration time.Duration) error {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    s.sessions[sid] = &Session{
        Data:      data,
        ExpiresAt: time.Now().Add(expiration),
    }
    
    return nil
}

func (s *MemoryStore) Get(sid string) (map[string]interface{}, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    session, exists := s.sessions[sid]
    if !exists {
        return nil, fmt.Errorf("session not found")
    }
    
    if time.Now().After(session.ExpiresAt) {
        return nil, fmt.Errorf("session expired")
    }
    
    return session.Data, nil
}

func (s *MemoryStore) Delete(sid string) error {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    delete(s.sessions, sid)
    return nil
}

func (s *MemoryStore) Exists(sid string) bool {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    session, exists := s.sessions[sid]
    if !exists {
        return false
    }
    
    return time.Now().Before(session.ExpiresAt)
}

func (s *MemoryStore) cleanup() {
    ticker := time.NewTicker(5 * time.Minute)
    defer ticker.Stop()
    
    for range ticker.C {
        s.mu.Lock()
        for sid, session := range s.sessions {
            if time.Now().After(session.ExpiresAt) {
                delete(s.sessions, sid)
            }
        }
        s.mu.Unlock()
    }
}

// ===== Sessionç®¡ç†å™¨ =====
type SessionManager struct {
    store      SessionStore
    cookieName string
    expiration time.Duration
}

func NewSessionManager(store SessionStore) *SessionManager {
    return &SessionManager{
        store:      store,
        cookieName: "session_id",
        expiration: 24 * time.Hour,
    }
}

// ç”ŸæˆSession ID
func (sm *SessionManager) generateSID() (string, error) {
    b := make([]byte, 32)
    if _, err := rand.Read(b); err != nil {
        return "", err
    }
    return base64.URLEncoding.EncodeToString(b), nil
}

// åˆ›å»ºSession
func (sm *SessionManager) Create(c *gin.Context, data map[string]interface{}) (string, error) {
    sid, err := sm.generateSID()
    if err != nil {
        return "", err
    }
    
    if err := sm.store.Set(sid, data, sm.expiration); err != nil {
        return "", err
    }
    
    // è®¾ç½®Cookie
    c.SetCookie(
        sm.cookieName,
        sid,
        int(sm.expiration.Seconds()),
        "/",
        "",
        false, // secure
        true,  // httpOnly
    )
    
    return sid, nil
}

// è·å–Session
func (sm *SessionManager) Get(c *gin.Context) (map[string]interface{}, error) {
    sid, err := c.Cookie(sm.cookieName)
    if err != nil {
        return nil, err
    }
    
    return sm.store.Get(sid)
}

// é”€æ¯Session
func (sm *SessionManager) Destroy(c *gin.Context) error {
    sid, err := c.Cookie(sm.cookieName)
    if err != nil {
        return err
    }
    
    if err := sm.store.Delete(sid); err != nil {
        return err
    }
    
    // æ¸…é™¤Cookie
    c.SetCookie(sm.cookieName, "", -1, "/", "", false, true)
    
    return nil
}

// ===== ä¸­é—´ä»¶ï¼šSessionè®¤è¯ =====
func (sm *SessionManager) AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        session, err := sm.Get(c)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
            c.Abort()
            return
        }
        
        // å°†ç”¨æˆ·ä¿¡æ¯å­˜å…¥Context
        c.Set("userID", session["userID"])
        c.Set("username", session["username"])
        
        c.Next()
    }
}

// ===== Handlerç¤ºä¾‹ =====
func setupRoutes(r *gin.Engine, sm *SessionManager) {
    // ç™»å½•
    r.POST("/login", func(c *gin.Context) {
        var req struct {
            Username string `json:"username" binding:"required"`
            Password string `json:"password" binding:"required"`
        }
        
        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }
        
        // éªŒè¯ç”¨æˆ·åå¯†ç ï¼ˆç®€åŒ–ç‰ˆï¼‰
        if req.Username != "alice" || req.Password != "password123" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
            return
        }
        
        // åˆ›å»ºSession
        sid, err := sm.Create(c, map[string]interface{}{
            "userID":   1,
            "username": req.Username,
        })
        
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }
        
        c.JSON(http.StatusOK, gin.H{
            "message":    "Login successful",
            "session_id": sid,
        })
    })
    
    // æ³¨é”€
    r.POST("/logout", sm.AuthMiddleware(), func(c *gin.Context) {
        if err := sm.Destroy(c); err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }
        
        c.JSON(http.StatusOK, gin.H{"message": "Logout successful"})
    })
    
    // å—ä¿æŠ¤çš„è·¯ç”±
    r.GET("/profile", sm.AuthMiddleware(), func(c *gin.Context) {
        username := c.GetString("username")
        c.JSON(http.StatusOK, gin.H{
            "username": username,
            "email":    username + "@example.com",
        })
    })
}

func main() {
    r := gin.Default()
    
    store := NewMemoryStore()
    sm := NewSessionManager(store)
    
    setupRoutes(r, sm)
    
    r.Run(":8080")
}
```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šJWTè®¤è¯æ·±åº¦å®æˆ˜

### 3.1 JWTç»“æ„

```text
JWT = Header.Payload.Signature

Header (Base64ç¼–ç ):
{
  "alg": "HS256",
  "typ": "JWT"
}

Payload (Base64ç¼–ç ):
{
  "sub": "user123",
  "name": "Alice",
  "iat": 1516239022,
  "exp": 1516242622
}

Signature (HMAC-SHA256):
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)

å®Œæ•´JWT:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiJ1c2VyMTIzIiwibmFtZSI6IkFsaWNlIiwiaWF0IjoxNTE2MjM5MDIyfQ.
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

---

### 3.2 å®æˆ˜æ¡ˆä¾‹2ï¼šJWTè®¤è¯å®Œæ•´å®ç°

```go
package main

import (
    "fmt"
    "net/http"
    "strings"
    "time"
    
    "github.com/gin-gonic/gin"
    "github.com/golang-jwt/jwt/v5"
)

// ===== JWTé…ç½® =====
var (
    jwtSecret     = []byte("your-secret-key-keep-it-safe")
    jwtExpiration = 24 * time.Hour
)

// ===== JWT Claims =====
type Claims struct {
    UserID   int64  `json:"user_id"`
    Username string `json:"username"`
    Role     string `json:"role"`
    jwt.RegisteredClaims
}

// ===== JWTå·¥å…·å‡½æ•° =====
// ç”ŸæˆJWT Token
func GenerateToken(userID int64, username, role string) (string, error) {
    now := time.Now()
    
    claims := &Claims{
        UserID:   userID,
        Username: username,
        Role:     role,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(now.Add(jwtExpiration)),
            IssuedAt:  jwt.NewNumericDate(now),
            NotBefore: jwt.NewNumericDate(now),
            Issuer:    "my-app",
            Subject:   username,
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(jwtSecret)
}

// è§£æJWT Token
func ParseToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        // éªŒè¯ç­¾åæ–¹æ³•
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
        }
        return jwtSecret, nil
    })
    
    if err != nil {
        return nil, err
    }
    
    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }
    
    return nil, fmt.Errorf("invalid token")
}

// ===== ä¸­é—´ä»¶ï¼šJWTè®¤è¯ =====
func JWTAuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // ä»Authorization Headerè·å–Token
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
            c.Abort()
            return
        }
        
        // æ£€æŸ¥Beareræ ¼å¼
        parts := strings.SplitN(authHeader, " ", 2)
        if len(parts) != 2 || parts[0] != "Bearer" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authorization header format"})
            c.Abort()
            return
        }
        
        tokenString := parts[1]
        
        // è§£æToken
        claims, err := ParseToken(tokenString)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or expired token"})
            c.Abort()
            return
        }
        
        // å°†ç”¨æˆ·ä¿¡æ¯å­˜å…¥Context
        c.Set("userID", claims.UserID)
        c.Set("username", claims.Username)
        c.Set("role", claims.Role)
        
        c.Next()
    }
}

// ===== Tokenåˆ·æ–°æœºåˆ¶ =====
type TokenPair struct {
    AccessToken  string `json:"access_token"`
    RefreshToken string `json:"refresh_token"`
    ExpiresIn    int64  `json:"expires_in"`
}

// ç”ŸæˆTokenå¯¹ï¼ˆAccess + Refreshï¼‰
func GenerateTokenPair(userID int64, username, role string) (*TokenPair, error) {
    // Access Tokenï¼ˆçŸ­æœŸæœ‰æ•ˆï¼Œ1å°æ—¶ï¼‰
    accessClaims := &Claims{
        UserID:   userID,
        Username: username,
        Role:     role,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(1 * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
        },
    }
    
    accessToken := jwt.NewWithClaims(jwt.SigningMethodHS256, accessClaims)
    accessTokenString, err := accessToken.SignedString(jwtSecret)
    if err != nil {
        return nil, err
    }
    
    // Refresh Tokenï¼ˆé•¿æœŸæœ‰æ•ˆï¼Œ7å¤©ï¼‰
    refreshClaims := &Claims{
        UserID:   userID,
        Username: username,
        Role:     role,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(7 * 24 * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
        },
    }
    
    refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshClaims)
    refreshTokenString, err := refreshToken.SignedString(jwtSecret)
    if err != nil {
        return nil, err
    }
    
    return &TokenPair{
        AccessToken:  accessTokenString,
        RefreshToken: refreshTokenString,
        ExpiresIn:    3600, // 1å°æ—¶
    }, nil
}

// ===== Handlerç¤ºä¾‹ =====
func setupJWTRoutes(r *gin.Engine) {
    // ç™»å½•
    r.POST("/api/login", func(c *gin.Context) {
        var req struct {
            Username string `json:"username" binding:"required"`
            Password string `json:"password" binding:"required"`
        }
        
        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }
        
        // éªŒè¯ç”¨æˆ·åå¯†ç ï¼ˆç®€åŒ–ç‰ˆï¼‰
        if req.Username != "alice" || req.Password != "password123" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
            return
        }
        
        // ç”ŸæˆTokenå¯¹
        tokenPair, err := GenerateTokenPair(1, req.Username, "admin")
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }
        
        c.JSON(http.StatusOK, tokenPair)
    })
    
    // åˆ·æ–°Token
    r.POST("/api/refresh", func(c *gin.Context) {
        var req struct {
            RefreshToken string `json:"refresh_token" binding:"required"`
        }
        
        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }
        
        // è§£æRefresh Token
        claims, err := ParseToken(req.RefreshToken)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid refresh token"})
            return
        }
        
        // ç”Ÿæˆæ–°çš„Tokenå¯¹
        tokenPair, err := GenerateTokenPair(claims.UserID, claims.Username, claims.Role)
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }
        
        c.JSON(http.StatusOK, tokenPair)
    })
    
    // å—ä¿æŠ¤çš„è·¯ç”±
    api := r.Group("/api")
    api.Use(JWTAuthMiddleware())
    {
        api.GET("/profile", func(c *gin.Context) {
            username := c.GetString("username")
            role := c.GetString("role")
            
            c.JSON(http.StatusOK, gin.H{
                "username": username,
                "role":     role,
            })
        })
    }
}

func main() {
    r := gin.Default()
    setupJWTRoutes(r)
    r.Run(":8080")
}
```

---

## ç¬¬å››éƒ¨åˆ†ï¼šOAuth2.0å®Œæ•´å®ç°

### 4.1 OAuth2.0æˆæƒæµç¨‹

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             OAuth2.0 æˆæƒç æµç¨‹                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. ç”¨æˆ·è¯·æ±‚æˆæƒ
   Client â”€â”€â”€â”€â”€> Authorization Server
   
2. ç”¨æˆ·åŒæ„æˆæƒ
   Authorization Server â”€â”€â”€â”€â”€> Client (Authorization Code)
   
3. å®¢æˆ·ç«¯è¯·æ±‚Access Token
   Client â”€â”€â”€â”€â”€> Authorization Server (Authorization Code)
   
4. è¿”å›Access Token
   Authorization Server â”€â”€â”€â”€â”€> Client (Access Token)
   
5. å®¢æˆ·ç«¯è®¿é—®èµ„æº
   Client â”€â”€â”€â”€â”€> Resource Server (Access Token)
   
6. è¿”å›å—ä¿æŠ¤èµ„æº
   Resource Server â”€â”€â”€â”€â”€> Client
```

---

### 4.2 å®æˆ˜æ¡ˆä¾‹3ï¼šOAuth2.0æˆæƒæœåŠ¡å™¨

```go
package main

import (
    "crypto/rand"
    "encoding/base64"
    "fmt"
    "net/http"
    "sync"
    "time"
    
    "github.com/gin-gonic/gin"
)

// ===== OAuth2.0æ•°æ®ç»“æ„ =====
type Client struct {
    ClientID     string
    ClientSecret string
    RedirectURIs []string
}

type AuthorizationCode struct {
    Code      string
    ClientID  string
    UserID    int64
    Scope     string
    ExpiresAt time.Time
}

type AccessToken struct {
    Token     string
    ClientID  string
    UserID    int64
    Scope     string
    ExpiresAt time.Time
}

// ===== OAuth2.0æœåŠ¡å™¨ =====
type OAuth2Server struct {
    mu                sync.RWMutex
    clients           map[string]*Client
    authorizationCode map[string]*AuthorizationCode
    accessTokens      map[string]*AccessToken
}

func NewOAuth2Server() *OAuth2Server {
    server := &OAuth2Server{
        clients:           make(map[string]*Client),
        authorizationCodes: make(map[string]*AuthorizationCode),
        accessTokens:      make(map[string]*AccessToken),
    }
    
    // æ³¨å†Œç¤ºä¾‹å®¢æˆ·ç«¯
    server.RegisterClient(&Client{
        ClientID:     "client123",
        ClientSecret: "secret456",
        RedirectURIs: []string{"http://localhost:3000/callback"},
    })
    
    return server
}

func (s *OAuth2Server) RegisterClient(client *Client) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.clients[client.ClientID] = client
}

// ç”Ÿæˆéšæœºå­—ç¬¦ä¸²
func generateRandomString(length int) (string, error) {
    b := make([]byte, length)
    if _, err := rand.Read(b); err != nil {
        return "", err
    }
    return base64.URLEncoding.EncodeToString(b)[:length], nil
}

// æˆæƒç«¯ç‚¹
func (s *OAuth2Server) Authorize(c *gin.Context) {
    clientID := c.Query("client_id")
    redirectURI := c.Query("redirect_uri")
    responseType := c.Query("response_type")
    scope := c.Query("scope")
    state := c.Query("state")
    
    // éªŒè¯client_id
    s.mu.RLock()
    client, exists := s.clients[clientID]
    s.mu.RUnlock()
    
    if !exists {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid_client"})
        return
    }
    
    // éªŒè¯redirect_uri
    validURI := false
    for _, uri := range client.RedirectURIs {
        if uri == redirectURI {
            validURI = true
            break
        }
    }
    
    if !validURI {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid_redirect_uri"})
        return
    }
    
    // æ£€æŸ¥response_type
    if responseType != "code" {
        c.Redirect(http.StatusFound, fmt.Sprintf("%s?error=unsupported_response_type&state=%s", redirectURI, state))
        return
    }
    
    // æ˜¾ç¤ºæˆæƒé¡µé¢ï¼ˆç®€åŒ–ç‰ˆï¼šç›´æ¥æˆæƒï¼‰
    // åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œè¿™é‡Œåº”è¯¥æ˜¾ç¤ºæˆæƒç¡®è®¤é¡µé¢
    userID := int64(1) // å‡è®¾ç”¨æˆ·å·²ç™»å½•
    
    // ç”Ÿæˆæˆæƒç 
    code, _ := generateRandomString(32)
    s.mu.Lock()
    s.authorizationCodes[code] = &AuthorizationCode{
        Code:      code,
        ClientID:  clientID,
        UserID:    userID,
        Scope:     scope,
        ExpiresAt: time.Now().Add(10 * time.Minute),
    }
    s.mu.Unlock()
    
    // é‡å®šå‘å›å®¢æˆ·ç«¯
    c.Redirect(http.StatusFound, fmt.Sprintf("%s?code=%s&state=%s", redirectURI, code, state))
}

// Tokenç«¯ç‚¹
func (s *OAuth2Server) Token(c *gin.Context) {
    grantType := c.PostForm("grant_type")
    
    switch grantType {
    case "authorization_code":
        s.handleAuthorizationCodeGrant(c)
    case "refresh_token":
        s.handleRefreshTokenGrant(c)
    default:
        c.JSON(http.StatusBadRequest, gin.H{"error": "unsupported_grant_type"})
    }
}

func (s *OAuth2Server) handleAuthorizationCodeGrant(c *gin.Context) {
    code := c.PostForm("code")
    clientID := c.PostForm("client_id")
    clientSecret := c.PostForm("client_secret")
    redirectURI := c.PostForm("redirect_uri")
    
    // éªŒè¯å®¢æˆ·ç«¯å‡­è¯
    s.mu.RLock()
    client, exists := s.clients[clientID]
    s.mu.RUnlock()
    
    if !exists || client.ClientSecret != clientSecret {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid_client"})
        return
    }
    
    // éªŒè¯æˆæƒç 
    s.mu.Lock()
    authCode, exists := s.authorizationCodes[code]
    if !exists {
        s.mu.Unlock()
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid_grant"})
        return
    }
    
    // æ£€æŸ¥æˆæƒç æ˜¯å¦è¿‡æœŸ
    if time.Now().After(authCode.ExpiresAt) {
        delete(s.authorizationCodes, code)
        s.mu.Unlock()
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid_grant"})
        return
    }
    
    // æˆæƒç åªèƒ½ä½¿ç”¨ä¸€æ¬¡
    delete(s.authorizationCodes, code)
    
    // ç”ŸæˆAccess Token
    tokenString, _ := generateRandomString(32)
    s.accessTokens[tokenString] = &AccessToken{
        Token:     tokenString,
        ClientID:  clientID,
        UserID:    authCode.UserID,
        Scope:     authCode.Scope,
        ExpiresAt: time.Now().Add(1 * time.Hour),
    }
    s.mu.Unlock()
    
    c.JSON(http.StatusOK, gin.H{
        "access_token": tokenString,
        "token_type":   "Bearer",
        "expires_in":   3600,
        "scope":        authCode.Scope,
    })
}

func (s *OAuth2Server) handleRefreshTokenGrant(c *gin.Context) {
    // åˆ·æ–°Tokenå®ç°
    c.JSON(http.StatusOK, gin.H{"message": "refresh token grant"})
}

// éªŒè¯Access Token
func (s *OAuth2Server) ValidateToken(tokenString string) (*AccessToken, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    token, exists := s.accessTokens[tokenString]
    if !exists {
        return nil, fmt.Errorf("invalid token")
    }
    
    if time.Now().After(token.ExpiresAt) {
        return nil, fmt.Errorf("token expired")
    }
    
    return token, nil
}

func main() {
    r := gin.Default()
    server := NewOAuth2Server()
    
    // OAuth2.0ç«¯ç‚¹
    r.GET("/oauth/authorize", server.Authorize)
    r.POST("/oauth/token", server.Token)
    
    // å—ä¿æŠ¤çš„èµ„æº
    r.GET("/api/userinfo", func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "missing token"})
            return
        }
        
        tokenString := authHeader[len("Bearer "):]
        token, err := server.ValidateToken(tokenString)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
            return
        }
        
        c.JSON(http.StatusOK, gin.H{
            "user_id": token.UserID,
            "scope":   token.Scope,
        })
    })
    
    r.Run(":8080")
}
```

---

## ç¬¬äº”éƒ¨åˆ†ï¼šRBACæƒé™æ§åˆ¶

### 5.1 RBACæ¨¡å‹

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              RBACæ¨¡å‹                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

User â”€â”€â”€â”€â”€> Role â”€â”€â”€â”€â”€> Permission â”€â”€â”€â”€â”€> Resource

ç”¨æˆ·     â†’  è§’è‰²    â†’  æƒé™        â†’  èµ„æº

ç¤ºä¾‹:
Alice   â†’  Admin   â†’  user:create  â†’  /api/users
Bob     â†’  Editor  â†’  post:edit    â†’  /api/posts
Charlie â†’  Viewer  â†’  post:read    â†’  /api/posts
```

---

### 5.2 å®æˆ˜æ¡ˆä¾‹4ï¼šRBACå®Œæ•´å®ç°

```go
package main

import (
    "fmt"
    "net/http"
    "strings"
    
    "github.com/gin-gonic/gin"
)

// ===== RBACæ•°æ®æ¨¡å‹ =====
type User struct {
    ID    int64
    Name  string
    Roles []string
}

type Role struct {
    Name        string
    Permissions []string
}

type Permission struct {
    Resource string // èµ„æºï¼Œå¦‚ "users", "posts"
    Action   string // æ“ä½œï¼Œå¦‚ "create", "read", "update", "delete"
}

// ===== RBACç®¡ç†å™¨ =====
type RBACManager struct {
    roles       map[string]*Role
    userRoles   map[int64][]string
    permissions map[string][]Permission
}

func NewRBACManager() *RBACManager {
    manager := &RBACManager{
        roles:       make(map[string]*Role),
        userRoles:   make(map[int64][]string),
        permissions: make(map[string][]Permission),
    }
    
    // åˆå§‹åŒ–è§’è‰²å’Œæƒé™
    manager.setupDefaultRoles()
    
    return manager
}

func (m *RBACManager) setupDefaultRoles() {
    // Adminè§’è‰²ï¼šæ‰€æœ‰æƒé™
    m.AddRole(&Role{
        Name: "admin",
        Permissions: []string{
            "users:create", "users:read", "users:update", "users:delete",
            "posts:create", "posts:read", "posts:update", "posts:delete",
        },
    })
    
    // Editorè§’è‰²ï¼šç¼–è¾‘æƒé™
    m.AddRole(&Role{
        Name: "editor",
        Permissions: []string{
            "posts:create", "posts:read", "posts:update",
            "users:read",
        },
    })
    
    // Viewerè§’è‰²ï¼šåªè¯»æƒé™
    m.AddRole(&Role{
        Name: "viewer",
        Permissions: []string{
            "posts:read",
            "users:read",
        },
    })
    
    // åˆ†é…ç”¨æˆ·è§’è‰²
    m.AssignRole(1, "admin")
    m.AssignRole(2, "editor")
    m.AssignRole(3, "viewer")
}

func (m *RBACManager) AddRole(role *Role) {
    m.roles[role.Name] = role
    
    for _, perm := range role.Permissions {
        parts := strings.Split(perm, ":")
        if len(parts) == 2 {
            m.permissions[role.Name] = append(m.permissions[role.Name], Permission{
                Resource: parts[0],
                Action:   parts[1],
            })
        }
    }
}

func (m *RBACManager) AssignRole(userID int64, roleName string) {
    m.userRoles[userID] = append(m.userRoles[userID], roleName)
}

// æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™
func (m *RBACManager) HasPermission(userID int64, resource, action string) bool {
    roles, exists := m.userRoles[userID]
    if !exists {
        return false
    }
    
    for _, roleName := range roles {
        permissions, exists := m.permissions[roleName]
        if !exists {
            continue
        }
        
        for _, perm := range permissions {
            if perm.Resource == resource && perm.Action == action {
                return true
            }
        }
    }
    
    return false
}

// è·å–ç”¨æˆ·æ‰€æœ‰æƒé™
func (m *RBACManager) GetUserPermissions(userID int64) []string {
    var permissions []string
    
    roles, exists := m.userRoles[userID]
    if !exists {
        return permissions
    }
    
    seen := make(map[string]bool)
    for _, roleName := range roles {
        role, exists := m.roles[roleName]
        if !exists {
            continue
        }
        
        for _, perm := range role.Permissions {
            if !seen[perm] {
                permissions = append(permissions, perm)
                seen[perm] = true
            }
        }
    }
    
    return permissions
}

// ===== ä¸­é—´ä»¶ï¼šRBACæƒé™æ£€æŸ¥ =====
func (m *RBACManager) RequirePermission(resource, action string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // ä»Contextè·å–ç”¨æˆ·IDï¼ˆå‡è®¾å·²é€šè¿‡JWTè®¤è¯ä¸­é—´ä»¶ï¼‰
        userID, exists := c.Get("userID")
        if !exists {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
            c.Abort()
            return
        }
        
        uid := userID.(int64)
        
        // æ£€æŸ¥æƒé™
        if !m.HasPermission(uid, resource, action) {
            c.JSON(http.StatusForbidden, gin.H{"error": "Permission denied"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}

// ===== Handlerç¤ºä¾‹ =====
func setupRBACRoutes(r *gin.Engine, rbac *RBACManager) {
    // æ¨¡æ‹ŸJWTè®¤è¯ä¸­é—´ä»¶
    mockAuth := func() gin.HandlerFunc {
        return func(c *gin.Context) {
            // ä»Headerè·å–ç”¨æˆ·IDï¼ˆç®€åŒ–ç‰ˆï¼‰
            userIDStr := c.GetHeader("X-User-ID")
            if userIDStr == "" {
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing X-User-ID header"})
                c.Abort()
                return
            }
            
            var userID int64
            fmt.Sscanf(userIDStr, "%d", &userID)
            c.Set("userID", userID)
            
            c.Next()
        }
    }
    
    api := r.Group("/api")
    api.Use(mockAuth())
    {
        // ç”¨æˆ·ç®¡ç†ï¼ˆéœ€è¦users:createæƒé™ï¼‰
        api.POST("/users", rbac.RequirePermission("users", "create"), func(c *gin.Context) {
            c.JSON(http.StatusOK, gin.H{"message": "User created"})
        })
        
        // æŸ¥çœ‹ç”¨æˆ·ï¼ˆéœ€è¦users:readæƒé™ï¼‰
        api.GET("/users", rbac.RequirePermission("users", "read"), func(c *gin.Context) {
            c.JSON(http.StatusOK, gin.H{"users": []string{"alice", "bob"}})
        })
        
        // æ–‡ç« ç®¡ç†ï¼ˆéœ€è¦posts:createæƒé™ï¼‰
        api.POST("/posts", rbac.RequirePermission("posts", "create"), func(c *gin.Context) {
            c.JSON(http.StatusOK, gin.H{"message": "Post created"})
        })
        
        // æŸ¥çœ‹æ–‡ç« ï¼ˆéœ€è¦posts:readæƒé™ï¼‰
        api.GET("/posts", rbac.RequirePermission("posts", "read"), func(c *gin.Context) {
            c.JSON(http.StatusOK, gin.H{"posts": []string{"post1", "post2"}})
        })
        
        // æŸ¥çœ‹ç”¨æˆ·æƒé™
        api.GET("/me/permissions", func(c *gin.Context) {
            userID := c.GetInt64("userID")
            permissions := rbac.GetUserPermissions(userID)
            c.JSON(http.StatusOK, gin.H{"permissions": permissions})
        })
    }
}

func main() {
    r := gin.Default()
    rbac := NewRBACManager()
    
    setupRBACRoutes(r, rbac)
    
    r.Run(":8080")
}

/*
æµ‹è¯•å‘½ä»¤:
# Adminç”¨æˆ·ï¼ˆuserID=1ï¼‰åˆ›å»ºç”¨æˆ·
curl -H "X-User-ID: 1" -X POST http://localhost:8080/api/users

# Editorç”¨æˆ·ï¼ˆuserID=2ï¼‰å°è¯•åˆ›å»ºç”¨æˆ·ï¼ˆå¤±è´¥ï¼‰
curl -H "X-User-ID: 2" -X POST http://localhost:8080/api/users

# Viewerç”¨æˆ·ï¼ˆuserID=3ï¼‰æŸ¥çœ‹æ–‡ç« 
curl -H "X-User-ID: 3" http://localhost:8080/api/posts

# æŸ¥çœ‹ç”¨æˆ·æƒé™
curl -H "X-User-ID: 1" http://localhost:8080/api/me/permissions
*/
```

---

## ç¬¬å…­éƒ¨åˆ†ï¼šå¯†ç åŠ å¯†ä¸å®‰å…¨

### 6.1 å¯†ç åŠ å¯†æœ€ä½³å®è·µ

```go
package main

import (
    "crypto/rand"
    "encoding/base64"
    "fmt"
    
    "golang.org/x/crypto/bcrypt"
    "golang.org/x/crypto/argon2"
)

// ===== 1. BcryptåŠ å¯†ï¼ˆæ¨èï¼‰=====
// å“ˆå¸Œå¯†ç 
func HashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    return string(bytes), err
}

// éªŒè¯å¯†ç 
func CheckPassword(password, hash string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}

// ===== 2. Argon2åŠ å¯†ï¼ˆæ›´å®‰å…¨ï¼‰=====
type Argon2Params struct {
    Memory      uint32
    Iterations  uint32
    Parallelism uint8
    SaltLength  uint32
    KeyLength   uint32
}

var DefaultArgon2Params = &Argon2Params{
    Memory:      64 * 1024, // 64 MB
    Iterations:  3,
    Parallelism: 2,
    SaltLength:  16,
    KeyLength:   32,
}

func Argon2Hash(password string, params *Argon2Params) (string, error) {
    // ç”Ÿæˆéšæœºsalt
    salt := make([]byte, params.SaltLength)
    if _, err := rand.Read(salt); err != nil {
        return "", err
    }
    
    // ç”Ÿæˆhash
    hash := argon2.IDKey(
        []byte(password),
        salt,
        params.Iterations,
        params.Memory,
        params.Parallelism,
        params.KeyLength,
    )
    
    // ç¼–ç ä¸ºbase64
    b64Salt := base64.RawStdEncoding.EncodeToString(salt)
    b64Hash := base64.RawStdEncoding.EncodeToString(hash)
    
    // æ ¼å¼: $argon2id$v=19$m=65536,t=3,p=2$salt$hash
    encodedHash := fmt.Sprintf("$argon2id$v=19$m=%d,t=%d,p=%d$%s$%s",
        params.Memory, params.Iterations, params.Parallelism, b64Salt, b64Hash)
    
    return encodedHash, nil
}

// ===== 3. å¯†ç å¼ºåº¦æ£€æŸ¥ =====
import (
    "regexp"
    "unicode"
)

func ValidatePasswordStrength(password string) []string {
    var errors []string
    
    // æœ€å°é•¿åº¦
    if len(password) < 8 {
        errors = append(errors, "å¯†ç é•¿åº¦è‡³å°‘8ä½")
    }
    
    // åŒ…å«å¤§å†™å­—æ¯
    if !regexp.MustCompile(`[A-Z]`).MatchString(password) {
        errors = append(errors, "å¯†ç å¿…é¡»åŒ…å«å¤§å†™å­—æ¯")
    }
    
    // åŒ…å«å°å†™å­—æ¯
    if !regexp.MustCompile(`[a-z]`).MatchString(password) {
        errors = append(errors, "å¯†ç å¿…é¡»åŒ…å«å°å†™å­—æ¯")
    }
    
    // åŒ…å«æ•°å­—
    if !regexp.MustCompile(`[0-9]`).MatchString(password) {
        errors = append(errors, "å¯†ç å¿…é¡»åŒ…å«æ•°å­—")
    }
    
    // åŒ…å«ç‰¹æ®Šå­—ç¬¦
    hasSpecial := false
    for _, char := range password {
        if unicode.IsPunct(char) || unicode.IsSymbol(char) {
            hasSpecial = true
            break
        }
    }
    if !hasSpecial {
        errors = append(errors, "å¯†ç å¿…é¡»åŒ…å«ç‰¹æ®Šå­—ç¬¦")
    }
    
    return errors
}

func main() {
    // æµ‹è¯•Bcrypt
    password := "MySecurePassword123!"
    
    hash, _ := HashPassword(password)
    fmt.Printf("Bcrypt Hash: %s\n", hash)
    fmt.Printf("éªŒè¯å¯†ç : %v\n", CheckPassword(password, hash))
    
    // æµ‹è¯•å¯†ç å¼ºåº¦
    errors := ValidatePasswordStrength("weak")
    if len(errors) > 0 {
        fmt.Println("å¯†ç å¼ºåº¦ä¸è¶³:")
        for _, err := range errors {
            fmt.Printf("  - %s\n", err)
        }
    }
}
```

---

## ğŸ¯ æ€»ç»“

### è®¤è¯æˆæƒæ ¸å¿ƒè¦ç‚¹

1. **Sessionè®¤è¯** - Cookie+æœåŠ¡ç«¯å­˜å‚¨
2. **JWTè®¤è¯** - æ— çŠ¶æ€Token
3. **OAuth2.0** - ç¬¬ä¸‰æ–¹æˆæƒ
4. **RBAC** - åŸºäºè§’è‰²çš„æƒé™æ§åˆ¶
5. **å¯†ç å®‰å…¨** - Bcrypt/Argon2åŠ å¯†
6. **APIå¯†é’¥** - æœåŠ¡é—´è®¤è¯
7. **MFA** - å¤šå› ç´ è®¤è¯å¢å¼ºå®‰å…¨
8. **SSO** - å•ç‚¹ç™»å½•
9. **å®‰å…¨æœ€ä½³å®è·µ** - HTTPSã€CSRFã€XSSé˜²æŠ¤

### æœ€ä½³å®è·µæ¸…å•

```text
âœ… ä½¿ç”¨HTTPSä¼ è¾“æ•æ„Ÿæ•°æ®
âœ… å¯†ç ä½¿ç”¨Bcrypt/Argon2åŠ å¯†
âœ… JWTä½¿ç”¨å¼ºéšæœºå¯†é’¥
âœ… Tokenè®¾ç½®åˆç†è¿‡æœŸæ—¶é—´
âœ… å®ç°Tokenåˆ·æ–°æœºåˆ¶
âœ… ä½¿ç”¨RBACè¿›è¡Œç»†ç²’åº¦æƒé™æ§åˆ¶
âœ… å®æ–½å¯†ç å¼ºåº¦ç­–ç•¥
âœ… é˜²æ­¢æš´åŠ›ç ´è§£ï¼ˆé™æµ+éªŒè¯ç ï¼‰
âœ… è®°å½•å®¡è®¡æ—¥å¿—
âœ… å®šæœŸæ›´æ–°ä¾èµ–åº“
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v12.0  
**æœ€åæ›´æ–°**: 2025-10-20

<div align="center">

Made with â¤ï¸ for Go Security Developers

[â¬† å›åˆ°é¡¶éƒ¨](#goè®¤è¯ä¸æˆæƒæ·±åº¦å®æˆ˜æŒ‡å—)

</div>
