# Go认证与授权深度实战指南

**字数**: ~38,000字  
**代码示例**: 120+个完整示例  
**实战案例**: 9个端到端案例  
**适用人群**: 中级到高级Go开发者

---

## 📚 目录

<!-- TOC -->
- [第一部分：认证授权基础理论](#第一部分认证授权基础理论)
- [第二部分：Session认证深度实战](#第二部分session认证深度实战)
- [第三部分：JWT认证深度实战](#第三部分jwt认证深度实战)
- [第四部分：OAuth2.0完整实现](#第四部分oauth20完整实现)
- [第五部分：RBAC权限控制](#第五部分rbac权限控制)
- [第六部分：密码加密与安全](#第六部分密码加密与安全)
- [第七部分：API密钥认证](#第七部分api密钥认证)
- [第八部分：多因素认证MFA](#第八部分多因素认证mfa)
- [第九部分：单点登录SSO](#第九部分单点登录sso)
- [第十部分：安全最佳实践](#第十部分安全最佳实践)
- [第十一部分：完整项目实战](#第十一部分完整项目实战)
<!-- TOC -->

---

## 第一部分：认证授权基础理论

### 核心概念

```text
认证（Authentication）: 验证"你是谁" - Who are you?
授权（Authorization）: 验证"你能做什么" - What can you do?

认证方式:
✅ Session-Cookie 认证
✅ Token 认证（JWT）
✅ OAuth2.0 授权
✅ API Key 认证
✅ 多因素认证（MFA）

授权模型:
✅ RBAC（基于角色）
✅ ABAC（基于属性）
✅ ACL（访问控制列表）
```

---

### 认证授权流程

```text
┌─────────────────────────────────────────────────┐
│              认证授权完整流程                    │
└─────────────────────────────────────────────────┘

1. 用户登录
   ├─ 输入用户名/密码
   ├─ 验证凭证
   └─ 生成凭证（Session/Token）

2. 认证检查
   ├─ 提取凭证
   ├─ 验证凭证有效性
   └─ 识别用户身份

3. 授权检查
   ├─ 获取用户权限
   ├─ 检查资源权限
   └─ 允许/拒绝访问

4. 注销
   └─ 销毁凭证
```

---

## 第二部分：Session认证深度实战

### Session工作原理

```text
┌────────┐          1. Login          ┌────────┐
│ Client │ ─────────────────────────> │ Server │
│        │                             │        │
│        │ <───────────────────────── │        │
│        │   2. Set-Cookie: sid=xxx    │        │
│        │                             │        │
│        │   3. Cookie: sid=xxx        │        │
│        │ ─────────────────────────> │        │
│        │                             │        │
│        │ <───────────────────────── │        │
└────────┘   4. Response with data    └────────┘
                                       │
                                       ├─ Memory Store
                                       ├─ Redis Store
                                       └─ Database Store
```

---

### 实战案例1：Session认证完整实现

```go
package main

import (
    "crypto/rand"
    "encoding/base64"
    "fmt"
    "net/http"
    "sync"
    "time"
    
    "github.com/gin-gonic/gin"
)

// ===== Session存储接口 =====
type SessionStore interface {
    Set(sid string, data map[string]interface{}, expiration time.Duration) error
    Get(sid string) (map[string]interface{}, error)
    Delete(sid string) error
    Exists(sid string) bool
}

// ===== 内存Session存储 =====
type MemoryStore struct {
    mu       sync.RWMutex
    sessions map[string]*Session
}

type Session struct {
    Data      map[string]interface{}
    ExpiresAt time.Time
}

func NewMemoryStore() *MemoryStore {
    store := &MemoryStore{
        sessions: make(map[string]*Session),
    }
    
    // 定期清理过期session
    go store.cleanup()
    
    return store
}

func (s *MemoryStore) Set(sid string, data map[string]interface{}, expiration time.Duration) error {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    s.sessions[sid] = &Session{
        Data:      data,
        ExpiresAt: time.Now().Add(expiration),
    }
    
    return nil
}

func (s *MemoryStore) Get(sid string) (map[string]interface{}, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    session, exists := s.sessions[sid]
    if !exists {
        return nil, fmt.Errorf("session not found")
    }
    
    if time.Now().After(session.ExpiresAt) {
        return nil, fmt.Errorf("session expired")
    }
    
    return session.Data, nil
}

func (s *MemoryStore) Delete(sid string) error {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    delete(s.sessions, sid)
    return nil
}

func (s *MemoryStore) Exists(sid string) bool {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    session, exists := s.sessions[sid]
    if !exists {
        return false
    }
    
    return time.Now().Before(session.ExpiresAt)
}

func (s *MemoryStore) cleanup() {
    ticker := time.NewTicker(5 * time.Minute)
    defer ticker.Stop()
    
    for range ticker.C {
        s.mu.Lock()
        for sid, session := range s.sessions {
            if time.Now().After(session.ExpiresAt) {
                delete(s.sessions, sid)
            }
        }
        s.mu.Unlock()
    }
}

// ===== Session管理器 =====
type SessionManager struct {
    store      SessionStore
    cookieName string
    expiration time.Duration
}

func NewSessionManager(store SessionStore) *SessionManager {
    return &SessionManager{
        store:      store,
        cookieName: "session_id",
        expiration: 24 * time.Hour,
    }
}

// 生成Session ID
func (sm *SessionManager) generateSID() (string, error) {
    b := make([]byte, 32)
    if _, err := rand.Read(b); err != nil {
        return "", err
    }
    return base64.URLEncoding.EncodeToString(b), nil
}

// 创建Session
func (sm *SessionManager) Create(c *gin.Context, data map[string]interface{}) (string, error) {
    sid, err := sm.generateSID()
    if err != nil {
        return "", err
    }
    
    if err := sm.store.Set(sid, data, sm.expiration); err != nil {
        return "", err
    }
    
    // 设置Cookie
    c.SetCookie(
        sm.cookieName,
        sid,
        int(sm.expiration.Seconds()),
        "/",
        "",
        false, // secure
        true,  // httpOnly
    )
    
    return sid, nil
}

// 获取Session
func (sm *SessionManager) Get(c *gin.Context) (map[string]interface{}, error) {
    sid, err := c.Cookie(sm.cookieName)
    if err != nil {
        return nil, err
    }
    
    return sm.store.Get(sid)
}

// 销毁Session
func (sm *SessionManager) Destroy(c *gin.Context) error {
    sid, err := c.Cookie(sm.cookieName)
    if err != nil {
        return err
    }
    
    if err := sm.store.Delete(sid); err != nil {
        return err
    }
    
    // 清除Cookie
    c.SetCookie(sm.cookieName, "", -1, "/", "", false, true)
    
    return nil
}

// ===== 中间件：Session认证 =====
func (sm *SessionManager) AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        session, err := sm.Get(c)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
            c.Abort()
            return
        }
        
        // 将用户信息存入Context
        c.Set("userID", session["userID"])
        c.Set("username", session["username"])
        
        c.Next()
    }
}

// ===== Handler示例 =====
func setupRoutes(r *gin.Engine, sm *SessionManager) {
    // 登录
    r.POST("/login", func(c *gin.Context) {
        var req struct {
            Username string `json:"username" binding:"required"`
            Password string `json:"password" binding:"required"`
        }
        
        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }
        
        // 验证用户名密码（简化版）
        if req.Username != "alice" || req.Password != "password123" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
            return
        }
        
        // 创建Session
        sid, err := sm.Create(c, map[string]interface{}{
            "userID":   1,
            "username": req.Username,
        })
        
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }
        
        c.JSON(http.StatusOK, gin.H{
            "message":    "Login successful",
            "session_id": sid,
        })
    })
    
    // 注销
    r.POST("/logout", sm.AuthMiddleware(), func(c *gin.Context) {
        if err := sm.Destroy(c); err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }
        
        c.JSON(http.StatusOK, gin.H{"message": "Logout successful"})
    })
    
    // 受保护的路由
    r.GET("/profile", sm.AuthMiddleware(), func(c *gin.Context) {
        username := c.GetString("username")
        c.JSON(http.StatusOK, gin.H{
            "username": username,
            "email":    username + "@example.com",
        })
    })
}

func main() {
    r := gin.Default()
    
    store := NewMemoryStore()
    sm := NewSessionManager(store)
    
    setupRoutes(r, sm)
    
    r.Run(":8080")
}
```

---

## 第三部分：JWT认证深度实战

### JWT结构

```text
JWT = Header.Payload.Signature

Header (Base64编码):
{
  "alg": "HS256",
  "typ": "JWT"
}

Payload (Base64编码):
{
  "sub": "user123",
  "name": "Alice",
  "iat": 1516239022,
  "exp": 1516242622
}

Signature (HMAC-SHA256):
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)

完整JWT:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiJ1c2VyMTIzIiwibmFtZSI6IkFsaWNlIiwiaWF0IjoxNTE2MjM5MDIyfQ.
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

---

### 实战案例2：JWT认证完整实现

```go
package main

import (
    "fmt"
    "net/http"
    "strings"
    "time"
    
    "github.com/gin-gonic/gin"
    "github.com/golang-jwt/jwt/v5"
)

// ===== JWT配置 =====
var (
    jwtSecret     = []byte("your-secret-key-keep-it-safe")
    jwtExpiration = 24 * time.Hour
)

// ===== JWT Claims =====
type Claims struct {
    UserID   int64  `json:"user_id"`
    Username string `json:"username"`
    Role     string `json:"role"`
    jwt.RegisteredClaims
}

// ===== JWT工具函数 =====
// 生成JWT Token
func GenerateToken(userID int64, username, role string) (string, error) {
    now := time.Now()
    
    claims := &Claims{
        UserID:   userID,
        Username: username,
        Role:     role,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(now.Add(jwtExpiration)),
            IssuedAt:  jwt.NewNumericDate(now),
            NotBefore: jwt.NewNumericDate(now),
            Issuer:    "my-app",
            Subject:   username,
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(jwtSecret)
}

// 解析JWT Token
func ParseToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        // 验证签名方法
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
        }
        return jwtSecret, nil
    })
    
    if err != nil {
        return nil, err
    }
    
    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }
    
    return nil, fmt.Errorf("invalid token")
}

// ===== 中间件：JWT认证 =====
func JWTAuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 从Authorization Header获取Token
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
            c.Abort()
            return
        }
        
        // 检查Bearer格式
        parts := strings.SplitN(authHeader, " ", 2)
        if len(parts) != 2 || parts[0] != "Bearer" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authorization header format"})
            c.Abort()
            return
        }
        
        tokenString := parts[1]
        
        // 解析Token
        claims, err := ParseToken(tokenString)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or expired token"})
            c.Abort()
            return
        }
        
        // 将用户信息存入Context
        c.Set("userID", claims.UserID)
        c.Set("username", claims.Username)
        c.Set("role", claims.Role)
        
        c.Next()
    }
}

// ===== Token刷新机制 =====
type TokenPair struct {
    AccessToken  string `json:"access_token"`
    RefreshToken string `json:"refresh_token"`
    ExpiresIn    int64  `json:"expires_in"`
}

// 生成Token对（Access + Refresh）
func GenerateTokenPair(userID int64, username, role string) (*TokenPair, error) {
    // Access Token（短期有效，1小时）
    accessClaims := &Claims{
        UserID:   userID,
        Username: username,
        Role:     role,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(1 * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
        },
    }
    
    accessToken := jwt.NewWithClaims(jwt.SigningMethodHS256, accessClaims)
    accessTokenString, err := accessToken.SignedString(jwtSecret)
    if err != nil {
        return nil, err
    }
    
    // Refresh Token（长期有效，7天）
    refreshClaims := &Claims{
        UserID:   userID,
        Username: username,
        Role:     role,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(7 * 24 * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
        },
    }
    
    refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshClaims)
    refreshTokenString, err := refreshToken.SignedString(jwtSecret)
    if err != nil {
        return nil, err
    }
    
    return &TokenPair{
        AccessToken:  accessTokenString,
        RefreshToken: refreshTokenString,
        ExpiresIn:    3600, // 1小时
    }, nil
}

// ===== Handler示例 =====
func setupJWTRoutes(r *gin.Engine) {
    // 登录
    r.POST("/api/login", func(c *gin.Context) {
        var req struct {
            Username string `json:"username" binding:"required"`
            Password string `json:"password" binding:"required"`
        }
        
        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }
        
        // 验证用户名密码（简化版）
        if req.Username != "alice" || req.Password != "password123" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
            return
        }
        
        // 生成Token对
        tokenPair, err := GenerateTokenPair(1, req.Username, "admin")
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }
        
        c.JSON(http.StatusOK, tokenPair)
    })
    
    // 刷新Token
    r.POST("/api/refresh", func(c *gin.Context) {
        var req struct {
            RefreshToken string `json:"refresh_token" binding:"required"`
        }
        
        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }
        
        // 解析Refresh Token
        claims, err := ParseToken(req.RefreshToken)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid refresh token"})
            return
        }
        
        // 生成新的Token对
        tokenPair, err := GenerateTokenPair(claims.UserID, claims.Username, claims.Role)
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }
        
        c.JSON(http.StatusOK, tokenPair)
    })
    
    // 受保护的路由
    api := r.Group("/api")
    api.Use(JWTAuthMiddleware())
    {
        api.GET("/profile", func(c *gin.Context) {
            username := c.GetString("username")
            role := c.GetString("role")
            
            c.JSON(http.StatusOK, gin.H{
                "username": username,
                "role":     role,
            })
        })
    }
}

func main() {
    r := gin.Default()
    setupJWTRoutes(r)
    r.Run(":8080")
}
```

---

## 第四部分：OAuth2.0完整实现

### OAuth2.0授权流程

```text
┌─────────────────────────────────────────────────────────┐
│             OAuth2.0 授权码流程                          │
└─────────────────────────────────────────────────────────┘

1. 用户请求授权
   Client ─────> Authorization Server
   
2. 用户同意授权
   Authorization Server ─────> Client (Authorization Code)
   
3. 客户端请求Access Token
   Client ─────> Authorization Server (Authorization Code)
   
4. 返回Access Token
   Authorization Server ─────> Client (Access Token)
   
5. 客户端访问资源
   Client ─────> Resource Server (Access Token)
   
6. 返回受保护资源
   Resource Server ─────> Client
```

---

### 实战案例3：OAuth2.0授权服务器

```go
package main

import (
    "crypto/rand"
    "encoding/base64"
    "fmt"
    "net/http"
    "sync"
    "time"
    
    "github.com/gin-gonic/gin"
)

// ===== OAuth2.0数据结构 =====
type Client struct {
    ClientID     string
    ClientSecret string
    RedirectURIs []string
}

type AuthorizationCode struct {
    Code      string
    ClientID  string
    UserID    int64
    Scope     string
    ExpiresAt time.Time
}

type AccessToken struct {
    Token     string
    ClientID  string
    UserID    int64
    Scope     string
    ExpiresAt time.Time
}

// ===== OAuth2.0服务器 =====
type OAuth2Server struct {
    mu                sync.RWMutex
    clients           map[string]*Client
    authorizationCode map[string]*AuthorizationCode
    accessTokens      map[string]*AccessToken
}

func NewOAuth2Server() *OAuth2Server {
 server := &OAuth2Server{
  clients:            make(map[string]*Client),
  authorizationCode:  make(map[string]*AuthorizationCode),
  accessTokens:       make(map[string]*AccessToken),
 }
    
    // 注册示例客户端
    server.RegisterClient(&Client{
        ClientID:     "client123",
        ClientSecret: "secret456",
        RedirectURIs: []string{"http://localhost:3000/callback"},
    })
    
    return server
}

func (s *OAuth2Server) RegisterClient(client *Client) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.clients[client.ClientID] = client
}

// 生成随机字符串
func generateRandomString(length int) (string, error) {
    b := make([]byte, length)
    if _, err := rand.Read(b); err != nil {
        return "", err
    }
    return base64.URLEncoding.EncodeToString(b)[:length], nil
}

// 授权端点
func (s *OAuth2Server) Authorize(c *gin.Context) {
    clientID := c.Query("client_id")
    redirectURI := c.Query("redirect_uri")
    responseType := c.Query("response_type")
    scope := c.Query("scope")
    state := c.Query("state")
    
    // 验证client_id
    s.mu.RLock()
    client, exists := s.clients[clientID]
    s.mu.RUnlock()
    
    if !exists {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid_client"})
        return
    }
    
    // 验证redirect_uri
    validURI := false
    for _, uri := range client.RedirectURIs {
        if uri == redirectURI {
            validURI = true
            break
        }
    }
    
    if !validURI {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid_redirect_uri"})
        return
    }
    
    // 检查response_type
    if responseType != "code" {
        c.Redirect(http.StatusFound, fmt.Sprintf("%s?error=unsupported_response_type&state=%s", redirectURI, state))
        return
    }
    
    // 显示授权页面（简化版：直接授权）
    // 在生产环境中，这里应该显示授权确认页面
    userID := int64(1) // 假设用户已登录
    
 // 生成授权码
 code, _ := generateRandomString(32)
 s.mu.Lock()
 s.authorizationCode[code] = &AuthorizationCode{
  Code:      code,
  ClientID:  clientID,
  UserID:    userID,
  Scope:     scope,
  ExpiresAt: time.Now().Add(10 * time.Minute),
 }
 s.mu.Unlock()
    
    // 重定向回客户端
    c.Redirect(http.StatusFound, fmt.Sprintf("%s?code=%s&state=%s", redirectURI, code, state))
}

// Token端点
func (s *OAuth2Server) Token(c *gin.Context) {
    grantType := c.PostForm("grant_type")
    
    switch grantType {
    case "authorization_code":
        s.handleAuthorizationCodeGrant(c)
    case "refresh_token":
        s.handleRefreshTokenGrant(c)
    default:
        c.JSON(http.StatusBadRequest, gin.H{"error": "unsupported_grant_type"})
    }
}

func (s *OAuth2Server) handleAuthorizationCodeGrant(c *gin.Context) {
    code := c.PostForm("code")
    clientID := c.PostForm("client_id")
    clientSecret := c.PostForm("client_secret")
    redirectURI := c.PostForm("redirect_uri")
    
    // 验证客户端凭证
    s.mu.RLock()
    client, exists := s.clients[clientID]
    s.mu.RUnlock()
    
    if !exists || client.ClientSecret != clientSecret {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid_client"})
        return
    }
    
 // 验证授权码
 s.mu.Lock()
 authCode, exists := s.authorizationCode[code]
 if !exists {
  s.mu.Unlock()
  c.JSON(http.StatusBadRequest, gin.H{"error": "invalid_grant"})
  return
 }
 
 // 检查授权码是否过期
 if time.Now().After(authCode.ExpiresAt) {
  delete(s.authorizationCode, code)
  s.mu.Unlock()
  c.JSON(http.StatusBadRequest, gin.H{"error": "invalid_grant"})
  return
 }
 
 // 授权码只能使用一次
 delete(s.authorizationCode, code)
    
    // 生成Access Token
    tokenString, _ := generateRandomString(32)
    s.accessTokens[tokenString] = &AccessToken{
        Token:     tokenString,
        ClientID:  clientID,
        UserID:    authCode.UserID,
        Scope:     authCode.Scope,
        ExpiresAt: time.Now().Add(1 * time.Hour),
    }
    s.mu.Unlock()
    
    c.JSON(http.StatusOK, gin.H{
        "access_token": tokenString,
        "token_type":   "Bearer",
        "expires_in":   3600,
        "scope":        authCode.Scope,
    })
}

func (s *OAuth2Server) handleRefreshTokenGrant(c *gin.Context) {
    // 刷新Token实现
    c.JSON(http.StatusOK, gin.H{"message": "refresh token grant"})
}

// 验证Access Token
func (s *OAuth2Server) ValidateToken(tokenString string) (*AccessToken, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    token, exists := s.accessTokens[tokenString]
    if !exists {
        return nil, fmt.Errorf("invalid token")
    }
    
    if time.Now().After(token.ExpiresAt) {
        return nil, fmt.Errorf("token expired")
    }
    
    return token, nil
}

func main() {
    r := gin.Default()
    server := NewOAuth2Server()
    
    // OAuth2.0端点
    r.GET("/oauth/authorize", server.Authorize)
    r.POST("/oauth/token", server.Token)
    
    // 受保护的资源
    r.GET("/api/userinfo", func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "missing token"})
            return
        }
        
        tokenString := authHeader[len("Bearer "):]
        token, err := server.ValidateToken(tokenString)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
            return
        }
        
        c.JSON(http.StatusOK, gin.H{
            "user_id": token.UserID,
            "scope":   token.Scope,
        })
    })
    
    r.Run(":8080")
}
```

---

## 第五部分：RBAC权限控制

### RBAC模型

```text
┌─────────────────────────────────────────────────┐
│              RBAC模型                            │
└─────────────────────────────────────────────────┘

User ─────> Role ─────> Permission ─────> Resource

用户     →  角色    →  权限        →  资源

示例:
Alice   →  Admin   →  user:create  →  /api/users
Bob     →  Editor  →  post:edit    →  /api/posts
Charlie →  Viewer  →  post:read    →  /api/posts
```

---

### 实战案例4：RBAC完整实现

```go
package main

import (
    "fmt"
    "net/http"
    "strings"
    
    "github.com/gin-gonic/gin"
)

// ===== RBAC数据模型 =====
type User struct {
    ID    int64
    Name  string
    Roles []string
}

type Role struct {
    Name        string
    Permissions []string
}

type Permission struct {
    Resource string // 资源，如 "users", "posts"
    Action   string // 操作，如 "create", "read", "update", "delete"
}

// ===== RBAC管理器 =====
type RBACManager struct {
    roles       map[string]*Role
    userRoles   map[int64][]string
    permissions map[string][]Permission
}

func NewRBACManager() *RBACManager {
    manager := &RBACManager{
        roles:       make(map[string]*Role),
        userRoles:   make(map[int64][]string),
        permissions: make(map[string][]Permission),
    }
    
    // 初始化角色和权限
    manager.setupDefaultRoles()
    
    return manager
}

func (m *RBACManager) setupDefaultRoles() {
    // Admin角色：所有权限
    m.AddRole(&Role{
        Name: "admin",
        Permissions: []string{
            "users:create", "users:read", "users:update", "users:delete",
            "posts:create", "posts:read", "posts:update", "posts:delete",
        },
    })
    
    // Editor角色：编辑权限
    m.AddRole(&Role{
        Name: "editor",
        Permissions: []string{
            "posts:create", "posts:read", "posts:update",
            "users:read",
        },
    })
    
    // Viewer角色：只读权限
    m.AddRole(&Role{
        Name: "viewer",
        Permissions: []string{
            "posts:read",
            "users:read",
        },
    })
    
    // 分配用户角色
    m.AssignRole(1, "admin")
    m.AssignRole(2, "editor")
    m.AssignRole(3, "viewer")
}

func (m *RBACManager) AddRole(role *Role) {
    m.roles[role.Name] = role
    
    for _, perm := range role.Permissions {
        parts := strings.Split(perm, ":")
        if len(parts) == 2 {
            m.permissions[role.Name] = append(m.permissions[role.Name], Permission{
                Resource: parts[0],
                Action:   parts[1],
            })
        }
    }
}

func (m *RBACManager) AssignRole(userID int64, roleName string) {
    m.userRoles[userID] = append(m.userRoles[userID], roleName)
}

// 检查用户是否有权限
func (m *RBACManager) HasPermission(userID int64, resource, action string) bool {
    roles, exists := m.userRoles[userID]
    if !exists {
        return false
    }
    
    for _, roleName := range roles {
        permissions, exists := m.permissions[roleName]
        if !exists {
            continue
        }
        
        for _, perm := range permissions {
            if perm.Resource == resource && perm.Action == action {
                return true
            }
        }
    }
    
    return false
}

// 获取用户所有权限
func (m *RBACManager) GetUserPermissions(userID int64) []string {
    var permissions []string
    
    roles, exists := m.userRoles[userID]
    if !exists {
        return permissions
    }
    
    seen := make(map[string]bool)
    for _, roleName := range roles {
        role, exists := m.roles[roleName]
        if !exists {
            continue
        }
        
        for _, perm := range role.Permissions {
            if !seen[perm] {
                permissions = append(permissions, perm)
                seen[perm] = true
            }
        }
    }
    
    return permissions
}

// ===== 中间件：RBAC权限检查 =====
func (m *RBACManager) RequirePermission(resource, action string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 从Context获取用户ID（假设已通过JWT认证中间件）
        userID, exists := c.Get("userID")
        if !exists {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
            c.Abort()
            return
        }
        
        uid := userID.(int64)
        
        // 检查权限
        if !m.HasPermission(uid, resource, action) {
            c.JSON(http.StatusForbidden, gin.H{"error": "Permission denied"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}

// ===== Handler示例 =====
func setupRBACRoutes(r *gin.Engine, rbac *RBACManager) {
    // 模拟JWT认证中间件
    mockAuth := func() gin.HandlerFunc {
        return func(c *gin.Context) {
            // 从Header获取用户ID（简化版）
            userIDStr := c.GetHeader("X-User-ID")
            if userIDStr == "" {
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing X-User-ID header"})
                c.Abort()
                return
            }
            
            var userID int64
            fmt.Sscanf(userIDStr, "%d", &userID)
            c.Set("userID", userID)
            
            c.Next()
        }
    }
    
    api := r.Group("/api")
    api.Use(mockAuth())
    {
        // 用户管理（需要users:create权限）
        api.POST("/users", rbac.RequirePermission("users", "create"), func(c *gin.Context) {
            c.JSON(http.StatusOK, gin.H{"message": "User created"})
        })
        
        // 查看用户（需要users:read权限）
        api.GET("/users", rbac.RequirePermission("users", "read"), func(c *gin.Context) {
            c.JSON(http.StatusOK, gin.H{"users": []string{"alice", "bob"}})
        })
        
        // 文章管理（需要posts:create权限）
        api.POST("/posts", rbac.RequirePermission("posts", "create"), func(c *gin.Context) {
            c.JSON(http.StatusOK, gin.H{"message": "Post created"})
        })
        
        // 查看文章（需要posts:read权限）
        api.GET("/posts", rbac.RequirePermission("posts", "read"), func(c *gin.Context) {
            c.JSON(http.StatusOK, gin.H{"posts": []string{"post1", "post2"}})
        })
        
        // 查看用户权限
        api.GET("/me/permissions", func(c *gin.Context) {
            userID := c.GetInt64("userID")
            permissions := rbac.GetUserPermissions(userID)
            c.JSON(http.StatusOK, gin.H{"permissions": permissions})
        })
    }
}

func main() {
    r := gin.Default()
    rbac := NewRBACManager()
    
    setupRBACRoutes(r, rbac)
    
    r.Run(":8080")
}

/*
测试命令:
# Admin用户（userID=1）创建用户
curl -H "X-User-ID: 1" -X POST http://localhost:8080/api/users

# Editor用户（userID=2）尝试创建用户（失败）
curl -H "X-User-ID: 2" -X POST http://localhost:8080/api/users

# Viewer用户（userID=3）查看文章
curl -H "X-User-ID: 3" http://localhost:8080/api/posts

# 查看用户权限
curl -H "X-User-ID: 1" http://localhost:8080/api/me/permissions
*/
```

---

## 第六部分：密码加密与安全

### 密码加密最佳实践

```go
package main

import (
    "crypto/rand"
    "encoding/base64"
    "fmt"
    
    "golang.org/x/crypto/bcrypt"
    "golang.org/x/crypto/argon2"
)

// ===== 1. Bcrypt加密（推荐）=====
// 哈希密码
func HashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    return string(bytes), err
}

// 验证密码
func CheckPassword(password, hash string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}

// ===== 2. Argon2加密（更安全）=====
type Argon2Params struct {
    Memory      uint32
    Iterations  uint32
    Parallelism uint8
    SaltLength  uint32
    KeyLength   uint32
}

var DefaultArgon2Params = &Argon2Params{
    Memory:      64 * 1024, // 64 MB
    Iterations:  3,
    Parallelism: 2,
    SaltLength:  16,
    KeyLength:   32,
}

func Argon2Hash(password string, params *Argon2Params) (string, error) {
    // 生成随机salt
    salt := make([]byte, params.SaltLength)
    if _, err := rand.Read(salt); err != nil {
        return "", err
    }
    
    // 生成hash
    hash := argon2.IDKey(
        []byte(password),
        salt,
        params.Iterations,
        params.Memory,
        params.Parallelism,
        params.KeyLength,
    )
    
    // 编码为base64
    b64Salt := base64.RawStdEncoding.EncodeToString(salt)
    b64Hash := base64.RawStdEncoding.EncodeToString(hash)
    
    // 格式: $argon2id$v=19$m=65536,t=3,p=2$salt$hash
    encodedHash := fmt.Sprintf("$argon2id$v=19$m=%d,t=%d,p=%d$%s$%s",
        params.Memory, params.Iterations, params.Parallelism, b64Salt, b64Hash)
    
    return encodedHash, nil
}

// ===== 3. 密码强度检查 =====
import (
    "regexp"
    "unicode"
)

func ValidatePasswordStrength(password string) []string {
    var errors []string
    
    // 最小长度
    if len(password) < 8 {
        errors = append(errors, "密码长度至少8位")
    }
    
    // 包含大写字母
    if !regexp.MustCompile(`[A-Z]`).MatchString(password) {
        errors = append(errors, "密码必须包含大写字母")
    }
    
    // 包含小写字母
    if !regexp.MustCompile(`[a-z]`).MatchString(password) {
        errors = append(errors, "密码必须包含小写字母")
    }
    
    // 包含数字
    if !regexp.MustCompile(`[0-9]`).MatchString(password) {
        errors = append(errors, "密码必须包含数字")
    }
    
    // 包含特殊字符
    hasSpecial := false
    for _, char := range password {
        if unicode.IsPunct(char) || unicode.IsSymbol(char) {
            hasSpecial = true
            break
        }
    }
    if !hasSpecial {
        errors = append(errors, "密码必须包含特殊字符")
    }
    
    return errors
}

func main() {
    // 测试Bcrypt
    password := "MySecurePassword123!"
    
    hash, _ := HashPassword(password)
    fmt.Printf("Bcrypt Hash: %s\n", hash)
    fmt.Printf("验证密码: %v\n", CheckPassword(password, hash))
    
    // 测试密码强度
    errors := ValidatePasswordStrength("weak")
    if len(errors) > 0 {
        fmt.Println("密码强度不足:")
        for _, err := range errors {
            fmt.Printf("  - %s\n", err)
        }
    }
}
```

---

## 第七部分：API密钥认证

### API密钥认证原理

```text
┌─────────────────────────────────────────────────┐
│              API密钥认证流程                     │
└─────────────────────────────────────────────────┘

Client ──────────────────────> Server
  │                               │
  │  1. Request with API Key      │
  │     Header: X-API-Key: xxx    │
  │                               │
  │ <──────────────────────────── │
  │  2. Validate API Key          │
  │     - Check existence         │
  │     - Check expiration        │
  │     - Check rate limit        │
  │                               │
  │ <──────────────────────────── │
     3. Return Response or Error
```

---

### 实战案例5：API密钥管理系统

```go
package main

import (
 "crypto/rand"
 "encoding/hex"
 "fmt"
 "log"
 "net/http"
 "sync"
 "time"

 "github.com/gin-gonic/gin"
)

// ===== API密钥数据结构 =====
type APIKey struct {
 Key          string
 Name         string
 UserID       int64
 Permissions  []string
 CreatedAt    time.Time
 ExpiresAt    time.Time
 LastUsedAt   time.Time
 RateLimit    int // 每分钟请求限制
 RequestCount int // 当前分钟请求数
 ResetAt      time.Time
}

// ===== API密钥管理器 =====
type APIKeyManager struct {
 mu   sync.RWMutex
 keys map[string]*APIKey
}

func NewAPIKeyManager() *APIKeyManager {
 return &APIKeyManager{
  keys: make(map[string]*APIKey),
 }
}

// 生成API密钥
func (m *APIKeyManager) GenerateKey(name string, userID int64, permissions []string, rateLimit int, ttl time.Duration) (*APIKey, error) {
 // 生成32字节随机密钥
 b := make([]byte, 32)
 if _, err := rand.Read(b); err != nil {
  return nil, err
 }
 
 key := hex.EncodeToString(b)
 
 apiKey := &APIKey{
  Key:         key,
  Name:        name,
  UserID:      userID,
  Permissions: permissions,
  CreatedAt:   time.Now(),
  ExpiresAt:   time.Now().Add(ttl),
  RateLimit:   rateLimit,
  ResetAt:     time.Now().Add(time.Minute),
 }
 
 m.mu.Lock()
 m.keys[key] = apiKey
 m.mu.Unlock()
 
 return apiKey, nil
}

// 验证API密钥
func (m *APIKeyManager) Validate(key string) (*APIKey, error) {
 m.mu.Lock()
 defer m.mu.Unlock()
 
 apiKey, exists := m.keys[key]
 if !exists {
  return nil, fmt.Errorf("invalid API key")
 }
 
 // 检查是否过期
 if time.Now().After(apiKey.ExpiresAt) {
  return nil, fmt.Errorf("API key expired")
 }
 
 // 检查速率限制
 now := time.Now()
 if now.After(apiKey.ResetAt) {
  // 重置计数器
  apiKey.RequestCount = 0
  apiKey.ResetAt = now.Add(time.Minute)
 }
 
 if apiKey.RequestCount >= apiKey.RateLimit {
  return nil, fmt.Errorf("rate limit exceeded")
 }
 
 // 增加请求计数
 apiKey.RequestCount++
 apiKey.LastUsedAt = now
 
 return apiKey, nil
}

// 撤销API密钥
func (m *APIKeyManager) Revoke(key string) error {
 m.mu.Lock()
 defer m.mu.Unlock()
 
 delete(m.keys, key)
 return nil
}

// 列出用户的所有API密钥
func (m *APIKeyManager) ListUserKeys(userID int64) []*APIKey {
 m.mu.RLock()
 defer m.mu.RUnlock()
 
 var keys []*APIKey
 for _, apiKey := range m.keys {
  if apiKey.UserID == userID {
   keys = append(keys, apiKey)
  }
 }
 
 return keys
}

// ===== 中间件：API密钥认证 =====
func (m *APIKeyManager) AuthMiddleware() gin.HandlerFunc {
 return func(c *gin.Context) {
  // 从Header获取API密钥
  apiKey := c.GetHeader("X-API-Key")
  if apiKey == "" {
   c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing API key"})
   c.Abort()
   return
  }
  
  // 验证API密钥
  key, err := m.Validate(apiKey)
  if err != nil {
   c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
   c.Abort()
   return
  }
  
  // 将API密钥信息存入Context
  c.Set("apiKey", key)
  c.Set("userID", key.UserID)
  c.Set("permissions", key.Permissions)
  
  c.Next()
 }
}

// ===== Handler示例 =====
func setupAPIKeyRoutes(r *gin.Engine, manager *APIKeyManager) {
 // 创建API密钥
 r.POST("/api/keys", func(c *gin.Context) {
  var req struct {
   Name        string   `json:"name" binding:"required"`
   Permissions []string `json:"permissions"`
   RateLimit   int      `json:"rate_limit"`
   TTLDays     int      `json:"ttl_days"`
  }
  
  if err := c.ShouldBindJSON(&req); err != nil {
   c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
   return
  }
  
  // 假设用户ID从JWT中获取
  userID := int64(1)
  
  if req.RateLimit == 0 {
   req.RateLimit = 60 // 默认每分钟60次
  }
  if req.TTLDays == 0 {
   req.TTLDays = 365 // 默认1年
  }
  
  apiKey, err := manager.GenerateKey(
   req.Name,
   userID,
   req.Permissions,
   req.RateLimit,
   time.Duration(req.TTLDays)*24*time.Hour,
  )
  
  if err != nil {
   c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
   return
  }
  
  c.JSON(http.StatusOK, gin.H{
   "key":        apiKey.Key,
   "name":       apiKey.Name,
   "created_at": apiKey.CreatedAt,
   "expires_at": apiKey.ExpiresAt,
  })
 })
 
 // 列出API密钥
 r.GET("/api/keys", func(c *gin.Context) {
  userID := int64(1) // 从JWT获取
  keys := manager.ListUserKeys(userID)
  
  var response []map[string]interface{}
  for _, key := range keys {
   response = append(response, map[string]interface{}{
    "name":       key.Name,
    "created_at": key.CreatedAt,
    "expires_at": key.ExpiresAt,
    "last_used":  key.LastUsedAt,
   })
  }
  
  c.JSON(http.StatusOK, gin.H{"keys": response})
 })
 
 // 撤销API密钥
 r.DELETE("/api/keys/:key", func(c *gin.Context) {
  key := c.Param("key")
  
  if err := manager.Revoke(key); err != nil {
   c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
   return
  }
  
  c.JSON(http.StatusOK, gin.H{"message": "API key revoked"})
 })
 
 // 使用API密钥访问受保护资源
 api := r.Group("/api/v1")
 api.Use(manager.AuthMiddleware())
 {
  api.GET("/data", func(c *gin.Context) {
   c.JSON(http.StatusOK, gin.H{"data": "Protected data"})
  })
 }
}

func main() {
 r := gin.Default()
 manager := NewAPIKeyManager()
 
 setupAPIKeyRoutes(r, manager)
 
 r.Run(":8080")
}
```

---

## 第八部分：多因素认证MFA

### MFA原理

```text
┌─────────────────────────────────────────────────┐
│              多因素认证（MFA）                    │
└─────────────────────────────────────────────────┘

认证因素:
1️⃣ 知识因素 - 你知道什么（密码、PIN）
2️⃣ 持有因素 - 你拥有什么（手机、硬件令牌）
3️⃣ 生物因素 - 你是什么（指纹、面部）

常见MFA方式:
✅ TOTP（基于时间的一次性密码）- Google Authenticator
✅ SMS（短信验证码）
✅ Email（邮件验证码）
✅ 硬件令牌（YubiKey）
```

---

### 实战案例6：TOTP双因素认证

```go
package main

import (
 "crypto/hmac"
 "crypto/rand"
 "crypto/sha1"
 "encoding/base32"
 "encoding/binary"
 "fmt"
 "net/http"
 "sync"
 "time"

 "github.com/gin-gonic/gin"
)

// ===== TOTP实现 =====
type TOTPManager struct {
 secret string
}

func NewTOTPManager(secret string) *TOTPManager {
 return &TOTPManager{secret: secret}
}

// 生成TOTP密钥
func GenerateTOTPSecret() string {
 // 生成20字节随机密钥
 b := make([]byte, 20)
 rand.Read(b)
 return base32.StdEncoding.EncodeToString(b)
}

// 生成TOTP码
func (t *TOTPManager) GenerateCode(timestamp time.Time) string {
 // 将时间戳转换为30秒时间窗口
 counter := uint64(timestamp.Unix() / 30)
 
 return t.generateHOTP(counter)
}

func (t *TOTPManager) generateHOTP(counter uint64) string {
 // 解码密钥
 key, err := base32.StdEncoding.DecodeString(t.secret)
 if err != nil {
  return ""
 }
 
 // 将计数器转换为字节
 buf := make([]byte, 8)
 binary.BigEndian.PutUint64(buf, counter)
 
 // HMAC-SHA1
 h := hmac.New(sha1.New, key)
 h.Write(buf)
 hash := h.Sum(nil)
 
 // 动态截断
 offset := hash[len(hash)-1] & 0x0F
 truncated := binary.BigEndian.Uint32(hash[offset:]) & 0x7FFFFFFF
 
 // 生成6位数字
 code := truncated % 1000000
 
 return fmt.Sprintf("%06d", code)
}

// 验证TOTP码
func (t *TOTPManager) ValidateCode(code string) bool {
 now := time.Now()
 
 // 检查当前时间窗口
 if t.GenerateCode(now) == code {
  return true
 }
 
 // 检查前一个时间窗口（允许30秒误差）
 if t.GenerateCode(now.Add(-30*time.Second)) == code {
  return true
 }
 
 // 检查后一个时间窗口
 if t.GenerateCode(now.Add(30*time.Second)) == code {
  return true
 }
 
 return false
}

// 生成QR码URI（用于Google Authenticator）
func (t *TOTPManager) GenerateQRCodeURI(accountName, issuer string) string {
 return fmt.Sprintf("otpauth://totp/%s:%s?secret=%s&issuer=%s",
  issuer, accountName, t.secret, issuer)
}

// ===== MFA用户管理 =====
type MFAUser struct {
 UserID       int64
 Username     string
 TOTPSecret   string
 MFAEnabled   bool
 BackupCodes  []string
}

type MFAManager struct {
 mu    sync.RWMutex
 users map[int64]*MFAUser
}

func NewMFAManager() *MFAManager {
 return &MFAManager{
  users: make(map[int64]*MFAUser),
 }
}

// 启用MFA
func (m *MFAManager) EnableMFA(userID int64, username string) (*MFAUser, error) {
 secret := GenerateTOTPSecret()
 
 // 生成备用码
 backupCodes := make([]string, 10)
 for i := 0; i < 10; i++ {
  b := make([]byte, 4)
  rand.Read(b)
  backupCodes[i] = fmt.Sprintf("%08x", b)
 }
 
 user := &MFAUser{
  UserID:      userID,
  Username:    username,
  TOTPSecret:  secret,
  MFAEnabled:  true,
  BackupCodes: backupCodes,
 }
 
 m.mu.Lock()
 m.users[userID] = user
 m.mu.Unlock()
 
 return user, nil
}

// 验证MFA码
func (m *MFAManager) VerifyMFA(userID int64, code string) bool {
 m.mu.RLock()
 user, exists := m.users[userID]
 m.mu.RUnlock()
 
 if !exists || !user.MFAEnabled {
  return false
 }
 
 // 验证TOTP码
 totp := NewTOTPManager(user.TOTPSecret)
 if totp.ValidateCode(code) {
  return true
 }
 
 // 验证备用码
 m.mu.Lock()
 defer m.mu.Unlock()
 
 for i, backupCode := range user.BackupCodes {
  if backupCode == code {
   // 使用后删除备用码
   user.BackupCodes = append(user.BackupCodes[:i], user.BackupCodes[i+1:]...)
   return true
  }
 }
 
 return false
}

// ===== Handler示例 =====
func setupMFARoutes(r *gin.Engine, mfaManager *MFAManager) {
 // 启用MFA
 r.POST("/api/mfa/enable", func(c *gin.Context) {
  // 假设用户已登录
  userID := int64(1)
  username := "alice"
  
  user, err := mfaManager.EnableMFA(userID, username)
  if err != nil {
   c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
   return
  }
  
  totp := NewTOTPManager(user.TOTPSecret)
  qrURI := totp.GenerateQRCodeURI(username, "MyApp")
  
  c.JSON(http.StatusOK, gin.H{
   "secret":       user.TOTPSecret,
   "qr_code_uri":  qrURI,
   "backup_codes": user.BackupCodes,
  })
 })
 
 // 验证MFA
 r.POST("/api/mfa/verify", func(c *gin.Context) {
  var req struct {
   UserID int64  `json:"user_id" binding:"required"`
   Code   string `json:"code" binding:"required"`
  }
  
  if err := c.ShouldBindJSON(&req); err != nil {
   c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
   return
  }
  
  if mfaManager.VerifyMFA(req.UserID, req.Code) {
   c.JSON(http.StatusOK, gin.H{"message": "MFA verification successful"})
  } else {
   c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid MFA code"})
  }
 })
}
```

---

## 第九部分：单点登录SSO

### SSO原理

```text
┌─────────────────────────────────────────────────┐
│              单点登录（SSO）流程                  │
└─────────────────────────────────────────────────┘

1. 用户访问App1
   App1 ─────> SSO Server (未登录，重定向到登录页)
   
2. 用户在SSO登录
   User ─────> SSO Server (输入凭证)
   SSO Server ─────> Set Global Session
   
3. 返回App1
   SSO Server ─────> App1 (Token)
   App1 ─────> Set Local Session
   
4. 用户访问App2
   App2 ─────> SSO Server (检查Global Session)
   SSO Server ─────> App2 (Token，无需重新登录)
```

---

### 实战案例7：简单SSO实现

```go
package main

import (
 "crypto/rand"
 "encoding/base64"
 "fmt"
 "net/http"
 "sync"
 "time"

 "github.com/gin-gonic/gin"
)

// ===== SSO票据 =====
type SSOTicket struct {
 Ticket    string
 UserID    int64
 Username  string
 CreatedAt time.Time
 ExpiresAt time.Time
 Apps      map[string]bool // 已登录的应用
}

// ===== SSO服务器 =====
type SSOServer struct {
 mu      sync.RWMutex
 tickets map[string]*SSOTicket
 users   map[string]string // username -> password
}

func NewSSOServer() *SSOServer {
 server := &SSOServer{
  tickets: make(map[string]*SSOTicket),
  users: map[string]string{
   "alice": "password123",
   "bob":   "password456",
  },
 }
 
 // 定期清理过期票据
 go server.cleanup()
 
 return server
}

func (s *SSOServer) cleanup() {
 ticker := time.NewTicker(5 * time.Minute)
 defer ticker.Stop()
 
 for range ticker.C {
  s.mu.Lock()
  for ticket, t := range s.tickets {
   if time.Now().After(t.ExpiresAt) {
    delete(s.tickets, ticket)
   }
  }
  s.mu.Unlock()
 }
}

// 生成票据
func generateTicket() (string, error) {
 b := make([]byte, 32)
 if _, err := rand.Read(b); err != nil {
  return "", err
 }
 return base64.URLEncoding.EncodeToString(b), nil
}

// SSO登录
func (s *SSOServer) Login(username, password string) (string, error) {
 // 验证凭证
 storedPassword, exists := s.users[username]
 if !exists || storedPassword != password {
  return "", fmt.Errorf("invalid credentials")
 }
 
 // 生成票据
 ticket, err := generateTicket()
 if err != nil {
  return "", err
 }
 
 s.mu.Lock()
 s.tickets[ticket] = &SSOTicket{
  Ticket:    ticket,
  UserID:    1,
  Username:  username,
  CreatedAt: time.Now(),
  ExpiresAt: time.Now().Add(8 * time.Hour),
  Apps:      make(map[string]bool),
 }
 s.mu.Unlock()
 
 return ticket, nil
}

// 验证票据
func (s *SSOServer) ValidateTicket(ticket, appID string) (*SSOTicket, error) {
 s.mu.Lock()
 defer s.mu.Unlock()
 
 t, exists := s.tickets[ticket]
 if !exists {
  return nil, fmt.Errorf("invalid ticket")
 }
 
 if time.Now().After(t.ExpiresAt) {
  delete(s.tickets, ticket)
  return nil, fmt.Errorf("ticket expired")
 }
 
 // 记录应用访问
 t.Apps[appID] = true
 
 return t, nil
}

// 登出
func (s *SSOServer) Logout(ticket string) error {
 s.mu.Lock()
 defer s.mu.Unlock()
 
 delete(s.tickets, ticket)
 return nil
}

// ===== SSO Handler =====
func setupSSORoutes(r *gin.Engine, sso *SSOServer) {
 // SSO登录页面
 r.POST("/sso/login", func(c *gin.Context) {
  var req struct {
   Username string `json:"username" binding:"required"`
   Password string `json:"password" binding:"required"`
   AppID    string `json:"app_id"`
  }
  
  if err := c.ShouldBindJSON(&req); err != nil {
   c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
   return
  }
  
  ticket, err := sso.Login(req.Username, req.Password)
  if err != nil {
   c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
   return
  }
  
  c.JSON(http.StatusOK, gin.H{
   "ticket": ticket,
   "message": "Login successful",
  })
 })
 
 // SSO票据验证
 r.POST("/sso/validate", func(c *gin.Context) {
  var req struct {
   Ticket string `json:"ticket" binding:"required"`
   AppID  string `json:"app_id" binding:"required"`
  }
  
  if err := c.ShouldBindJSON(&req); err != nil {
   c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
   return
  }
  
  ticket, err := sso.ValidateTicket(req.Ticket, req.AppID)
  if err != nil {
   c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
   return
  }
  
  c.JSON(http.StatusOK, gin.H{
   "user_id":  ticket.UserID,
   "username": ticket.Username,
   "valid":    true,
  })
 })
 
 // SSO登出
 r.POST("/sso/logout", func(c *gin.Context) {
  var req struct {
   Ticket string `json:"ticket" binding:"required"`
  }
  
  if err := c.ShouldBindJSON(&req); err != nil {
   c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
   return
  }
  
  sso.Logout(req.Ticket)
  
  c.JSON(http.StatusOK, gin.H{"message": "Logout successful"})
 })
}
```

---

## 第十部分：安全最佳实践

### 实战案例8：安全中间件集合

```go
package main

import (
 "log"
 "net/http"
 "strings"
 "sync"
 "time"

 "github.com/gin-gonic/gin"
 "golang.org/x/time/rate"
)

// ===== 1. CSRF防护 =====
func CSRFMiddleware() gin.HandlerFunc {
 return func(c *gin.Context) {
  // 检查请求方法
  if c.Request.Method != "GET" && c.Request.Method != "HEAD" {
   csrfToken := c.GetHeader("X-CSRF-Token")
   expectedToken := c.GetString("csrf_token") // 从session获取
   
   if csrfToken == "" || csrfToken != expectedToken {
    c.JSON(http.StatusForbidden, gin.H{"error": "CSRF token mismatch"})
    c.Abort()
    return
   }
  }
  
  c.Next()
 }
}

// ===== 2. XSS防护 =====
func SecurityHeadersMiddleware() gin.HandlerFunc {
 return func(c *gin.Context) {
  // 设置安全头
  c.Header("X-Frame-Options", "DENY")
  c.Header("X-Content-Type-Options", "nosniff")
  c.Header("X-XSS-Protection", "1; mode=block")
  c.Header("Content-Security-Policy", "default-src 'self'")
  c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
  
  c.Next()
 }
}

// ===== 3. 限流中间件 =====
type IPRateLimiter struct {
 limiters map[string]*rate.Limiter
 mu       sync.RWMutex
 rate     rate.Limit
 burst    int
}

func NewIPRateLimiter(r rate.Limit, b int) *IPRateLimiter {
 return &IPRateLimiter{
  limiters: make(map[string]*rate.Limiter),
  rate:     r,
  burst:    b,
 }
}

func (i *IPRateLimiter) GetLimiter(ip string) *rate.Limiter {
 i.mu.Lock()
 defer i.mu.Unlock()
 
 limiter, exists := i.limiters[ip]
 if !exists {
  limiter = rate.NewLimiter(i.rate, i.burst)
  i.limiters[ip] = limiter
 }
 
 return limiter
}

func (i *IPRateLimiter) Middleware() gin.HandlerFunc {
 return func(c *gin.Context) {
  ip := c.ClientIP()
  limiter := i.GetLimiter(ip)
  
  if !limiter.Allow() {
   c.JSON(http.StatusTooManyRequests, gin.H{
    "error": "Rate limit exceeded",
   })
   c.Abort()
   return
  }
  
  c.Next()
 }
}

// ===== 4. 审计日志中间件 =====
func AuditLogMiddleware() gin.HandlerFunc {
 return func(c *gin.Context) {
  start := time.Now()
  
  // 记录请求信息
  method := c.Request.Method
  path := c.Request.URL.Path
  ip := c.ClientIP()
  userAgent := c.Request.UserAgent()
  
  c.Next()
  
  // 记录响应信息
  statusCode := c.Writer.Status()
  duration := time.Since(start)
  
  // 记录审计日志（简化版，实际应写入数据库）
  log.Printf("[AUDIT] %s %s %s %d %v %s",
   method, path, ip, statusCode, duration, userAgent)
 }
}

// ===== 5. 输入验证 =====
func SanitizeInput(input string) string {
 // 移除危险字符
 input = strings.ReplaceAll(input, "<", "&lt;")
 input = strings.ReplaceAll(input, ">", "&gt;")
 input = strings.ReplaceAll(input, "\"", "&quot;")
 input = strings.ReplaceAll(input, "'", "&#x27;")
 input = strings.ReplaceAll(input, "/", "&#x2F;")
 
 return input
}
```

---

## 第十一部分：完整项目实战

### 实战案例9：完整的认证授权系统

```go
package main

import (
 "log"
 "net/http"
 "strings"
 "time"

 "github.com/gin-gonic/gin"
)

// ===== 完整的认证授权系统 =====
type AuthSystem struct {
 sessionManager *SessionManager
 jwtManager     *JWTManager
 rbacManager    *RBACManager
 apiKeyManager  *APIKeyManager
 mfaManager     *MFAManager
 rateLimiter    *IPRateLimiter
}

func NewAuthSystem() *AuthSystem {
 return &AuthSystem{
  sessionManager: NewSessionManager(NewMemoryStore()),
  rbacManager:    NewRBACManager(),
  apiKeyManager:  NewAPIKeyManager(),
  mfaManager:     NewMFAManager(),
  rateLimiter:    NewIPRateLimiter(10, 20), // 10 req/s, burst 20
 }
}

// 统一认证中间件
func (a *AuthSystem) AuthMiddleware() gin.HandlerFunc {
 return func(c *gin.Context) {
  // 1. 尝试API Key认证
  apiKey := c.GetHeader("X-API-Key")
  if apiKey != "" {
   key, err := a.apiKeyManager.Validate(apiKey)
   if err == nil {
    c.Set("userID", key.UserID)
    c.Set("authType", "api_key")
    c.Next()
    return
   }
  }
  
  // 2. 尝试JWT认证
  authHeader := c.GetHeader("Authorization")
  if authHeader != "" {
   parts := strings.SplitN(authHeader, " ", 2)
   if len(parts) == 2 && parts[0] == "Bearer" {
    claims, err := ParseToken(parts[1])
    if err == nil {
     c.Set("userID", claims.UserID)
     c.Set("authType", "jwt")
     c.Next()
     return
    }
   }
  }
  
  // 3. 尝试Session认证
  session, err := a.sessionManager.Get(c)
  if err == nil {
   c.Set("userID", session["userID"])
   c.Set("authType", "session")
   c.Next()
   return
  }
  
  // 认证失败
  c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
  c.Abort()
 }
}

// 设置完整路由
func (a *AuthSystem) SetupRoutes(r *gin.Engine) {
 // 应用全局中间件
 r.Use(SecurityHeadersMiddleware())
 r.Use(a.rateLimiter.Middleware())
 r.Use(AuditLogMiddleware())
 
 // 公开路由
 public := r.Group("/api/public")
 {
  // 注册
  public.POST("/register", a.handleRegister)
  
  // 登录（支持多种方式）
  public.POST("/login", a.handleLogin)
  
  // OAuth2.0端点
  public.GET("/oauth/authorize", a.handleOAuthAuthorize)
  public.POST("/oauth/token", a.handleOAuthToken)
 }
 
 // 受保护路由
 protected := r.Group("/api")
 protected.Use(a.AuthMiddleware())
 {
  // 用户信息
  protected.GET("/me", a.handleGetProfile)
  protected.PUT("/me", a.handleUpdateProfile)
  
  // MFA管理
  protected.POST("/mfa/enable", a.handleEnableMFA)
  protected.POST("/mfa/verify", a.handleVerifyMFA)
  
  // API密钥管理
  protected.POST("/keys", a.handleCreateAPIKey)
  protected.GET("/keys", a.handleListAPIKeys)
  protected.DELETE("/keys/:key", a.handleRevokeAPIKey)
  
  // 管理员路由（需要admin角色）
  admin := protected.Group("/admin")
  admin.Use(a.rbacManager.RequirePermission("admin", "manage"))
  {
   admin.GET("/users", a.handleListUsers)
   admin.POST("/users/:id/roles", a.handleAssignRole)
  }
 }
}

// Handler实现（简化版）
func (a *AuthSystem) handleRegister(c *gin.Context) {
 // 注册逻辑
 c.JSON(http.StatusOK, gin.H{"message": "Registration successful"})
}

func (a *AuthSystem) handleLogin(c *gin.Context) {
 var req struct {
  Username string `json:"username" binding:"required"`
  Password string `json:"password" binding:"required"`
  Method   string `json:"method"` // "session" or "jwt"
 }
 
 if err := c.ShouldBindJSON(&req); err != nil {
  c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
  return
 }
 
 // 验证凭证（简化版）
 if req.Username != "alice" || req.Password != "password123" {
  c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
  return
 }
 
 // 根据请求的方法返回不同类型的凭证
 if req.Method == "jwt" {
  token, _ := GenerateToken(1, req.Username, "user")
  c.JSON(http.StatusOK, gin.H{
   "token": token,
   "type":  "Bearer",
  })
 } else {
  // 默认使用Session
  sid, _ := a.sessionManager.Create(c, map[string]interface{}{
   "userID":   1,
   "username": req.Username,
  })
  c.JSON(http.StatusOK, gin.H{
   "session_id": sid,
   "message":    "Login successful",
  })
 }
}

func (a *AuthSystem) handleGetProfile(c *gin.Context) {
 userID := c.GetInt64("userID")
 authType := c.GetString("authType")
 
 c.JSON(http.StatusOK, gin.H{
  "user_id":   userID,
  "auth_type": authType,
  "profile":   map[string]interface{}{
   "name":  "Alice",
   "email": "alice@example.com",
  },
 })
}

func (a *AuthSystem) handleUpdateProfile(c *gin.Context) {
 c.JSON(http.StatusOK, gin.H{"message": "Profile updated"})
}

func (a *AuthSystem) handleEnableMFA(c *gin.Context) {
 // MFA启用逻辑
 c.JSON(http.StatusOK, gin.H{"message": "MFA enabled"})
}

func (a *AuthSystem) handleVerifyMFA(c *gin.Context) {
 // MFA验证逻辑
 c.JSON(http.StatusOK, gin.H{"message": "MFA verified"})
}

func (a *AuthSystem) handleCreateAPIKey(c *gin.Context) {
 // API密钥创建逻辑
 c.JSON(http.StatusOK, gin.H{"message": "API key created"})
}

func (a *AuthSystem) handleListAPIKeys(c *gin.Context) {
 c.JSON(http.StatusOK, gin.H{"keys": []interface{}{}})
}

func (a *AuthSystem) handleRevokeAPIKey(c *gin.Context) {
 c.JSON(http.StatusOK, gin.H{"message": "API key revoked"})
}

func (a *AuthSystem) handleOAuthAuthorize(c *gin.Context) {
 c.JSON(http.StatusOK, gin.H{"message": "OAuth authorize"})
}

func (a *AuthSystem) handleOAuthToken(c *gin.Context) {
 c.JSON(http.StatusOK, gin.H{"message": "OAuth token"})
}

func (a *AuthSystem) handleListUsers(c *gin.Context) {
 c.JSON(http.StatusOK, gin.H{"users": []interface{}{}})
}

func (a *AuthSystem) handleAssignRole(c *gin.Context) {
 c.JSON(http.StatusOK, gin.H{"message": "Role assigned"})
}

func main() {
 r := gin.Default()
 
 authSystem := NewAuthSystem()
 authSystem.SetupRoutes(r)
 
 log.Println("Authentication system running on :8080")
 r.Run(":8080")
}
```

---

## 🎯 总结

### 认证授权核心要点

1. **Session认证** - Cookie+服务端存储
2. **JWT认证** - 无状态Token
3. **OAuth2.0** - 第三方授权
4. **RBAC** - 基于角色的权限控制
5. **密码安全** - Bcrypt/Argon2加密
6. **API密钥** - 服务间认证
7. **MFA** - 多因素认证增强安全
8. **SSO** - 单点登录
9. **安全最佳实践** - HTTPS、CSRF、XSS防护

### 最佳实践清单

```text
✅ 使用HTTPS传输敏感数据
✅ 密码使用Bcrypt/Argon2加密
✅ JWT使用强随机密钥
✅ Token设置合理过期时间
✅ 实现Token刷新机制
✅ 使用RBAC进行细粒度权限控制
✅ 实施密码强度策略
✅ 防止暴力破解（限流+验证码）
✅ 记录审计日志
✅ 定期更新依赖库
```

---

**文档版本**: v12.0  

<div align="center">

Made with ❤️ for Go Security Developers

[⬆ 回到顶部](#go认证与授权深度实战指南)

</div>

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025年10月20日  
**文档状态**: 完成  
**适用版本**: Go 1.21+
