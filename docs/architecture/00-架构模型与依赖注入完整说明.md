# 架构模型与依赖注入完整说明

> **简介**: 本文档全面阐述项目的架构模型、领域模型设计和依赖注入机制，包括设计原理、实现细节和使用指南。

**版本**: v1.0
**更新日期**: 2025-01-XX
**适用于**: Go 1.25.3

---

## 📋 目录

- [架构模型与依赖注入完整说明](#架构模型与依赖注入完整说明)
  - [📋 目录](#-目录)
  - [1. 架构模型总览](#1-架构模型总览)
    - [1.1 Clean Architecture 四层架构](#11-clean-architecture-四层架构)
    - [1.2 依赖关系图](#12-依赖关系图)
    - [1.3 架构设计原则](#13-架构设计原则)
  - [2. 领域模型设计](#2-领域模型设计)
    - [2.1 领域层接口设计](#21-领域层接口设计)
    - [2.2 仓储模式（Repository Pattern）](#22-仓储模式repository-pattern)
    - [2.3 领域服务（Domain Service）](#23-领域服务domain-service)
  - [3. 应用层模式设计](#3-应用层模式设计)
    - [3.1 CQRS 模式](#31-cqrs-模式)
    - [3.2 命令模式（Command Pattern）](#32-命令模式command-pattern)
    - [3.3 查询模式（Query Pattern）](#33-查询模式query-pattern)
    - [3.4 事件模式（Event Pattern）](#34-事件模式event-pattern)
    - [3.5 DTO 模式](#35-dto-模式)
  - [4. 依赖注入机制](#4-依赖注入机制)
    - [4.1 Wire 依赖注入原理](#41-wire-依赖注入原理)
    - [4.2 Provider 函数设计](#42-provider-函数设计)
    - [4.3 依赖注入流程](#43-依赖注入流程)
    - [4.4 最佳实践](#44-最佳实践)
  - [5. 完整示例](#5-完整示例)
    - [5.1 领域模型定义](#51-领域模型定义)
    - [5.2 应用服务实现](#52-应用服务实现)
    - [5.3 依赖注入配置](#53-依赖注入配置)
    - [5.4 使用示例](#54-使用示例)
  - [📚 扩展阅读](#-扩展阅读)

---

## 1. 架构模型总览

### 1.1 Clean Architecture 四层架构

本项目采用 **Clean Architecture（整洁架构）** 设计，将系统分为四个层次：

```text
┌─────────────────────────────────────────────────────────┐
│                    Interfaces Layer                     │
│              (HTTP, gRPC, GraphQL, MQTT)                │
│                  协议适配、请求处理                       │
└──────────────────────┬──────────────────────────────────┘
                       │ 调用
                       ↓
┌─────────────────────────────────────────────────────────┐
│                  Application Layer                      │
│         (Services, Commands, Queries, Events)           │
│                  用例编排、业务协调                       │
└──────────────────────┬──────────────────────────────────┘
                       │ 依赖接口
                       ↓
┌─────────────────────────────────────────────────────────┐
│                    Domain Layer                         │
│         (Entities, Value Objects, Interfaces)           │
│                  核心业务逻辑、接口定义                   │
└──────────────────────┬──────────────────────────────────┘
                       ↑ 实现接口
                       │
┌─────────────────────────────────────────────────────────┐
│                Infrastructure Layer                     │
│    (Database, Message Queue, Cache, Observability)      │
│                  技术实现、外部集成                       │
└─────────────────────────────────────────────────────────┘
```

**层次职责**：

| 层次 | 职责 | 规则 |
|------|------|------|
| **Interfaces Layer** | 协议适配、请求处理、响应格式化 | ✅ 调用 Application Layer<br/>❌ 不直接调用 Domain Layer |
| **Application Layer** | 用例编排、业务协调、DTO 转换 | ✅ 依赖 Domain Layer 接口<br/>❌ 不依赖 Infrastructure Layer |
| **Domain Layer** | 核心业务逻辑、领域模型、接口定义 | ✅ 不依赖任何其他层<br/>✅ 只包含业务逻辑 |
| **Infrastructure Layer** | 技术实现、数据访问、外部服务集成 | ✅ 实现 Domain Layer 接口<br/>✅ 可以依赖外部库 |

### 1.2 依赖关系图

**依赖方向**：

```text
Interfaces → Application → Domain
     ↓            ↓
Infrastructure → Domain
```

**依赖规则**：

1. **Domain Layer**：不依赖任何其他层（最内层）
2. **Application Layer**：只依赖 Domain Layer
3. **Infrastructure Layer**：实现 Domain Layer 定义的接口
4. **Interfaces Layer**：调用 Application Layer

**依赖倒置原则**：

- 内层定义接口，外层实现接口
- 依赖方向向内，保证业务逻辑独立
- 可以轻松替换技术实现

### 1.3 架构设计原则

**核心原则**：

1. **依赖倒置原则（DIP）**
   - 内层不依赖外层，外层依赖内层接口
   - 业务逻辑独立于技术实现

2. **关注点分离原则（SoC）**
   - 每个层次只负责一个明确的关注点
   - 职责清晰，易于维护

3. **单一职责原则（SRP）**
   - 每个模块只负责一个职责
   - 降低耦合度

4. **开闭原则（OCP）**
   - 对扩展开放，对修改关闭
   - 可以添加新实现，不需要修改接口

---

## 2. 领域模型设计

### 2.1 领域层接口设计

领域层提供框架层面的接口抽象，用户需要根据业务需求定义具体的接口。

**位置**：`internal/domain/interfaces/`

**接口类型**：

1. **Repository 接口**：数据访问抽象
2. **DomainService 接口**：领域服务抽象
3. **Validator 接口**：验证器抽象
4. **Processor 接口**：处理器抽象

### 2.2 仓储模式（Repository Pattern）

**设计原理**：

1. 仓储模式是 DDD 中的核心模式，用于抽象数据访问层
2. 仓储接口定义在领域层，实现放在基础设施层
3. 领域层不依赖具体的数据访问技术（如 Ent、GORM）

**接口定义**：

```go
// internal/domain/interfaces/repository.go

// Repository 通用仓储接口
type Repository[T any] interface {
    Create(ctx context.Context, entity *T) error
    FindByID(ctx context.Context, id string) (*T, error)
    Update(ctx context.Context, entity *T) error
    Delete(ctx context.Context, id string) error
    List(ctx context.Context, limit, offset int) ([]*T, error)
}
```

**使用示例**：

```go
// 1. 领域层定义具体仓储接口
// internal/domain/user/repository.go
package user

type Repository interface {
    interfaces.Repository[*User]
    FindByEmail(ctx context.Context, email string) (*User, error)
}

// 2. 基础设施层实现接口
// internal/infrastructure/database/ent/repository/user_repository.go
package repository

type UserRepository struct {
    client *ent.Client
}

var _ user.Repository = (*UserRepository)(nil)

func (r *UserRepository) Create(ctx context.Context, u *user.User) error {
    // 使用 Ent 实现
}

// 3. 应用层使用接口
// internal/application/user/service.go
type UserService struct {
    repo user.Repository  // 依赖接口，不依赖具体实现
}
```

**优势**：

- ✅ 业务逻辑独立于数据访问技术
- ✅ 可以轻松替换数据访问实现
- ✅ 便于单元测试（可以使用 Mock）

### 2.3 领域服务（Domain Service）

**设计原理**：

1. 领域服务用于处理不属于单个实体的业务逻辑
2. 领域服务是无状态的，不保存业务状态
3. 领域服务处理跨聚合的操作或复杂的业务规则

**使用场景**：

1. 跨聚合的业务逻辑（如转账涉及两个账户）
2. 复杂的业务规则计算（如价格计算、折扣计算）
3. 需要多个仓储协调的操作

**示例**：

```go
// 领域服务接口
type PricingService interface {
    CalculatePrice(ctx context.Context, product *Product, quantity int) (*Money, error)
}

// 领域服务实现
type pricingService struct {
    discountRepo DiscountRepository
}

func (s *pricingService) CalculatePrice(ctx context.Context, product *Product, quantity int) (*Money, error) {
    // 计算价格逻辑，可能涉及折扣、促销等
}
```

---

## 3. 应用层模式设计

### 3.1 CQRS 模式

**CQRS（Command Query Responsibility Segregation）** 是命令查询职责分离模式。

**核心思想**：

- **Command（命令）**：写操作，改变系统状态
- **Query（查询）**：读操作，不改变系统状态
- 分离读写操作，提高系统的可扩展性和性能

**优势**：

1. 读写分离，可以独立优化
2. 支持不同的数据模型
3. 提高系统性能
4. 简化业务逻辑

### 3.2 命令模式（Command Pattern）

**设计原理**：

1. 命令用于表示写操作（Create、Update、Delete）
2. 命令是不可变的，表示一个业务操作的意图
3. 命令应该包含执行操作所需的所有信息

**接口定义**：

```go
// internal/application/patterns/command.go

// Command 命令接口
type Command interface {
    Execute(ctx context.Context) error
}

// CommandHandler 命令处理器接口
type CommandHandler[T Command] interface {
    Handle(ctx context.Context, cmd T) error
}
```

**使用示例**：

```go
// 1. 定义命令
type CreateUserCommand struct {
    Email string
    Name  string
}

func (c CreateUserCommand) Execute(ctx context.Context) error {
    return nil
}

// 2. 定义命令处理器
type CreateUserCommandHandler struct {
    userRepo domain.UserRepository
    eventBus eventbus.EventBus
}

func (h *CreateUserCommandHandler) Handle(ctx context.Context, cmd CreateUserCommand) error {
    // 1. 验证命令
    if err := validateCreateUserCommand(cmd); err != nil {
        return err
    }

    // 2. 创建领域实体
    user := domain.NewUser(cmd.Email, cmd.Name)

    // 3. 保存实体
    if err := h.userRepo.Create(ctx, user); err != nil {
        return err
    }

    // 4. 发布领域事件
    event := eventbus.NewEvent("user.created", user)
    return h.eventBus.Publish(ctx, event)
}
```

### 3.3 查询模式（Query Pattern）

**设计原理**：

1. 查询用于表示读操作（Read、List、Search）
2. 查询应该是幂等的，多次执行相同查询应该返回相同结果
3. 查询应该包含查询所需的所有条件

**接口定义**：

```go
// internal/application/patterns/query.go

// Query 查询接口
type Query interface {
    Execute(ctx context.Context) (interface{}, error)
}

// QueryHandler 查询处理器接口
type QueryHandler[T Query, R any] interface {
    Handle(ctx context.Context, query T) (R, error)
}
```

**使用示例**：

```go
// 1. 定义查询
type GetUserQuery struct {
    ID string
}

func (q GetUserQuery) Execute(ctx context.Context) (interface{}, error) {
    return nil, nil
}

// 2. 定义查询处理器
type GetUserQueryHandler struct {
    userRepo domain.UserRepository
    cache    cache.Cache
}

func (h *GetUserQueryHandler) Handle(ctx context.Context, query GetUserQuery) (*UserDTO, error) {
    // 1. 检查缓存
    if cached, err := h.cache.Get(ctx, "user:"+query.ID); err == nil {
        return cached.(*UserDTO), nil
    }

    // 2. 查询数据库
    user, err := h.userRepo.FindByID(ctx, query.ID)
    if err != nil {
        return nil, err
    }

    // 3. 转换为 DTO
    dto := toUserDTO(user)

    // 4. 更新缓存
    h.cache.Set(ctx, "user:"+query.ID, dto, 5*time.Minute)

    return dto, nil
}
```

### 3.4 事件模式（Event Pattern）

**设计原理**：

1. 领域事件表示领域中的重要业务事件
2. 事件是不可变的，一旦创建就不能修改
3. 事件用于解耦业务逻辑，支持异步处理

**接口定义**：

```go
// internal/application/patterns/event.go

// Event 事件接口
type Event interface {
    Type() string
    Data() interface{}
    Timestamp() time.Time
}

// EventHandler 事件处理器接口
type EventHandler[T Event] interface {
    Handle(ctx context.Context, event T) error
}
```

**使用示例**：

```go
// 1. 定义领域事件
type UserCreatedEvent struct {
    patterns.BaseEvent
    UserID  string
    Email   string
    CreatedAt time.Time
}

func NewUserCreatedEvent(user *domain.User) *UserCreatedEvent {
    return &UserCreatedEvent{
        BaseEvent: *patterns.NewBaseEvent("user.created", user),
        UserID:    user.ID,
        Email:     user.Email,
        CreatedAt: user.CreatedAt,
    }
}

// 2. 定义事件处理器
type SendWelcomeEmailHandler struct {
    emailService EmailService
}

func (h *SendWelcomeEmailHandler) Handle(ctx context.Context, event *UserCreatedEvent) error {
    return h.emailService.SendWelcomeEmail(ctx, event.Email)
}
```

### 3.5 DTO 模式

**设计原理**：

1. DTO（Data Transfer Object）用于在不同层之间传输数据
2. DTO 不包含业务逻辑，只包含数据
3. DTO 用于隔离领域模型和外部接口

**接口定义**：

```go
// internal/application/patterns/dto.go

// DTO 数据传输对象基类
type DTO struct {
    ID        string    `json:"id"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
}

// ToDTO 转换函数接口
type ToDTO[T any] interface {
    ToDTO() T
}
```

**使用示例**：

```go
// 1. 定义 DTO
type UserDTO struct {
    patterns.DTO
    Email string `json:"email" validate:"required,email"`
    Name  string `json:"name" validate:"required,min=2,max=50"`
}

// 2. 从领域对象转换为 DTO
func toUserDTO(user *domain.User) *UserDTO {
    return &UserDTO{
        DTO: patterns.DTO{
            ID:        user.ID,
            CreatedAt: user.CreatedAt,
            UpdatedAt: user.UpdatedAt,
        },
        Email: user.Email,
        Name:  user.Name,
    }
}
```

---

## 4. 依赖注入机制

### 4.1 Wire 依赖注入原理

> **📚 详细文档**：
> - [Wire 依赖注入全面解析](01-Wire依赖注入全面解析.md) - 核心原理、深度论证、完整示例
> - [Wire 知识矩阵与思维导图](02-Wire知识矩阵与思维导图.md) - 知识矩阵、思维导图、学习路径
> - [Wire 完整示例与实战](03-Wire完整示例与实战.md) - 实战案例、常见模式、故障排查
> - [Wire 依赖关系可视化](04-Wire依赖关系可视化.md) - 依赖关系图、矩阵、复杂度分析

**Wire 是什么？**

Wire 是 Google 开源的 Go 语言依赖注入工具，在编译时生成依赖注入代码。

**核心特性**：

- ✅ **编译时注入**：编译时生成代码，不是运行时反射
- ✅ **类型安全**：使用 Go 的类型系统，编译时检查
- ✅ **零反射**：生成的代码不使用反射，性能优秀
- ✅ **易于调试**：生成的代码可以查看，易于调试

**工作原理**：

1. 定义 Provider 函数：每个 Provider 函数创建一个依赖
2. 使用 `wire.Build` 声明依赖关系
3. 运行 `go generate` 或 `wire` 命令生成代码
4. 生成的代码在 `wire_gen.go` 文件中

### 4.2 Provider 函数设计

**Provider 函数规范**：

1. **命名规范**：使用 `NewXxx` 格式
2. **返回值**：返回依赖对象和错误（如果可能失败）
3. **参数**：通过参数声明依赖关系
4. **单一职责**：每个 Provider 只负责创建一个依赖

**示例**：

```go
// Provider 函数示例

// 1. 创建数据库客户端
func NewEntClient(cfg *config.Config) (*ent.Client, error) {
    return ent.NewClient(ent.Driver(...)), nil
}

// 2. 创建仓储
func NewUserRepository(client *ent.Client) domain.UserRepository {
    return entrepo.NewUserRepository(client)
}

// 3. 创建应用服务
func NewUserService(repo domain.UserRepository) *appuser.Service {
    return appuser.NewService(repo)
}

// 4. 创建路由
func NewRouter(userService *appuser.Service) *chirouter.Router {
    return chirouter.NewRouter(userService)
}
```

**Provider 集合**：

```go
// 使用 wire.NewSet 组织 Provider 函数

// 数据库相关 Provider
var DatabaseProviderSet = wire.NewSet(
    NewEntClient,
    NewUserRepository,
)

// 应用层 Provider
var ApplicationProviderSet = wire.NewSet(
    NewUserService,
)

// 接口层 Provider
var InterfaceProviderSet = wire.NewSet(
    NewRouter,
)

// 所有 Provider 集合
var AllProviderSet = wire.NewSet(
    DatabaseProviderSet,
    ApplicationProviderSet,
    InterfaceProviderSet,
)
```

### 4.3 依赖注入流程

**依赖注入流程**：

```text
1. Config (配置对象)
   ↓
2. Infrastructure Layer
   - NewEntClient(cfg) → *ent.Client
   - NewUserRepository(client) → domain.UserRepository
   ↓
3. Application Layer
   - NewUserService(repo) → *appuser.Service
   ↓
4. Interfaces Layer
   - NewRouter(service) → *chirouter.Router
   ↓
5. App
   - NewApp(router) → *App
```

**Wire 配置**：

```go
// scripts/wire/wire.go

//go:build wireinject

func InitializeApp(cfg *config.Config) (*App, error) {
    wire.Build(
        // Infrastructure
        NewEntClient,
        NewUserRepository,

        // Application
        NewUserService,

        // Interfaces
        NewRouter,

        // App
        NewApp,
    )
    return &App{}, nil
}
```

**生成代码**：

```bash
# 运行生成命令
go generate ./scripts/wire

# 或直接运行 wire
wire ./scripts/wire
```

### 4.4 最佳实践

**1. 按层次组织 Provider**:

```go
// 按层次组织，便于管理和理解
var (
    DatabaseProviderSet    = wire.NewSet(...)
    ApplicationProviderSet = wire.NewSet(...)
    InterfaceProviderSet   = wire.NewSet(...)
)
```

**2. 使用接口绑定**:

```go
// 如果实现类型不匹配接口，使用 wire.Bind
var RepositoryProviderSet = wire.NewSet(
    entrepo.NewUserRepository,
    wire.Bind(new(domain.UserRepository), new(*entrepo.UserRepository)),
)
```

**3. Provider 函数错误处理**:

```go
// Provider 函数应该返回错误
func NewEntClient(cfg *config.Config) (*ent.Client, error) {
    client, err := ent.Open("postgres", cfg.Database.DSN)
    if err != nil {
        return nil, fmt.Errorf("failed to open database: %w", err)
    }
    return client, nil
}
```

**4. 避免循环依赖**:

```go
// ❌ 错误：循环依赖
func NewService(repo Repository) *Service {
    return &Service{repo: repo}
}

func NewRepository(service *Service) Repository {
    return &Repository{service: service}
}

// ✅ 正确：单向依赖
func NewService(repo Repository) *Service {
    return &Service{repo: repo}
}

func NewRepository() Repository {
    return &Repository{}
}
```

---

## 5. 完整示例

### 5.1 领域模型定义

```go
// internal/domain/user/entity.go
package user

type User struct {
    ID        string
    Email     string
    Name      string
    CreatedAt time.Time
    UpdatedAt time.Time
}

func (u *User) ValidateEmail() error {
    // 验证邮箱格式
}

// internal/domain/user/repository.go
package user

type Repository interface {
    interfaces.Repository[*User]
    FindByEmail(ctx context.Context, email string) (*User, error)
}
```

### 5.2 应用服务实现

```go
// internal/application/user/service.go
package application

type UserService struct {
    repo user.Repository
}

func NewUserService(repo user.Repository) *UserService {
    return &UserService{repo: repo}
}

func (s *UserService) CreateUser(ctx context.Context, req CreateUserRequest) (*UserDTO, error) {
    // 1. 创建领域实体
    user := domain.NewUser(req.Email, req.Name)

    // 2. 验证
    if err := user.ValidateEmail(); err != nil {
        return nil, err
    }

    // 3. 保存
    if err := s.repo.Create(ctx, user); err != nil {
        return nil, err
    }

    // 4. 转换为 DTO
    return toUserDTO(user), nil
}
```

### 5.3 依赖注入配置

```go
// scripts/wire/wire.go

//go:build wireinject

func InitializeApp(cfg *config.Config) (*App, error) {
    wire.Build(
        // Infrastructure
        NewEntClient,
        NewUserRepository,

        // Application
        NewUserService,

        // Interfaces
        NewRouter,

        // App
        NewApp,
    )
    return &App{}, nil
}

// Provider 函数
func NewEntClient(cfg *config.Config) (*ent.Client, error) {
    return entdb.NewClientFromConfig(...)
}

func NewUserRepository(client *ent.Client) domain.UserRepository {
    return entrepo.NewUserRepository(client)
}

func NewUserService(repo domain.UserRepository) *appuser.Service {
    return appuser.NewService(repo)
}

func NewRouter(service *appuser.Service) *chirouter.Router {
    return chirouter.NewRouter(service)
}

func NewApp(router *chirouter.Router) *App {
    return &App{Router: router}
}
```

### 5.4 使用示例

```go
// cmd/server/main.go
package main

func main() {
    // 1. 加载配置
    cfg, err := config.LoadConfig()
    if err != nil {
        log.Fatal(err)
    }

    // 2. 初始化应用（依赖注入）
    app, err := wire.InitializeApp(cfg)
    if err != nil {
        log.Fatal(err)
    }

    // 3. 启动应用
    if err := app.Start(); err != nil {
        log.Fatal(err)
    }
}
```

---

## 📚 扩展阅读

- [Clean Architecture 详解](./clean-architecture.md)
- [领域模型设计](./domain-model.md)
- [Wire 依赖注入文档](./tech-stack/config/wire.md)
- [CQRS 模式实践](../../docs/advanced/architecture/)

---

> 📚 **总结**
> 本文档全面阐述了项目的架构模型、领域模型设计和依赖注入机制。通过清晰的层次划分、接口抽象和依赖注入，实现了业务逻辑与技术实现的分离，提高了系统的可测试性、可维护性和可扩展性。
