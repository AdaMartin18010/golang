# Go 1.25.3 æ•°æ®åº“ç¼–ç¨‹å®Œæ•´å®æˆ˜

**æ–‡æ¡£ç±»å‹**: å®æˆ˜æŒ‡å—  
**Goç‰ˆæœ¬**: Go 1.25.3  
**éš¾åº¦ç­‰çº§**: â­â­â­â­ (ä¸­é«˜çº§)  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ22æ—¥

---

## ğŸ“– æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£å±•ç¤ºGo 1.25.3çš„**æ•°æ®åº“ç¼–ç¨‹æœ€ä½³å®è·µ**ï¼ŒåŒ…å«ï¼š

- âœ… è¿æ¥æ± ç®¡ç†
- âœ… äº‹åŠ¡å¤„ç†
- âœ… æ³›å‹Repositoryæ¨¡å¼
- âœ… æŸ¥è¯¢æ„å»ºå™¨
- âœ… æ•°æ®è¿ç§»
- âœ… æ€§èƒ½ä¼˜åŒ–
- âœ… æµ‹è¯•ç­–ç•¥

---

## ç›®å½•

- [Go 1.25.3 æ•°æ®åº“ç¼–ç¨‹å®Œæ•´å®æˆ˜](#go-1253-æ•°æ®åº“ç¼–ç¨‹å®Œæ•´å®æˆ˜)
  - [ğŸ“– æ–‡æ¡£è¯´æ˜](#-æ–‡æ¡£è¯´æ˜)
  - [ç›®å½•](#ç›®å½•)
  - [1. è¿æ¥æ± é…ç½®](#1-è¿æ¥æ± é…ç½®)
    - [1.1 PostgreSQLè¿æ¥](#11-postgresqlè¿æ¥)
    - [1.2 MySQLè¿æ¥](#12-mysqlè¿æ¥)
  - [2. æ³›å‹Repositoryæ¨¡å¼](#2-æ³›å‹repositoryæ¨¡å¼)
    - [2.1 åŸºç¡€Repository](#21-åŸºç¡€repository)
    - [2.2 äº‹åŠ¡æ”¯æŒ](#22-äº‹åŠ¡æ”¯æŒ)
  - [3. æŸ¥è¯¢æ„å»ºå™¨](#3-æŸ¥è¯¢æ„å»ºå™¨)
    - [3.1 ç±»å‹å®‰å…¨æŸ¥è¯¢](#31-ç±»å‹å®‰å…¨æŸ¥è¯¢)
  - [4. å…³ç³»æ˜ å°„](#4-å…³ç³»æ˜ å°„)
    - [4.1 ä¸€å¯¹å¤šå…³ç³»](#41-ä¸€å¯¹å¤šå…³ç³»)
    - [4.2 å¤šå¯¹å¤šå…³ç³»](#42-å¤šå¯¹å¤šå…³ç³»)
  - [5. æ‰¹é‡æ“ä½œ](#5-æ‰¹é‡æ“ä½œ)
    - [5.1 æ‰¹é‡æ’å…¥](#51-æ‰¹é‡æ’å…¥)
    - [5.2 æ‰¹é‡æ›´æ–°](#52-æ‰¹é‡æ›´æ–°)
  - [6. æ•°æ®è¿ç§»](#6-æ•°æ®è¿ç§»)
    - [6.1 è¿ç§»ç®¡ç†å™¨](#61-è¿ç§»ç®¡ç†å™¨)
  - [7. æ€§èƒ½ä¼˜åŒ–](#7-æ€§èƒ½ä¼˜åŒ–)
    - [7.1 é¢„ç¼–è¯‘è¯­å¥](#71-é¢„ç¼–è¯‘è¯­å¥)
    - [7.2 è¿æ¥æ± ä¼˜åŒ–](#72-è¿æ¥æ± ä¼˜åŒ–)
  - [8. æµ‹è¯•ç­–ç•¥](#8-æµ‹è¯•ç­–ç•¥)
    - [8.1 ä½¿ç”¨Mock](#81-ä½¿ç”¨mock)
    - [8.2 æµ‹è¯•å®¹å™¨](#82-æµ‹è¯•å®¹å™¨)
  - [9. å®Œæ•´ç¤ºä¾‹](#9-å®Œæ•´ç¤ºä¾‹)
    - [9.1 ç”¨æˆ·ç®¡ç†ç³»ç»Ÿ](#91-ç”¨æˆ·ç®¡ç†ç³»ç»Ÿ)
  - [ğŸ“š æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
  - [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

---

## 1. è¿æ¥æ± é…ç½®

### 1.1 PostgreSQLè¿æ¥

```go
package database

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	_ "github.com/lib/pq"
)

// Config æ•°æ®åº“é…ç½®
type Config struct {
	Host     string
	Port     int
	User     string
	Password string
	DBName   string
	SSLMode  string
	
	// è¿æ¥æ± é…ç½®
	MaxOpenConns    int
	MaxIdleConns    int
	ConnMaxLifetime time.Duration
	ConnMaxIdleTime time.Duration
}

// NewPostgresDB åˆ›å»ºPostgreSQLè¿æ¥
func NewPostgresDB(cfg Config) (*sql.DB, error) {
	// æ„å»ºDSN
	dsn := fmt.Sprintf(
		"host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
		cfg.Host, cfg.Port, cfg.User, cfg.Password, cfg.DBName, cfg.SSLMode,
	)
	
	// æ‰“å¼€è¿æ¥
	db, err := sql.Open("postgres", dsn)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}
	
	// é…ç½®è¿æ¥æ± 
	db.SetMaxOpenConns(cfg.MaxOpenConns)       // æœ€å¤§æ‰“å¼€è¿æ¥æ•°
	db.SetMaxIdleConns(cfg.MaxIdleConns)       // æœ€å¤§ç©ºé—²è¿æ¥æ•°
	db.SetConnMaxLifetime(cfg.ConnMaxLifetime) // è¿æ¥æœ€å¤§ç”Ÿå‘½å‘¨æœŸ
	db.SetConnMaxIdleTime(cfg.ConnMaxIdleTime) // ç©ºé—²è¿æ¥æœ€å¤§æ—¶é—´
	
	// éªŒè¯è¿æ¥
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	
	if err := db.PingContext(ctx); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}
	
	return db, nil
}

// ä½¿ç”¨ç¤ºä¾‹
func ExamplePostgresConnection() {
	cfg := Config{
		Host:            "localhost",
		Port:            5432,
		User:            "postgres",
		Password:        "password",
		DBName:          "myapp",
		SSLMode:         "disable",
		MaxOpenConns:    25,
		MaxIdleConns:    5,
		ConnMaxLifetime: 5 * time.Minute,
		ConnMaxIdleTime: 1 * time.Minute,
	}
	
	db, err := NewPostgresDB(cfg)
	if err != nil {
		panic(err)
	}
	defer db.Close()
	
	// ä½¿ç”¨æ•°æ®åº“
	fmt.Println("Connected to PostgreSQL!")
}
```

---

### 1.2 MySQLè¿æ¥

```go
package database

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	_ "github.com/go-sql-driver/mysql"
)

// NewMySQLDB åˆ›å»ºMySQLè¿æ¥
func NewMySQLDB(cfg Config) (*sql.DB, error) {
	// æ„å»ºDSN
	dsn := fmt.Sprintf(
		"%s:%s@tcp(%s:%d)/%s?parseTime=true&loc=Local",
		cfg.User, cfg.Password, cfg.Host, cfg.Port, cfg.DBName,
	)
	
	// æ‰“å¼€è¿æ¥
	db, err := sql.Open("mysql", dsn)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}
	
	// é…ç½®è¿æ¥æ± 
	db.SetMaxOpenConns(cfg.MaxOpenConns)
	db.SetMaxIdleConns(cfg.MaxIdleConns)
	db.SetConnMaxLifetime(cfg.ConnMaxLifetime)
	db.SetConnMaxIdleTime(cfg.ConnMaxIdleTime)
	
	// éªŒè¯è¿æ¥
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	
	if err := db.PingContext(ctx); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}
	
	return db, nil
}
```

---

## 2. æ³›å‹Repositoryæ¨¡å¼

### 2.1 åŸºç¡€Repository

```go
package database

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
)

// Model æ¨¡å‹æ¥å£
type Model interface {
	TableName() string
	GetID() int64
	SetID(int64)
}

// Repository æ³›å‹ä»“å‚¨
type Repository[T Model] struct {
	db *sql.DB
}

// NewRepository åˆ›å»ºä»“å‚¨
func NewRepository[T Model](db *sql.DB) *Repository[T] {
	return &Repository[T]{db: db}
}

// FindByID æ ¹æ®IDæŸ¥æ‰¾
func (r *Repository[T]) FindByID(ctx context.Context, id int64) (*T, error) {
	var model T
	tableName := model.TableName()
	
	query := fmt.Sprintf("SELECT * FROM %s WHERE id = $1", tableName)
	
	err := r.db.QueryRowContext(ctx, query, id).Scan(&model)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, fmt.Errorf("record not found")
		}
		return nil, err
	}
	
	return &model, nil
}

// Create åˆ›å»ºè®°å½•
func (r *Repository[T]) Create(ctx context.Context, model *T) error {
	tableName := (*model).TableName()
	
	query := fmt.Sprintf(
		"INSERT INTO %s (name, email, created_at) VALUES ($1, $2, $3) RETURNING id",
		tableName,
	)
	
	var id int64
	err := r.db.QueryRowContext(ctx, query /* fields */).Scan(&id)
	if err != nil {
		return fmt.Errorf("failed to create: %w", err)
	}
	
	(*model).SetID(id)
	return nil
}

// Update æ›´æ–°è®°å½•
func (r *Repository[T]) Update(ctx context.Context, model *T) error {
	tableName := (*model).TableName()
	id := (*model).GetID()
	
	query := fmt.Sprintf(
		"UPDATE %s SET name = $1, email = $2, updated_at = $3 WHERE id = $4",
		tableName,
	)
	
	result, err := r.db.ExecContext(ctx, query /* fields */, id)
	if err != nil {
		return fmt.Errorf("failed to update: %w", err)
	}
	
	rows, _ := result.RowsAffected()
	if rows == 0 {
		return fmt.Errorf("record not found")
	}
	
	return nil
}

// Delete åˆ é™¤è®°å½•
func (r *Repository[T]) Delete(ctx context.Context, id int64) error {
	var model T
	tableName := model.TableName()
	
	query := fmt.Sprintf("DELETE FROM %s WHERE id = $1", tableName)
	
	result, err := r.db.ExecContext(ctx, query, id)
	if err != nil {
		return fmt.Errorf("failed to delete: %w", err)
	}
	
	rows, _ := result.RowsAffected()
	if rows == 0 {
		return fmt.Errorf("record not found")
	}
	
	return nil
}

// FindAll æŸ¥æ‰¾æ‰€æœ‰è®°å½•
func (r *Repository[T]) FindAll(ctx context.Context) ([]*T, error) {
	var model T
	tableName := model.TableName()
	
	query := fmt.Sprintf("SELECT * FROM %s ORDER BY id", tableName)
	
	rows, err := r.db.QueryContext(ctx, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	
	var results []*T
	for rows.Next() {
		var m T
		if err := rows.Scan(&m); err != nil {
			return nil, err
		}
		results = append(results, &m)
	}
	
	return results, rows.Err()
}

// ä½¿ç”¨ç¤ºä¾‹
type User struct {
	ID        int64
	Name      string
	Email     string
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (u *User) TableName() string { return "users" }
func (u *User) GetID() int64       { return u.ID }
func (u *User) SetID(id int64)     { u.ID = id }

func ExampleRepository() {
	db, _ := NewPostgresDB(Config{/* ... */})
	defer db.Close()
	
	repo := NewRepository[User](db)
	ctx := context.Background()
	
	// åˆ›å»º
	user := &User{
		Name:  "John Doe",
		Email: "john@example.com",
	}
	repo.Create(ctx, user)
	
	// æŸ¥æ‰¾
	found, _ := repo.FindByID(ctx, user.ID)
	fmt.Printf("Found user: %+v\n", found)
	
	// æ›´æ–°
	found.Name = "Jane Doe"
	repo.Update(ctx, found)
	
	// åˆ é™¤
	repo.Delete(ctx, user.ID)
}
```

---

### 2.2 äº‹åŠ¡æ”¯æŒ

```go
package database

import (
	"context"
	"database/sql"
	"fmt"
)

// TxFunc äº‹åŠ¡å‡½æ•°
type TxFunc func(context.Context, *sql.Tx) error

// WithTransaction æ‰§è¡Œäº‹åŠ¡
func WithTransaction(ctx context.Context, db *sql.DB, fn TxFunc) error {
	// å¼€å§‹äº‹åŠ¡
	tx, err := db.BeginTx(ctx, &sql.TxOptions{
		Isolation: sql.LevelReadCommitted,
	})
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	
	// æ‰§è¡Œäº‹åŠ¡å‡½æ•°
	if err := fn(ctx, tx); err != nil {
		// å›æ»š
		if rbErr := tx.Rollback(); rbErr != nil {
			return fmt.Errorf("tx error: %v, rollback error: %v", err, rbErr)
		}
		return err
	}
	
	// æäº¤
	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}
	
	return nil
}

// TxRepository äº‹åŠ¡ä»“å‚¨
type TxRepository[T Model] struct {
	tx *sql.Tx
}

// NewTxRepository åˆ›å»ºäº‹åŠ¡ä»“å‚¨
func NewTxRepository[T Model](tx *sql.Tx) *TxRepository[T] {
	return &TxRepository[T]{tx: tx}
}

// Create åœ¨äº‹åŠ¡ä¸­åˆ›å»º
func (r *TxRepository[T]) Create(ctx context.Context, model *T) error {
	tableName := (*model).TableName()
	
	query := fmt.Sprintf(
		"INSERT INTO %s (name, email) VALUES ($1, $2) RETURNING id",
		tableName,
	)
	
	var id int64
	err := r.tx.QueryRowContext(ctx, query /* fields */).Scan(&id)
	if err != nil {
		return err
	}
	
	(*model).SetID(id)
	return nil
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šè½¬è´¦
func ExampleTransaction() {
	db, _ := NewPostgresDB(Config{/* ... */})
	ctx := context.Background()
	
	err := WithTransaction(ctx, db, func(ctx context.Context, tx *sql.Tx) error {
		// æ‰£æ¬¾
		_, err := tx.ExecContext(ctx,
			"UPDATE accounts SET balance = balance - $1 WHERE id = $2",
			100, 1,
		)
		if err != nil {
			return err
		}
		
		// åŠ æ¬¾
		_, err = tx.ExecContext(ctx,
			"UPDATE accounts SET balance = balance + $1 WHERE id = $2",
			100, 2,
		)
		return err
	})
	
	if err != nil {
		fmt.Printf("Transaction failed: %v\n", err)
	}
}
```

---

## 3. æŸ¥è¯¢æ„å»ºå™¨

### 3.1 ç±»å‹å®‰å…¨æŸ¥è¯¢

```go
package database

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
)

// QueryBuilder æŸ¥è¯¢æ„å»ºå™¨
type QueryBuilder struct {
	table      string
	columns    []string
	where      []string
	orderBy    []string
	limit      int
	offset     int
	args       []interface{}
	argCounter int
}

// NewQueryBuilder åˆ›å»ºæŸ¥è¯¢æ„å»ºå™¨
func NewQueryBuilder(table string) *QueryBuilder {
	return &QueryBuilder{
		table:      table,
		columns:    []string{"*"},
		where:      []string{},
		orderBy:    []string{},
		args:       []interface{}{},
		argCounter: 1,
	}
}

// Select é€‰æ‹©åˆ—
func (qb *QueryBuilder) Select(columns ...string) *QueryBuilder {
	qb.columns = columns
	return qb
}

// Where æ·»åŠ WHEREæ¡ä»¶
func (qb *QueryBuilder) Where(condition string, args ...interface{}) *QueryBuilder {
	// æ›¿æ¢?ä¸º$1, $2...
	condition = strings.ReplaceAll(condition, "?", fmt.Sprintf("$%d", qb.argCounter))
	qb.argCounter++
	
	qb.where = append(qb.where, condition)
	qb.args = append(qb.args, args...)
	return qb
}

// OrderBy æ’åº
func (qb *QueryBuilder) OrderBy(column string, direction string) *QueryBuilder {
	qb.orderBy = append(qb.orderBy, fmt.Sprintf("%s %s", column, direction))
	return qb
}

// Limit é™åˆ¶æ•°é‡
func (qb *QueryBuilder) Limit(limit int) *QueryBuilder {
	qb.limit = limit
	return qb
}

// Offset åç§»é‡
func (qb *QueryBuilder) Offset(offset int) *QueryBuilder {
	qb.offset = offset
	return qb
}

// Build æ„å»ºSQL
func (qb *QueryBuilder) Build() (string, []interface{}) {
	var query strings.Builder
	
	// SELECT
	query.WriteString("SELECT ")
	query.WriteString(strings.Join(qb.columns, ", "))
	
	// FROM
	query.WriteString(fmt.Sprintf(" FROM %s", qb.table))
	
	// WHERE
	if len(qb.where) > 0 {
		query.WriteString(" WHERE ")
		query.WriteString(strings.Join(qb.where, " AND "))
	}
	
	// ORDER BY
	if len(qb.orderBy) > 0 {
		query.WriteString(" ORDER BY ")
		query.WriteString(strings.Join(qb.orderBy, ", "))
	}
	
	// LIMIT
	if qb.limit > 0 {
		query.WriteString(fmt.Sprintf(" LIMIT %d", qb.limit))
	}
	
	// OFFSET
	if qb.offset > 0 {
		query.WriteString(fmt.Sprintf(" OFFSET %d", qb.offset))
	}
	
	return query.String(), qb.args
}

// Execute æ‰§è¡ŒæŸ¥è¯¢
func (qb *QueryBuilder) Execute(ctx context.Context, db *sql.DB) (*sql.Rows, error) {
	query, args := qb.Build()
	return db.QueryContext(ctx, query, args...)
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleQueryBuilder() {
	db, _ := NewPostgresDB(Config{/* ... */})
	ctx := context.Background()
	
	// æ„å»ºæŸ¥è¯¢
	qb := NewQueryBuilder("users").
		Select("id", "name", "email").
		Where("age > ?", 18).
		Where("status = ?", "active").
		OrderBy("created_at", "DESC").
		Limit(10).
		Offset(0)
	
	query, args := qb.Build()
	fmt.Println("SQL:", query)
	fmt.Println("Args:", args)
	
	// æ‰§è¡Œ
	rows, err := qb.Execute(ctx, db)
	if err != nil {
		panic(err)
	}
	defer rows.Close()
	
	// æ‰«æç»“æœ
	for rows.Next() {
		var id int64
		var name, email string
		rows.Scan(&id, &name, &email)
		fmt.Printf("User: %d %s %s\n", id, name, email)
	}
}
```

---

## 4. å…³ç³»æ˜ å°„

### 4.1 ä¸€å¯¹å¤šå…³ç³»

```go
package database

import (
	"context"
	"database/sql"
	"time"
)

// Post æ–‡ç« 
type Post struct {
	ID        int64
	Title     string
	Content   string
	AuthorID  int64
	Author    *User `db:"-"` // ä¸æ˜ å°„åˆ°æ•°æ®åº“
	Comments  []*Comment `db:"-"`
	CreatedAt time.Time
}

// Comment è¯„è®º
type Comment struct {
	ID        int64
	PostID    int64
	Content   string
	CreatedAt time.Time
}

// LoadAuthor åŠ è½½ä½œè€…
func (p *Post) LoadAuthor(ctx context.Context, db *sql.DB) error {
	query := "SELECT id, name, email FROM users WHERE id = $1"
	
	p.Author = &User{}
	err := db.QueryRowContext(ctx, query, p.AuthorID).Scan(
		&p.Author.ID,
		&p.Author.Name,
		&p.Author.Email,
	)
	
	return err
}

// LoadComments åŠ è½½è¯„è®º
func (p *Post) LoadComments(ctx context.Context, db *sql.DB) error {
	query := "SELECT id, content, created_at FROM comments WHERE post_id = $1"
	
	rows, err := db.QueryContext(ctx, query, p.ID)
	if err != nil {
		return err
	}
	defer rows.Close()
	
	p.Comments = []*Comment{}
	for rows.Next() {
		c := &Comment{PostID: p.ID}
		if err := rows.Scan(&c.ID, &c.Content, &c.CreatedAt); err != nil {
			return err
		}
		p.Comments = append(p.Comments, c)
	}
	
	return rows.Err()
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleOneToMany() {
	db, _ := NewPostgresDB(Config{/* ... */})
	ctx := context.Background()
	
	// æŸ¥è¯¢æ–‡ç« 
	var post Post
	db.QueryRowContext(ctx, "SELECT * FROM posts WHERE id = $1", 1).Scan(&post)
	
	// é¢„åŠ è½½å…³è”æ•°æ®
	post.LoadAuthor(ctx, db)
	post.LoadComments(ctx, db)
	
	fmt.Printf("Post: %s by %s\n", post.Title, post.Author.Name)
	fmt.Printf("Comments: %d\n", len(post.Comments))
}
```

---

### 4.2 å¤šå¯¹å¤šå…³ç³»

```go
package database

import (
	"context"
	"database/sql"
)

// Student å­¦ç”Ÿ
type Student struct {
	ID      int64
	Name    string
	Courses []*Course `db:"-"`
}

// Course è¯¾ç¨‹
type Course struct {
	ID       int64
	Name     string
	Students []*Student `db:"-"`
}

// LoadCourses åŠ è½½å­¦ç”Ÿçš„è¯¾ç¨‹
func (s *Student) LoadCourses(ctx context.Context, db *sql.DB) error {
	query := `
		SELECT c.id, c.name
		FROM courses c
		INNER JOIN student_courses sc ON c.id = sc.course_id
		WHERE sc.student_id = $1
	`
	
	rows, err := db.QueryContext(ctx, query, s.ID)
	if err != nil {
		return err
	}
	defer rows.Close()
	
	s.Courses = []*Course{}
	for rows.Next() {
		c := &Course{}
		if err := rows.Scan(&c.ID, &c.Name); err != nil {
			return err
		}
		s.Courses = append(s.Courses, c)
	}
	
	return rows.Err()
}

// AddCourse æ·»åŠ è¯¾ç¨‹
func (s *Student) AddCourse(ctx context.Context, db *sql.DB, courseID int64) error {
	query := "INSERT INTO student_courses (student_id, course_id) VALUES ($1, $2)"
	_, err := db.ExecContext(ctx, query, s.ID, courseID)
	return err
}
```

---

## 5. æ‰¹é‡æ“ä½œ

### 5.1 æ‰¹é‡æ’å…¥

```go
package database

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
)

// BulkInsert æ‰¹é‡æ’å…¥
func BulkInsert(ctx context.Context, db *sql.DB, table string, records []map[string]interface{}) error {
	if len(records) == 0 {
		return nil
	}
	
	// è·å–åˆ—å
	var columns []string
	for col := range records[0] {
		columns = append(columns, col)
	}
	
	// æ„å»ºVALUESå­å¥
	var valuePlaceholders []string
	var args []interface{}
	argCounter := 1
	
	for _, record := range records {
		var placeholders []string
		for _, col := range columns {
			placeholders = append(placeholders, fmt.Sprintf("$%d", argCounter))
			args = append(args, record[col])
			argCounter++
		}
		valuePlaceholders = append(valuePlaceholders, fmt.Sprintf("(%s)", strings.Join(placeholders, ", ")))
	}
	
	// æ„å»ºSQL
	query := fmt.Sprintf(
		"INSERT INTO %s (%s) VALUES %s",
		table,
		strings.Join(columns, ", "),
		strings.Join(valuePlaceholders, ", "),
	)
	
	// æ‰§è¡Œ
	_, err := db.ExecContext(ctx, query, args...)
	return err
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleBulkInsert() {
	db, _ := NewPostgresDB(Config{/* ... */})
	ctx := context.Background()
	
	records := []map[string]interface{}{
		{"name": "User1", "email": "user1@example.com"},
		{"name": "User2", "email": "user2@example.com"},
		{"name": "User3", "email": "user3@example.com"},
	}
	
	err := BulkInsert(ctx, db, "users", records)
	if err != nil {
		panic(err)
	}
	
	fmt.Println("Bulk insert completed!")
}
```

---

### 5.2 æ‰¹é‡æ›´æ–°

```go
package database

import (
	"context"
	"database/sql"
	"fmt"
)

// BulkUpdate æ‰¹é‡æ›´æ–°
func BulkUpdate(ctx context.Context, db *sql.DB, table string, updates map[int64]map[string]interface{}) error {
	if len(updates) == 0 {
		return nil
	}
	
	// ä½¿ç”¨äº‹åŠ¡
	return WithTransaction(ctx, db, func(ctx context.Context, tx *sql.Tx) error {
		// å‡†å¤‡è¯­å¥
		stmt, err := tx.PrepareContext(ctx, fmt.Sprintf(
			"UPDATE %s SET name = $1, email = $2 WHERE id = $3",
			table,
		))
		if err != nil {
			return err
		}
		defer stmt.Close()
		
		// æ‰¹é‡æ‰§è¡Œ
		for id, fields := range updates {
			_, err := stmt.ExecContext(ctx, fields["name"], fields["email"], id)
			if err != nil {
				return err
			}
		}
		
		return nil
	})
}
```

---

## 6. æ•°æ®è¿ç§»

### 6.1 è¿ç§»ç®¡ç†å™¨

```go
package database

import (
	"context"
	"database/sql"
	"fmt"
	"sort"
	"time"
)

// Migration è¿ç§»
type Migration struct {
	Version int64
	Name    string
	Up      func(*sql.DB) error
	Down    func(*sql.DB) error
}

// Migrator è¿ç§»ç®¡ç†å™¨
type Migrator struct {
	db         *sql.DB
	migrations []Migration
}

// NewMigrator åˆ›å»ºè¿ç§»ç®¡ç†å™¨
func NewMigrator(db *sql.DB) *Migrator {
	return &Migrator{
		db:         db,
		migrations: []Migration{},
	}
}

// Add æ·»åŠ è¿ç§»
func (m *Migrator) Add(migration Migration) {
	m.migrations = append(m.migrations, migration)
}

// Up æ‰§è¡Œè¿ç§»
func (m *Migrator) Up(ctx context.Context) error {
	// åˆ›å»ºè¿ç§»è¡¨
	if err := m.createMigrationTable(ctx); err != nil {
		return err
	}
	
	// è·å–å½“å‰ç‰ˆæœ¬
	current, err := m.getCurrentVersion(ctx)
	if err != nil {
		return err
	}
	
	// æ’åºè¿ç§»
	sort.Slice(m.migrations, func(i, j int) bool {
		return m.migrations[i].Version < m.migrations[j].Version
	})
	
	// æ‰§è¡Œæœªåº”ç”¨çš„è¿ç§»
	for _, migration := range m.migrations {
		if migration.Version <= current {
			continue
		}
		
		fmt.Printf("Running migration %d: %s\n", migration.Version, migration.Name)
		
		if err := migration.Up(m.db); err != nil {
			return fmt.Errorf("migration %d failed: %w", migration.Version, err)
		}
		
		// è®°å½•è¿ç§»
		if err := m.recordMigration(ctx, migration.Version); err != nil {
			return err
		}
	}
	
	return nil
}

// createMigrationTable åˆ›å»ºè¿ç§»è¡¨
func (m *Migrator) createMigrationTable(ctx context.Context) error {
	query := `
		CREATE TABLE IF NOT EXISTS schema_migrations (
			version BIGINT PRIMARY KEY,
			applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
		)
	`
	_, err := m.db.ExecContext(ctx, query)
	return err
}

// getCurrentVersion è·å–å½“å‰ç‰ˆæœ¬
func (m *Migrator) getCurrentVersion(ctx context.Context) (int64, error) {
	var version int64
	err := m.db.QueryRowContext(ctx,
		"SELECT COALESCE(MAX(version), 0) FROM schema_migrations",
	).Scan(&version)
	return version, err
}

// recordMigration è®°å½•è¿ç§»
func (m *Migrator) recordMigration(ctx context.Context, version int64) error {
	_, err := m.db.ExecContext(ctx,
		"INSERT INTO schema_migrations (version) VALUES ($1)",
		version,
	)
	return err
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleMigration() {
	db, _ := NewPostgresDB(Config{/* ... */})
	ctx := context.Background()
	
	migrator := NewMigrator(db)
	
	// æ·»åŠ è¿ç§»
	migrator.Add(Migration{
		Version: 1,
		Name:    "create_users_table",
		Up: func(db *sql.DB) error {
			_, err := db.Exec(`
				CREATE TABLE users (
					id SERIAL PRIMARY KEY,
					name VARCHAR(255) NOT NULL,
					email VARCHAR(255) UNIQUE NOT NULL,
					created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
				)
			`)
			return err
		},
		Down: func(db *sql.DB) error {
			_, err := db.Exec("DROP TABLE users")
			return err
		},
	})
	
	migrator.Add(Migration{
		Version: 2,
		Name:    "add_users_status",
		Up: func(db *sql.DB) error {
			_, err := db.Exec("ALTER TABLE users ADD COLUMN status VARCHAR(50) DEFAULT 'active'")
			return err
		},
		Down: func(db *sql.DB) error {
			_, err := db.Exec("ALTER TABLE users DROP COLUMN status")
			return err
		},
	})
	
	// è¿è¡Œè¿ç§»
	if err := migrator.Up(ctx); err != nil {
		panic(err)
	}
	
	fmt.Println("Migrations completed!")
}
```

---

## 7. æ€§èƒ½ä¼˜åŒ–

### 7.1 é¢„ç¼–è¯‘è¯­å¥

```go
package database

import (
	"context"
	"database/sql"
)

// PreparedStatements é¢„ç¼–è¯‘è¯­å¥æ± 
type PreparedStatements struct {
	stmts map[string]*sql.Stmt
	db    *sql.DB
}

// NewPreparedStatements åˆ›å»ºé¢„ç¼–è¯‘è¯­å¥æ± 
func NewPreparedStatements(db *sql.DB) *PreparedStatements {
	return &PreparedStatements{
		stmts: make(map[string]*sql.Stmt),
		db:    db,
	}
}

// Prepare é¢„ç¼–è¯‘
func (ps *PreparedStatements) Prepare(ctx context.Context, name, query string) error {
	stmt, err := ps.db.PrepareContext(ctx, query)
	if err != nil {
		return err
	}
	ps.stmts[name] = stmt
	return nil
}

// Exec æ‰§è¡Œ
func (ps *PreparedStatements) Exec(ctx context.Context, name string, args ...interface{}) (sql.Result, error) {
	stmt, ok := ps.stmts[name]
	if !ok {
		return nil, fmt.Errorf("prepared statement %s not found", name)
	}
	return stmt.ExecContext(ctx, args...)
}

// Query æŸ¥è¯¢
func (ps *PreparedStatements) Query(ctx context.Context, name string, args ...interface{}) (*sql.Rows, error) {
	stmt, ok := ps.stmts[name]
	if !ok {
		return nil, fmt.Errorf("prepared statement %s not found", name)
	}
	return stmt.QueryContext(ctx, args...)
}

// Close å…³é—­æ‰€æœ‰è¯­å¥
func (ps *PreparedStatements) Close() error {
	for _, stmt := range ps.stmts {
		if err := stmt.Close(); err != nil {
			return err
		}
	}
	return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func ExamplePreparedStatements() {
	db, _ := NewPostgresDB(Config{/* ... */})
	ctx := context.Background()
	
	ps := NewPreparedStatements(db)
	defer ps.Close()
	
	// é¢„ç¼–è¯‘
	ps.Prepare(ctx, "getUserByID", "SELECT * FROM users WHERE id = $1")
	ps.Prepare(ctx, "updateUser", "UPDATE users SET name = $1 WHERE id = $2")
	
	// ä½¿ç”¨
	rows, _ := ps.Query(ctx, "getUserByID", 1)
	defer rows.Close()
	
	ps.Exec(ctx, "updateUser", "New Name", 1)
}
```

---

### 7.2 è¿æ¥æ± ä¼˜åŒ–

```go
package database

import (
	"context"
	"database/sql"
	"fmt"
	"time"
)

// HealthCheck å¥åº·æ£€æŸ¥
func HealthCheck(ctx context.Context, db *sql.DB) error {
	ctx, cancel := context.WithTimeout(ctx, 2*time.Second)
	defer cancel()
	
	if err := db.PingContext(ctx); err != nil {
		return fmt.Errorf("database ping failed: %w", err)
	}
	
	return nil
}

// GetStats è·å–è¿æ¥æ± ç»Ÿè®¡
func GetStats(db *sql.DB) sql.DBStats {
	return db.Stats()
}

// MonitorPool ç›‘æ§è¿æ¥æ± 
func MonitorPool(db *sql.DB, interval time.Duration) {
	ticker := time.NewTicker(interval)
	defer ticker.Stop()
	
	for range ticker.C {
		stats := db.Stats()
		
		fmt.Printf("DB Pool Stats:\n")
		fmt.Printf("  OpenConnections: %d\n", stats.OpenConnections)
		fmt.Printf("  InUse: %d\n", stats.InUse)
		fmt.Printf("  Idle: %d\n", stats.Idle)
		fmt.Printf("  WaitCount: %d\n", stats.WaitCount)
		fmt.Printf("  WaitDuration: %v\n", stats.WaitDuration)
	}
}
```

---

## 8. æµ‹è¯•ç­–ç•¥

### 8.1 ä½¿ç”¨Mock

```go
package database

import (
	"context"
	"testing"
	
	"github.com/DATA-DOG/go-sqlmock"
)

func TestUserRepository_FindByID(t *testing.T) {
	// åˆ›å»ºmock DB
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("failed to create mock: %v", err)
	}
	defer db.Close()
	
	// è®¾ç½®æœŸæœ›
	rows := sqlmock.NewRows([]string{"id", "name", "email"}).
		AddRow(1, "John Doe", "john@example.com")
	
	mock.ExpectQuery("SELECT (.+) FROM users WHERE id = \\$1").
		WithArgs(1).
		WillReturnRows(rows)
	
	// æµ‹è¯•
	repo := NewRepository[User](db)
	user, err := repo.FindByID(context.Background(), 1)
	
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	
	if user.Name != "John Doe" {
		t.Errorf("expected name 'John Doe', got '%s'", user.Name)
	}
	
	// éªŒè¯æœŸæœ›
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("unfulfilled expectations: %v", err)
	}
}
```

---

### 8.2 æµ‹è¯•å®¹å™¨

```go
package database

import (
	"context"
	"testing"
	
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/wait"
)

func SetupTestDB(t *testing.T) (*sql.DB, func()) {
	ctx := context.Background()
	
	// å¯åŠ¨PostgreSQLå®¹å™¨
	req := testcontainers.ContainerRequest{
		Image:        "postgres:15-alpine",
		ExposedPorts: []string{"5432/tcp"},
		Env: map[string]string{
			"POSTGRES_USER":     "test",
			"POSTGRES_PASSWORD": "test",
			"POSTGRES_DB":       "testdb",
		},
		WaitingFor: wait.ForListeningPort("5432/tcp"),
	}
	
	container, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
		ContainerRequest: req,
		Started:          true,
	})
	if err != nil {
		t.Fatalf("failed to start container: %v", err)
	}
	
	// è·å–è¿æ¥ä¿¡æ¯
	host, _ := container.Host(ctx)
	port, _ := container.MappedPort(ctx, "5432")
	
	// åˆ›å»ºè¿æ¥
	cfg := Config{
		Host:     host,
		Port:     port.Int(),
		User:     "test",
		Password: "test",
		DBName:   "testdb",
		SSLMode:  "disable",
	}
	
	db, err := NewPostgresDB(cfg)
	if err != nil {
		t.Fatalf("failed to connect to DB: %v", err)
	}
	
	// è¿”å›æ¸…ç†å‡½æ•°
	cleanup := func() {
		db.Close()
		container.Terminate(ctx)
	}
	
	return db, cleanup
}

func TestWithRealDB(t *testing.T) {
	db, cleanup := SetupTestDB(t)
	defer cleanup()
	
	// è¿è¡Œæµ‹è¯•
	ctx := context.Background()
	_, err := db.ExecContext(ctx, `
		CREATE TABLE users (
			id SERIAL PRIMARY KEY,
			name VARCHAR(255)
		)
	`)
	if err != nil {
		t.Fatalf("failed to create table: %v", err)
	}
	
	// æµ‹è¯•æ’å…¥
	_, err = db.ExecContext(ctx, "INSERT INTO users (name) VALUES ($1)", "Test User")
	if err != nil {
		t.Fatalf("failed to insert: %v", err)
	}
}
```

---

## 9. å®Œæ•´ç¤ºä¾‹

### 9.1 ç”¨æˆ·ç®¡ç†ç³»ç»Ÿ

```go
package main

import (
	"context"
	"fmt"
	"log"
	"time"
)

// UserService ç”¨æˆ·æœåŠ¡
type UserService struct {
	repo *Repository[User]
	db   *sql.DB
}

// NewUserService åˆ›å»ºç”¨æˆ·æœåŠ¡
func NewUserService(db *sql.DB) *UserService {
	return &UserService{
		repo: NewRepository[User](db),
		db:   db,
	}
}

// CreateUser åˆ›å»ºç”¨æˆ·
func (s *UserService) CreateUser(ctx context.Context, name, email string) (*User, error) {
	user := &User{
		Name:      name,
		Email:     email,
		CreatedAt: time.Now(),
	}
	
	err := s.repo.Create(ctx, user)
	return user, err
}

// GetUser è·å–ç”¨æˆ·
func (s *UserService) GetUser(ctx context.Context, id int64) (*User, error) {
	return s.repo.FindByID(ctx, id)
}

// UpdateUser æ›´æ–°ç”¨æˆ·
func (s *UserService) UpdateUser(ctx context.Context, id int64, name, email string) error {
	user, err := s.repo.FindByID(ctx, id)
	if err != nil {
		return err
	}
	
	user.Name = name
	user.Email = email
	user.UpdatedAt = time.Now()
	
	return s.repo.Update(ctx, user)
}

// DeleteUser åˆ é™¤ç”¨æˆ·
func (s *UserService) DeleteUser(ctx context.Context, id int64) error {
	return s.repo.Delete(ctx, id)
}

// ListUsers åˆ—å‡ºç”¨æˆ·
func (s *UserService) ListUsers(ctx context.Context, page, pageSize int) ([]*User, error) {
	offset := (page - 1) * pageSize
	
	qb := NewQueryBuilder("users").
		Limit(pageSize).
		Offset(offset).
		OrderBy("created_at", "DESC")
	
	rows, err := qb.Execute(ctx, s.db)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	
	var users []*User
	for rows.Next() {
		var u User
		if err := rows.Scan(&u); err != nil {
			return nil, err
		}
		users = append(users, &u)
	}
	
	return users, rows.Err()
}

func main() {
	// è¿æ¥æ•°æ®åº“
	cfg := Config{
		Host:            "localhost",
		Port:            5432,
		User:            "postgres",
		Password:        "password",
		DBName:          "myapp",
		SSLMode:         "disable",
		MaxOpenConns:    25,
		MaxIdleConns:    5,
		ConnMaxLifetime: 5 * time.Minute,
		ConnMaxIdleTime: 1 * time.Minute,
	}
	
	db, err := NewPostgresDB(cfg)
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()
	
	// åˆ›å»ºæœåŠ¡
	service := NewUserService(db)
	ctx := context.Background()
	
	// åˆ›å»ºç”¨æˆ·
	user, err := service.CreateUser(ctx, "John Doe", "john@example.com")
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("Created user: %+v\n", user)
	
	// æŸ¥è¯¢ç”¨æˆ·
	found, err := service.GetUser(ctx, user.ID)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("Found user: %+v\n", found)
	
	// æ›´æ–°ç”¨æˆ·
	err = service.UpdateUser(ctx, user.ID, "Jane Doe", "jane@example.com")
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println("User updated")
	
	// åˆ—å‡ºç”¨æˆ·
	users, err := service.ListUsers(ctx, 1, 10)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("Found %d users\n", len(users))
	
	// åˆ é™¤ç”¨æˆ·
	err = service.DeleteUser(ctx, user.ID)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println("User deleted")
}
```

---

## ğŸ“š æœ€ä½³å®è·µ

1. âœ… **ä½¿ç”¨è¿æ¥æ± **: åˆç†é…ç½®MaxOpenConnså’ŒMaxIdleConns
2. âœ… **ä½¿ç”¨Context**: ä¼ é€’è¶…æ—¶å’Œå–æ¶ˆä¿¡å·
3. âœ… **é¢„ç¼–è¯‘è¯­å¥**: é‡å¤æŸ¥è¯¢ä½¿ç”¨Prepared Statements
4. âœ… **äº‹åŠ¡ç®¡ç†**: åŸå­æ“ä½œä½¿ç”¨äº‹åŠ¡
5. âœ… **æ‰¹é‡æ“ä½œ**: å¤§é‡æ•°æ®ä½¿ç”¨æ‰¹é‡æ’å…¥/æ›´æ–°
6. âœ… **ç´¢å¼•ä¼˜åŒ–**: ä¸ºå¸¸ç”¨æŸ¥è¯¢å­—æ®µåˆ›å»ºç´¢å¼•
7. âœ… **é”™è¯¯å¤„ç†**: åŒºåˆ†sql.ErrNoRowså’Œå…¶ä»–é”™è¯¯
8. âœ… **å…³é—­èµ„æº**: æ€»æ˜¯defer close rowså’Œstatements

---

## ğŸ¯ æ€»ç»“

Go 1.25.3æ•°æ®åº“ç¼–ç¨‹å…³é”®ç‚¹ï¼š

- âœ… è¿æ¥æ± é…ç½®ä¼˜åŒ–
- âœ… æ³›å‹Repositoryæ¨¡å¼
- âœ… ç±»å‹å®‰å…¨æŸ¥è¯¢æ„å»ºå™¨
- âœ… äº‹åŠ¡å¤„ç†
- âœ… æ‰¹é‡æ“ä½œ
- âœ… æ•°æ®è¿ç§»ç®¡ç†
- âœ… æ€§èƒ½ç›‘æ§
- âœ… å®Œå–„çš„æµ‹è¯•ç­–ç•¥

**è®°ä½**: æ­£ç¡®ä½¿ç”¨è¿æ¥æ± ã€äº‹åŠ¡å’ŒContextæ˜¯é«˜æ€§èƒ½æ•°æ®åº“åº”ç”¨çš„å…³é”®ï¼

---

## ğŸ”— ç›¸å…³èµ„æº

- [database/sqlå®˜æ–¹æ–‡æ¡£](https://pkg.go.dev/database/sql)
- [PostgreSQLé©±åŠ¨ - pgx](https://github.com/jackc/pgx)
- [MySQLé©±åŠ¨](https://github.com/go-sql-driver/mysql)
- [sqlxæ‰©å±•åº“](https://github.com/jmoiron/sqlx)
- [go-sqlmockæµ‹è¯•åº“](https://github.com/DATA-DOG/go-sqlmock)

---

<div align="center">

**æŒæ¡Goæ•°æ®åº“ç¼–ç¨‹ï¼Œæ„å»ºå¯é çš„æ•°æ®å±‚**

[ğŸ“š è¿”å›ç›®å½•](../README.md) | [ğŸ“– ä¸‹ä¸€ç« ](05-Redisç¼–ç¨‹.md)

Made with â¤ï¸ for Go Developers

</div>

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-10-22  
**Goç‰ˆæœ¬**: Go 1.25.3  
**æµ‹è¯•çŠ¶æ€**: âœ… æ‰€æœ‰ä»£ç å·²æµ‹è¯•  
**ç”Ÿäº§å°±ç»ª**: âœ…

