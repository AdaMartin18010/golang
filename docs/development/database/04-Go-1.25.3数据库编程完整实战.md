# Go 1.25.3 数据库编程完整实战

**版本**: v1.0
**更新日期**: 2025-10-29
**适用于**: Go 1.25.3

---
## 📋 目录

- [Go 1.25.3 数据库编程完整实战](#go-1253-数据库编程完整实战)
  - [📖 文档说明](#文档说明)
  - [1. 连接池配置](#1-连接池配置)
  - [2. 泛型Repository模式](#2-泛型repository模式)
  - [3. 查询构建器](#3-查询构建器)
  - [4. 关系映射](#4-关系映射)
  - [5. 批量操作](#5-批量操作)
  - [6. 数据迁移](#6-数据迁移)
  - [7. 性能优化](#7-性能优化)
  - [8. 测试策略](#8-测试策略)
  - [9. 完整示例](#9-完整示例)
  - [📚 最佳实践](#最佳实践)
  - [🎯 总结](#总结)
  - [🔗 相关资源](#相关资源)

---

## 📖 文档说明

本文档展示Go 1.25.3的**数据库编程最佳实践**，包含：

- ✅ 连接池管理
- ✅ 事务处理
- ✅ 泛型Repository模式
- ✅ 查询构建器
- ✅ 数据迁移
- ✅ 性能优化
- ✅ 测试策略

---

## 1. 连接池配置

### 1.1 PostgreSQL连接

```go
package database

import (
 "Context"
 "database/sql"
 "fmt"
 "time"

 _ "github.com/lib/pq"
)

// Config 数据库配置
type Config struct {
 Host     string
 Port     int
 User     string
 Password string
 DBName   string
 SSLMode  string

 // 连接池配置
 MaxOpenConns    int
 MaxIdleConns    int
 ConnMaxLifetime time.Duration
 ConnMaxIdleTime time.Duration
}

// NewPostgresDB 创建PostgreSQL连接
func NewPostgresDB(cfg Config) (*sql.DB, error) {
 // 构建DSN
 dsn := fmt.Sprintf(
  "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
  cfg.Host, cfg.Port, cfg.User, cfg.Password, cfg.DBName, cfg.SSLMode,
 )

 // 打开连接
 db, err := sql.Open("postgres", dsn)
 if err != nil {
  return nil, fmt.Errorf("failed to open database: %w", err)
 }

 // 配置连接池
 db.SetMaxOpenConns(cfg.MaxOpenConns)       // 最大打开连接数
 db.SetMaxIdleConns(cfg.MaxIdleConns)       // 最大空闲连接数
 db.SetConnMaxLifetime(cfg.ConnMaxLifetime) // 连接最大生命周期
 db.SetConnMaxIdleTime(cfg.ConnMaxIdleTime) // 空闲连接最大时间

 // 验证连接
 ctx, cancel := Context.WithTimeout(Context.Background(), 5*time.Second)
 defer cancel()

 if err := db.PingContext(ctx); err != nil {
  return nil, fmt.Errorf("failed to ping database: %w", err)
 }

 return db, nil
}

// 使用示例
func ExamplePostgresConnection() {
 cfg := Config{
  Host:            "localhost",
  Port:            5432,
  User:            "postgres",
  Password:        "password",
  DBName:          "myapp",
  SSLMode:         "disable",
  MaxOpenConns:    25,
  MaxIdleConns:    5,
  ConnMaxLifetime: 5 * time.Minute,
  ConnMaxIdleTime: 1 * time.Minute,
 }

 db, err := NewPostgresDB(cfg)
 if err != nil {
  panic(err)
 }
 defer db.Close()

 // 使用数据库
 fmt.Println("Connected to PostgreSQL!")
}
```

---

### 1.2 MySQL连接

```go
package database

import (
 "Context"
 "database/sql"
 "fmt"
 "time"

 _ "github.com/go-sql-driver/mysql"
)

// NewMySQLDB 创建MySQL连接
func NewMySQLDB(cfg Config) (*sql.DB, error) {
 // 构建DSN
 dsn := fmt.Sprintf(
  "%s:%s@tcp(%s:%d)/%s?parseTime=true&loc=Local",
  cfg.User, cfg.Password, cfg.Host, cfg.Port, cfg.DBName,
 )

 // 打开连接
 db, err := sql.Open("mysql", dsn)
 if err != nil {
  return nil, fmt.Errorf("failed to open database: %w", err)
 }

 // 配置连接池
 db.SetMaxOpenConns(cfg.MaxOpenConns)
 db.SetMaxIdleConns(cfg.MaxIdleConns)
 db.SetConnMaxLifetime(cfg.ConnMaxLifetime)
 db.SetConnMaxIdleTime(cfg.ConnMaxIdleTime)

 // 验证连接
 ctx, cancel := Context.WithTimeout(Context.Background(), 5*time.Second)
 defer cancel()

 if err := db.PingContext(ctx); err != nil {
  return nil, fmt.Errorf("failed to ping database: %w", err)
 }

 return db, nil
}
```

---

## 2. 泛型Repository模式

### 2.1 基础Repository

```go
package database

import (
 "Context"
 "database/sql"
 "errors"
 "fmt"
)

// Model 模型接口
type Model interface {
 TableName() string
 GetID() int64
 SetID(int64)
}

// Repository 泛型仓储
type Repository[T Model] struct {
 db *sql.DB
}

// NewRepository 创建仓储
func NewRepository[T Model](db *sql.DB) *Repository[T] {
 return &Repository[T]{db: db}
}

// FindByID 根据ID查找
func (r *Repository[T]) FindByID(ctx Context.Context, id int64) (*T, error) {
 var model T
 tableName := model.TableName()

 query := fmt.Sprintf("SELECT * FROM %s WHERE id = $1", tableName)

 err := r.db.QueryRowContext(ctx, query, id).Scan(&model)
 if err != nil {
  if errors.Is(err, sql.ErrNoRows) {
   return nil, fmt.Errorf("record not found")
  }
  return nil, err
 }

 return &model, nil
}

// Create 创建记录
func (r *Repository[T]) Create(ctx Context.Context, model *T) error {
 tableName := (*model).TableName()

 query := fmt.Sprintf(
  "INSERT INTO %s (name, email, created_at) VALUES ($1, $2, $3) RETURNING id",
  tableName,
 )

 var id int64
 err := r.db.QueryRowContext(ctx, query /* fields */).Scan(&id)
 if err != nil {
  return fmt.Errorf("failed to create: %w", err)
 }

 (*model).SetID(id)
 return nil
}

// Update 更新记录
func (r *Repository[T]) Update(ctx Context.Context, model *T) error {
 tableName := (*model).TableName()
 id := (*model).GetID()

 query := fmt.Sprintf(
  "UPDATE %s SET name = $1, email = $2, updated_at = $3 WHERE id = $4",
  tableName,
 )

 result, err := r.db.ExecContext(ctx, query /* fields */, id)
 if err != nil {
  return fmt.Errorf("failed to update: %w", err)
 }

 rows, _ := result.RowsAffected()
 if rows == 0 {
  return fmt.Errorf("record not found")
 }

 return nil
}

// Delete 删除记录
func (r *Repository[T]) Delete(ctx Context.Context, id int64) error {
 var model T
 tableName := model.TableName()

 query := fmt.Sprintf("DELETE FROM %s WHERE id = $1", tableName)

 result, err := r.db.ExecContext(ctx, query, id)
 if err != nil {
  return fmt.Errorf("failed to delete: %w", err)
 }

 rows, _ := result.RowsAffected()
 if rows == 0 {
  return fmt.Errorf("record not found")
 }

 return nil
}

// FindAll 查找所有记录
func (r *Repository[T]) FindAll(ctx Context.Context) ([]*T, error) {
 var model T
 tableName := model.TableName()

 query := fmt.Sprintf("SELECT * FROM %s ORDER BY id", tableName)

 rows, err := r.db.QueryContext(ctx, query)
 if err != nil {
  return nil, err
 }
 defer rows.Close()

 var results []*T
 for rows.Next() {
  var m T
  if err := rows.Scan(&m); err != nil {
   return nil, err
  }
  results = append(results, &m)
 }

 return results, rows.Err()
}

// 使用示例
type User struct {
 ID        int64
 Name      string
 Email     string
 CreatedAt time.Time
 UpdatedAt time.Time
}

func (u *User) TableName() string { return "users" }
func (u *User) GetID() int64       { return u.ID }
func (u *User) SetID(id int64)     { u.ID = id }

func ExampleRepository() {
 db, _ := NewPostgresDB(Config{/* ... */})
 defer db.Close()

 repo := NewRepository[User](db)
 ctx := Context.Background()

 // 创建
 user := &User{
  Name:  "John Doe",
  Email: "john@example.com",
 }
 repo.Create(ctx, user)

 // 查找
 found, _ := repo.FindByID(ctx, user.ID)
 fmt.Printf("Found user: %+v\n", found)

 // 更新
 found.Name = "Jane Doe"
 repo.Update(ctx, found)

 // 删除
 repo.Delete(ctx, user.ID)
}
```

---

### 2.2 事务支持

```go
package database

import (
 "Context"
 "database/sql"
 "fmt"
)

// TxFunc 事务函数
type TxFunc func(Context.Context, *sql.Tx) error

// WithTransaction 执行事务
func WithTransaction(ctx Context.Context, db *sql.DB, fn TxFunc) error {
 // 开始事务
 tx, err := db.BeginTx(ctx, &sql.TxOptions{
  Isolation: sql.LevelReadCommitted,
 })
 if err != nil {
  return fmt.Errorf("failed to begin transaction: %w", err)
 }

 // 执行事务函数
 if err := fn(ctx, tx); err != nil {
  // 回滚
  if rbErr := tx.Rollback(); rbErr != nil {
   return fmt.Errorf("tx error: %v, rollback error: %v", err, rbErr)
  }
  return err
 }

 // 提交
 if err := tx.Commit(); err != nil {
  return fmt.Errorf("failed to commit transaction: %w", err)
 }

 return nil
}

// TxRepository 事务仓储
type TxRepository[T Model] struct {
 tx *sql.Tx
}

// NewTxRepository 创建事务仓储
func NewTxRepository[T Model](tx *sql.Tx) *TxRepository[T] {
 return &TxRepository[T]{tx: tx}
}

// Create 在事务中创建
func (r *TxRepository[T]) Create(ctx Context.Context, model *T) error {
 tableName := (*model).TableName()

 query := fmt.Sprintf(
  "INSERT INTO %s (name, email) VALUES ($1, $2) RETURNING id",
  tableName,
 )

 var id int64
 err := r.tx.QueryRowContext(ctx, query /* fields */).Scan(&id)
 if err != nil {
  return err
 }

 (*model).SetID(id)
 return nil
}

// 使用示例：转账
func ExampleTransaction() {
 db, _ := NewPostgresDB(Config{/* ... */})
 ctx := Context.Background()

 err := WithTransaction(ctx, db, func(ctx Context.Context, tx *sql.Tx) error {
  // 扣款
  _, err := tx.ExecContext(ctx,
   "UPDATE accounts SET balance = balance - $1 WHERE id = $2",
   100, 1,
  )
  if err != nil {
   return err
  }

  // 加款
  _, err = tx.ExecContext(ctx,
   "UPDATE accounts SET balance = balance + $1 WHERE id = $2",
   100, 2,
  )
  return err
 })

 if err != nil {
  fmt.Printf("Transaction failed: %v\n", err)
 }
}
```

---

## 3. 查询构建器

### 3.1 类型安全查询

```go
package database

import (
 "Context"
 "database/sql"
 "fmt"
 "strings"
)

// QueryBuilder 查询构建器
type QueryBuilder struct {
 table      string
 columns    []string
 where      []string
 orderBy    []string
 limit      int
 offset     int
 args       []interface{}
 argCounter int
}

// NewQueryBuilder 创建查询构建器
func NewQueryBuilder(table string) *QueryBuilder {
 return &QueryBuilder{
  table:      table,
  columns:    []string{"*"},
  where:      []string{},
  orderBy:    []string{},
  args:       []interface{}{},
  argCounter: 1,
 }
}

// Select 选择列
func (qb *QueryBuilder) Select(columns ...string) *QueryBuilder {
 qb.columns = columns
 return qb
}

// Where 添加WHERE条件
func (qb *QueryBuilder) Where(condition string, args ...interface{}) *QueryBuilder {
 // 替换?为$1, $2...
 condition = strings.ReplaceAll(condition, "?", fmt.Sprintf("$%d", qb.argCounter))
 qb.argCounter++

 qb.where = append(qb.where, condition)
 qb.args = append(qb.args, args...)
 return qb
}

// OrderBy 排序
func (qb *QueryBuilder) OrderBy(column string, direction string) *QueryBuilder {
 qb.orderBy = append(qb.orderBy, fmt.Sprintf("%s %s", column, direction))
 return qb
}

// Limit 限制数量
func (qb *QueryBuilder) Limit(limit int) *QueryBuilder {
 qb.limit = limit
 return qb
}

// Offset 偏移量
func (qb *QueryBuilder) Offset(offset int) *QueryBuilder {
 qb.offset = offset
 return qb
}

// Build 构建SQL
func (qb *QueryBuilder) Build() (string, []interface{}) {
 var query strings.Builder

 // SELECT
 query.WriteString("SELECT ")
 query.WriteString(strings.Join(qb.columns, ", "))

 // FROM
 query.WriteString(fmt.Sprintf(" FROM %s", qb.table))

 // WHERE
 if len(qb.where) > 0 {
  query.WriteString(" WHERE ")
  query.WriteString(strings.Join(qb.where, " AND "))
 }

 // ORDER BY
 if len(qb.orderBy) > 0 {
  query.WriteString(" ORDER BY ")
  query.WriteString(strings.Join(qb.orderBy, ", "))
 }

 // LIMIT
 if qb.limit > 0 {
  query.WriteString(fmt.Sprintf(" LIMIT %d", qb.limit))
 }

 // OFFSET
 if qb.offset > 0 {
  query.WriteString(fmt.Sprintf(" OFFSET %d", qb.offset))
 }

 return query.String(), qb.args
}

// Execute 执行查询
func (qb *QueryBuilder) Execute(ctx Context.Context, db *sql.DB) (*sql.Rows, error) {
 query, args := qb.Build()
 return db.QueryContext(ctx, query, args...)
}

// 使用示例
func ExampleQueryBuilder() {
 db, _ := NewPostgresDB(Config{/* ... */})
 ctx := Context.Background()

 // 构建查询
 qb := NewQueryBuilder("users").
  Select("id", "name", "email").
  Where("age > ?", 18).
  Where("status = ?", "active").
  OrderBy("created_at", "DESC").
  Limit(10).
  Offset(0)

 query, args := qb.Build()
 fmt.Println("SQL:", query)
 fmt.Println("Args:", args)

 // 执行
 rows, err := qb.Execute(ctx, db)
 if err != nil {
  panic(err)
 }
 defer rows.Close()

 // 扫描结果
 for rows.Next() {
  var id int64
  var name, email string
  rows.Scan(&id, &name, &email)
  fmt.Printf("User: %d %s %s\n", id, name, email)
 }
}
```

---

## 4. 关系映射

### 4.1 一对多关系

```go
package database

import (
 "Context"
 "database/sql"
 "time"
)

// Post 文章
type Post struct {
 ID        int64
 Title     string
 Content   string
 AuthorID  int64
 Author    *User `db:"-"` // 不映射到数据库
 Comments  []*Comment `db:"-"`
 CreatedAt time.Time
}

// Comment 评论
type Comment struct {
 ID        int64
 PostID    int64
 Content   string
 CreatedAt time.Time
}

// LoadAuthor 加载作者
func (p *Post) LoadAuthor(ctx Context.Context, db *sql.DB) error {
 query := "SELECT id, name, email FROM users WHERE id = $1"

 p.Author = &User{}
 err := db.QueryRowContext(ctx, query, p.AuthorID).Scan(
  &p.Author.ID,
  &p.Author.Name,
  &p.Author.Email,
 )

 return err
}

// LoadComments 加载评论
func (p *Post) LoadComments(ctx Context.Context, db *sql.DB) error {
 query := "SELECT id, content, created_at FROM comments WHERE post_id = $1"

 rows, err := db.QueryContext(ctx, query, p.ID)
 if err != nil {
  return err
 }
 defer rows.Close()

 p.Comments = []*Comment{}
 for rows.Next() {
  c := &Comment{PostID: p.ID}
  if err := rows.Scan(&c.ID, &c.Content, &c.CreatedAt); err != nil {
   return err
  }
  p.Comments = append(p.Comments, c)
 }

 return rows.Err()
}

// 使用示例
func ExampleOneToMany() {
 db, _ := NewPostgresDB(Config{/* ... */})
 ctx := Context.Background()

 // 查询文章
 var post Post
 db.QueryRowContext(ctx, "SELECT * FROM posts WHERE id = $1", 1).Scan(&post)

 // 预加载关联数据
 post.LoadAuthor(ctx, db)
 post.LoadComments(ctx, db)

 fmt.Printf("Post: %s by %s\n", post.Title, post.Author.Name)
 fmt.Printf("Comments: %d\n", len(post.Comments))
}
```

---

### 4.2 多对多关系

```go
package database

import (
 "Context"
 "database/sql"
)

// Student 学生
type Student struct {
 ID      int64
 Name    string
 Courses []*Course `db:"-"`
}

// Course 课程
type Course struct {
 ID       int64
 Name     string
 Students []*Student `db:"-"`
}

// LoadCourses 加载学生的课程
func (s *Student) LoadCourses(ctx Context.Context, db *sql.DB) error {
 query := `
  SELECT c.id, c.name
  FROM courses c
  INNER JOIN student_courses sc ON c.id = sc.course_id
  WHERE sc.student_id = $1
 `

 rows, err := db.QueryContext(ctx, query, s.ID)
 if err != nil {
  return err
 }
 defer rows.Close()

 s.Courses = []*Course{}
 for rows.Next() {
  c := &Course{}
  if err := rows.Scan(&c.ID, &c.Name); err != nil {
   return err
  }
  s.Courses = append(s.Courses, c)
 }

 return rows.Err()
}

// AddCourse 添加课程
func (s *Student) AddCourse(ctx Context.Context, db *sql.DB, courseID int64) error {
 query := "INSERT INTO student_courses (student_id, course_id) VALUES ($1, $2)"
 _, err := db.ExecContext(ctx, query, s.ID, courseID)
 return err
}
```

---

## 5. 批量操作

### 5.1 批量插入

```go
package database

import (
 "Context"
 "database/sql"
 "fmt"
 "strings"
)

// BulkInsert 批量插入
func BulkInsert(ctx Context.Context, db *sql.DB, table string, records []map[string]interface{}) error {
 if len(records) == 0 {
  return nil
 }

 // 获取列名
 var columns []string
 for col := range records[0] {
  columns = append(columns, col)
 }

 // 构建VALUES子句
 var valuePlaceholders []string
 var args []interface{}
 argCounter := 1

 for _, record := range records {
  var placeholders []string
  for _, col := range columns {
   placeholders = append(placeholders, fmt.Sprintf("$%d", argCounter))
   args = append(args, record[col])
   argCounter++
  }
  valuePlaceholders = append(valuePlaceholders, fmt.Sprintf("(%s)", strings.Join(placeholders, ", ")))
 }

 // 构建SQL
 query := fmt.Sprintf(
  "INSERT INTO %s (%s) VALUES %s",
  table,
  strings.Join(columns, ", "),
  strings.Join(valuePlaceholders, ", "),
 )

 // 执行
 _, err := db.ExecContext(ctx, query, args...)
 return err
}

// 使用示例
func ExampleBulkInsert() {
 db, _ := NewPostgresDB(Config{/* ... */})
 ctx := Context.Background()

 records := []map[string]interface{}{
  {"name": "User1", "email": "user1@example.com"},
  {"name": "User2", "email": "user2@example.com"},
  {"name": "User3", "email": "user3@example.com"},
 }

 err := BulkInsert(ctx, db, "users", records)
 if err != nil {
  panic(err)
 }

 fmt.Println("Bulk insert completed!")
}
```

---

### 5.2 批量更新

```go
package database

import (
 "Context"
 "database/sql"
 "fmt"
)

// BulkUpdate 批量更新
func BulkUpdate(ctx Context.Context, db *sql.DB, table string, updates map[int64]map[string]interface{}) error {
 if len(updates) == 0 {
  return nil
 }

 // 使用事务
 return WithTransaction(ctx, db, func(ctx Context.Context, tx *sql.Tx) error {
  // 准备语句
  stmt, err := tx.PrepareContext(ctx, fmt.Sprintf(
   "UPDATE %s SET name = $1, email = $2 WHERE id = $3",
   table,
  ))
  if err != nil {
   return err
  }
  defer stmt.Close()

  // 批量执行
  for id, fields := range updates {
   _, err := stmt.ExecContext(ctx, fields["name"], fields["email"], id)
   if err != nil {
    return err
   }
  }

  return nil
 })
}
```

---

## 6. 数据迁移

### 6.1 迁移管理器

```go
package database

import (
 "Context"
 "database/sql"
 "fmt"
 "sort"
 "time"
)

// Migration 迁移
type Migration struct {
 Version int64
 Name    string
 Up      func(*sql.DB) error
 Down    func(*sql.DB) error
}

// Migrator 迁移管理器
type Migrator struct {
 db         *sql.DB
 migrations []Migration
}

// NewMigrator 创建迁移管理器
func NewMigrator(db *sql.DB) *Migrator {
 return &Migrator{
  db:         db,
  migrations: []Migration{},
 }
}

// Add 添加迁移
func (m *Migrator) Add(migration Migration) {
 m.migrations = append(m.migrations, migration)
}

// Up 执行迁移
func (m *Migrator) Up(ctx Context.Context) error {
 // 创建迁移表
 if err := m.createMigrationTable(ctx); err != nil {
  return err
 }

 // 获取当前版本
 current, err := m.getCurrentVersion(ctx)
 if err != nil {
  return err
 }

 // 排序迁移
 sort.Slice(m.migrations, func(i, j int) bool {
  return m.migrations[i].Version < m.migrations[j].Version
 })

 // 执行未应用的迁移
 for _, migration := range m.migrations {
  if migration.Version <= current {
   continue
  }

  fmt.Printf("Running migration %d: %s\n", migration.Version, migration.Name)

  if err := migration.Up(m.db); err != nil {
   return fmt.Errorf("migration %d failed: %w", migration.Version, err)
  }

  // 记录迁移
  if err := m.recordMigration(ctx, migration.Version); err != nil {
   return err
  }
 }

 return nil
}

// createMigrationTable 创建迁移表
func (m *Migrator) createMigrationTable(ctx Context.Context) error {
 query := `
  CREATE TABLE IF NOT EXISTS schema_migrations (
   version BIGINT PRIMARY KEY,
   applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  )
 `
 _, err := m.db.ExecContext(ctx, query)
 return err
}

// getCurrentVersion 获取当前版本
func (m *Migrator) getCurrentVersion(ctx Context.Context) (int64, error) {
 var version int64
 err := m.db.QueryRowContext(ctx,
  "SELECT COALESCE(MAX(version), 0) FROM schema_migrations",
 ).Scan(&version)
 return version, err
}

// recordMigration 记录迁移
func (m *Migrator) recordMigration(ctx Context.Context, version int64) error {
 _, err := m.db.ExecContext(ctx,
  "INSERT INTO schema_migrations (version) VALUES ($1)",
  version,
 )
 return err
}

// 使用示例
func ExampleMigration() {
 db, _ := NewPostgresDB(Config{/* ... */})
 ctx := Context.Background()

 migrator := NewMigrator(db)

 // 添加迁移
 migrator.Add(Migration{
  Version: 1,
  Name:    "create_users_table",
  Up: func(db *sql.DB) error {
   _, err := db.Exec(`
    CREATE TABLE users (
     id SERIAL PRIMARY KEY,
     name VARCHAR(255) NOT NULL,
     email VARCHAR(255) UNIQUE NOT NULL,
     created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
   `)
   return err
  },
  Down: func(db *sql.DB) error {
   _, err := db.Exec("DROP TABLE users")
   return err
  },
 })

 migrator.Add(Migration{
  Version: 2,
  Name:    "add_users_status",
  Up: func(db *sql.DB) error {
   _, err := db.Exec("ALTER TABLE users ADD COLUMN status VARCHAR(50) DEFAULT 'active'")
   return err
  },
  Down: func(db *sql.DB) error {
   _, err := db.Exec("ALTER TABLE users DROP COLUMN status")
   return err
  },
 })

 // 运行迁移
 if err := migrator.Up(ctx); err != nil {
  panic(err)
 }

 fmt.Println("Migrations completed!")
}
```

---

## 7. 性能优化

### 7.1 预编译语句

```go
package database

import (
 "Context"
 "database/sql"
)

// PreparedStatements 预编译语句池
type PreparedStatements struct {
 stmts map[string]*sql.Stmt
 db    *sql.DB
}

// NewPreparedStatements 创建预编译语句池
func NewPreparedStatements(db *sql.DB) *PreparedStatements {
 return &PreparedStatements{
  stmts: make(map[string]*sql.Stmt),
  db:    db,
 }
}

// Prepare 预编译
func (ps *PreparedStatements) Prepare(ctx Context.Context, name, query string) error {
 stmt, err := ps.db.PrepareContext(ctx, query)
 if err != nil {
  return err
 }
 ps.stmts[name] = stmt
 return nil
}

// Exec 执行
func (ps *PreparedStatements) Exec(ctx Context.Context, name string, args ...interface{}) (sql.Result, error) {
 stmt, ok := ps.stmts[name]
 if !ok {
  return nil, fmt.Errorf("prepared statement %s not found", name)
 }
 return stmt.ExecContext(ctx, args...)
}

// Query 查询
func (ps *PreparedStatements) Query(ctx Context.Context, name string, args ...interface{}) (*sql.Rows, error) {
 stmt, ok := ps.stmts[name]
 if !ok {
  return nil, fmt.Errorf("prepared statement %s not found", name)
 }
 return stmt.QueryContext(ctx, args...)
}

// Close 关闭所有语句
func (ps *PreparedStatements) Close() error {
 for _, stmt := range ps.stmts {
  if err := stmt.Close(); err != nil {
   return err
  }
 }
 return nil
}

// 使用示例
func ExamplePreparedStatements() {
 db, _ := NewPostgresDB(Config{/* ... */})
 ctx := Context.Background()

 ps := NewPreparedStatements(db)
 defer ps.Close()

 // 预编译
 ps.Prepare(ctx, "getUserByID", "SELECT * FROM users WHERE id = $1")
 ps.Prepare(ctx, "updateUser", "UPDATE users SET name = $1 WHERE id = $2")

 // 使用
 rows, _ := ps.Query(ctx, "getUserByID", 1)
 defer rows.Close()

 ps.Exec(ctx, "updateUser", "New Name", 1)
}
```

---

### 7.2 连接池优化

```go
package database

import (
 "Context"
 "database/sql"
 "fmt"
 "time"
)

// HealthCheck 健康检查
func HealthCheck(ctx Context.Context, db *sql.DB) error {
 ctx, cancel := Context.WithTimeout(ctx, 2*time.Second)
 defer cancel()

 if err := db.PingContext(ctx); err != nil {
  return fmt.Errorf("database ping failed: %w", err)
 }

 return nil
}

// GetStats 获取连接池统计
func GetStats(db *sql.DB) sql.DBStats {
 return db.Stats()
}

// MonitorPool 监控连接池
func MonitorPool(db *sql.DB, interval time.Duration) {
 ticker := time.NewTicker(interval)
 defer ticker.Stop()

 for range ticker.C {
  stats := db.Stats()

  fmt.Printf("DB Pool Stats:\n")
  fmt.Printf("  OpenConnections: %d\n", stats.OpenConnections)
  fmt.Printf("  InUse: %d\n", stats.InUse)
  fmt.Printf("  Idle: %d\n", stats.Idle)
  fmt.Printf("  WaitCount: %d\n", stats.WaitCount)
  fmt.Printf("  WaitDuration: %v\n", stats.WaitDuration)
 }
}
```

---

## 8. 测试策略

### 8.1 使用Mock

```go
package database

import (
 "Context"
 "testing"

 "github.com/DATA-DOG/go-sqlmock"
)

func TestUserRepository_FindByID(t *testing.T) {
 // 创建mock DB
 db, mock, err := sqlmock.New()
 if err != nil {
  t.Fatalf("failed to create mock: %v", err)
 }
 defer db.Close()

 // 设置期望
 rows := sqlmock.NewRows([]string{"id", "name", "email"}).
  AddRow(1, "John Doe", "john@example.com")

 mock.ExpectQuery("SELECT (.+) FROM users WHERE id = \\$1").
  WithArgs(1).
  WillReturnRows(rows)

 // 测试
 repo := NewRepository[User](db)
 user, err := repo.FindByID(Context.Background(), 1)

 if err != nil {
  t.Errorf("unexpected error: %v", err)
 }

 if user.Name != "John Doe" {
  t.Errorf("expected name 'John Doe', got '%s'", user.Name)
 }

 // 验证期望
 if err := mock.ExpectationsWereMet(); err != nil {
  t.Errorf("unfulfilled expectations: %v", err)
 }
}
```

---

### 8.2 测试容器

```go
package database

import (
 "Context"
 "testing"

 "github.com/testcontainers/testcontainers-go"
 "github.com/testcontainers/testcontainers-go/wait"
)

func SetupTestDB(t *testing.T) (*sql.DB, func()) {
 ctx := Context.Background()

 // 启动PostgreSQL容器
 req := testcontainers.ContainerRequest{
  Image:        "postgres:15-alpine",
  ExposedPorts: []string{"5432/tcp"},
  Env: map[string]string{
   "POSTGRES_USER":     "test",
   "POSTGRES_PASSWORD": "test",
   "POSTGRES_DB":       "testdb",
  },
  WaitingFor: wait.ForListeningPort("5432/tcp"),
 }

 container, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
  ContainerRequest: req,
  Started:          true,
 })
 if err != nil {
  t.Fatalf("failed to start container: %v", err)
 }

 // 获取连接信息
 host, _ := container.Host(ctx)
 port, _ := container.MappedPort(ctx, "5432")

 // 创建连接
 cfg := Config{
  Host:     host,
  Port:     port.Int(),
  User:     "test",
  Password: "test",
  DBName:   "testdb",
  SSLMode:  "disable",
 }

 db, err := NewPostgresDB(cfg)
 if err != nil {
  t.Fatalf("failed to connect to DB: %v", err)
 }

 // 返回清理函数
 cleanup := func() {
  db.Close()
  container.Terminate(ctx)
 }

 return db, cleanup
}

func TestWithRealDB(t *testing.T) {
 db, cleanup := SetupTestDB(t)
 defer cleanup()

 // 运行测试
 ctx := Context.Background()
 _, err := db.ExecContext(ctx, `
  CREATE TABLE users (
   id SERIAL PRIMARY KEY,
   name VARCHAR(255)
  )
 `)
 if err != nil {
  t.Fatalf("failed to create table: %v", err)
 }

 // 测试插入
 _, err = db.ExecContext(ctx, "INSERT INTO users (name) VALUES ($1)", "Test User")
 if err != nil {
  t.Fatalf("failed to insert: %v", err)
 }
}
```

---

## 9. 完整示例

### 9.1 用户管理系统

```go
package main

import (
 "Context"
 "fmt"
 "log"
 "time"
)

// UserService 用户服务
type UserService struct {
 repo *Repository[User]
 db   *sql.DB
}

// NewUserService 创建用户服务
func NewUserService(db *sql.DB) *UserService {
 return &UserService{
  repo: NewRepository[User](db),
  db:   db,
 }
}

// CreateUser 创建用户
func (s *UserService) CreateUser(ctx Context.Context, name, email string) (*User, error) {
 user := &User{
  Name:      name,
  Email:     email,
  CreatedAt: time.Now(),
 }

 err := s.repo.Create(ctx, user)
 return user, err
}

// GetUser 获取用户
func (s *UserService) GetUser(ctx Context.Context, id int64) (*User, error) {
 return s.repo.FindByID(ctx, id)
}

// UpdateUser 更新用户
func (s *UserService) UpdateUser(ctx Context.Context, id int64, name, email string) error {
 user, err := s.repo.FindByID(ctx, id)
 if err != nil {
  return err
 }

 user.Name = name
 user.Email = email
 user.UpdatedAt = time.Now()

 return s.repo.Update(ctx, user)
}

// DeleteUser 删除用户
func (s *UserService) DeleteUser(ctx Context.Context, id int64) error {
 return s.repo.Delete(ctx, id)
}

// ListUsers 列出用户
func (s *UserService) ListUsers(ctx Context.Context, page, pageSize int) ([]*User, error) {
 offset := (page - 1) * pageSize

 qb := NewQueryBuilder("users").
  Limit(pageSize).
  Offset(offset).
  OrderBy("created_at", "DESC")

 rows, err := qb.Execute(ctx, s.db)
 if err != nil {
  return nil, err
 }
 defer rows.Close()

 var users []*User
 for rows.Next() {
  var u User
  if err := rows.Scan(&u); err != nil {
   return nil, err
  }
  users = append(users, &u)
 }

 return users, rows.Err()
}

func main() {
 // 连接数据库
 cfg := Config{
  Host:            "localhost",
  Port:            5432,
  User:            "postgres",
  Password:        "password",
  DBName:          "myapp",
  SSLMode:         "disable",
  MaxOpenConns:    25,
  MaxIdleConns:    5,
  ConnMaxLifetime: 5 * time.Minute,
  ConnMaxIdleTime: 1 * time.Minute,
 }

 db, err := NewPostgresDB(cfg)
 if err != nil {
  log.Fatal(err)
 }
 defer db.Close()

 // 创建服务
 service := NewUserService(db)
 ctx := Context.Background()

 // 创建用户
 user, err := service.CreateUser(ctx, "John Doe", "john@example.com")
 if err != nil {
  log.Fatal(err)
 }
 fmt.Printf("Created user: %+v\n", user)

 // 查询用户
 found, err := service.GetUser(ctx, user.ID)
 if err != nil {
  log.Fatal(err)
 }
 fmt.Printf("Found user: %+v\n", found)

 // 更新用户
 err = service.UpdateUser(ctx, user.ID, "Jane Doe", "jane@example.com")
 if err != nil {
  log.Fatal(err)
 }
 fmt.Println("User updated")

 // 列出用户
 users, err := service.ListUsers(ctx, 1, 10)
 if err != nil {
  log.Fatal(err)
 }
 fmt.Printf("Found %d users\n", len(users))

 // 删除用户
 err = service.DeleteUser(ctx, user.ID)
 if err != nil {
  log.Fatal(err)
 }
 fmt.Println("User deleted")
}
```

---

## 📚 最佳实践

1. ✅ **使用连接池**: 合理配置MaxOpenConns和MaxIdleConns
2. ✅ **使用Context**: 传递超时和取消信号
3. ✅ **预编译语句**: 重复查询使用Prepared Statements
4. ✅ **事务管理**: 原子操作使用事务
5. ✅ **批量操作**: 大量数据使用批量插入/更新
6. ✅ **索引优化**: 为常用查询字段创建索引
7. ✅ **错误处理**: 区分sql.ErrNoRows和其他错误
8. ✅ **关闭资源**: 总是defer close rows和statements

---

## 🎯 总结

Go 1.25.3数据库编程关键点：

- ✅ 连接池配置优化
- ✅ 泛型Repository模式
- ✅ 类型安全查询构建器
- ✅ 事务处理
- ✅ 批量操作
- ✅ 数据迁移管理
- ✅ 性能监控
- ✅ 完善的测试策略

**记住**: 正确使用连接池、事务和Context是高性能数据库应用的关键！

---

## 🔗 相关资源
