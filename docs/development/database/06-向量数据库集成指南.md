# 向量数据库集成指南

> **难度**: ⭐⭐⭐⭐
> **标签**: #向量数据库 #AI #语义搜索 #Embedding

**版本**: v1.0
**更新日期**: 2025-10-29
**适用于**: Go 1.25.3

---

## 📋 目录

- [向量数据库集成指南](#向量数据库集成指南)
  - [📋 目录](#-目录)
  - [1. 向量数据库概述](#1-向量数据库概述)
    - [1.1 什么是向量数据库](#11-什么是向量数据库)
    - [1.2 应用场景](#12-应用场景)
    - [1.3 主流向量数据库对比](#13-主流向量数据库对比)
  - [2. Qdrant集成](#2-qdrant集成)
    - [2.1 快速开始](#21-快速开始)
    - [2.2 集合管理](#22-集合管理)
    - [2.3 向量操作](#23-向量操作)
  - [3. Weaviate集成](#3-weaviate集成)
    - [3.1 客户端配置](#31-客户端配置)
    - [3.2 Schema定义](#32-schema定义)
    - [3.3 数据操作](#33-数据操作)
  - [6. Embedding集成](#6-embedding集成)
    - [6.1 OpenAI Embeddings](#61-openai-embeddings)
    - [6.3 Embedding缓存](#63-embedding缓存)
  - [7. 实战案例](#7-实战案例)
    - [7.1 语义搜索系统](#71-语义搜索系统)
  - [10. 参考资源](#10-参考资源)
    - [官方文档](#官方文档)
    - [Go客户端](#go客户端)
    - [Embedding服务](#embedding服务)

## 1. 向量数据库概述

### 1.1 什么是向量数据库

**向量数据库** 是专门用于存储、索引和查询高维向量数据的数据库系统。

**核心概念**:

- **向量/Embedding**: 文本、图片等数据的数值化表示
- **相似度**: 向量间的距离（余弦、欧氏等）
- **ANN**: 近似最近邻搜索（Approximate Nearest Neighbor）
- **索引**: HNSW、IVF等高效索引结构

**工作流程**:

```text
1. 数据 → 2. Embedding → 3. 存储 → 4. 搜索
   文本      向量表示      向量数据库   相似度检索
```

### 1.2 应用场景

**典型应用**:

| 场景 | 说明 | 示例 |
|------|------|------|
| **语义搜索** | 基于意义的搜索 | 智能问答、文档检索 |
| **推荐系统** | 相似内容推荐 | 商品、视频推荐 |
| **RAG** | 检索增强生成 | ChatGPT插件、知识库 |
| **图片搜索** | 以图搜图 | 电商、图库管理 |
| **异常检测** | 识别异常模式 | 欺诈检测、安全监控 |

### 1.3 主流向量数据库对比

**特性对比**:

| 数据库 | 开源 | 语言 | 特点 | 适用场景 |
|--------|------|------|------|----------|
| **Qdrant** | ✅ | Rust | 高性能、易用 | 中小规模 |
| **Weaviate** | ✅ | Go | 模块化、GraphQL | 企业级 |
| **Milvus** | ✅ | C++/Go | 超大规模、分布式 | 海量数据 |
| **Pinecone** | ❌ | - | 云服务、托管 | 快速上线 |
| **Chroma** | ✅ | Python | 轻量、嵌入式 | 原型开发 |

---

## 2. Qdrant集成

### 2.1 快速开始

**安装Qdrant客户端**:

```bash
go get github.com/qdrant/go-client
```

**基础连接**:

```go
package main

import (
    "context"
    "fmt"
    "log"

    "github.com/qdrant/go-client/qdrant"
)

func main() {
    // 创建客户端
    client, err := qdrant.NewClient(&qdrant.Config{
        Host: "localhost",
        Port: 6334,
        APIKey: "",  // 如果需要
        UseTLS: false,
    })
    if err != nil {
        log.Fatal(err)
    }
    defer client.Close()

    // 测试连接
    ctx := context.Background()
    collections, err := client.ListCollections(ctx)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Found %d collections\n", len(collections))
}
```

### 2.2 集合管理

**创建集合**:

```go
package qdrant

import (
    "context"
    "fmt"

    "github.com/qdrant/go-client/qdrant"
)

// CollectionManager 集合管理器
type CollectionManager struct {
    client *qdrant.Client
}

func NewCollectionManager(client *qdrant.Client) *CollectionManager {
    return &CollectionManager{client: client}
}

// CreateCollection 创建集合
func (cm *CollectionManager) CreateCollection(ctx context.Context, name string, vectorSize uint64) error {
    // 集合配置
    config := &qdrant.CreateCollection{
        VectorSize: vectorSize,
        Distance:   qdrant.Distance_Cosine, // 余弦相似度
    }

    // 创建集合
    if err := cm.client.CreateCollection(ctx, name, config); err != nil {
        return fmt.Errorf("create collection: %w", err)
    }

    fmt.Printf("Collection %s created with vector size %d\n", name, vectorSize)
    return nil
}

// DeleteCollection 删除集合
func (cm *CollectionManager) DeleteCollection(ctx context.Context, name string) error {
    if err := cm.client.DeleteCollection(ctx, name); err != nil {
        return fmt.Errorf("delete collection: %w", err)
    }

    fmt.Printf("Collection %s deleted\n", name)
    return nil
}

// GetCollectionInfo 获取集合信息
func (cm *CollectionManager) GetCollectionInfo(ctx context.Context, name string) (*qdrant.CollectionInfo, error) {
    info, err := cm.client.GetCollection(ctx, name)
    if err != nil {
        return nil, fmt.Errorf("get collection: %w", err)
    }

    fmt.Printf("Collection: %s\n", name)
    fmt.Printf("  Vectors: %d\n", info.VectorsCount)
    fmt.Printf("  Points: %d\n", info.PointsCount)
    fmt.Printf("  Status: %s\n", info.Status)

    return info, nil
}
```

### 2.3 向量操作

**插入和查询向量**:

```go
package qdrant

import (
    "context"
    "fmt"

    "github.com/google/uuid"
    "github.com/qdrant/go-client/qdrant"
)

// VectorOperations 向量操作
type VectorOperations struct {
    client         *qdrant.Client
    collectionName string
}

func NewVectorOperations(client *qdrant.Client, collectionName string) *VectorOperations {
    return &VectorOperations{
        client:         client,
        collectionName: collectionName,
    }
}

// Document 文档结构
type Document struct {
    ID      string
    Content string
    Vector  []float32
    Meta    map[string]interface{}
}

// Upsert 插入或更新向量
func (vo *VectorOperations) Upsert(ctx context.Context, doc *Document) error {
    point := &qdrant.Point{
        ID:      qdrant.NewIDNum(uuid.New().ID()),
        Vector:  doc.Vector,
        Payload: doc.Meta,
    }

    points := []*qdrant.Point{point}

    _, err := vo.client.Upsert(ctx, vo.collectionName, &qdrant.UpsertPoints{
        Points: points,
    })

    if err != nil {
        return fmt.Errorf("upsert point: %w", err)
    }

    fmt.Printf("Upserted document: %s\n", doc.ID)
    return nil
}

// Search 搜索相似向量
func (vo *VectorOperations) Search(ctx context.Context, queryVector []float32, limit uint64) ([]*qdrant.ScoredPoint, error) {
    // 搜索参数
    searchParams := &qdrant.SearchPoints{
        Vector: queryVector,
        Limit:  limit,
        WithPayload: &qdrant.WithPayloadSelector{
            Include: &qdrant.PayloadIncludeSelector{
                Fields: []string{"content", "title", "url"},
            },
        },
    }

    // 执行搜索
    results, err := vo.client.Search(ctx, vo.collectionName, searchParams)
    if err != nil {
        return nil, fmt.Errorf("search: %w", err)
    }

    fmt.Printf("Found %d similar documents\n", len(results))
    for i, result := range results {
        fmt.Printf("%d. Score: %.4f, ID: %v\n", i+1, result.Score, result.ID)
    }

    return results, nil
}

// BatchUpsert 批量插入
func (vo *VectorOperations) BatchUpsert(ctx context.Context, docs []*Document) error {
    points := make([]*qdrant.Point, len(docs))

    for i, doc := range docs {
        points[i] = &qdrant.Point{
            ID:      qdrant.NewIDNum(uint64(i)),
            Vector:  doc.Vector,
            Payload: doc.Meta,
        }
    }

    _, err := vo.client.Upsert(ctx, vo.collectionName, &qdrant.UpsertPoints{
        Points: points,
    })

    if err != nil {
        return fmt.Errorf("batch upsert: %w", err)
    }

    fmt.Printf("Batch upserted %d documents\n", len(docs))
    return nil
}
```

---

## 3. Weaviate集成

### 3.1 客户端配置

**Weaviate Go客户端**:

```bash
go get github.com/weaviate/weaviate-go-client/v4
```

```go
package main

import (
    "context"
    "fmt"
    "log"

    "github.com/weaviate/weaviate-go-client/v4/weaviate"
)

func main() {
    // 配置客户端
    cfg := weaviate.Config{
        Host:   "localhost:8080",
        Scheme: "http",
    }

    client, err := weaviate.NewClient(cfg)
    if err != nil {
        log.Fatal(err)
    }

    // 测试连接
    ctx := context.Background()
    meta, err := client.Misc().MetaGetter().Do(ctx)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Weaviate version: %s\n", meta.Version)
}
```

### 3.2 Schema定义

**创建Schema**:

```go
package weaviate

import (
    "context"
    "fmt"

    "github.com/weaviate/weaviate-go-client/v4/weaviate"
    "github.com/weaviate/weaviate-go-client/v4/weaviate/models"
)

// SchemaManager Schema管理器
type SchemaManager struct {
    client *weaviate.Client
}

func NewSchemaManager(client *weaviate.Client) *SchemaManager {
    return &SchemaManager{client: client}
}

// CreateArticleClass 创建Article类
func (sm *SchemaManager) CreateArticleClass(ctx context.Context) error {
    // 定义类Schema
    classSchema := &models.Class{
        Class:       "Article",
        Description: "Article with semantic search",
        Vectorizer:  "text2vec-transformers",
        Properties: []*models.Property{
            {
                Name:        "title",
                DataType:    []string{"string"},
                Description: "Article title",
            },
            {
                Name:        "content",
                DataType:    []string{"text"},
                Description: "Article content",
            },
            {
                Name:        "url",
                DataType:    []string{"string"},
                Description: "Article URL",
            },
            {
                Name:        "publishDate",
                DataType:    []string{"date"},
                Description: "Publish date",
            },
        },
    }

    // 创建类
    err := sm.client.Schema().ClassCreator().WithClass(classSchema).Do(ctx)
    if err != nil {
        return fmt.Errorf("create class: %w", err)
    }

    fmt.Println("Article class created")
    return nil
}

// GetSchema 获取Schema
func (sm *SchemaManager) GetSchema(ctx context.Context) (*models.Schema, error) {
    schema, err := sm.client.Schema().Getter().Do(ctx)
    if err != nil {
        return nil, fmt.Errorf("get schema: %w", err)
    }

    fmt.Printf("Found %d classes\n", len(schema.Classes))
    for _, class := range schema.Classes {
        fmt.Printf("  - %s (%d properties)\n", class.Class, len(class.Properties))
    }

    return schema, nil
}
```

### 3.3 数据操作

**CRUD操作**:

```go
package weaviate

import (
    "context"
    "fmt"

    "github.com/weaviate/weaviate-go-client/v4/weaviate"
    "github.com/weaviate/weaviate-go-client/v4/weaviate/data"
    "github.com/weaviate/weaviate-go-client/v4/weaviate/graphql"
)

// DataOperations 数据操作
type DataOperations struct {
    client *weaviate.Client
}

func NewDataOperations(client *weaviate.Client) *DataOperations {
    return &DataOperations{client: client}
}

// Article 文章结构
type Article struct {
    Title       string `json:"title"`
    Content     string `json:"content"`
    URL         string `json:"url"`
    PublishDate string `json:"publishDate"`
}

// Create 创建对象
func (do *DataOperations) Create(ctx context.Context, article *Article) (string, error) {
    // 创建数据对象
    creator := do.client.Data().Creator().
        WithClassName("Article").
        WithProperties(map[string]interface{}{
            "title":       article.Title,
            "content":     article.Content,
            "url":         article.URL,
            "publishDate": article.PublishDate,
        })

    // 执行创建
    created, err := creator.Do(ctx)
    if err != nil {
        return "", fmt.Errorf("create object: %w", err)
    }

    id := created.Object.ID.String()
    fmt.Printf("Created article: %s\n", id)
    return id, nil
}

// Search 语义搜索
func (do *DataOperations) Search(ctx context.Context, query string, limit int) (*models.GraphQLResponse, error) {
    // GraphQL查询
    nearText := do.client.GraphQL().NearTextArgBuilder().
        WithConcepts([]string{query})

    result, err := do.client.GraphQL().Get().
        WithClassName("Article").
        WithFields(graphql.Field{Name: "title"}, graphql.Field{Name: "content"}, graphql.Field{Name: "url"}).
        WithNearText(nearText).
        WithLimit(limit).
        Do(ctx)

    if err != nil {
        return nil, fmt.Errorf("search: %w", err)
    }

    fmt.Printf("Search completed: %d results\n", len(result.Data["Get"].(map[string]interface{})["Article"].([]interface{})))
    return result, nil
}

// Delete 删除对象
func (do *DataOperations) Delete(ctx context.Context, id string) error {
    err := do.client.Data().Deleter().
        WithClassName("Article").
        WithID(id).
        Do(ctx)

    if err != nil {
        return fmt.Errorf("delete object: %w", err)
    }

    fmt.Printf("Deleted article: %s\n", id)
    return nil
}
```

---

## 6. Embedding集成

### 6.1 OpenAI Embeddings

**OpenAI Embedding生成**:

```go
package embedding

import (
    "context"
    "fmt"

    "github.com/sashabaranov/go-openai"
)

// OpenAIEmbedder OpenAI Embedding生成器
type OpenAIEmbedder struct {
    client *openai.Client
    model  string
}

func NewOpenAIEmbedder(apiKey string) *OpenAIEmbedder {
    return &OpenAIEmbedder{
        client: openai.NewClient(apiKey),
        model:  openai.AdaEmbeddingV2, // text-embedding-ada-002
    }
}

// Embed 生成单个文本的Embedding
func (e *OpenAIEmbedder) Embed(ctx context.Context, text string) ([]float32, error) {
    req := openai.EmbeddingRequest{
        Input: []string{text},
        Model: e.model,
    }

    resp, err := e.client.CreateEmbeddings(ctx, req)
    if err != nil {
        return nil, fmt.Errorf("create embedding: %w", err)
    }

    if len(resp.Data) == 0 {
        return nil, fmt.Errorf("no embedding returned")
    }

    return resp.Data[0].Embedding, nil
}

// BatchEmbed 批量生成Embedding
func (e *OpenAIEmbedder) BatchEmbed(ctx context.Context, texts []string) ([][]float32, error) {
    // OpenAI API限制：每次最多处理2048个输入
    batchSize := 100
    allEmbeddings := make([][]float32, 0, len(texts))

    for i := 0; i < len(texts); i += batchSize {
        end := i + batchSize
        if end > len(texts) {
            end = len(texts)
        }

        batch := texts[i:end]

        req := openai.EmbeddingRequest{
            Input: batch,
            Model: e.model,
        }

        resp, err := e.client.CreateEmbeddings(ctx, req)
        if err != nil {
            return nil, fmt.Errorf("batch embed: %w", err)
        }

        for _, data := range resp.Data {
            allEmbeddings = append(allEmbeddings, data.Embedding)
        }

        fmt.Printf("Processed batch %d-%d\n", i, end)
    }

    return allEmbeddings, nil
}
```

### 6.3 Embedding缓存

**Redis缓存Embedding**:

```go
package embedding

import (
    "context"
    "crypto/sha256"
    "encoding/json"
    "fmt"
    "time"

    "github.com/redis/go-redis/v9"
)

// CachedEmbedder 带缓存的Embedding生成器
type CachedEmbedder struct {
    embedder Embedder
    redis    *redis.Client
    ttl      time.Duration
}

type Embedder interface {
    Embed(ctx context.Context, text string) ([]float32, error)
}

func NewCachedEmbedder(embedder Embedder, redisClient *redis.Client) *CachedEmbedder {
    return &CachedEmbedder{
        embedder: embedder,
        redis:    redisClient,
        ttl:      24 * time.Hour, // 缓存24小时
    }
}

// Embed 生成Embedding（带缓存）
func (ce *CachedEmbedder) Embed(ctx context.Context, text string) ([]float32, error) {
    // 生成缓存key
    cacheKey := ce.generateCacheKey(text)

    // 尝试从缓存读取
    cached, err := ce.redis.Get(ctx, cacheKey).Bytes()
    if err == nil {
        var embedding []float32
        if err := json.Unmarshal(cached, &embedding); err == nil {
            fmt.Println("Cache hit")
            return embedding, nil
        }
    }

    // 缓存未命中，生成新的Embedding
    fmt.Println("Cache miss, generating embedding")
    embedding, err := ce.embedder.Embed(ctx, text)
    if err != nil {
        return nil, err
    }

    // 存入缓存
    data, _ := json.Marshal(embedding)
    ce.redis.Set(ctx, cacheKey, data, ce.ttl)

    return embedding, nil
}

func (ce *CachedEmbedder) generateCacheKey(text string) string {
    hash := sha256.Sum256([]byte(text))
    return fmt.Sprintf("embedding:%x", hash)
}
```

---

## 7. 实战案例

### 7.1 语义搜索系统

**完整的语义搜索系统**:

```go
package search

import (
    "context"
    "fmt"

    "github.com/qdrant/go-client/qdrant"
)

// SemanticSearchEngine 语义搜索引擎
type SemanticSearchEngine struct {
    vectorDB  *qdrant.Client
    embedder  Embedder
    collectionName string
}

type SearchResult struct {
    ID      string
    Score   float32
    Content string
    Meta    map[string]interface{}
}

func NewSemanticSearchEngine(vectorDB *qdrant.Client, embedder Embedder, collection string) *SemanticSearchEngine {
    return &SemanticSearchEngine{
        vectorDB:  vectorDB,
        embedder:  embedder,
        collectionName: collection,
    }
}

// Index 索引文档
func (se *SemanticSearchEngine) Index(ctx context.Context, id, content string, meta map[string]interface{}) error {
    // 生成Embedding
    vector, err := se.embedder.Embed(ctx, content)
    if err != nil {
        return fmt.Errorf("generate embedding: %w", err)
    }

    // 准备payload
    payload := make(map[string]interface{})
    payload["content"] = content
    for k, v := range meta {
        payload[k] = v
    }

    // 插入向量数据库
    point := &qdrant.Point{
        ID:      qdrant.NewIDNum(hashString(id)),
        Vector:  vector,
        Payload: payload,
    }

    _, err = se.vectorDB.Upsert(ctx, se.collectionName, &qdrant.UpsertPoints{
        Points: []*qdrant.Point{point},
    })

    if err != nil {
        return fmt.Errorf("upsert vector: %w", err)
    }

    fmt.Printf("Indexed document: %s\n", id)
    return nil
}

// Search 搜索相似文档
func (se *SemanticSearchEngine) Search(ctx context.Context, query string, limit int) ([]*SearchResult, error) {
    // 生成查询向量
    queryVector, err := se.embedder.Embed(ctx, query)
    if err != nil {
        return nil, fmt.Errorf("generate query embedding: %w", err)
    }

    // 搜索相似向量
    searchParams := &qdrant.SearchPoints{
        Vector: queryVector,
        Limit:  uint64(limit),
        WithPayload: &qdrant.WithPayloadSelector{
            Include: &qdrant.PayloadIncludeSelector{
                Fields: []string{"content", "title", "url"},
            },
        },
    }

    results, err := se.vectorDB.Search(ctx, se.collectionName, searchParams)
    if err != nil {
        return nil, fmt.Errorf("search vectors: %w", err)
    }

    // 转换结果
    searchResults := make([]*SearchResult, len(results))
    for i, result := range results {
        searchResults[i] = &SearchResult{
            ID:      fmt.Sprintf("%v", result.ID),
            Score:   result.Score,
            Content: result.Payload["content"].(string),
            Meta:    result.Payload,
        }
    }

    fmt.Printf("Found %d similar documents\n", len(searchResults))
    return searchResults, nil
}

func hashString(s string) uint64 {
    h := uint64(0)
    for i := 0; i < len(s); i++ {
        h = 31*h + uint64(s[i])
    }
    return h
}
```

---

## 10. 参考资源

### 官方文档

- [Qdrant Documentation](https://qdrant.tech/documentation/)
- [Weaviate Documentation](https://weaviate.io/developers/weaviate)
- [Milvus Documentation](https://milvus.io/docs)

### Go客户端

- [qdrant-client](https://github.com/qdrant/go-client)
- [weaviate-go-client](https://github.com/weaviate/weaviate-go-client)
- [milvus-sdk-go](https://github.com/milvus-io/milvus-sdk-go)

### Embedding服务

- [OpenAI Embeddings API](https://platform.openai.com/docs/guides/embeddings)
- [Sentence Transformers](https://www.sbert.net/)

---

**文档维护者**: Go Documentation Team
**最后更新**: 2025-10-29
**文档状态**: ✅ 完成
**适用版本**: Go 1.21+

**贡献者**: 欢迎提交Issue和PR改进本文档
