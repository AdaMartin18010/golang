# å‘é‡æ•°æ®åº“é›†æˆæŒ‡å—

> **éš¾åº¦**: â­â­â­â­
> **æ ‡ç­¾**: #å‘é‡æ•°æ®åº“ #AI #è¯­ä¹‰æœç´¢ #Embedding

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.25.3

---

## ğŸ“‹ ç›®å½•

- [å‘é‡æ•°æ®åº“é›†æˆæŒ‡å—](#å‘é‡æ•°æ®åº“é›†æˆæŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å‘é‡æ•°æ®åº“æ¦‚è¿°](#1-å‘é‡æ•°æ®åº“æ¦‚è¿°)
    - [1.1 ä»€ä¹ˆæ˜¯å‘é‡æ•°æ®åº“](#11-ä»€ä¹ˆæ˜¯å‘é‡æ•°æ®åº“)
    - [1.2 åº”ç”¨åœºæ™¯](#12-åº”ç”¨åœºæ™¯)
    - [1.3 ä¸»æµå‘é‡æ•°æ®åº“å¯¹æ¯”](#13-ä¸»æµå‘é‡æ•°æ®åº“å¯¹æ¯”)
  - [2. Qdranté›†æˆ](#2-qdranté›†æˆ)
    - [2.1 å¿«é€Ÿå¼€å§‹](#21-å¿«é€Ÿå¼€å§‹)
    - [2.2 é›†åˆç®¡ç†](#22-é›†åˆç®¡ç†)
    - [2.3 å‘é‡æ“ä½œ](#23-å‘é‡æ“ä½œ)
  - [3. Weaviateé›†æˆ](#3-weaviateé›†æˆ)
    - [3.1 å®¢æˆ·ç«¯é…ç½®](#31-å®¢æˆ·ç«¯é…ç½®)
    - [3.2 Schemaå®šä¹‰](#32-schemaå®šä¹‰)
    - [3.3 æ•°æ®æ“ä½œ](#33-æ•°æ®æ“ä½œ)
  - [6. Embeddingé›†æˆ](#6-embeddingé›†æˆ)
    - [6.1 OpenAI Embeddings](#61-openai-embeddings)
    - [6.3 Embeddingç¼“å­˜](#63-embeddingç¼“å­˜)
  - [7. å®æˆ˜æ¡ˆä¾‹](#7-å®æˆ˜æ¡ˆä¾‹)
    - [7.1 è¯­ä¹‰æœç´¢ç³»ç»Ÿ](#71-è¯­ä¹‰æœç´¢ç³»ç»Ÿ)
  - [10. å‚è€ƒèµ„æº](#10-å‚è€ƒèµ„æº)
    - [å®˜æ–¹æ–‡æ¡£](#å®˜æ–¹æ–‡æ¡£)
    - [Goå®¢æˆ·ç«¯](#goå®¢æˆ·ç«¯)
    - [EmbeddingæœåŠ¡](#embeddingæœåŠ¡)

## 1. å‘é‡æ•°æ®åº“æ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯å‘é‡æ•°æ®åº“

**å‘é‡æ•°æ®åº“** æ˜¯ä¸“é—¨ç”¨äºå­˜å‚¨ã€ç´¢å¼•å’ŒæŸ¥è¯¢é«˜ç»´å‘é‡æ•°æ®çš„æ•°æ®åº“ç³»ç»Ÿã€‚

**æ ¸å¿ƒæ¦‚å¿µ**:

- **å‘é‡/Embedding**: æ–‡æœ¬ã€å›¾ç‰‡ç­‰æ•°æ®çš„æ•°å€¼åŒ–è¡¨ç¤º
- **ç›¸ä¼¼åº¦**: å‘é‡é—´çš„è·ç¦»ï¼ˆä½™å¼¦ã€æ¬§æ°ç­‰ï¼‰
- **ANN**: è¿‘ä¼¼æœ€è¿‘é‚»æœç´¢ï¼ˆApproximate Nearest Neighborï¼‰
- **ç´¢å¼•**: HNSWã€IVFç­‰é«˜æ•ˆç´¢å¼•ç»“æ„

**å·¥ä½œæµç¨‹**:

```text
1. æ•°æ® â†’ 2. Embedding â†’ 3. å­˜å‚¨ â†’ 4. æœç´¢
   æ–‡æœ¬      å‘é‡è¡¨ç¤º      å‘é‡æ•°æ®åº“   ç›¸ä¼¼åº¦æ£€ç´¢
```

### 1.2 åº”ç”¨åœºæ™¯

**å…¸å‹åº”ç”¨**:

| åœºæ™¯ | è¯´æ˜ | ç¤ºä¾‹ |
|------|------|------|
| **è¯­ä¹‰æœç´¢** | åŸºäºæ„ä¹‰çš„æœç´¢ | æ™ºèƒ½é—®ç­”ã€æ–‡æ¡£æ£€ç´¢ |
| **æ¨èç³»ç»Ÿ** | ç›¸ä¼¼å†…å®¹æ¨è | å•†å“ã€è§†é¢‘æ¨è |
| **RAG** | æ£€ç´¢å¢å¼ºç”Ÿæˆ | ChatGPTæ’ä»¶ã€çŸ¥è¯†åº“ |
| **å›¾ç‰‡æœç´¢** | ä»¥å›¾æœå›¾ | ç”µå•†ã€å›¾åº“ç®¡ç† |
| **å¼‚å¸¸æ£€æµ‹** | è¯†åˆ«å¼‚å¸¸æ¨¡å¼ | æ¬ºè¯ˆæ£€æµ‹ã€å®‰å…¨ç›‘æ§ |

### 1.3 ä¸»æµå‘é‡æ•°æ®åº“å¯¹æ¯”

**ç‰¹æ€§å¯¹æ¯”**:

| æ•°æ®åº“ | å¼€æº | è¯­è¨€ | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ |
|--------|------|------|------|----------|
| **Qdrant** | âœ… | Rust | é«˜æ€§èƒ½ã€æ˜“ç”¨ | ä¸­å°è§„æ¨¡ |
| **Weaviate** | âœ… | Go | æ¨¡å—åŒ–ã€GraphQL | ä¼ä¸šçº§ |
| **Milvus** | âœ… | C++/Go | è¶…å¤§è§„æ¨¡ã€åˆ†å¸ƒå¼ | æµ·é‡æ•°æ® |
| **Pinecone** | âŒ | - | äº‘æœåŠ¡ã€æ‰˜ç®¡ | å¿«é€Ÿä¸Šçº¿ |
| **Chroma** | âœ… | Python | è½»é‡ã€åµŒå…¥å¼ | åŸå‹å¼€å‘ |

---

## 2. Qdranté›†æˆ

### 2.1 å¿«é€Ÿå¼€å§‹

**å®‰è£…Qdrantå®¢æˆ·ç«¯**:

```bash
go get github.com/qdrant/go-client
```

**åŸºç¡€è¿æ¥**:

```go
package main

import (
    "context"
    "fmt"
    "log"

    "github.com/qdrant/go-client/qdrant"
)

func main() {
    // åˆ›å»ºå®¢æˆ·ç«¯
    client, err := qdrant.NewClient(&qdrant.Config{
        Host: "localhost",
        Port: 6334,
        APIKey: "",  // å¦‚æœéœ€è¦
        UseTLS: false,
    })
    if err != nil {
        log.Fatal(err)
    }
    defer client.Close()

    // æµ‹è¯•è¿æ¥
    ctx := context.Background()
    collections, err := client.ListCollections(ctx)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Found %d collections\n", len(collections))
}
```

### 2.2 é›†åˆç®¡ç†

**åˆ›å»ºé›†åˆ**:

```go
package qdrant

import (
    "context"
    "fmt"

    "github.com/qdrant/go-client/qdrant"
)

// CollectionManager é›†åˆç®¡ç†å™¨
type CollectionManager struct {
    client *qdrant.Client
}

func NewCollectionManager(client *qdrant.Client) *CollectionManager {
    return &CollectionManager{client: client}
}

// CreateCollection åˆ›å»ºé›†åˆ
func (cm *CollectionManager) CreateCollection(ctx context.Context, name string, vectorSize uint64) error {
    // é›†åˆé…ç½®
    config := &qdrant.CreateCollection{
        VectorSize: vectorSize,
        Distance:   qdrant.Distance_Cosine, // ä½™å¼¦ç›¸ä¼¼åº¦
    }

    // åˆ›å»ºé›†åˆ
    if err := cm.client.CreateCollection(ctx, name, config); err != nil {
        return fmt.Errorf("create collection: %w", err)
    }

    fmt.Printf("Collection %s created with vector size %d\n", name, vectorSize)
    return nil
}

// DeleteCollection åˆ é™¤é›†åˆ
func (cm *CollectionManager) DeleteCollection(ctx context.Context, name string) error {
    if err := cm.client.DeleteCollection(ctx, name); err != nil {
        return fmt.Errorf("delete collection: %w", err)
    }

    fmt.Printf("Collection %s deleted\n", name)
    return nil
}

// GetCollectionInfo è·å–é›†åˆä¿¡æ¯
func (cm *CollectionManager) GetCollectionInfo(ctx context.Context, name string) (*qdrant.CollectionInfo, error) {
    info, err := cm.client.GetCollection(ctx, name)
    if err != nil {
        return nil, fmt.Errorf("get collection: %w", err)
    }

    fmt.Printf("Collection: %s\n", name)
    fmt.Printf("  Vectors: %d\n", info.VectorsCount)
    fmt.Printf("  Points: %d\n", info.PointsCount)
    fmt.Printf("  Status: %s\n", info.Status)

    return info, nil
}
```

### 2.3 å‘é‡æ“ä½œ

**æ’å…¥å’ŒæŸ¥è¯¢å‘é‡**:

```go
package qdrant

import (
    "context"
    "fmt"

    "github.com/google/uuid"
    "github.com/qdrant/go-client/qdrant"
)

// VectorOperations å‘é‡æ“ä½œ
type VectorOperations struct {
    client         *qdrant.Client
    collectionName string
}

func NewVectorOperations(client *qdrant.Client, collectionName string) *VectorOperations {
    return &VectorOperations{
        client:         client,
        collectionName: collectionName,
    }
}

// Document æ–‡æ¡£ç»“æ„
type Document struct {
    ID      string
    Content string
    Vector  []float32
    Meta    map[string]interface{}
}

// Upsert æ’å…¥æˆ–æ›´æ–°å‘é‡
func (vo *VectorOperations) Upsert(ctx context.Context, doc *Document) error {
    point := &qdrant.Point{
        ID:      qdrant.NewIDNum(uuid.New().ID()),
        Vector:  doc.Vector,
        Payload: doc.Meta,
    }

    points := []*qdrant.Point{point}

    _, err := vo.client.Upsert(ctx, vo.collectionName, &qdrant.UpsertPoints{
        Points: points,
    })

    if err != nil {
        return fmt.Errorf("upsert point: %w", err)
    }

    fmt.Printf("Upserted document: %s\n", doc.ID)
    return nil
}

// Search æœç´¢ç›¸ä¼¼å‘é‡
func (vo *VectorOperations) Search(ctx context.Context, queryVector []float32, limit uint64) ([]*qdrant.ScoredPoint, error) {
    // æœç´¢å‚æ•°
    searchParams := &qdrant.SearchPoints{
        Vector: queryVector,
        Limit:  limit,
        WithPayload: &qdrant.WithPayloadSelector{
            Include: &qdrant.PayloadIncludeSelector{
                Fields: []string{"content", "title", "url"},
            },
        },
    }

    // æ‰§è¡Œæœç´¢
    results, err := vo.client.Search(ctx, vo.collectionName, searchParams)
    if err != nil {
        return nil, fmt.Errorf("search: %w", err)
    }

    fmt.Printf("Found %d similar documents\n", len(results))
    for i, result := range results {
        fmt.Printf("%d. Score: %.4f, ID: %v\n", i+1, result.Score, result.ID)
    }

    return results, nil
}

// BatchUpsert æ‰¹é‡æ’å…¥
func (vo *VectorOperations) BatchUpsert(ctx context.Context, docs []*Document) error {
    points := make([]*qdrant.Point, len(docs))

    for i, doc := range docs {
        points[i] = &qdrant.Point{
            ID:      qdrant.NewIDNum(uint64(i)),
            Vector:  doc.Vector,
            Payload: doc.Meta,
        }
    }

    _, err := vo.client.Upsert(ctx, vo.collectionName, &qdrant.UpsertPoints{
        Points: points,
    })

    if err != nil {
        return fmt.Errorf("batch upsert: %w", err)
    }

    fmt.Printf("Batch upserted %d documents\n", len(docs))
    return nil
}
```

---

## 3. Weaviateé›†æˆ

### 3.1 å®¢æˆ·ç«¯é…ç½®

**Weaviate Goå®¢æˆ·ç«¯**:

```bash
go get github.com/weaviate/weaviate-go-client/v4
```

```go
package main

import (
    "context"
    "fmt"
    "log"

    "github.com/weaviate/weaviate-go-client/v4/weaviate"
)

func main() {
    // é…ç½®å®¢æˆ·ç«¯
    cfg := weaviate.Config{
        Host:   "localhost:8080",
        Scheme: "http",
    }

    client, err := weaviate.NewClient(cfg)
    if err != nil {
        log.Fatal(err)
    }

    // æµ‹è¯•è¿æ¥
    ctx := context.Background()
    meta, err := client.Misc().MetaGetter().Do(ctx)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Weaviate version: %s\n", meta.Version)
}
```

### 3.2 Schemaå®šä¹‰

**åˆ›å»ºSchema**:

```go
package weaviate

import (
    "context"
    "fmt"

    "github.com/weaviate/weaviate-go-client/v4/weaviate"
    "github.com/weaviate/weaviate-go-client/v4/weaviate/models"
)

// SchemaManager Schemaç®¡ç†å™¨
type SchemaManager struct {
    client *weaviate.Client
}

func NewSchemaManager(client *weaviate.Client) *SchemaManager {
    return &SchemaManager{client: client}
}

// CreateArticleClass åˆ›å»ºArticleç±»
func (sm *SchemaManager) CreateArticleClass(ctx context.Context) error {
    // å®šä¹‰ç±»Schema
    classSchema := &models.Class{
        Class:       "Article",
        Description: "Article with semantic search",
        Vectorizer:  "text2vec-transformers",
        Properties: []*models.Property{
            {
                Name:        "title",
                DataType:    []string{"string"},
                Description: "Article title",
            },
            {
                Name:        "content",
                DataType:    []string{"text"},
                Description: "Article content",
            },
            {
                Name:        "url",
                DataType:    []string{"string"},
                Description: "Article URL",
            },
            {
                Name:        "publishDate",
                DataType:    []string{"date"},
                Description: "Publish date",
            },
        },
    }

    // åˆ›å»ºç±»
    err := sm.client.Schema().ClassCreator().WithClass(classSchema).Do(ctx)
    if err != nil {
        return fmt.Errorf("create class: %w", err)
    }

    fmt.Println("Article class created")
    return nil
}

// GetSchema è·å–Schema
func (sm *SchemaManager) GetSchema(ctx context.Context) (*models.Schema, error) {
    schema, err := sm.client.Schema().Getter().Do(ctx)
    if err != nil {
        return nil, fmt.Errorf("get schema: %w", err)
    }

    fmt.Printf("Found %d classes\n", len(schema.Classes))
    for _, class := range schema.Classes {
        fmt.Printf("  - %s (%d properties)\n", class.Class, len(class.Properties))
    }

    return schema, nil
}
```

### 3.3 æ•°æ®æ“ä½œ

**CRUDæ“ä½œ**:

```go
package weaviate

import (
    "context"
    "fmt"

    "github.com/weaviate/weaviate-go-client/v4/weaviate"
    "github.com/weaviate/weaviate-go-client/v4/weaviate/data"
    "github.com/weaviate/weaviate-go-client/v4/weaviate/graphql"
)

// DataOperations æ•°æ®æ“ä½œ
type DataOperations struct {
    client *weaviate.Client
}

func NewDataOperations(client *weaviate.Client) *DataOperations {
    return &DataOperations{client: client}
}

// Article æ–‡ç« ç»“æ„
type Article struct {
    Title       string `json:"title"`
    Content     string `json:"content"`
    URL         string `json:"url"`
    PublishDate string `json:"publishDate"`
}

// Create åˆ›å»ºå¯¹è±¡
func (do *DataOperations) Create(ctx context.Context, article *Article) (string, error) {
    // åˆ›å»ºæ•°æ®å¯¹è±¡
    creator := do.client.Data().Creator().
        WithClassName("Article").
        WithProperties(map[string]interface{}{
            "title":       article.Title,
            "content":     article.Content,
            "url":         article.URL,
            "publishDate": article.PublishDate,
        })

    // æ‰§è¡Œåˆ›å»º
    created, err := creator.Do(ctx)
    if err != nil {
        return "", fmt.Errorf("create object: %w", err)
    }

    id := created.Object.ID.String()
    fmt.Printf("Created article: %s\n", id)
    return id, nil
}

// Search è¯­ä¹‰æœç´¢
func (do *DataOperations) Search(ctx context.Context, query string, limit int) (*models.GraphQLResponse, error) {
    // GraphQLæŸ¥è¯¢
    nearText := do.client.GraphQL().NearTextArgBuilder().
        WithConcepts([]string{query})

    result, err := do.client.GraphQL().Get().
        WithClassName("Article").
        WithFields(graphql.Field{Name: "title"}, graphql.Field{Name: "content"}, graphql.Field{Name: "url"}).
        WithNearText(nearText).
        WithLimit(limit).
        Do(ctx)

    if err != nil {
        return nil, fmt.Errorf("search: %w", err)
    }

    fmt.Printf("Search completed: %d results\n", len(result.Data["Get"].(map[string]interface{})["Article"].([]interface{})))
    return result, nil
}

// Delete åˆ é™¤å¯¹è±¡
func (do *DataOperations) Delete(ctx context.Context, id string) error {
    err := do.client.Data().Deleter().
        WithClassName("Article").
        WithID(id).
        Do(ctx)

    if err != nil {
        return fmt.Errorf("delete object: %w", err)
    }

    fmt.Printf("Deleted article: %s\n", id)
    return nil
}
```

---

## 6. Embeddingé›†æˆ

### 6.1 OpenAI Embeddings

**OpenAI Embeddingç”Ÿæˆ**:

```go
package embedding

import (
    "context"
    "fmt"

    "github.com/sashabaranov/go-openai"
)

// OpenAIEmbedder OpenAI Embeddingç”Ÿæˆå™¨
type OpenAIEmbedder struct {
    client *openai.Client
    model  string
}

func NewOpenAIEmbedder(apiKey string) *OpenAIEmbedder {
    return &OpenAIEmbedder{
        client: openai.NewClient(apiKey),
        model:  openai.AdaEmbeddingV2, // text-embedding-ada-002
    }
}

// Embed ç”Ÿæˆå•ä¸ªæ–‡æœ¬çš„Embedding
func (e *OpenAIEmbedder) Embed(ctx context.Context, text string) ([]float32, error) {
    req := openai.EmbeddingRequest{
        Input: []string{text},
        Model: e.model,
    }

    resp, err := e.client.CreateEmbeddings(ctx, req)
    if err != nil {
        return nil, fmt.Errorf("create embedding: %w", err)
    }

    if len(resp.Data) == 0 {
        return nil, fmt.Errorf("no embedding returned")
    }

    return resp.Data[0].Embedding, nil
}

// BatchEmbed æ‰¹é‡ç”ŸæˆEmbedding
func (e *OpenAIEmbedder) BatchEmbed(ctx context.Context, texts []string) ([][]float32, error) {
    // OpenAI APIé™åˆ¶ï¼šæ¯æ¬¡æœ€å¤šå¤„ç†2048ä¸ªè¾“å…¥
    batchSize := 100
    allEmbeddings := make([][]float32, 0, len(texts))

    for i := 0; i < len(texts); i += batchSize {
        end := i + batchSize
        if end > len(texts) {
            end = len(texts)
        }

        batch := texts[i:end]

        req := openai.EmbeddingRequest{
            Input: batch,
            Model: e.model,
        }

        resp, err := e.client.CreateEmbeddings(ctx, req)
        if err != nil {
            return nil, fmt.Errorf("batch embed: %w", err)
        }

        for _, data := range resp.Data {
            allEmbeddings = append(allEmbeddings, data.Embedding)
        }

        fmt.Printf("Processed batch %d-%d\n", i, end)
    }

    return allEmbeddings, nil
}
```

### 6.3 Embeddingç¼“å­˜

**Redisç¼“å­˜Embedding**:

```go
package embedding

import (
    "context"
    "crypto/sha256"
    "encoding/json"
    "fmt"
    "time"

    "github.com/redis/go-redis/v9"
)

// CachedEmbedder å¸¦ç¼“å­˜çš„Embeddingç”Ÿæˆå™¨
type CachedEmbedder struct {
    embedder Embedder
    redis    *redis.Client
    ttl      time.Duration
}

type Embedder interface {
    Embed(ctx context.Context, text string) ([]float32, error)
}

func NewCachedEmbedder(embedder Embedder, redisClient *redis.Client) *CachedEmbedder {
    return &CachedEmbedder{
        embedder: embedder,
        redis:    redisClient,
        ttl:      24 * time.Hour, // ç¼“å­˜24å°æ—¶
    }
}

// Embed ç”ŸæˆEmbeddingï¼ˆå¸¦ç¼“å­˜ï¼‰
func (ce *CachedEmbedder) Embed(ctx context.Context, text string) ([]float32, error) {
    // ç”Ÿæˆç¼“å­˜key
    cacheKey := ce.generateCacheKey(text)

    // å°è¯•ä»ç¼“å­˜è¯»å–
    cached, err := ce.redis.Get(ctx, cacheKey).Bytes()
    if err == nil {
        var embedding []float32
        if err := json.Unmarshal(cached, &embedding); err == nil {
            fmt.Println("Cache hit")
            return embedding, nil
        }
    }

    // ç¼“å­˜æœªå‘½ä¸­ï¼Œç”Ÿæˆæ–°çš„Embedding
    fmt.Println("Cache miss, generating embedding")
    embedding, err := ce.embedder.Embed(ctx, text)
    if err != nil {
        return nil, err
    }

    // å­˜å…¥ç¼“å­˜
    data, _ := json.Marshal(embedding)
    ce.redis.Set(ctx, cacheKey, data, ce.ttl)

    return embedding, nil
}

func (ce *CachedEmbedder) generateCacheKey(text string) string {
    hash := sha256.Sum256([]byte(text))
    return fmt.Sprintf("embedding:%x", hash)
}
```

---

## 7. å®æˆ˜æ¡ˆä¾‹

### 7.1 è¯­ä¹‰æœç´¢ç³»ç»Ÿ

**å®Œæ•´çš„è¯­ä¹‰æœç´¢ç³»ç»Ÿ**:

```go
package search

import (
    "context"
    "fmt"

    "github.com/qdrant/go-client/qdrant"
)

// SemanticSearchEngine è¯­ä¹‰æœç´¢å¼•æ“
type SemanticSearchEngine struct {
    vectorDB  *qdrant.Client
    embedder  Embedder
    collectionName string
}

type SearchResult struct {
    ID      string
    Score   float32
    Content string
    Meta    map[string]interface{}
}

func NewSemanticSearchEngine(vectorDB *qdrant.Client, embedder Embedder, collection string) *SemanticSearchEngine {
    return &SemanticSearchEngine{
        vectorDB:  vectorDB,
        embedder:  embedder,
        collectionName: collection,
    }
}

// Index ç´¢å¼•æ–‡æ¡£
func (se *SemanticSearchEngine) Index(ctx context.Context, id, content string, meta map[string]interface{}) error {
    // ç”ŸæˆEmbedding
    vector, err := se.embedder.Embed(ctx, content)
    if err != nil {
        return fmt.Errorf("generate embedding: %w", err)
    }

    // å‡†å¤‡payload
    payload := make(map[string]interface{})
    payload["content"] = content
    for k, v := range meta {
        payload[k] = v
    }

    // æ’å…¥å‘é‡æ•°æ®åº“
    point := &qdrant.Point{
        ID:      qdrant.NewIDNum(hashString(id)),
        Vector:  vector,
        Payload: payload,
    }

    _, err = se.vectorDB.Upsert(ctx, se.collectionName, &qdrant.UpsertPoints{
        Points: []*qdrant.Point{point},
    })

    if err != nil {
        return fmt.Errorf("upsert vector: %w", err)
    }

    fmt.Printf("Indexed document: %s\n", id)
    return nil
}

// Search æœç´¢ç›¸ä¼¼æ–‡æ¡£
func (se *SemanticSearchEngine) Search(ctx context.Context, query string, limit int) ([]*SearchResult, error) {
    // ç”ŸæˆæŸ¥è¯¢å‘é‡
    queryVector, err := se.embedder.Embed(ctx, query)
    if err != nil {
        return nil, fmt.Errorf("generate query embedding: %w", err)
    }

    // æœç´¢ç›¸ä¼¼å‘é‡
    searchParams := &qdrant.SearchPoints{
        Vector: queryVector,
        Limit:  uint64(limit),
        WithPayload: &qdrant.WithPayloadSelector{
            Include: &qdrant.PayloadIncludeSelector{
                Fields: []string{"content", "title", "url"},
            },
        },
    }

    results, err := se.vectorDB.Search(ctx, se.collectionName, searchParams)
    if err != nil {
        return nil, fmt.Errorf("search vectors: %w", err)
    }

    // è½¬æ¢ç»“æœ
    searchResults := make([]*SearchResult, len(results))
    for i, result := range results {
        searchResults[i] = &SearchResult{
            ID:      fmt.Sprintf("%v", result.ID),
            Score:   result.Score,
            Content: result.Payload["content"].(string),
            Meta:    result.Payload,
        }
    }

    fmt.Printf("Found %d similar documents\n", len(searchResults))
    return searchResults, nil
}

func hashString(s string) uint64 {
    h := uint64(0)
    for i := 0; i < len(s); i++ {
        h = 31*h + uint64(s[i])
    }
    return h
}
```

---

## 10. å‚è€ƒèµ„æº

### å®˜æ–¹æ–‡æ¡£

- [Qdrant Documentation](https://qdrant.tech/documentation/)
- [Weaviate Documentation](https://weaviate.io/developers/weaviate)
- [Milvus Documentation](https://milvus.io/docs)

### Goå®¢æˆ·ç«¯

- [qdrant-client](https://github.com/qdrant/go-client)
- [weaviate-go-client](https://github.com/weaviate/weaviate-go-client)
- [milvus-sdk-go](https://github.com/milvus-io/milvus-sdk-go)

### EmbeddingæœåŠ¡

- [OpenAI Embeddings API](https://platform.openai.com/docs/guides/embeddings)
- [Sentence Transformers](https://www.sbert.net/)

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team
**æœ€åæ›´æ–°**: 2025-10-29
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.21+

**è´¡çŒ®è€…**: æ¬¢è¿æäº¤Issueå’ŒPRæ”¹è¿›æœ¬æ–‡æ¡£
