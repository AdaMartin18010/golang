# æ•°æ®åº“æ€§èƒ½ä¼˜åŒ–å®æˆ˜

## ğŸ“‹ ç›®å½•


- [1. æ€§èƒ½ç“¶é¢ˆè¯†åˆ«](#1-æ€§èƒ½ç“¶é¢ˆè¯†åˆ«)
  - [ç›‘æ§å…³é”®æŒ‡æ ‡](#ç›‘æ§å…³é”®æŒ‡æ ‡)
  - [æ…¢æŸ¥è¯¢æ—¥å¿—åˆ†æ](#æ…¢æŸ¥è¯¢æ—¥å¿—åˆ†æ)
- [2. è¿æ¥æ± ä¼˜åŒ–](#2-è¿æ¥æ± ä¼˜åŒ–)
  - [é—®é¢˜æ¡ˆä¾‹](#é—®é¢˜æ¡ˆä¾‹)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [åŠ¨æ€è°ƒæ•´](#åŠ¨æ€è°ƒæ•´)
  - [æ€§èƒ½å¯¹æ¯”](#æ€§èƒ½å¯¹æ¯”)
- [3. æŸ¥è¯¢ä¼˜åŒ–](#3-æŸ¥è¯¢ä¼˜åŒ–)
  - [N+1æŸ¥è¯¢é—®é¢˜](#n1æŸ¥è¯¢é—®é¢˜)
  - [é¢„ç¼–è¯‘è¯­å¥](#é¢„ç¼–è¯‘è¯­å¥)
  - [SELECTä¼˜åŒ–](#selectä¼˜åŒ–)
- [4. ç´¢å¼•ä¼˜åŒ–](#4-ç´¢å¼•ä¼˜åŒ–)
  - [è¯†åˆ«ç¼ºå¤±ç´¢å¼•](#è¯†åˆ«ç¼ºå¤±ç´¢å¼•)
  - [æ·»åŠ ç´¢å¼•](#æ·»åŠ ç´¢å¼•)
  - [ç´¢å¼•å¯¹æ¯”](#ç´¢å¼•å¯¹æ¯”)
  - [å¤åˆç´¢å¼•æœ€ä½³å®è·µ](#å¤åˆç´¢å¼•æœ€ä½³å®è·µ)
- [5. æ‰¹é‡æ“ä½œä¼˜åŒ–](#5-æ‰¹é‡æ“ä½œä¼˜åŒ–)
  - [æ‰¹é‡æ’å…¥](#æ‰¹é‡æ’å…¥)
  - [æ‰¹é‡æ›´æ–°](#æ‰¹é‡æ›´æ–°)
- [6. ç¼“å­˜ç­–ç•¥](#6-ç¼“å­˜ç­–ç•¥)
  - [Cache-Asideæ¨¡å¼](#cache-asideæ¨¡å¼)
  - [é¢„çƒ­ç¼“å­˜](#é¢„çƒ­ç¼“å­˜)
  - [æ€§èƒ½å¯¹æ¯”](#æ€§èƒ½å¯¹æ¯”)
- [7. è¯»å†™åˆ†ç¦»](#7-è¯»å†™åˆ†ç¦»)
  - [ä¸»ä»é…ç½®](#ä¸»ä»é…ç½®)
  - [ä½¿ç”¨ç¤ºä¾‹](#ä½¿ç”¨ç¤ºä¾‹)
- [8. å®æˆ˜æ¡ˆä¾‹](#8-å®æˆ˜æ¡ˆä¾‹)
  - [æ¡ˆä¾‹: ç”µå•†è®¢å•ç³»ç»Ÿä¼˜åŒ–](#æ¡ˆä¾‹-ç”µå•†è®¢å•ç³»ç»Ÿä¼˜åŒ–)
    - [é—®é¢˜åˆ†æ](#é—®é¢˜åˆ†æ)
    - [ä¼˜åŒ–æ­¥éª¤](#ä¼˜åŒ–æ­¥éª¤)
    - [æœ€ç»ˆæ•ˆæœ](#æœ€ç»ˆæ•ˆæœ)
  - [å®Œæ•´ä¼˜åŒ–æ¸…å•](#å®Œæ•´ä¼˜åŒ–æ¸…å•)
- [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

## 1. æ€§èƒ½ç“¶é¢ˆè¯†åˆ«

### ç›‘æ§å…³é”®æŒ‡æ ‡

```go
// æ•°æ®åº“ç›‘æ§
func monitorDBStats(db *sql.DB) {
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        stats := db.Stats()
        
        log.Printf("DB Stats:")
        log.Printf("  OpenConnections: %d", stats.OpenConnections)
        log.Printf("  InUse: %d", stats.InUse)
        log.Printf("  Idle: %d", stats.Idle)
        log.Printf("  WaitCount: %d", stats.WaitCount)
        log.Printf("  WaitDuration: %v", stats.WaitDuration)
        log.Printf("  MaxIdleClosed: %d", stats.MaxIdleClosed)
        log.Printf("  MaxLifetimeClosed: %d", stats.MaxLifetimeClosed)
        
        // å‘Šè­¦
        if float64(stats.InUse) > float64(stats.MaxOpenConnections)*0.8 {
            log.Warn("Connection pool nearly exhausted!")
        }
    }
}
```

### æ…¢æŸ¥è¯¢æ—¥å¿—åˆ†æ

```sql
-- MySQLæ…¢æŸ¥è¯¢é…ç½®
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;  -- è¶…è¿‡1ç§’çš„æŸ¥è¯¢
SET GLOBAL log_queries_not_using_indexes = 'ON';

-- æŸ¥çœ‹æ…¢æŸ¥è¯¢
SELECT * FROM mysql.slow_log ORDER BY query_time DESC LIMIT 10;
```

---

## 2. è¿æ¥æ± ä¼˜åŒ–

### é—®é¢˜æ¡ˆä¾‹

**ç—‡çŠ¶**: å¤§é‡"too many connections"é”™è¯¯

```go
// âŒ é—®é¢˜é…ç½®
db, _ := sql.Open("mysql", dsn)
db.SetMaxOpenConns(10)       // å¤ªå°
db.SetMaxIdleConns(5)
db.SetConnMaxLifetime(0)     // æ°¸ä¸è¿‡æœŸ
```

### æœ€ä½³å®è·µ

```go
// âœ… ä¼˜åŒ–é…ç½®
func configureDB(db *sql.DB) {
    // æœ€å¤§æ‰“å¼€è¿æ¥æ•°
    // å…¬å¼: MaxOpenConns = ((æ ¸å¿ƒæ•° * 2) + ç£ç›˜æ•°é‡)
    // ç¤ºä¾‹: 4æ ¸ + 1ç£ç›˜ = 10
    db.SetMaxOpenConns(100)
    
    // æœ€å¤§ç©ºé—²è¿æ¥æ•° (å»ºè®® MaxOpenConns çš„ 50%)
    db.SetMaxIdleConns(50)
    
    // è¿æ¥æœ€å¤§ç”Ÿå‘½å‘¨æœŸ (é¿å…æ•°æ®åº“ç«¯è¶…æ—¶)
    db.SetConnMaxLifetime(30 * time.Minute)
    
    // è¿æ¥æœ€å¤§ç©ºé—²æ—¶é—´ (Go 1.15+)
    db.SetConnMaxIdleTime(10 * time.Minute)
}
```

### åŠ¨æ€è°ƒæ•´

```go
type AdaptiveDB struct {
    db *sql.DB
}

func (adb *AdaptiveDB) adjustConnectionPool() {
    ticker := time.NewTicker(time.Minute)
    defer ticker.Stop()
    
    for range ticker.C {
        stats := adb.db.Stats()
        
        // å¦‚æœç­‰å¾…æ¬¡æ•°å¤šï¼Œå¢åŠ è¿æ¥
        if stats.WaitCount > 100 {
            current := stats.MaxOpenConnections
            if current < 200 {
                adb.db.SetMaxOpenConns(current + 10)
                log.Printf("Increased max connections to %d", current+10)
            }
        }
        
        // å¦‚æœä½¿ç”¨ç‡ä½ï¼Œå‡å°‘è¿æ¥
        utilizationRate := float64(stats.InUse) / float64(stats.MaxOpenConnections)
        if utilizationRate < 0.2 && stats.MaxOpenConnections > 20 {
            adb.db.SetMaxOpenConns(stats.MaxOpenConnections - 10)
            log.Printf("Decreased max connections to %d", stats.MaxOpenConnections-10)
        }
    }
}
```

### æ€§èƒ½å¯¹æ¯”

| é…ç½® | QPS | P99å»¶è¿Ÿ | é”™è¯¯ç‡ |
|------|-----|---------|--------|
| MaxOpenConns=10 | 500 | 2000ms | 5% |
| MaxOpenConns=50 | 2000 | 100ms | 0.1% |
| MaxOpenConns=100 | 2500 | 50ms | 0% |
| MaxOpenConns=500 | 2400 | 60ms | 0% (è¿‡åº¦é…ç½®) |

---

## 3. æŸ¥è¯¢ä¼˜åŒ–

### N+1æŸ¥è¯¢é—®é¢˜

**é—®é¢˜ä»£ç **:

```go
// âŒ N+1æŸ¥è¯¢
func GetOrdersWithItems(userID string) ([]Order, error) {
    // 1æ¬¡æŸ¥è¯¢
    orders, err := db.Query("SELECT * FROM orders WHERE user_id = ?", userID)
    if err != nil {
        return nil, err
    }
    defer orders.Close()
    
    var result []Order
    for orders.Next() {
        var order Order
        orders.Scan(&order.ID, &order.UserID, &order.Total)
        
        // Næ¬¡æŸ¥è¯¢ (æ¯ä¸ªè®¢å•ä¸€æ¬¡)
        items, _ := db.Query("SELECT * FROM order_items WHERE order_id = ?", order.ID)
        // ... æ‰«æitems
        order.Items = items
        
        result = append(result, order)
    }
    
    return result, nil
}

// æ€§èƒ½: 100ä¸ªè®¢å• = 101æ¬¡æ•°æ®åº“æŸ¥è¯¢ = 2ç§’
```

**ä¼˜åŒ–æ–¹æ¡ˆ**:

```go
// âœ… JOINä¼˜åŒ–
func GetOrdersWithItemsOptimized(userID string) ([]Order, error) {
    query := `
        SELECT 
            o.id, o.user_id, o.total,
            oi.id, oi.product_id, oi.quantity, oi.price
        FROM orders o
        LEFT JOIN order_items oi ON o.id = oi.order_id
        WHERE o.user_id = ?
        ORDER BY o.id
    `
    
    rows, err := db.Query(query, userID)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    ordersMap := make(map[string]*Order)
    
    for rows.Next() {
        var orderID, userID, itemID, productID string
        var total, price float64
        var quantity int
        
        rows.Scan(&orderID, &userID, &total, &itemID, &productID, &quantity, &price)
        
        order, exists := ordersMap[orderID]
        if !exists {
            order = &Order{
                ID:     orderID,
                UserID: userID,
                Total:  total,
                Items:  []OrderItem{},
            }
            ordersMap[orderID] = order
        }
        
        if itemID != "" {
            order.Items = append(order.Items, OrderItem{
                ID:        itemID,
                ProductID: productID,
                Quantity:  quantity,
                Price:     price,
            })
        }
    }
    
    orders := make([]Order, 0, len(ordersMap))
    for _, order := range ordersMap {
        orders = append(orders, *order)
    }
    
    return orders, nil
}

// æ€§èƒ½: 100ä¸ªè®¢å• = 1æ¬¡æ•°æ®åº“æŸ¥è¯¢ = 0.1ç§’ (20xæå‡)
```

---

### é¢„ç¼–è¯‘è¯­å¥

```go
// âŒ æ¯æ¬¡è§£æSQL
func GetUserByID(id string) (*User, error) {
    row := db.QueryRow("SELECT * FROM users WHERE id = ?", id)
    // ...
}

// âœ… é¢„ç¼–è¯‘è¯­å¥
type UserRepository struct {
    db            *sql.DB
    getUserStmt   *sql.Stmt
    updateStmt    *sql.Stmt
    deleteStmt    *sql.Stmt
}

func NewUserRepository(db *sql.DB) (*UserRepository, error) {
    getUserStmt, err := db.Prepare("SELECT * FROM users WHERE id = ?")
    if err != nil {
        return nil, err
    }
    
    updateStmt, err := db.Prepare("UPDATE users SET name = ?, email = ? WHERE id = ?")
    if err != nil {
        return nil, err
    }
    
    deleteStmt, err := db.Prepare("DELETE FROM users WHERE id = ?")
    if err != nil {
        return nil, err
    }
    
    return &UserRepository{
        db:          db,
        getUserStmt: getUserStmt,
        updateStmt:  updateStmt,
        deleteStmt:  deleteStmt,
    }, nil
}

func (r *UserRepository) GetByID(id string) (*User, error) {
    row := r.getUserStmt.QueryRow(id)
    // ...
}

func (r *UserRepository) Close() {
    r.getUserStmt.Close()
    r.updateStmt.Close()
    r.deleteStmt.Close()
}

// æ€§èƒ½æå‡: 10-15%
```

---

### SELECTä¼˜åŒ–

```go
// âŒ æŸ¥è¯¢æ‰€æœ‰å­—æ®µ
func GetUserNames() ([]string, error) {
    rows, _ := db.Query("SELECT * FROM users")  // æŸ¥è¯¢æ‰€æœ‰å­—æ®µ
    defer rows.Close()
    
    var names []string
    for rows.Next() {
        var id, name, email, phone, address string  // æµªè´¹
        rows.Scan(&id, &name, &email, &phone, &address)
        names = append(names, name)
    }
    return names, nil
}

// âœ… åªæŸ¥è¯¢éœ€è¦çš„å­—æ®µ
func GetUserNamesOptimized() ([]string, error) {
    rows, _ := db.Query("SELECT name FROM users")  // åªæŸ¥è¯¢name
    defer rows.Close()
    
    var names []string
    for rows.Next() {
        var name string
        rows.Scan(&name)
        names = append(names, name)
    }
    return names, nil
}

// æ€§èƒ½: å¦‚æœusersè¡¨æœ‰å¾ˆå¤šå­—æ®µï¼Œæå‡å¯è¾¾50%+
```

---

## 4. ç´¢å¼•ä¼˜åŒ–

### è¯†åˆ«ç¼ºå¤±ç´¢å¼•

```sql
-- MySQL: æŸ¥çœ‹æ…¢æŸ¥è¯¢ä¸­æœªä½¿ç”¨ç´¢å¼•çš„æŸ¥è¯¢
SELECT * FROM mysql.slow_log 
WHERE sql_text NOT LIKE '%INDEX%' 
ORDER BY query_time DESC 
LIMIT 10;

-- æŸ¥çœ‹è¡¨çš„ç´¢å¼•
SHOW INDEX FROM users;

-- åˆ†ææŸ¥è¯¢æ‰§è¡Œè®¡åˆ’
EXPLAIN SELECT * FROM users WHERE email = 'john@example.com';
```

### æ·»åŠ ç´¢å¼•

```go
// è¿ç§»è„šæœ¬
func AddIndexes(db *sql.DB) error {
    indexes := []string{
        // å•åˆ—ç´¢å¼•
        "CREATE INDEX idx_users_email ON users(email)",
        "CREATE INDEX idx_orders_user_id ON orders(user_id)",
        "CREATE INDEX idx_orders_created_at ON orders(created_at)",
        
        // å¤åˆç´¢å¼• (æ³¨æ„é¡ºåº!)
        "CREATE INDEX idx_orders_user_created ON orders(user_id, created_at)",
        
        // å”¯ä¸€ç´¢å¼•
        "CREATE UNIQUE INDEX idx_users_email_unique ON users(email)",
        
        // éƒ¨åˆ†ç´¢å¼• (PostgreSQL)
        "CREATE INDEX idx_orders_pending ON orders(user_id) WHERE status = 'pending'",
    }
    
    for _, indexSQL := range indexes {
        if _, err := db.Exec(indexSQL); err != nil {
            return fmt.Errorf("failed to create index: %w", err)
        }
    }
    
    return nil
}
```

### ç´¢å¼•å¯¹æ¯”

**æµ‹è¯•åœºæ™¯**: æŸ¥è¯¢ç”¨æˆ·çš„è®¢å•

```sql
-- æ— ç´¢å¼•
SELECT * FROM orders WHERE user_id = 'user123';
-- æ‰§è¡Œæ—¶é—´: 2500ms (å…¨è¡¨æ‰«æ 100ä¸‡è¡Œ)

-- æ·»åŠ ç´¢å¼•å
CREATE INDEX idx_orders_user_id ON orders(user_id);
SELECT * FROM orders WHERE user_id = 'user123';
-- æ‰§è¡Œæ—¶é—´: 5ms (ç´¢å¼•æ‰«æ 100è¡Œ)

-- æ€§èƒ½æå‡: 500x
```

### å¤åˆç´¢å¼•æœ€ä½³å®è·µ

```go
// âŒ é”™è¯¯: ä¸ºæ¯ä¸ªå­—æ®µå•ç‹¬å»ºç´¢å¼•
CREATE INDEX idx_user_id ON orders(user_id);
CREATE INDEX idx_created_at ON orders(created_at);

// æŸ¥è¯¢
SELECT * FROM orders 
WHERE user_id = ? AND created_at > ?
-- åªä¼šä½¿ç”¨ä¸€ä¸ªç´¢å¼•

// âœ… æ­£ç¡®: å¤åˆç´¢å¼•
CREATE INDEX idx_user_created ON orders(user_id, created_at);

// æŸ¥è¯¢
SELECT * FROM orders 
WHERE user_id = ? AND created_at > ?
-- åŒæ—¶ä½¿ç”¨ä¸¤ä¸ªæ¡ä»¶ï¼Œæ€§èƒ½æœ€ä¼˜

// æ³¨æ„: ç´¢å¼•åˆ—é¡ºåºå¾ˆé‡è¦!
// æœ€å·¦å‰ç¼€åŸåˆ™: (user_id, created_at) å¯ä»¥ç”¨äº
//   - WHERE user_id = ?
//   - WHERE user_id = ? AND created_at > ?
// ä½†ä¸èƒ½å•ç‹¬ç”¨äº
//   - WHERE created_at > ?  (éœ€è¦å¦å»ºç´¢å¼•)
```

---

## 5. æ‰¹é‡æ“ä½œä¼˜åŒ–

### æ‰¹é‡æ’å…¥

```go
// âŒ é€æ¡æ’å…¥
func InsertUsers(users []User) error {
    for _, user := range users {
        _, err := db.Exec(
            "INSERT INTO users (name, email) VALUES (?, ?)",
            user.Name, user.Email,
        )
        if err != nil {
            return err
        }
    }
    return nil
}
// 1000æ¡æ•°æ® = 10ç§’

// âœ… æ‰¹é‡æ’å…¥
func InsertUsersBatch(users []User) error {
    tx, err := db.Begin()
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    stmt, err := tx.Prepare("INSERT INTO users (name, email) VALUES (?, ?)")
    if err != nil {
        return err
    }
    defer stmt.Close()
    
    for _, user := range users {
        if _, err := stmt.Exec(user.Name, user.Email); err != nil {
            return err
        }
    }
    
    return tx.Commit()
}
// 1000æ¡æ•°æ® = 0.5ç§’ (20xæå‡)

// âœ… æ›´ä¼˜: ä½¿ç”¨VALUESå¤šè¡Œæ’å…¥
func InsertUsersBulk(users []User) error {
    if len(users) == 0 {
        return nil
    }
    
    batchSize := 100
    for i := 0; i < len(users); i += batchSize {
        end := i + batchSize
        if end > len(users) {
            end = len(users)
        }
        
        batch := users[i:end]
        
        // æ„å»ºæ‰¹é‡æ’å…¥SQL
        valueStrings := make([]string, 0, len(batch))
        valueArgs := make([]interface{}, 0, len(batch)*2)
        
        for _, user := range batch {
            valueStrings = append(valueStrings, "(?, ?)")
            valueArgs = append(valueArgs, user.Name, user.Email)
        }
        
        query := fmt.Sprintf(
            "INSERT INTO users (name, email) VALUES %s",
            strings.Join(valueStrings, ","),
        )
        
        if _, err := db.Exec(query, valueArgs...); err != nil {
            return err
        }
    }
    
    return nil
}
// 1000æ¡æ•°æ® = 0.1ç§’ (100xæå‡)
```

### æ‰¹é‡æ›´æ–°

```go
// âŒ é€æ¡æ›´æ–°
func UpdateUserStatuses(updates map[string]string) error {
    for id, status := range updates {
        _, err := db.Exec(
            "UPDATE users SET status = ? WHERE id = ?",
            status, id,
        )
        if err != nil {
            return err
        }
    }
    return nil
}

// âœ… æ‰¹é‡æ›´æ–° (ä½¿ç”¨CASE WHEN)
func UpdateUserStatusesBatch(updates map[string]string) error {
    if len(updates) == 0 {
        return nil
    }
    
    ids := make([]string, 0, len(updates))
    for id := range updates {
        ids = append(ids, id)
    }
    
    // æ„å»ºCASE WHENè¯­å¥
    caseSQL := "CASE id"
    args := make([]interface{}, 0, len(updates)*2)
    
    for id, status := range updates {
        caseSQL += " WHEN ? THEN ?"
        args = append(args, id, status)
    }
    caseSQL += " END"
    
    // WHERE IN
    placeholders := make([]string, len(ids))
    for i, id := range ids {
        placeholders[i] = "?"
        args = append(args, id)
    }
    
    query := fmt.Sprintf(
        "UPDATE users SET status = %s WHERE id IN (%s)",
        caseSQL,
        strings.Join(placeholders, ","),
    )
    
    _, err := db.Exec(query, args...)
    return err
}
```

---

## 6. ç¼“å­˜ç­–ç•¥

### Cache-Asideæ¨¡å¼

```go
type UserRepository struct {
    db    *sql.DB
    cache *redis.Client
}

func (r *UserRepository) GetByID(ctx context.Context, id string) (*User, error) {
    // 1. å°è¯•ä»ç¼“å­˜è·å–
    cacheKey := fmt.Sprintf("user:%s", id)
    if cached, err := r.cache.Get(ctx, cacheKey).Result(); err == nil {
        var user User
        if err := json.Unmarshal([]byte(cached), &user); err == nil {
            return &user, nil
        }
    }
    
    // 2. ä»æ•°æ®åº“è·å–
    var user User
    err := r.db.QueryRowContext(ctx, 
        "SELECT id, name, email FROM users WHERE id = ?", id,
    ).Scan(&user.ID, &user.Name, &user.Email)
    
    if err != nil {
        return nil, err
    }
    
    // 3. å†™å…¥ç¼“å­˜
    if data, err := json.Marshal(user); err == nil {
        r.cache.Set(ctx, cacheKey, data, 10*time.Minute)
    }
    
    return &user, nil
}

func (r *UserRepository) Update(ctx context.Context, user *User) error {
    // 1. æ›´æ–°æ•°æ®åº“
    _, err := r.db.ExecContext(ctx,
        "UPDATE users SET name = ?, email = ? WHERE id = ?",
        user.Name, user.Email, user.ID,
    )
    if err != nil {
        return err
    }
    
    // 2. åˆ é™¤ç¼“å­˜ (è®©ä¸‹æ¬¡è¯»å–æ—¶é‡æ–°åŠ è½½)
    cacheKey := fmt.Sprintf("user:%s", user.ID)
    r.cache.Del(ctx, cacheKey)
    
    return nil
}
```

### é¢„çƒ­ç¼“å­˜

```go
func (r *UserRepository) WarmupCache(ctx context.Context) error {
    // æŸ¥è¯¢çƒ­ç‚¹æ•°æ®
    rows, err := r.db.QueryContext(ctx, `
        SELECT id, name, email 
        FROM users 
        WHERE last_active > NOW() - INTERVAL 7 DAY
        LIMIT 1000
    `)
    if err != nil {
        return err
    }
    defer rows.Close()
    
    pipe := r.cache.Pipeline()
    
    for rows.Next() {
        var user User
        rows.Scan(&user.ID, &user.Name, &user.Email)
        
        cacheKey := fmt.Sprintf("user:%s", user.ID)
        if data, err := json.Marshal(user); err == nil {
            pipe.Set(ctx, cacheKey, data, 10*time.Minute)
        }
    }
    
    _, err = pipe.Exec(ctx)
    return err
}
```

### æ€§èƒ½å¯¹æ¯”

| åœºæ™¯ | QPS | P99å»¶è¿Ÿ | æ•°æ®åº“è´Ÿè½½ |
|------|-----|---------|------------|
| æ— ç¼“å­˜ | 1000 | 50ms | 100% |
| ç¼“å­˜(50%å‘½ä¸­) | 3000 | 10ms | 50% |
| ç¼“å­˜(90%å‘½ä¸­) | 8000 | 2ms | 10% |
| ç¼“å­˜(99%å‘½ä¸­) | 15000 | 1ms | 1% |

---

## 7. è¯»å†™åˆ†ç¦»

### ä¸»ä»é…ç½®

```go
type DB struct {
    master *sql.DB
    slaves []*sql.DB
    nextSlave int32
}

func NewDB(masterDSN string, slaveDSNs []string) (*DB, error) {
    master, err := sql.Open("mysql", masterDSN)
    if err != nil {
        return nil, err
    }
    
    slaves := make([]*sql.DB, len(slaveDSNs))
    for i, dsn := range slaveDSNs {
        slave, err := sql.Open("mysql", dsn)
        if err != nil {
            return nil, err
        }
        slaves[i] = slave
    }
    
    return &DB{
        master: master,
        slaves: slaves,
    }, nil
}

// å†™æ“ä½œ - ä½¿ç”¨ä¸»åº“
func (db *DB) Exec(query string, args ...interface{}) (sql.Result, error) {
    return db.master.Exec(query, args...)
}

// è¯»æ“ä½œ - ä½¿ç”¨ä»åº“ (è½®è¯¢)
func (db *DB) Query(query string, args ...interface{}) (*sql.Rows, error) {
    slave := db.getSlave()
    return slave.Query(query, args...)
}

func (db *DB) getSlave() *sql.DB {
    if len(db.slaves) == 0 {
        return db.master
    }
    
    // è½®è¯¢è´Ÿè½½å‡è¡¡
    next := atomic.AddInt32(&db.nextSlave, 1)
    return db.slaves[int(next)%len(db.slaves)]
}
```

### ä½¿ç”¨ç¤ºä¾‹

```go
type UserRepository struct {
    db *DB
}

func (r *UserRepository) Create(user *User) error {
    // å†™æ“ä½œ â†’ ä¸»åº“
    result, err := r.db.Exec(
        "INSERT INTO users (name, email) VALUES (?, ?)",
        user.Name, user.Email,
    )
    if err != nil {
        return err
    }
    
    id, _ := result.LastInsertId()
    user.ID = fmt.Sprintf("%d", id)
    return nil
}

func (r *UserRepository) FindByID(id string) (*User, error) {
    // è¯»æ“ä½œ â†’ ä»åº“
    var user User
    err := r.db.QueryRow(
        "SELECT id, name, email FROM users WHERE id = ?", id,
    ).Scan(&user.ID, &user.Name, &user.Email)
    
    return &user, err
}
```

---

## 8. å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹: ç”µå•†è®¢å•ç³»ç»Ÿä¼˜åŒ–

**èƒŒæ™¯**:
- è®¢å•è¡¨: 1000ä¸‡è¡Œ
- æŸ¥è¯¢è®¢å•åˆ—è¡¨æ…¢: P99 > 5ç§’
- æ•°æ®åº“CPU 90%

#### é—®é¢˜åˆ†æ

```sql
-- åŸå§‹æ…¢æŸ¥è¯¢
SELECT * FROM orders 
WHERE user_id = 'user123' 
ORDER BY created_at DESC 
LIMIT 20;

EXPLAIN:
+----+-------------+--------+------+---------------+------+---------+------+----------+-------------+
| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows     | Extra       |
+----+-------------+--------+------+---------------+------+---------+------+----------+-------------+
|  1 | SIMPLE      | orders | ALL  | NULL          | NULL | NULL    | NULL | 10000000 | Using where; Using filesort |
+----+-------------+--------+------+---------------+------+---------+------+----------+-------------+

é—®é¢˜: 
1. å…¨è¡¨æ‰«æ (type=ALL)
2. æ–‡ä»¶æ’åº (Using filesort)
3. æ‰«æ1000ä¸‡è¡Œ
```

#### ä¼˜åŒ–æ­¥éª¤

**ç¬¬1æ­¥: æ·»åŠ ç´¢å¼•**

```sql
-- æ·»åŠ å¤åˆç´¢å¼•
CREATE INDEX idx_orders_user_created ON orders(user_id, created_at);

-- å†æ¬¡EXPLAIN
EXPLAIN SELECT * FROM orders 
WHERE user_id = 'user123' 
ORDER BY created_at DESC 
LIMIT 20;

+----+-------------+--------+-------+------------------------+------------------------+---------+-------+------+-------+
| id | select_type | table  | type  | possible_keys          | key                    | key_len | ref   | rows | Extra |
+----+-------------+--------+-------+------------------------+------------------------+---------+-------+------+-------+
|  1 | SIMPLE      | orders | range | idx_orders_user_created| idx_orders_user_created| 767     | const | 100  | NULL  |
+----+-------------+--------+-------+------------------------+------------------------+---------+-------+------+-------+

æ”¹å–„: æ‰«æè¡Œæ•° 10000000 â†’ 100
æ•ˆæœ: æŸ¥è¯¢æ—¶é—´ 5s â†’ 0.05s
```

**ç¬¬2æ­¥: åªæŸ¥è¯¢éœ€è¦çš„å­—æ®µ**

```go
// âŒ ä¹‹å‰: æŸ¥è¯¢æ‰€æœ‰å­—æ®µ (50ä¸ªå­—æ®µ)
func GetOrders(userID string) ([]Order, error) {
    rows, _ := db.Query(`
        SELECT * FROM orders 
        WHERE user_id = ? 
        ORDER BY created_at DESC 
        LIMIT 20
    `, userID)
    // ...
}

// âœ… ä¼˜åŒ–: åªæŸ¥è¯¢åˆ—è¡¨éœ€è¦çš„å­—æ®µ
func GetOrders(userID string) ([]Order, error) {
    rows, _ := db.Query(`
        SELECT id, order_no, total, status, created_at 
        FROM orders 
        WHERE user_id = ? 
        ORDER BY created_at DESC 
        LIMIT 20
    `, userID)
    // ...
}

// æ•ˆæœ: 0.05s â†’ 0.01s
```

**ç¬¬3æ­¥: æ·»åŠ ç¼“å­˜**

```go
func (r *OrderRepository) GetUserOrders(ctx context.Context, userID string) ([]Order, error) {
    cacheKey := fmt.Sprintf("orders:user:%s", userID)
    
    // å°è¯•ä»ç¼“å­˜è·å–
    if cached, err := r.cache.Get(ctx, cacheKey).Result(); err == nil {
        var orders []Order
        if err := json.Unmarshal([]byte(cached), &orders); err == nil {
            return orders, nil
        }
    }
    
    // ä»æ•°æ®åº“æŸ¥è¯¢
    orders, err := r.queryFromDB(userID)
    if err != nil {
        return nil, err
    }
    
    // å†™å…¥ç¼“å­˜
    if data, err := json.Marshal(orders); err == nil {
        r.cache.Set(ctx, cacheKey, data, 5*time.Minute)
    }
    
    return orders, nil
}

// æ•ˆæœ: ç¼“å­˜å‘½ä¸­æ—¶ 0.01s â†’ 0.001s
```

#### æœ€ç»ˆæ•ˆæœ

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æå‡ |
|------|--------|--------|------|
| P99å»¶è¿Ÿ | 5000ms | 10ms (ç¼“å­˜1ms) | 500x |
| DB CPU | 90% | 15% | 6x |
| QPS | 200 | 5000 | 25x |
| ç¼“å­˜å‘½ä¸­ç‡ | 0% | 95% | - |

---

### å®Œæ•´ä¼˜åŒ–æ¸…å•

```go
// âœ… æ•°æ®åº“æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ

// 1. è¿æ¥æ± é…ç½®
db.SetMaxOpenConns(100)
db.SetMaxIdleConns(50)
db.SetConnMaxLifetime(30 * time.Minute)
db.SetConnMaxIdleTime(10 * time.Minute)

// 2. ä½¿ç”¨é¢„ç¼–è¯‘è¯­å¥
stmt, _ := db.Prepare("SELECT * FROM users WHERE id = ?")
defer stmt.Close()

// 3. é¿å…N+1æŸ¥è¯¢ï¼Œä½¿ç”¨JOIN
// 4. åªæŸ¥è¯¢éœ€è¦çš„å­—æ®µ
// 5. æ·»åŠ åˆé€‚çš„ç´¢å¼•
// 6. æ‰¹é‡æ“ä½œä½¿ç”¨äº‹åŠ¡
// 7. æ·»åŠ ç¼“å­˜å±‚
// 8. è¯»å†™åˆ†ç¦»
// 9. ç›‘æ§æ…¢æŸ¥è¯¢
// 10. å®šæœŸä¼˜åŒ–æ•°æ®åº“
```

---

## ğŸ”— ç›¸å…³èµ„æº

- [æ•°æ®åº“åŸºç¡€](./01-SQLåŸºç¡€.md)
- [GORMå®æˆ˜](./02-GORMå®æˆ˜.md)
- [æ€§èƒ½è°ƒä¼˜](../../advanced/performance/06-æ€§èƒ½è°ƒä¼˜å®æˆ˜.md)

---

**æœ€åæ›´æ–°**: 2025-10-28  
**Goç‰ˆæœ¬**: 1.25.3  
**æ–‡æ¡£ç±»å‹**: æ€§èƒ½ä¼˜åŒ–å®æˆ˜ âœ¨

