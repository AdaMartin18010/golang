# äº‘åŸç”Ÿå®Œæ•´é¡¹ç›®å®æˆ˜ï¼šTask Management System

> **ç®€ä»‹**: ä¸€ä¸ªå®Œæ•´çš„äº‘åŸç”Ÿä»»åŠ¡ç®¡ç†ç³»ç»Ÿï¼Œå±•ç¤ºä»å¼€å‘åˆ°éƒ¨ç½²çš„å…¨æµç¨‹æœ€ä½³å®è·µ  
> **ç‰ˆæœ¬**: Go 1.25.3+  
> **éš¾åº¦**: â­â­â­â­â­  
> **æ ‡ç­¾**: #äº‘åŸç”Ÿ #Kubernetes #å¾®æœåŠ¡ #å®Œæ•´é¡¹ç›®

**å­—æ•°**: ~8,500å­—  
**ä»£ç æ–‡ä»¶**: 30+ä¸ªå®Œæ•´æ–‡ä»¶  
**éƒ¨ç½²æ—¶é—´**: çº¦2å°æ—¶  
**é€‚ç”¨äººç¾¤**: é«˜çº§Goå¼€å‘è€…ã€æ¶æ„å¸ˆ

---

## ğŸ“‹ ç›®å½•


- [ğŸ¯ é¡¹ç›®æ¦‚è¿°](#-é¡¹ç›®æ¦‚è¿°)
  - [æŠ€æœ¯æ¶æ„](#æŠ€æœ¯æ¶æ„)
  - [æ ¸å¿ƒåŠŸèƒ½](#æ ¸å¿ƒåŠŸèƒ½)
  - [æŠ€æœ¯æ ˆ](#æŠ€æœ¯æ ˆ)
- [ğŸ“ é¡¹ç›®ç»“æ„](#-é¡¹ç›®ç»“æ„)
- [ç¬¬ä¸€éƒ¨åˆ†ï¼šåº”ç”¨ç¨‹åºä»£ç ](#ç¬¬ä¸€éƒ¨åˆ†åº”ç”¨ç¨‹åºä»£ç )
  - [1.1 ä¸»åº”ç”¨ç¨‹åº](#11-ä¸»åº”ç”¨ç¨‹åº)
  - [1.2 æ•°æ®æ¨¡å‹](#12-æ•°æ®æ¨¡å‹)
  - [1.3 æ•°æ®åº“å±‚](#13-æ•°æ®åº“å±‚)
  - [1.4 æœåŠ¡å±‚](#14-æœåŠ¡å±‚)
  - [1.5 HTTPå¤„ç†å™¨](#15-httpå¤„ç†å™¨)
  - [1.6 ä¸­é—´ä»¶](#16-ä¸­é—´ä»¶)
  - [1.7 é…ç½®ç®¡ç†](#17-é…ç½®ç®¡ç†)
- [ç¬¬äºŒéƒ¨åˆ†ï¼šå®¹å™¨åŒ–é…ç½®](#ç¬¬äºŒéƒ¨åˆ†å®¹å™¨åŒ–é…ç½®)
  - [2.1 Dockerfile](#21-dockerfile)
  - [2.2 .dockerignore](#22-dockerignore)
  - [2.3 Docker Compose (æœ¬åœ°å¼€å‘)](#23-docker-compose-æœ¬åœ°å¼€å‘)
- [ç¬¬ä¸‰éƒ¨åˆ†ï¼šKuberneteséƒ¨ç½²](#ç¬¬ä¸‰éƒ¨åˆ†kuberneteséƒ¨ç½²)
  - [3.1 å‘½åç©ºé—´](#31-å‘½åç©ºé—´)
  - [3.2 ConfigMap](#32-configmap)
  - [3.3 Secret](#33-secret)
  - [3.4 PostgreSQLéƒ¨ç½²](#34-postgresqléƒ¨ç½²)
  - [3.5 Rediséƒ¨ç½²](#35-rediséƒ¨ç½²)
  - [3.6 åº”ç”¨ç¨‹åºéƒ¨ç½²](#36-åº”ç”¨ç¨‹åºéƒ¨ç½²)
  - [3.7 Service](#37-service)
  - [3.8 Ingress](#38-ingress)
  - [3.9 HPA (æ°´å¹³è‡ªåŠ¨æ‰©å±•)](#39-hpa-æ°´å¹³è‡ªåŠ¨æ‰©å±•)
- [ç¬¬å››éƒ¨åˆ†ï¼šCI/CDæµæ°´çº¿](#ç¬¬å››éƒ¨åˆ†cicdæµæ°´çº¿)
  - [4.1 GitHub Actions](#41-github-actions)
  - [4.2 Makefile](#42-makefile)
- [ç¬¬äº”éƒ¨åˆ†ï¼šå¯è§‚æµ‹æ€§](#ç¬¬äº”éƒ¨åˆ†å¯è§‚æµ‹æ€§)
  - [5.1 Prometheusç›‘æ§](#51-prometheusç›‘æ§)
  - [5.2 Grafanaä»ªè¡¨æ¿](#52-grafanaä»ªè¡¨æ¿)
  - [5.3 Jaegeråˆ†å¸ƒå¼è¿½è¸ª](#53-jaegeråˆ†å¸ƒå¼è¿½è¸ª)
- [ç¬¬å…­éƒ¨åˆ†ï¼šHelm Chart](#ç¬¬å…­éƒ¨åˆ†helm-chart)
  - [6.1 Chartç»“æ„](#61-chartç»“æ„)
  - [6.2 Chart.yaml](#62-chartyaml)
  - [6.3 values.yaml](#63-valuesyaml)
  - [6.4 éƒ¨ç½²æ¨¡æ¿](#64-éƒ¨ç½²æ¨¡æ¿)
- [ç¬¬ä¸ƒéƒ¨åˆ†ï¼šéƒ¨ç½²æŒ‡å—](#ç¬¬ä¸ƒéƒ¨åˆ†éƒ¨ç½²æŒ‡å—)
  - [7.1 å‰ç½®è¦æ±‚](#71-å‰ç½®è¦æ±‚)
  - [7.2 æœ¬åœ°å¼€å‘](#72-æœ¬åœ°å¼€å‘)
  - [7.3 Kuberneteséƒ¨ç½²](#73-kuberneteséƒ¨ç½²)
  - [7.4 ä½¿ç”¨Helméƒ¨ç½²](#74-ä½¿ç”¨helméƒ¨ç½²)
  - [7.5 éªŒè¯éƒ¨ç½²](#75-éªŒè¯éƒ¨ç½²)
- [ç¬¬å…«éƒ¨åˆ†ï¼šæœ€ä½³å®è·µæ€»ç»“](#ç¬¬å…«éƒ¨åˆ†æœ€ä½³å®è·µæ€»ç»“)
  - [ä»£ç å±‚é¢](#ä»£ç å±‚é¢)
  - [å®¹å™¨å±‚é¢](#å®¹å™¨å±‚é¢)
  - [Kuberneteså±‚é¢](#kuberneteså±‚é¢)
  - [è¿ç»´å±‚é¢](#è¿ç»´å±‚é¢)
- [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
  - [æ ¸å¿ƒä»·å€¼](#æ ¸å¿ƒä»·å€¼)
  - [åç»­æ‰©å±•](#åç»­æ‰©å±•)
- [ğŸ“š å‚è€ƒèµ„æ–™](#-å‚è€ƒèµ„æ–™)

## ğŸ¯ é¡¹ç›®æ¦‚è¿°

### æŠ€æœ¯æ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ç”¨æˆ·æµé‡                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Ingress Controller                            â”‚
â”‚                  (Nginx Ingress / SSL)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Service Mesh (å¯é€‰)                             â”‚
â”‚                    Istio / Linkerd                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â–¼              â–¼              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Task API   â”‚  â”‚  Task API   â”‚  â”‚  Task API   â”‚
â”‚   Pod 1     â”‚  â”‚   Pod 2     â”‚  â”‚   Pod 3     â”‚
â”‚ (Go 1.25.3) â”‚  â”‚ (Go 1.25.3) â”‚  â”‚ (Go 1.25.3) â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚                â”‚                â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â–¼                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   PostgreSQL    â”‚       â”‚      Redis      â”‚
â”‚   (ä¸»æ•°æ®åº“)     â”‚       â”‚   (ç¼“å­˜/ä¼šè¯)    â”‚
â”‚   Statefulset   â”‚       â”‚   Statefulset   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ç›‘æ§ & æ—¥å¿—                                 â”‚
â”‚  Prometheus | Grafana | Jaeger | ELK Stack                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Mermaidæ¶æ„å›¾**ï¼ˆå¯åœ¨GitHubè‡ªåŠ¨æ¸²æŸ“ï¼‰:

```mermaid
graph TB
    subgraph "ç”¨æˆ·å±‚"
        User[ğŸ‘¤ ç”¨æˆ·]
    end
    
    subgraph "æ¥å…¥å±‚"
        Ingress[ğŸŒ Ingress Controller<br/>Nginx + SSL]
        LB[âš–ï¸ è´Ÿè½½å‡è¡¡]
    end
    
    subgraph "åº”ç”¨å±‚ - Task API"
        API1[ğŸš€ Pod 1<br/>Go 1.25.3]
        API2[ğŸš€ Pod 2<br/>Go 1.25.3]
        API3[ğŸš€ Pod 3<br/>Go 1.25.3]
    end
    
    subgraph "æ•°æ®å±‚"
        PG[(ğŸ—„ï¸ PostgreSQL 15<br/>ä¸»æ•°æ®åº“)]
        Redis[(âš¡ Redis 7<br/>ç¼“å­˜/ä¼šè¯)]
    end
    
    subgraph "ç›‘æ§ & å¯è§‚æµ‹æ€§"
        Prom[ğŸ“Š Prometheus]
        Grafana[ğŸ“ˆ Grafana]
        Jaeger[ğŸ” Jaeger]
    end
    
    User -->|HTTPS| Ingress
    Ingress --> LB
    LB --> API1
    LB --> API2
    LB --> API3
    
    API1 -->|æŸ¥è¯¢/å†™å…¥| PG
    API2 -->|æŸ¥è¯¢/å†™å…¥| PG
    API3 -->|æŸ¥è¯¢/å†™å…¥| PG
    
    API1 -->|ç¼“å­˜| Redis
    API2 -->|ç¼“å­˜| Redis
    API3 -->|ç¼“å­˜| Redis
    
    API1 -.æŒ‡æ ‡.-> Prom
    API2 -.æŒ‡æ ‡.-> Prom
    API3 -.æŒ‡æ ‡.-> Prom
    
    Prom -->|æ•°æ®æº| Grafana
    API1 -.è¿½è¸ª.-> Jaeger
    API2 -.è¿½è¸ª.-> Jaeger
    API3 -.è¿½è¸ª.-> Jaeger
    
    style User fill:#e1f5ff
    style Ingress fill:#ffe1e1
    style API1 fill:#e1ffe1
    style API2 fill:#e1ffe1
    style API3 fill:#e1ffe1
    style PG fill:#fff4e1
    style Redis fill:#fff4e1
    style Prom fill:#f0e1ff
    style Grafana fill:#f0e1ff
    style Jaeger fill:#f0e1ff
```

### æ ¸å¿ƒåŠŸèƒ½

1. **ä»»åŠ¡ç®¡ç†**: åˆ›å»ºã€æŸ¥è¯¢ã€æ›´æ–°ã€åˆ é™¤ä»»åŠ¡
2. **ç”¨æˆ·è®¤è¯**: JWTè®¤è¯å’Œæˆæƒ
3. **ç¼“å­˜æœºåˆ¶**: Redisç¼“å­˜çƒ­ç‚¹æ•°æ®
4. **å¥åº·æ£€æŸ¥**: Livenesså’ŒReadinessæ¢é’ˆ
5. **æŒ‡æ ‡ç›‘æ§**: PrometheusæŒ‡æ ‡æš´éœ²
6. **åˆ†å¸ƒå¼è¿½è¸ª**: Jaegeré“¾è·¯è¿½è¸ª
7. **è‡ªåŠ¨æ‰©ç¼©å®¹**: HPAåŸºäºCPU/å†…å­˜
8. **CI/CD**: GitHub Actionsè‡ªåŠ¨åŒ–éƒ¨ç½²

### æŠ€æœ¯æ ˆ

- **è¯­è¨€**: Go 1.25.3
- **Webæ¡†æ¶**: Gin
- **æ•°æ®åº“**: PostgreSQL 15
- **ç¼“å­˜**: Redis 7
- **å®¹å™¨**: Docker
- **ç¼–æ’**: Kubernetes
- **ç›‘æ§**: Prometheus + Grafana
- **è¿½è¸ª**: Jaeger
- **CI/CD**: GitHub Actions
- **åŒ…ç®¡ç†**: Helm

---

## ğŸ“ é¡¹ç›®ç»“æ„

```text
task-manager/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ api/
â”‚       â””â”€â”€ main.go                 # åº”ç”¨å…¥å£
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ config.go               # é…ç½®ç®¡ç†
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â””â”€â”€ task.go                 # æ•°æ®æ¨¡å‹
â”‚   â”œâ”€â”€ repository/
â”‚   â”‚   â”œâ”€â”€ postgres.go             # PostgreSQLä»“å‚¨
â”‚   â”‚   â””â”€â”€ redis.go                # Redisç¼“å­˜
â”‚   â”œâ”€â”€ service/
â”‚   â”‚   â””â”€â”€ task_service.go         # ä¸šåŠ¡é€»è¾‘
â”‚   â”œâ”€â”€ handler/
â”‚   â”‚   â””â”€â”€ task_handler.go         # HTTPå¤„ç†å™¨
â”‚   â””â”€â”€ middleware/
â”‚       â”œâ”€â”€ auth.go                 # JWTè®¤è¯
â”‚       â”œâ”€â”€ logging.go              # æ—¥å¿—ä¸­é—´ä»¶
â”‚       â””â”€â”€ metrics.go              # æŒ‡æ ‡ä¸­é—´ä»¶
â”œâ”€â”€ pkg/
â”‚   â”œâ”€â”€ logger/
â”‚   â”‚   â””â”€â”€ logger.go               # æ—¥å¿—å·¥å…·
â”‚   â””â”€â”€ tracing/
â”‚       â””â”€â”€ jaeger.go               # è¿½è¸ªå·¥å…·
â”œâ”€â”€ deployments/
â”‚   â”œâ”€â”€ docker/
â”‚   â”‚   â”œâ”€â”€ Dockerfile              # Dockeré•œåƒ
â”‚   â”‚   â””â”€â”€ docker-compose.yml      # æœ¬åœ°å¼€å‘
â”‚   â”œâ”€â”€ kubernetes/
â”‚   â”‚   â”œâ”€â”€ namespace.yaml          # å‘½åç©ºé—´
â”‚   â”‚   â”œâ”€â”€ configmap.yaml          # é…ç½®
â”‚   â”‚   â”œâ”€â”€ secret.yaml             # å¯†é’¥
â”‚   â”‚   â”œâ”€â”€ postgres.yaml           # æ•°æ®åº“
â”‚   â”‚   â”œâ”€â”€ redis.yaml              # ç¼“å­˜
â”‚   â”‚   â”œâ”€â”€ deployment.yaml         # åº”ç”¨éƒ¨ç½²
â”‚   â”‚   â”œâ”€â”€ service.yaml            # æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ ingress.yaml            # è·¯ç”±
â”‚   â”‚   â””â”€â”€ hpa.yaml                # è‡ªåŠ¨æ‰©å±•
â”‚   â””â”€â”€ helm/
â”‚       â””â”€â”€ task-manager/           # Helm Chart
â”‚           â”œâ”€â”€ Chart.yaml
â”‚           â”œâ”€â”€ values.yaml
â”‚           â””â”€â”€ templates/
â”œâ”€â”€ monitoring/
â”‚   â”œâ”€â”€ prometheus/
â”‚   â”‚   â””â”€â”€ prometheus.yaml         # Prometheusé…ç½®
â”‚   â””â”€â”€ grafana/
â”‚       â””â”€â”€ dashboard.json          # Grafanaä»ªè¡¨æ¿
â”œâ”€â”€ .github/
â”‚   â””â”€â”€ workflows/
â”‚       â””â”€â”€ ci-cd.yaml              # CI/CDæµæ°´çº¿
â”œâ”€â”€ Makefile                        # æ„å»ºè„šæœ¬
â”œâ”€â”€ go.mod
â”œâ”€â”€ go.sum
â””â”€â”€ README.md
```

---

## ç¬¬ä¸€éƒ¨åˆ†ï¼šåº”ç”¨ç¨‹åºä»£ç 

### 1.1 ä¸»åº”ç”¨ç¨‹åº

**`cmd/api/main.go`**

```go
package main

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/prometheus/client_golang/prometheus/promhttp"
    
    "task-manager/internal/config"
    "task-manager/internal/handler"
    "task-manager/internal/middleware"
    "task-manager/internal/repository"
    "task-manager/internal/service"
    "task-manager/pkg/logger"
    "task-manager/pkg/tracing"
)

func main() {
    // 1. åŠ è½½é…ç½®
    cfg := config.Load()
    
    // 2. åˆå§‹åŒ–æ—¥å¿—
    log := logger.New(cfg.LogLevel)
    
    // 3. åˆå§‹åŒ–Jaegerè¿½è¸ª
    closer, err := tracing.InitJaeger(cfg.ServiceName, cfg.JaegerEndpoint)
    if err != nil {
        log.Fatal("Failed to initialize Jaeger", err)
    }
    defer closer.Close()
    
    // 4. è¿æ¥PostgreSQL
    pgRepo, err := repository.NewPostgresRepository(cfg.DatabaseURL)
    if err != nil {
        log.Fatal("Failed to connect to PostgreSQL", err)
    }
    defer pgRepo.Close()
    
    // 5. è¿æ¥Redis
    redisRepo := repository.NewRedisRepository(cfg.RedisURL)
    defer redisRepo.Close()
    
    // 6. åˆå§‹åŒ–æœåŠ¡å±‚
    taskService := service.NewTaskService(pgRepo, redisRepo, log)
    
    // 7. åˆå§‹åŒ–å¤„ç†å™¨
    taskHandler := handler.NewTaskHandler(taskService, log)
    
    // 8. é…ç½®Ginè·¯ç”±
    if cfg.Environment == "production" {
        gin.SetMode(gin.ReleaseMode)
    }
    router := gin.New()
    
    // å…¨å±€ä¸­é—´ä»¶
    router.Use(
        middleware.Logger(log),
        middleware.Recovery(log),
        middleware.Metrics(),
        middleware.Tracing(),
        gin.Recovery(),
    )
    
    // å¥åº·æ£€æŸ¥
    router.GET("/health", func(c *gin.Context) {
        c.JSON(200, gin.H{
            "status": "healthy",
            "timestamp": time.Now().Unix(),
        })
    })
    
    router.GET("/ready", func(c *gin.Context) {
        // æ£€æŸ¥æ•°æ®åº“è¿æ¥
        if err := pgRepo.Ping(); err != nil {
            c.JSON(503, gin.H{"status": "not ready", "error": "database unavailable"})
            return
        }
        c.JSON(200, gin.H{"status": "ready"})
    })
    
    // PrometheusæŒ‡æ ‡
    router.GET("/metrics", gin.WrapH(promhttp.Handler()))
    
    // APIè·¯ç”±
    v1 := router.Group("/api/v1")
    {
        // å…¬å¼€è·¯ç”±
        v1.POST("/auth/login", taskHandler.Login)
        v1.POST("/auth/register", taskHandler.Register)
        
        // å—ä¿æŠ¤è·¯ç”±
        auth := v1.Group("")
        auth.Use(middleware.AuthRequired(cfg.JWTSecret))
        {
            auth.GET("/tasks", taskHandler.ListTasks)
            auth.GET("/tasks/:id", taskHandler.GetTask)
            auth.POST("/tasks", taskHandler.CreateTask)
            auth.PUT("/tasks/:id", taskHandler.UpdateTask)
            auth.DELETE("/tasks/:id", taskHandler.DeleteTask)
        }
    }
    
    // 9. å¯åŠ¨HTTPæœåŠ¡å™¨
    server := &http.Server{
        Addr:           fmt.Sprintf(":%d", cfg.Port),
        Handler:        router,
        ReadTimeout:    15 * time.Second,
        WriteTimeout:   15 * time.Second,
        MaxHeaderBytes: 1 << 20,
    }
    
    // ä¼˜é›…å…³é—­
    go func() {
        log.Info(fmt.Sprintf("Starting server on port %d", cfg.Port))
        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatal("Server failed to start", err)
        }
    }()
    
    // ç­‰å¾…ä¸­æ–­ä¿¡å·
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Info("Shutting down server...")
    
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := server.Shutdown(ctx); err != nil {
        log.Fatal("Server forced to shutdown", err)
    }
    
    log.Info("Server exited")
}
```

### 1.2 æ•°æ®æ¨¡å‹

**`internal/models/task.go`**

```go
package models

import (
    "time"
)

// Task represents a task in the system
type Task struct {
    ID          int64      `json:"id" db:"id"`
    UserID      int64      `json:"user_id" db:"user_id"`
    Title       string     `json:"title" db:"title" binding:"required,min=1,max=200"`
    Description string     `json:"description" db:"description"`
    Status      string     `json:"status" db:"status"` // pending, in_progress, completed
    Priority    int        `json:"priority" db:"priority"` // 1-5
    DueDate     *time.Time `json:"due_date,omitempty" db:"due_date"`
    CreatedAt   time.Time  `json:"created_at" db:"created_at"`
    UpdatedAt   time.Time  `json:"updated_at" db:"updated_at"`
}

// User represents a user in the system
type User struct {
    ID        int64     `json:"id" db:"id"`
    Email     string    `json:"email" db:"email" binding:"required,email"`
    Password  string    `json:"-" db:"password"` // ä¸è¿”å›ç»™å®¢æˆ·ç«¯
    Name      string    `json:"name" db:"name" binding:"required,min=1,max=100"`
    CreatedAt time.Time `json:"created_at" db:"created_at"`
    UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
}

// LoginRequest represents login credentials
type LoginRequest struct {
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required,min=6"`
}

// RegisterRequest represents registration data
type RegisterRequest struct {
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required,min=6"`
    Name     string `json:"name" binding:"required,min=1,max=100"`
}

// TaskFilter represents filtering options for tasks
type TaskFilter struct {
    UserID   int64
    Status   string
    Priority *int
    Limit    int
    Offset   int
}
```

### 1.3 æ•°æ®åº“å±‚

**`internal/repository/postgres.go`**

```go
package repository

import (
    "context"
    "database/sql"
    "fmt"
    "time"

    _ "github.com/lib/pq"
    
    "task-manager/internal/models"
)

type PostgresRepository struct {
    db *sql.DB
}

func NewPostgresRepository(dsn string) (*PostgresRepository, error) {
    db, err := sql.Open("postgres", dsn)
    if err != nil {
        return nil, fmt.Errorf("failed to open database: %w", err)
    }
    
    // é…ç½®è¿æ¥æ± 
    db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(5)
    db.SetConnMaxLifetime(5 * time.Minute)
    
    // æµ‹è¯•è¿æ¥
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := db.PingContext(ctx); err != nil {
        return nil, fmt.Errorf("failed to ping database: %w", err)
    }
    
    // åˆå§‹åŒ–æ•°æ®åº“è¡¨
    if err := initSchema(db); err != nil {
        return nil, fmt.Errorf("failed to initialize schema: %w", err)
    }
    
    return &PostgresRepository{db: db}, nil
}

func initSchema(db *sql.DB) error {
    schema := `
    CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        email VARCHAR(255) UNIQUE NOT NULL,
        password VARCHAR(255) NOT NULL,
        name VARCHAR(100) NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE IF NOT EXISTS tasks (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        title VARCHAR(200) NOT NULL,
        description TEXT,
        status VARCHAR(20) NOT NULL DEFAULT 'pending',
        priority INTEGER DEFAULT 3 CHECK (priority >= 1 AND priority <= 5),
        due_date TIMESTAMP,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
    CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
    CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
    `
    
    _, err := db.Exec(schema)
    return err
}

func (r *PostgresRepository) Ping() error {
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()
    return r.db.PingContext(ctx)
}

func (r *PostgresRepository) Close() error {
    return r.db.Close()
}

// Task CRUD operations
func (r *PostgresRepository) CreateTask(ctx context.Context, task *models.Task) error {
    query := `
        INSERT INTO tasks (user_id, title, description, status, priority, due_date)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING id, created_at, updated_at
    `
    
    return r.db.QueryRowContext(
        ctx, query,
        task.UserID, task.Title, task.Description, task.Status, task.Priority, task.DueDate,
    ).Scan(&task.ID, &task.CreatedAt, &task.UpdatedAt)
}

func (r *PostgresRepository) GetTask(ctx context.Context, id, userID int64) (*models.Task, error) {
    var task models.Task
    query := `
        SELECT id, user_id, title, description, status, priority, due_date, created_at, updated_at
        FROM tasks
        WHERE id = $1 AND user_id = $2
    `
    
    err := r.db.QueryRowContext(ctx, query, id, userID).Scan(
        &task.ID, &task.UserID, &task.Title, &task.Description,
        &task.Status, &task.Priority, &task.DueDate,
        &task.CreatedAt, &task.UpdatedAt,
    )
    
    if err == sql.ErrNoRows {
        return nil, fmt.Errorf("task not found")
    }
    
    return &task, err
}

func (r *PostgresRepository) ListTasks(ctx context.Context, filter models.TaskFilter) ([]*models.Task, error) {
    query := `
        SELECT id, user_id, title, description, status, priority, due_date, created_at, updated_at
        FROM tasks
        WHERE user_id = $1
    `
    args := []interface{}{filter.UserID}
    argCount := 1
    
    if filter.Status != "" {
        argCount++
        query += fmt.Sprintf(" AND status = $%d", argCount)
        args = append(args, filter.Status)
    }
    
    if filter.Priority != nil {
        argCount++
        query += fmt.Sprintf(" AND priority = $%d", argCount)
        args = append(args, *filter.Priority)
    }
    
    query += " ORDER BY created_at DESC"
    
    if filter.Limit > 0 {
        argCount++
        query += fmt.Sprintf(" LIMIT $%d", argCount)
        args = append(args, filter.Limit)
    }
    
    if filter.Offset > 0 {
        argCount++
        query += fmt.Sprintf(" OFFSET $%d", argCount)
        args = append(args, filter.Offset)
    }
    
    rows, err := r.db.QueryContext(ctx, query, args...)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var tasks []*models.Task
    for rows.Next() {
        var task models.Task
        if err := rows.Scan(
            &task.ID, &task.UserID, &task.Title, &task.Description,
            &task.Status, &task.Priority, &task.DueDate,
            &task.CreatedAt, &task.UpdatedAt,
        ); err != nil {
            return nil, err
        }
        tasks = append(tasks, &task)
    }
    
    return tasks, rows.Err()
}

func (r *PostgresRepository) UpdateTask(ctx context.Context, task *models.Task) error {
    query := `
        UPDATE tasks
        SET title = $1, description = $2, status = $3, priority = $4, due_date = $5, updated_at = CURRENT_TIMESTAMP
        WHERE id = $6 AND user_id = $7
        RETURNING updated_at
    `
    
    return r.db.QueryRowContext(
        ctx, query,
        task.Title, task.Description, task.Status, task.Priority, task.DueDate, task.ID, task.UserID,
    ).Scan(&task.UpdatedAt)
}

func (r *PostgresRepository) DeleteTask(ctx context.Context, id, userID int64) error {
    query := `DELETE FROM tasks WHERE id = $1 AND user_id = $2`
    result, err := r.db.ExecContext(ctx, query, id, userID)
    if err != nil {
        return err
    }
    
    rows, err := result.RowsAffected()
    if err != nil {
        return err
    }
    
    if rows == 0 {
        return fmt.Errorf("task not found")
    }
    
    return nil
}

// User operations
func (r *PostgresRepository) CreateUser(ctx context.Context, user *models.User) error {
    query := `
        INSERT INTO users (email, password, name)
        VALUES ($1, $2, $3)
        RETURNING id, created_at, updated_at
    `
    
    return r.db.QueryRowContext(ctx, query, user.Email, user.Password, user.Name).
        Scan(&user.ID, &user.CreatedAt, &user.UpdatedAt)
}

func (r *PostgresRepository) GetUserByEmail(ctx context.Context, email string) (*models.User, error) {
    var user models.User
    query := `
        SELECT id, email, password, name, created_at, updated_at
        FROM users
        WHERE email = $1
    `
    
    err := r.db.QueryRowContext(ctx, query, email).Scan(
        &user.ID, &user.Email, &user.Password, &user.Name, &user.CreatedAt, &user.UpdatedAt,
    )
    
    if err == sql.ErrNoRows {
        return nil, fmt.Errorf("user not found")
    }
    
    return &user, err
}
```

**`internal/repository/redis.go`**

```go
package repository

import (
    "context"
    "encoding/json"
    "fmt"
    "time"

    "github.com/redis/go-redis/v9"
    
    "task-manager/internal/models"
)

type RedisRepository struct {
    client *redis.Client
}

func NewRedisRepository(addr string) *RedisRepository {
    client := redis.NewClient(&redis.Options{
        Addr:         addr,
        Password:     "",
        DB:           0,
        DialTimeout:  5 * time.Second,
        ReadTimeout:  3 * time.Second,
        WriteTimeout: 3 * time.Second,
        PoolSize:     10,
    })
    
    return &RedisRepository{client: client}
}

func (r *RedisRepository) Close() error {
    return r.client.Close()
}

func (r *RedisRepository) SetTask(ctx context.Context, task *models.Task, ttl time.Duration) error {
    key := fmt.Sprintf("task:%d", task.ID)
    data, err := json.Marshal(task)
    if err != nil {
        return err
    }
    
    return r.client.Set(ctx, key, data, ttl).Err()
}

func (r *RedisRepository) GetTask(ctx context.Context, id int64) (*models.Task, error) {
    key := fmt.Sprintf("task:%d", id)
    data, err := r.client.Get(ctx, key).Bytes()
    if err == redis.Nil {
        return nil, fmt.Errorf("cache miss")
    }
    if err != nil {
        return nil, err
    }
    
    var task models.Task
    if err := json.Unmarshal(data, &task); err != nil {
        return nil, err
    }
    
    return &task, nil
}

func (r *RedisRepository) DeleteTask(ctx context.Context, id int64) error {
    key := fmt.Sprintf("task:%d", id)
    return r.client.Del(ctx, key).Err()
}

func (r *RedisRepository) Ping() error {
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()
    return r.client.Ping(ctx).Err()
}
```

### 1.4 æœåŠ¡å±‚

**`internal/service/task_service.go`**

```go
package service

import (
    "context"
    "fmt"
    "time"

    "golang.org/x/crypto/bcrypt"
    "github.com/golang-jwt/jwt/v5"
    
    "task-manager/internal/models"
    "task-manager/internal/repository"
    "task-manager/pkg/logger"
)

type TaskService struct {
    pgRepo    *repository.PostgresRepository
    redisRepo *repository.RedisRepository
    log       *logger.Logger
}

func NewTaskService(pg *repository.PostgresRepository, redis *repository.RedisRepository, log *logger.Logger) *TaskService {
    return &TaskService{
        pgRepo:    pg,
        redisRepo: redis,
        log:       log,
    }
}

// Task operations with caching
func (s *TaskService) CreateTask(ctx context.Context, task *models.Task) error {
    if task.Status == "" {
        task.Status = "pending"
    }
    if task.Priority == 0 {
        task.Priority = 3
    }
    
    if err := s.pgRepo.CreateTask(ctx, task); err != nil {
        return err
    }
    
    // å¼‚æ­¥ç¼“å­˜
    go func() {
        ctx := context.Background()
        if err := s.redisRepo.SetTask(ctx, task, 10*time.Minute); err != nil {
            s.log.Warn("Failed to cache task", err)
        }
    }()
    
    return nil
}

func (s *TaskService) GetTask(ctx context.Context, id, userID int64) (*models.Task, error) {
    // å…ˆæŸ¥ç¼“å­˜
    task, err := s.redisRepo.GetTask(ctx, id)
    if err == nil && task.UserID == userID {
        s.log.Debug(fmt.Sprintf("Cache hit for task %d", id))
        return task, nil
    }
    
    // ç¼“å­˜æœªå‘½ä¸­ï¼ŒæŸ¥æ•°æ®åº“
    task, err = s.pgRepo.GetTask(ctx, id, userID)
    if err != nil {
        return nil, err
    }
    
    // å¼‚æ­¥æ›´æ–°ç¼“å­˜
    go func() {
        ctx := context.Background()
        if err := s.redisRepo.SetTask(ctx, task, 10*time.Minute); err != nil {
            s.log.Warn("Failed to cache task", err)
        }
    }()
    
    return task, nil
}

func (s *TaskService) ListTasks(ctx context.Context, filter models.TaskFilter) ([]*models.Task, error) {
    return s.pgRepo.ListTasks(ctx, filter)
}

func (s *TaskService) UpdateTask(ctx context.Context, task *models.Task) error {
    if err := s.pgRepo.UpdateTask(ctx, task); err != nil {
        return err
    }
    
    // åˆ é™¤ç¼“å­˜
    go func() {
        ctx := context.Background()
        if err := s.redisRepo.DeleteTask(ctx, task.ID); err != nil {
            s.log.Warn("Failed to delete task cache", err)
        }
    }()
    
    return nil
}

func (s *TaskService) DeleteTask(ctx context.Context, id, userID int64) error {
    if err := s.pgRepo.DeleteTask(ctx, id, userID); err != nil {
        return err
    }
    
    // åˆ é™¤ç¼“å­˜
    go func() {
        ctx := context.Background()
        if err := s.redisRepo.DeleteTask(ctx, id); err != nil {
            s.log.Warn("Failed to delete task cache", err)
        }
    }()
    
    return nil
}

// Authentication
func (s *TaskService) Register(ctx context.Context, req models.RegisterRequest) (*models.User, error) {
    // åŠ å¯†å¯†ç 
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        return nil, err
    }
    
    user := &models.User{
        Email:    req.Email,
        Password: string(hashedPassword),
        Name:     req.Name,
    }
    
    if err := s.pgRepo.CreateUser(ctx, user); err != nil {
        return nil, err
    }
    
    return user, nil
}

func (s *TaskService) Login(ctx context.Context, req models.LoginRequest, jwtSecret string) (string, error) {
    user, err := s.pgRepo.GetUserByEmail(ctx, req.Email)
    if err != nil {
        return "", fmt.Errorf("invalid credentials")
    }
    
    // éªŒè¯å¯†ç 
    if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password)); err != nil {
        return "", fmt.Errorf("invalid credentials")
    }
    
    // ç”ŸæˆJWT
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
        "user_id": user.ID,
        "email":   user.Email,
        "exp":     time.Now().Add(24 * time.Hour).Unix(),
    })
    
    tokenString, err := token.SignedString([]byte(jwtSecret))
    if err != nil {
        return "", err
    }
    
    return tokenString, nil
}
```

### 1.5 HTTPå¤„ç†å™¨

**`internal/handler/task_handler.go`**

```go
package handler

import (
    "net/http"
    "strconv"

    "github.com/gin-gonic/gin"
    
    "task-manager/internal/config"
    "task-manager/internal/models"
    "task-manager/internal/service"
    "task-manager/pkg/logger"
)

type TaskHandler struct {
    service *service.TaskService
    log     *logger.Logger
}

func NewTaskHandler(service *service.TaskService, log *logger.Logger) *TaskHandler {
    return &TaskHandler{
        service: service,
        log:     log,
    }
}

// Register handles user registration
func (h *TaskHandler) Register(c *gin.Context) {
    var req models.RegisterRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    user, err := h.service.Register(c.Request.Context(), req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusCreated, user)
}

// Login handles user login
func (h *TaskHandler) Login(c *gin.Context) {
    var req models.LoginRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    cfg := config.Load()
    token, err := h.service.Login(c.Request.Context(), req, cfg.JWTSecret)
    if err != nil {
        c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{"token": token})
}

// CreateTask creates a new task
func (h *TaskHandler) CreateTask(c *gin.Context) {
    var task models.Task
    if err := c.ShouldBindJSON(&task); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    // ä»JWTä¸­è·å–user_id
    userID, _ := c.Get("user_id")
    task.UserID = userID.(int64)
    
    if err := h.service.CreateTask(c.Request.Context(), &task); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusCreated, task)
}

// GetTask retrieves a single task
func (h *TaskHandler) GetTask(c *gin.Context) {
    id, err := strconv.ParseInt(c.Param("id"), 10, 64)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid task id"})
        return
    }
    
    userID, _ := c.Get("user_id")
    task, err := h.service.GetTask(c.Request.Context(), id, userID.(int64))
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, task)
}

// ListTasks retrieves all tasks for the user
func (h *TaskHandler) ListTasks(c *gin.Context) {
    userID, _ := c.Get("user_id")
    
    filter := models.TaskFilter{
        UserID: userID.(int64),
        Status: c.Query("status"),
        Limit:  20,
        Offset: 0,
    }
    
    if priority := c.Query("priority"); priority != "" {
        p, err := strconv.Atoi(priority)
        if err == nil {
            filter.Priority = &p
        }
    }
    
    if limit := c.Query("limit"); limit != "" {
        l, err := strconv.Atoi(limit)
        if err == nil && l > 0 && l <= 100 {
            filter.Limit = l
        }
    }
    
    if offset := c.Query("offset"); offset != "" {
        o, err := strconv.Atoi(offset)
        if err == nil && o >= 0 {
            filter.Offset = o
        }
    }
    
    tasks, err := h.service.ListTasks(c.Request.Context(), filter)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{"tasks": tasks, "count": len(tasks)})
}

// UpdateTask updates an existing task
func (h *TaskHandler) UpdateTask(c *gin.Context) {
    id, err := strconv.ParseInt(c.Param("id"), 10, 64)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid task id"})
        return
    }
    
    var task models.Task
    if err := c.ShouldBindJSON(&task); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    userID, _ := c.Get("user_id")
    task.ID = id
    task.UserID = userID.(int64)
    
    if err := h.service.UpdateTask(c.Request.Context(), &task); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, task)
}

// DeleteTask deletes a task
func (h *TaskHandler) DeleteTask(c *gin.Context) {
    id, err := strconv.ParseInt(c.Param("id"), 10, 64)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid task id"})
        return
    }
    
    userID, _ := c.Get("user_id")
    if err := h.service.DeleteTask(c.Request.Context(), id, userID.(int64)); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{"message": "task deleted successfully"})
}
```

### 1.6 ä¸­é—´ä»¶

**`internal/middleware/auth.go`**

```go
package middleware

import (
    "net/http"
    "strings"

    "github.com/gin-gonic/gin"
    "github.com/golang-jwt/jwt/v5"
)

func AuthRequired(jwtSecret string) gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "missing authorization header"})
            c.Abort()
            return
        }
        
        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
        if tokenString == authHeader {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid authorization header format"})
            c.Abort()
            return
        }
        
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
            return []byte(jwtSecret), nil
        })
        
        if err != nil || !token.Valid {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid token"})
            c.Abort()
            return
        }
        
        claims, ok := token.Claims.(jwt.MapClaims)
        if !ok {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid token claims"})
            c.Abort()
            return
        }
        
        c.Set("user_id", int64(claims["user_id"].(float64)))
        c.Set("email", claims["email"].(string))
        
        c.Next()
    }
}
```

**`internal/middleware/metrics.go`**

```go
package middleware

import (
    "strconv"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    httpRequestsTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total number of HTTP requests",
        },
        []string{"method", "path", "status"},
    )
    
    httpRequestDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_request_duration_seconds",
            Help:    "HTTP request duration in seconds",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method", "path"},
    )
)

func Metrics() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        
        c.Next()
        
        duration := time.Since(start).Seconds()
        status := strconv.Itoa(c.Writer.Status())
        
        httpRequestsTotal.WithLabelValues(c.Request.Method, c.FullPath(), status).Inc()
        httpRequestDuration.WithLabelValues(c.Request.Method, c.FullPath()).Observe(duration)
    }
}
```

### 1.7 é…ç½®ç®¡ç†

**`internal/config/config.go`**

```go
package config

import (
    "os"
    "strconv"
)

type Config struct {
    Environment    string
    Port           int
    DatabaseURL    string
    RedisURL       string
    JWTSecret      string
    JaegerEndpoint string
    ServiceName    string
    LogLevel       string
}

func Load() *Config {
    return &Config{
        Environment:    getEnv("ENVIRONMENT", "development"),
        Port:           getEnvAsInt("PORT", 8080),
        DatabaseURL:    getEnv("DATABASE_URL", "postgres://postgres:postgres@localhost:5432/taskdb?sslmode=disable"),
        RedisURL:       getEnv("REDIS_URL", "localhost:6379"),
        JWTSecret:      getEnv("JWT_SECRET", "my-secret-key-change-in-production"),
        JaegerEndpoint: getEnv("JAEGER_ENDPOINT", "http://localhost:14268/api/traces"),
        ServiceName:    getEnv("SERVICE_NAME", "task-manager"),
        LogLevel:       getEnv("LOG_LEVEL", "info"),
    }
}

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func getEnvAsInt(key string, defaultValue int) int {
    if value := os.Getenv(key); value != "" {
        if intValue, err := strconv.Atoi(value); err == nil {
            return intValue
        }
    }
    return defaultValue
}
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šå®¹å™¨åŒ–é…ç½®

### 2.1 Dockerfile

**`deployments/docker/Dockerfile`**

```dockerfile
# ========== å¤šé˜¶æ®µæ„å»º Dockerfile ==========

# é˜¶æ®µ1: æ„å»ºé˜¶æ®µ
FROM golang:1.25.3-alpine AS builder

# å®‰è£…å¿…è¦å·¥å…·
RUN apk add --no-cache git ca-certificates tzdata

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /build

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY go.mod go.sum ./
RUN go mod download

# å¤åˆ¶æºä»£ç 
COPY . .

# æ„å»ºåº”ç”¨ï¼ˆé™æ€ç¼–è¯‘ï¼Œç¦ç”¨CGOï¼‰
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
    -ldflags="-w -s -X main.version=$(git describe --tags --always)" \
    -o task-manager \
    ./cmd/api

# é˜¶æ®µ2: è¿è¡Œé˜¶æ®µ
FROM alpine:latest

# å®‰è£…CAè¯ä¹¦å’Œæ—¶åŒºæ•°æ®
RUN apk --no-cache add ca-certificates tzdata

# åˆ›å»ºérootç”¨æˆ·
RUN addgroup -g 1000 appgroup && \
    adduser -D -u 1000 -G appgroup appuser

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /app

# ä»æ„å»ºé˜¶æ®µå¤åˆ¶äºŒè¿›åˆ¶æ–‡ä»¶
COPY --from=builder /build/task-manager .

# ä¿®æ”¹æ‰€æœ‰è€…
RUN chown -R appuser:appgroup /app

# åˆ‡æ¢åˆ°érootç”¨æˆ·
USER appuser

# æš´éœ²ç«¯å£
EXPOSE 8080

# å¥åº·æ£€æŸ¥
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1

# å¯åŠ¨åº”ç”¨
ENTRYPOINT ["./task-manager"]
```

### 2.2 .dockerignore

**`.dockerignore`**

```text
# Git
.git
.gitignore

# IDE
.vscode
.idea
*.swp
*.swo

# æ„å»ºäº§ç‰©
bin/
dist/
*.exe

# æµ‹è¯•
*_test.go
coverage.out
coverage.html

# æ–‡æ¡£
*.md
docs/

# éƒ¨ç½²æ–‡ä»¶
deployments/kubernetes/
deployments/helm/
.github/

# ç¯å¢ƒæ–‡ä»¶
.env
.env.local

# ä¸´æ—¶æ–‡ä»¶
tmp/
temp/
```

### 2.3 Docker Compose (æœ¬åœ°å¼€å‘)

**`deployments/docker/docker-compose.yml`**

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    container_name: taskdb
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: taskdb
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: taskredis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5

  jaeger:
    image: jaegertracing/all-in-one:latest
    container_name: jaeger
    ports:
      - "5775:5775/udp"
      - "6831:6831/udp"
      - "6832:6832/udp"
      - "5778:5778"
      - "16686:16686"
      - "14268:14268"
      - "14250:14250"
      - "9411:9411"
    environment:
      COLLECTOR_ZIPKIN_HOST_PORT: ":9411"

  task-manager:
    build:
      context: ../..
      dockerfile: deployments/docker/Dockerfile
    container_name: task-manager
    ports:
      - "8080:8080"
    environment:
      ENVIRONMENT: development
      PORT: 8080
      DATABASE_URL: postgres://postgres:postgres@postgres:5432/taskdb?sslmode=disable
      REDIS_URL: redis:6379
      JWT_SECRET: my-development-secret-key
      JAEGER_ENDPOINT: http://jaeger:14268/api/traces
      SERVICE_NAME: task-manager
      LOG_LEVEL: debug
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      jaeger:
        condition: service_started
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šKuberneteséƒ¨ç½²

### 3.1 å‘½åç©ºé—´

**`deployments/kubernetes/namespace.yaml`**

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: task-manager
  labels:
    name: task-manager
    environment: production
```

### 3.2 ConfigMap

**`deployments/kubernetes/configmap.yaml`**

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: task-manager-config
  namespace: task-manager
data:
  ENVIRONMENT: "production"
  PORT: "8080"
  LOG_LEVEL: "info"
  SERVICE_NAME: "task-manager"
  DATABASE_URL: "postgres://postgres:$(POSTGRES_PASSWORD)@postgres-service:5432/taskdb?sslmode=disable"
  REDIS_URL: "redis-service:6379"
  JAEGER_ENDPOINT: "http://jaeger-collector:14268/api/traces"
```

### 3.3 Secret

**`deployments/kubernetes/secret.yaml`**

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: task-manager-secrets
  namespace: task-manager
type: Opaque
stringData:
  POSTGRES_PASSWORD: "your-secure-postgres-password"
  JWT_SECRET: "your-secure-jwt-secret-key-min-32-chars"
```

### 3.4 PostgreSQLéƒ¨ç½²

**`deployments/kubernetes/postgres.yaml`**

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc
  namespace: task-manager
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
  namespace: task-manager
spec:
  serviceName: postgres-service
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:15-alpine
        ports:
        - containerPort: 5432
          name: postgres
        env:
        - name: POSTGRES_USER
          value: "postgres"
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: task-manager-secrets
              key: POSTGRES_PASSWORD
        - name: POSTGRES_DB
          value: "taskdb"
        - name: PGDATA
          value: /var/lib/postgresql/data/pgdata
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          exec:
            command:
            - pg_isready
            - -U
            - postgres
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          exec:
            command:
            - pg_isready
            - -U
            - postgres
          initialDelaySeconds: 5
          periodSeconds: 5
  volumeClaimTemplates:
  - metadata:
      name: postgres-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi
---
apiVersion: v1
kind: Service
metadata:
  name: postgres-service
  namespace: task-manager
spec:
  selector:
    app: postgres
  ports:
  - port: 5432
    targetPort: 5432
  clusterIP: None
```

### 3.5 Rediséƒ¨ç½²

**`deployments/kubernetes/redis.yaml`**

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: redis
  namespace: task-manager
spec:
  serviceName: redis-service
  replicas: 1
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
    spec:
      containers:
      - name: redis
        image: redis:7-alpine
        ports:
        - containerPort: 6379
          name: redis
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          exec:
            command:
            - redis-cli
            - ping
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          exec:
            command:
            - redis-cli
            - ping
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: redis-service
  namespace: task-manager
spec:
  selector:
    app: redis
  ports:
  - port: 6379
    targetPort: 6379
  clusterIP: None
```

### 3.6 åº”ç”¨ç¨‹åºéƒ¨ç½²

**`deployments/kubernetes/deployment.yaml`**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: task-manager
  namespace: task-manager
  labels:
    app: task-manager
    version: v1
spec:
  replicas: 3
  selector:
    matchLabels:
      app: task-manager
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    metadata:
      labels:
        app: task-manager
        version: v1
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      containers:
      - name: task-manager
        image: your-registry/task-manager:latest
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
          name: http
          protocol: TCP
        envFrom:
        - configMapRef:
            name: task-manager-config
        env:
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: task-manager-secrets
              key: POSTGRES_PASSWORD
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: task-manager-secrets
              key: JWT_SECRET
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 15
          periodSeconds: 10
          timeoutSeconds: 3
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
```

### 3.7 Service

**`deployments/kubernetes/service.yaml`**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: task-manager-service
  namespace: task-manager
  labels:
    app: task-manager
spec:
  type: ClusterIP
  selector:
    app: task-manager
  ports:
  - name: http
    port: 80
    targetPort: 8080
    protocol: TCP
  sessionAffinity: None
```

### 3.8 Ingress

**`deployments/kubernetes/ingress.yaml`**

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: task-manager-ingress
  namespace: task-manager
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/rate-limit: "100"
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - task-manager.example.com
    secretName: task-manager-tls
  rules:
  - host: task-manager.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: task-manager-service
            port:
              number: 80
```

### 3.9 HPA (æ°´å¹³è‡ªåŠ¨æ‰©å±•)

**`deployments/kubernetes/hpa.yaml`**

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: task-manager-hpa
  namespace: task-manager
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: task-manager
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15
      - type: Pods
        value: 2
        periodSeconds: 15
      selectPolicy: Max
```

---

## ç¬¬å››éƒ¨åˆ†ï¼šCI/CDæµæ°´çº¿

### 4.1 GitHub Actions

**`.github/workflows/ci-cd.yaml`**

```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/task-manager

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: testdb
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25.3'

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Download dependencies
        run: go mod download

      - name: Run tests
        env:
          DATABASE_URL: postgres://postgres:postgres@localhost:5432/testdb?sslmode=disable
          REDIS_URL: localhost:6379
        run: go test -v -race -coverprofile=coverage.out ./...

      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage.out

  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25.3'

      - name: golangci-lint
        uses: golangci/golangci-lint-action@v4
        with:
          version: latest

  build:
    name: Build and Push
    needs: [test, lint]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=semver,pattern={{version}}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./deployments/docker/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to Kubernetes
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure kubectl
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG }}

      - name: Deploy to Kubernetes
        run: |
          kubectl apply -f deployments/kubernetes/namespace.yaml
          kubectl apply -f deployments/kubernetes/configmap.yaml
          kubectl apply -f deployments/kubernetes/secret.yaml
          kubectl apply -f deployments/kubernetes/postgres.yaml
          kubectl apply -f deployments/kubernetes/redis.yaml
          kubectl apply -f deployments/kubernetes/deployment.yaml
          kubectl apply -f deployments/kubernetes/service.yaml
          kubectl apply -f deployments/kubernetes/ingress.yaml
          kubectl apply -f deployments/kubernetes/hpa.yaml

      - name: Verify deployment
        run: |
          kubectl rollout status deployment/task-manager -n task-manager
          kubectl get pods -n task-manager
```

**CI/CDæµæ°´çº¿å¯è§†åŒ–**:

```mermaid
graph LR
    A[ğŸ“ ä»£ç æ¨é€] --> B[ğŸ” Checkout]
    B --> C{åˆ†æ”¯æ£€æŸ¥}
    
    C -->|PR| D1[ğŸ§ª æµ‹è¯•]
    C -->|mainåˆ†æ”¯| D1
    
    D1 --> D2[ğŸ“‹ ä»£ç è´¨é‡]
    D2 --> D3[ğŸ”§ æ„å»º]
    
    C -->|émain| END1[ç»“æŸ]
    
    D3 --> E{æ„å»ºæˆåŠŸ?}
    E -->|å¤±è´¥| F1[âŒ é€šçŸ¥å¤±è´¥]
    E -->|æˆåŠŸ| F2[ğŸ“¦ æ¨é€é•œåƒ]
    
    F2 --> G[ğŸš€ éƒ¨ç½²K8s]
    G --> H[âœ… å¥åº·æ£€æŸ¥]
    H --> I[âœ… éƒ¨ç½²å®Œæˆ]
    
    F1 --> END2[ç»“æŸ]
    
    style A fill:#e1f5ff
    style D1 fill:#fff4e1
    style D2 fill:#fff4e1
    style D3 fill:#e1ffe1
    style F2 fill:#e1ffe1
    style G fill:#ffe1e1
    style I fill:#e1ffe1
    style F1 fill:#ffe1e1
```

**æµæ°´çº¿æ—¶åºå›¾**:

```mermaid
gantt
    title CI/CD Pipeline Execution Timeline
    dateFormat mm:ss
    axisFormat %M:%S
    
    section å‡†å¤‡
    Checkout Code       :done, prep1, 00:00, 10s
    Cache Dependencies  :done, prep2, after prep1, 15s
    
    section è´¨é‡æ£€æŸ¥
    Linters             :active, qa1, after prep2, 30s
    Unit Tests          :qa2, after qa1, 45s
    Integration Tests   :qa3, after qa2, 60s
    
    section æ„å»º
    Build Binary        :build1, after qa3, 40s
    Build Docker Image  :build2, after build1, 50s
    Scan Image          :build3, after build2, 20s
    
    section éƒ¨ç½²
    Push to Registry    :deploy1, after build3, 20s
    Apply K8s Manifests :deploy2, after deploy1, 30s
    Health Check        :deploy3, after deploy2, 15s
    Smoke Tests         :deploy4, after deploy3, 25s
```

### 4.2 Makefile

**`Makefile`**

```makefile
.PHONY: help build test lint run docker-build docker-run k8s-deploy k8s-delete clean

# Variables
APP_NAME=task-manager
DOCKER_IMAGE=task-manager:latest
NAMESPACE=task-manager

help: ## Display this help
 @awk 'BEGIN {FS = ":.*##"; printf "\nUsage:\n  make \033[36m<target>\033[0m\n"} /^[a-zA-Z_-]+:.*?##/ { printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2 } /^##@/ { printf "\n\033[1m%s\033[0m\n", substr($$0, 5) } ' $(MAKEFILE_LIST)

##@ Development

build: ## Build the application
 go build -o bin/$(APP_NAME) ./cmd/api

test: ## Run tests
 go test -v -race -coverprofile=coverage.out ./...

lint: ## Run linters
 golangci-lint run ./...

run: ## Run the application locally
 go run ./cmd/api/main.go

##@ Docker

docker-build: ## Build Docker image
 docker build -t $(DOCKER_IMAGE) -f deployments/docker/Dockerfile .

docker-run: ## Run Docker container
 docker-compose -f deployments/docker/docker-compose.yml up -d

docker-stop: ## Stop Docker container
 docker-compose -f deployments/docker/docker-compose.yml down

##@ Kubernetes

k8s-deploy: ## Deploy to Kubernetes
 kubectl apply -f deployments/kubernetes/namespace.yaml
 kubectl apply -f deployments/kubernetes/configmap.yaml
 kubectl apply -f deployments/kubernetes/secret.yaml
 kubectl apply -f deployments/kubernetes/postgres.yaml
 kubectl apply -f deployments/kubernetes/redis.yaml
 kubectl apply -f deployments/kubernetes/deployment.yaml
 kubectl apply -f deployments/kubernetes/service.yaml
 kubectl apply -f deployments/kubernetes/ingress.yaml
 kubectl apply -f deployments/kubernetes/hpa.yaml

k8s-delete: ## Delete from Kubernetes
 kubectl delete namespace $(NAMESPACE)

k8s-logs: ## View application logs
 kubectl logs -f -n $(NAMESPACE) -l app=$(APP_NAME)

k8s-status: ## Check deployment status
 kubectl get all -n $(NAMESPACE)

##@ Cleanup

clean: ## Clean build artifacts
 rm -rf bin/
 rm -f coverage.out
```

---

## ç¬¬äº”éƒ¨åˆ†ï¼šå¯è§‚æµ‹æ€§

### 5.1 Prometheusç›‘æ§

**`monitoring/prometheus/prometheus.yaml`**

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config
  namespace: task-manager
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s
      evaluation_interval: 15s

    scrape_configs:
      - job_name: 'task-manager'
        kubernetes_sd_configs:
          - role: pod
            namespaces:
              names:
                - task-manager
        relabel_configs:
          - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
            action: keep
            regex: true
          - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
            action: replace
            target_label: __metrics_path__
            regex: (.+)
          - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
            action: replace
            regex: ([^:]+)(?::\d+)?;(\d+)
            replacement: $1:$2
            target_label: __address__
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus
  namespace: task-manager
spec:
  replicas: 1
  selector:
    matchLabels:
      app: prometheus
  template:
    metadata:
      labels:
        app: prometheus
    spec:
      containers:
      - name: prometheus
        image: prom/prometheus:latest
        args:
          - '--config.file=/etc/prometheus/prometheus.yml'
          - '--storage.tsdb.path=/prometheus'
        ports:
        - containerPort: 9090
        volumeMounts:
        - name: prometheus-config
          mountPath: /etc/prometheus
        - name: prometheus-storage
          mountPath: /prometheus
      volumes:
      - name: prometheus-config
        configMap:
          name: prometheus-config
      - name: prometheus-storage
        emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: prometheus
  namespace: task-manager
spec:
  selector:
    app: prometheus
  ports:
  - port: 9090
    targetPort: 9090
```

### 5.2 Grafanaä»ªè¡¨æ¿

**`monitoring/grafana/dashboard.json`** (ç®€åŒ–ç¤ºä¾‹)

```json
{
  "dashboard": {
    "title": "Task Manager Metrics",
    "panels": [
      {
        "title": "HTTP Requests per Second",
        "targets": [
          {
            "expr": "rate(http_requests_total[1m])"
          }
        ]
      },
      {
        "title": "HTTP Request Duration (p95)",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))"
          }
        ]
      },
      {
        "title": "Active Pods",
        "targets": [
          {
            "expr": "count(kube_pod_status_phase{namespace=\"task-manager\", phase=\"Running\"})"
          }
        ]
      }
    ]
  }
}
```

### 5.3 Jaegeråˆ†å¸ƒå¼è¿½è¸ª

**`pkg/tracing/jaeger.go`**

```go
package tracing

import (
    "io"

    "github.com/uber/jaeger-client-go"
    "github.com/uber/jaeger-client-go/config"
)

func InitJaeger(serviceName, endpoint string) (io.Closer, error) {
    cfg := config.Configuration{
        ServiceName: serviceName,
        Sampler: &config.SamplerConfig{
            Type:  jaeger.SamplerTypeConst,
            Param: 1,
        },
        Reporter: &config.ReporterConfig{
            LogSpans:          true,
            CollectorEndpoint: endpoint,
        },
    }

    tracer, closer, err := cfg.NewTracer()
    if err != nil {
        return nil, err
    }

    opentracing.SetGlobalTracer(tracer)
    return closer, nil
}
```

---

## ç¬¬å…­éƒ¨åˆ†ï¼šHelm Chart

### 6.1 Chartç»“æ„

```text
deployments/helm/task-manager/
â”œâ”€â”€ Chart.yaml
â”œâ”€â”€ values.yaml
â”œâ”€â”€ templates/
â”‚   â”œâ”€â”€ deployment.yaml
â”‚   â”œâ”€â”€ service.yaml
â”‚   â”œâ”€â”€ ingress.yaml
â”‚   â”œâ”€â”€ configmap.yaml
â”‚   â”œâ”€â”€ secret.yaml
â”‚   â”œâ”€â”€ hpa.yaml
â”‚   â””â”€â”€ _helpers.tpl
â””â”€â”€ .helmignore
```

### 6.2 Chart.yaml

```yaml
apiVersion: v2
name: task-manager
description: A cloud-native task management system
version: 1.0.0
appVersion: "1.0.0"
type: application
keywords:
  - task-manager
  - go
  - cloud-native
home: https://github.com/your-org/task-manager
maintainers:
  - name: Your Name
    email: your.email@example.com
```

### 6.3 values.yaml

```yaml
replicaCount: 3

image:
  repository: your-registry/task-manager
  pullPolicy: IfNotPresent
  tag: "latest"

service:
  type: ClusterIP
  port: 80
  targetPort: 8080

ingress:
  enabled: true
  className: nginx
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
  hosts:
    - host: task-manager.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: task-manager-tls
      hosts:
        - task-manager.example.com

resources:
  limits:
    cpu: 200m
    memory: 256Mi
  requests:
    cpu: 100m
    memory: 128Mi

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

postgresql:
  enabled: true
  auth:
    username: postgres
    password: postgres
    database: taskdb
  persistence:
    size: 10Gi

redis:
  enabled: true
  architecture: standalone
  auth:
    enabled: false
```

### 6.4 éƒ¨ç½²æ¨¡æ¿

**`deployments/helm/task-manager/templates/deployment.yaml`** (ç®€åŒ–)

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "task-manager.fullname" . }}
  labels:
    {{- include "task-manager.labels" . | nindent 4 }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      {{- include "task-manager.selectorLabels" . | nindent 6 }}
  template:
    metadata:
      labels:
        {{- include "task-manager.selectorLabels" . | nindent 8 }}
    spec:
      containers:
      - name: {{ .Chart.Name }}
        image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
        imagePullPolicy: {{ .Values.image.pullPolicy }}
        ports:
        - name: http
          containerPort: {{ .Values.service.targetPort }}
        resources:
          {{- toYaml .Values.resources | nindent 10 }}
```

---

## ç¬¬ä¸ƒéƒ¨åˆ†ï¼šéƒ¨ç½²æŒ‡å—

### 7.1 å‰ç½®è¦æ±‚

- Docker 20+
- Kubernetes 1.25+
- kubectl
- Helm 3+ (å¯é€‰)
- Go 1.25.3+ (æœ¬åœ°å¼€å‘)

### 7.2 æœ¬åœ°å¼€å‘

```bash
# 1. å…‹éš†ä»£ç 
git clone https://github.com/your-org/task-manager.git
cd task-manager

# 2. å®‰è£…ä¾èµ–
go mod download

# 3. å¯åŠ¨æœ¬åœ°ç¯å¢ƒ (Docker Compose)
make docker-run

# 4. è¿è¡Œåº”ç”¨
make run

# 5. æµ‹è¯•API
curl http://localhost:8080/health
```

### 7.3 Kuberneteséƒ¨ç½²

```bash
# 1. åˆ›å»ºå‘½åç©ºé—´å’Œèµ„æº
make k8s-deploy

# 2. æ£€æŸ¥çŠ¶æ€
make k8s-status

# 3. æŸ¥çœ‹æ—¥å¿—
make k8s-logs

# 4. ç«¯å£è½¬å‘æµ‹è¯•
kubectl port-forward -n task-manager service/task-manager-service 8080:80

# 5. æ¸…ç†èµ„æº
make k8s-delete
```

### 7.4 ä½¿ç”¨Helméƒ¨ç½²

```bash
# 1. æ·»åŠ ä¾èµ–
cd deployments/helm/task-manager
helm dependency update

# 2. å®‰è£…
helm install task-manager . -n task-manager --create-namespace

# 3. å‡çº§
helm upgrade task-manager . -n task-manager

# 4. å¸è½½
helm uninstall task-manager -n task-manager
```

### 7.5 éªŒè¯éƒ¨ç½²

```bash
# 1. æ£€æŸ¥æ‰€æœ‰èµ„æº
kubectl get all -n task-manager

# 2. æ£€æŸ¥PodçŠ¶æ€
kubectl get pods -n task-manager -w

# 3. æ£€æŸ¥HPA
kubectl get hpa -n task-manager

# 4. æŸ¥çœ‹PrometheusæŒ‡æ ‡
kubectl port-forward -n task-manager svc/prometheus 9090:9090

# 5. è®¿é—®Jaeger UI
kubectl port-forward -n task-manager svc/jaeger 16686:16686
```

---

## ç¬¬å…«éƒ¨åˆ†ï¼šæœ€ä½³å®è·µæ€»ç»“

### ä»£ç å±‚é¢

1. **é…ç½®å¤–éƒ¨åŒ–**: ä½¿ç”¨ç¯å¢ƒå˜é‡å’ŒConfigMap
2. **ä¼˜é›…å…³é—­**: å¤„ç†SIGTERMä¿¡å·
3. **å¥åº·æ£€æŸ¥**: å®ç° `/health` å’Œ `/ready` ç«¯ç‚¹
4. **ç»“æ„åŒ–æ—¥å¿—**: ä½¿ç”¨JSONæ ¼å¼æ—¥å¿—
5. **é”™è¯¯å¤„ç†**: ç»Ÿä¸€é”™è¯¯å“åº”æ ¼å¼

### å®¹å™¨å±‚é¢

1. **å¤šé˜¶æ®µæ„å»º**: å‡å°é•œåƒä½“ç§¯
2. **érootç”¨æˆ·**: æå‡å®‰å…¨æ€§
3. **å¥åº·æ£€æŸ¥**: Dockerfile HEALTHCHECKæŒ‡ä»¤
4. **èµ„æºé™åˆ¶**: è®¾ç½®CPUå’Œå†…å­˜é™åˆ¶
5. **é•œåƒæ ‡ç­¾**: ä½¿ç”¨è¯­ä¹‰åŒ–ç‰ˆæœ¬

### Kuberneteså±‚é¢

1. **èµ„æºé…é¢**: è®¾ç½®requestså’Œlimits
2. **æ¢é’ˆé…ç½®**: livenesså’Œreadinessæ¢é’ˆ
3. **æ»šåŠ¨æ›´æ–°**: é›¶åœæœºéƒ¨ç½²
4. **HPA**: è‡ªåŠ¨æ°´å¹³æ‰©ç¼©å®¹
5. **æŒä¹…åŒ–**: ä½¿ç”¨StatefulSetå’ŒPVC

### è¿ç»´å±‚é¢

1. **ç›‘æ§**: PrometheusæŒ‡æ ‡é‡‡é›†
2. **æ—¥å¿—**: é›†ä¸­å¼æ—¥å¿—æ”¶é›†
3. **è¿½è¸ª**: åˆ†å¸ƒå¼é“¾è·¯è¿½è¸ª
4. **å¤‡ä»½**: å®šæœŸå¤‡ä»½æ•°æ®åº“
5. **CI/CD**: è‡ªåŠ¨åŒ–æµ‹è¯•å’Œéƒ¨ç½²

---

## ğŸ¯ æ€»ç»“

æœ¬é¡¹ç›®å±•ç¤ºäº†ä¸€ä¸ª**ç”Ÿäº§çº§äº‘åŸç”Ÿåº”ç”¨**çš„å®Œæ•´å®ç°ï¼Œæ¶µç›–ï¼š

âœ… **å®Œæ•´çš„Goåº”ç”¨ä»£ç ** (3å±‚æ¶æ„)  
âœ… **Dockerå®¹å™¨åŒ–** (å¤šé˜¶æ®µæ„å»º)  
âœ… **Kuberneteså®Œæ•´é…ç½®** (10+ä¸ªYAMLæ–‡ä»¶)  
âœ… **CI/CDè‡ªåŠ¨åŒ–** (GitHub Actions)  
âœ… **å¯è§‚æµ‹æ€§** (Prometheus + Grafana + Jaeger)  
âœ… **Helm Chart** (å¯å¤ç”¨éƒ¨ç½²)  
âœ… **ç”Ÿäº§æœ€ä½³å®è·µ** (å®‰å…¨ã€æ€§èƒ½ã€å¯ç»´æŠ¤æ€§)

### æ ¸å¿ƒä»·å€¼

1. **ç«¯åˆ°ç«¯å‚è€ƒ**: ä»ä»£ç åˆ°éƒ¨ç½²çš„å®Œæ•´æµç¨‹
2. **æœ€ä½³å®è·µ**: éµå¾ªäº‘åŸç”Ÿ12è¦ç´ 
3. **ç”Ÿäº§å°±ç»ª**: åŒ…å«ç›‘æ§ã€æ—¥å¿—ã€è¿½è¸ª
4. **å¯æ‰©å±•æ€§**: HPAå’Œè´Ÿè½½å‡è¡¡
5. **å®‰å…¨æ€§**: érootç”¨æˆ·ã€Secretç®¡ç†

### åç»­æ‰©å±•

- æ·»åŠ Service Mesh (Istio)
- å®ç°è“ç»¿/é‡‘ä¸é›€éƒ¨ç½²
- é›†æˆELKæ—¥å¿—æ ˆ
- æ·»åŠ æ›´å¤šä¸šåŠ¡åŠŸèƒ½
- æ€§èƒ½å‹æµ‹å’Œä¼˜åŒ–

---

## ğŸ“š å‚è€ƒèµ„æ–™

- [Kuberneteså®˜æ–¹æ–‡æ¡£](https://kubernetes.io/docs/)
- [Dockeræœ€ä½³å®è·µ](https://docs.docker.com/develop/dev-best-practices/)
- [12-Factor App](https://12factor.net/)
- [Go Webå¼€å‘æœ€ä½³å®è·µ](https://go.dev/doc/effective_go)
- [Prometheusç›‘æ§æŒ‡å—](https://prometheus.io/docs/introduction/overview/)

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ22æ—¥  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+ | Kubernetes 1.25+
