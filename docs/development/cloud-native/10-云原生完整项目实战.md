# 云原生完整项目实战：Task Management System

> **简介**: 一个完整的云原生任务管理系统，展示从开发到部署的全流程最佳实践  
> **版本**: Go 1.25.3+  
> **难度**: ⭐⭐⭐⭐⭐  
> **标签**: #云原生 #Kubernetes #微服务 #完整项目

**字数**: ~8,500字  
**代码文件**: 30+个完整文件  
**部署时间**: 约2小时  
**适用人群**: 高级Go开发者、架构师

---

## 📋 目录

<!-- TOC START -->
- [云原生完整项目实战：Task Management System](#云原生完整项目实战task-management-system)
  - [📚 目录](#-目录)
  - [🎯 项目概述](#-项目概述)
    - [技术架构](#技术架构)
    - [核心功能](#核心功能)
    - [技术栈](#技术栈)
  - [📁 项目结构](#-项目结构)
  - [第一部分：应用程序代码](#第一部分应用程序代码)
    - [1.1 主应用程序](#11-主应用程序)
    - [1.2 数据模型](#12-数据模型)
    - [1.3 数据库层](#13-数据库层)
    - [1.4 服务层](#14-服务层)
    - [1.5 HTTP处理器](#15-http处理器)
    - [1.6 中间件](#16-中间件)
    - [1.7 配置管理](#17-配置管理)
  - [第二部分：容器化配置](#第二部分容器化配置)
    - [2.1 Dockerfile](#21-dockerfile)
    - [2.2 .dockerignore](#22-dockerignore)
    - [2.3 Docker Compose (本地开发)](#23-docker-compose-本地开发)
  - [第三部分：Kubernetes部署](#第三部分kubernetes部署)
    - [3.1 命名空间](#31-命名空间)
    - [3.2 ConfigMap](#32-configmap)
    - [3.3 Secret](#33-secret)
    - [3.4 PostgreSQL部署](#34-postgresql部署)
    - [3.5 Redis部署](#35-redis部署)
    - [3.6 应用程序部署](#36-应用程序部署)
    - [3.7 Service](#37-service)
    - [3.8 Ingress](#38-ingress)
    - [3.9 HPA (水平自动扩展)](#39-hpa-水平自动扩展)
  - [第四部分：CI/CD流水线](#第四部分cicd流水线)
    - [4.1 GitHub Actions](#41-github-actions)
    - [4.2 Makefile](#42-makefile)
  - [第五部分：可观测性](#第五部分可观测性)
    - [5.1 Prometheus监控](#51-prometheus监控)
    - [5.2 Grafana仪表板](#52-grafana仪表板)
    - [5.3 Jaeger分布式追踪](#53-jaeger分布式追踪)
  - [第六部分：Helm Chart](#第六部分helm-chart)
    - [6.1 Chart结构](#61-chart结构)
    - [6.2 Chart.yaml](#62-chartyaml)
    - [6.3 values.yaml](#63-valuesyaml)
    - [6.4 部署模板](#64-部署模板)
  - [第七部分：部署指南](#第七部分部署指南)
    - [7.1 前置要求](#71-前置要求)
    - [7.2 本地开发](#72-本地开发)
    - [7.3 Kubernetes部署](#73-kubernetes部署)
    - [7.4 使用Helm部署](#74-使用helm部署)
    - [7.5 验证部署](#75-验证部署)
  - [第八部分：最佳实践总结](#第八部分最佳实践总结)
    - [代码层面](#代码层面)
    - [容器层面](#容器层面)
    - [Kubernetes层面](#kubernetes层面)
    - [运维层面](#运维层面)
  - [🎯 总结](#-总结)
    - [核心价值](#核心价值)
    - [后续扩展](#后续扩展)
  - [📚 参考资料](#-参考资料)
<!-- TOC END -->

---

## 🎯 项目概述

### 技术架构

```text
┌────────────────────────────────────────────────────────────────┐
│                        用户流量                                  │
└────────────────────────┬───────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Ingress Controller                            │
│                  (Nginx Ingress / SSL)                          │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│                  Service Mesh (可选)                             │
│                    Istio / Linkerd                              │
└────────────────────────┬────────────────────────────────────────┘
                         │
          ┌──────────────┼──────────────┐
          ▼              ▼              ▼
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│  Task API   │  │  Task API   │  │  Task API   │
│   Pod 1     │  │   Pod 2     │  │   Pod 3     │
│ (Go 1.25.3) │  │ (Go 1.25.3) │  │ (Go 1.25.3) │
└─────┬───────┘  └─────┬───────┘  └─────┬───────┘
      │                │                │
      └────────────────┼────────────────┘
                       │
          ┌────────────┴────────────┐
          ▼                         ▼
┌─────────────────┐       ┌─────────────────┐
│   PostgreSQL    │       │      Redis      │
│   (主数据库)     │       │   (缓存/会话)    │
│   Statefulset   │       │   Statefulset   │
└─────────────────┘       └─────────────────┘
          │
          ▼
┌─────────────────────────────────────────────────────────────────┐
│                      监控 & 日志                                 │
│  Prometheus | Grafana | Jaeger | ELK Stack                     │
└─────────────────────────────────────────────────────────────────┘
```

**Mermaid架构图**（可在GitHub自动渲染）:

```mermaid
graph TB
    subgraph "用户层"
        User[👤 用户]
    end
    
    subgraph "接入层"
        Ingress[🌐 Ingress Controller<br/>Nginx + SSL]
        LB[⚖️ 负载均衡]
    end
    
    subgraph "应用层 - Task API"
        API1[🚀 Pod 1<br/>Go 1.25.3]
        API2[🚀 Pod 2<br/>Go 1.25.3]
        API3[🚀 Pod 3<br/>Go 1.25.3]
    end
    
    subgraph "数据层"
        PG[(🗄️ PostgreSQL 15<br/>主数据库)]
        Redis[(⚡ Redis 7<br/>缓存/会话)]
    end
    
    subgraph "监控 & 可观测性"
        Prom[📊 Prometheus]
        Grafana[📈 Grafana]
        Jaeger[🔍 Jaeger]
    end
    
    User -->|HTTPS| Ingress
    Ingress --> LB
    LB --> API1
    LB --> API2
    LB --> API3
    
    API1 -->|查询/写入| PG
    API2 -->|查询/写入| PG
    API3 -->|查询/写入| PG
    
    API1 -->|缓存| Redis
    API2 -->|缓存| Redis
    API3 -->|缓存| Redis
    
    API1 -.指标.-> Prom
    API2 -.指标.-> Prom
    API3 -.指标.-> Prom
    
    Prom -->|数据源| Grafana
    API1 -.追踪.-> Jaeger
    API2 -.追踪.-> Jaeger
    API3 -.追踪.-> Jaeger
    
    style User fill:#e1f5ff
    style Ingress fill:#ffe1e1
    style API1 fill:#e1ffe1
    style API2 fill:#e1ffe1
    style API3 fill:#e1ffe1
    style PG fill:#fff4e1
    style Redis fill:#fff4e1
    style Prom fill:#f0e1ff
    style Grafana fill:#f0e1ff
    style Jaeger fill:#f0e1ff
```

### 核心功能

1. **任务管理**: 创建、查询、更新、删除任务
2. **用户认证**: JWT认证和授权
3. **缓存机制**: Redis缓存热点数据
4. **健康检查**: Liveness和Readiness探针
5. **指标监控**: Prometheus指标暴露
6. **分布式追踪**: Jaeger链路追踪
7. **自动扩缩容**: HPA基于CPU/内存
8. **CI/CD**: GitHub Actions自动化部署

### 技术栈

- **语言**: Go 1.25.3
- **Web框架**: Gin
- **数据库**: PostgreSQL 15
- **缓存**: Redis 7
- **容器**: Docker
- **编排**: Kubernetes
- **监控**: Prometheus + Grafana
- **追踪**: Jaeger
- **CI/CD**: GitHub Actions
- **包管理**: Helm

---

## 📁 项目结构

```text
task-manager/
├── cmd/
│   └── api/
│       └── main.go                 # 应用入口
├── internal/
│   ├── config/
│   │   └── config.go               # 配置管理
│   ├── models/
│   │   └── task.go                 # 数据模型
│   ├── repository/
│   │   ├── postgres.go             # PostgreSQL仓储
│   │   └── redis.go                # Redis缓存
│   ├── service/
│   │   └── task_service.go         # 业务逻辑
│   ├── handler/
│   │   └── task_handler.go         # HTTP处理器
│   └── middleware/
│       ├── auth.go                 # JWT认证
│       ├── logging.go              # 日志中间件
│       └── metrics.go              # 指标中间件
├── pkg/
│   ├── logger/
│   │   └── logger.go               # 日志工具
│   └── tracing/
│       └── jaeger.go               # 追踪工具
├── deployments/
│   ├── docker/
│   │   ├── Dockerfile              # Docker镜像
│   │   └── docker-compose.yml      # 本地开发
│   ├── kubernetes/
│   │   ├── namespace.yaml          # 命名空间
│   │   ├── configmap.yaml          # 配置
│   │   ├── secret.yaml             # 密钥
│   │   ├── postgres.yaml           # 数据库
│   │   ├── redis.yaml              # 缓存
│   │   ├── deployment.yaml         # 应用部署
│   │   ├── service.yaml            # 服务
│   │   ├── ingress.yaml            # 路由
│   │   └── hpa.yaml                # 自动扩展
│   └── helm/
│       └── task-manager/           # Helm Chart
│           ├── Chart.yaml
│           ├── values.yaml
│           └── templates/
├── monitoring/
│   ├── prometheus/
│   │   └── prometheus.yaml         # Prometheus配置
│   └── grafana/
│       └── dashboard.json          # Grafana仪表板
├── .github/
│   └── workflows/
│       └── ci-cd.yaml              # CI/CD流水线
├── Makefile                        # 构建脚本
├── go.mod
├── go.sum
└── README.md
```

---

## 第一部分：应用程序代码

### 1.1 主应用程序

**`cmd/api/main.go`**

```go
package main

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/prometheus/client_golang/prometheus/promhttp"
    
    "task-manager/internal/config"
    "task-manager/internal/handler"
    "task-manager/internal/middleware"
    "task-manager/internal/repository"
    "task-manager/internal/service"
    "task-manager/pkg/logger"
    "task-manager/pkg/tracing"
)

func main() {
    // 1. 加载配置
    cfg := config.Load()
    
    // 2. 初始化日志
    log := logger.New(cfg.LogLevel)
    
    // 3. 初始化Jaeger追踪
    closer, err := tracing.InitJaeger(cfg.ServiceName, cfg.JaegerEndpoint)
    if err != nil {
        log.Fatal("Failed to initialize Jaeger", err)
    }
    defer closer.Close()
    
    // 4. 连接PostgreSQL
    pgRepo, err := repository.NewPostgresRepository(cfg.DatabaseURL)
    if err != nil {
        log.Fatal("Failed to connect to PostgreSQL", err)
    }
    defer pgRepo.Close()
    
    // 5. 连接Redis
    redisRepo := repository.NewRedisRepository(cfg.RedisURL)
    defer redisRepo.Close()
    
    // 6. 初始化服务层
    taskService := service.NewTaskService(pgRepo, redisRepo, log)
    
    // 7. 初始化处理器
    taskHandler := handler.NewTaskHandler(taskService, log)
    
    // 8. 配置Gin路由
    if cfg.Environment == "production" {
        gin.SetMode(gin.ReleaseMode)
    }
    router := gin.New()
    
    // 全局中间件
    router.Use(
        middleware.Logger(log),
        middleware.Recovery(log),
        middleware.Metrics(),
        middleware.Tracing(),
        gin.Recovery(),
    )
    
    // 健康检查
    router.GET("/health", func(c *gin.Context) {
        c.JSON(200, gin.H{
            "status": "healthy",
            "timestamp": time.Now().Unix(),
        })
    })
    
    router.GET("/ready", func(c *gin.Context) {
        // 检查数据库连接
        if err := pgRepo.Ping(); err != nil {
            c.JSON(503, gin.H{"status": "not ready", "error": "database unavailable"})
            return
        }
        c.JSON(200, gin.H{"status": "ready"})
    })
    
    // Prometheus指标
    router.GET("/metrics", gin.WrapH(promhttp.Handler()))
    
    // API路由
    v1 := router.Group("/api/v1")
    {
        // 公开路由
        v1.POST("/auth/login", taskHandler.Login)
        v1.POST("/auth/register", taskHandler.Register)
        
        // 受保护路由
        auth := v1.Group("")
        auth.Use(middleware.AuthRequired(cfg.JWTSecret))
        {
            auth.GET("/tasks", taskHandler.ListTasks)
            auth.GET("/tasks/:id", taskHandler.GetTask)
            auth.POST("/tasks", taskHandler.CreateTask)
            auth.PUT("/tasks/:id", taskHandler.UpdateTask)
            auth.DELETE("/tasks/:id", taskHandler.DeleteTask)
        }
    }
    
    // 9. 启动HTTP服务器
    server := &http.Server{
        Addr:           fmt.Sprintf(":%d", cfg.Port),
        Handler:        router,
        ReadTimeout:    15 * time.Second,
        WriteTimeout:   15 * time.Second,
        MaxHeaderBytes: 1 << 20,
    }
    
    // 优雅关闭
    go func() {
        log.Info(fmt.Sprintf("Starting server on port %d", cfg.Port))
        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatal("Server failed to start", err)
        }
    }()
    
    // 等待中断信号
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Info("Shutting down server...")
    
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := server.Shutdown(ctx); err != nil {
        log.Fatal("Server forced to shutdown", err)
    }
    
    log.Info("Server exited")
}
```

### 1.2 数据模型

**`internal/models/task.go`**

```go
package models

import (
    "time"
)

// Task represents a task in the system
type Task struct {
    ID          int64      `json:"id" db:"id"`
    UserID      int64      `json:"user_id" db:"user_id"`
    Title       string     `json:"title" db:"title" binding:"required,min=1,max=200"`
    Description string     `json:"description" db:"description"`
    Status      string     `json:"status" db:"status"` // pending, in_progress, completed
    Priority    int        `json:"priority" db:"priority"` // 1-5
    DueDate     *time.Time `json:"due_date,omitempty" db:"due_date"`
    CreatedAt   time.Time  `json:"created_at" db:"created_at"`
    UpdatedAt   time.Time  `json:"updated_at" db:"updated_at"`
}

// User represents a user in the system
type User struct {
    ID        int64     `json:"id" db:"id"`
    Email     string    `json:"email" db:"email" binding:"required,email"`
    Password  string    `json:"-" db:"password"` // 不返回给客户端
    Name      string    `json:"name" db:"name" binding:"required,min=1,max=100"`
    CreatedAt time.Time `json:"created_at" db:"created_at"`
    UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
}

// LoginRequest represents login credentials
type LoginRequest struct {
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required,min=6"`
}

// RegisterRequest represents registration data
type RegisterRequest struct {
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required,min=6"`
    Name     string `json:"name" binding:"required,min=1,max=100"`
}

// TaskFilter represents filtering options for tasks
type TaskFilter struct {
    UserID   int64
    Status   string
    Priority *int
    Limit    int
    Offset   int
}
```

### 1.3 数据库层

**`internal/repository/postgres.go`**

```go
package repository

import (
    "context"
    "database/sql"
    "fmt"
    "time"

    _ "github.com/lib/pq"
    
    "task-manager/internal/models"
)

type PostgresRepository struct {
    db *sql.DB
}

func NewPostgresRepository(dsn string) (*PostgresRepository, error) {
    db, err := sql.Open("postgres", dsn)
    if err != nil {
        return nil, fmt.Errorf("failed to open database: %w", err)
    }
    
    // 配置连接池
    db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(5)
    db.SetConnMaxLifetime(5 * time.Minute)
    
    // 测试连接
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := db.PingContext(ctx); err != nil {
        return nil, fmt.Errorf("failed to ping database: %w", err)
    }
    
    // 初始化数据库表
    if err := initSchema(db); err != nil {
        return nil, fmt.Errorf("failed to initialize schema: %w", err)
    }
    
    return &PostgresRepository{db: db}, nil
}

func initSchema(db *sql.DB) error {
    schema := `
    CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        email VARCHAR(255) UNIQUE NOT NULL,
        password VARCHAR(255) NOT NULL,
        name VARCHAR(100) NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE IF NOT EXISTS tasks (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        title VARCHAR(200) NOT NULL,
        description TEXT,
        status VARCHAR(20) NOT NULL DEFAULT 'pending',
        priority INTEGER DEFAULT 3 CHECK (priority >= 1 AND priority <= 5),
        due_date TIMESTAMP,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
    CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
    CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
    `
    
    _, err := db.Exec(schema)
    return err
}

func (r *PostgresRepository) Ping() error {
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()
    return r.db.PingContext(ctx)
}

func (r *PostgresRepository) Close() error {
    return r.db.Close()
}

// Task CRUD operations
func (r *PostgresRepository) CreateTask(ctx context.Context, task *models.Task) error {
    query := `
        INSERT INTO tasks (user_id, title, description, status, priority, due_date)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING id, created_at, updated_at
    `
    
    return r.db.QueryRowContext(
        ctx, query,
        task.UserID, task.Title, task.Description, task.Status, task.Priority, task.DueDate,
    ).Scan(&task.ID, &task.CreatedAt, &task.UpdatedAt)
}

func (r *PostgresRepository) GetTask(ctx context.Context, id, userID int64) (*models.Task, error) {
    var task models.Task
    query := `
        SELECT id, user_id, title, description, status, priority, due_date, created_at, updated_at
        FROM tasks
        WHERE id = $1 AND user_id = $2
    `
    
    err := r.db.QueryRowContext(ctx, query, id, userID).Scan(
        &task.ID, &task.UserID, &task.Title, &task.Description,
        &task.Status, &task.Priority, &task.DueDate,
        &task.CreatedAt, &task.UpdatedAt,
    )
    
    if err == sql.ErrNoRows {
        return nil, fmt.Errorf("task not found")
    }
    
    return &task, err
}

func (r *PostgresRepository) ListTasks(ctx context.Context, filter models.TaskFilter) ([]*models.Task, error) {
    query := `
        SELECT id, user_id, title, description, status, priority, due_date, created_at, updated_at
        FROM tasks
        WHERE user_id = $1
    `
    args := []interface{}{filter.UserID}
    argCount := 1
    
    if filter.Status != "" {
        argCount++
        query += fmt.Sprintf(" AND status = $%d", argCount)
        args = append(args, filter.Status)
    }
    
    if filter.Priority != nil {
        argCount++
        query += fmt.Sprintf(" AND priority = $%d", argCount)
        args = append(args, *filter.Priority)
    }
    
    query += " ORDER BY created_at DESC"
    
    if filter.Limit > 0 {
        argCount++
        query += fmt.Sprintf(" LIMIT $%d", argCount)
        args = append(args, filter.Limit)
    }
    
    if filter.Offset > 0 {
        argCount++
        query += fmt.Sprintf(" OFFSET $%d", argCount)
        args = append(args, filter.Offset)
    }
    
    rows, err := r.db.QueryContext(ctx, query, args...)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var tasks []*models.Task
    for rows.Next() {
        var task models.Task
        if err := rows.Scan(
            &task.ID, &task.UserID, &task.Title, &task.Description,
            &task.Status, &task.Priority, &task.DueDate,
            &task.CreatedAt, &task.UpdatedAt,
        ); err != nil {
            return nil, err
        }
        tasks = append(tasks, &task)
    }
    
    return tasks, rows.Err()
}

func (r *PostgresRepository) UpdateTask(ctx context.Context, task *models.Task) error {
    query := `
        UPDATE tasks
        SET title = $1, description = $2, status = $3, priority = $4, due_date = $5, updated_at = CURRENT_TIMESTAMP
        WHERE id = $6 AND user_id = $7
        RETURNING updated_at
    `
    
    return r.db.QueryRowContext(
        ctx, query,
        task.Title, task.Description, task.Status, task.Priority, task.DueDate, task.ID, task.UserID,
    ).Scan(&task.UpdatedAt)
}

func (r *PostgresRepository) DeleteTask(ctx context.Context, id, userID int64) error {
    query := `DELETE FROM tasks WHERE id = $1 AND user_id = $2`
    result, err := r.db.ExecContext(ctx, query, id, userID)
    if err != nil {
        return err
    }
    
    rows, err := result.RowsAffected()
    if err != nil {
        return err
    }
    
    if rows == 0 {
        return fmt.Errorf("task not found")
    }
    
    return nil
}

// User operations
func (r *PostgresRepository) CreateUser(ctx context.Context, user *models.User) error {
    query := `
        INSERT INTO users (email, password, name)
        VALUES ($1, $2, $3)
        RETURNING id, created_at, updated_at
    `
    
    return r.db.QueryRowContext(ctx, query, user.Email, user.Password, user.Name).
        Scan(&user.ID, &user.CreatedAt, &user.UpdatedAt)
}

func (r *PostgresRepository) GetUserByEmail(ctx context.Context, email string) (*models.User, error) {
    var user models.User
    query := `
        SELECT id, email, password, name, created_at, updated_at
        FROM users
        WHERE email = $1
    `
    
    err := r.db.QueryRowContext(ctx, query, email).Scan(
        &user.ID, &user.Email, &user.Password, &user.Name, &user.CreatedAt, &user.UpdatedAt,
    )
    
    if err == sql.ErrNoRows {
        return nil, fmt.Errorf("user not found")
    }
    
    return &user, err
}
```

**`internal/repository/redis.go`**

```go
package repository

import (
    "context"
    "encoding/json"
    "fmt"
    "time"

    "github.com/redis/go-redis/v9"
    
    "task-manager/internal/models"
)

type RedisRepository struct {
    client *redis.Client
}

func NewRedisRepository(addr string) *RedisRepository {
    client := redis.NewClient(&redis.Options{
        Addr:         addr,
        Password:     "",
        DB:           0,
        DialTimeout:  5 * time.Second,
        ReadTimeout:  3 * time.Second,
        WriteTimeout: 3 * time.Second,
        PoolSize:     10,
    })
    
    return &RedisRepository{client: client}
}

func (r *RedisRepository) Close() error {
    return r.client.Close()
}

func (r *RedisRepository) SetTask(ctx context.Context, task *models.Task, ttl time.Duration) error {
    key := fmt.Sprintf("task:%d", task.ID)
    data, err := json.Marshal(task)
    if err != nil {
        return err
    }
    
    return r.client.Set(ctx, key, data, ttl).Err()
}

func (r *RedisRepository) GetTask(ctx context.Context, id int64) (*models.Task, error) {
    key := fmt.Sprintf("task:%d", id)
    data, err := r.client.Get(ctx, key).Bytes()
    if err == redis.Nil {
        return nil, fmt.Errorf("cache miss")
    }
    if err != nil {
        return nil, err
    }
    
    var task models.Task
    if err := json.Unmarshal(data, &task); err != nil {
        return nil, err
    }
    
    return &task, nil
}

func (r *RedisRepository) DeleteTask(ctx context.Context, id int64) error {
    key := fmt.Sprintf("task:%d", id)
    return r.client.Del(ctx, key).Err()
}

func (r *RedisRepository) Ping() error {
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()
    return r.client.Ping(ctx).Err()
}
```

### 1.4 服务层

**`internal/service/task_service.go`**

```go
package service

import (
    "context"
    "fmt"
    "time"

    "golang.org/x/crypto/bcrypt"
    "github.com/golang-jwt/jwt/v5"
    
    "task-manager/internal/models"
    "task-manager/internal/repository"
    "task-manager/pkg/logger"
)

type TaskService struct {
    pgRepo    *repository.PostgresRepository
    redisRepo *repository.RedisRepository
    log       *logger.Logger
}

func NewTaskService(pg *repository.PostgresRepository, redis *repository.RedisRepository, log *logger.Logger) *TaskService {
    return &TaskService{
        pgRepo:    pg,
        redisRepo: redis,
        log:       log,
    }
}

// Task operations with caching
func (s *TaskService) CreateTask(ctx context.Context, task *models.Task) error {
    if task.Status == "" {
        task.Status = "pending"
    }
    if task.Priority == 0 {
        task.Priority = 3
    }
    
    if err := s.pgRepo.CreateTask(ctx, task); err != nil {
        return err
    }
    
    // 异步缓存
    go func() {
        ctx := context.Background()
        if err := s.redisRepo.SetTask(ctx, task, 10*time.Minute); err != nil {
            s.log.Warn("Failed to cache task", err)
        }
    }()
    
    return nil
}

func (s *TaskService) GetTask(ctx context.Context, id, userID int64) (*models.Task, error) {
    // 先查缓存
    task, err := s.redisRepo.GetTask(ctx, id)
    if err == nil && task.UserID == userID {
        s.log.Debug(fmt.Sprintf("Cache hit for task %d", id))
        return task, nil
    }
    
    // 缓存未命中，查数据库
    task, err = s.pgRepo.GetTask(ctx, id, userID)
    if err != nil {
        return nil, err
    }
    
    // 异步更新缓存
    go func() {
        ctx := context.Background()
        if err := s.redisRepo.SetTask(ctx, task, 10*time.Minute); err != nil {
            s.log.Warn("Failed to cache task", err)
        }
    }()
    
    return task, nil
}

func (s *TaskService) ListTasks(ctx context.Context, filter models.TaskFilter) ([]*models.Task, error) {
    return s.pgRepo.ListTasks(ctx, filter)
}

func (s *TaskService) UpdateTask(ctx context.Context, task *models.Task) error {
    if err := s.pgRepo.UpdateTask(ctx, task); err != nil {
        return err
    }
    
    // 删除缓存
    go func() {
        ctx := context.Background()
        if err := s.redisRepo.DeleteTask(ctx, task.ID); err != nil {
            s.log.Warn("Failed to delete task cache", err)
        }
    }()
    
    return nil
}

func (s *TaskService) DeleteTask(ctx context.Context, id, userID int64) error {
    if err := s.pgRepo.DeleteTask(ctx, id, userID); err != nil {
        return err
    }
    
    // 删除缓存
    go func() {
        ctx := context.Background()
        if err := s.redisRepo.DeleteTask(ctx, id); err != nil {
            s.log.Warn("Failed to delete task cache", err)
        }
    }()
    
    return nil
}

// Authentication
func (s *TaskService) Register(ctx context.Context, req models.RegisterRequest) (*models.User, error) {
    // 加密密码
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        return nil, err
    }
    
    user := &models.User{
        Email:    req.Email,
        Password: string(hashedPassword),
        Name:     req.Name,
    }
    
    if err := s.pgRepo.CreateUser(ctx, user); err != nil {
        return nil, err
    }
    
    return user, nil
}

func (s *TaskService) Login(ctx context.Context, req models.LoginRequest, jwtSecret string) (string, error) {
    user, err := s.pgRepo.GetUserByEmail(ctx, req.Email)
    if err != nil {
        return "", fmt.Errorf("invalid credentials")
    }
    
    // 验证密码
    if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password)); err != nil {
        return "", fmt.Errorf("invalid credentials")
    }
    
    // 生成JWT
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
        "user_id": user.ID,
        "email":   user.Email,
        "exp":     time.Now().Add(24 * time.Hour).Unix(),
    })
    
    tokenString, err := token.SignedString([]byte(jwtSecret))
    if err != nil {
        return "", err
    }
    
    return tokenString, nil
}
```

### 1.5 HTTP处理器

**`internal/handler/task_handler.go`**

```go
package handler

import (
    "net/http"
    "strconv"

    "github.com/gin-gonic/gin"
    
    "task-manager/internal/config"
    "task-manager/internal/models"
    "task-manager/internal/service"
    "task-manager/pkg/logger"
)

type TaskHandler struct {
    service *service.TaskService
    log     *logger.Logger
}

func NewTaskHandler(service *service.TaskService, log *logger.Logger) *TaskHandler {
    return &TaskHandler{
        service: service,
        log:     log,
    }
}

// Register handles user registration
func (h *TaskHandler) Register(c *gin.Context) {
    var req models.RegisterRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    user, err := h.service.Register(c.Request.Context(), req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusCreated, user)
}

// Login handles user login
func (h *TaskHandler) Login(c *gin.Context) {
    var req models.LoginRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    cfg := config.Load()
    token, err := h.service.Login(c.Request.Context(), req, cfg.JWTSecret)
    if err != nil {
        c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{"token": token})
}

// CreateTask creates a new task
func (h *TaskHandler) CreateTask(c *gin.Context) {
    var task models.Task
    if err := c.ShouldBindJSON(&task); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    // 从JWT中获取user_id
    userID, _ := c.Get("user_id")
    task.UserID = userID.(int64)
    
    if err := h.service.CreateTask(c.Request.Context(), &task); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusCreated, task)
}

// GetTask retrieves a single task
func (h *TaskHandler) GetTask(c *gin.Context) {
    id, err := strconv.ParseInt(c.Param("id"), 10, 64)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid task id"})
        return
    }
    
    userID, _ := c.Get("user_id")
    task, err := h.service.GetTask(c.Request.Context(), id, userID.(int64))
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, task)
}

// ListTasks retrieves all tasks for the user
func (h *TaskHandler) ListTasks(c *gin.Context) {
    userID, _ := c.Get("user_id")
    
    filter := models.TaskFilter{
        UserID: userID.(int64),
        Status: c.Query("status"),
        Limit:  20,
        Offset: 0,
    }
    
    if priority := c.Query("priority"); priority != "" {
        p, err := strconv.Atoi(priority)
        if err == nil {
            filter.Priority = &p
        }
    }
    
    if limit := c.Query("limit"); limit != "" {
        l, err := strconv.Atoi(limit)
        if err == nil && l > 0 && l <= 100 {
            filter.Limit = l
        }
    }
    
    if offset := c.Query("offset"); offset != "" {
        o, err := strconv.Atoi(offset)
        if err == nil && o >= 0 {
            filter.Offset = o
        }
    }
    
    tasks, err := h.service.ListTasks(c.Request.Context(), filter)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{"tasks": tasks, "count": len(tasks)})
}

// UpdateTask updates an existing task
func (h *TaskHandler) UpdateTask(c *gin.Context) {
    id, err := strconv.ParseInt(c.Param("id"), 10, 64)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid task id"})
        return
    }
    
    var task models.Task
    if err := c.ShouldBindJSON(&task); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    userID, _ := c.Get("user_id")
    task.ID = id
    task.UserID = userID.(int64)
    
    if err := h.service.UpdateTask(c.Request.Context(), &task); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, task)
}

// DeleteTask deletes a task
func (h *TaskHandler) DeleteTask(c *gin.Context) {
    id, err := strconv.ParseInt(c.Param("id"), 10, 64)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid task id"})
        return
    }
    
    userID, _ := c.Get("user_id")
    if err := h.service.DeleteTask(c.Request.Context(), id, userID.(int64)); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{"message": "task deleted successfully"})
}
```

### 1.6 中间件

**`internal/middleware/auth.go`**

```go
package middleware

import (
    "net/http"
    "strings"

    "github.com/gin-gonic/gin"
    "github.com/golang-jwt/jwt/v5"
)

func AuthRequired(jwtSecret string) gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "missing authorization header"})
            c.Abort()
            return
        }
        
        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
        if tokenString == authHeader {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid authorization header format"})
            c.Abort()
            return
        }
        
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
            return []byte(jwtSecret), nil
        })
        
        if err != nil || !token.Valid {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid token"})
            c.Abort()
            return
        }
        
        claims, ok := token.Claims.(jwt.MapClaims)
        if !ok {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid token claims"})
            c.Abort()
            return
        }
        
        c.Set("user_id", int64(claims["user_id"].(float64)))
        c.Set("email", claims["email"].(string))
        
        c.Next()
    }
}
```

**`internal/middleware/metrics.go`**

```go
package middleware

import (
    "strconv"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    httpRequestsTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total number of HTTP requests",
        },
        []string{"method", "path", "status"},
    )
    
    httpRequestDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_request_duration_seconds",
            Help:    "HTTP request duration in seconds",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method", "path"},
    )
)

func Metrics() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        
        c.Next()
        
        duration := time.Since(start).Seconds()
        status := strconv.Itoa(c.Writer.Status())
        
        httpRequestsTotal.WithLabelValues(c.Request.Method, c.FullPath(), status).Inc()
        httpRequestDuration.WithLabelValues(c.Request.Method, c.FullPath()).Observe(duration)
    }
}
```

### 1.7 配置管理

**`internal/config/config.go`**

```go
package config

import (
    "os"
    "strconv"
)

type Config struct {
    Environment    string
    Port           int
    DatabaseURL    string
    RedisURL       string
    JWTSecret      string
    JaegerEndpoint string
    ServiceName    string
    LogLevel       string
}

func Load() *Config {
    return &Config{
        Environment:    getEnv("ENVIRONMENT", "development"),
        Port:           getEnvAsInt("PORT", 8080),
        DatabaseURL:    getEnv("DATABASE_URL", "postgres://postgres:postgres@localhost:5432/taskdb?sslmode=disable"),
        RedisURL:       getEnv("REDIS_URL", "localhost:6379"),
        JWTSecret:      getEnv("JWT_SECRET", "my-secret-key-change-in-production"),
        JaegerEndpoint: getEnv("JAEGER_ENDPOINT", "http://localhost:14268/api/traces"),
        ServiceName:    getEnv("SERVICE_NAME", "task-manager"),
        LogLevel:       getEnv("LOG_LEVEL", "info"),
    }
}

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func getEnvAsInt(key string, defaultValue int) int {
    if value := os.Getenv(key); value != "" {
        if intValue, err := strconv.Atoi(value); err == nil {
            return intValue
        }
    }
    return defaultValue
}
```

---

## 第二部分：容器化配置

### 2.1 Dockerfile

**`deployments/docker/Dockerfile`**

```dockerfile
# ========== 多阶段构建 Dockerfile ==========

# 阶段1: 构建阶段
FROM golang:1.25.3-alpine AS builder

# 安装必要工具
RUN apk add --no-cache git ca-certificates tzdata

# 设置工作目录
WORKDIR /build

# 复制依赖文件
COPY go.mod go.sum ./
RUN go mod download

# 复制源代码
COPY . .

# 构建应用（静态编译，禁用CGO）
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
    -ldflags="-w -s -X main.version=$(git describe --tags --always)" \
    -o task-manager \
    ./cmd/api

# 阶段2: 运行阶段
FROM alpine:latest

# 安装CA证书和时区数据
RUN apk --no-cache add ca-certificates tzdata

# 创建非root用户
RUN addgroup -g 1000 appgroup && \
    adduser -D -u 1000 -G appgroup appuser

# 设置工作目录
WORKDIR /app

# 从构建阶段复制二进制文件
COPY --from=builder /build/task-manager .

# 修改所有者
RUN chown -R appuser:appgroup /app

# 切换到非root用户
USER appuser

# 暴露端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1

# 启动应用
ENTRYPOINT ["./task-manager"]
```

### 2.2 .dockerignore

**`.dockerignore`**

```text
# Git
.git
.gitignore

# IDE
.vscode
.idea
*.swp
*.swo

# 构建产物
bin/
dist/
*.exe

# 测试
*_test.go
coverage.out
coverage.html

# 文档
*.md
docs/

# 部署文件
deployments/kubernetes/
deployments/helm/
.github/

# 环境文件
.env
.env.local

# 临时文件
tmp/
temp/
```

### 2.3 Docker Compose (本地开发)

**`deployments/docker/docker-compose.yml`**

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    container_name: taskdb
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: taskdb
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: taskredis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5

  jaeger:
    image: jaegertracing/all-in-one:latest
    container_name: jaeger
    ports:
      - "5775:5775/udp"
      - "6831:6831/udp"
      - "6832:6832/udp"
      - "5778:5778"
      - "16686:16686"
      - "14268:14268"
      - "14250:14250"
      - "9411:9411"
    environment:
      COLLECTOR_ZIPKIN_HOST_PORT: ":9411"

  task-manager:
    build:
      context: ../..
      dockerfile: deployments/docker/Dockerfile
    container_name: task-manager
    ports:
      - "8080:8080"
    environment:
      ENVIRONMENT: development
      PORT: 8080
      DATABASE_URL: postgres://postgres:postgres@postgres:5432/taskdb?sslmode=disable
      REDIS_URL: redis:6379
      JWT_SECRET: my-development-secret-key
      JAEGER_ENDPOINT: http://jaeger:14268/api/traces
      SERVICE_NAME: task-manager
      LOG_LEVEL: debug
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      jaeger:
        condition: service_started
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
```

---

## 第三部分：Kubernetes部署

### 3.1 命名空间

**`deployments/kubernetes/namespace.yaml`**

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: task-manager
  labels:
    name: task-manager
    environment: production
```

### 3.2 ConfigMap

**`deployments/kubernetes/configmap.yaml`**

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: task-manager-config
  namespace: task-manager
data:
  ENVIRONMENT: "production"
  PORT: "8080"
  LOG_LEVEL: "info"
  SERVICE_NAME: "task-manager"
  DATABASE_URL: "postgres://postgres:$(POSTGRES_PASSWORD)@postgres-service:5432/taskdb?sslmode=disable"
  REDIS_URL: "redis-service:6379"
  JAEGER_ENDPOINT: "http://jaeger-collector:14268/api/traces"
```

### 3.3 Secret

**`deployments/kubernetes/secret.yaml`**

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: task-manager-secrets
  namespace: task-manager
type: Opaque
stringData:
  POSTGRES_PASSWORD: "your-secure-postgres-password"
  JWT_SECRET: "your-secure-jwt-secret-key-min-32-chars"
```

### 3.4 PostgreSQL部署

**`deployments/kubernetes/postgres.yaml`**

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc
  namespace: task-manager
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
  namespace: task-manager
spec:
  serviceName: postgres-service
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:15-alpine
        ports:
        - containerPort: 5432
          name: postgres
        env:
        - name: POSTGRES_USER
          value: "postgres"
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: task-manager-secrets
              key: POSTGRES_PASSWORD
        - name: POSTGRES_DB
          value: "taskdb"
        - name: PGDATA
          value: /var/lib/postgresql/data/pgdata
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          exec:
            command:
            - pg_isready
            - -U
            - postgres
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          exec:
            command:
            - pg_isready
            - -U
            - postgres
          initialDelaySeconds: 5
          periodSeconds: 5
  volumeClaimTemplates:
  - metadata:
      name: postgres-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi
---
apiVersion: v1
kind: Service
metadata:
  name: postgres-service
  namespace: task-manager
spec:
  selector:
    app: postgres
  ports:
  - port: 5432
    targetPort: 5432
  clusterIP: None
```

### 3.5 Redis部署

**`deployments/kubernetes/redis.yaml`**

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: redis
  namespace: task-manager
spec:
  serviceName: redis-service
  replicas: 1
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
    spec:
      containers:
      - name: redis
        image: redis:7-alpine
        ports:
        - containerPort: 6379
          name: redis
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          exec:
            command:
            - redis-cli
            - ping
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          exec:
            command:
            - redis-cli
            - ping
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: redis-service
  namespace: task-manager
spec:
  selector:
    app: redis
  ports:
  - port: 6379
    targetPort: 6379
  clusterIP: None
```

### 3.6 应用程序部署

**`deployments/kubernetes/deployment.yaml`**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: task-manager
  namespace: task-manager
  labels:
    app: task-manager
    version: v1
spec:
  replicas: 3
  selector:
    matchLabels:
      app: task-manager
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    metadata:
      labels:
        app: task-manager
        version: v1
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      containers:
      - name: task-manager
        image: your-registry/task-manager:latest
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
          name: http
          protocol: TCP
        envFrom:
        - configMapRef:
            name: task-manager-config
        env:
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: task-manager-secrets
              key: POSTGRES_PASSWORD
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: task-manager-secrets
              key: JWT_SECRET
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 15
          periodSeconds: 10
          timeoutSeconds: 3
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
```

### 3.7 Service

**`deployments/kubernetes/service.yaml`**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: task-manager-service
  namespace: task-manager
  labels:
    app: task-manager
spec:
  type: ClusterIP
  selector:
    app: task-manager
  ports:
  - name: http
    port: 80
    targetPort: 8080
    protocol: TCP
  sessionAffinity: None
```

### 3.8 Ingress

**`deployments/kubernetes/ingress.yaml`**

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: task-manager-ingress
  namespace: task-manager
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/rate-limit: "100"
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - task-manager.example.com
    secretName: task-manager-tls
  rules:
  - host: task-manager.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: task-manager-service
            port:
              number: 80
```

### 3.9 HPA (水平自动扩展)

**`deployments/kubernetes/hpa.yaml`**

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: task-manager-hpa
  namespace: task-manager
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: task-manager
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15
      - type: Pods
        value: 2
        periodSeconds: 15
      selectPolicy: Max
```

---

## 第四部分：CI/CD流水线

### 4.1 GitHub Actions

**`.github/workflows/ci-cd.yaml`**

```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/task-manager

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: testdb
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25.3'

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Download dependencies
        run: go mod download

      - name: Run tests
        env:
          DATABASE_URL: postgres://postgres:postgres@localhost:5432/testdb?sslmode=disable
          REDIS_URL: localhost:6379
        run: go test -v -race -coverprofile=coverage.out ./...

      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage.out

  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25.3'

      - name: golangci-lint
        uses: golangci/golangci-lint-action@v4
        with:
          version: latest

  build:
    name: Build and Push
    needs: [test, lint]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=semver,pattern={{version}}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./deployments/docker/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to Kubernetes
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure kubectl
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG }}

      - name: Deploy to Kubernetes
        run: |
          kubectl apply -f deployments/kubernetes/namespace.yaml
          kubectl apply -f deployments/kubernetes/configmap.yaml
          kubectl apply -f deployments/kubernetes/secret.yaml
          kubectl apply -f deployments/kubernetes/postgres.yaml
          kubectl apply -f deployments/kubernetes/redis.yaml
          kubectl apply -f deployments/kubernetes/deployment.yaml
          kubectl apply -f deployments/kubernetes/service.yaml
          kubectl apply -f deployments/kubernetes/ingress.yaml
          kubectl apply -f deployments/kubernetes/hpa.yaml

      - name: Verify deployment
        run: |
          kubectl rollout status deployment/task-manager -n task-manager
          kubectl get pods -n task-manager
```

**CI/CD流水线可视化**:

```mermaid
graph LR
    A[📝 代码推送] --> B[🔍 Checkout]
    B --> C{分支检查}
    
    C -->|PR| D1[🧪 测试]
    C -->|main分支| D1
    
    D1 --> D2[📋 代码质量]
    D2 --> D3[🔧 构建]
    
    C -->|非main| END1[结束]
    
    D3 --> E{构建成功?}
    E -->|失败| F1[❌ 通知失败]
    E -->|成功| F2[📦 推送镜像]
    
    F2 --> G[🚀 部署K8s]
    G --> H[✅ 健康检查]
    H --> I[✅ 部署完成]
    
    F1 --> END2[结束]
    
    style A fill:#e1f5ff
    style D1 fill:#fff4e1
    style D2 fill:#fff4e1
    style D3 fill:#e1ffe1
    style F2 fill:#e1ffe1
    style G fill:#ffe1e1
    style I fill:#e1ffe1
    style F1 fill:#ffe1e1
```

**流水线时序图**:

```mermaid
gantt
    title CI/CD Pipeline Execution Timeline
    dateFormat mm:ss
    axisFormat %M:%S
    
    section 准备
    Checkout Code       :done, prep1, 00:00, 10s
    Cache Dependencies  :done, prep2, after prep1, 15s
    
    section 质量检查
    Linters             :active, qa1, after prep2, 30s
    Unit Tests          :qa2, after qa1, 45s
    Integration Tests   :qa3, after qa2, 60s
    
    section 构建
    Build Binary        :build1, after qa3, 40s
    Build Docker Image  :build2, after build1, 50s
    Scan Image          :build3, after build2, 20s
    
    section 部署
    Push to Registry    :deploy1, after build3, 20s
    Apply K8s Manifests :deploy2, after deploy1, 30s
    Health Check        :deploy3, after deploy2, 15s
    Smoke Tests         :deploy4, after deploy3, 25s
```

### 4.2 Makefile

**`Makefile`**

```makefile
.PHONY: help build test lint run docker-build docker-run k8s-deploy k8s-delete clean

# Variables
APP_NAME=task-manager
DOCKER_IMAGE=task-manager:latest
NAMESPACE=task-manager

help: ## Display this help
 @awk 'BEGIN {FS = ":.*##"; printf "\nUsage:\n  make \033[36m<target>\033[0m\n"} /^[a-zA-Z_-]+:.*?##/ { printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2 } /^##@/ { printf "\n\033[1m%s\033[0m\n", substr($$0, 5) } ' $(MAKEFILE_LIST)

##@ Development

build: ## Build the application
 go build -o bin/$(APP_NAME) ./cmd/api

test: ## Run tests
 go test -v -race -coverprofile=coverage.out ./...

lint: ## Run linters
 golangci-lint run ./...

run: ## Run the application locally
 go run ./cmd/api/main.go

##@ Docker

docker-build: ## Build Docker image
 docker build -t $(DOCKER_IMAGE) -f deployments/docker/Dockerfile .

docker-run: ## Run Docker container
 docker-compose -f deployments/docker/docker-compose.yml up -d

docker-stop: ## Stop Docker container
 docker-compose -f deployments/docker/docker-compose.yml down

##@ Kubernetes

k8s-deploy: ## Deploy to Kubernetes
 kubectl apply -f deployments/kubernetes/namespace.yaml
 kubectl apply -f deployments/kubernetes/configmap.yaml
 kubectl apply -f deployments/kubernetes/secret.yaml
 kubectl apply -f deployments/kubernetes/postgres.yaml
 kubectl apply -f deployments/kubernetes/redis.yaml
 kubectl apply -f deployments/kubernetes/deployment.yaml
 kubectl apply -f deployments/kubernetes/service.yaml
 kubectl apply -f deployments/kubernetes/ingress.yaml
 kubectl apply -f deployments/kubernetes/hpa.yaml

k8s-delete: ## Delete from Kubernetes
 kubectl delete namespace $(NAMESPACE)

k8s-logs: ## View application logs
 kubectl logs -f -n $(NAMESPACE) -l app=$(APP_NAME)

k8s-status: ## Check deployment status
 kubectl get all -n $(NAMESPACE)

##@ Cleanup

clean: ## Clean build artifacts
 rm -rf bin/
 rm -f coverage.out
```

---

## 第五部分：可观测性

### 5.1 Prometheus监控

**`monitoring/prometheus/prometheus.yaml`**

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config
  namespace: task-manager
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s
      evaluation_interval: 15s

    scrape_configs:
      - job_name: 'task-manager'
        kubernetes_sd_configs:
          - role: pod
            namespaces:
              names:
                - task-manager
        relabel_configs:
          - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
            action: keep
            regex: true
          - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
            action: replace
            target_label: __metrics_path__
            regex: (.+)
          - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
            action: replace
            regex: ([^:]+)(?::\d+)?;(\d+)
            replacement: $1:$2
            target_label: __address__
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus
  namespace: task-manager
spec:
  replicas: 1
  selector:
    matchLabels:
      app: prometheus
  template:
    metadata:
      labels:
        app: prometheus
    spec:
      containers:
      - name: prometheus
        image: prom/prometheus:latest
        args:
          - '--config.file=/etc/prometheus/prometheus.yml'
          - '--storage.tsdb.path=/prometheus'
        ports:
        - containerPort: 9090
        volumeMounts:
        - name: prometheus-config
          mountPath: /etc/prometheus
        - name: prometheus-storage
          mountPath: /prometheus
      volumes:
      - name: prometheus-config
        configMap:
          name: prometheus-config
      - name: prometheus-storage
        emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: prometheus
  namespace: task-manager
spec:
  selector:
    app: prometheus
  ports:
  - port: 9090
    targetPort: 9090
```

### 5.2 Grafana仪表板

**`monitoring/grafana/dashboard.json`** (简化示例)

```json
{
  "dashboard": {
    "title": "Task Manager Metrics",
    "panels": [
      {
        "title": "HTTP Requests per Second",
        "targets": [
          {
            "expr": "rate(http_requests_total[1m])"
          }
        ]
      },
      {
        "title": "HTTP Request Duration (p95)",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))"
          }
        ]
      },
      {
        "title": "Active Pods",
        "targets": [
          {
            "expr": "count(kube_pod_status_phase{namespace=\"task-manager\", phase=\"Running\"})"
          }
        ]
      }
    ]
  }
}
```

### 5.3 Jaeger分布式追踪

**`pkg/tracing/jaeger.go`**

```go
package tracing

import (
    "io"

    "github.com/uber/jaeger-client-go"
    "github.com/uber/jaeger-client-go/config"
)

func InitJaeger(serviceName, endpoint string) (io.Closer, error) {
    cfg := config.Configuration{
        ServiceName: serviceName,
        Sampler: &config.SamplerConfig{
            Type:  jaeger.SamplerTypeConst,
            Param: 1,
        },
        Reporter: &config.ReporterConfig{
            LogSpans:          true,
            CollectorEndpoint: endpoint,
        },
    }

    tracer, closer, err := cfg.NewTracer()
    if err != nil {
        return nil, err
    }

    opentracing.SetGlobalTracer(tracer)
    return closer, nil
}
```

---

## 第六部分：Helm Chart

### 6.1 Chart结构

```text
deployments/helm/task-manager/
├── Chart.yaml
├── values.yaml
├── templates/
│   ├── deployment.yaml
│   ├── service.yaml
│   ├── ingress.yaml
│   ├── configmap.yaml
│   ├── secret.yaml
│   ├── hpa.yaml
│   └── _helpers.tpl
└── .helmignore
```

### 6.2 Chart.yaml

```yaml
apiVersion: v2
name: task-manager
description: A cloud-native task management system
version: 1.0.0
appVersion: "1.0.0"
type: application
keywords:
  - task-manager
  - go
  - cloud-native
home: https://github.com/your-org/task-manager
maintainers:
  - name: Your Name
    email: your.email@example.com
```

### 6.3 values.yaml

```yaml
replicaCount: 3

image:
  repository: your-registry/task-manager
  pullPolicy: IfNotPresent
  tag: "latest"

service:
  type: ClusterIP
  port: 80
  targetPort: 8080

ingress:
  enabled: true
  className: nginx
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
  hosts:
    - host: task-manager.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: task-manager-tls
      hosts:
        - task-manager.example.com

resources:
  limits:
    cpu: 200m
    memory: 256Mi
  requests:
    cpu: 100m
    memory: 128Mi

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

postgresql:
  enabled: true
  auth:
    username: postgres
    password: postgres
    database: taskdb
  persistence:
    size: 10Gi

redis:
  enabled: true
  architecture: standalone
  auth:
    enabled: false
```

### 6.4 部署模板

**`deployments/helm/task-manager/templates/deployment.yaml`** (简化)

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "task-manager.fullname" . }}
  labels:
    {{- include "task-manager.labels" . | nindent 4 }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      {{- include "task-manager.selectorLabels" . | nindent 6 }}
  template:
    metadata:
      labels:
        {{- include "task-manager.selectorLabels" . | nindent 8 }}
    spec:
      containers:
      - name: {{ .Chart.Name }}
        image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
        imagePullPolicy: {{ .Values.image.pullPolicy }}
        ports:
        - name: http
          containerPort: {{ .Values.service.targetPort }}
        resources:
          {{- toYaml .Values.resources | nindent 10 }}
```

---

## 第七部分：部署指南

### 7.1 前置要求

- Docker 20+
- Kubernetes 1.25+
- kubectl
- Helm 3+ (可选)
- Go 1.25.3+ (本地开发)

### 7.2 本地开发

```bash
# 1. 克隆代码
git clone https://github.com/your-org/task-manager.git
cd task-manager

# 2. 安装依赖
go mod download

# 3. 启动本地环境 (Docker Compose)
make docker-run

# 4. 运行应用
make run

# 5. 测试API
curl http://localhost:8080/health
```

### 7.3 Kubernetes部署

```bash
# 1. 创建命名空间和资源
make k8s-deploy

# 2. 检查状态
make k8s-status

# 3. 查看日志
make k8s-logs

# 4. 端口转发测试
kubectl port-forward -n task-manager service/task-manager-service 8080:80

# 5. 清理资源
make k8s-delete
```

### 7.4 使用Helm部署

```bash
# 1. 添加依赖
cd deployments/helm/task-manager
helm dependency update

# 2. 安装
helm install task-manager . -n task-manager --create-namespace

# 3. 升级
helm upgrade task-manager . -n task-manager

# 4. 卸载
helm uninstall task-manager -n task-manager
```

### 7.5 验证部署

```bash
# 1. 检查所有资源
kubectl get all -n task-manager

# 2. 检查Pod状态
kubectl get pods -n task-manager -w

# 3. 检查HPA
kubectl get hpa -n task-manager

# 4. 查看Prometheus指标
kubectl port-forward -n task-manager svc/prometheus 9090:9090

# 5. 访问Jaeger UI
kubectl port-forward -n task-manager svc/jaeger 16686:16686
```

---

## 第八部分：最佳实践总结

### 代码层面

1. **配置外部化**: 使用环境变量和ConfigMap
2. **优雅关闭**: 处理SIGTERM信号
3. **健康检查**: 实现 `/health` 和 `/ready` 端点
4. **结构化日志**: 使用JSON格式日志
5. **错误处理**: 统一错误响应格式

### 容器层面

1. **多阶段构建**: 减小镜像体积
2. **非root用户**: 提升安全性
3. **健康检查**: Dockerfile HEALTHCHECK指令
4. **资源限制**: 设置CPU和内存限制
5. **镜像标签**: 使用语义化版本

### Kubernetes层面

1. **资源配额**: 设置requests和limits
2. **探针配置**: liveness和readiness探针
3. **滚动更新**: 零停机部署
4. **HPA**: 自动水平扩缩容
5. **持久化**: 使用StatefulSet和PVC

### 运维层面

1. **监控**: Prometheus指标采集
2. **日志**: 集中式日志收集
3. **追踪**: 分布式链路追踪
4. **备份**: 定期备份数据库
5. **CI/CD**: 自动化测试和部署

---

## 🎯 总结

本项目展示了一个**生产级云原生应用**的完整实现，涵盖：

✅ **完整的Go应用代码** (3层架构)  
✅ **Docker容器化** (多阶段构建)  
✅ **Kubernetes完整配置** (10+个YAML文件)  
✅ **CI/CD自动化** (GitHub Actions)  
✅ **可观测性** (Prometheus + Grafana + Jaeger)  
✅ **Helm Chart** (可复用部署)  
✅ **生产最佳实践** (安全、性能、可维护性)

### 核心价值

1. **端到端参考**: 从代码到部署的完整流程
2. **最佳实践**: 遵循云原生12要素
3. **生产就绪**: 包含监控、日志、追踪
4. **可扩展性**: HPA和负载均衡
5. **安全性**: 非root用户、Secret管理

### 后续扩展

- 添加Service Mesh (Istio)
- 实现蓝绿/金丝雀部署
- 集成ELK日志栈
- 添加更多业务功能
- 性能压测和优化

---

## 📚 参考资料

- [Kubernetes官方文档](https://kubernetes.io/docs/)
- [Docker最佳实践](https://docs.docker.com/develop/dev-best-practices/)
- [12-Factor App](https://12factor.net/)
- [Go Web开发最佳实践](https://go.dev/doc/effective_go)
- [Prometheus监控指南](https://prometheus.io/docs/introduction/overview/)

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025年10月22日  
**文档状态**: ✅ 完成  
**适用版本**: Go 1.25.3+ | Kubernetes 1.25+
