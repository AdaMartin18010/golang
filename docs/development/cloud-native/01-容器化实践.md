# Goå®¹å™¨åŒ–å®è·µ

> **ç®€ä»‹**: Goå®¹å™¨åŒ–å®è·µå®Œæ•´æŒ‡å—ï¼ŒåŒ…æ‹¬Dockerã€Kubernetesã€é…ç½®ç®¡ç†å’Œæœ€ä½³å®è·µ
> **ç‰ˆæœ¬**: Go 1.25.3, Docker 24+, Kubernetes 1.28+  
> **éš¾åº¦**: â­â­â­â­  
> **æ ‡ç­¾**: #å®¹å™¨åŒ– #Docker #Kubernetes #äº‘åŸç”Ÿ

---

## ğŸ“‹ ç›®å½•

- [1. å®¹å™¨åŒ–åŸºç¡€](#1-å®¹å™¨åŒ–åŸºç¡€)
  - [ä¸ºä»€ä¹ˆå®¹å™¨åŒ–](#ä¸ºä»€ä¹ˆå®¹å™¨åŒ–)
  - [åŸºæœ¬Dockerfile](#åŸºæœ¬dockerfile)
- [2. Dockerfileæœ€ä½³å®è·µ](#2-dockerfileæœ€ä½³å®è·µ)
  - [å¤šé˜¶æ®µæ„å»º](#å¤šé˜¶æ®µæ„å»º)
  - [ä¼˜åŒ–é•œåƒå¤§å°](#ä¼˜åŒ–é•œåƒå¤§å°)
  - [.dockerignore](#dockerignore)
- [3. é…ç½®ç®¡ç†](#3-é…ç½®ç®¡ç†)
  - [ç¯å¢ƒå˜é‡é…ç½®](#ç¯å¢ƒå˜é‡é…ç½®)
  - [Docker Composeé…ç½®](#docker-composeé…ç½®)
  - [Kubernetes ConfigMap](#kubernetes-configmap)
- [4. å¥åº·æ£€æŸ¥](#4-å¥åº·æ£€æŸ¥)
  - [å¥åº·æ£€æŸ¥ç«¯ç‚¹](#å¥åº·æ£€æŸ¥ç«¯ç‚¹)
  - [Kuberneteså¥åº·æ£€æŸ¥é…ç½®](#kuberneteså¥åº·æ£€æŸ¥é…ç½®)
- [5. æ—¥å¿—å’Œç›‘æ§](#5-æ—¥å¿—å’Œç›‘æ§)
  - [ç»“æ„åŒ–æ—¥å¿—](#ç»“æ„åŒ–æ—¥å¿—)
  - [PrometheusæŒ‡æ ‡](#prometheusæŒ‡æ ‡)
- [6. ç”Ÿäº§å®è·µ](#6-ç”Ÿäº§å®è·µ)
  - [ä¼˜é›…å…³é—­](#ä¼˜é›…å…³é—­)
  - [èµ„æºé™åˆ¶](#èµ„æºé™åˆ¶)
  - [å®Œæ•´éƒ¨ç½²ç¤ºä¾‹](#å®Œæ•´éƒ¨ç½²ç¤ºä¾‹)
- [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

## 1. å®¹å™¨åŒ–åŸºç¡€

### ä¸ºä»€ä¹ˆå®¹å™¨åŒ–

**ä¼˜åŠ¿**:

- âœ… ä¸€è‡´çš„è¿è¡Œç¯å¢ƒ
- âœ… å¿«é€Ÿéƒ¨ç½²å’Œæ‰©å±•
- âœ… èµ„æºéš”ç¦»
- âœ… æ˜“äºç‰ˆæœ¬ç®¡ç†
- âœ… å¾®æœåŠ¡å‹å¥½

---

### åŸºæœ¬Dockerfile

```dockerfile
FROM golang:1.25.3-alpine

WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY . .

RUN go build -o main .

EXPOSE 8080

CMD ["./main"]
```

---

## 2. Dockerfileæœ€ä½³å®è·µ

### å¤šé˜¶æ®µæ„å»º

```dockerfile
# æ„å»ºé˜¶æ®µ
FROM golang:1.25.3-alpine AS builder

# å®‰è£…æ„å»ºä¾èµ–
RUN apk add --no-cache git make

WORKDIR /build

# ç¼“å­˜ä¾èµ–
COPY go.mod go.sum ./
RUN go mod download

# å¤åˆ¶æºä»£ç 
COPY . .

# æ„å»ºåº”ç”¨
ARG VERSION=dev
ARG BUILD_TIME
RUN CGO_ENABLED=0 GOOS=linux go build \
    -ldflags="-w -s -X main.Version=${VERSION} -X main.BuildTime=${BUILD_TIME}" \
    -trimpath \
    -o app .

# è¿è¡Œé˜¶æ®µ
FROM alpine:latest

# å®‰è£…è¿è¡Œæ—¶ä¾èµ–
RUN apk --no-cache add ca-certificates tzdata

# åˆ›å»ºérootç”¨æˆ·
RUN addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser

WORKDIR /app

# å¤åˆ¶äºŒè¿›åˆ¶æ–‡ä»¶
COPY --from=builder /build/app .

# åˆ‡æ¢ç”¨æˆ·
USER appuser

# å¥åº·æ£€æŸ¥
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1

EXPOSE 8080

CMD ["./app"]
```

---

### ä¼˜åŒ–é•œåƒå¤§å°

```dockerfile
# ä½¿ç”¨Scratchï¼ˆæœ€å°é•œåƒï¼‰
FROM golang:1.25.3-alpine AS builder

WORKDIR /build

COPY go.mod go.sum ./
RUN go mod download

COPY . .

# é™æ€é“¾æ¥æ„å»º
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
    -ldflags='-w -s -extldflags "-static"' \
    -a \
    -o app .

# æœ€å°åŒ–è¿è¡Œé•œåƒ
FROM scratch

# å¤åˆ¶CAè¯ä¹¦ï¼ˆç”¨äºHTTPSï¼‰
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

# å¤åˆ¶æ—¶åŒºæ•°æ®
COPY --from=builder /usr/share/zoneinfo /usr/share/zoneinfo

# å¤åˆ¶åº”ç”¨
COPY --from=builder /build/app /app

EXPOSE 8080

ENTRYPOINT ["/app"]
```

---

### .dockerignore

```text
# Git
.git
.gitignore

# IDE
.vscode
.idea
*.swp

# Build
bin/
dist/
*.exe

# Test
*.test
coverage.txt
coverage.html

# Docs
*.md
docs/

# CI/CD
.github
.gitlab-ci.yml

# Environment
.env
.env.*
!.env.example

# Dependencies
vendor/

# Logs
*.log
logs/
```

---

## 3. é…ç½®ç®¡ç†

### ç¯å¢ƒå˜é‡é…ç½®

```go
package config

import (
    "os"
    "strconv"
    "time"
)

type Config struct {
    Server   ServerConfig
    Database DatabaseConfig
    Redis    RedisConfig
}

type ServerConfig struct {
    Host         string
    Port         int
    ReadTimeout  time.Duration
    WriteTimeout time.Duration
}

type DatabaseConfig struct {
    Host     string
    Port     int
    User     string
    Password string
    Database string
}

func LoadFromEnv() *Config {
    return &Config{
        Server: ServerConfig{
            Host:         getEnv("SERVER_HOST", "0.0.0.0"),
            Port:         getEnvInt("SERVER_PORT", 8080),
            ReadTimeout:  getEnvDuration("SERVER_READ_TIMEOUT", 10*time.Second),
            WriteTimeout: getEnvDuration("SERVER_WRITE_TIMEOUT", 10*time.Second),
        },
        Database: DatabaseConfig{
            Host:     getEnv("DB_HOST", "localhost"),
            Port:     getEnvInt("DB_PORT", 5432),
            User:     getEnv("DB_USER", "postgres"),
            Password: getEnv("DB_PASSWORD", ""),
            Database: getEnv("DB_NAME", "myapp"),
        },
        Redis: RedisConfig{
            Host: getEnv("REDIS_HOST", "localhost"),
            Port: getEnvInt("REDIS_PORT", 6379),
        },
    }
}

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func getEnvInt(key string, defaultValue int) int {
    if value := os.Getenv(key); value != "" {
        if i, err := strconv.Atoi(value); err == nil {
            return i
        }
    }
    return defaultValue
}

func getEnvDuration(key string, defaultValue time.Duration) time.Duration {
    if value := os.Getenv(key); value != "" {
        if d, err := time.ParseDuration(value); err == nil {
            return d
        }
    }
    return defaultValue
}
```

---

### Docker Composeé…ç½®

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
      args:
        VERSION: ${VERSION:-dev}
        BUILD_TIME: ${BUILD_TIME:-unknown}
    ports:
      - "${APP_PORT:-8080}:8080"
    environment:
      - SERVER_HOST=0.0.0.0
      - SERVER_PORT=8080
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_USER=myapp
      - DB_PASSWORD=${DB_PASSWORD}
      - DB_NAME=myapp
      - REDIS_HOST=redis
      - REDIS_PORT=6379
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_started
    restart: unless-stopped
    networks:
      - app-network

  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: myapp
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: myapp
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U myapp"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - app-network

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
    networks:
      - app-network

volumes:
  postgres_data:
  redis_data:

networks:
  app-network:
    driver: bridge
```

---

### Kubernetes ConfigMap

```yaml
# configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  SERVER_HOST: "0.0.0.0"
  SERVER_PORT: "8080"
  DB_HOST: "postgres-service"
  DB_PORT: "5432"
  DB_NAME: "myapp"
  REDIS_HOST: "redis-service"
  REDIS_PORT: "6379"
  LOG_LEVEL: "info"
  LOG_FORMAT: "json"

---
# secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: app-secret
type: Opaque
data:
  DB_USER: bXlhcHA=       # base64("myapp")
  DB_PASSWORD: cGFzc3dvcmQ=  # base64("password")
  JWT_SECRET: c2VjcmV0a2V5  # base64("secretkey")
```

---

## 4. å¥åº·æ£€æŸ¥

### å¥åº·æ£€æŸ¥ç«¯ç‚¹

```go
package health

import (
    "context"
    "database/sql"
    "encoding/json"
    "net/http"
    "time"
)

type HealthStatus struct {
    Status    string            `json:"status"`
    Timestamp time.Time         `json:"timestamp"`
    Checks    map[string]Check  `json:"checks"`
}

type Check struct {
    Status  string `json:"status"`
    Message string `json:"message,omitempty"`
}

type HealthChecker struct {
    db    *sql.DB
    redis *redis.Client
}

func NewHealthChecker(db *sql.DB, redis *redis.Client) *HealthChecker {
    return &HealthChecker{
        db:    db,
        redis: redis,
    }
}

// å­˜æ´»æ£€æŸ¥ï¼ˆLivenessï¼‰
func (h *HealthChecker) Live(w http.ResponseWriter, r *http.Request) {
    // ç®€å•æ£€æŸ¥åº”ç”¨æ˜¯å¦è¿è¡Œ
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(map[string]string{
        "status": "UP",
    })
}

// å°±ç»ªæ£€æŸ¥ï¼ˆReadinessï¼‰
func (h *HealthChecker) Ready(w http.ResponseWriter, r *http.Request) {
    ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
    defer cancel()
    
    status := HealthStatus{
        Status:    "UP",
        Timestamp: time.Now(),
        Checks:    make(map[string]Check),
    }
    
    // æ£€æŸ¥æ•°æ®åº“
    if err := h.db.PingContext(ctx); err != nil {
        status.Checks["database"] = Check{
            Status:  "DOWN",
            Message: err.Error(),
        }
        status.Status = "DOWN"
    } else {
        status.Checks["database"] = Check{Status: "UP"}
    }
    
    // æ£€æŸ¥Redis
    if err := h.redis.Ping(ctx).Err(); err != nil {
        status.Checks["redis"] = Check{
            Status:  "DOWN",
            Message: err.Error(),
        }
        status.Status = "DEGRADED"
    } else {
        status.Checks["redis"] = Check{Status: "UP"}
    }
    
    // è¿”å›ç»“æœ
    w.Header().Set("Content-Type", "application/json")
    if status.Status == "DOWN" {
        w.WriteHeader(http.StatusServiceUnavailable)
    } else {
        w.WriteHeader(http.StatusOK)
    }
    json.NewEncoder(w).Encode(status)
}

// å¯åŠ¨æ£€æŸ¥ï¼ˆStartupï¼‰
func (h *HealthChecker) Startup(w http.ResponseWriter, r *http.Request) {
    // æ£€æŸ¥åº”ç”¨æ˜¯å¦å®Œæˆåˆå§‹åŒ–
    if !appInitialized {
        w.WriteHeader(http.StatusServiceUnavailable)
        json.NewEncoder(w).Encode(map[string]string{
            "status": "STARTING",
        })
        return
    }
    
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(map[string]string{
        "status": "READY",
    })
}
```

---

### Kuberneteså¥åº·æ£€æŸ¥é…ç½®

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3
  template:
    spec:
      containers:
      - name: myapp
        image: myapp:1.0.0
        ports:
        - containerPort: 8080
        
        # å¯åŠ¨æ¢é’ˆï¼ˆåº”ç”¨å¯åŠ¨æ—¶æ£€æŸ¥ï¼‰
        startupProbe:
          httpGet:
            path: /health/startup
            port: 8080
          failureThreshold: 30
          periodSeconds: 10
        
        # å­˜æ´»æ¢é’ˆï¼ˆåº”ç”¨æ˜¯å¦è¿è¡Œï¼‰
        livenessProbe:
          httpGet:
            path: /health/live
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 3
          failureThreshold: 3
        
        # å°±ç»ªæ¢é’ˆï¼ˆåº”ç”¨æ˜¯å¦å¯æ¥æ”¶æµé‡ï¼‰
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          successThreshold: 1
          failureThreshold: 3
```

---

## 5. æ—¥å¿—å’Œç›‘æ§

### ç»“æ„åŒ–æ—¥å¿—

```go
package logger

import (
    "log/slog"
    "os"
)

func Init() *slog.Logger {
    var handler slog.Handler
    
    // æ ¹æ®ç¯å¢ƒé€‰æ‹©æ—¥å¿—æ ¼å¼
    logFormat := os.Getenv("LOG_FORMAT")
    logLevel := os.Getenv("LOG_LEVEL")
    
    level := slog.LevelInfo
    switch logLevel {
    case "debug":
        level = slog.LevelDebug
    case "warn":
        level = slog.LevelWarn
    case "error":
        level = slog.LevelError
    }
    
    opts := &slog.HandlerOptions{
        Level: level,
        AddSource: true,
    }
    
    if logFormat == "json" {
        handler = slog.NewJSONHandler(os.Stdout, opts)
    } else {
        handler = slog.NewTextHandler(os.Stdout, opts)
    }
    
    logger := slog.New(handler)
    slog.SetDefault(logger)
    
    return logger
}

// ä½¿ç”¨
func main() {
    logger := logger.Init()
    
    logger.Info("Server starting",
        "port", 8080,
        "version", "1.0.0",
    )
    
    logger.Error("Failed to connect to database",
        "error", err,
        "host", dbHost,
        "retry", retryCount,
    )
}
```

---

### PrometheusæŒ‡æ ‡

```go
package metrics

import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promhttp"
    "net/http"
)

var (
    // HTTPè¯·æ±‚è®¡æ•°å™¨
    httpRequestsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total number of HTTP requests",
        },
        []string{"method", "endpoint", "status"},
    )
    
    // HTTPè¯·æ±‚å»¶è¿Ÿ
    httpRequestDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_request_duration_seconds",
            Help:    "HTTP request duration in seconds",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method", "endpoint"},
    )
    
    // å½“å‰æ´»è·ƒè¿æ¥æ•°
    activeConnections = prometheus.NewGauge(
        prometheus.GaugeOpts{
            Name: "active_connections",
            Help: "Number of active connections",
        },
    )
)

func init() {
    prometheus.MustRegister(httpRequestsTotal)
    prometheus.MustRegister(httpRequestDuration)
    prometheus.MustRegister(activeConnections)
}

// Prometheusä¸­é—´ä»¶
func PrometheusMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        timer := prometheus.NewTimer(httpRequestDuration.WithLabelValues(
            r.Method,
            r.URL.Path,
        ))
        defer timer.ObserveDuration()
        
        activeConnections.Inc()
        defer activeConnections.Dec()
        
        // åŒ…è£…ResponseWriterä»¥è·å–çŠ¶æ€ç 
        rw := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
        
        next.ServeHTTP(rw, r)
        
        httpRequestsTotal.WithLabelValues(
            r.Method,
            r.URL.Path,
            http.StatusText(rw.statusCode),
        ).Inc()
    })
}

type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}

// æ³¨å†ŒæŒ‡æ ‡ç«¯ç‚¹
func RegisterMetrics(mux *http.ServeMux) {
    mux.Handle("/metrics", promhttp.Handler())
}
```

---

## 6. ç”Ÿäº§å®è·µ

### ä¼˜é›…å…³é—­

```go
package main

import (
    "context"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
)

func main() {
    server := &http.Server{
        Addr:    ":8080",
        Handler: setupRouter(),
    }
    
    // å¯åŠ¨æœåŠ¡å™¨
    go func() {
        log.Println("Server starting on :8080")
        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatalf("Server error: %v", err)
        }
    }()
    
    // ç­‰å¾…ä¸­æ–­ä¿¡å·
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Println("Shutting down server...")
    
    // ä¼˜é›…å…³é—­ï¼ˆ30ç§’è¶…æ—¶ï¼‰
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    if err := server.Shutdown(ctx); err != nil {
        log.Fatalf("Server forced to shutdown: %v", err)
    }
    
    log.Println("Server exited")
}
```

---

### èµ„æºé™åˆ¶

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  template:
    spec:
      containers:
      - name: myapp
        image: myapp:1.0.0
        
        # èµ„æºè¯·æ±‚å’Œé™åˆ¶
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "500m"
        
        # ç¯å¢ƒå˜é‡
        env:
        - name: GOMAXPROCS
          valueFrom:
            resourceFieldRef:
              resource: limits.cpu
        
        # å®‰å…¨ä¸Šä¸‹æ–‡
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
          readOnlyRootFilesystem: true
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
```

---

### å®Œæ•´éƒ¨ç½²ç¤ºä¾‹

```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  labels:
    app: myapp
    version: v1.0.0
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
        version: v1.0.0
    spec:
      terminationGracePeriodSeconds: 30
      
      containers:
      - name: myapp
        image: myapp:1.0.0
        imagePullPolicy: IfNotPresent
        
        ports:
        - containerPort: 8080
          name: http
        
        envFrom:
        - configMapRef:
            name: app-config
        - secretRef:
            name: app-secret
        
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "500m"
        
        livenessProbe:
          httpGet:
            path: /health/live
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
        
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
          allowPrivilegeEscalation: false

---
# service.yaml
apiVersion: v1
kind: Service
metadata:
  name: myapp-service
spec:
  type: ClusterIP
  selector:
    app: myapp
  ports:
  - port: 80
    targetPort: 8080
    name: http
```

---

## ğŸ”— ç›¸å…³èµ„æº

- [Dockeréƒ¨ç½²](../../practices/deployment/02-Dockeréƒ¨ç½².md)
- [Kuberneteséƒ¨ç½²](../../practices/deployment/03-Kuberneteséƒ¨ç½².md)
- [æœåŠ¡ç½‘æ ¼](../microservices/04-æœåŠ¡ç½‘æ ¼.md)

---

**æœ€åæ›´æ–°**: 2025-10-28  
**Goç‰ˆæœ¬**: 1.25.3  
**Dockerç‰ˆæœ¬**: 24+  
**Kubernetesç‰ˆæœ¬**: 1.28+
