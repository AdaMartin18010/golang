# Go容器化实践

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.25.3, Docker 24+, Kubernetes 1.28+

---

---

## 📋 目录

- [1. 容器化基础](#1.-容器化基础)
  - [为什么容器化](#为什么容器化)
  - [基本Dockerfile](#基本dockerfile)
- [2. Dockerfile最佳实践](#2.-dockerfile最佳实践)
  - [多阶段构建](#多阶段构建)
  - [优化镜像大小](#优化镜像大小)
  - [.dockerignore](#.dockerignore)
- [3. 配置管理](#3.-配置管理)
  - [环境变量配置](#环境变量配置)
  - [Docker Compose配置](#docker-compose配置)
  - [Kubernetes ConfigMap](#kubernetes-configmap)
- [4. 健康检查](#4.-健康检查)
  - [健康检查端点](#健康检查端点)
  - [Kubernetes健康检查配置](#kubernetes健康检查配置)
- [5. 日志和监控](#5.-日志和监控)
  - [结构化日志](#结构化日志)
  - [Prometheus指标](#prometheus指标)
- [6. 生产实践](#6.-生产实践)
  - [优雅关闭](#优雅关闭)
  - [资源限制](#资源限制)
  - [完整部署示例](#完整部署示例)
- [🔗 相关资源](#相关资源)

## 1. 容器化基础

### 为什么容器化

**优势**:

- ✅ 一致的运行环境
- ✅ 快速部署和扩展
- ✅ 资源隔离
- ✅ 易于版本管理
- ✅ 微服务友好

---

### 基本Dockerfile

```dockerfile
FROM golang:1.25.3-alpine

WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY . .

RUN go build -o main .

EXPOSE 8080

CMD ["./main"]
```

---

## 2. Dockerfile最佳实践

### 多阶段构建

```dockerfile
# 构建阶段
FROM golang:1.25.3-alpine AS builder

# 安装构建依赖
RUN apk add --no-cache git make

WORKDIR /build

# 缓存依赖
COPY go.mod go.sum ./
RUN go mod download

# 复制源代码
COPY . .

# 构建应用
ARG VERSION=dev
ARG BUILD_TIME
RUN CGO_ENABLED=0 GOOS=linux go build \
    -ldflags="-w -s -X main.Version=${VERSION} -X main.BuildTime=${BUILD_TIME}" \
    -trimpath \
    -o app .

# 运行阶段
FROM alpine:latest

# 安装运行时依赖
RUN apk --no-cache add ca-certificates tzdata

# 创建非root用户
RUN addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser

WORKDIR /app

# 复制二进制文件
COPY --from=builder /build/app .

# 切换用户
USER appuser

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1

EXPOSE 8080

CMD ["./app"]
```

---

### 优化镜像大小

```dockerfile
# 使用Scratch（最小镜像）
FROM golang:1.25.3-alpine AS builder

WORKDIR /build

COPY go.mod go.sum ./
RUN go mod download

COPY . .

# 静态链接构建
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
    -ldflags='-w -s -extldflags "-static"' \
    -a \
    -o app .

# 最小化运行镜像
FROM scratch

# 复制CA证书（用于HTTPS）
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

# 复制时区数据
COPY --from=builder /usr/share/zoneinfo /usr/share/zoneinfo

# 复制应用
COPY --from=builder /build/app /app

EXPOSE 8080

ENTRYPOINT ["/app"]
```

---

### .dockerignore

```text
# Git
.git
.gitignore

# IDE
.vscode
.idea
*.swp

# Build
bin/
dist/
*.exe

# Test
*.test
coverage.txt
coverage.html

# Docs
*.md
docs/

# CI/CD
.github
.gitlab-ci.yml

# Environment
.env
.env.*
!.env.example

# Dependencies
vendor/

# Logs
*.log
logs/
```

---

## 3. 配置管理

### 环境变量配置

```go
package config

import (
    "os"
    "strconv"
    "time"
)

type Config struct {
    Server   ServerConfig
    Database DatabaseConfig
    Redis    RedisConfig
}

type ServerConfig struct {
    Host         string
    Port         int
    ReadTimeout  time.Duration
    WriteTimeout time.Duration
}

type DatabaseConfig struct {
    Host     string
    Port     int
    User     string
    Password string
    Database string
}

func LoadFromEnv() *Config {
    return &Config{
        Server: ServerConfig{
            Host:         getEnv("SERVER_HOST", "0.0.0.0"),
            Port:         getEnvInt("SERVER_PORT", 8080),
            ReadTimeout:  getEnvDuration("SERVER_READ_TIMEOUT", 10*time.Second),
            WriteTimeout: getEnvDuration("SERVER_WRITE_TIMEOUT", 10*time.Second),
        },
        Database: DatabaseConfig{
            Host:     getEnv("DB_HOST", "localhost"),
            Port:     getEnvInt("DB_PORT", 5432),
            User:     getEnv("DB_USER", "postgres"),
            Password: getEnv("DB_PASSWORD", ""),
            Database: getEnv("DB_NAME", "myapp"),
        },
        Redis: RedisConfig{
            Host: getEnv("REDIS_HOST", "localhost"),
            Port: getEnvInt("REDIS_PORT", 6379),
        },
    }
}

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func getEnvInt(key string, defaultValue int) int {
    if value := os.Getenv(key); value != "" {
        if i, err := strconv.Atoi(value); err == nil {
            return i
        }
    }
    return defaultValue
}

func getEnvDuration(key string, defaultValue time.Duration) time.Duration {
    if value := os.Getenv(key); value != "" {
        if d, err := time.ParseDuration(value); err == nil {
            return d
        }
    }
    return defaultValue
}
```

---

### Docker Compose配置

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
      args:
        VERSION: ${VERSION:-dev}
        BUILD_TIME: ${BUILD_TIME:-unknown}
    ports:
      - "${APP_PORT:-8080}:8080"
    environment:
      - SERVER_HOST=0.0.0.0
      - SERVER_PORT=8080
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_USER=myapp
      - DB_PASSWORD=${DB_PASSWORD}
      - DB_NAME=myapp
      - REDIS_HOST=redis
      - REDIS_PORT=6379
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_started
    restart: unless-stopped
    networks:
      - app-network

  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: myapp
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: myapp
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U myapp"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - app-network

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
    networks:
      - app-network

volumes:
  postgres_data:
  redis_data:

networks:
  app-network:
    driver: bridge
```

---

### Kubernetes ConfigMap

```yaml
# configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  SERVER_HOST: "0.0.0.0"
  SERVER_PORT: "8080"
  DB_HOST: "postgres-service"
  DB_PORT: "5432"
  DB_NAME: "myapp"
  REDIS_HOST: "redis-service"
  REDIS_PORT: "6379"
  LOG_LEVEL: "info"
  LOG_FORMAT: "json"

---
# secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: app-secret
type: Opaque
data:
  DB_USER: bXlhcHA=       # base64("myapp")
  DB_PASSWORD: cGFzc3dvcmQ=  # base64("password")
  JWT_SECRET: c2VjcmV0a2V5  # base64("secretkey")
```

---

## 4. 健康检查

### 健康检查端点

```go
package health

import (
    "context"
    "database/sql"
    "encoding/json"
    "net/http"
    "time"
)

type HealthStatus struct {
    Status    string            `json:"status"`
    Timestamp time.Time         `json:"timestamp"`
    Checks    map[string]Check  `json:"checks"`
}

type Check struct {
    Status  string `json:"status"`
    Message string `json:"message,omitempty"`
}

type HealthChecker struct {
    db    *sql.DB
    redis *redis.Client
}

func NewHealthChecker(db *sql.DB, redis *redis.Client) *HealthChecker {
    return &HealthChecker{
        db:    db,
        redis: redis,
    }
}

// 存活检查（Liveness）
func (h *HealthChecker) Live(w http.ResponseWriter, r *http.Request) {
    // 简单检查应用是否运行
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(map[string]string{
        "status": "UP",
    })
}

// 就绪检查（Readiness）
func (h *HealthChecker) Ready(w http.ResponseWriter, r *http.Request) {
    ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
    defer cancel()
    
    status := HealthStatus{
        Status:    "UP",
        Timestamp: time.Now(),
        Checks:    make(map[string]Check),
    }
    
    // 检查数据库
    if err := h.db.PingContext(ctx); err != nil {
        status.Checks["database"] = Check{
            Status:  "DOWN",
            Message: err.Error(),
        }
        status.Status = "DOWN"
    } else {
        status.Checks["database"] = Check{Status: "UP"}
    }
    
    // 检查Redis
    if err := h.redis.Ping(ctx).Err(); err != nil {
        status.Checks["redis"] = Check{
            Status:  "DOWN",
            Message: err.Error(),
        }
        status.Status = "DEGRADED"
    } else {
        status.Checks["redis"] = Check{Status: "UP"}
    }
    
    // 返回结果
    w.Header().Set("Content-Type", "application/json")
    if status.Status == "DOWN" {
        w.WriteHeader(http.StatusServiceUnavailable)
    } else {
        w.WriteHeader(http.StatusOK)
    }
    json.NewEncoder(w).Encode(status)
}

// 启动检查（Startup）
func (h *HealthChecker) Startup(w http.ResponseWriter, r *http.Request) {
    // 检查应用是否完成初始化
    if !appInitialized {
        w.WriteHeader(http.StatusServiceUnavailable)
        json.NewEncoder(w).Encode(map[string]string{
            "status": "STARTING",
        })
        return
    }
    
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(map[string]string{
        "status": "READY",
    })
}
```

---

### Kubernetes健康检查配置

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3
  template:
    spec:
      containers:
      - name: myapp
        image: myapp:1.0.0
        ports:
        - containerPort: 8080
        
        # 启动探针（应用启动时检查）
        startupProbe:
          httpGet:
            path: /health/startup
            port: 8080
          failureThreshold: 30
          periodSeconds: 10
        
        # 存活探针（应用是否运行）
        livenessProbe:
          httpGet:
            path: /health/live
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 3
          failureThreshold: 3
        
        # 就绪探针（应用是否可接收流量）
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          successThreshold: 1
          failureThreshold: 3
```

---

## 5. 日志和监控

### 结构化日志

```go
package logger

import (
    "log/slog"
    "os"
)

func Init() *slog.Logger {
    var handler slog.Handler
    
    // 根据环境选择日志格式
    logFormat := os.Getenv("LOG_FORMAT")
    logLevel := os.Getenv("LOG_LEVEL")
    
    level := slog.LevelInfo
    switch logLevel {
    case "debug":
        level = slog.LevelDebug
    case "warn":
        level = slog.LevelWarn
    case "error":
        level = slog.LevelError
    }
    
    opts := &slog.HandlerOptions{
        Level: level,
        AddSource: true,
    }
    
    if logFormat == "json" {
        handler = slog.NewJSONHandler(os.Stdout, opts)
    } else {
        handler = slog.NewTextHandler(os.Stdout, opts)
    }
    
    logger := slog.New(handler)
    slog.SetDefault(logger)
    
    return logger
}

// 使用
func main() {
    logger := logger.Init()
    
    logger.Info("Server starting",
        "port", 8080,
        "version", "1.0.0",
    )
    
    logger.Error("Failed to connect to database",
        "error", err,
        "host", dbHost,
        "retry", retryCount,
    )
}
```

---

### Prometheus指标

```go
package metrics

import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promhttp"
    "net/http"
)

var (
    // HTTP请求计数器
    httpRequestsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total number of HTTP requests",
        },
        []string{"method", "endpoint", "status"},
    )
    
    // HTTP请求延迟
    httpRequestDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_request_duration_seconds",
            Help:    "HTTP request duration in seconds",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method", "endpoint"},
    )
    
    // 当前活跃连接数
    activeConnections = prometheus.NewGauge(
        prometheus.GaugeOpts{
            Name: "active_connections",
            Help: "Number of active connections",
        },
    )
)

func init() {
    prometheus.MustRegister(httpRequestsTotal)
    prometheus.MustRegister(httpRequestDuration)
    prometheus.MustRegister(activeConnections)
}

// Prometheus中间件
func PrometheusMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        timer := prometheus.NewTimer(httpRequestDuration.WithLabelValues(
            r.Method,
            r.URL.Path,
        ))
        defer timer.ObserveDuration()
        
        activeConnections.Inc()
        defer activeConnections.Dec()
        
        // 包装ResponseWriter以获取状态码
        rw := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
        
        next.ServeHTTP(rw, r)
        
        httpRequestsTotal.WithLabelValues(
            r.Method,
            r.URL.Path,
            http.StatusText(rw.statusCode),
        ).Inc()
    })
}

type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}

// 注册指标端点
func RegisterMetrics(mux *http.ServeMux) {
    mux.Handle("/metrics", promhttp.Handler())
}
```

---

## 6. 生产实践

### 优雅关闭

```go
package main

import (
    "context"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
)

func main() {
    server := &http.Server{
        Addr:    ":8080",
        Handler: setupRouter(),
    }
    
    // 启动服务器
    go func() {
        log.Println("Server starting on :8080")
        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatalf("Server error: %v", err)
        }
    }()
    
    // 等待中断信号
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Println("Shutting down server...")
    
    // 优雅关闭（30秒超时）
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    if err := server.Shutdown(ctx); err != nil {
        log.Fatalf("Server forced to shutdown: %v", err)
    }
    
    log.Println("Server exited")
}
```

---

### 资源限制

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  template:
    spec:
      containers:
      - name: myapp
        image: myapp:1.0.0
        
        # 资源请求和限制
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "500m"
        
        # 环境变量
        env:
        - name: GOMAXPROCS
          valueFrom:
            resourceFieldRef:
              resource: limits.cpu
        
        # 安全上下文
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
          readOnlyRootFilesystem: true
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
```

---

### 完整部署示例

```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  labels:
    app: myapp
    version: v1.0.0
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
        version: v1.0.0
    spec:
      terminationGracePeriodSeconds: 30
      
      containers:
      - name: myapp
        image: myapp:1.0.0
        imagePullPolicy: IfNotPresent
        
        ports:
        - containerPort: 8080
          name: http
        
        envFrom:
        - configMapRef:
            name: app-config
        - secretRef:
            name: app-secret
        
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "500m"
        
        livenessProbe:
          httpGet:
            path: /health/live
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
        
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
          allowPrivilegeEscalation: false

---
# service.yaml
apiVersion: v1
kind: Service
metadata:
  name: myapp-service
spec:
  type: ClusterIP
  selector:
    app: myapp
  ports:
  - port: 80
    targetPort: 8080
    name: http
```

---

## 🔗 相关资源

- [Docker部署](../../practices/deployment/02-Docker部署.md)
- [Kubernetes部署](../../practices/deployment/03-Kubernetes部署.md)
- [服务网格](../microservices/04-服务网格.md)

---

**最后更新**: 2025-10-29  
**Go版本**: 1.25.3  
**Docker版本**: 24+  
**Kubernetes版本**: 1.28+
