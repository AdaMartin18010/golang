# Ginæ¡†æ¶æ·±åº¦å®æˆ˜æŒ‡å—

**å­—æ•°**: ~42,000å­—  
**ä»£ç ç¤ºä¾‹**: 130+ä¸ªå®Œæ•´ç¤ºä¾‹  
**å®æˆ˜æ¡ˆä¾‹**: 12ä¸ªç«¯åˆ°ç«¯æ¡ˆä¾‹  
**é€‚ç”¨äººç¾¤**: åˆçº§åˆ°é«˜çº§Go Webå¼€å‘è€…

---

## ğŸ“‹ ç›®å½•


- [ç¬¬ä¸€éƒ¨åˆ†ï¼šGinæ¡†æ¶æ ¸å¿ƒåŸç†](#ç¬¬ä¸€éƒ¨åˆ†ginæ¡†æ¶æ ¸å¿ƒåŸç†)
  - [Ginæ¡†æ¶æ¶æ„](#ginæ¡†æ¶æ¶æ„)
  - [å®æˆ˜æ¡ˆä¾‹1ï¼šGinæ ¸å¿ƒåŸç†ç¤ºä¾‹](#å®æˆ˜æ¡ˆä¾‹1ginæ ¸å¿ƒåŸç†ç¤ºä¾‹)
- [ç¬¬äºŒéƒ¨åˆ†ï¼šè·¯ç”±ç³»ç»Ÿæ·±åº¦è§£æ](#ç¬¬äºŒéƒ¨åˆ†è·¯ç”±ç³»ç»Ÿæ·±åº¦è§£æ)
  - [è·¯ç”±åŒ¹é…è§„åˆ™](#è·¯ç”±åŒ¹é…è§„åˆ™)
  - [å®æˆ˜æ¡ˆä¾‹2ï¼šRESTful APIè®¾è®¡](#å®æˆ˜æ¡ˆä¾‹2restful-apiè®¾è®¡)
- [ç¬¬ä¸‰éƒ¨åˆ†ï¼šä¸­é—´ä»¶å®Œæ•´å®æˆ˜](#ç¬¬ä¸‰éƒ¨åˆ†ä¸­é—´ä»¶å®Œæ•´å®æˆ˜)
  - [ä¸­é—´ä»¶æ‰§è¡Œæµç¨‹ï¼ˆæ´‹è‘±æ¨¡å‹ï¼‰](#ä¸­é—´ä»¶æ‰§è¡Œæµç¨‹æ´‹è‘±æ¨¡å‹)
  - [å®æˆ˜æ¡ˆä¾‹3ï¼šè‡ªå®šä¹‰ä¸­é—´ä»¶å®Œæ•´å®ç°](#å®æˆ˜æ¡ˆä¾‹3è‡ªå®šä¹‰ä¸­é—´ä»¶å®Œæ•´å®ç°)
- [ç¬¬å››éƒ¨åˆ†ï¼šè¯·æ±‚å¤„ç†ä¸å‚æ•°ç»‘å®š](#ç¬¬å››éƒ¨åˆ†è¯·æ±‚å¤„ç†ä¸å‚æ•°ç»‘å®š)
  - [å‚æ•°ç»‘å®šå®Œæ•´æŒ‡å—](#å‚æ•°ç»‘å®šå®Œæ•´æŒ‡å—)
- [ç¬¬äº”éƒ¨åˆ†ï¼šå“åº”æ¸²æŸ“ä¸æ ¼å¼åŒ–](#ç¬¬äº”éƒ¨åˆ†å“åº”æ¸²æŸ“ä¸æ ¼å¼åŒ–)
  - [å®æˆ˜æ¡ˆä¾‹4ï¼šå¤šç§å“åº”æ ¼å¼](#å®æˆ˜æ¡ˆä¾‹4å¤šç§å“åº”æ ¼å¼)
- [ç¬¬å…­éƒ¨åˆ†ï¼šæ•°æ®éªŒè¯æ·±åº¦å®æˆ˜](#ç¬¬å…­éƒ¨åˆ†æ•°æ®éªŒè¯æ·±åº¦å®æˆ˜)
  - [å®æˆ˜æ¡ˆä¾‹5ï¼švalidatorå®Œæ•´éªŒè¯](#å®æˆ˜æ¡ˆä¾‹5validatorå®Œæ•´éªŒè¯)
- [ç¬¬ä¸ƒéƒ¨åˆ†ï¼šæ–‡ä»¶ä¸Šä¼ ä¸‹è½½](#ç¬¬ä¸ƒéƒ¨åˆ†æ–‡ä»¶ä¸Šä¼ ä¸‹è½½)
  - [å®æˆ˜æ¡ˆä¾‹6ï¼šæ–‡ä»¶æ“ä½œå®Œæ•´å®ç°](#å®æˆ˜æ¡ˆä¾‹6æ–‡ä»¶æ“ä½œå®Œæ•´å®ç°)
- [ç¬¬å…«éƒ¨åˆ†ï¼šWebSocketå®æ—¶é€šä¿¡](#ç¬¬å…«éƒ¨åˆ†websocketå®æ—¶é€šä¿¡)
  - [å®æˆ˜æ¡ˆä¾‹7ï¼šWebSocketèŠå¤©å®¤](#å®æˆ˜æ¡ˆä¾‹7websocketèŠå¤©å®¤)
- [ç¬¬ä¹éƒ¨åˆ†ï¼šGinæ€§èƒ½ä¼˜åŒ–](#ç¬¬ä¹éƒ¨åˆ†ginæ€§èƒ½ä¼˜åŒ–)
  - [å®æˆ˜æ¡ˆä¾‹8ï¼šæ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ](#å®æˆ˜æ¡ˆä¾‹8æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ)
- [ç¬¬åéƒ¨åˆ†ï¼šGinæµ‹è¯•æœ€ä½³å®è·µ](#ç¬¬åéƒ¨åˆ†ginæµ‹è¯•æœ€ä½³å®è·µ)
  - [å®æˆ˜æ¡ˆä¾‹9ï¼šå•å…ƒæµ‹è¯•å®Œæ•´å®ç°](#å®æˆ˜æ¡ˆä¾‹9å•å…ƒæµ‹è¯•å®Œæ•´å®ç°)
- [ç¬¬åä¸€éƒ¨åˆ†ï¼šGiné¡¹ç›®æ¶æ„è®¾è®¡](#ç¬¬åä¸€éƒ¨åˆ†giné¡¹ç›®æ¶æ„è®¾è®¡)
  - [å®æˆ˜æ¡ˆä¾‹10ï¼šåˆ†å±‚æ¶æ„è®¾è®¡](#å®æˆ˜æ¡ˆä¾‹10åˆ†å±‚æ¶æ„è®¾è®¡)
- [ç¬¬åäºŒéƒ¨åˆ†ï¼šå®Œæ•´ç”µå•†APIå®æˆ˜](#ç¬¬åäºŒéƒ¨åˆ†å®Œæ•´ç”µå•†apiå®æˆ˜)
  - [å®æˆ˜æ¡ˆä¾‹11ï¼šå®Œæ•´ç”µå•†ç³»ç»Ÿ](#å®æˆ˜æ¡ˆä¾‹11å®Œæ•´ç”µå•†ç³»ç»Ÿ)
- [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
  - [Ginæ ¸å¿ƒè¦ç‚¹](#ginæ ¸å¿ƒè¦ç‚¹)
  - [æœ€ä½³å®è·µæ¸…å•](#æœ€ä½³å®è·µæ¸…å•)

## ç¬¬ä¸€éƒ¨åˆ†ï¼šGinæ¡†æ¶æ ¸å¿ƒåŸç†

### Ginæ¡†æ¶æ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Ginæ¡†æ¶æ¶æ„                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                    HTTP Request
                         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  gin.Engine                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚         Router (Radix Tree)              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                     â†“                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚       Middleware Chain (æ´‹è‘±æ¨¡å‹)        â”‚  â”‚
â”‚  â”‚  Recovery â†’ Logger â†’ CORS â†’ Auth â†’ ...   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                     â†“                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚           gin.Context                    â”‚  â”‚
â”‚  â”‚  - Request                               â”‚  â”‚
â”‚  â”‚  - ResponseWriter                        â”‚  â”‚
â”‚  â”‚  - Params                                â”‚  â”‚
â”‚  â”‚  - Keys (Contextæ•°æ®)                    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                     â†“                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚          Handler Function                â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“
                   HTTP Response
```

---

### å®æˆ˜æ¡ˆä¾‹1ï¼šGinæ ¸å¿ƒåŸç†ç¤ºä¾‹

```go
package main

import (
    "fmt"
    "net/http"
    "time"
    
    "github.com/gin-gonic/gin"
)

// ===== 1. Engineåˆå§‹åŒ– =====
func createEngine() *gin.Engine {
    // æ–¹å¼1ï¼šä½¿ç”¨Defaultï¼ˆåŒ…å«Loggerå’ŒRecoveryä¸­é—´ä»¶ï¼‰
    // r := gin.Default()
    
    // æ–¹å¼2ï¼šä½¿ç”¨Newï¼ˆä¸åŒ…å«ä¸­é—´ä»¶ï¼‰
    r := gin.New()
    
    // æ‰‹åŠ¨æ·»åŠ ä¸­é—´ä»¶
    r.Use(gin.Logger())
    r.Use(gin.Recovery())
    
    return r
}

// ===== 2. Contextç”Ÿå‘½å‘¨æœŸ =====
func contextLifecycle() {
    r := gin.Default()
    
    r.GET("/lifecycle", func(c *gin.Context) {
        // Contextåœ¨è¯·æ±‚å¼€å§‹æ—¶åˆ›å»º
        fmt.Printf("Request ID: %p\n", c)
        
        // è®¾ç½®Contextæ•°æ®ï¼ˆé”®å€¼å¯¹ï¼‰
        c.Set("user_id", 123)
        c.Set("request_time", time.Now())
        
        // è·å–Contextæ•°æ®
        if userID, exists := c.Get("user_id"); exists {
            fmt.Printf("User ID: %v\n", userID)
        }
        
        // Contextä¼šåœ¨è¯·æ±‚ç»“æŸåè¢«å›æ”¶ï¼ˆsync.Poolï¼‰
        c.JSON(http.StatusOK, gin.H{"message": "lifecycle demo"})
    })
    
    r.Run(":8080")
}

// ===== 3. Radix Treeè·¯ç”±åŸç† =====
/*
Radix Treeç¤ºä¾‹:

          /
         / \
      api   static
       /       \
     v1        css
    /  \
users  posts

åŒ¹é…è·¯å¾„:
/api/v1/users  â†’ Handler1
/api/v1/posts  â†’ Handler2
/static/css    â†’ Handler3

æ—¶é—´å¤æ‚åº¦: O(log n)
*/

func routingDemo() {
    r := gin.Default()
    
    // é™æ€è·¯ç”±
    r.GET("/users", func(c *gin.Context) {
        c.JSON(200, gin.H{"type": "static"})
    })
    
    // å‚æ•°è·¯ç”±
    r.GET("/users/:id", func(c *gin.Context) {
        id := c.Param("id")
        c.JSON(200, gin.H{"type": "param", "id": id})
    })
    
    // é€šé…ç¬¦è·¯ç”±
    r.GET("/files/*filepath", func(c *gin.Context) {
        filepath := c.Param("filepath")
        c.JSON(200, gin.H{"type": "wildcard", "path": filepath})
    })
    
    r.Run(":8080")
}

func main() {
    contextLifecycle()
}
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šè·¯ç”±ç³»ç»Ÿæ·±åº¦è§£æ

### è·¯ç”±åŒ¹é…è§„åˆ™

```go
package main

import (
    "github.com/gin-gonic/gin"
)

func routePatterns() {
    r := gin.Default()
    
    // ===== 1. é™æ€è·¯ç”±ï¼ˆç²¾ç¡®åŒ¹é…ï¼‰=====
    r.GET("/users", func(c *gin.Context) {
        c.JSON(200, gin.H{"message": "list users"})
    })
    
    // ===== 2. è·¯å¾„å‚æ•°ï¼ˆ:paramï¼‰=====
    r.GET("/users/:id", func(c *gin.Context) {
        id := c.Param("id")
        c.JSON(200, gin.H{"user_id": id})
    })
    
    r.GET("/posts/:category/:id", func(c *gin.Context) {
        category := c.Param("category")
        id := c.Param("id")
        c.JSON(200, gin.H{
            "category": category,
            "id":       id,
        })
    })
    
    // ===== 3. é€šé…ç¬¦è·¯ç”±ï¼ˆ*pathï¼‰=====
    r.GET("/static/*filepath", func(c *gin.Context) {
        filepath := c.Param("filepath")
        // filepath = /css/style.css
        c.String(200, "File: %s", filepath)
    })
    
    // ===== 4. æŸ¥è¯¢å‚æ•° =====
    r.GET("/search", func(c *gin.Context) {
        // /search?q=golang&page=1
        query := c.Query("q")              // å¿…éœ€å‚æ•°ï¼ˆç¼ºå°‘è¿”å›ç©ºå­—ç¬¦ä¸²ï¼‰
        page := c.DefaultQuery("page", "1") // å¯é€‰å‚æ•°ï¼ˆé»˜è®¤å€¼ï¼‰
        
        c.JSON(200, gin.H{
            "query": query,
            "page":  page,
        })
    })
    
    // ===== 5. è·¯ç”±ä¼˜å…ˆçº§ =====
    // ä¼˜å…ˆçº§ï¼šé™æ€ > å‚æ•° > é€šé…ç¬¦
    r.GET("/admin/dashboard", func(c *gin.Context) {
        c.String(200, "Admin dashboard")
    })
    
    r.GET("/admin/:page", func(c *gin.Context) {
        page := c.Param("page")
        c.String(200, "Admin page: %s", page)
    })
    
    r.GET("/admin/*action", func(c *gin.Context) {
        action := c.Param("action")
        c.String(200, "Admin action: %s", action)
    })
    
    /*
    åŒ¹é…æµ‹è¯•:
    /admin/dashboard   â†’ "Admin dashboard" (é™æ€è·¯ç”±)
    /admin/users       â†’ "Admin page: users" (å‚æ•°è·¯ç”±)
    /admin/settings/profile â†’ "Admin action: /settings/profile" (é€šé…ç¬¦è·¯ç”±)
    */
    
    r.Run(":8080")
}
```

---

### å®æˆ˜æ¡ˆä¾‹2ï¼šRESTful APIè®¾è®¡

```go
package main

import (
    "net/http"
    
    "github.com/gin-gonic/gin"
)

// ===== ç”¨æˆ·æ¨¡å‹ =====
type User struct {
    ID    int64  `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

// ===== ç”¨æˆ·Controller =====
type UserController struct {
    users map[int64]*User
    nextID int64
}

func NewUserController() *UserController {
    return &UserController{
        users:  make(map[int64]*User),
        nextID: 1,
    }
}

// List - GET /users
func (uc *UserController) List(c *gin.Context) {
    var users []*User
    for _, user := range uc.users {
        users = append(users, user)
    }
    
    c.JSON(http.StatusOK, gin.H{
        "data": users,
        "total": len(users),
    })
}

// Create - POST /users
func (uc *UserController) Create(c *gin.Context) {
    var user User
    if err := c.ShouldBindJSON(&user); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    user.ID = uc.nextID
    uc.nextID++
    uc.users[user.ID] = &user
    
    c.JSON(http.StatusCreated, gin.H{"data": user})
}

// Get - GET /users/:id
func (uc *UserController) Get(c *gin.Context) {
    id := c.Param("id")
    
    var userID int64
    if _, err := fmt.Sscanf(id, "%d", &userID); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
        return
    }
    
    user, exists := uc.users[userID]
    if !exists {
        c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{"data": user})
}

// Update - PUT /users/:id
func (uc *UserController) Update(c *gin.Context) {
    id := c.Param("id")
    
    var userID int64
    fmt.Sscanf(id, "%d", &userID)
    
    user, exists := uc.users[userID]
    if !exists {
        c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
        return
    }
    
    var updates User
    if err := c.ShouldBindJSON(&updates); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    user.Name = updates.Name
    user.Email = updates.Email
    
    c.JSON(http.StatusOK, gin.H{"data": user})
}

// Delete - DELETE /users/:id
func (uc *UserController) Delete(c *gin.Context) {
    id := c.Param("id")
    
    var userID int64
    fmt.Sscanf(id, "%d", &userID)
    
    if _, exists := uc.users[userID]; !exists {
        c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
        return
    }
    
    delete(uc.users, userID)
    
    c.JSON(http.StatusOK, gin.H{"message": "User deleted"})
}

// ===== è·¯ç”±æ³¨å†Œ =====
func setupRESTfulRoutes() {
    r := gin.Default()
    
    uc := NewUserController()
    
    // RESTful APIè·¯ç”±
    api := r.Group("/api/v1")
    {
        users := api.Group("/users")
        {
            users.GET("", uc.List)        // åˆ—è¡¨
            users.POST("", uc.Create)     // åˆ›å»º
            users.GET("/:id", uc.Get)     // è¯¦æƒ…
            users.PUT("/:id", uc.Update)  // æ›´æ–°
            users.DELETE("/:id", uc.Delete) // åˆ é™¤
        }
    }
    
    r.Run(":8080")
}

func main() {
    setupRESTfulRoutes()
}
```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šä¸­é—´ä»¶å®Œæ•´å®æˆ˜

### ä¸­é—´ä»¶æ‰§è¡Œæµç¨‹ï¼ˆæ´‹è‘±æ¨¡å‹ï¼‰

```text
Request
   â†“
[â”€â”€â”€â”€â”€â”€ Middleware 1 å¼€å§‹ â”€â”€â”€â”€â”€â”€]
   â†“
   [â”€â”€â”€â”€ Middleware 2 å¼€å§‹ â”€â”€â”€â”€]
      â†“
      [â”€â”€ Middleware 3 å¼€å§‹ â”€â”€]
         â†“
       Handlerå¤„ç†è¯·æ±‚
         â†“
      [â”€â”€ Middleware 3 ç»“æŸ â”€â”€]
   â†“
   [â”€â”€â”€â”€ Middleware 2 ç»“æŸ â”€â”€â”€â”€]
â†“
[â”€â”€â”€â”€â”€â”€ Middleware 1 ç»“æŸ â”€â”€â”€â”€â”€â”€]
   â†“
Response
```

---

### å®æˆ˜æ¡ˆä¾‹3ï¼šè‡ªå®šä¹‰ä¸­é—´ä»¶å®Œæ•´å®ç°

```go
package main

import (
    "fmt"
    "log"
    "net/http"
    "runtime/debug"
    "strings"
    "sync"
    "time"
    
    "github.com/gin-gonic/gin"
)

// ===== 1. æ—¥å¿—ä¸­é—´ä»¶ =====
func LoggerMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        path := c.Request.URL.Path
        raw := c.Request.URL.RawQuery
        
        // å¤„ç†è¯·æ±‚
        c.Next()
        
        // è¯·æ±‚å®Œæˆåè®°å½•æ—¥å¿—
        latency := time.Since(start)
        clientIP := c.ClientIP()
        method := c.Request.Method
        statusCode := c.Writer.Status()
        
        if raw != "" {
            path = path + "?" + raw
        }
        
        log.Printf("[GIN] %v | %3d | %13v | %15s | %-7s %s",
            start.Format("2006/01/02 - 15:04:05"),
            statusCode,
            latency,
            clientIP,
            method,
            path,
        )
    }
}

// ===== 2. Recoveryä¸­é—´ä»¶ï¼ˆæ•è·panicï¼‰=====
func RecoveryMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        defer func() {
            if err := recover(); err != nil {
                // æ‰“å°å †æ ˆä¿¡æ¯
                log.Printf("Panic recovered: %v\n%s", err, debug.Stack())
                
                // è¿”å›500é”™è¯¯
                c.JSON(http.StatusInternalServerError, gin.H{
                    "error": "Internal Server Error",
                })
                
                c.Abort()
            }
        }()
        
        c.Next()
    }
}

// ===== 3. CORSä¸­é—´ä»¶ =====
func CORSMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
        c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
        c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
        c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE")
        
        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(http.StatusNoContent)
            return
        }
        
        c.Next()
    }
}

// ===== 4. è®¤è¯ä¸­é—´ä»¶ =====
func AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // ä»Headerè·å–Token
        token := c.GetHeader("Authorization")
        
        // ç§»é™¤"Bearer "å‰ç¼€
        if len(token) > 7 && strings.HasPrefix(token, "Bearer ") {
            token = token[7:]
        }
        
        // éªŒè¯Tokenï¼ˆç®€åŒ–ç‰ˆï¼‰
        if token == "" || token != "valid-token-123" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
            c.Abort() // ç»ˆæ­¢åç»­å¤„ç†
            return
        }
        
        // å°†ç”¨æˆ·ä¿¡æ¯å­˜å…¥Context
        c.Set("userID", 123)
        c.Set("username", "alice")
        
        c.Next()
    }
}

// ===== 5. é™æµä¸­é—´ä»¶ï¼ˆä»¤ç‰Œæ¡¶ï¼‰=====
type RateLimiter struct {
    mu         sync.Mutex
    tokens     int
    maxTokens  int
    refillRate int           // æ¯ç§’refillçš„tokenæ•°
    lastRefill time.Time
}

func NewRateLimiter(maxTokens, refillRate int) *RateLimiter {
    return &RateLimiter{
        tokens:     maxTokens,
        maxTokens:  maxTokens,
        refillRate: refillRate,
        lastRefill: time.Now(),
    }
}

func (rl *RateLimiter) Allow() bool {
    rl.mu.Lock()
    defer rl.mu.Unlock()
    
    // è¡¥å……token
    elapsed := time.Since(rl.lastRefill)
    if elapsed >= time.Second {
        tokensToAdd := int(elapsed.Seconds()) * rl.refillRate
        rl.tokens = min(rl.maxTokens, rl.tokens+tokensToAdd)
        rl.lastRefill = time.Now()
    }
    
    // æ£€æŸ¥token
    if rl.tokens > 0 {
        rl.tokens--
        return true
    }
    
    return false
}

func RateLimitMiddleware(limiter *RateLimiter) gin.HandlerFunc {
    return func(c *gin.Context) {
        if !limiter.Allow() {
            c.JSON(http.StatusTooManyRequests, gin.H{
                "error": "Too many requests",
            })
            c.Abort()
            return
        }
        
        c.Next()
    }
}

// ===== 6. è¯·æ±‚IDä¸­é—´ä»¶ =====
func RequestIDMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        requestID := c.GetHeader("X-Request-ID")
        if requestID == "" {
            requestID = fmt.Sprintf("%d", time.Now().UnixNano())
        }
        
        c.Set("requestID", requestID)
        c.Writer.Header().Set("X-Request-ID", requestID)
        
        c.Next()
    }
}

// ===== 7. è¶…æ—¶ä¸­é—´ä»¶ =====
func TimeoutMiddleware(timeout time.Duration) gin.HandlerFunc {
    return func(c *gin.Context) {
        // åˆ›å»ºå¸¦è¶…æ—¶çš„Context
        ctx, cancel := context.WithTimeout(c.Request.Context(), timeout)
        defer cancel()
        
        // æ›¿æ¢è¯·æ±‚çš„Context
        c.Request = c.Request.WithContext(ctx)
        
        // åˆ›å»ºå®Œæˆchannel
        done := make(chan struct{})
        
        go func() {
            c.Next()
            close(done)
        }()
        
        select {
        case <-done:
            // æ­£å¸¸å®Œæˆ
        case <-ctx.Done():
            // è¶…æ—¶
            c.JSON(http.StatusGatewayTimeout, gin.H{
                "error": "Request timeout",
            })
            c.Abort()
        }
    }
}

// ===== ä½¿ç”¨ç¤ºä¾‹ =====
func main() {
    r := gin.New() // ä¸ä½¿ç”¨é»˜è®¤ä¸­é—´ä»¶
    
    // å…¨å±€ä¸­é—´ä»¶
    r.Use(RecoveryMiddleware())
    r.Use(LoggerMiddleware())
    r.Use(RequestIDMiddleware())
    r.Use(CORSMiddleware())
    
    // é™æµå™¨
    limiter := NewRateLimiter(10, 10) // æ¯ç§’10ä¸ªè¯·æ±‚
    
    // å…¬å¼€è·¯ç”±
    r.GET("/ping", func(c *gin.Context) {
        c.JSON(200, gin.H{"message": "pong"})
    })
    
    // éœ€è¦è®¤è¯çš„è·¯ç”±
    api := r.Group("/api")
    api.Use(AuthMiddleware())
    api.Use(RateLimitMiddleware(limiter))
    api.Use(TimeoutMiddleware(5 * time.Second))
    {
        api.GET("/profile", func(c *gin.Context) {
            username := c.GetString("username")
            c.JSON(200, gin.H{"username": username})
        })
    }
    
    r.Run(":8080")
}
```

---

## ç¬¬å››éƒ¨åˆ†ï¼šè¯·æ±‚å¤„ç†ä¸å‚æ•°ç»‘å®š

### å‚æ•°ç»‘å®šå®Œæ•´æŒ‡å—

```go
package main

import (
    "net/http"
    
    "github.com/gin-gonic/gin"
)

// ===== 1. JSONç»‘å®š =====
type CreateUserRequest struct {
    Name     string `json:"name" binding:"required"`
    Email    string `json:"email" binding:"required,email"`
    Age      int    `json:"age" binding:"required,gte=1,lte=150"`
    Password string `json:"password" binding:"required,min=8"`
}

func createUser(c *gin.Context) {
    var req CreateUserRequest
    
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusCreated, gin.H{
        "message": "User created",
        "data":    req,
    })
}

// ===== 2. æŸ¥è¯¢å‚æ•°ç»‘å®š =====
type ListQuery struct {
    Page     int    `form:"page" binding:"required,min=1"`
    PageSize int    `form:"page_size" binding:"required,min=1,max=100"`
    Keyword  string `form:"keyword"`
    Sort     string `form:"sort" binding:"oneof=asc desc"`
}

func listUsers(c *gin.Context) {
    var query ListQuery
    
    if err := c.ShouldBindQuery(&query); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "page":      query.Page,
        "page_size": query.PageSize,
        "keyword":   query.Keyword,
        "sort":      query.Sort,
    })
}

// ===== 3. è·¯å¾„å‚æ•°+æŸ¥è¯¢å‚æ•°+JSON =====
type UpdateUserRequest struct {
    Name  string `json:"name" binding:"omitempty"`
    Email string `json:"email" binding:"omitempty,email"`
}

func updateUser(c *gin.Context) {
    // è·¯å¾„å‚æ•°
    userID := c.Param("id")
    
    // æŸ¥è¯¢å‚æ•°
    force := c.DefaultQuery("force", "false")
    
    // JSON Body
    var req UpdateUserRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "user_id": userID,
        "force":   force,
        "updates": req,
    })
}

// ===== 4. è¡¨å•ç»‘å®š =====
type LoginForm struct {
    Username string `form:"username" binding:"required"`
    Password string `form:"password" binding:"required"`
    Remember bool   `form:"remember"`
}

func login(c *gin.Context) {
    var form LoginForm
    
    if err := c.ShouldBind(&form); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "message": "Login successful",
        "user":    form.Username,
    })
}

// ===== 5. Headerç»‘å®š =====
type HeaderInfo struct {
    UserAgent string `header:"User-Agent" binding:"required"`
    XRequestID string `header:"X-Request-ID"`
}

func getHeaders(c *gin.Context) {
    var headers HeaderInfo
    
    if err := c.ShouldBindHeader(&headers); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{"headers": headers})
}

// ===== 6. URIç»‘å®š =====
type URIParams struct {
    Category string `uri:"category" binding:"required"`
    ID       int64  `uri:"id" binding:"required,min=1"`
}

func getPost(c *gin.Context) {
    var params URIParams
    
    if err := c.ShouldBindUri(&params); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "category": params.Category,
        "id":       params.ID,
    })
}

func main() {
    r := gin.Default()
    
    // è·¯ç”±æ³¨å†Œ
    r.POST("/users", createUser)
    r.GET("/users", listUsers)
    r.PUT("/users/:id", updateUser)
    r.POST("/login", login)
    r.GET("/headers", getHeaders)
    r.GET("/posts/:category/:id", getPost)
    
    r.Run(":8080")
}
```

---

## ç¬¬äº”éƒ¨åˆ†ï¼šå“åº”æ¸²æŸ“ä¸æ ¼å¼åŒ–

### å®æˆ˜æ¡ˆä¾‹4ï¼šå¤šç§å“åº”æ ¼å¼

```go
package main

import (
 "net/http"
 "time"

 "github.com/gin-gonic/gin"
)

// ===== 1. JSONå“åº” =====
func jsonResponse(c *gin.Context) {
 // gin.H æ˜¯ map[string]interface{} çš„åˆ«å
 c.JSON(http.StatusOK, gin.H{
  "message": "Success",
  "data": gin.H{
   "id":   1,
   "name": "Alice",
  },
  "timestamp": time.Now().Unix(),
 })
}

// ä½¿ç”¨ç»“æ„ä½“
type Response struct {
 Code    int         `json:"code"`
 Message string      `json:"message"`
 Data    interface{} `json:"data"`
}

func structResponse(c *gin.Context) {
 resp := Response{
  Code:    200,
  Message: "Success",
  Data: map[string]interface{}{
   "id":   1,
   "name": "Alice",
  },
 }
 c.JSON(http.StatusOK, resp)
}

// ===== 2. XMLå“åº” =====
type XMLUser struct {
 ID    int64  `xml:"id"`
 Name  string `xml:"name"`
 Email string `xml:"email"`
}

func xmlResponse(c *gin.Context) {
 user := XMLUser{
  ID:    1,
  Name:  "Alice",
  Email: "alice@example.com",
 }
 c.XML(http.StatusOK, user)
}

// ===== 3. YAMLå“åº” =====
func yamlResponse(c *gin.Context) {
 c.YAML(http.StatusOK, gin.H{
  "name":  "Alice",
  "age":   25,
  "email": "alice@example.com",
 })
}

// ===== 4. HTMLå“åº” =====
func htmlResponse(c *gin.Context) {
 c.HTML(http.StatusOK, "index.html", gin.H{
  "title": "Home Page",
  "user":  "Alice",
 })
}

// ===== 5. å­—ç¬¦ä¸²å“åº” =====
func stringResponse(c *gin.Context) {
 c.String(http.StatusOK, "Hello, %s!", "World")
}

// ===== 6. é‡å®šå‘ =====
func redirectResponse(c *gin.Context) {
 // HTTPé‡å®šå‘
 c.Redirect(http.StatusMovedPermanently, "https://google.com")
 
 // è·¯ç”±é‡å®šå‘
 // c.Request.URL.Path = "/new-path"
 // r.HandleContext(c)
}

// ===== 7. æ–‡ä»¶å“åº” =====
func fileResponse(c *gin.Context) {
 c.File("./files/document.pdf")
}

// ===== 8. æ•°æ®æµå“åº” =====
func streamResponse(c *gin.Context) {
 c.Stream(func(w io.Writer) bool {
  // æ¨¡æ‹Ÿæµå¼æ•°æ®
  fmt.Fprintf(w, "data: %s\n\n", time.Now().Format(time.RFC3339))
  time.Sleep(time.Second)
  return true // è¿”å›falseåœæ­¢æµ
 })
}

// ===== 9. è®¾ç½®å“åº”å¤´ =====
func customHeaders(c *gin.Context) {
 c.Header("X-Custom-Header", "CustomValue")
 c.Header("Cache-Control", "no-cache")
 
 c.JSON(http.StatusOK, gin.H{"message": "With custom headers"})
}

// ===== 10. ç»Ÿä¸€å“åº”æ ¼å¼ =====
type APIResponse struct {
 Code    int         `json:"code"`
 Message string      `json:"message"`
 Data    interface{} `json:"data,omitempty"`
 Error   string      `json:"error,omitempty"`
}

func Success(c *gin.Context, data interface{}) {
 c.JSON(http.StatusOK, APIResponse{
  Code:    200,
  Message: "Success",
  Data:    data,
 })
}

func Error(c *gin.Context, code int, message string) {
 c.JSON(code, APIResponse{
  Code:    code,
  Message: "Error",
  Error:   message,
 })
}

func exampleHandler(c *gin.Context) {
 // ä½¿ç”¨ç»Ÿä¸€å“åº”
 Success(c, gin.H{
  "id":   1,
  "name": "Alice",
 })
}
```

---

## ç¬¬å…­éƒ¨åˆ†ï¼šæ•°æ®éªŒè¯æ·±åº¦å®æˆ˜

### å®æˆ˜æ¡ˆä¾‹5ï¼švalidatorå®Œæ•´éªŒè¯

```go
package main

import (
 "net/http"
 "time"

 "github.com/gin-gonic/gin"
 "github.com/go-playground/validator/v10"
)

// ===== 1. åŸºç¡€éªŒè¯ =====
type RegisterRequest struct {
 Username string `json:"username" binding:"required,min=3,max=20,alphanum"`
 Email    string `json:"email" binding:"required,email"`
 Password string `json:"password" binding:"required,min=8,max=32"`
 Age      int    `json:"age" binding:"required,gte=18,lte=100"`
 Gender   string `json:"gender" binding:"required,oneof=male female other"`
}

func register(c *gin.Context) {
 var req RegisterRequest
 
 if err := c.ShouldBindJSON(&req); err != nil {
  c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
  return
 }
 
 c.JSON(http.StatusOK, gin.H{"message": "Registration successful"})
}

// ===== 2. è‡ªå®šä¹‰éªŒè¯å™¨ =====
type BookingRequest struct {
 CheckIn  time.Time `json:"check_in" binding:"required" time_format:"2006-01-02"`
 CheckOut time.Time `json:"check_out" binding:"required,gtefield=CheckIn" time_format:"2006-01-02"`
}

// æ³¨å†Œè‡ªå®šä¹‰éªŒè¯å™¨
func setupCustomValidators(r *gin.Engine) {
 if v, ok := binding.Validator.Engine().(*validator.Validate); ok {
  // è‡ªå®šä¹‰éªŒè¯ï¼šæ—¥æœŸä¸èƒ½æ˜¯è¿‡å»
  v.RegisterValidation("futuredate", func(fl validator.FieldLevel) bool {
   date, ok := fl.Field().Interface().(time.Time)
   if !ok {
    return false
   }
   return date.After(time.Now())
  })
 }
}

// ===== 3. è·¨å­—æ®µéªŒè¯ =====
type ChangePasswordRequest struct {
 OldPassword     string `json:"old_password" binding:"required"`
 NewPassword     string `json:"new_password" binding:"required,min=8,nefield=OldPassword"`
 ConfirmPassword string `json:"confirm_password" binding:"required,eqfield=NewPassword"`
}

func changePassword(c *gin.Context) {
 var req ChangePasswordRequest
 
 if err := c.ShouldBindJSON(&req); err != nil {
  c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
  return
 }
 
 c.JSON(http.StatusOK, gin.H{"message": "Password changed"})
}

// ===== 4. åµŒå¥—ç»“æ„éªŒè¯ =====
type Address struct {
 Street  string `json:"street" binding:"required"`
 City    string `json:"city" binding:"required"`
 ZipCode string `json:"zip_code" binding:"required,len=5,numeric"`
}

type UserProfile struct {
 Name    string  `json:"name" binding:"required"`
 Email   string  `json:"email" binding:"required,email"`
 Address Address `json:"address" binding:"required"`
}

func createProfile(c *gin.Context) {
 var req UserProfile
 
 if err := c.ShouldBindJSON(&req); err != nil {
  c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
  return
 }
 
 c.JSON(http.StatusCreated, gin.H{"data": req})
}

// ===== 5. æ•°ç»„éªŒè¯ =====
type BatchCreateRequest struct {
 Users []struct {
  Name  string `json:"name" binding:"required"`
  Email string `json:"email" binding:"required,email"`
 } `json:"users" binding:"required,min=1,max=10,dive"`
}

func batchCreate(c *gin.Context) {
 var req BatchCreateRequest
 
 if err := c.ShouldBindJSON(&req); err != nil {
  c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
  return
 }
 
 c.JSON(http.StatusCreated, gin.H{
  "message": "Users created",
  "count":   len(req.Users),
 })
}

// ===== 6. è‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯ =====
func getValidationErrors(err error) map[string]string {
 errors := make(map[string]string)
 
 if validationErrors, ok := err.(validator.ValidationErrors); ok {
  for _, e := range validationErrors {
   field := e.Field()
   tag := e.Tag()
   
   switch tag {
   case "required":
    errors[field] = field + " is required"
   case "email":
    errors[field] = field + " must be a valid email"
   case "min":
    errors[field] = field + " must be at least " + e.Param() + " characters"
   case "max":
    errors[field] = field + " must be at most " + e.Param() + " characters"
   default:
    errors[field] = field + " is invalid"
   }
  }
 }
 
 return errors
}

func registerWithCustomError(c *gin.Context) {
 var req RegisterRequest
 
 if err := c.ShouldBindJSON(&req); err != nil {
  errors := getValidationErrors(err)
  c.JSON(http.StatusBadRequest, gin.H{"errors": errors})
  return
 }
 
 c.JSON(http.StatusOK, gin.H{"message": "Success"})
}
```

---

## ç¬¬ä¸ƒéƒ¨åˆ†ï¼šæ–‡ä»¶ä¸Šä¼ ä¸‹è½½

### å®æˆ˜æ¡ˆä¾‹6ï¼šæ–‡ä»¶æ“ä½œå®Œæ•´å®ç°

```go
package main

import (
 "fmt"
 "io"
 "mime/multipart"
 "net/http"
 "os"
 "path/filepath"
 "strings"
 "time"

 "github.com/gin-gonic/gin"
)

// ===== 1. å•æ–‡ä»¶ä¸Šä¼  =====
func uploadSingleFile(c *gin.Context) {
 file, err := c.FormFile("file")
 if err != nil {
  c.JSON(http.StatusBadRequest, gin.H{"error": "No file uploaded"})
  return
 }

 // éªŒè¯æ–‡ä»¶ç±»å‹
 allowedExts := []string{".jpg", ".jpeg", ".png", ".gif"}
 ext := strings.ToLower(filepath.Ext(file.Filename))
 
 allowed := false
 for _, allowedExt := range allowedExts {
  if ext == allowedExt {
   allowed = true
   break
  }
 }
 
 if !allowed {
  c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid file type"})
  return
 }

 // éªŒè¯æ–‡ä»¶å¤§å°ï¼ˆ5MBï¼‰
 if file.Size > 5*1024*1024 {
  c.JSON(http.StatusBadRequest, gin.H{"error": "File too large"})
  return
 }

 // ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
 filename := fmt.Sprintf("%d_%s", time.Now().Unix(), file.Filename)
 savePath := filepath.Join("uploads", filename)

 // ä¿å­˜æ–‡ä»¶
 if err := c.SaveUploadedFile(file, savePath); err != nil {
  c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save file"})
  return
 }

 c.JSON(http.StatusOK, gin.H{
  "message":  "File uploaded successfully",
  "filename": filename,
  "size":     file.Size,
 })
}

// ===== 2. å¤šæ–‡ä»¶ä¸Šä¼  =====
func uploadMultipleFiles(c *gin.Context) {
 form, err := c.MultipartForm()
 if err != nil {
  c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
  return
 }

 files := form.File["files"]
 if len(files) == 0 {
  c.JSON(http.StatusBadRequest, gin.H{"error": "No files uploaded"})
  return
 }

 // é™åˆ¶æ–‡ä»¶æ•°é‡
 if len(files) > 10 {
  c.JSON(http.StatusBadRequest, gin.H{"error": "Too many files"})
  return
 }

 var uploadedFiles []string

 for _, file := range files {
  filename := fmt.Sprintf("%d_%s", time.Now().UnixNano(), file.Filename)
  savePath := filepath.Join("uploads", filename)

  if err := c.SaveUploadedFile(file, savePath); err != nil {
   c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save file"})
   return
  }

  uploadedFiles = append(uploadedFiles, filename)
 }

 c.JSON(http.StatusOK, gin.H{
  "message": "Files uploaded successfully",
  "files":   uploadedFiles,
  "count":   len(uploadedFiles),
 })
}

// ===== 3. æ–‡ä»¶ä¸‹è½½ =====
func downloadFile(c *gin.Context) {
 filename := c.Param("filename")
 
 // éªŒè¯æ–‡ä»¶åï¼ˆé˜²æ­¢è·¯å¾„éå†æ”»å‡»ï¼‰
 if strings.Contains(filename, "..") || strings.Contains(filename, "/") {
  c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid filename"})
  return
 }

 filepath := filepath.Join("uploads", filename)

 // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
 if _, err := os.Stat(filepath); os.IsNotExist(err) {
  c.JSON(http.StatusNotFound, gin.H{"error": "File not found"})
  return
 }

 // è®¾ç½®å“åº”å¤´
 c.Header("Content-Description", "File Transfer")
 c.Header("Content-Transfer-Encoding", "binary")
 c.Header("Content-Disposition", "attachment; filename="+filename)
 c.Header("Content-Type", "application/octet-stream")

 c.File(filepath)
}

// ===== 4. æ–‡ä»¶æµå¼ä¸Šä¼  =====
func uploadStream(c *gin.Context) {
 reader, err := c.Request.MultipartReader()
 if err != nil {
  c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
  return
 }

 for {
  part, err := reader.NextPart()
  if err == io.EOF {
   break
  }
  if err != nil {
   c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
   return
  }

  filename := fmt.Sprintf("%d_%s", time.Now().UnixNano(), part.FileName())
  savePath := filepath.Join("uploads", filename)

  dst, err := os.Create(savePath)
  if err != nil {
   c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
   return
  }

  if _, err := io.Copy(dst, part); err != nil {
   dst.Close()
   c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
   return
  }

  dst.Close()
 }

 c.JSON(http.StatusOK, gin.H{"message": "Files uploaded successfully"})
}

// ===== 5. å›¾ç‰‡å¤„ç†ä¸ä¸Šä¼  =====
func uploadImage(c *gin.Context) {
 file, err := c.FormFile("image")
 if err != nil {
  c.JSON(http.StatusBadRequest, gin.H{"error": "No image uploaded"})
  return
 }

 // éªŒè¯MIMEç±»å‹
 allowedTypes := []string{"image/jpeg", "image/png", "image/gif"}
 
 src, err := file.Open()
 if err != nil {
  c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
  return
 }
 defer src.Close()

 // è¯»å–æ–‡ä»¶å¤´åˆ¤æ–­ç±»å‹
 buffer := make([]byte, 512)
 if _, err := src.Read(buffer); err != nil {
  c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
  return
 }

 contentType := http.DetectContentType(buffer)
 
 allowed := false
 for _, allowedType := range allowedTypes {
  if contentType == allowedType {
   allowed = true
   break
  }
 }

 if !allowed {
  c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid image type"})
  return
 }

 // é‡ç½®è¯»å–ä½ç½®
 src.Seek(0, 0)

 // ä¿å­˜æ–‡ä»¶
 filename := fmt.Sprintf("%d_%s", time.Now().Unix(), file.Filename)
 savePath := filepath.Join("uploads", "images", filename)

 dst, err := os.Create(savePath)
 if err != nil {
  c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
  return
 }
 defer dst.Close()

 if _, err := io.Copy(dst, src); err != nil {
  c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
  return
 }

 c.JSON(http.StatusOK, gin.H{
  "message":      "Image uploaded successfully",
  "filename":     filename,
  "content_type": contentType,
  "size":         file.Size,
 })
}
```

---

## ç¬¬å…«éƒ¨åˆ†ï¼šWebSocketå®æ—¶é€šä¿¡

### å®æˆ˜æ¡ˆä¾‹7ï¼šWebSocketèŠå¤©å®¤

```go
package main

import (
 "log"
 "net/http"
 "sync"
 "time"

 "github.com/gin-gonic/gin"
 "github.com/gorilla/websocket"
)

var upgrader = websocket.Upgrader{
 CheckOrigin: func(r *http.Request) bool {
  return true // ç”Ÿäº§ç¯å¢ƒåº”ä¸¥æ ¼éªŒè¯
 },
}

// ===== æ¶ˆæ¯ç±»å‹ =====
type Message struct {
 Type      string    `json:"type"`      // join, leave, message
 Username  string    `json:"username"`
 Content   string    `json:"content"`
 Timestamp time.Time `json:"timestamp"`
}

// ===== å®¢æˆ·ç«¯è¿æ¥ =====
type Client struct {
 ID       string
 Username string
 Conn     *websocket.Conn
 Send     chan Message
 Hub      *Hub
}

// ===== Hubç®¡ç†æ‰€æœ‰å®¢æˆ·ç«¯ =====
type Hub struct {
 clients    map[string]*Client
 broadcast  chan Message
 register   chan *Client
 unregister chan *Client
 mu         sync.RWMutex
}

func NewHub() *Hub {
 return &Hub{
  clients:    make(map[string]*Client),
  broadcast:  make(chan Message, 256),
  register:   make(chan *Client),
  unregister: make(chan *Client),
 }
}

// Hubè¿è¡Œ
func (h *Hub) Run() {
 for {
  select {
  case client := <-h.register:
   h.mu.Lock()
   h.clients[client.ID] = client
   h.mu.Unlock()

   // å¹¿æ’­ç”¨æˆ·åŠ å…¥æ¶ˆæ¯
   h.broadcast <- Message{
    Type:      "join",
    Username:  client.Username,
    Content:   client.Username + " joined the chat",
    Timestamp: time.Now(),
   }

  case client := <-h.unregister:
   h.mu.Lock()
   if _, ok := h.clients[client.ID]; ok {
    delete(h.clients, client.ID)
    close(client.Send)
   }
   h.mu.Unlock()

   // å¹¿æ’­ç”¨æˆ·ç¦»å¼€æ¶ˆæ¯
   h.broadcast <- Message{
    Type:      "leave",
    Username:  client.Username,
    Content:   client.Username + " left the chat",
    Timestamp: time.Now(),
   }

  case message := <-h.broadcast:
   h.mu.RLock()
   for _, client := range h.clients {
    select {
    case client.Send <- message:
    default:
     close(client.Send)
     delete(h.clients, client.ID)
    }
   }
   h.mu.RUnlock()
  }
 }
}

// å®¢æˆ·ç«¯è¯»å–æ¶ˆæ¯
func (c *Client) ReadPump() {
 defer func() {
  c.Hub.unregister <- c
  c.Conn.Close()
 }()

 c.Conn.SetReadDeadline(time.Now().Add(60 * time.Second))
 c.Conn.SetPongHandler(func(string) error {
  c.Conn.SetReadDeadline(time.Now().Add(60 * time.Second))
  return nil
 })

 for {
  var msg Message
  if err := c.Conn.ReadJSON(&msg); err != nil {
   if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
    log.Printf("Error: %v", err)
   }
   break
  }

  msg.Username = c.Username
  msg.Timestamp = time.Now()
  msg.Type = "message"

  c.Hub.broadcast <- msg
 }
}

// å®¢æˆ·ç«¯å†™å…¥æ¶ˆæ¯
func (c *Client) WritePump() {
 ticker := time.NewTicker(54 * time.Second)
 defer func() {
  ticker.Stop()
  c.Conn.Close()
 }()

 for {
  select {
  case message, ok := <-c.Send:
   c.Conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
   if !ok {
    c.Conn.WriteMessage(websocket.CloseMessage, []byte{})
    return
   }

   if err := c.Conn.WriteJSON(message); err != nil {
    return
   }

  case <-ticker.C:
   c.Conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
   if err := c.Conn.WriteMessage(websocket.PingMessage, nil); err != nil {
    return
   }
  }
 }
}

// ===== WebSocketå¤„ç†å™¨ =====
func wsHandler(hub *Hub) gin.HandlerFunc {
 return func(c *gin.Context) {
  username := c.Query("username")
  if username == "" {
   c.JSON(http.StatusBadRequest, gin.H{"error": "Username required"})
   return
  }

  conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
  if err != nil {
   log.Println("Upgrade error:", err)
   return
  }

  client := &Client{
   ID:       fmt.Sprintf("%d", time.Now().UnixNano()),
   Username: username,
   Conn:     conn,
   Send:     make(chan Message, 256),
   Hub:      hub,
  }

  client.Hub.register <- client

  go client.WritePump()
  go client.ReadPump()
 }
}

func setupWebSocket() {
 r := gin.Default()

 hub := NewHub()
 go hub.Run()

 r.GET("/ws", wsHandler(hub))
 r.StaticFile("/", "./static/chat.html")

 r.Run(":8080")
}
```

---

## ç¬¬ä¹éƒ¨åˆ†ï¼šGinæ€§èƒ½ä¼˜åŒ–

### å®æˆ˜æ¡ˆä¾‹8ï¼šæ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ

```go
package main

import (
 "context"
 "net/http"
 "time"

 "github.com/gin-gonic/gin"
)

// ===== 1. ä½¿ç”¨ReleaseMode =====
func setupReleaseMode() *gin.Engine {
 // ç”Ÿäº§ç¯å¢ƒä½¿ç”¨Releaseæ¨¡å¼
 gin.SetMode(gin.ReleaseMode)
 r := gin.New()
 
 // åªæ·»åŠ å¿…è¦çš„ä¸­é—´ä»¶
 r.Use(gin.Recovery())
 
 return r
}

// ===== 2. è¿æ¥æ± ä¼˜åŒ– =====
func setupHTTPServer(r *gin.Engine) *http.Server {
 return &http.Server{
  Addr:           ":8080",
  Handler:        r,
  ReadTimeout:    10 * time.Second,
  WriteTimeout:   10 * time.Second,
  MaxHeaderBytes: 1 << 20, // 1MB
  IdleTimeout:    120 * time.Second,
 }
}

// ===== 3. ä¼˜é›…å…³é—­ =====
func gracefulShutdown() {
 r := gin.Default()

 r.GET("/ping", func(c *gin.Context) {
  c.JSON(200, gin.H{"message": "pong"})
 })

 srv := &http.Server{
  Addr:    ":8080",
  Handler: r,
 }

 // å¯åŠ¨æœåŠ¡å™¨
 go func() {
  if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
   log.Fatalf("listen: %s\n", err)
  }
 }()

 // ç­‰å¾…ä¸­æ–­ä¿¡å·
 quit := make(chan os.Signal, 1)
 signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
 <-quit
 log.Println("Shutting down server...")

 // 5ç§’è¶…æ—¶å…³é—­
 ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
 defer cancel()

 if err := srv.Shutdown(ctx); err != nil {
  log.Fatal("Server forced to shutdown:", err)
 }

 log.Println("Server exiting")
}

// ===== 4. å“åº”ç¼“å­˜ =====
type CachedResponse struct {
 Data      []byte
 Timestamp time.Time
 TTL       time.Duration
}

var responseCache sync.Map

func CacheMiddleware(ttl time.Duration) gin.HandlerFunc {
 return func(c *gin.Context) {
  // åªç¼“å­˜GETè¯·æ±‚
  if c.Request.Method != "GET" {
   c.Next()
   return
  }

  cacheKey := c.Request.URL.String()

  // æ£€æŸ¥ç¼“å­˜
  if cached, ok := responseCache.Load(cacheKey); ok {
   cachedResp := cached.(*CachedResponse)
   
   // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
   if time.Since(cachedResp.Timestamp) < cachedResp.TTL {
    c.Data(http.StatusOK, "application/json", cachedResp.Data)
    c.Abort()
    return
   }
   
   // åˆ é™¤è¿‡æœŸç¼“å­˜
   responseCache.Delete(cacheKey)
  }

  // åˆ›å»ºResponseWriteråŒ…è£…
  writer := &responseWriter{
   ResponseWriter: c.Writer,
   body:           &bytes.Buffer{},
  }
  c.Writer = writer

  c.Next()

  // ç¼“å­˜å“åº”
  if c.Writer.Status() == http.StatusOK {
   responseCache.Store(cacheKey, &CachedResponse{
    Data:      writer.body.Bytes(),
    Timestamp: time.Now(),
    TTL:       ttl,
   })
  }
 }
}

type responseWriter struct {
 gin.ResponseWriter
 body *bytes.Buffer
}

func (w *responseWriter) Write(b []byte) (int, error) {
 w.body.Write(b)
 return w.ResponseWriter.Write(b)
}

// ===== 5. Gzipå‹ç¼© =====
func GzipMiddleware() gin.HandlerFunc {
 return gzip.Gzip(gzip.DefaultCompression)
}

// ===== 6. æ•°æ®åº“è¿æ¥æ±  =====
type DBPool struct {
 db *sql.DB
}

func NewDBPool(dsn string) (*DBPool, error) {
 db, err := sql.Open("mysql", dsn)
 if err != nil {
  return nil, err
 }

 // è¿æ¥æ± é…ç½®
 db.SetMaxOpenConns(100)          // æœ€å¤§æ‰“å¼€è¿æ¥æ•°
 db.SetMaxIdleConns(10)           // æœ€å¤§ç©ºé—²è¿æ¥æ•°
 db.SetConnMaxLifetime(time.Hour) // è¿æ¥æœ€å¤§ç”Ÿå­˜æ—¶é—´

 return &DBPool{db: db}, nil
}
```

---

## ç¬¬åéƒ¨åˆ†ï¼šGinæµ‹è¯•æœ€ä½³å®è·µ

### å®æˆ˜æ¡ˆä¾‹9ï¼šå•å…ƒæµ‹è¯•å®Œæ•´å®ç°

```go
package main

import (
 "bytes"
 "encoding/json"
 "net/http"
 "net/http/httptest"
 "testing"

 "github.com/gin-gonic/gin"
 "github.com/stretchr/testify/assert"
)

// ===== æµ‹è¯•è·¯ç”± =====
func setupTestRouter() *gin.Engine {
 gin.SetMode(gin.TestMode)
 r := gin.Default()

 r.GET("/ping", func(c *gin.Context) {
  c.JSON(200, gin.H{"message": "pong"})
 })

 r.POST("/users", func(c *gin.Context) {
  var user User
  if err := c.ShouldBindJSON(&user); err != nil {
   c.JSON(400, gin.H{"error": err.Error()})
   return
  }
  c.JSON(201, gin.H{"data": user})
 })

 return r
}

// ===== æµ‹è¯•GETè¯·æ±‚ =====
func TestPingRoute(t *testing.T) {
 r := setupTestRouter()

 w := httptest.NewRecorder()
 req, _ := http.NewRequest("GET", "/ping", nil)
 r.ServeHTTP(w, req)

 assert.Equal(t, 200, w.Code)

 var response map[string]string
 err := json.Unmarshal(w.Body.Bytes(), &response)
 assert.Nil(t, err)
 assert.Equal(t, "pong", response["message"])
}

// ===== æµ‹è¯•POSTè¯·æ±‚ =====
func TestCreateUser(t *testing.T) {
 r := setupTestRouter()

 user := User{
  Name:  "Alice",
  Email: "alice@example.com",
 }

 jsonValue, _ := json.Marshal(user)
 req, _ := http.NewRequest("POST", "/users", bytes.NewBuffer(jsonValue))
 req.Header.Set("Content-Type", "application/json")

 w := httptest.NewRecorder()
 r.ServeHTTP(w, req)

 assert.Equal(t, 201, w.Code)

 var response map[string]User
 err := json.Unmarshal(w.Body.Bytes(), &response)
 assert.Nil(t, err)
 assert.Equal(t, user.Name, response["data"].Name)
}

// ===== æµ‹è¯•ä¸­é—´ä»¶ =====
func TestAuthMiddleware(t *testing.T) {
 r := gin.New()
 r.Use(AuthMiddleware())

 r.GET("/protected", func(c *gin.Context) {
  c.JSON(200, gin.H{"message": "protected"})
 })

 // æµ‹è¯•æ— Token
 w1 := httptest.NewRecorder()
 req1, _ := http.NewRequest("GET", "/protected", nil)
 r.ServeHTTP(w1, req1)
 assert.Equal(t, 401, w1.Code)

 // æµ‹è¯•æœ‰æ•ˆToken
 w2 := httptest.NewRecorder()
 req2, _ := http.NewRequest("GET", "/protected", nil)
 req2.Header.Set("Authorization", "Bearer valid-token-123")
 r.ServeHTTP(w2, req2)
 assert.Equal(t, 200, w2.Code)
}

// ===== åŸºå‡†æµ‹è¯• =====
func BenchmarkPingRoute(b *testing.B) {
 r := setupTestRouter()

 b.ResetTimer()
 for i := 0; i < b.N; i++ {
  w := httptest.NewRecorder()
  req, _ := http.NewRequest("GET", "/ping", nil)
  r.ServeHTTP(w, req)
 }
}
```

---

## ç¬¬åä¸€éƒ¨åˆ†ï¼šGiné¡¹ç›®æ¶æ„è®¾è®¡

### å®æˆ˜æ¡ˆä¾‹10ï¼šåˆ†å±‚æ¶æ„è®¾è®¡

```go
// ===== é¡¹ç›®ç»“æ„ =====
/*
project/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ main.go           # å…¥å£
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ handler/          # HTTPå¤„ç†å™¨ï¼ˆControllerï¼‰
â”‚   â”‚   â”œâ”€â”€ user.go
â”‚   â”‚   â””â”€â”€ product.go
â”‚   â”œâ”€â”€ service/          # ä¸šåŠ¡é€»è¾‘ï¼ˆServiceï¼‰
â”‚   â”‚   â”œâ”€â”€ user.go
â”‚   â”‚   â””â”€â”€ product.go
â”‚   â”œâ”€â”€ repository/       # æ•°æ®è®¿é—®ï¼ˆRepositoryï¼‰
â”‚   â”‚   â”œâ”€â”€ user.go
â”‚   â”‚   â””â”€â”€ product.go
â”‚   â””â”€â”€ model/            # æ•°æ®æ¨¡å‹
â”‚       â”œâ”€â”€ user.go
â”‚       â””â”€â”€ product.go
â”œâ”€â”€ pkg/
â”‚   â”œâ”€â”€ database/         # æ•°æ®åº“è¿æ¥
â”‚   â”œâ”€â”€ middleware/       # ä¸­é—´ä»¶
â”‚   â””â”€â”€ response/         # ç»Ÿä¸€å“åº”
â””â”€â”€ config/               # é…ç½®æ–‡ä»¶
*/

// ===== 1. Modelå±‚ =====
package model

type User struct {
 ID        int64     `json:"id" gorm:"primaryKey"`
 Username  string    `json:"username" gorm:"uniqueIndex"`
 Email     string    `json:"email" gorm:"uniqueIndex"`
 CreatedAt time.Time `json:"created_at"`
 UpdatedAt time.Time `json:"updated_at"`
}

// ===== 2. Repositoryå±‚ =====
package repository

type UserRepository interface {
 Create(ctx context.Context, user *model.User) error
 GetByID(ctx context.Context, id int64) (*model.User, error)
 GetByUsername(ctx context.Context, username string) (*model.User, error)
 Update(ctx context.Context, user *model.User) error
 Delete(ctx context.Context, id int64) error
 List(ctx context.Context, offset, limit int) ([]*model.User, error)
}

type userRepository struct {
 db *gorm.DB
}

func NewUserRepository(db *gorm.DB) UserRepository {
 return &userRepository{db: db}
}

func (r *userRepository) Create(ctx context.Context, user *model.User) error {
 return r.db.WithContext(ctx).Create(user).Error
}

func (r *userRepository) GetByID(ctx context.Context, id int64) (*model.User, error) {
 var user model.User
 err := r.db.WithContext(ctx).First(&user, id).Error
 if err != nil {
  return nil, err
 }
 return &user, nil
}

// ===== 3. Serviceå±‚ =====
package service

type UserService interface {
 Register(ctx context.Context, req *RegisterRequest) (*model.User, error)
 Login(ctx context.Context, req *LoginRequest) (string, error)
 GetProfile(ctx context.Context, userID int64) (*model.User, error)
 UpdateProfile(ctx context.Context, userID int64, req *UpdateProfileRequest) error
}

type userService struct {
 userRepo repository.UserRepository
}

func NewUserService(userRepo repository.UserRepository) UserService {
 return &userService{
  userRepo: userRepo,
 }
}

func (s *userService) Register(ctx context.Context, req *RegisterRequest) (*model.User, error) {
 // æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å­˜åœ¨
 existing, _ := s.userRepo.GetByUsername(ctx, req.Username)
 if existing != nil {
  return nil, errors.New("username already exists")
 }

 // åˆ›å»ºç”¨æˆ·
 user := &model.User{
  Username: req.Username,
  Email:    req.Email,
 }

 if err := s.userRepo.Create(ctx, user); err != nil {
  return nil, err
 }

 return user, nil
}

// ===== 4. Handlerå±‚ =====
package handler

type UserHandler struct {
 userService service.UserService
}

func NewUserHandler(userService service.UserService) *UserHandler {
 return &UserHandler{
  userService: userService,
 }
}

func (h *UserHandler) Register(c *gin.Context) {
 var req RegisterRequest
 if err := c.ShouldBindJSON(&req); err != nil {
  response.Error(c, http.StatusBadRequest, err.Error())
  return
 }

 user, err := h.userService.Register(c.Request.Context(), &req)
 if err != nil {
  response.Error(c, http.StatusBadRequest, err.Error())
  return
 }

 response.Success(c, user)
}

func (h *UserHandler) GetProfile(c *gin.Context) {
 userID := c.GetInt64("userID")

 user, err := h.userService.GetProfile(c.Request.Context(), userID)
 if err != nil {
  response.Error(c, http.StatusNotFound, "User not found")
  return
 }

 response.Success(c, user)
}

// ===== 5. ä¾èµ–æ³¨å…¥ =====
package main

func main() {
 // åˆå§‹åŒ–æ•°æ®åº“
 db, err := database.NewDB()
 if err != nil {
  log.Fatal(err)
 }

 // åˆå§‹åŒ–Repository
 userRepo := repository.NewUserRepository(db)

 // åˆå§‹åŒ–Service
 userService := service.NewUserService(userRepo)

 // åˆå§‹åŒ–Handler
 userHandler := handler.NewUserHandler(userService)

 // åˆå§‹åŒ–è·¯ç”±
 r := gin.Default()
 r.Use(middleware.CORS())
 r.Use(middleware.Recovery())

 // æ³¨å†Œè·¯ç”±
 api := r.Group("/api/v1")
 {
  users := api.Group("/users")
  {
   users.POST("/register", userHandler.Register)
   users.GET("/profile", middleware.Auth(), userHandler.GetProfile)
  }
 }

 r.Run(":8080")
}
```

---

## ç¬¬åäºŒéƒ¨åˆ†ï¼šå®Œæ•´ç”µå•†APIå®æˆ˜

### å®æˆ˜æ¡ˆä¾‹11ï¼šå®Œæ•´ç”µå•†ç³»ç»Ÿ

```go
package main

// ===== äº§å“æ¨¡å‹ =====
type Product struct {
 ID          int64   `json:"id"`
 Name        string  `json:"name"`
 Description string  `json:"description"`
 Price       float64 `json:"price"`
 Stock       int     `json:"stock"`
 CategoryID  int64   `json:"category_id"`
}

// ===== è®¢å•æ¨¡å‹ =====
type Order struct {
 ID         int64     `json:"id"`
 UserID     int64     `json:"user_id"`
 TotalPrice float64   `json:"total_price"`
 Status     string    `json:"status"` // pending, paid, shipped, completed
 CreatedAt  time.Time `json:"created_at"`
}

type OrderItem struct {
 ID        int64   `json:"id"`
 OrderID   int64   `json:"order_id"`
 ProductID int64   `json:"product_id"`
 Quantity  int     `json:"quantity"`
 Price     float64 `json:"price"`
}

// ===== äº§å“Handler =====
type ProductHandler struct {
 productService ProductService
}

func (h *ProductHandler) List(c *gin.Context) {
 var query ListProductQuery
 if err := c.ShouldBindQuery(&query); err != nil {
  c.JSON(400, gin.H{"error": err.Error()})
  return
 }

 products, total, err := h.productService.List(c.Request.Context(), &query)
 if err != nil {
  c.JSON(500, gin.H{"error": err.Error()})
  return
 }

 c.JSON(200, gin.H{
  "data":  products,
  "total": total,
  "page":  query.Page,
 })
}

func (h *ProductHandler) Get(c *gin.Context) {
 id := c.Param("id")
 productID, _ := strconv.ParseInt(id, 10, 64)

 product, err := h.productService.GetByID(c.Request.Context(), productID)
 if err != nil {
  c.JSON(404, gin.H{"error": "Product not found"})
  return
 }

 c.JSON(200, gin.H{"data": product})
}

// ===== è®¢å•Handler =====
type OrderHandler struct {
 orderService OrderService
}

func (h *OrderHandler) Create(c *gin.Context) {
 userID := c.GetInt64("userID")

 var req CreateOrderRequest
 if err := c.ShouldBindJSON(&req); err != nil {
  c.JSON(400, gin.H{"error": err.Error()})
  return
 }

 order, err := h.orderService.Create(c.Request.Context(), userID, &req)
 if err != nil {
  c.JSON(400, gin.H{"error": err.Error()})
  return
 }

 c.JSON(201, gin.H{"data": order})
}

func (h *OrderHandler) GetMyOrders(c *gin.Context) {
 userID := c.GetInt64("userID")

 orders, err := h.orderService.GetUserOrders(c.Request.Context(), userID)
 if err != nil {
  c.JSON(500, gin.H{"error": err.Error()})
  return
 }

 c.JSON(200, gin.H{"data": orders})
}

// ===== è·¯ç”±æ³¨å†Œ =====
func setupECommerceRoutes(r *gin.Engine, handlers *Handlers) {
 api := r.Group("/api/v1")
 {
  // äº§å“è·¯ç”±
  products := api.Group("/products")
  {
   products.GET("", handlers.Product.List)
   products.GET("/:id", handlers.Product.Get)
  }

  // éœ€è¦è®¤è¯çš„è·¯ç”±
  auth := api.Group("")
  auth.Use(middleware.Auth())
  {
   // è®¢å•è·¯ç”±
   orders := auth.Group("/orders")
   {
    orders.POST("", handlers.Order.Create)
    orders.GET("", handlers.Order.GetMyOrders)
    orders.GET("/:id", handlers.Order.Get)
   }

   // è´­ç‰©è½¦è·¯ç”±
   cart := auth.Group("/cart")
   {
    cart.GET("", handlers.Cart.Get)
    cart.POST("/items", handlers.Cart.AddItem)
    cart.DELETE("/items/:id", handlers.Cart.RemoveItem)
   }
  }
 }
}
```

---

## ğŸ¯ æ€»ç»“

### Ginæ ¸å¿ƒè¦ç‚¹

1. **è·¯ç”±ç³»ç»Ÿ** - Radix Treeé«˜æ•ˆåŒ¹é…
2. **ä¸­é—´ä»¶** - æ´‹è‘±æ¨¡å‹ã€è´£ä»»é“¾
3. **å‚æ•°ç»‘å®š** - JSON/Form/Query/URI/Header
4. **æ•°æ®éªŒè¯** - validatoræ ‡ç­¾éªŒè¯
5. **å“åº”æ¸²æŸ“** - JSON/XML/HTML/ProtoBuf
6. **æ–‡ä»¶å¤„ç†** - ä¸Šä¼ /ä¸‹è½½/é™æ€æ–‡ä»¶
7. **WebSocket** - å®æ—¶é€šä¿¡
8. **æ€§èƒ½ä¼˜åŒ–** - Connection Poolã€ç¼“å­˜
9. **æµ‹è¯•** - httptestå®Œæ•´æ”¯æŒ
10. **æ¶æ„è®¾è®¡** - åˆ†å±‚æ¶æ„ã€ä¾èµ–æ³¨å…¥

### æœ€ä½³å®è·µæ¸…å•

```text
âœ… ä½¿ç”¨gin.Default()å¿«é€Ÿå¼€å§‹
âœ… åˆç†ä½¿ç”¨ä¸­é—´ä»¶ï¼ˆå…¨å±€vsåˆ†ç»„ï¼‰
âœ… ä½¿ç”¨å‚æ•°ç»‘å®š+éªŒè¯
âœ… ç»Ÿä¸€é”™è¯¯å¤„ç†
âœ… ä½¿ç”¨Contextä¼ é€’è¯·æ±‚èŒƒå›´æ•°æ®
âœ… è·¯ç”±åˆ†ç»„æ¨¡å—åŒ–ç®¡ç†
âœ… å®æ–½CORSç­–ç•¥
âœ… æ·»åŠ è¯·æ±‚é™æµ
âœ… è®°å½•è¯·æ±‚æ—¥å¿—
âœ… ä¼˜é›…å…³é—­æœåŠ¡å™¨
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v13.0  

<div align="center">

Made with â¤ï¸ for Gin Framework Developers

[â¬† å›åˆ°é¡¶éƒ¨](#ginæ¡†æ¶æ·±åº¦å®æˆ˜æŒ‡å—)

</div>

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ20æ—¥  
**æ–‡æ¡£çŠ¶æ€**: å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
