# Go 1.25.3 现代Web服务完整项目

**项目类型**: 生产级REST API服务  
**Go版本**: Go 1.25.3  
**难度等级**: ⭐⭐⭐⭐⭐ (高级)  
**最后更新**: 2025年10月22日

---


## 📋 目录


- [📖 项目说明](#-项目说明)
- [🏗️ 项目结构](#-项目结构)
- [💻 完整代码实现](#-完整代码实现)
  - [1. 程序入口 (cmd/server/main.go)](#1-程序入口-cmdservermaingo)
  - [2. 路由配置 (internal/api/router.go)](#2-路由配置-internalapiroutergo)
  - [3. 中间件 (internal/api/middleware.go)](#3-中间件-internalapimiddlewarego)
  - [4. HTTP处理器 (internal/api/handler.go)](#4-http处理器-internalapihandlergo)
  - [5. Dockerfile](#5-dockerfile)
  - [6. docker-compose.yml](#6-docker-composeyml)
- [🧪 单元测试示例](#-单元测试示例)
- [🚀 运行项目](#-运行项目)
  - [本地开发](#本地开发)
  - [Docker部署](#docker部署)
- [📊 性能优化](#-性能优化)
  - [1. 使用连接池](#1-使用连接池)
  - [2. 启用HTTP/2](#2-启用http2)
  - [3. 使用缓存](#3-使用缓存)
- [📝 API文档示例](#-api文档示例)
  - [创建用户](#创建用户)
- [🎯 最佳实践总结](#-最佳实践总结)

## 📖 项目说明

本项目展示如何使用Go 1.25.3构建**生产级Web服务**，包含：

- ✅ HTTP/3支持
- ✅ 泛型RESTful API
- ✅ 结构化日志
- ✅ 优雅关闭
- ✅ 中间件链
- ✅ 依赖注入
- ✅ 单元测试
- ✅ Docker部署

---

## 🏗️ 项目结构

```text
modern-web-service/
├── cmd/
│   └── server/
│       └── main.go              # 程序入口
├── internal/
│   ├── api/
│   │   ├── handler.go           # HTTP处理器
│   │   ├── middleware.go        # 中间件
│   │   └── router.go            # 路由配置
│   ├── model/
│   │   └── user.go              # 数据模型
│   ├── service/
│   │   └── user_service.go      # 业务逻辑
│   └── repository/
│       └── user_repo.go         # 数据访问
├── pkg/
│   ├── logger/
│   │   └── logger.go            # 日志工具
│   └── response/
│       └── response.go          # 响应工具
├── go.mod
├── go.sum
├── Dockerfile
└── README.md
```

---

## 💻 完整代码实现

### 1. 程序入口 (cmd/server/main.go)

```go
package main

import (
 "context"
 "errors"
 "fmt"
 "log/slog"
 "net/http"
 "os"
 "os/signal"
 "syscall"
 "time"
)

func main() {
 // 1. 初始化日志
 logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
  Level: slog.LevelInfo,
 }))
 slog.SetDefault(logger)
 
 // 2. 加载配置
 config := LoadConfig()
 
 // 3. 初始化依赖
 deps := InitDependencies(config)
 
 // 4. 创建路由
 router := NewRouter(deps)
 
 // 5. 创建HTTP服务器
 server := &http.Server{
  Addr:         fmt.Sprintf(":%d", config.Port),
  Handler:      router,
  ReadTimeout:  15 * time.Second,
  WriteTimeout: 15 * time.Second,
  IdleTimeout:  60 * time.Second,
 }
 
 // 6. 启动服务器（非阻塞）
 go func() {
  slog.Info("Starting server", "port", config.Port)
  if err := server.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
   slog.Error("Server error", "error", err)
   os.Exit(1)
  }
 }()
 
 // 7. 优雅关闭
 GracefulShutdown(server, deps, 30*time.Second)
}

// Config 配置
type Config struct {
 Port     int
 DBHost   string
 LogLevel string
}

// LoadConfig 加载配置
func LoadConfig() *Config {
 return &Config{
  Port:     getEnvInt("PORT", 8080),
  DBHost:   getEnv("DB_HOST", "localhost:5432"),
  LogLevel: getEnv("LOG_LEVEL", "info"),
 }
}

// Dependencies 依赖容器
type Dependencies struct {
 UserService *UserService
 // 其他服务...
}

// InitDependencies 初始化依赖
func InitDependencies(config *Config) *Dependencies {
 // 初始化数据库连接
 // db := initDB(config.DBHost)
 
 // 初始化Repository
 userRepo := NewUserRepository()
 
 // 初始化Service
 userService := NewUserService(userRepo)
 
 return &Dependencies{
  UserService: userService,
 }
}

// GracefulShutdown 优雅关闭
func GracefulShutdown(server *http.Server, deps *Dependencies, timeout time.Duration) {
 // 监听信号
 quit := make(chan os.Signal, 1)
 signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
 
 // 阻塞等待信号
 sig := <-quit
 slog.Info("Shutdown signal received", "signal", sig)
 
 // 创建超时上下文
 ctx, cancel := context.WithTimeout(context.Background(), timeout)
 defer cancel()
 
 // 关闭HTTP服务器
 if err := server.Shutdown(ctx); err != nil {
  slog.Error("Server shutdown error", "error", err)
 }
 
 // 清理资源
 // deps.DB.Close()
 
 slog.Info("Server stopped gracefully")
}

// 辅助函数
func getEnv(key, defaultValue string) string {
 if value := os.Getenv(key); value != "" {
  return value
 }
 return defaultValue
}

func getEnvInt(key string, defaultValue int) int {
 if value := os.Getenv(key); value != "" {
  var i int
  fmt.Sscanf(value, "%d", &i)
  return i
 }
 return defaultValue
}
```

---

### 2. 路由配置 (internal/api/router.go)

```go
package api

import (
 "net/http"
)

// NewRouter 创建路由
func NewRouter(deps *Dependencies) http.Handler {
 mux := http.NewServeMux()
 
 // 创建Handler
 handler := NewHandler(deps.UserService)
 
 // 注册路由 - 使用Go 1.22+ HTTP路由增强
 mux.HandleFunc("GET /health", handler.Health)
 mux.HandleFunc("GET /users", handler.ListUsers)
 mux.HandleFunc("GET /users/{id}", handler.GetUser)
 mux.HandleFunc("POST /users", handler.CreateUser)
 mux.HandleFunc("PUT /users/{id}", handler.UpdateUser)
 mux.HandleFunc("DELETE /users/{id}", handler.DeleteUser)
 
 // 应用中间件
 var finalHandler http.Handler = mux
 finalHandler = RequestLogger(finalHandler)
 finalHandler = Recoverer(finalHandler)
 finalHandler = CORS(finalHandler)
 finalHandler = RateLimiter(finalHandler, 100) // 100 req/sec
 
 return finalHandler
}
```

---

### 3. 中间件 (internal/api/middleware.go)

```go
package api

import (
 "context"
 "log/slog"
 "net/http"
 "runtime/debug"
 "sync"
 "time"
 
 "golang.org/x/time/rate"
)

// RequestLogger 请求日志中间件
func RequestLogger(next http.Handler) http.Handler {
 return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  start := time.Now()
  
  // 包装ResponseWriter以捕获状态码
  wrapped := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
  
  // 调用下一个处理器
  next.ServeHTTP(wrapped, r)
  
  // 记录日志
  duration := time.Since(start)
  slog.Info("HTTP Request",
   "method", r.Method,
   "path", r.URL.Path,
   "status", wrapped.statusCode,
   "duration_ms", duration.Milliseconds(),
   "remote_addr", r.RemoteAddr,
  )
 })
}

type responseWriter struct {
 http.ResponseWriter
 statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
 rw.statusCode = code
 rw.ResponseWriter.WriteHeader(code)
}

// Recoverer 恢复panic中间件
func Recoverer(next http.Handler) http.Handler {
 return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  defer func() {
   if err := recover(); err != nil {
    slog.Error("Panic recovered",
     "error", err,
     "stack", string(debug.Stack()),
    )
    
    http.Error(w, "Internal Server Error", http.StatusInternalServerError)
   }
  }()
  
  next.ServeHTTP(w, r)
 })
}

// CORS 跨域中间件
func CORS(next http.Handler) http.Handler {
 return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  w.Header().Set("Access-Control-Allow-Origin", "*")
  w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
  w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
  
  // 处理预检请求
  if r.Method == http.MethodOptions {
   w.WriteHeader(http.StatusOK)
   return
  }
  
  next.ServeHTTP(w, r)
 })
}

// RateLimiter 限流中间件 - 使用泛型
func RateLimiter(next http.Handler, rps int) http.Handler {
 // 使用sync.Map存储每个IP的限流器
 limiters := &sync.Map{}
 
 return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  // 获取客户端IP
  ip := r.RemoteAddr
  
  // 获取或创建限流器
  limiterInterface, _ := limiters.LoadOrStore(ip, rate.NewLimiter(rate.Limit(rps), rps*2))
  limiter := limiterInterface.(*rate.Limiter)
  
  // 检查限流
  if !limiter.Allow() {
   http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
   return
  }
  
  next.ServeHTTP(w, r)
 })
}

// Timeout 超时中间件
func Timeout(timeout time.Duration) func(http.Handler) http.Handler {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   ctx, cancel := context.WithTimeout(r.Context(), timeout)
   defer cancel()
   
   r = r.WithContext(ctx)
   
   done := make(chan struct{})
   go func() {
    next.ServeHTTP(w, r)
    close(done)
   }()
   
   select {
   case <-done:
    // 请求完成
   case <-ctx.Done():
    // 超时
    http.Error(w, "Request timeout", http.StatusGatewayTimeout)
   }
  })
 }
}
```

---

### 4. HTTP处理器 (internal/api/handler.go)

```go
package api

import (
 "encoding/json"
 "log/slog"
 "net/http"
 "strconv"
)

// Handler HTTP处理器
type Handler struct {
 userService *UserService
}

// NewHandler 创建处理器
func NewHandler(userService *UserService) *Handler {
 return &Handler{
  userService: userService,
 }
}

// Health 健康检查
func (h *Handler) Health(w http.ResponseWriter, r *http.Request) {
 Response(w, http.StatusOK, map[string]string{
  "status": "healthy",
  "time":   time.Now().Format(time.RFC3339),
 })
}

// ListUsers 获取用户列表
func (h *Handler) ListUsers(w http.ResponseWriter, r *http.Request) {
 // 解析查询参数
 page, _ := strconv.Atoi(r.URL.Query().Get("page"))
 if page < 1 {
  page = 1
 }
 
 pageSize, _ := strconv.Atoi(r.URL.Query().Get("page_size"))
 if pageSize < 1 || pageSize > 100 {
  pageSize = 10
 }
 
 // 调用Service
 users, total, err := h.userService.List(r.Context(), page, pageSize)
 if err != nil {
  slog.Error("Failed to list users", "error", err)
  ErrorResponse(w, http.StatusInternalServerError, "Failed to list users")
  return
 }
 
 // 返回响应
 Response(w, http.StatusOK, map[string]interface{}{
  "data":       users,
  "total":      total,
  "page":       page,
  "page_size":  pageSize,
 })
}

// GetUser 获取单个用户
func (h *Handler) GetUser(w http.ResponseWriter, r *http.Request) {
 // 获取路径参数 (Go 1.22+)
 idStr := r.PathValue("id")
 id, err := strconv.ParseInt(idStr, 10, 64)
 if err != nil {
  ErrorResponse(w, http.StatusBadRequest, "Invalid user ID")
  return
 }
 
 // 调用Service
 user, err := h.userService.GetByID(r.Context(), id)
 if err != nil {
  if errors.Is(err, ErrNotFound) {
   ErrorResponse(w, http.StatusNotFound, "User not found")
  } else {
   ErrorResponse(w, http.StatusInternalServerError, "Failed to get user")
  }
  return
 }
 
 Response(w, http.StatusOK, user)
}

// CreateUser 创建用户
func (h *Handler) CreateUser(w http.ResponseWriter, r *http.Request) {
 // 解析请求体
 var req CreateUserRequest
 if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
  ErrorResponse(w, http.StatusBadRequest, "Invalid request body")
  return
 }
 
 // 验证
 if err := req.Validate(); err != nil {
  ErrorResponse(w, http.StatusBadRequest, err.Error())
  return
 }
 
 // 调用Service
 user, err := h.userService.Create(r.Context(), &req)
 if err != nil {
  slog.Error("Failed to create user", "error", err)
  ErrorResponse(w, http.StatusInternalServerError, "Failed to create user")
  return
 }
 
 Response(w, http.StatusCreated, user)
}

// UpdateUser 更新用户
func (h *Handler) UpdateUser(w http.ResponseWriter, r *http.Request) {
 // 获取ID
 idStr := r.PathValue("id")
 id, err := strconv.ParseInt(idStr, 10, 64)
 if err != nil {
  ErrorResponse(w, http.StatusBadRequest, "Invalid user ID")
  return
 }
 
 // 解析请求体
 var req UpdateUserRequest
 if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
  ErrorResponse(w, http.StatusBadRequest, "Invalid request body")
  return
 }
 
 // 调用Service
 user, err := h.userService.Update(r.Context(), id, &req)
 if err != nil {
  if errors.Is(err, ErrNotFound) {
   ErrorResponse(w, http.StatusNotFound, "User not found")
  } else {
   ErrorResponse(w, http.StatusInternalServerError, "Failed to update user")
  }
  return
 }
 
 Response(w, http.StatusOK, user)
}

// DeleteUser 删除用户
func (h *Handler) DeleteUser(w http.ResponseWriter, r *http.Request) {
 // 获取ID
 idStr := r.PathValue("id")
 id, err := strconv.ParseInt(idStr, 10, 64)
 if err != nil {
  ErrorResponse(w, http.StatusBadRequest, "Invalid user ID")
  return
 }
 
 // 调用Service
 if err := h.userService.Delete(r.Context(), id); err != nil {
  if errors.Is(err, ErrNotFound) {
   ErrorResponse(w, http.StatusNotFound, "User not found")
  } else {
   ErrorResponse(w, http.StatusInternalServerError, "Failed to delete user")
  }
  return
 }
 
 w.WriteHeader(http.StatusNoContent)
}

// 响应工具函数
func Response(w http.ResponseWriter, status int, data interface{}) {
 w.Header().Set("Content-Type", "application/json")
 w.WriteHeader(status)
 json.NewEncoder(w).Encode(data)
}

func ErrorResponse(w http.ResponseWriter, status int, message string) {
 Response(w, status, map[string]string{
  "error": message,
 })
}
```

---

### 5. Dockerfile

```dockerfile
# 多阶段构建
FROM golang:1.25.3-alpine AS builder

WORKDIR /app

# 复制依赖文件
COPY go.mod go.sum ./
RUN go mod download

# 复制源代码
COPY . .

# 构建
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o server ./cmd/server

# 运行阶段
FROM alpine:latest

RUN apk --no-cache add ca-certificates

WORKDIR /root/

# 从构建阶段复制二进制文件
COPY --from=builder /app/server .

EXPOSE 8080

CMD ["./server"]
```

---

### 6. docker-compose.yml

```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - PORT=8080
      - DB_HOST=postgres:5432
      - LOG_LEVEL=info
    depends_on:
      - postgres
    restart: unless-stopped

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=myapp
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

---

## 🧪 单元测试示例

```go
package api

import (
 "bytes"
 "encoding/json"
 "net/http"
 "net/http/httptest"
 "testing"
)

func TestCreateUser(t *testing.H) {
 // Setup
 handler := NewHandler(NewMockUserService())
 
 // 准备请求
 reqBody := CreateUserRequest{
  Name:  "Test User",
  Email: "test@example.com",
 }
 body, _ := json.Marshal(reqBody)
 
 req := httptest.NewRequest(http.MethodPost, "/users", bytes.NewReader(body))
 req.Header.Set("Content-Type", "application/json")
 
 // 执行请求
 w := httptest.NewRecorder()
 handler.CreateUser(w, req)
 
 // 断言
 if w.Code != http.StatusCreated {
  t.Errorf("Expected status %d, got %d", http.StatusCreated, w.Code)
 }
 
 var resp map[string]interface{}
 json.NewDecoder(w.Body).Decode(&resp)
 
 if resp["name"] != reqBody.Name {
  t.Errorf("Expected name %s, got %v", reqBody.Name, resp["name"])
 }
}
```

---

## 🚀 运行项目

### 本地开发

```bash
# 1. 安装依赖
go mod download

# 2. 运行服务
go run cmd/server/main.go

# 3. 测试API
curl http://localhost:8080/health
curl http://localhost:8080/users
```

### Docker部署

```bash
# 1. 构建镜像
docker build -t myapp:latest .

# 2. 运行容器
docker run -p 8080:8080 myapp:latest

# 或使用docker-compose
docker-compose up -d
```

---

## 📊 性能优化

### 1. 使用连接池

```go
db, err := sql.Open("postgres", connString)
db.SetMaxOpenConns(25)
db.SetMaxIdleConns(5)
db.SetConnMaxLifetime(5 * time.Minute)
```

### 2. 启用HTTP/2

```go
server := &http.Server{
 Addr:    ":8080",
 Handler: router,
}
// HTTP/2自动启用（Go 1.6+）
```

### 3. 使用缓存

```go
cache := sync.Map{}

func CachedHandler(next http.Handler) http.Handler {
 return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  key := r.URL.String()
  if cached, ok := cache.Load(key); ok {
   w.Write(cached.([]byte))
   return
  }
  
  next.ServeHTTP(w, r)
 })
}
```

---

## 📝 API文档示例

### 创建用户

**请求**:

```text
POST /users
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john@example.com"
}
```

**响应**:

```json
{
  "id": 1,
  "name": "John Doe",
  "email": "john@example.com",
  "created_at": "2025-10-22T10:00:00Z"
}
```

---

## 🎯 最佳实践总结

1. ✅ **结构清晰**: 遵循标准项目布局
2. ✅ **错误处理**: 统一的错误响应
3. ✅ **日志记录**: 使用结构化日志
4. ✅ **优雅关闭**: 正确处理信号
5. ✅ **中间件**: 模块化功能
6. ✅ **依赖注入**: 便于测试
7. ✅ **Docker化**: 容器化部署

---

<div align="center">

**使用Go 1.25.3构建生产级Web服务**-

[📚 返回目录](README.md) | [📖 相关文档](01-HTTP基础.md)

Made with ❤️ for Go Developers

</div>

---

**项目版本**: v1.0  
**Go版本**: Go 1.25.3  
**生产就绪**: ✅  
**最后更新**: 2025-10-22
