# Go 1.25.3 ç°ä»£WebæœåŠ¡å®Œæ•´é¡¹ç›®

**é¡¹ç›®ç±»å‹**: ç”Ÿäº§çº§REST APIæœåŠ¡  
**Goç‰ˆæœ¬**: Go 1.25.3  
**éš¾åº¦ç­‰çº§**: â­â­â­â­â­ (é«˜çº§)  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ22æ—¥

---


## ğŸ“‹ ç›®å½•


- [ğŸ“– é¡¹ç›®è¯´æ˜](#-é¡¹ç›®è¯´æ˜)
- [ğŸ—ï¸ é¡¹ç›®ç»“æ„](#-é¡¹ç›®ç»“æ„)
- [ğŸ’» å®Œæ•´ä»£ç å®ç°](#-å®Œæ•´ä»£ç å®ç°)
  - [1. ç¨‹åºå…¥å£ (cmd/server/main.go)](#1-ç¨‹åºå…¥å£-cmdservermaingo)
  - [2. è·¯ç”±é…ç½® (internal/api/router.go)](#2-è·¯ç”±é…ç½®-internalapiroutergo)
  - [3. ä¸­é—´ä»¶ (internal/api/middleware.go)](#3-ä¸­é—´ä»¶-internalapimiddlewarego)
  - [4. HTTPå¤„ç†å™¨ (internal/api/handler.go)](#4-httpå¤„ç†å™¨-internalapihandlergo)
  - [5. Dockerfile](#5-dockerfile)
  - [6. docker-compose.yml](#6-docker-composeyml)
- [ğŸ§ª å•å…ƒæµ‹è¯•ç¤ºä¾‹](#-å•å…ƒæµ‹è¯•ç¤ºä¾‹)
- [ğŸš€ è¿è¡Œé¡¹ç›®](#-è¿è¡Œé¡¹ç›®)
  - [æœ¬åœ°å¼€å‘](#æœ¬åœ°å¼€å‘)
  - [Dockeréƒ¨ç½²](#dockeréƒ¨ç½²)
- [ğŸ“Š æ€§èƒ½ä¼˜åŒ–](#-æ€§èƒ½ä¼˜åŒ–)
  - [1. ä½¿ç”¨è¿æ¥æ± ](#1-ä½¿ç”¨è¿æ¥æ± )
  - [2. å¯ç”¨HTTP/2](#2-å¯ç”¨http2)
  - [3. ä½¿ç”¨ç¼“å­˜](#3-ä½¿ç”¨ç¼“å­˜)
- [ğŸ“ APIæ–‡æ¡£ç¤ºä¾‹](#-apiæ–‡æ¡£ç¤ºä¾‹)
  - [åˆ›å»ºç”¨æˆ·](#åˆ›å»ºç”¨æˆ·)
- [ğŸ¯ æœ€ä½³å®è·µæ€»ç»“](#-æœ€ä½³å®è·µæ€»ç»“)

## ğŸ“– é¡¹ç›®è¯´æ˜

æœ¬é¡¹ç›®å±•ç¤ºå¦‚ä½•ä½¿ç”¨Go 1.25.3æ„å»º**ç”Ÿäº§çº§WebæœåŠ¡**ï¼ŒåŒ…å«ï¼š

- âœ… HTTP/3æ”¯æŒ
- âœ… æ³›å‹RESTful API
- âœ… ç»“æ„åŒ–æ—¥å¿—
- âœ… ä¼˜é›…å…³é—­
- âœ… ä¸­é—´ä»¶é“¾
- âœ… ä¾èµ–æ³¨å…¥
- âœ… å•å…ƒæµ‹è¯•
- âœ… Dockeréƒ¨ç½²

---

## ğŸ—ï¸ é¡¹ç›®ç»“æ„

```text
modern-web-service/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ main.go              # ç¨‹åºå…¥å£
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ handler.go           # HTTPå¤„ç†å™¨
â”‚   â”‚   â”œâ”€â”€ middleware.go        # ä¸­é—´ä»¶
â”‚   â”‚   â””â”€â”€ router.go            # è·¯ç”±é…ç½®
â”‚   â”œâ”€â”€ model/
â”‚   â”‚   â””â”€â”€ user.go              # æ•°æ®æ¨¡å‹
â”‚   â”œâ”€â”€ service/
â”‚   â”‚   â””â”€â”€ user_service.go      # ä¸šåŠ¡é€»è¾‘
â”‚   â””â”€â”€ repository/
â”‚       â””â”€â”€ user_repo.go         # æ•°æ®è®¿é—®
â”œâ”€â”€ pkg/
â”‚   â”œâ”€â”€ logger/
â”‚   â”‚   â””â”€â”€ logger.go            # æ—¥å¿—å·¥å…·
â”‚   â””â”€â”€ response/
â”‚       â””â”€â”€ response.go          # å“åº”å·¥å…·
â”œâ”€â”€ go.mod
â”œâ”€â”€ go.sum
â”œâ”€â”€ Dockerfile
â””â”€â”€ README.md
```

---

## ğŸ’» å®Œæ•´ä»£ç å®ç°

### 1. ç¨‹åºå…¥å£ (cmd/server/main.go)

```go
package main

import (
 "context"
 "errors"
 "fmt"
 "log/slog"
 "net/http"
 "os"
 "os/signal"
 "syscall"
 "time"
)

func main() {
 // 1. åˆå§‹åŒ–æ—¥å¿—
 logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
  Level: slog.LevelInfo,
 }))
 slog.SetDefault(logger)
 
 // 2. åŠ è½½é…ç½®
 config := LoadConfig()
 
 // 3. åˆå§‹åŒ–ä¾èµ–
 deps := InitDependencies(config)
 
 // 4. åˆ›å»ºè·¯ç”±
 router := NewRouter(deps)
 
 // 5. åˆ›å»ºHTTPæœåŠ¡å™¨
 server := &http.Server{
  Addr:         fmt.Sprintf(":%d", config.Port),
  Handler:      router,
  ReadTimeout:  15 * time.Second,
  WriteTimeout: 15 * time.Second,
  IdleTimeout:  60 * time.Second,
 }
 
 // 6. å¯åŠ¨æœåŠ¡å™¨ï¼ˆéé˜»å¡ï¼‰
 go func() {
  slog.Info("Starting server", "port", config.Port)
  if err := server.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
   slog.Error("Server error", "error", err)
   os.Exit(1)
  }
 }()
 
 // 7. ä¼˜é›…å…³é—­
 GracefulShutdown(server, deps, 30*time.Second)
}

// Config é…ç½®
type Config struct {
 Port     int
 DBHost   string
 LogLevel string
}

// LoadConfig åŠ è½½é…ç½®
func LoadConfig() *Config {
 return &Config{
  Port:     getEnvInt("PORT", 8080),
  DBHost:   getEnv("DB_HOST", "localhost:5432"),
  LogLevel: getEnv("LOG_LEVEL", "info"),
 }
}

// Dependencies ä¾èµ–å®¹å™¨
type Dependencies struct {
 UserService *UserService
 // å…¶ä»–æœåŠ¡...
}

// InitDependencies åˆå§‹åŒ–ä¾èµ–
func InitDependencies(config *Config) *Dependencies {
 // åˆå§‹åŒ–æ•°æ®åº“è¿æ¥
 // db := initDB(config.DBHost)
 
 // åˆå§‹åŒ–Repository
 userRepo := NewUserRepository()
 
 // åˆå§‹åŒ–Service
 userService := NewUserService(userRepo)
 
 return &Dependencies{
  UserService: userService,
 }
}

// GracefulShutdown ä¼˜é›…å…³é—­
func GracefulShutdown(server *http.Server, deps *Dependencies, timeout time.Duration) {
 // ç›‘å¬ä¿¡å·
 quit := make(chan os.Signal, 1)
 signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
 
 // é˜»å¡ç­‰å¾…ä¿¡å·
 sig := <-quit
 slog.Info("Shutdown signal received", "signal", sig)
 
 // åˆ›å»ºè¶…æ—¶ä¸Šä¸‹æ–‡
 ctx, cancel := context.WithTimeout(context.Background(), timeout)
 defer cancel()
 
 // å…³é—­HTTPæœåŠ¡å™¨
 if err := server.Shutdown(ctx); err != nil {
  slog.Error("Server shutdown error", "error", err)
 }
 
 // æ¸…ç†èµ„æº
 // deps.DB.Close()
 
 slog.Info("Server stopped gracefully")
}

// è¾…åŠ©å‡½æ•°
func getEnv(key, defaultValue string) string {
 if value := os.Getenv(key); value != "" {
  return value
 }
 return defaultValue
}

func getEnvInt(key string, defaultValue int) int {
 if value := os.Getenv(key); value != "" {
  var i int
  fmt.Sscanf(value, "%d", &i)
  return i
 }
 return defaultValue
}
```

---

### 2. è·¯ç”±é…ç½® (internal/api/router.go)

```go
package api

import (
 "net/http"
)

// NewRouter åˆ›å»ºè·¯ç”±
func NewRouter(deps *Dependencies) http.Handler {
 mux := http.NewServeMux()
 
 // åˆ›å»ºHandler
 handler := NewHandler(deps.UserService)
 
 // æ³¨å†Œè·¯ç”± - ä½¿ç”¨Go 1.22+ HTTPè·¯ç”±å¢å¼º
 mux.HandleFunc("GET /health", handler.Health)
 mux.HandleFunc("GET /users", handler.ListUsers)
 mux.HandleFunc("GET /users/{id}", handler.GetUser)
 mux.HandleFunc("POST /users", handler.CreateUser)
 mux.HandleFunc("PUT /users/{id}", handler.UpdateUser)
 mux.HandleFunc("DELETE /users/{id}", handler.DeleteUser)
 
 // åº”ç”¨ä¸­é—´ä»¶
 var finalHandler http.Handler = mux
 finalHandler = RequestLogger(finalHandler)
 finalHandler = Recoverer(finalHandler)
 finalHandler = CORS(finalHandler)
 finalHandler = RateLimiter(finalHandler, 100) // 100 req/sec
 
 return finalHandler
}
```

---

### 3. ä¸­é—´ä»¶ (internal/api/middleware.go)

```go
package api

import (
 "context"
 "log/slog"
 "net/http"
 "runtime/debug"
 "sync"
 "time"
 
 "golang.org/x/time/rate"
)

// RequestLogger è¯·æ±‚æ—¥å¿—ä¸­é—´ä»¶
func RequestLogger(next http.Handler) http.Handler {
 return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  start := time.Now()
  
  // åŒ…è£…ResponseWriterä»¥æ•è·çŠ¶æ€ç 
  wrapped := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
  
  // è°ƒç”¨ä¸‹ä¸€ä¸ªå¤„ç†å™¨
  next.ServeHTTP(wrapped, r)
  
  // è®°å½•æ—¥å¿—
  duration := time.Since(start)
  slog.Info("HTTP Request",
   "method", r.Method,
   "path", r.URL.Path,
   "status", wrapped.statusCode,
   "duration_ms", duration.Milliseconds(),
   "remote_addr", r.RemoteAddr,
  )
 })
}

type responseWriter struct {
 http.ResponseWriter
 statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
 rw.statusCode = code
 rw.ResponseWriter.WriteHeader(code)
}

// Recoverer æ¢å¤panicä¸­é—´ä»¶
func Recoverer(next http.Handler) http.Handler {
 return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  defer func() {
   if err := recover(); err != nil {
    slog.Error("Panic recovered",
     "error", err,
     "stack", string(debug.Stack()),
    )
    
    http.Error(w, "Internal Server Error", http.StatusInternalServerError)
   }
  }()
  
  next.ServeHTTP(w, r)
 })
}

// CORS è·¨åŸŸä¸­é—´ä»¶
func CORS(next http.Handler) http.Handler {
 return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  w.Header().Set("Access-Control-Allow-Origin", "*")
  w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
  w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
  
  // å¤„ç†é¢„æ£€è¯·æ±‚
  if r.Method == http.MethodOptions {
   w.WriteHeader(http.StatusOK)
   return
  }
  
  next.ServeHTTP(w, r)
 })
}

// RateLimiter é™æµä¸­é—´ä»¶ - ä½¿ç”¨æ³›å‹
func RateLimiter(next http.Handler, rps int) http.Handler {
 // ä½¿ç”¨sync.Mapå­˜å‚¨æ¯ä¸ªIPçš„é™æµå™¨
 limiters := &sync.Map{}
 
 return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  // è·å–å®¢æˆ·ç«¯IP
  ip := r.RemoteAddr
  
  // è·å–æˆ–åˆ›å»ºé™æµå™¨
  limiterInterface, _ := limiters.LoadOrStore(ip, rate.NewLimiter(rate.Limit(rps), rps*2))
  limiter := limiterInterface.(*rate.Limiter)
  
  // æ£€æŸ¥é™æµ
  if !limiter.Allow() {
   http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
   return
  }
  
  next.ServeHTTP(w, r)
 })
}

// Timeout è¶…æ—¶ä¸­é—´ä»¶
func Timeout(timeout time.Duration) func(http.Handler) http.Handler {
 return func(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   ctx, cancel := context.WithTimeout(r.Context(), timeout)
   defer cancel()
   
   r = r.WithContext(ctx)
   
   done := make(chan struct{})
   go func() {
    next.ServeHTTP(w, r)
    close(done)
   }()
   
   select {
   case <-done:
    // è¯·æ±‚å®Œæˆ
   case <-ctx.Done():
    // è¶…æ—¶
    http.Error(w, "Request timeout", http.StatusGatewayTimeout)
   }
  })
 }
}
```

---

### 4. HTTPå¤„ç†å™¨ (internal/api/handler.go)

```go
package api

import (
 "encoding/json"
 "log/slog"
 "net/http"
 "strconv"
)

// Handler HTTPå¤„ç†å™¨
type Handler struct {
 userService *UserService
}

// NewHandler åˆ›å»ºå¤„ç†å™¨
func NewHandler(userService *UserService) *Handler {
 return &Handler{
  userService: userService,
 }
}

// Health å¥åº·æ£€æŸ¥
func (h *Handler) Health(w http.ResponseWriter, r *http.Request) {
 Response(w, http.StatusOK, map[string]string{
  "status": "healthy",
  "time":   time.Now().Format(time.RFC3339),
 })
}

// ListUsers è·å–ç”¨æˆ·åˆ—è¡¨
func (h *Handler) ListUsers(w http.ResponseWriter, r *http.Request) {
 // è§£ææŸ¥è¯¢å‚æ•°
 page, _ := strconv.Atoi(r.URL.Query().Get("page"))
 if page < 1 {
  page = 1
 }
 
 pageSize, _ := strconv.Atoi(r.URL.Query().Get("page_size"))
 if pageSize < 1 || pageSize > 100 {
  pageSize = 10
 }
 
 // è°ƒç”¨Service
 users, total, err := h.userService.List(r.Context(), page, pageSize)
 if err != nil {
  slog.Error("Failed to list users", "error", err)
  ErrorResponse(w, http.StatusInternalServerError, "Failed to list users")
  return
 }
 
 // è¿”å›å“åº”
 Response(w, http.StatusOK, map[string]interface{}{
  "data":       users,
  "total":      total,
  "page":       page,
  "page_size":  pageSize,
 })
}

// GetUser è·å–å•ä¸ªç”¨æˆ·
func (h *Handler) GetUser(w http.ResponseWriter, r *http.Request) {
 // è·å–è·¯å¾„å‚æ•° (Go 1.22+)
 idStr := r.PathValue("id")
 id, err := strconv.ParseInt(idStr, 10, 64)
 if err != nil {
  ErrorResponse(w, http.StatusBadRequest, "Invalid user ID")
  return
 }
 
 // è°ƒç”¨Service
 user, err := h.userService.GetByID(r.Context(), id)
 if err != nil {
  if errors.Is(err, ErrNotFound) {
   ErrorResponse(w, http.StatusNotFound, "User not found")
  } else {
   ErrorResponse(w, http.StatusInternalServerError, "Failed to get user")
  }
  return
 }
 
 Response(w, http.StatusOK, user)
}

// CreateUser åˆ›å»ºç”¨æˆ·
func (h *Handler) CreateUser(w http.ResponseWriter, r *http.Request) {
 // è§£æè¯·æ±‚ä½“
 var req CreateUserRequest
 if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
  ErrorResponse(w, http.StatusBadRequest, "Invalid request body")
  return
 }
 
 // éªŒè¯
 if err := req.Validate(); err != nil {
  ErrorResponse(w, http.StatusBadRequest, err.Error())
  return
 }
 
 // è°ƒç”¨Service
 user, err := h.userService.Create(r.Context(), &req)
 if err != nil {
  slog.Error("Failed to create user", "error", err)
  ErrorResponse(w, http.StatusInternalServerError, "Failed to create user")
  return
 }
 
 Response(w, http.StatusCreated, user)
}

// UpdateUser æ›´æ–°ç”¨æˆ·
func (h *Handler) UpdateUser(w http.ResponseWriter, r *http.Request) {
 // è·å–ID
 idStr := r.PathValue("id")
 id, err := strconv.ParseInt(idStr, 10, 64)
 if err != nil {
  ErrorResponse(w, http.StatusBadRequest, "Invalid user ID")
  return
 }
 
 // è§£æè¯·æ±‚ä½“
 var req UpdateUserRequest
 if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
  ErrorResponse(w, http.StatusBadRequest, "Invalid request body")
  return
 }
 
 // è°ƒç”¨Service
 user, err := h.userService.Update(r.Context(), id, &req)
 if err != nil {
  if errors.Is(err, ErrNotFound) {
   ErrorResponse(w, http.StatusNotFound, "User not found")
  } else {
   ErrorResponse(w, http.StatusInternalServerError, "Failed to update user")
  }
  return
 }
 
 Response(w, http.StatusOK, user)
}

// DeleteUser åˆ é™¤ç”¨æˆ·
func (h *Handler) DeleteUser(w http.ResponseWriter, r *http.Request) {
 // è·å–ID
 idStr := r.PathValue("id")
 id, err := strconv.ParseInt(idStr, 10, 64)
 if err != nil {
  ErrorResponse(w, http.StatusBadRequest, "Invalid user ID")
  return
 }
 
 // è°ƒç”¨Service
 if err := h.userService.Delete(r.Context(), id); err != nil {
  if errors.Is(err, ErrNotFound) {
   ErrorResponse(w, http.StatusNotFound, "User not found")
  } else {
   ErrorResponse(w, http.StatusInternalServerError, "Failed to delete user")
  }
  return
 }
 
 w.WriteHeader(http.StatusNoContent)
}

// å“åº”å·¥å…·å‡½æ•°
func Response(w http.ResponseWriter, status int, data interface{}) {
 w.Header().Set("Content-Type", "application/json")
 w.WriteHeader(status)
 json.NewEncoder(w).Encode(data)
}

func ErrorResponse(w http.ResponseWriter, status int, message string) {
 Response(w, status, map[string]string{
  "error": message,
 })
}
```

---

### 5. Dockerfile

```dockerfile
# å¤šé˜¶æ®µæ„å»º
FROM golang:1.25.3-alpine AS builder

WORKDIR /app

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY go.mod go.sum ./
RUN go mod download

# å¤åˆ¶æºä»£ç 
COPY . .

# æ„å»º
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o server ./cmd/server

# è¿è¡Œé˜¶æ®µ
FROM alpine:latest

RUN apk --no-cache add ca-certificates

WORKDIR /root/

# ä»æ„å»ºé˜¶æ®µå¤åˆ¶äºŒè¿›åˆ¶æ–‡ä»¶
COPY --from=builder /app/server .

EXPOSE 8080

CMD ["./server"]
```

---

### 6. docker-compose.yml

```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - PORT=8080
      - DB_HOST=postgres:5432
      - LOG_LEVEL=info
    depends_on:
      - postgres
    restart: unless-stopped

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=myapp
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

---

## ğŸ§ª å•å…ƒæµ‹è¯•ç¤ºä¾‹

```go
package api

import (
 "bytes"
 "encoding/json"
 "net/http"
 "net/http/httptest"
 "testing"
)

func TestCreateUser(t *testing.H) {
 // Setup
 handler := NewHandler(NewMockUserService())
 
 // å‡†å¤‡è¯·æ±‚
 reqBody := CreateUserRequest{
  Name:  "Test User",
  Email: "test@example.com",
 }
 body, _ := json.Marshal(reqBody)
 
 req := httptest.NewRequest(http.MethodPost, "/users", bytes.NewReader(body))
 req.Header.Set("Content-Type", "application/json")
 
 // æ‰§è¡Œè¯·æ±‚
 w := httptest.NewRecorder()
 handler.CreateUser(w, req)
 
 // æ–­è¨€
 if w.Code != http.StatusCreated {
  t.Errorf("Expected status %d, got %d", http.StatusCreated, w.Code)
 }
 
 var resp map[string]interface{}
 json.NewDecoder(w.Body).Decode(&resp)
 
 if resp["name"] != reqBody.Name {
  t.Errorf("Expected name %s, got %v", reqBody.Name, resp["name"])
 }
}
```

---

## ğŸš€ è¿è¡Œé¡¹ç›®

### æœ¬åœ°å¼€å‘

```bash
# 1. å®‰è£…ä¾èµ–
go mod download

# 2. è¿è¡ŒæœåŠ¡
go run cmd/server/main.go

# 3. æµ‹è¯•API
curl http://localhost:8080/health
curl http://localhost:8080/users
```

### Dockeréƒ¨ç½²

```bash
# 1. æ„å»ºé•œåƒ
docker build -t myapp:latest .

# 2. è¿è¡Œå®¹å™¨
docker run -p 8080:8080 myapp:latest

# æˆ–ä½¿ç”¨docker-compose
docker-compose up -d
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### 1. ä½¿ç”¨è¿æ¥æ± 

```go
db, err := sql.Open("postgres", connString)
db.SetMaxOpenConns(25)
db.SetMaxIdleConns(5)
db.SetConnMaxLifetime(5 * time.Minute)
```

### 2. å¯ç”¨HTTP/2

```go
server := &http.Server{
 Addr:    ":8080",
 Handler: router,
}
// HTTP/2è‡ªåŠ¨å¯ç”¨ï¼ˆGo 1.6+ï¼‰
```

### 3. ä½¿ç”¨ç¼“å­˜

```go
cache := sync.Map{}

func CachedHandler(next http.Handler) http.Handler {
 return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  key := r.URL.String()
  if cached, ok := cache.Load(key); ok {
   w.Write(cached.([]byte))
   return
  }
  
  next.ServeHTTP(w, r)
 })
}
```

---

## ğŸ“ APIæ–‡æ¡£ç¤ºä¾‹

### åˆ›å»ºç”¨æˆ·

**è¯·æ±‚**:

```text
POST /users
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john@example.com"
}
```

**å“åº”**:

```json
{
  "id": 1,
  "name": "John Doe",
  "email": "john@example.com",
  "created_at": "2025-10-22T10:00:00Z"
}
```

---

## ğŸ¯ æœ€ä½³å®è·µæ€»ç»“

1. âœ… **ç»“æ„æ¸…æ™°**: éµå¾ªæ ‡å‡†é¡¹ç›®å¸ƒå±€
2. âœ… **é”™è¯¯å¤„ç†**: ç»Ÿä¸€çš„é”™è¯¯å“åº”
3. âœ… **æ—¥å¿—è®°å½•**: ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—
4. âœ… **ä¼˜é›…å…³é—­**: æ­£ç¡®å¤„ç†ä¿¡å·
5. âœ… **ä¸­é—´ä»¶**: æ¨¡å—åŒ–åŠŸèƒ½
6. âœ… **ä¾èµ–æ³¨å…¥**: ä¾¿äºæµ‹è¯•
7. âœ… **DockeråŒ–**: å®¹å™¨åŒ–éƒ¨ç½²

---

<div align="center">

**ä½¿ç”¨Go 1.25.3æ„å»ºç”Ÿäº§çº§WebæœåŠ¡**-

[ğŸ“š è¿”å›ç›®å½•](README.md) | [ğŸ“– ç›¸å…³æ–‡æ¡£](01-HTTPåŸºç¡€.md)

Made with â¤ï¸ for Go Developers

</div>

---

**é¡¹ç›®ç‰ˆæœ¬**: v1.0  
**Goç‰ˆæœ¬**: Go 1.25.3  
**ç”Ÿäº§å°±ç»ª**: âœ…  
**æœ€åæ›´æ–°**: 2025-10-22
