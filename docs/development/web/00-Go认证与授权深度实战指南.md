# Goè®¤è¯ä¸æˆæƒ

**å­—æ•°**: ~38,000å­—
**ä»£ç ç¤ºä¾‹**: 120+ä¸ªå®Œæ•´ç¤ºä¾‹
**å®æˆ˜æ¡ˆä¾‹**: 9ä¸ªç«¯åˆ°ç«¯æ¡ˆä¾‹
**é€‚ç”¨äººç¾¤**: ä¸­çº§åˆ°é«˜çº§Goå¼€å‘è€…

---

## ğŸ“‹ ç›®å½•

- [ç¬¬ä¸€éƒ¨åˆ†ï¼šè®¤è¯æˆæƒåŸºç¡€ç†è®º](#ç¬¬ä¸€éƒ¨åˆ†è®¤è¯æˆæƒåŸºç¡€ç†è®º)
  - [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
  - [è®¤è¯æˆæƒæµç¨‹](#è®¤è¯æˆæƒæµç¨‹)
- [ç¬¬äºŒéƒ¨åˆ†ï¼šSessionè®¤è¯æ·±åº¦å®æˆ˜](#ç¬¬äºŒéƒ¨åˆ†sessionè®¤è¯æ·±åº¦å®æˆ˜)
  - [Sessionå·¥ä½œåŸç†](#sessionå·¥ä½œåŸç†)
  - [å®æˆ˜æ¡ˆä¾‹1ï¼šSessionè®¤è¯å®Œæ•´å®ç°](#å®æˆ˜æ¡ˆä¾‹1sessionè®¤è¯å®Œæ•´å®ç°)
- [ç¬¬ä¸‰éƒ¨åˆ†ï¼šJWTè®¤è¯æ·±åº¦å®æˆ˜](#ç¬¬ä¸‰éƒ¨åˆ†jwtè®¤è¯æ·±åº¦å®æˆ˜)
  - [JWTç»“æ„](#jwtç»“æ„)
  - [å®æˆ˜æ¡ˆä¾‹2ï¼šJWTè®¤è¯å®Œæ•´å®ç°](#å®æˆ˜æ¡ˆä¾‹2jwtè®¤è¯å®Œæ•´å®ç°)
- [ç¬¬å››éƒ¨åˆ†ï¼šOAuth2.0å®Œæ•´å®ç°](#ç¬¬å››éƒ¨åˆ†oauth2-0å®Œæ•´å®ç°)
  - [OAuth2.0æˆæƒæµç¨‹](#oauth2-0æˆæƒæµç¨‹)
  - [å®æˆ˜æ¡ˆä¾‹3ï¼šOAuth2.0æˆæƒæœåŠ¡å™¨](#å®æˆ˜æ¡ˆä¾‹3oauth2-0æˆæƒæœåŠ¡å™¨)
- [ç¬¬äº”éƒ¨åˆ†ï¼šRBACæƒé™æ§åˆ¶](#ç¬¬äº”éƒ¨åˆ†rbacæƒé™æ§åˆ¶)
  - [RBACæ¨¡å‹](#rbacæ¨¡å‹)
  - [å®æˆ˜æ¡ˆä¾‹4ï¼šRBACå®Œæ•´å®ç°](#å®æˆ˜æ¡ˆä¾‹4rbacå®Œæ•´å®ç°)
- [ç¬¬å…­éƒ¨åˆ†ï¼šå¯†ç åŠ å¯†ä¸å®‰å…¨](#ç¬¬å…­éƒ¨åˆ†å¯†ç åŠ å¯†ä¸å®‰å…¨)
  - [å¯†ç åŠ å¯†æœ€ä½³å®è·µ](#å¯†ç åŠ å¯†æœ€ä½³å®è·µ)
- [ç¬¬ä¸ƒéƒ¨åˆ†ï¼šAPIå¯†é’¥è®¤è¯](#ç¬¬ä¸ƒéƒ¨åˆ†apiå¯†é’¥è®¤è¯)
  - [APIå¯†é’¥è®¤è¯åŸç†](#apiå¯†é’¥è®¤è¯åŸç†)
  - [å®æˆ˜æ¡ˆä¾‹5ï¼šAPIå¯†é’¥ç®¡ç†ç³»ç»Ÿ](#å®æˆ˜æ¡ˆä¾‹5apiå¯†é’¥ç®¡ç†ç³»ç»Ÿ)
- [ç¬¬å…«éƒ¨åˆ†ï¼šå¤šå› ç´ è®¤è¯MFA](#ç¬¬å…«éƒ¨åˆ†å¤šå› ç´ è®¤è¯mfa)
  - [MFAåŸç†](#mfaåŸç†)
  - [å®æˆ˜æ¡ˆä¾‹6ï¼šTOTPåŒå› ç´ è®¤è¯](#å®æˆ˜æ¡ˆä¾‹6totpåŒå› ç´ è®¤è¯)
- [ç¬¬ä¹éƒ¨åˆ†ï¼šå•ç‚¹ç™»å½•SSO](#ç¬¬ä¹éƒ¨åˆ†å•ç‚¹ç™»å½•sso)
  - [SSOåŸç†](#ssoåŸç†)
  - [å®æˆ˜æ¡ˆä¾‹7ï¼šç®€å•SSOå®ç°](#å®æˆ˜æ¡ˆä¾‹7ç®€å•ssoå®ç°)
- [ç¬¬åéƒ¨åˆ†ï¼šå®‰å…¨æœ€ä½³å®è·µ](#ç¬¬åéƒ¨åˆ†å®‰å…¨æœ€ä½³å®è·µ)
  - [å®æˆ˜æ¡ˆä¾‹8ï¼šå®‰å…¨ä¸­é—´ä»¶é›†åˆ](#å®æˆ˜æ¡ˆä¾‹8å®‰å…¨ä¸­é—´ä»¶é›†åˆ)
- [ç¬¬åä¸€éƒ¨åˆ†ï¼šå®Œæ•´é¡¹ç›®å®æˆ˜](#ç¬¬åä¸€éƒ¨åˆ†å®Œæ•´é¡¹ç›®å®æˆ˜)
  - [å®æˆ˜æ¡ˆä¾‹9ï¼šå®Œæ•´çš„è®¤è¯æˆæƒç³»ç»Ÿ](#å®æˆ˜æ¡ˆä¾‹9å®Œæ•´çš„è®¤è¯æˆæƒç³»ç»Ÿ)
- [ğŸ¯ æ€»ç»“](#æ€»ç»“)
  - [è®¤è¯æˆæƒæ ¸å¿ƒè¦ç‚¹](#è®¤è¯æˆæƒæ ¸å¿ƒè¦ç‚¹)
  - [æœ€ä½³å®è·µæ¸…å•](#æœ€ä½³å®è·µæ¸…å•)

## ç¬¬ä¸€éƒ¨åˆ†ï¼šè®¤è¯æˆæƒåŸºç¡€ç†è®º

### æ ¸å¿ƒæ¦‚å¿µ

```text
è®¤è¯ï¼ˆAuthenticationï¼‰: éªŒè¯"ä½ æ˜¯è°" - Who are you?
æˆæƒï¼ˆAuthorizationï¼‰: éªŒè¯"ä½ èƒ½åšä»€ä¹ˆ" - What can you do?

è®¤è¯æ–¹å¼:
âœ… Session-Cookie è®¤è¯
âœ… Token è®¤è¯ï¼ˆJWTï¼‰
âœ… OAuth2.0 æˆæƒ
âœ… API Key è®¤è¯
âœ… å¤šå› ç´ è®¤è¯ï¼ˆMFAï¼‰

æˆæƒæ¨¡å‹:
âœ… RBACï¼ˆåŸºäºè§’è‰²ï¼‰
âœ… ABACï¼ˆåŸºäºå±æ€§ï¼‰
âœ… ACLï¼ˆè®¿é—®æ§åˆ¶åˆ—è¡¨ï¼‰
```

---

### è®¤è¯æˆæƒæµç¨‹

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              è®¤è¯æˆæƒå®Œæ•´æµç¨‹                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. ç”¨æˆ·ç™»å½•
   â”œâ”€ è¾“å…¥ç”¨æˆ·å/å¯†ç 
   â”œâ”€ éªŒè¯å‡­è¯
   â””â”€ ç”Ÿæˆå‡­è¯ï¼ˆSession/Tokenï¼‰

2. è®¤è¯æ£€æŸ¥
   â”œâ”€ æå–å‡­è¯
   â”œâ”€ éªŒè¯å‡­è¯æœ‰æ•ˆæ€§
   â””â”€ è¯†åˆ«ç”¨æˆ·èº«ä»½

3. æˆæƒæ£€æŸ¥
   â”œâ”€ è·å–ç”¨æˆ·æƒé™
   â”œâ”€ æ£€æŸ¥èµ„æºæƒé™
   â””â”€ å…è®¸/æ‹’ç»è®¿é—®

4. æ³¨é”€
   â””â”€ é”€æ¯å‡­è¯
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šSessionè®¤è¯æ·±åº¦å®æˆ˜

### Sessionå·¥ä½œåŸç†

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”          1. Login          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚ Server â”‚
â”‚        â”‚                             â”‚        â”‚
â”‚        â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚        â”‚
â”‚        â”‚   2. Set-Cookie: sid=xxx    â”‚        â”‚
â”‚        â”‚                             â”‚        â”‚
â”‚        â”‚   3. Cookie: sid=xxx        â”‚        â”‚
â”‚        â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚        â”‚
â”‚        â”‚                             â”‚        â”‚
â”‚        â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜   4. Response with data    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                       â”‚
                                       â”œâ”€ Memory Store
                                       â”œâ”€ Redis Store
                                       â””â”€ Database Store
```

---

### å®æˆ˜æ¡ˆä¾‹1ï¼šSessionè®¤è¯å®Œæ•´å®ç°

```go
package main

import (
    "crypto/rand"
    "encoding/base64"
    "fmt"
    "net/http"
    "sync"
    "time"

    "github.com/gin-gonic/gin"
)

// ===== Sessionå­˜å‚¨æ¥å£ =====
type SessionStore interface {
    Set(sid string, data map[string]interface{}, expiration time.Duration) error
    Get(sid string) (map[string]interface{}, error)
    Delete(sid string) error
    Exists(sid string) bool
}

// ===== å†…å­˜Sessionå­˜å‚¨ =====
type MemoryStore struct {
    mu       sync.RWMutex
    sessions map[string]*Session
}

type Session struct {
    Data      map[string]interface{}
    ExpiresAt time.Time
}

func NewMemoryStore() *MemoryStore {
    store := &MemoryStore{
        sessions: make(map[string]*Session),
    }

    // å®šæœŸæ¸…ç†è¿‡æœŸsession
    go store.cleanup()

    return store
}

func (s *MemoryStore) Set(sid string, data map[string]interface{}, expiration time.Duration) error {
    s.mu.Lock()
    defer s.mu.Unlock()

    s.sessions[sid] = &Session{
        Data:      data,
        ExpiresAt: time.Now().Add(expiration),
    }

    return nil
}

func (s *MemoryStore) Get(sid string) (map[string]interface{}, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()

    session, exists := s.sessions[sid]
    if !exists {
        return nil, fmt.Errorf("session not found")
    }

    if time.Now().After(session.ExpiresAt) {
        return nil, fmt.Errorf("session expired")
    }

    return session.Data, nil
}

func (s *MemoryStore) Delete(sid string) error {
    s.mu.Lock()
    defer s.mu.Unlock()

    delete(s.sessions, sid)
    return nil
}

func (s *MemoryStore) Exists(sid string) bool {
    s.mu.RLock()
    defer s.mu.RUnlock()

    session, exists := s.sessions[sid]
    if !exists {
        return false
    }

    return time.Now().Before(session.ExpiresAt)
}

func (s *MemoryStore) cleanup() {
    ticker := time.NewTicker(5 * time.Minute)
    defer ticker.Stop()

    for range ticker.C {
        s.mu.Lock()
        for sid, session := range s.sessions {
            if time.Now().After(session.ExpiresAt) {
                delete(s.sessions, sid)
            }
        }
        s.mu.Unlock()
    }
}

// ===== Sessionç®¡ç†å™¨ =====
type SessionManager struct {
    store      SessionStore
    cookieName string
    expiration time.Duration
}

func NewSessionManager(store SessionStore) *SessionManager {
    return &SessionManager{
        store:      store,
        cookieName: "session_id",
        expiration: 24 * time.Hour,
    }
}

// ç”ŸæˆSession ID
func (sm *SessionManager) generateSID() (string, error) {
    b := make([]byte, 32)
    if _, err := rand.Read(b); err != nil {
        return "", err
    }
    return base64.URLEncoding.EncodeToString(b), nil
}

// åˆ›å»ºSession
func (sm *SessionManager) Create(c *gin.Context, data map[string]interface{}) (string, error) {
    sid, err := sm.generateSID()
    if err != nil {
        return "", err
    }

    if err := sm.store.Set(sid, data, sm.expiration); err != nil {
        return "", err
    }

    // è®¾ç½®Cookie
    c.SetCookie(
        sm.cookieName,
        sid,
        int(sm.expiration.Seconds()),
        "/",
        "",
        false, // secure
        true,  // httpOnly
    )

    return sid, nil
}

// è·å–Session
func (sm *SessionManager) Get(c *gin.Context) (map[string]interface{}, error) {
    sid, err := c.Cookie(sm.cookieName)
    if err != nil {
        return nil, err
    }

    return sm.store.Get(sid)
}

// é”€æ¯Session
func (sm *SessionManager) Destroy(c *gin.Context) error {
    sid, err := c.Cookie(sm.cookieName)
    if err != nil {
        return err
    }

    if err := sm.store.Delete(sid); err != nil {
        return err
    }

    // æ¸…é™¤Cookie
    c.SetCookie(sm.cookieName, "", -1, "/", "", false, true)

    return nil
}

// ===== ä¸­é—´ä»¶ï¼šSessionè®¤è¯ =====
func (sm *SessionManager) AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        session, err := sm.Get(c)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
            c.Abort()
            return
        }

        // å°†ç”¨æˆ·ä¿¡æ¯å­˜å…¥Context
        c.Set("userID", session["userID"])
        c.Set("username", session["username"])

        c.Next()
    }
}

// ===== Handlerç¤ºä¾‹ =====
func setupRoutes(r *gin.Engine, sm *SessionManager) {
    // ç™»å½•
    r.POST("/login", func(c *gin.Context) {
        var req struct {
            Username string `json:"username" binding:"required"`
            Password string `json:"password" binding:"required"`
        }

        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        // éªŒè¯ç”¨æˆ·åå¯†ç ï¼ˆç®€åŒ–ç‰ˆï¼‰
        if req.Username != "alice" || req.Password != "password123" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
            return
        }

        // åˆ›å»ºSession
        sid, err := sm.Create(c, map[string]interface{}{
            "userID":   1,
            "username": req.Username,
        })

        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }

        c.JSON(http.StatusOK, gin.H{
            "message":    "Login successful",
            "session_id": sid,
        })
    })

    // æ³¨é”€
    r.POST("/logout", sm.AuthMiddleware(), func(c *gin.Context) {
        if err := sm.Destroy(c); err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }

        c.JSON(http.StatusOK, gin.H{"message": "Logout successful"})
    })

    // å—ä¿æŠ¤çš„è·¯ç”±
    r.GET("/profile", sm.AuthMiddleware(), func(c *gin.Context) {
        username := c.GetString("username")
        c.JSON(http.StatusOK, gin.H{
            "username": username,
            "email":    username + "@example.com",
        })
    })
}

func main() {
    r := gin.Default()

    store := NewMemoryStore()
    sm := NewSessionManager(store)

    setupRoutes(r, sm)

    r.Run(":8080")
}
```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šJWTè®¤è¯æ·±åº¦å®æˆ˜

### JWTç»“æ„

```text
JWT = Header.Payload.Signature

Header (Base64ç¼–ç ):
{
  "alg": "HS256",
  "typ": "JWT"
}

Payload (Base64ç¼–ç ):
{
  "sub": "user123",
  "name": "Alice",
  "iat": 1516239022,
  "exp": 1516242622
}

Signature (HMAC-SHA256):
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)

å®Œæ•´JWT:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiJ1c2VyMTIzIiwibmFtZSI6IkFsaWNlIiwiaWF0IjoxNTE2MjM5MDIyfQ.
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

---

### å®æˆ˜æ¡ˆä¾‹2ï¼šJWTè®¤è¯å®Œæ•´å®ç°

```go
package main

import (
    "fmt"
    "net/http"
    "strings"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/golang-jwt/jwt/v5"
)

// ===== JWTé…ç½® =====
var (
    jwtSecret     = []byte("your-secret-key-keep-it-safe")
    jwtExpiration = 24 * time.Hour
)

// ===== JWT Claims =====
type Claims struct {
    UserID   int64  `json:"user_id"`
    Username string `json:"username"`
    Role     string `json:"role"`
    jwt.RegisteredClaims
}

// ===== JWTå·¥å…·å‡½æ•° =====
// ç”ŸæˆJWT Token
func GenerateToken(userID int64, username, role string) (string, error) {
    now := time.Now()

    claims := &Claims{
        UserID:   userID,
        Username: username,
        Role:     role,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(now.Add(jwtExpiration)),
            IssuedAt:  jwt.NewNumericDate(now),
            NotBefore: jwt.NewNumericDate(now),
            Issuer:    "my-app",
            Subject:   username,
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(jwtSecret)
}

// è§£æJWT Token
func ParseToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        // éªŒè¯ç­¾åæ–¹æ³•
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
        }
        return jwtSecret, nil
    })

    if err != nil {
        return nil, err
    }

    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }

    return nil, fmt.Errorf("invalid token")
}

// ===== ä¸­é—´ä»¶ï¼šJWTè®¤è¯ =====
func JWTAuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // ä»Authorization Headerè·å–Token
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
            c.Abort()
            return
        }

        // æ£€æŸ¥Beareræ ¼å¼
        parts := strings.SplitN(authHeader, " ", 2)
        if len(parts) != 2 || parts[0] != "Bearer" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authorization header format"})
            c.Abort()
            return
        }

        tokenString := parts[1]

        // è§£æToken
        claims, err := ParseToken(tokenString)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or expired token"})
            c.Abort()
            return
        }

        // å°†ç”¨æˆ·ä¿¡æ¯å­˜å…¥Context
        c.Set("userID", claims.UserID)
        c.Set("username", claims.Username)
        c.Set("role", claims.Role)

        c.Next()
    }
}

// ===== Tokenåˆ·æ–°æœºåˆ¶ =====
type TokenPair struct {
    AccessToken  string `json:"access_token"`
    RefreshToken string `json:"refresh_token"`
    ExpiresIn    int64  `json:"expires_in"`
}

// ç”ŸæˆTokenå¯¹ï¼ˆAccess + Refreshï¼‰
func GenerateTokenPair(userID int64, username, role string) (*TokenPair, error) {
    // Access Tokenï¼ˆçŸ­æœŸæœ‰æ•ˆï¼Œ1å°æ—¶ï¼‰
    accessClaims := &Claims{
        UserID:   userID,
        Username: username,
        Role:     role,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(1 * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
        },
    }

    accessToken := jwt.NewWithClaims(jwt.SigningMethodHS256, accessClaims)
    accessTokenString, err := accessToken.SignedString(jwtSecret)
    if err != nil {
        return nil, err
    }

    // Refresh Tokenï¼ˆé•¿æœŸæœ‰æ•ˆï¼Œ7å¤©ï¼‰
    refreshClaims := &Claims{
        UserID:   userID,
        Username: username,
        Role:     role,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(7 * 24 * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
        },
    }

    refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshClaims)
    refreshTokenString, err := refreshToken.SignedString(jwtSecret)
    if err != nil {
        return nil, err
    }

    return &TokenPair{
        AccessToken:  accessTokenString,
        RefreshToken: refreshTokenString,
        ExpiresIn:    3600, // 1å°æ—¶
    }, nil
}

// ===== Handlerç¤ºä¾‹ =====
func setupJWTRoutes(r *gin.Engine) {
    // ç™»å½•
    r.POST("/api/login", func(c *gin.Context) {
        var req struct {
            Username string `json:"username" binding:"required"`
            Password string `json:"password" binding:"required"`
        }

        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        // éªŒè¯ç”¨æˆ·åå¯†ç ï¼ˆç®€åŒ–ç‰ˆï¼‰
        if req.Username != "alice" || req.Password != "password123" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
            return
        }

        // ç”ŸæˆTokenå¯¹
        tokenPair, err := GenerateTokenPair(1, req.Username, "admin")
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }

        c.JSON(http.StatusOK, tokenPair)
    })

    // åˆ·æ–°Token
    r.POST("/api/refresh", func(c *gin.Context) {
        var req struct {
            RefreshToken string `json:"refresh_token" binding:"required"`
        }

        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        // è§£æRefresh Token
        claims, err := ParseToken(req.RefreshToken)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid refresh token"})
            return
        }

        // ç”Ÿæˆæ–°çš„Tokenå¯¹
        tokenPair, err := GenerateTokenPair(claims.UserID, claims.Username, claims.Role)
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }

        c.JSON(http.StatusOK, tokenPair)
    })

    // å—ä¿æŠ¤çš„è·¯ç”±
    api := r.Group("/api")
    api.Use(JWTAuthMiddleware())
    {
        api.GET("/profile", func(c *gin.Context) {
            username := c.GetString("username")
            role := c.GetString("role")

            c.JSON(http.StatusOK, gin.H{
                "username": username,
                "role":     role,
            })
        })
    }
}

func main() {
    r := gin.Default()
    setupJWTRoutes(r)
    r.Run(":8080")
}
```

---

## ç¬¬å››éƒ¨åˆ†ï¼šOAuth2.0å®Œæ•´å®ç°

### OAuth2.0æˆæƒæµç¨‹

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             OAuth2.0 æˆæƒç æµç¨‹                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. ç”¨æˆ·è¯·æ±‚æˆæƒ
   Client â”€â”€â”€â”€â”€> Authorization Server

2. ç”¨æˆ·åŒæ„æˆæƒ
   Authorization Server â”€â”€â”€â”€â”€> Client (Authorization Code)

3. å®¢æˆ·ç«¯è¯·æ±‚Access Token
   Client â”€â”€â”€â”€â”€> Authorization Server (Authorization Code)

4. è¿”å›Access Token
   Authorization Server â”€â”€â”€â”€â”€> Client (Access Token)

5. å®¢æˆ·ç«¯è®¿é—®èµ„æº
   Client â”€â”€â”€â”€â”€> Resource Server (Access Token)

6. è¿”å›å—ä¿æŠ¤èµ„æº
   Resource Server â”€â”€â”€â”€â”€> Client
```

---

### å®æˆ˜æ¡ˆä¾‹3ï¼šOAuth2.0æˆæƒæœåŠ¡å™¨

```go
package main

import (
    "crypto/rand"
    "encoding/base64"
    "fmt"
    "net/http"
    "sync"
    "time"

    "github.com/gin-gonic/gin"
)

// ===== OAuth2.0æ•°æ®ç»“æ„ =====
type Client struct {
    ClientID     string
    ClientSecret string
    RedirectURIs []string
}

type AuthorizationCode struct {
    Code      string
    ClientID  string
    UserID    int64
    Scope     string
    ExpiresAt time.Time
}

type AccessToken struct {
    Token     string
    ClientID  string
    UserID    int64
    Scope     string
    ExpiresAt time.Time
}

// ===== OAuth2.0æœåŠ¡å™¨ =====
type OAuth2Server struct {
    mu                sync.RWMutex
    clients           map[string]*Client
    authorizationCode map[string]*AuthorizationCode
    accessTokens      map[string]*AccessToken
}

func NewOAuth2Server() *OAuth2Server {
 server := &OAuth2Server{
  clients:            make(map[string]*Client),
  authorizationCode:  make(map[string]*AuthorizationCode),
  accessTokens:       make(map[string]*AccessToken),
 }

    // æ³¨å†Œç¤ºä¾‹å®¢æˆ·ç«¯
    server.RegisterClient(&Client{
        ClientID:     "client123",
        ClientSecret: "secret456",
        RedirectURIs: []string{"http://localhost:3000/callback"},
    })

    return server
}

func (s *OAuth2Server) RegisterClient(client *Client) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.clients[client.ClientID] = client
}

// ç”Ÿæˆéšæœºå­—ç¬¦ä¸²
func generateRandomString(length int) (string, error) {
    b := make([]byte, length)
    if _, err := rand.Read(b); err != nil {
        return "", err
    }
    return base64.URLEncoding.EncodeToString(b)[:length], nil
}

// æˆæƒç«¯ç‚¹
func (s *OAuth2Server) Authorize(c *gin.Context) {
    clientID := c.Query("client_id")
    redirectURI := c.Query("redirect_uri")
    responseType := c.Query("response_type")
    scope := c.Query("scope")
    state := c.Query("state")

    // éªŒè¯client_id
    s.mu.RLock()
    client, exists := s.clients[clientID]
    s.mu.RUnlock()

    if !exists {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid_client"})
        return
    }

    // éªŒè¯redirect_uri
    validURI := false
    for _, uri := range client.RedirectURIs {
        if uri == redirectURI {
            validURI = true
            break
        }
    }

    if !validURI {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid_redirect_uri"})
        return
    }

    // æ£€æŸ¥response_type
    if responseType != "code" {
        c.Redirect(http.StatusFound, fmt.Sprintf("%s?error=unsupported_response_type&state=%s", redirectURI, state))
        return
    }

    // æ˜¾ç¤ºæˆæƒé¡µé¢ï¼ˆç®€åŒ–ç‰ˆï¼šç›´æ¥æˆæƒï¼‰
    // åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œè¿™é‡Œåº”è¯¥æ˜¾ç¤ºæˆæƒç¡®è®¤é¡µé¢
    userID := int64(1) // å‡è®¾ç”¨æˆ·å·²ç™»å½•

 // ç”Ÿæˆæˆæƒç 
 code, _ := generateRandomString(32)
 s.mu.Lock()
 s.authorizationCode[code] = &AuthorizationCode{
  Code:      code,
  ClientID:  clientID,
  UserID:    userID,
  Scope:     scope,
  ExpiresAt: time.Now().Add(10 * time.Minute),
 }
 s.mu.Unlock()

    // é‡å®šå‘å›å®¢æˆ·ç«¯
    c.Redirect(http.StatusFound, fmt.Sprintf("%s?code=%s&state=%s", redirectURI, code, state))
}

// Tokenç«¯ç‚¹
func (s *OAuth2Server) Token(c *gin.Context) {
    grantType := c.PostForm("grant_type")

    switch grantType {
    case "authorization_code":
        s.handleAuthorizationCodeGrant(c)
    case "refresh_token":
        s.handleRefreshTokenGrant(c)
    default:
        c.JSON(http.StatusBadRequest, gin.H{"error": "unsupported_grant_type"})
    }
}

func (s *OAuth2Server) handleAuthorizationCodeGrant(c *gin.Context) {
    code := c.PostForm("code")
    clientID := c.PostForm("client_id")
    clientSecret := c.PostForm("client_secret")
    redirectURI := c.PostForm("redirect_uri")

    // éªŒè¯å®¢æˆ·ç«¯å‡­è¯
    s.mu.RLock()
    client, exists := s.clients[clientID]
    s.mu.RUnlock()

    if !exists || client.ClientSecret != clientSecret {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid_client"})
        return
    }

 // éªŒè¯æˆæƒç 
 s.mu.Lock()
 authCode, exists := s.authorizationCode[code]
 if !exists {
  s.mu.Unlock()
  c.JSON(http.StatusBadRequest, gin.H{"error": "invalid_grant"})
  return
 }

 // æ£€æŸ¥æˆæƒç æ˜¯å¦è¿‡æœŸ
 if time.Now().After(authCode.ExpiresAt) {
  delete(s.authorizationCode, code)
  s.mu.Unlock()
  c.JSON(http.StatusBadRequest, gin.H{"error": "invalid_grant"})
  return
 }

 // æˆæƒç åªèƒ½ä½¿ç”¨ä¸€æ¬¡
 delete(s.authorizationCode, code)

    // ç”ŸæˆAccess Token
    tokenString, _ := generateRandomString(32)
    s.accessTokens[tokenString] = &AccessToken{
        Token:     tokenString,
        ClientID:  clientID,
        UserID:    authCode.UserID,
        Scope:     authCode.Scope,
        ExpiresAt: time.Now().Add(1 * time.Hour),
    }
    s.mu.Unlock()

    c.JSON(http.StatusOK, gin.H{
        "access_token": tokenString,
        "token_type":   "Bearer",
        "expires_in":   3600,
        "scope":        authCode.Scope,
    })
}

func (s *OAuth2Server) handleRefreshTokenGrant(c *gin.Context) {
    // åˆ·æ–°Tokenå®ç°
    c.JSON(http.StatusOK, gin.H{"message": "refresh token grant"})
}

// éªŒè¯Access Token
func (s *OAuth2Server) ValidateToken(tokenString string) (*AccessToken, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()

    token, exists := s.accessTokens[tokenString]
    if !exists {
        return nil, fmt.Errorf("invalid token")
    }

    if time.Now().After(token.ExpiresAt) {
        return nil, fmt.Errorf("token expired")
    }

    return token, nil
}

func main() {
    r := gin.Default()
    server := NewOAuth2Server()

    // OAuth2.0ç«¯ç‚¹
    r.GET("/oauth/authorize", server.Authorize)
    r.POST("/oauth/token", server.Token)

    // å—ä¿æŠ¤çš„èµ„æº
    r.GET("/api/userinfo", func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "missing token"})
            return
        }

        tokenString := authHeader[len("Bearer "):]
        token, err := server.ValidateToken(tokenString)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
            return
        }

        c.JSON(http.StatusOK, gin.H{
            "user_id": token.UserID,
            "scope":   token.Scope,
        })
    })

    r.Run(":8080")
}
```

---

## ç¬¬äº”éƒ¨åˆ†ï¼šRBACæƒé™æ§åˆ¶

### RBACæ¨¡å‹

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              RBACæ¨¡å‹                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

User â”€â”€â”€â”€â”€> Role â”€â”€â”€â”€â”€> Permission â”€â”€â”€â”€â”€> Resource

ç”¨æˆ·     â†’  è§’è‰²    â†’  æƒé™        â†’  èµ„æº

ç¤ºä¾‹:
Alice   â†’  Admin   â†’  user:create  â†’  /api/users
Bob     â†’  Editor  â†’  post:edit    â†’  /api/posts
Charlie â†’  Viewer  â†’  post:read    â†’  /api/posts
```

---

### å®æˆ˜æ¡ˆä¾‹4ï¼šRBACå®Œæ•´å®ç°

```go
package main

import (
    "fmt"
    "net/http"
    "strings"

    "github.com/gin-gonic/gin"
)

// ===== RBACæ•°æ®æ¨¡å‹ =====
type User struct {
    ID    int64
    Name  string
    Roles []string
}

type Role struct {
    Name        string
    Permissions []string
}

type Permission struct {
    Resource string // èµ„æºï¼Œå¦‚ "users", "posts"
    Action   string // æ“ä½œï¼Œå¦‚ "create", "read", "update", "delete"
}

// ===== RBACç®¡ç†å™¨ =====
type RBACManager struct {
    roles       map[string]*Role
    userRoles   map[int64][]string
    permissions map[string][]Permission
}

func NewRBACManager() *RBACManager {
    manager := &RBACManager{
        roles:       make(map[string]*Role),
        userRoles:   make(map[int64][]string),
        permissions: make(map[string][]Permission),
    }

    // åˆå§‹åŒ–è§’è‰²å’Œæƒé™
    manager.setupDefaultRoles()

    return manager
}

func (m *RBACManager) setupDefaultRoles() {
    // Adminè§’è‰²ï¼šæ‰€æœ‰æƒé™
    m.AddRole(&Role{
        Name: "admin",
        Permissions: []string{
            "users:create", "users:read", "users:update", "users:delete",
            "posts:create", "posts:read", "posts:update", "posts:delete",
        },
    })

    // Editorè§’è‰²ï¼šç¼–è¾‘æƒé™
    m.AddRole(&Role{
        Name: "editor",
        Permissions: []string{
            "posts:create", "posts:read", "posts:update",
            "users:read",
        },
    })

    // Viewerè§’è‰²ï¼šåªè¯»æƒé™
    m.AddRole(&Role{
        Name: "viewer",
        Permissions: []string{
            "posts:read",
            "users:read",
        },
    })

    // åˆ†é…ç”¨æˆ·è§’è‰²
    m.AssignRole(1, "admin")
    m.AssignRole(2, "editor")
    m.AssignRole(3, "viewer")
}

func (m *RBACManager) AddRole(role *Role) {
    m.roles[role.Name] = role

    for _, perm := range role.Permissions {
        parts := strings.Split(perm, ":")
        if len(parts) == 2 {
            m.permissions[role.Name] = append(m.permissions[role.Name], Permission{
                Resource: parts[0],
                Action:   parts[1],
            })
        }
    }
}

func (m *RBACManager) AssignRole(userID int64, roleName string) {
    m.userRoles[userID] = append(m.userRoles[userID], roleName)
}

// æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™
func (m *RBACManager) HasPermission(userID int64, resource, action string) bool {
    roles, exists := m.userRoles[userID]
    if !exists {
        return false
    }

    for _, roleName := range roles {
        permissions, exists := m.permissions[roleName]
        if !exists {
            continue
        }

        for _, perm := range permissions {
            if perm.Resource == resource && perm.Action == action {
                return true
            }
        }
    }

    return false
}

// è·å–ç”¨æˆ·æ‰€æœ‰æƒé™
func (m *RBACManager) GetUserPermissions(userID int64) []string {
    var permissions []string

    roles, exists := m.userRoles[userID]
    if !exists {
        return permissions
    }

    seen := make(map[string]bool)
    for _, roleName := range roles {
        role, exists := m.roles[roleName]
        if !exists {
            continue
        }

        for _, perm := range role.Permissions {
            if !seen[perm] {
                permissions = append(permissions, perm)
                seen[perm] = true
            }
        }
    }

    return permissions
}

// ===== ä¸­é—´ä»¶ï¼šRBACæƒé™æ£€æŸ¥ =====
func (m *RBACManager) RequirePermission(resource, action string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // ä»Contextè·å–ç”¨æˆ·IDï¼ˆå‡è®¾å·²é€šè¿‡JWTè®¤è¯ä¸­é—´ä»¶ï¼‰
        userID, exists := c.Get("userID")
        if !exists {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
            c.Abort()
            return
        }

        uid := userID.(int64)

        // æ£€æŸ¥æƒé™
        if !m.HasPermission(uid, resource, action) {
            c.JSON(http.StatusForbidden, gin.H{"error": "Permission denied"})
            c.Abort()
            return
        }

        c.Next()
    }
}

// ===== Handlerç¤ºä¾‹ =====
func setupRBACRoutes(r *gin.Engine, rbac *RBACManager) {
    // æ¨¡æ‹ŸJWTè®¤è¯ä¸­é—´ä»¶
    mockAuth := func() gin.HandlerFunc {
        return func(c *gin.Context) {
            // ä»Headerè·å–ç”¨æˆ·IDï¼ˆç®€åŒ–ç‰ˆï¼‰
            userIDStr := c.GetHeader("X-User-ID")
            if userIDStr == "" {
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing X-User-ID header"})
                c.Abort()
                return
            }

            var userID int64
            fmt.Sscanf(userIDStr, "%d", &userID)
            c.Set("userID", userID)

            c.Next()
        }
    }

    api := r.Group("/api")
    api.Use(mockAuth())
    {
        // ç”¨æˆ·ç®¡ç†ï¼ˆéœ€è¦users:createæƒé™ï¼‰
        api.POST("/users", rbac.RequirePermission("users", "create"), func(c *gin.Context) {
            c.JSON(http.StatusOK, gin.H{"message": "User created"})
        })

        // æŸ¥çœ‹ç”¨æˆ·ï¼ˆéœ€è¦users:readæƒé™ï¼‰
        api.GET("/users", rbac.RequirePermission("users", "read"), func(c *gin.Context) {
            c.JSON(http.StatusOK, gin.H{"users": []string{"alice", "bob"}})
        })

        // æ–‡ç« ç®¡ç†ï¼ˆéœ€è¦posts:createæƒé™ï¼‰
        api.POST("/posts", rbac.RequirePermission("posts", "create"), func(c *gin.Context) {
            c.JSON(http.StatusOK, gin.H{"message": "Post created"})
        })

        // æŸ¥çœ‹æ–‡ç« ï¼ˆéœ€è¦posts:readæƒé™ï¼‰
        api.GET("/posts", rbac.RequirePermission("posts", "read"), func(c *gin.Context) {
            c.JSON(http.StatusOK, gin.H{"posts": []string{"post1", "post2"}})
        })

        // æŸ¥çœ‹ç”¨æˆ·æƒé™
        api.GET("/me/permissions", func(c *gin.Context) {
            userID := c.GetInt64("userID")
            permissions := rbac.GetUserPermissions(userID)
            c.JSON(http.StatusOK, gin.H{"permissions": permissions})
        })
    }
}

func main() {
    r := gin.Default()
    rbac := NewRBACManager()

    setupRBACRoutes(r, rbac)

    r.Run(":8080")
}

/*
æµ‹è¯•å‘½ä»¤:
# Adminç”¨æˆ·ï¼ˆuserID=1ï¼‰åˆ›å»ºç”¨æˆ·
curl -H "X-User-ID: 1" -X POST http://localhost:8080/api/users

# Editorç”¨æˆ·ï¼ˆuserID=2ï¼‰å°è¯•åˆ›å»ºç”¨æˆ·ï¼ˆå¤±è´¥ï¼‰
curl -H "X-User-ID: 2" -X POST http://localhost:8080/api/users

# Viewerç”¨æˆ·ï¼ˆuserID=3ï¼‰æŸ¥çœ‹æ–‡ç« 
curl -H "X-User-ID: 3" http://localhost:8080/api/posts

# æŸ¥çœ‹ç”¨æˆ·æƒé™
curl -H "X-User-ID: 1" http://localhost:8080/api/me/permissions
*/
```

---

## ç¬¬å…­éƒ¨åˆ†ï¼šå¯†ç åŠ å¯†ä¸å®‰å…¨

### å¯†ç åŠ å¯†æœ€ä½³å®è·µ

```go
package main

import (
    "crypto/rand"
    "encoding/base64"
    "fmt"

    "golang.org/x/crypto/bcrypt"
    "golang.org/x/crypto/argon2"
)

// ===== 1. BcryptåŠ å¯†ï¼ˆæ¨èï¼‰=====
// å“ˆå¸Œå¯†ç 
func HashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    return string(bytes), err
}

// éªŒè¯å¯†ç 
func CheckPassword(password, hash string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}

// ===== 2. Argon2åŠ å¯†ï¼ˆæ›´å®‰å…¨ï¼‰=====
type Argon2Params struct {
    Memory      uint32
    Iterations  uint32
    Parallelism uint8
    SaltLength  uint32
    KeyLength   uint32
}

var DefaultArgon2Params = &Argon2Params{
    Memory:      64 * 1024, // 64 MB
    Iterations:  3,
    Parallelism: 2,
    SaltLength:  16,
    KeyLength:   32,
}

func Argon2Hash(password string, params *Argon2Params) (string, error) {
    // ç”Ÿæˆéšæœºsalt
    salt := make([]byte, params.SaltLength)
    if _, err := rand.Read(salt); err != nil {
        return "", err
    }

    // ç”Ÿæˆhash
    hash := argon2.IDKey(
        []byte(password),
        salt,
        params.Iterations,
        params.Memory,
        params.Parallelism,
        params.KeyLength,
    )

    // ç¼–ç ä¸ºbase64
    b64Salt := base64.RawStdEncoding.EncodeToString(salt)
    b64Hash := base64.RawStdEncoding.EncodeToString(hash)

    // æ ¼å¼: $argon2id$v=19$m=65536,t=3,p=2$salt$hash
    encodedHash := fmt.Sprintf("$argon2id$v=19$m=%d,t=%d,p=%d$%s$%s",
        params.Memory, params.Iterations, params.Parallelism, b64Salt, b64Hash)

    return encodedHash, nil
}

// ===== 3. å¯†ç å¼ºåº¦æ£€æŸ¥ =====
import (
    "regexp"
    "unicode"
)

func ValidatePasswordStrength(password string) []string {
    var errors []string

    // æœ€å°é•¿åº¦
    if len(password) < 8 {
        errors = append(errors, "å¯†ç é•¿åº¦è‡³å°‘8ä½")
    }

    // åŒ…å«å¤§å†™å­—æ¯
    if !regexp.MustCompile(`[A-Z]`).MatchString(password) {
        errors = append(errors, "å¯†ç å¿…é¡»åŒ…å«å¤§å†™å­—æ¯")
    }

    // åŒ…å«å°å†™å­—æ¯
    if !regexp.MustCompile(`[a-z]`).MatchString(password) {
        errors = append(errors, "å¯†ç å¿…é¡»åŒ…å«å°å†™å­—æ¯")
    }

    // åŒ…å«æ•°å­—
    if !regexp.MustCompile(`[0-9]`).MatchString(password) {
        errors = append(errors, "å¯†ç å¿…é¡»åŒ…å«æ•°å­—")
    }

    // åŒ…å«ç‰¹æ®Šå­—ç¬¦
    hasSpecial := false
    for _, char := range password {
        if unicode.IsPunct(char) || unicode.IsSymbol(char) {
            hasSpecial = true
            break
        }
    }
    if !hasSpecial {
        errors = append(errors, "å¯†ç å¿…é¡»åŒ…å«ç‰¹æ®Šå­—ç¬¦")
    }

    return errors
}

func main() {
    // æµ‹è¯•Bcrypt
    password := "MySecurePassword123!"

    hash, _ := HashPassword(password)
    fmt.Printf("Bcrypt Hash: %s\n", hash)
    fmt.Printf("éªŒè¯å¯†ç : %v\n", CheckPassword(password, hash))

    // æµ‹è¯•å¯†ç å¼ºåº¦
    errors := ValidatePasswordStrength("weak")
    if len(errors) > 0 {
        fmt.Println("å¯†ç å¼ºåº¦ä¸è¶³:")
        for _, err := range errors {
            fmt.Printf("  - %s\n", err)
        }
    }
}
```

---

## ç¬¬ä¸ƒéƒ¨åˆ†ï¼šAPIå¯†é’¥è®¤è¯

### APIå¯†é’¥è®¤è¯åŸç†

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              APIå¯†é’¥è®¤è¯æµç¨‹                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Client â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Server
  â”‚                               â”‚
  â”‚  1. Request with API Key      â”‚
  â”‚     Header: X-API-Key: xxx    â”‚
  â”‚                               â”‚
  â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
  â”‚  2. Validate API Key          â”‚
  â”‚     - Check existence         â”‚
  â”‚     - Check expiration        â”‚
  â”‚     - Check rate limit        â”‚
  â”‚                               â”‚
  â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
     3. Return Response or Error
```

---

### å®æˆ˜æ¡ˆä¾‹5ï¼šAPIå¯†é’¥ç®¡ç†ç³»ç»Ÿ

```go
package main

import (
 "crypto/rand"
 "encoding/hex"
 "fmt"
 "log"
 "net/http"
 "sync"
 "time"

 "github.com/gin-gonic/gin"
)

// ===== APIå¯†é’¥æ•°æ®ç»“æ„ =====
type APIKey struct {
 Key          string
 Name         string
 UserID       int64
 Permissions  []string
 CreatedAt    time.Time
 ExpiresAt    time.Time
 LastUsedAt   time.Time
 RateLimit    int // æ¯åˆ†é’Ÿè¯·æ±‚é™åˆ¶
 RequestCount int // å½“å‰åˆ†é’Ÿè¯·æ±‚æ•°
 ResetAt      time.Time
}

// ===== APIå¯†é’¥ç®¡ç†å™¨ =====
type APIKeyManager struct {
 mu   sync.RWMutex
 keys map[string]*APIKey
}

func NewAPIKeyManager() *APIKeyManager {
 return &APIKeyManager{
  keys: make(map[string]*APIKey),
 }
}

// ç”ŸæˆAPIå¯†é’¥
func (m *APIKeyManager) GenerateKey(name string, userID int64, permissions []string, rateLimit int, ttl time.Duration) (*APIKey, error) {
 // ç”Ÿæˆ32å­—èŠ‚éšæœºå¯†é’¥
 b := make([]byte, 32)
 if _, err := rand.Read(b); err != nil {
  return nil, err
 }

 key := hex.EncodeToString(b)

 apiKey := &APIKey{
  Key:         key,
  Name:        name,
  UserID:      userID,
  Permissions: permissions,
  CreatedAt:   time.Now(),
  ExpiresAt:   time.Now().Add(ttl),
  RateLimit:   rateLimit,
  ResetAt:     time.Now().Add(time.Minute),
 }

 m.mu.Lock()
 m.keys[key] = apiKey
 m.mu.Unlock()

 return apiKey, nil
}

// éªŒè¯APIå¯†é’¥
func (m *APIKeyManager) Validate(key string) (*APIKey, error) {
 m.mu.Lock()
 defer m.mu.Unlock()

 apiKey, exists := m.keys[key]
 if !exists {
  return nil, fmt.Errorf("invalid API key")
 }

 // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
 if time.Now().After(apiKey.ExpiresAt) {
  return nil, fmt.Errorf("API key expired")
 }

 // æ£€æŸ¥é€Ÿç‡é™åˆ¶
 now := time.Now()
 if now.After(apiKey.ResetAt) {
  // é‡ç½®è®¡æ•°å™¨
  apiKey.RequestCount = 0
  apiKey.ResetAt = now.Add(time.Minute)
 }

 if apiKey.RequestCount >= apiKey.RateLimit {
  return nil, fmt.Errorf("rate limit exceeded")
 }

 // å¢åŠ è¯·æ±‚è®¡æ•°
 apiKey.RequestCount++
 apiKey.LastUsedAt = now

 return apiKey, nil
}

// æ’¤é”€APIå¯†é’¥
func (m *APIKeyManager) Revoke(key string) error {
 m.mu.Lock()
 defer m.mu.Unlock()

 delete(m.keys, key)
 return nil
}

// åˆ—å‡ºç”¨æˆ·çš„æ‰€æœ‰APIå¯†é’¥
func (m *APIKeyManager) ListUserKeys(userID int64) []*APIKey {
 m.mu.RLock()
 defer m.mu.RUnlock()

 var keys []*APIKey
 for _, apiKey := range m.keys {
  if apiKey.UserID == userID {
   keys = append(keys, apiKey)
  }
 }

 return keys
}

// ===== ä¸­é—´ä»¶ï¼šAPIå¯†é’¥è®¤è¯ =====
func (m *APIKeyManager) AuthMiddleware() gin.HandlerFunc {
 return func(c *gin.Context) {
  // ä»Headerè·å–APIå¯†é’¥
  apiKey := c.GetHeader("X-API-Key")
  if apiKey == "" {
   c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing API key"})
   c.Abort()
   return
  }

  // éªŒè¯APIå¯†é’¥
  key, err := m.Validate(apiKey)
  if err != nil {
   c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
   c.Abort()
   return
  }

  // å°†APIå¯†é’¥ä¿¡æ¯å­˜å…¥Context
  c.Set("apiKey", key)
  c.Set("userID", key.UserID)
  c.Set("permissions", key.Permissions)

  c.Next()
 }
}

// ===== Handlerç¤ºä¾‹ =====
func setupAPIKeyRoutes(r *gin.Engine, manager *APIKeyManager) {
 // åˆ›å»ºAPIå¯†é’¥
 r.POST("/api/keys", func(c *gin.Context) {
  var req struct {
   Name        string   `json:"name" binding:"required"`
   Permissions []string `json:"permissions"`
   RateLimit   int      `json:"rate_limit"`
   TTLDays     int      `json:"ttl_days"`
  }

  if err := c.ShouldBindJSON(&req); err != nil {
   c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
   return
  }

  // å‡è®¾ç”¨æˆ·IDä»JWTä¸­è·å–
  userID := int64(1)

  if req.RateLimit == 0 {
   req.RateLimit = 60 // é»˜è®¤æ¯åˆ†é’Ÿ60æ¬¡
  }
  if req.TTLDays == 0 {
   req.TTLDays = 365 // é»˜è®¤1å¹´
  }

  apiKey, err := manager.GenerateKey(
   req.Name,
   userID,
   req.Permissions,
   req.RateLimit,
   time.Duration(req.TTLDays)*24*time.Hour,
  )

  if err != nil {
   c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
   return
  }

  c.JSON(http.StatusOK, gin.H{
   "key":        apiKey.Key,
   "name":       apiKey.Name,
   "created_at": apiKey.CreatedAt,
   "expires_at": apiKey.ExpiresAt,
  })
 })

 // åˆ—å‡ºAPIå¯†é’¥
 r.GET("/api/keys", func(c *gin.Context) {
  userID := int64(1) // ä»JWTè·å–
  keys := manager.ListUserKeys(userID)

  var response []map[string]interface{}
  for _, key := range keys {
   response = append(response, map[string]interface{}{
    "name":       key.Name,
    "created_at": key.CreatedAt,
    "expires_at": key.ExpiresAt,
    "last_used":  key.LastUsedAt,
   })
  }

  c.JSON(http.StatusOK, gin.H{"keys": response})
 })

 // æ’¤é”€APIå¯†é’¥
 r.DELETE("/api/keys/:key", func(c *gin.Context) {
  key := c.Param("key")

  if err := manager.Revoke(key); err != nil {
   c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
   return
  }

  c.JSON(http.StatusOK, gin.H{"message": "API key revoked"})
 })

 // ä½¿ç”¨APIå¯†é’¥è®¿é—®å—ä¿æŠ¤èµ„æº
 api := r.Group("/api/v1")
 api.Use(manager.AuthMiddleware())
 {
  api.GET("/data", func(c *gin.Context) {
   c.JSON(http.StatusOK, gin.H{"data": "Protected data"})
  })
 }
}

func main() {
 r := gin.Default()
 manager := NewAPIKeyManager()

 setupAPIKeyRoutes(r, manager)

 r.Run(":8080")
}
```

---

## ç¬¬å…«éƒ¨åˆ†ï¼šå¤šå› ç´ è®¤è¯MFA

### MFAåŸç†

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              å¤šå› ç´ è®¤è¯ï¼ˆMFAï¼‰                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

è®¤è¯å› ç´ :
1ï¸âƒ£ çŸ¥è¯†å› ç´  - ä½ çŸ¥é“ä»€ä¹ˆï¼ˆå¯†ç ã€PINï¼‰
2ï¸âƒ£ æŒæœ‰å› ç´  - ä½ æ‹¥æœ‰ä»€ä¹ˆï¼ˆæ‰‹æœºã€ç¡¬ä»¶ä»¤ç‰Œï¼‰
3ï¸âƒ£ ç”Ÿç‰©å› ç´  - ä½ æ˜¯ä»€ä¹ˆï¼ˆæŒ‡çº¹ã€é¢éƒ¨ï¼‰

å¸¸è§MFAæ–¹å¼:
âœ… TOTPï¼ˆåŸºäºæ—¶é—´çš„ä¸€æ¬¡æ€§å¯†ç ï¼‰- Google Authenticator
âœ… SMSï¼ˆçŸ­ä¿¡éªŒè¯ç ï¼‰
âœ… Emailï¼ˆé‚®ä»¶éªŒè¯ç ï¼‰
âœ… ç¡¬ä»¶ä»¤ç‰Œï¼ˆYubiKeyï¼‰
```

---

### å®æˆ˜æ¡ˆä¾‹6ï¼šTOTPåŒå› ç´ è®¤è¯

```go
package main

import (
 "crypto/hmac"
 "crypto/rand"
 "crypto/sha1"
 "encoding/base32"
 "encoding/binary"
 "fmt"
 "net/http"
 "sync"
 "time"

 "github.com/gin-gonic/gin"
)

// ===== TOTPå®ç° =====
type TOTPManager struct {
 secret string
}

func NewTOTPManager(secret string) *TOTPManager {
 return &TOTPManager{secret: secret}
}

// ç”ŸæˆTOTPå¯†é’¥
func GenerateTOTPSecret() string {
 // ç”Ÿæˆ20å­—èŠ‚éšæœºå¯†é’¥
 b := make([]byte, 20)
 rand.Read(b)
 return base32.StdEncoding.EncodeToString(b)
}

// ç”ŸæˆTOTPç 
func (t *TOTPManager) GenerateCode(timestamp time.Time) string {
 // å°†æ—¶é—´æˆ³è½¬æ¢ä¸º30ç§’æ—¶é—´çª—å£
 counter := uint64(timestamp.Unix() / 30)

 return t.generateHOTP(counter)
}

func (t *TOTPManager) generateHOTP(counter uint64) string {
 // è§£ç å¯†é’¥
 key, err := base32.StdEncoding.DecodeString(t.secret)
 if err != nil {
  return ""
 }

 // å°†è®¡æ•°å™¨è½¬æ¢ä¸ºå­—èŠ‚
 buf := make([]byte, 8)
 binary.BigEndian.PutUint64(buf, counter)

 // HMAC-SHA1
 h := hmac.New(sha1.New, key)
 h.Write(buf)
 hash := h.Sum(nil)

 // åŠ¨æ€æˆªæ–­
 offset := hash[len(hash)-1] & 0x0F
 truncated := binary.BigEndian.Uint32(hash[offset:]) & 0x7FFFFFFF

 // ç”Ÿæˆ6ä½æ•°å­—
 code := truncated % 1000000

 return fmt.Sprintf("%06d", code)
}

// éªŒè¯TOTPç 
func (t *TOTPManager) ValidateCode(code string) bool {
 now := time.Now()

 // æ£€æŸ¥å½“å‰æ—¶é—´çª—å£
 if t.GenerateCode(now) == code {
  return true
 }

 // æ£€æŸ¥å‰ä¸€ä¸ªæ—¶é—´çª—å£ï¼ˆå…è®¸30ç§’è¯¯å·®ï¼‰
 if t.GenerateCode(now.Add(-30*time.Second)) == code {
  return true
 }

 // æ£€æŸ¥åä¸€ä¸ªæ—¶é—´çª—å£
 if t.GenerateCode(now.Add(30*time.Second)) == code {
  return true
 }

 return false
}

// ç”ŸæˆQRç URIï¼ˆç”¨äºGoogle Authenticatorï¼‰
func (t *TOTPManager) GenerateQRCodeURI(accountName, issuer string) string {
 return fmt.Sprintf("otpauth://totp/%s:%s?secret=%s&issuer=%s",
  issuer, accountName, t.secret, issuer)
}

// ===== MFAç”¨æˆ·ç®¡ç† =====
type MFAUser struct {
 UserID       int64
 Username     string
 TOTPSecret   string
 MFAEnabled   bool
 BackupCodes  []string
}

type MFAManager struct {
 mu    sync.RWMutex
 users map[int64]*MFAUser
}

func NewMFAManager() *MFAManager {
 return &MFAManager{
  users: make(map[int64]*MFAUser),
 }
}

// å¯ç”¨MFA
func (m *MFAManager) EnableMFA(userID int64, username string) (*MFAUser, error) {
 secret := GenerateTOTPSecret()

 // ç”Ÿæˆå¤‡ç”¨ç 
 backupCodes := make([]string, 10)
 for i := 0; i < 10; i++ {
  b := make([]byte, 4)
  rand.Read(b)
  backupCodes[i] = fmt.Sprintf("%08x", b)
 }

 user := &MFAUser{
  UserID:      userID,
  Username:    username,
  TOTPSecret:  secret,
  MFAEnabled:  true,
  BackupCodes: backupCodes,
 }

 m.mu.Lock()
 m.users[userID] = user
 m.mu.Unlock()

 return user, nil
}

// éªŒè¯MFAç 
func (m *MFAManager) VerifyMFA(userID int64, code string) bool {
 m.mu.RLock()
 user, exists := m.users[userID]
 m.mu.RUnlock()

 if !exists || !user.MFAEnabled {
  return false
 }

 // éªŒè¯TOTPç 
 totp := NewTOTPManager(user.TOTPSecret)
 if totp.ValidateCode(code) {
  return true
 }

 // éªŒè¯å¤‡ç”¨ç 
 m.mu.Lock()
 defer m.mu.Unlock()

 for i, backupCode := range user.BackupCodes {
  if backupCode == code {
   // ä½¿ç”¨ååˆ é™¤å¤‡ç”¨ç 
   user.BackupCodes = append(user.BackupCodes[:i], user.BackupCodes[i+1:]...)
   return true
  }
 }

 return false
}

// ===== Handlerç¤ºä¾‹ =====
func setupMFARoutes(r *gin.Engine, mfaManager *MFAManager) {
 // å¯ç”¨MFA
 r.POST("/api/mfa/enable", func(c *gin.Context) {
  // å‡è®¾ç”¨æˆ·å·²ç™»å½•
  userID := int64(1)
  username := "alice"

  user, err := mfaManager.EnableMFA(userID, username)
  if err != nil {
   c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
   return
  }

  totp := NewTOTPManager(user.TOTPSecret)
  qrURI := totp.GenerateQRCodeURI(username, "MyApp")

  c.JSON(http.StatusOK, gin.H{
   "secret":       user.TOTPSecret,
   "qr_code_uri":  qrURI,
   "backup_codes": user.BackupCodes,
  })
 })

 // éªŒè¯MFA
 r.POST("/api/mfa/verify", func(c *gin.Context) {
  var req struct {
   UserID int64  `json:"user_id" binding:"required"`
   Code   string `json:"code" binding:"required"`
  }

  if err := c.ShouldBindJSON(&req); err != nil {
   c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
   return
  }

  if mfaManager.VerifyMFA(req.UserID, req.Code) {
   c.JSON(http.StatusOK, gin.H{"message": "MFA verification successful"})
  } else {
   c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid MFA code"})
  }
 })
}
```

---

## ç¬¬ä¹éƒ¨åˆ†ï¼šå•ç‚¹ç™»å½•SSO

### SSOåŸç†

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              å•ç‚¹ç™»å½•ï¼ˆSSOï¼‰æµç¨‹                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. ç”¨æˆ·è®¿é—®App1
   App1 â”€â”€â”€â”€â”€> SSO Server (æœªç™»å½•ï¼Œé‡å®šå‘åˆ°ç™»å½•é¡µ)

2. ç”¨æˆ·åœ¨SSOç™»å½•
   User â”€â”€â”€â”€â”€> SSO Server (è¾“å…¥å‡­è¯)
   SSO Server â”€â”€â”€â”€â”€> Set Global Session

3. è¿”å›App1
   SSO Server â”€â”€â”€â”€â”€> App1 (Token)
   App1 â”€â”€â”€â”€â”€> Set Local Session

4. ç”¨æˆ·è®¿é—®App2
   App2 â”€â”€â”€â”€â”€> SSO Server (æ£€æŸ¥Global Session)
   SSO Server â”€â”€â”€â”€â”€> App2 (Tokenï¼Œæ— éœ€é‡æ–°ç™»å½•)
```

---

### å®æˆ˜æ¡ˆä¾‹7ï¼šç®€å•SSOå®ç°

```go
package main

import (
 "crypto/rand"
 "encoding/base64"
 "fmt"
 "net/http"
 "sync"
 "time"

 "github.com/gin-gonic/gin"
)

// ===== SSOç¥¨æ® =====
type SSOTicket struct {
 Ticket    string
 UserID    int64
 Username  string
 CreatedAt time.Time
 ExpiresAt time.Time
 Apps      map[string]bool // å·²ç™»å½•çš„åº”ç”¨
}

// ===== SSOæœåŠ¡å™¨ =====
type SSOServer struct {
 mu      sync.RWMutex
 tickets map[string]*SSOTicket
 users   map[string]string // username -> password
}

func NewSSOServer() *SSOServer {
 server := &SSOServer{
  tickets: make(map[string]*SSOTicket),
  users: map[string]string{
   "alice": "password123",
   "bob":   "password456",
  },
 }

 // å®šæœŸæ¸…ç†è¿‡æœŸç¥¨æ®
 go server.cleanup()

 return server
}

func (s *SSOServer) cleanup() {
 ticker := time.NewTicker(5 * time.Minute)
 defer ticker.Stop()

 for range ticker.C {
  s.mu.Lock()
  for ticket, t := range s.tickets {
   if time.Now().After(t.ExpiresAt) {
    delete(s.tickets, ticket)
   }
  }
  s.mu.Unlock()
 }
}

// ç”Ÿæˆç¥¨æ®
func generateTicket() (string, error) {
 b := make([]byte, 32)
 if _, err := rand.Read(b); err != nil {
  return "", err
 }
 return base64.URLEncoding.EncodeToString(b), nil
}

// SSOç™»å½•
func (s *SSOServer) Login(username, password string) (string, error) {
 // éªŒè¯å‡­è¯
 storedPassword, exists := s.users[username]
 if !exists || storedPassword != password {
  return "", fmt.Errorf("invalid credentials")
 }

 // ç”Ÿæˆç¥¨æ®
 ticket, err := generateTicket()
 if err != nil {
  return "", err
 }

 s.mu.Lock()
 s.tickets[ticket] = &SSOTicket{
  Ticket:    ticket,
  UserID:    1,
  Username:  username,
  CreatedAt: time.Now(),
  ExpiresAt: time.Now().Add(8 * time.Hour),
  Apps:      make(map[string]bool),
 }
 s.mu.Unlock()

 return ticket, nil
}

// éªŒè¯ç¥¨æ®
func (s *SSOServer) ValidateTicket(ticket, appID string) (*SSOTicket, error) {
 s.mu.Lock()
 defer s.mu.Unlock()

 t, exists := s.tickets[ticket]
 if !exists {
  return nil, fmt.Errorf("invalid ticket")
 }

 if time.Now().After(t.ExpiresAt) {
  delete(s.tickets, ticket)
  return nil, fmt.Errorf("ticket expired")
 }

 // è®°å½•åº”ç”¨è®¿é—®
 t.Apps[appID] = true

 return t, nil
}

// ç™»å‡º
func (s *SSOServer) Logout(ticket string) error {
 s.mu.Lock()
 defer s.mu.Unlock()

 delete(s.tickets, ticket)
 return nil
}

// ===== SSO Handler =====
func setupSSORoutes(r *gin.Engine, sso *SSOServer) {
 // SSOç™»å½•é¡µé¢
 r.POST("/sso/login", func(c *gin.Context) {
  var req struct {
   Username string `json:"username" binding:"required"`
   Password string `json:"password" binding:"required"`
   AppID    string `json:"app_id"`
  }

  if err := c.ShouldBindJSON(&req); err != nil {
   c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
   return
  }

  ticket, err := sso.Login(req.Username, req.Password)
  if err != nil {
   c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
   return
  }

  c.JSON(http.StatusOK, gin.H{
   "ticket": ticket,
   "message": "Login successful",
  })
 })

 // SSOç¥¨æ®éªŒè¯
 r.POST("/sso/validate", func(c *gin.Context) {
  var req struct {
   Ticket string `json:"ticket" binding:"required"`
   AppID  string `json:"app_id" binding:"required"`
  }

  if err := c.ShouldBindJSON(&req); err != nil {
   c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
   return
  }

  ticket, err := sso.ValidateTicket(req.Ticket, req.AppID)
  if err != nil {
   c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
   return
  }

  c.JSON(http.StatusOK, gin.H{
   "user_id":  ticket.UserID,
   "username": ticket.Username,
   "valid":    true,
  })
 })

 // SSOç™»å‡º
 r.POST("/sso/logout", func(c *gin.Context) {
  var req struct {
   Ticket string `json:"ticket" binding:"required"`
  }

  if err := c.ShouldBindJSON(&req); err != nil {
   c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
   return
  }

  sso.Logout(req.Ticket)

  c.JSON(http.StatusOK, gin.H{"message": "Logout successful"})
 })
}
```

---

## ç¬¬åéƒ¨åˆ†ï¼šå®‰å…¨æœ€ä½³å®è·µ

### å®æˆ˜æ¡ˆä¾‹8ï¼šå®‰å…¨ä¸­é—´ä»¶é›†åˆ

```go
package main

import (
 "log"
 "net/http"
 "strings"
 "sync"
 "time"

 "github.com/gin-gonic/gin"
 "golang.org/x/time/rate"
)

// ===== 1. CSRFé˜²æŠ¤ =====
func CSRFMiddleware() gin.HandlerFunc {
 return func(c *gin.Context) {
  // æ£€æŸ¥è¯·æ±‚æ–¹æ³•
  if c.Request.Method != "GET" && c.Request.Method != "HEAD" {
   csrfToken := c.GetHeader("X-CSRF-Token")
   expectedToken := c.GetString("csrf_token") // ä»sessionè·å–

   if csrfToken == "" || csrfToken != expectedToken {
    c.JSON(http.StatusForbidden, gin.H{"error": "CSRF token mismatch"})
    c.Abort()
    return
   }
  }

  c.Next()
 }
}

// ===== 2. XSSé˜²æŠ¤ =====
func SecurityHeadersMiddleware() gin.HandlerFunc {
 return func(c *gin.Context) {
  // è®¾ç½®å®‰å…¨å¤´
  c.Header("X-Frame-Options", "DENY")
  c.Header("X-Content-Type-Options", "nosniff")
  c.Header("X-XSS-Protection", "1; mode=block")
  c.Header("Content-Security-Policy", "default-src 'self'")
  c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")

  c.Next()
 }
}

// ===== 3. é™æµä¸­é—´ä»¶ =====
type IPRateLimiter struct {
 limiters map[string]*rate.Limiter
 mu       sync.RWMutex
 rate     rate.Limit
 burst    int
}

func NewIPRateLimiter(r rate.Limit, b int) *IPRateLimiter {
 return &IPRateLimiter{
  limiters: make(map[string]*rate.Limiter),
  rate:     r,
  burst:    b,
 }
}

func (i *IPRateLimiter) GetLimiter(ip string) *rate.Limiter {
 i.mu.Lock()
 defer i.mu.Unlock()

 limiter, exists := i.limiters[ip]
 if !exists {
  limiter = rate.NewLimiter(i.rate, i.burst)
  i.limiters[ip] = limiter
 }

 return limiter
}

func (i *IPRateLimiter) Middleware() gin.HandlerFunc {
 return func(c *gin.Context) {
  ip := c.ClientIP()
  limiter := i.GetLimiter(ip)

  if !limiter.Allow() {
   c.JSON(http.StatusTooManyRequests, gin.H{
    "error": "Rate limit exceeded",
   })
   c.Abort()
   return
  }

  c.Next()
 }
}

// ===== 4. å®¡è®¡æ—¥å¿—ä¸­é—´ä»¶ =====
func AuditLogMiddleware() gin.HandlerFunc {
 return func(c *gin.Context) {
  start := time.Now()

  // è®°å½•è¯·æ±‚ä¿¡æ¯
  method := c.Request.Method
  path := c.Request.URL.Path
  ip := c.ClientIP()
  userAgent := c.Request.UserAgent()

  c.Next()

  // è®°å½•å“åº”ä¿¡æ¯
  statusCode := c.Writer.Status()
  duration := time.Since(start)

  // è®°å½•å®¡è®¡æ—¥å¿—ï¼ˆç®€åŒ–ç‰ˆï¼Œå®é™…åº”å†™å…¥æ•°æ®åº“ï¼‰
  log.Printf("[AUDIT] %s %s %s %d %v %s",
   method, path, ip, statusCode, duration, userAgent)
 }
}

// ===== 5. è¾“å…¥éªŒè¯ =====
func SanitizeInput(input string) string {
 // ç§»é™¤å±é™©å­—ç¬¦
 input = strings.ReplaceAll(input, "<", "&lt;")
 input = strings.ReplaceAll(input, ">", "&gt;")
 input = strings.ReplaceAll(input, "\"", "&quot;")
 input = strings.ReplaceAll(input, "'", "&#x27;")
 input = strings.ReplaceAll(input, "/", "&#x2F;")

 return input
}
```

---

## ç¬¬åä¸€éƒ¨åˆ†ï¼šå®Œæ•´é¡¹ç›®å®æˆ˜

### å®æˆ˜æ¡ˆä¾‹9ï¼šå®Œæ•´çš„è®¤è¯æˆæƒç³»ç»Ÿ

```go
package main

import (
 "log"
 "net/http"
 "strings"
 "time"

 "github.com/gin-gonic/gin"
)

// ===== å®Œæ•´çš„è®¤è¯æˆæƒç³»ç»Ÿ =====
type AuthSystem struct {
 sessionManager *SessionManager
 jwtManager     *JWTManager
 rbacManager    *RBACManager
 apiKeyManager  *APIKeyManager
 mfaManager     *MFAManager
 rateLimiter    *IPRateLimiter
}

func NewAuthSystem() *AuthSystem {
 return &AuthSystem{
  sessionManager: NewSessionManager(NewMemoryStore()),
  rbacManager:    NewRBACManager(),
  apiKeyManager:  NewAPIKeyManager(),
  mfaManager:     NewMFAManager(),
  rateLimiter:    NewIPRateLimiter(10, 20), // 10 req/s, burst 20
 }
}

// ç»Ÿä¸€è®¤è¯ä¸­é—´ä»¶
func (a *AuthSystem) AuthMiddleware() gin.HandlerFunc {
 return func(c *gin.Context) {
  // 1. å°è¯•API Keyè®¤è¯
  apiKey := c.GetHeader("X-API-Key")
  if apiKey != "" {
   key, err := a.apiKeyManager.Validate(apiKey)
   if err == nil {
    c.Set("userID", key.UserID)
    c.Set("authType", "api_key")
    c.Next()
    return
   }
  }

  // 2. å°è¯•JWTè®¤è¯
  authHeader := c.GetHeader("Authorization")
  if authHeader != "" {
   parts := strings.SplitN(authHeader, " ", 2)
   if len(parts) == 2 && parts[0] == "Bearer" {
    claims, err := ParseToken(parts[1])
    if err == nil {
     c.Set("userID", claims.UserID)
     c.Set("authType", "jwt")
     c.Next()
     return
    }
   }
  }

  // 3. å°è¯•Sessionè®¤è¯
  session, err := a.sessionManager.Get(c)
  if err == nil {
   c.Set("userID", session["userID"])
   c.Set("authType", "session")
   c.Next()
   return
  }

  // è®¤è¯å¤±è´¥
  c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
  c.Abort()
 }
}

// è®¾ç½®å®Œæ•´è·¯ç”±
func (a *AuthSystem) SetupRoutes(r *gin.Engine) {
 // åº”ç”¨å…¨å±€ä¸­é—´ä»¶
 r.Use(SecurityHeadersMiddleware())
 r.Use(a.rateLimiter.Middleware())
 r.Use(AuditLogMiddleware())

 // å…¬å¼€è·¯ç”±
 public := r.Group("/api/public")
 {
  // æ³¨å†Œ
  public.POST("/register", a.handleRegister)

  // ç™»å½•ï¼ˆæ”¯æŒå¤šç§æ–¹å¼ï¼‰
  public.POST("/login", a.handleLogin)

  // OAuth2.0ç«¯ç‚¹
  public.GET("/oauth/authorize", a.handleOAuthAuthorize)
  public.POST("/oauth/token", a.handleOAuthToken)
 }

 // å—ä¿æŠ¤è·¯ç”±
 protected := r.Group("/api")
 protected.Use(a.AuthMiddleware())
 {
  // ç”¨æˆ·ä¿¡æ¯
  protected.GET("/me", a.handleGetProfile)
  protected.PUT("/me", a.handleUpdateProfile)

  // MFAç®¡ç†
  protected.POST("/mfa/enable", a.handleEnableMFA)
  protected.POST("/mfa/verify", a.handleVerifyMFA)

  // APIå¯†é’¥ç®¡ç†
  protected.POST("/keys", a.handleCreateAPIKey)
  protected.GET("/keys", a.handleListAPIKeys)
  protected.DELETE("/keys/:key", a.handleRevokeAPIKey)

  // ç®¡ç†å‘˜è·¯ç”±ï¼ˆéœ€è¦adminè§’è‰²ï¼‰
  admin := protected.Group("/admin")
  admin.Use(a.rbacManager.RequirePermission("admin", "manage"))
  {
   admin.GET("/users", a.handleListUsers)
   admin.POST("/users/:id/roles", a.handleAssignRole)
  }
 }
}

// Handlerå®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰
func (a *AuthSystem) handleRegister(c *gin.Context) {
 // æ³¨å†Œé€»è¾‘
 c.JSON(http.StatusOK, gin.H{"message": "Registration successful"})
}

func (a *AuthSystem) handleLogin(c *gin.Context) {
 var req struct {
  Username string `json:"username" binding:"required"`
  Password string `json:"password" binding:"required"`
  Method   string `json:"method"` // "session" or "jwt"
 }

 if err := c.ShouldBindJSON(&req); err != nil {
  c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
  return
 }

 // éªŒè¯å‡­è¯ï¼ˆç®€åŒ–ç‰ˆï¼‰
 if req.Username != "alice" || req.Password != "password123" {
  c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
  return
 }

 // æ ¹æ®è¯·æ±‚çš„æ–¹æ³•è¿”å›ä¸åŒç±»å‹çš„å‡­è¯
 if req.Method == "jwt" {
  token, _ := GenerateToken(1, req.Username, "user")
  c.JSON(http.StatusOK, gin.H{
   "token": token,
   "type":  "Bearer",
  })
 } else {
  // é»˜è®¤ä½¿ç”¨Session
  sid, _ := a.sessionManager.Create(c, map[string]interface{}{
   "userID":   1,
   "username": req.Username,
  })
  c.JSON(http.StatusOK, gin.H{
   "session_id": sid,
   "message":    "Login successful",
  })
 }
}

func (a *AuthSystem) handleGetProfile(c *gin.Context) {
 userID := c.GetInt64("userID")
 authType := c.GetString("authType")

 c.JSON(http.StatusOK, gin.H{
  "user_id":   userID,
  "auth_type": authType,
  "profile":   map[string]interface{}{
   "name":  "Alice",
   "email": "alice@example.com",
  },
 })
}

func (a *AuthSystem) handleUpdateProfile(c *gin.Context) {
 c.JSON(http.StatusOK, gin.H{"message": "Profile updated"})
}

func (a *AuthSystem) handleEnableMFA(c *gin.Context) {
 // MFAå¯ç”¨é€»è¾‘
 c.JSON(http.StatusOK, gin.H{"message": "MFA enabled"})
}

func (a *AuthSystem) handleVerifyMFA(c *gin.Context) {
 // MFAéªŒè¯é€»è¾‘
 c.JSON(http.StatusOK, gin.H{"message": "MFA verified"})
}

func (a *AuthSystem) handleCreateAPIKey(c *gin.Context) {
 // APIå¯†é’¥åˆ›å»ºé€»è¾‘
 c.JSON(http.StatusOK, gin.H{"message": "API key created"})
}

func (a *AuthSystem) handleListAPIKeys(c *gin.Context) {
 c.JSON(http.StatusOK, gin.H{"keys": []interface{}{}})
}

func (a *AuthSystem) handleRevokeAPIKey(c *gin.Context) {
 c.JSON(http.StatusOK, gin.H{"message": "API key revoked"})
}

func (a *AuthSystem) handleOAuthAuthorize(c *gin.Context) {
 c.JSON(http.StatusOK, gin.H{"message": "OAuth authorize"})
}

func (a *AuthSystem) handleOAuthToken(c *gin.Context) {
 c.JSON(http.StatusOK, gin.H{"message": "OAuth token"})
}

func (a *AuthSystem) handleListUsers(c *gin.Context) {
 c.JSON(http.StatusOK, gin.H{"users": []interface{}{}})
}

func (a *AuthSystem) handleAssignRole(c *gin.Context) {
 c.JSON(http.StatusOK, gin.H{"message": "Role assigned"})
}

func main() {
 r := gin.Default()

 authSystem := NewAuthSystem()
 authSystem.SetupRoutes(r)

 log.Println("Authentication system running on :8080")
 r.Run(":8080")
}
```

---

## ğŸ¯ æ€»ç»“

### è®¤è¯æˆæƒæ ¸å¿ƒè¦ç‚¹

1. **Sessionè®¤è¯** - Cookie+æœåŠ¡ç«¯å­˜å‚¨
2. **JWTè®¤è¯** - æ— çŠ¶æ€Token
3. **OAuth2.0** - ç¬¬ä¸‰æ–¹æˆæƒ
4. **RBAC** - åŸºäºè§’è‰²çš„æƒé™æ§åˆ¶
5. **å¯†ç å®‰å…¨** - Bcrypt/Argon2åŠ å¯†
6. **APIå¯†é’¥** - æœåŠ¡é—´è®¤è¯
7. **MFA** - å¤šå› ç´ è®¤è¯å¢å¼ºå®‰å…¨
8. **SSO** - å•ç‚¹ç™»å½•
9. **å®‰å…¨æœ€ä½³å®è·µ** - HTTPSã€CSRFã€XSSé˜²æŠ¤

### æœ€ä½³å®è·µæ¸…å•

```text
âœ… ä½¿ç”¨HTTPSä¼ è¾“æ•æ„Ÿæ•°æ®
âœ… å¯†ç ä½¿ç”¨Bcrypt/Argon2åŠ å¯†
âœ… JWTä½¿ç”¨å¼ºéšæœºå¯†é’¥
âœ… Tokenè®¾ç½®åˆç†è¿‡æœŸæ—¶é—´
âœ… å®ç°Tokenåˆ·æ–°æœºåˆ¶
âœ… ä½¿ç”¨RBACè¿›è¡Œç»†ç²’åº¦æƒé™æ§åˆ¶
âœ… å®æ–½å¯†ç å¼ºåº¦ç­–ç•¥
âœ… é˜²æ­¢æš´åŠ›ç ´è§£ï¼ˆé™æµ+éªŒè¯ç ï¼‰
âœ… è®°å½•å®¡è®¡æ—¥å¿—
âœ… å®šæœŸæ›´æ–°ä¾èµ–åº“
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v12.0

<div align="center">

Made with â¤ï¸ for Go Security Developers

[â¬† å›åˆ°é¡¶éƒ¨](#å›åˆ°é¡¶éƒ¨)

</div>

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team
**æœ€åæ›´æ–°**: 2025-10-29
**æ–‡æ¡£çŠ¶æ€**: å®Œæˆ
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
