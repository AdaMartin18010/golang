# Go数据库编程

**版本**: v1.0
**更新日期**: 2025-11-11
**适用于**: Go 1.25.3

---

## 📋 目录

- [Go数据库编程](#go数据库编程)
  - [📋 目录](#-目录)
  - [第一部分：database/sql基础](#第一部分databasesql基础)
    - [为什么学习database/sql？](#为什么学习databasesql)
    - [核心类型](#核心类型)
    - [实战案例1：database/sql完整示例](#实战案例1databasesql完整示例)
  - [第二部分：GORM深度实战](#第二部分gorm深度实战)
    - [为什么选择GORM？](#为什么选择gorm)
    - [GORM核心概念](#gorm核心概念)
    - [实战案例2：GORM完整CRUD](#实战案例2gorm完整crud)
    - [实战案例3：GORM关联关系](#实战案例3gorm关联关系)
    - [实战案例4：GORM钩子函数](#实战案例4gorm钩子函数)
  - [第三部分：sqlx深度实战](#第三部分sqlx深度实战)
    - [为什么选择sqlx？](#为什么选择sqlx)
    - [实战案例5：sqlx完整示例](#实战案例5sqlx完整示例)
    - [实战案例6：sqlx高级查询](#实战案例6sqlx高级查询)
  - [第四部分：连接池与性能优化](#第四部分连接池与性能优化)
    - [连接池配置最佳实践](#连接池配置最佳实践)
    - [实战案例7：性能对比测试](#实战案例7性能对比测试)
  - [第五部分：事务处理深度实战](#第五部分事务处理深度实战)
    - [事务隔离级别](#事务隔离级别)
    - [实战案例8：事务处理完整示例](#实战案例8事务处理完整示例)
  - [第六部分：数据库迁移与版本管理](#第六部分数据库迁移与版本管理)
    - [实战案例9：使用golang-migrate](#实战案例9使用golang-migrate)
  - [第七部分：查询优化与索引](#第七部分查询优化与索引)
    - [索引类型与使用场景](#索引类型与使用场景)
    - [查询优化技巧](#查询优化技巧)
  - [第八部分：完整实战项目](#第八部分完整实战项目)
    - [项目结构](#项目结构)
    - [完整代码示例](#完整代码示例)
      - [models/user.go](#modelsusergo)
      - [repository/article\_repo.go](#repositoryarticle_repogo)
      - [service/article\_service.go](#servicearticle_servicego)
  - [🎯 总结](#-总结)
    - [数据库编程核心要点](#数据库编程核心要点)
    - [技术选型建议](#技术选型建议)
    - [最佳实践清单](#最佳实践清单)

---

## 第一部分：database/sql基础

### 为什么学习database/sql？

```text
✅ Go标准库 - 无需第三方依赖
✅ 通用接口 - 支持所有SQL数据库
✅ 连接池管理 - 内置高效连接池
✅ 预编译语句 - 防止SQL注入
✅ 并发安全 - 天然支持并发
```

---

### 核心类型

| 类型 | 作用 | 关键方法 |
|------|------|---------|
| **sql.DB** | 数据库连接池 | Query(), Exec(), Ping() |
| **sql.Tx** | 事务 | Commit(), Rollback() |
| **sql.Stmt** | 预编译语句 | Query(), Exec(), Close() |
| **sql.Rows** | 查询结果集 | Next(), Scan(), Close() |
| **sql.Result** | 执行结果 | LastInsertId(), RowsAffected() |

---

### 实战案例1：database/sql完整示例

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
    "log"
    "time"

    _ "github.com/go-sql-driver/mysql"
)

// User 用户模型
type User struct {
    ID        int64
    Username  string
    Email     sql.NullString // 可能为NULL的字段
    CreatedAt time.Time
}

func main() {
    // 1. 连接数据库
    dsn := "user:password@tcp(127.0.0.1:3306)/testdb?parseTime=true&charset=utf8mb4"
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()

    // 2. 配置连接池
    db.SetMaxOpenConns(25)                 // 最大打开连接数
    db.SetMaxIdleConns(25)                 // 最大空闲连接数
    db.SetConnMaxLifetime(5 * time.Minute) // 连接最大生命周期

    // 3. 测试连接
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    if err := db.PingContext(ctx); err != nil {
        log.Fatal("Failed to ping database:", err)
    }

    fmt.Println("Database connected successfully!")

    // 4. 创建用户
    user := &User{
        Username: "alice",
        Email:    sql.NullString{String: "alice@example.com", Valid: true},
    }

    if err := CreateUser(ctx, db, user); err != nil {
        log.Fatal("Failed to create user:", err)
    }

    fmt.Printf("User created: ID=%d\n", user.ID)

    // 5. 查询用户
    fetchedUser, err := GetUser(ctx, db, user.ID)
    if err != nil {
        log.Fatal("Failed to get user:", err)
    }

    fmt.Printf("User fetched: %+v\n", fetchedUser)

    // 6. 更新用户
    fetchedUser.Email = sql.NullString{String: "alice.new@example.com", Valid: true}
    if err := UpdateUser(ctx, db, fetchedUser); err != nil {
        log.Fatal("Failed to update user:", err)
    }

    fmt.Println("User updated successfully!")

    // 7. 删除用户
    if err := DeleteUser(ctx, db, user.ID); err != nil {
        log.Fatal("Failed to delete user:", err)
    }

    fmt.Println("User deleted successfully!")
}

// CreateUser 创建用户
func CreateUser(ctx Context.Context, db *sql.DB, user *User) error {
    query := `INSERT INTO users (username, email, created_at) VALUES (?, ?, ?)`

    result, err := db.ExecContext(ctx, query, user.Username, user.Email, time.Now())
    if err != nil {
        return err
    }

    id, err := result.LastInsertId()
    if err != nil {
        return err
    }

    user.ID = id
    return nil
}

// GetUser 获取用户
func GetUser(ctx Context.Context, db *sql.DB, id int64) (*User, error) {
    query := `SELECT id, username, email, created_at FROM users WHERE id = ?`

    user := &User{}
    err := db.QueryRowContext(ctx, query, id).Scan(
        &user.ID,
        &user.Username,
        &user.Email,
        &user.CreatedAt,
    )

    if err != nil {
        if err == sql.ErrNoRows {
            return nil, fmt.Errorf("user not found")
        }
        return nil, err
    }

    return user, nil
}

// UpdateUser 更新用户
func UpdateUser(ctx Context.Context, db *sql.DB, user *User) error {
    query := `UPDATE users SET username = ?, email = ? WHERE id = ?`

    result, err := db.ExecContext(ctx, query, user.Username, user.Email, user.ID)
    if err != nil {
        return err
    }

    rows, err := result.RowsAffected()
    if err != nil {
        return err
    }

    if rows == 0 {
        return fmt.Errorf("user not found")
    }

    return nil
}

// DeleteUser 删除用户
func DeleteUser(ctx Context.Context, db *sql.DB, id int64) error {
    query := `DELETE FROM users WHERE id = ?`

    result, err := db.ExecContext(ctx, query, id)
    if err != nil {
        return err
    }

    rows, err := result.RowsAffected()
    if err != nil {
        return err
    }

    if rows == 0 {
        return fmt.Errorf("user not found")
    }

    return nil
}

// ListUsers 列出所有用户
func ListUsers(ctx Context.Context, db *sql.DB) ([]*User, error) {
    query := `SELECT id, username, email, created_at FROM users ORDER BY id`

    rows, err := db.QueryContext(ctx, query)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var users []*User
    for rows.Next() {
        user := &User{}
        if err := rows.Scan(&user.ID, &user.Username, &user.Email, &user.CreatedAt); err != nil {
            return nil, err
        }
        users = append(users, user)
    }

    if err := rows.Err(); err != nil {
        return nil, err
    }

    return users, nil
}
```

---

## 第二部分：GORM深度实战

### 为什么选择GORM？

```text
✅ 功能完善 - ORM功能齐全
✅ 开发效率 - 自动迁移、钩子函数
✅ 关联处理 - 一对一、一对多、多对多
✅ 链式调用 - API优雅
✅ 插件生态 - 丰富的插件系统
```

---

### GORM核心概念

| 概念 | 说明 | 示例 |
|------|------|------|
| **模型定义** | 结构体映射到表 | `type User struct {...}` |
| **约定** | 表名、主键、时间戳 | users表、ID主键 |
| **钩子** | BeforeCreate、AfterUpdate | 自动填充字段 |
| **关联** | HasOne、HasMany、BelongsTo | 用户与订单 |
| **预加载** | Preload、Joins | 避免N+1问题 |

---

### 实战案例2：GORM完整CRUD

```go
package main

import (
    "fmt"
    "log"
    "time"

    "gorm.io/driver/mysql"
    "gorm.io/gorm"
    "gorm.io/gorm/logger"
)

// User 用户模型
type User struct {
    ID        uint           `gorm:"primarykey"`
    Username  string         `gorm:"uniqueIndex;not null;size:50"`
    Email     string         `gorm:"uniqueIndex;size:100"`
    Age       int            `gorm:"default:0"`
    Active    bool           `gorm:"default:true"`
    CreatedAt time.Time
    UpdatedAt time.Time
    DeletedAt gorm.DeletedAt `gorm:"index"` // 软删除
}

func main() {
    // 1. 连接数据库
    dsn := "user:password@tcp(127.0.0.1:3306)/testdb?charset=utf8mb4&parseTime=True&loc=Local"
    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
        Logger: logger.Default.LogMode(logger.Info), // 开启SQL日志
    })
    if err != nil {
        log.Fatal("Failed to connect database:", err)
    }

    // 2. 自动迁移（创建表）
    if err := db.AutoMigrate(&User{}); err != nil {
        log.Fatal("Failed to migrate:", err)
    }

    // 3. 创建用户
    user := &User{
        Username: "bob",
        Email:    "bob@example.com",
        Age:      25,
    }

    result := db.Create(user)
    if result.Error != nil {
        log.Fatal("Failed to create user:", result.Error)
    }

    fmt.Printf("User created: ID=%d, RowsAffected=%d\n", user.ID, result.RowsAffected)

    // 4. 查询单个用户
    var fetchedUser User
    db.First(&fetchedUser, user.ID)
    fmt.Printf("User fetched: %+v\n", fetchedUser)

    // 5. 条件查询
    var users []User
    db.Where("age > ?", 20).Find(&users)
    fmt.Printf("Users with age > 20: %d\n", len(users))

    // 6. 更新用户
    db.Model(&user).Update("Age", 26)
    fmt.Println("User age updated to 26")

    // 7. 更新多个字段
    db.Model(&user).Updates(User{Age: 27, Email: "bob.new@example.com"})
    fmt.Println("User updated with multiple fields")

    // 8. 软删除
    db.Delete(&user)
    fmt.Println("User soft deleted")

    // 9. 查询包含软删除的记录
    var deletedUser User
    db.Unscoped().First(&deletedUser, user.ID)
    fmt.Printf("Deleted user found: %+v\n", deletedUser)

    // 10. 永久删除
    db.Unscoped().Delete(&user)
    fmt.Println("User permanently deleted")
}
```

---

### 实战案例3：GORM关联关系

```go
package main

import (
    "fmt"
    "log"
    "time"

    "gorm.io/driver/mysql"
    "gorm.io/gorm"
)

// User 用户（一）
type User struct {
    ID       uint
    Username string
    Profile  Profile  // 一对一：用户资料
    Orders   []Order  // 一对多：用户订单
    Tags     []Tag    `gorm:"many2many:user_tags;"` // 多对多：用户标签
}

// Profile 用户资料（一）
type Profile struct {
    ID      uint
    UserID  uint   // 外键
    Bio     string
    Avatar  string
}

// Order 订单（多）
type Order struct {
    ID      uint
    UserID  uint  // 外键
    Amount  float64
    Status  string
    Items   []OrderItem // 一对多：订单项
}

// OrderItem 订单项
type OrderItem struct {
    ID        uint
    OrderID   uint // 外键
    ProductID uint
    Quantity  int
    Price     float64
}

// Tag 标签（多对多）
type Tag struct {
    ID   uint
    Name string
}

func main() {
    dsn := "user:password@tcp(127.0.0.1:3306)/testdb?charset=utf8mb4&parseTime=True&loc=Local"
    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
    if err != nil {
        log.Fatal(err)
    }

    // 自动迁移
    db.AutoMigrate(&User{}, &Profile{}, &Order{}, &OrderItem{}, &Tag{})

    // 创建带关联的用户
    user := &User{
        Username: "charlie",
        Profile: Profile{
            Bio:    "Go developer",
            Avatar: "avatar.jpg",
        },
        Orders: []Order{
            {Amount: 100.50, Status: "pending"},
            {Amount: 200.75, Status: "completed"},
        },
        Tags: []Tag{
            {Name: "developer"},
            {Name: "golang"},
        },
    }

    // 自动创建关联数据
    db.Create(user)
    fmt.Printf("User created with ID: %d\n", user.ID)

    // 预加载关联数据（解决N+1问题）
    var fetchedUser User
    db.Preload("Profile").
       Preload("Orders").
       Preload("Tags").
       First(&fetchedUser, user.ID)

    fmt.Printf("User: %s\n", fetchedUser.Username)
    fmt.Printf("Profile: %s\n", fetchedUser.Profile.Bio)
    fmt.Printf("Orders: %d\n", len(fetchedUser.Orders))
    fmt.Printf("Tags: %d\n", len(fetchedUser.Tags))

    // 添加关联
    newTag := Tag{Name: "backend"}
    db.Model(&fetchedUser).Association("Tags").Append(&newTag)
    fmt.Println("New tag added")

    // 删除关联（不删除Tag本身）
    db.Model(&fetchedUser).Association("Tags").Delete(&newTag)
    fmt.Println("Tag association removed")
}
```

---

### 实战案例4：GORM钩子函数

```go
package main

import (
    "fmt"
    "time"

    "gorm.io/gorm"
)

// Article 文章模型（带钩子）
type Article struct {
    ID          uint
    Title       string
    Content     string
    Slug        string    // 自动生成
    WordCount   int       // 自动计算
    PublishedAt *time.Time
    CreatedAt   time.Time
    UpdatedAt   time.Time
}

// BeforeCreate 创建前钩子
func (a *Article) BeforeCreate(tx *gorm.DB) error {
    // 1. 生成slug
    a.Slug = generateSlug(a.Title)

    // 2. 计算字数
    a.WordCount = len([]rune(a.Content))

    // 3. 设置发布时间
    if a.PublishedAt == nil {
        now := time.Now()
        a.PublishedAt = &now
    }

    fmt.Println("BeforeCreate hook executed")
    return nil
}

// AfterCreate 创建后钩子
func (a *Article) AfterCreate(tx *gorm.DB) error {
    fmt.Printf("Article created: ID=%d, WordCount=%d\n", a.ID, a.WordCount)

    // 可以在这里发送通知、更新缓存等
    return nil
}

// BeforeUpdate 更新前钩子
func (a *Article) BeforeUpdate(tx *gorm.DB) error {
    // 重新计算字数
    if tx.Statement.Changed("Content") {
        a.WordCount = len([]rune(a.Content))
        fmt.Println("Content changed, recalculating word count")
    }

    return nil
}

// AfterUpdate 更新后钩子
func (a *Article) AfterUpdate(tx *gorm.DB) error {
    fmt.Printf("Article updated: ID=%d\n", a.ID)

    // 清除缓存
    return nil
}

// BeforeDelete 删除前钩子
func (a *Article) BeforeDelete(tx *gorm.DB) error {
    fmt.Printf("Deleting article: ID=%d\n", a.ID)

    // 可以在这里备份数据、删除关联文件等
    return nil
}

// generateSlug 生成slug
func generateSlug(title string) string {
    // 简化版：实际应该做更复杂的处理
    return fmt.Sprintf("%s-%d", title, time.Now().Unix())
}

func main() {
    // 使用示例
    article := &Article{
        Title:   "Go GORM Hooks",
        Content: "This is a comprehensive guide to GORM hooks.",
    }

    // db.Create(article) // 会触发BeforeCreate和AfterCreate
}
```

---

## 第三部分：sqlx深度实战

### 为什么选择sqlx？

```text
✅ 结构体映射 - 自动扫描到结构体
✅ 命名参数 - 更清晰的SQL
✅ 批量操作 - NamedExec批量插入
✅ 性能优越 - 接近原生database/sql
✅ 轻量级 - 只是database/sql的扩展
```

---

### 实战案例5：sqlx完整示例

```go
package main

import (
    "fmt"
    "log"
    "time"

    _ "github.com/go-sql-driver/mysql"
    "github.com/jmoiron/sqlx"
)

// User 用户模型
type User struct {
    ID        int64     `db:"id"`
    Username  string    `db:"username"`
    Email     string    `db:"email"`
    Age       int       `db:"age"`
    CreatedAt time.Time `db:"created_at"`
}

func main() {
    // 1. 连接数据库
    dsn := "user:password@tcp(127.0.0.1:3306)/testdb?parseTime=true"
    db, err := sqlx.Connect("mysql", dsn)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()

    // 2. 创建用户（单个）
    user := &User{
        Username: "david",
        Email:    "david@example.com",
        Age:      30,
    }

    result, err := db.NamedExec(`
        INSERT INTO users (username, email, age, created_at)
        VALUES (:username, :email, :age, NOW())
    `, user)

    if err != nil {
        log.Fatal(err)
    }

    id, _ := result.LastInsertId()
    user.ID = id
    fmt.Printf("User created: ID=%d\n", user.ID)

    // 3. 查询单个用户（Get）
    var fetchedUser User
    err = db.Get(&fetchedUser, "SELECT * FROM users WHERE id = ?", user.ID)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("User fetched: %+v\n", fetchedUser)

    // 4. 查询多个用户（Select）
    var users []User
    err = db.Select(&users, "SELECT * FROM users WHERE age > ?", 20)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Users found: %d\n", len(users))

    // 5. 命名查询
    query := `SELECT * FROM users WHERE username = :username AND age > :age`
    params := map[string]interface{}{
        "username": "david",
        "age":      25,
    }

    rows, err := db.NamedQuery(query, params)
    if err != nil {
        log.Fatal(err)
    }
    defer rows.Close()

    for rows.Next() {
        var u User
        if err := rows.StructScan(&u); err != nil {
            log.Fatal(err)
        }
        fmt.Printf("Named query result: %+v\n", u)
    }

    // 6. 批量插入
    users = []User{
        {Username: "user1", Email: "user1@example.com", Age: 20},
        {Username: "user2", Email: "user2@example.com", Age: 22},
        {Username: "user3", Email: "user3@example.com", Age: 24},
    }

    _, err = db.NamedExec(`
        INSERT INTO users (username, email, age, created_at)
        VALUES (:username, :email, :age, NOW())
    `, users)

    if err != nil {
        log.Fatal(err)
    }

    fmt.Println("Batch insert successful")

    // 7. 更新
    _, err = db.Exec("UPDATE users SET age = ? WHERE id = ?", 31, user.ID)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println("User updated")

    // 8. 删除
    _, err = db.Exec("DELETE FROM users WHERE id = ?", user.ID)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println("User deleted")
}
```

---

### 实战案例6：sqlx高级查询

```go
package main

import (
    "fmt"
    "log"

    "github.com/jmoiron/sqlx"
)

// UserStats 用户统计
type UserStats struct {
    AgeGroup string `db:"age_group"`
    Count    int    `db:"count"`
    AvgAge   float64 `db:"avg_age"`
}

// UserWithOrders 用户及订单统计
type UserWithOrders struct {
    UserID      int64   `db:"user_id"`
    Username    string  `db:"username"`
    OrderCount  int     `db:"order_count"`
    TotalAmount float64 `db:"total_amount"`
}

func AdvancedQueries(db *sqlx.DB) {
    // 1. 聚合查询
    var stats []UserStats
    query := `
        SELECT
            CASE
                WHEN age < 20 THEN 'Under 20'
                WHEN age BETWEEN 20 AND 30 THEN '20-30'
                ELSE 'Over 30'
            END as age_group,
            COUNT(*) as count,
            AVG(age) as avg_age
        FROM users
        GROUP BY age_group
        ORDER BY age_group
    `

    err := db.Select(&stats, query)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println("User statistics by age group:")
    for _, stat := range stats {
        fmt.Printf("  %s: %d users, avg age %.2f\n", stat.AgeGroup, stat.Count, stat.AvgAge)
    }

    // 2. JOIN查询
    var userOrders []UserWithOrders
    joinQuery := `
        SELECT
            u.id as user_id,
            u.username,
            COUNT(o.id) as order_count,
            COALESCE(SUM(o.amount), 0) as total_amount
        FROM users u
        LEFT JOIN orders o ON u.id = o.user_id
        GROUP BY u.id, u.username
        HAVING order_count > 0
        ORDER BY total_amount DESC
        LIMIT 10
    `

    err = db.Select(&userOrders, joinQuery)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println("\nTop 10 users by order amount:")
    for i, uo := range userOrders {
        fmt.Printf("  %d. %s: %d orders, $%.2f total\n",
            i+1, uo.Username, uo.OrderCount, uo.TotalAmount)
    }

    // 3. IN查询
    ids := []int64{1, 2, 3, 4, 5}
    query, args, err := sqlx.In("SELECT * FROM users WHERE id IN (?)", ids)
    if err != nil {
        log.Fatal(err)
    }

    query = db.Rebind(query) // 重新绑定占位符

    var users []User
    err = db.Select(&users, query, args...)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("\nUsers with IDs in %v: %d\n", ids, len(users))
}
```

---

## 第四部分：连接池与性能优化

### 连接池配置最佳实践

```go
package main

import (
    "database/sql"
    "time"
)

func ConfigureConnectionPool(db *sql.DB) {
    // 1. 最大打开连接数
    // 建议：CPU核心数 * 2 到 CPU核心数 * 4
    db.SetMaxOpenConns(25)

    // 2. 最大空闲连接数
    // 建议：等于MaxOpenConns，避免频繁创建/销毁连接
    db.SetMaxIdleConns(25)

    // 3. 连接最大生命周期
    // 建议：5-10分钟，防止长时间连接被数据库服务器关闭
    db.SetConnMaxLifetime(5 * time.Minute)

    // 4. 连接最大空闲时间（Go 1.15+）
    // 建议：1-2分钟，及时释放不用的连接
    db.SetConnMaxIdleTime(2 * time.Minute)
}

// ConnectionPoolStats 连接池统计
func ConnectionPoolStats(db *sql.DB) {
    stats := db.Stats()

    println("Connection Pool Statistics:")
    println("  MaxOpenConnections:", stats.MaxOpenConnections)
    println("  OpenConnections:", stats.OpenConnections)
    println("  InUse:", stats.InUse)
    println("  Idle:", stats.Idle)
    println("  WaitCount:", stats.WaitCount)
    println("  WaitDuration:", stats.WaitDuration)
    println("  MaxIdleClosed:", stats.MaxIdleClosed)
    println("  MaxLifetimeClosed:", stats.MaxLifetimeClosed)
}
```

---

### 实战案例7：性能对比测试

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
    "testing"
    "time"

    "github.com/jmoiron/sqlx"
    "gorm.io/gorm"
)

// BenchmarkInsert 插入性能对比
func BenchmarkInsert(b *testing.B) {
    // 准备数据库连接
    sqlDB, _ := sql.Open("mysql", dsn)
    sqlxDB, _ := sqlx.Connect("mysql", dsn)
    gormDB, _ := gorm.Open(mysql.Open(dsn), &gorm.Config{})

    b.Run("database/sql", func(b *testing.B) {
        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            sqlDB.Exec("INSERT INTO users (username, email) VALUES (?, ?)",
                fmt.Sprintf("user%d", i), fmt.Sprintf("user%d@example.com", i))
        }
    })

    b.Run("sqlx", func(b *testing.B) {
        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            sqlxDB.NamedExec("INSERT INTO users (username, email) VALUES (:username, :email)",
                map[string]interface{}{
                    "username": fmt.Sprintf("user%d", i),
                    "email":    fmt.Sprintf("user%d@example.com", i),
                })
        }
    })

    b.Run("GORM", func(b *testing.B) {
        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            gormDB.Create(&User{
                Username: fmt.Sprintf("user%d", i),
                Email:    fmt.Sprintf("user%d@example.com", i),
            })
        }
    })
}

// BenchmarkQuery 查询性能对比
func BenchmarkQuery(b *testing.B) {
    sqlDB, _ := sql.Open("mysql", dsn)
    sqlxDB, _ := sqlx.Connect("mysql", dsn)
    gormDB, _ := gorm.Open(mysql.Open(dsn), &gorm.Config{})

    b.Run("database/sql", func(b *testing.B) {
        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            rows, _ := sqlDB.Query("SELECT * FROM users LIMIT 100")
            for rows.Next() {
                var u User
                rows.Scan(&u.ID, &u.Username, &u.Email, &u.CreatedAt)
            }
            rows.Close()
        }
    })

    b.Run("sqlx", func(b *testing.B) {
        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            var users []User
            sqlxDB.Select(&users, "SELECT * FROM users LIMIT 100")
        }
    })

    b.Run("GORM", func(b *testing.B) {
        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            var users []User
            gormDB.Limit(100).Find(&users)
        }
    })
}

/*
性能对比结果（参考）：

插入性能：
database/sql:  10000 ns/op
sqlx:          12000 ns/op (+20%)
GORM:          25000 ns/op (+150%)

查询性能：
database/sql:  50000 ns/op
sqlx:          55000 ns/op (+10%)
GORM:          80000 ns/op (+60%)

结论：
- database/sql: 性能最优，但代码量大
- sqlx: 性能与便利性平衡
- GORM: 开发效率最高，性能损失可接受
*/
```

---

## 第五部分：事务处理深度实战

### 事务隔离级别

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 性能 |
|---------|------|-----------|------|------|
| **Read Uncommitted** | ✅ | ✅ | ✅ | 最高 |
| **Read Committed** | ❌ | ✅ | ✅ | 高 |
| **Repeatable Read** | ❌ | ❌ | ✅ | 中 |
| **Serializable** | ❌ | ❌ | ❌ | 最低 |

---

### 实战案例8：事务处理完整示例

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
    "log"
)

// TransferMoney 转账（事务示例）
func TransferMoney(db *sql.DB, fromUserID, toUserID int64, amount float64) error {
    // 1. 开启事务
    ctx := context.Background()
    tx, err := db.BeginTx(ctx, &sql.TxOptions{
        Isolation: sql.LevelReadCommitted, // 设置隔离级别
    })
    if err != nil {
        return err
    }

    // 2. 使用defer确保事务被处理
    defer func() {
        if p := recover(); p != nil {
            tx.Rollback()
            panic(p) // 重新抛出panic
        } else if err != nil {
            tx.Rollback()
        } else {
            err = tx.Commit()
        }
    }()

    // 3. 检查发送方余额
    var balance float64
    err = tx.QueryRowContext(ctx,
        "SELECT balance FROM accounts WHERE user_id = ? FOR UPDATE",
        fromUserID).Scan(&balance)
    if err != nil {
        return fmt.Errorf("failed to get sender balance: %w", err)
    }

    if balance < amount {
        return fmt.Errorf("insufficient balance: have %.2f, need %.2f", balance, amount)
    }

    // 4. 扣款
    _, err = tx.ExecContext(ctx,
        "UPDATE accounts SET balance = balance - ? WHERE user_id = ?",
        amount, fromUserID)
    if err != nil {
        return fmt.Errorf("failed to deduct from sender: %w", err)
    }

    // 5. 加款
    _, err = tx.ExecContext(ctx,
        "UPDATE accounts SET balance = balance + ? WHERE user_id = ?",
        amount, toUserID)
    if err != nil {
        return fmt.Errorf("failed to add to receiver: %w", err)
    }

    // 6. 记录交易
    _, err = tx.ExecContext(ctx,
        `INSERT INTO transactions (from_user_id, to_user_id, amount, created_at)
         VALUES (?, ?, ?, NOW())`,
        fromUserID, toUserID, amount)
    if err != nil {
        return fmt.Errorf("failed to record transaction: %w", err)
    }

    return nil
}

// GORM事务示例
func TransferMoneyGORM(db *gorm.DB, fromUserID, toUserID uint, amount float64) error {
    return db.Transaction(func(tx *gorm.DB) error {
        // 1. 检查发送方余额
        var fromAccount Account
        if err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).
            First(&fromAccount, fromUserID).Error; err != nil {
            return err
        }

        if fromAccount.Balance < amount {
            return fmt.Errorf("insufficient balance")
        }

        // 2. 扣款
        if err := tx.Model(&fromAccount).
            Update("balance", gorm.Expr("balance - ?", amount)).Error; err != nil {
            return err
        }

        // 3. 加款
        if err := tx.Model(&Account{}).
            Where("user_id = ?", toUserID).
            Update("balance", gorm.Expr("balance + ?", amount)).Error; err != nil {
            return err
        }

        // 4. 记录交易
        transaction := &Transaction{
            FromUserID: fromUserID,
            ToUserID:   toUserID,
            Amount:     amount,
        }

        return tx.Create(transaction).Error
    })
}

// sqlx事务示例
func TransferMoneySqlx(db *sqlx.DB, fromUserID, toUserID int64, amount float64) error {
    tx, err := db.Beginx()
    if err != nil {
        return err
    }

    defer func() {
        if p := recover(); p != nil {
            tx.Rollback()
            panic(p)
        } else if err != nil {
            tx.Rollback()
        } else {
            err = tx.Commit()
        }
    }()

    // 1. 检查余额
    var balance float64
    err = tx.Get(&balance,
        "SELECT balance FROM accounts WHERE user_id = ? FOR UPDATE",
        fromUserID)
    if err != nil {
        return err
    }

    if balance < amount {
        return fmt.Errorf("insufficient balance")
    }

    // 2. 扣款
    _, err = tx.Exec(
        "UPDATE accounts SET balance = balance - ? WHERE user_id = ?",
        amount, fromUserID)
    if err != nil {
        return err
    }

    // 3. 加款
    _, err = tx.Exec(
        "UPDATE accounts SET balance = balance + ? WHERE user_id = ?",
        amount, toUserID)
    if err != nil {
        return err
    }

    // 4. 记录交易
    _, err = tx.NamedExec(
        `INSERT INTO transactions (from_user_id, to_user_id, amount, created_at)
         VALUES (:from_user_id, :to_user_id, :amount, NOW())`,
        map[string]interface{}{
            "from_user_id": fromUserID,
            "to_user_id":   toUserID,
            "amount":       amount,
        })

    return err
}
```

---

## 第六部分：数据库迁移与版本管理

### 实战案例9：使用golang-migrate

```go
package main

import (
    "database/sql"
    "log"

    "github.com/golang-migrate/migrate/v4"
    "github.com/golang-migrate/migrate/v4/database/mysql"
    _ "github.com/golang-migrate/migrate/v4/source/file"
)

func RunMigrations(db *sql.DB) error {
    driver, err := mysql.WithInstance(db, &mysql.Config{})
    if err != nil {
        return err
    }

    m, err := migrate.NewWithDatabaseInstance(
        "file://migrations", // 迁移文件目录
        "mysql",
        driver,
    )
    if err != nil {
        return err
    }

    // 执行所有迁移
    if err := m.Up(); err != nil && err != migrate.ErrNoChange {
        return err
    }

    version, dirty, err := m.Version()
    if err != nil {
        return err
    }

    log.Printf("Migration completed: version=%d, dirty=%v", version, dirty)
    return nil
}

// 迁移文件示例
/*
// migrations/000001_create_users_table.up.sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_username (username),
    INDEX idx_email (email)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

// migrations/000001_create_users_table.down.sql
DROP TABLE IF EXISTS users;

// migrations/000002_create_orders_table.up.sql
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    amount DECIMAL(10, 2) NOT NULL,
    status VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_user_id (user_id),
    INDEX idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

// migrations/000002_create_orders_table.down.sql
DROP TABLE IF EXISTS orders;
*/
```

---

## 第七部分：查询优化与索引

### 索引类型与使用场景

| 索引类型 | 适用场景 | 示例 |
|---------|---------|------|
| **单列索引** | 单字段查询 | `CREATE INDEX idx_username ON users(username)` |
| **复合索引** | 多字段查询 | `CREATE INDEX idx_user_email ON users(username, email)` |
| **唯一索引** | 保证唯一性 | `CREATE UNIQUE INDEX idx_email ON users(email)` |
| **全文索引** | 文本搜索 | `CREATE FULLTEXT INDEX idx_content ON articles(content)` |

---

### 查询优化技巧

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
)

// BadQuery 糟糕的查询
func BadQuery(db *sql.DB) {
    // ❌ N+1问题
    rows, _ := db.Query("SELECT id FROM users")
    for rows.Next() {
        var id int
        rows.Scan(&id)

        // 每个用户都查一次订单（N+1问题）
        db.Query("SELECT * FROM orders WHERE user_id = ?", id)
    }

    // ❌ SELECT *
    db.Query("SELECT * FROM users") // 查询了不需要的字段

    // ❌ 没有使用LIMIT
    db.Query("SELECT * FROM users") // 可能返回百万条记录

    // ❌ OR条件无法使用索引
    db.Query("SELECT * FROM users WHERE username = ? OR email = ?", "alice", "alice@example.com")
}

// GoodQuery 优化后的查询
func GoodQuery(db *sql.DB) {
    // ✅ 使用JOIN避免N+1
    query := `
        SELECT u.*, o.*
        FROM users u
        LEFT JOIN orders o ON u.id = o.user_id
    `
    db.Query(query)

    // ✅ 只查询需要的字段
    db.Query("SELECT id, username, email FROM users")

    // ✅ 使用LIMIT和OFFSET分页
    db.Query("SELECT id, username FROM users LIMIT 10 OFFSET 0")

    // ✅ 使用IN代替OR（可以使用索引）
    db.Query("SELECT * FROM users WHERE id IN (?, ?)", 1, 2)

    // ✅ 使用EXISTS代替COUNT
    var exists bool
    db.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE username = ?)", "alice").Scan(&exists)

    // ✅ 批量插入
    stmt, _ := db.Prepare("INSERT INTO users (username, email) VALUES (?, ?)")
    for i := 0; i < 1000; i++ {
        stmt.Exec(fmt.Sprintf("user%d", i), fmt.Sprintf("user%d@example.com", i))
    }
}

// EXPLAIN分析查询
func ExplainQuery(db *sql.DB, query string) {
    rows, err := db.Query(fmt.Sprintf("EXPLAIN %s", query))
    if err != nil {
        log.Fatal(err)
    }
    defer rows.Close()

    // 打印EXPLAIN结果
    fmt.Println("Query Execution Plan:")
    for rows.Next() {
        // 扫描EXPLAIN结果
        // ...
    }
}
```

---

## 第八部分：完整实战项目

### 项目结构

```text
blog-api/
├── cmd/
│   └── server/
│       └── main.go
├── internal/
│   ├── models/
│   │   ├── user.go
│   │   ├── article.go
│   │   └── comment.go
│   ├── repository/
│   │   ├── user_repo.go
│   │   ├── article_repo.go
│   │   └── comment_repo.go
│   ├── service/
│   │   ├── user_service.go
│   │   └── article_service.go
│   └── handler/
│       ├── user_handler.go
│       └── article_handler.go
├── migrations/
│   ├── 000001_init.up.sql
│   └── 000001_init.down.sql
├── go.mod
└── go.sum
```

---

### 完整代码示例

#### models/user.go

```go
package models

import (
    "time"
    "gorm.io/gorm"
)

type User struct {
    ID        uint           `gorm:"primarykey" json:"id"`
    Username  string         `gorm:"uniqueIndex;size:50;not null" json:"username"`
    Email     string         `gorm:"uniqueIndex;size:100;not null" json:"email"`
    Password  string         `gorm:"size:255;not null" json:"-"`
    Avatar    string         `gorm:"size:255" json:"avatar"`
    Articles  []Article      `gorm:"foreignKey:AuthorID" json:"articles,omitempty"`
    Comments  []Comment      `gorm:"foreignKey:UserID" json:"comments,omitempty"`
    CreatedAt time.Time      `json:"created_at"`
    UpdatedAt time.Time      `json:"updated_at"`
    DeletedAt gorm.DeletedAt `gorm:"index" json:"-"`
}

type Article struct {
    ID        uint           `gorm:"primarykey" json:"id"`
    Title     string         `gorm:"size:200;not null" json:"title"`
    Content   string         `gorm:"type:text;not null" json:"content"`
    AuthorID  uint           `gorm:"not null;index" json:"author_id"`
    Author    *User          `gorm:"foreignKey:AuthorID" json:"author,omitempty"`
    Comments  []Comment      `gorm:"foreignKey:ArticleID" json:"comments,omitempty"`
    Tags      []Tag          `gorm:"many2many:article_tags;" json:"tags,omitempty"`
    Views     int            `gorm:"default:0" json:"views"`
    CreatedAt time.Time      `json:"created_at"`
    UpdatedAt time.Time      `json:"updated_at"`
    DeletedAt gorm.DeletedAt `gorm:"index" json:"-"`
}

type Comment struct {
    ID        uint           `gorm:"primarykey" json:"id"`
    Content   string         `gorm:"size:1000;not null" json:"content"`
    ArticleID uint           `gorm:"not null;index" json:"article_id"`
    UserID    uint           `gorm:"not null;index" json:"user_id"`
    User      *User          `gorm:"foreignKey:UserID" json:"user,omitempty"`
    CreatedAt time.Time      `json:"created_at"`
    UpdatedAt time.Time      `json:"updated_at"`
    DeletedAt gorm.DeletedAt `gorm:"index" json:"-"`
}

type Tag struct {
    ID   uint   `gorm:"primarykey" json:"id"`
    Name string `gorm:"uniqueIndex;size:50;not null" json:"name"`
}
```

#### repository/article_repo.go

```go
package repository

import (
    "context"
    "blog-api/internal/models"
    "gorm.io/gorm"
)

type ArticleRepository struct {
    db *gorm.DB
}

func NewArticleRepository(db *gorm.DB) *ArticleRepository {
    return &ArticleRepository{db: db}
}

// Create 创建文章
func (r *ArticleRepository) Create(ctx Context.Context, article *models.Article) error {
    return r.db.WithContext(ctx).Create(article).Error
}

// Get 获取文章（带作者和评论）
func (r *ArticleRepository) Get(ctx Context.Context, id uint) (*models.Article, error) {
    var article models.Article
    err := r.db.WithContext(ctx).
        Preload("Author").
        Preload("Comments.User").
        Preload("Tags").
        First(&article, id).Error

    if err != nil {
        return nil, err
    }

    return &article, nil
}

// List 列出文章（分页）
func (r *ArticleRepository) List(ctx Context.Context, page, pageSize int) ([]*models.Article, int64, error) {
    var articles []*models.Article
    var total int64

    // 计数
    if err := r.db.WithContext(ctx).Model(&models.Article{}).Count(&total).Error; err != nil {
        return nil, 0, err
    }

    // 查询
    offset := (page - 1) * pageSize
    err := r.db.WithContext(ctx).
        Preload("Author").
        Order("created_at DESC").
        Limit(pageSize).
        Offset(offset).
        Find(&articles).Error

    if err != nil {
        return nil, 0, err
    }

    return articles, total, nil
}

// Update 更新文章
func (r *ArticleRepository) Update(ctx Context.Context, article *models.Article) error {
    return r.db.WithContext(ctx).Save(article).Error
}

// Delete 删除文章
func (r *ArticleRepository) Delete(ctx Context.Context, id uint) error {
    return r.db.WithContext(ctx).Delete(&models.Article{}, id).Error
}

// IncrementViews 增加浏览量
func (r *ArticleRepository) IncrementViews(ctx Context.Context, id uint) error {
    return r.db.WithContext(ctx).
        Model(&models.Article{}).
        Where("id = ?", id).
        Update("views", gorm.Expr("views + ?", 1)).Error
}
```

#### service/article_service.go

```go
package service

import (
    "context"
    "blog-api/internal/models"
    "blog-api/internal/repository"
    "fmt"
)

type ArticleService struct {
    articleRepo *repository.ArticleRepository
    userRepo    *repository.UserRepository
}

func NewArticleService(articleRepo *repository.ArticleRepository, userRepo *repository.UserRepository) *ArticleService {
    return &ArticleService{
        articleRepo: articleRepo,
        userRepo:    userRepo,
    }
}

// CreateArticle 创建文章
func (s *ArticleService) CreateArticle(ctx Context.Context, authorID uint, title, content string, tagNames []string) (*models.Article, error) {
    // 验证作者
    _, err := s.userRepo.Get(ctx, authorID)
    if err != nil {
        return nil, fmt.Errorf("author not found: %w", err)
    }

    // 创建文章
    article := &models.Article{
        Title:    title,
        Content:  content,
        AuthorID: authorID,
    }

    // 处理标签
    for _, name := range tagNames {
        article.Tags = append(article.Tags, models.Tag{Name: name})
    }

    if err := s.articleRepo.Create(ctx, article); err != nil {
        return nil, err
    }

    return article, nil
}

// GetArticle 获取文章（增加浏览量）
func (s *ArticleService) GetArticle(ctx Context.Context, id uint) (*models.Article, error) {
    article, err := s.articleRepo.Get(ctx, id)
    if err != nil {
        return nil, err
    }

    // 异步增加浏览量
    go s.articleRepo.IncrementViews(context.Background(), id)

    return article, nil
}

// ListArticles 列出文章
func (s *ArticleService) ListArticles(ctx Context.Context, page, pageSize int) ([]*models.Article, int64, error) {
    return s.articleRepo.List(ctx, page, pageSize)
}
```

---

## 🎯 总结

### 数据库编程核心要点

1. **database/sql** - Go标准库，通用SQL接口
2. **GORM** - 功能完善的ORM，开发效率高
3. **sqlx** - 轻量级扩展，性能与便利性平衡
4. **连接池** - 合理配置，提升性能
5. **事务处理** - 保证数据一致性
6. **查询优化** - 索引、EXPLAIN、避免N+1
7. **迁移管理** - 版本控制，团队协作

### 技术选型建议

| 场景 | 推荐方案 | 理由 |
|------|---------|------|
| 高性能场景 | database/sql | 性能最优 |
| 快速开发 | GORM | 功能完善、开发效率高 |
| 平衡方案 | sqlx | 性能与便利性兼顾 |
| 复杂查询 | database/sql + sqlx | 灵活控制 |

### 最佳实践清单
