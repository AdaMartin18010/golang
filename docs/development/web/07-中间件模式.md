# ‰∏≠Èó¥‰ª∂Ê®°Âºè

**ÁâàÊú¨**: v1.0
**Êõ¥Êñ∞Êó•Êúü**: 2025-10-29
**ÈÄÇÁî®‰∫é**: Go 1.23+

---

## üìã ÁõÆÂΩï

- [üìö **ÁêÜËÆ∫ÂàÜÊûê**](#ÁêÜËÆ∫ÂàÜÊûê)
  - [**‰∏≠Èó¥‰ª∂ËÆæËÆ°ÂéüÁêÜ**](#‰∏≠Èó¥‰ª∂ËÆæËÆ°ÂéüÁêÜ)
  - [**ÈìæÂºèË∞ÉÁî®Ê®°Âûã**](#ÈìæÂºèË∞ÉÁî®Ê®°Âûã)
    - [**‰º™‰ª£Á†Å**](#‰º™‰ª£Á†Å)
  - [**GoÂÆûÁé∞ÊñπÂºè**](#goÂÆûÁé∞ÊñπÂºè)
- [üíª **‰ª£Á†ÅÁ§∫‰æã**](#‰ª£Á†ÅÁ§∫‰æã)
  - [**Ê†áÂáÜÂ∫ì‰∏≠Èó¥‰ª∂ÂÆûÁé∞**](#Ê†áÂáÜÂ∫ì‰∏≠Èó¥‰ª∂ÂÆûÁé∞)
  - [**Gin‰∏≠Èó¥‰ª∂Áî®Ê≥ï**](#gin‰∏≠Èó¥‰ª∂Áî®Ê≥ï)
  - [**Echo‰∏≠Èó¥‰ª∂Áî®Ê≥ï**](#echo‰∏≠Èó¥‰ª∂Áî®Ê≥ï)
  - [**Fiber‰∏≠Èó¥‰ª∂Áî®Ê≥ï**](#fiber‰∏≠Èó¥‰ª∂Áî®Ê≥ï)
- [üß™ **ÊµãËØï‰ª£Á†Å**](#ÊµãËØï‰ª£Á†Å)
- [üéØ **ÊúÄ‰Ω≥ÂÆûË∑µ**](#ÊúÄ‰Ω≥ÂÆûË∑µ)
- [üîç **Â∏∏ËßÅÈóÆÈ¢ò**](#Â∏∏ËßÅÈóÆÈ¢ò)
- [üìö **Êâ©Â±ïÈòÖËØª**](#Êâ©Â±ïÈòÖËØª)
- [üöÄ **ÂÆåÊï¥ÂÆûÊàòÁ§∫‰æãÔºöÁîü‰∫ßÁ∫ß‰∏≠Èó¥‰ª∂Èìæ**](#ÂÆåÊï¥ÂÆûÊàòÁ§∫‰æãÁîü‰∫ßÁ∫ß‰∏≠Èó¥‰ª∂Èìæ)
  - [Âú∫ÊôØÔºöÁîµÂïÜAPIÊúçÂä°](#Âú∫ÊôØÁîµÂïÜapiÊúçÂä°)
  - [‰ΩøÁî®Á§∫‰æã](#‰ΩøÁî®Á§∫‰æã)
  - [Á§∫‰æãÊó•ÂøóËæìÂá∫](#Á§∫‰æãÊó•ÂøóËæìÂá∫)
  - [‰∏≠Èó¥‰ª∂ÊâßË°åÈ°∫Â∫è](#‰∏≠Èó¥‰ª∂ÊâßË°åÈ°∫Â∫è)
  - [Áîü‰∫ßÁéØÂ¢É‰ºòÂåñÂª∫ËÆÆ](#Áîü‰∫ßÁéØÂ¢É‰ºòÂåñÂª∫ËÆÆ)

## üìö **ÁêÜËÆ∫ÂàÜÊûê**

### **‰∏≠Èó¥‰ª∂ËÆæËÆ°ÂéüÁêÜ**

- ‰∏≠Èó¥‰ª∂ÔºàMiddlewareÔºâÊòØWebÂºÄÂèë‰∏≠Áî®‰∫éÂ§ÑÁêÜËØ∑Ê±Ç/ÂìçÂ∫îÊµÅÁ®ãÁöÑÂèØÊèíÊãîÁªÑ‰ª∂„ÄÇ
- ÈááÁî®ÈìæÂºèË∞ÉÁî®ÔºàÊ¥ãËë±Ê®°ÂûãÔºâÔºåÊØè‰∏™‰∏≠Èó¥‰ª∂ÂèØÂú®ËØ∑Ê±ÇÂâçÂêéÊâßË°åÈÄªËæë„ÄÇ
- ÂÖ∏ÂûãÁî®ÈÄîÔºöÊó•Âøó„ÄÅËÆ§ËØÅ„ÄÅÈôêÊµÅ„ÄÅCORS„ÄÅÈîôËØØÊÅ¢Â§ç„ÄÅËØ∑Ê±Ç‰øÆÊîπÁ≠â„ÄÇ

### **ÈìæÂºèË∞ÉÁî®Ê®°Âûã**

- ÊØè‰∏™‰∏≠Èó¥‰ª∂Êé•Êî∂‰∏ã‰∏Ä‰∏™Â§ÑÁêÜÂô®‰Ωú‰∏∫ÂèÇÊï∞ÔºåÂÜ≥ÂÆöÊòØÂê¶ÁªßÁª≠‰º†ÈÄí
- Ê¥ãËë±Ê®°ÂûãÔºöÂ§ñÂ±Ç‰∏≠Èó¥‰ª∂ÂåÖË£πÂÜÖÂ±ÇÔºåÂÖàËøõÂêéÂá∫

#### **‰º™‰ª£Á†Å**

```text
func Middleware(next Handler) Handler {
    return func(w, r) {
        // ÂâçÁΩÆÈÄªËæë
        next(w, r)
        // ÂêéÁΩÆÈÄªËæë
    }
}
```

**‰∏≠Èó¥‰ª∂Ê¥ãËë±Ê®°ÂûãÂèØËßÜÂåñ**:

```mermaid
graph
    subgraph "ËØ∑Ê±ÇÊµÅ"
        Request[HTTP Request]
    end

    subgraph "‰∏≠Èó¥‰ª∂1: Logging"
        L1[‚Üí ËÆ∞ÂΩïËØ∑Ê±ÇÂºÄÂßã]
        L2[‚Üê ËÆ∞ÂΩïÂìçÂ∫îÊó∂Èó¥]
    end

    subgraph "‰∏≠Èó¥‰ª∂2: Recovery"
        R1[‚Üí defer recover]
        R2[‚Üê ÊçïËé∑panic]
    end

    subgraph "‰∏≠Èó¥‰ª∂3: Auth"
        A1[‚Üí È™åËØÅToken]
        A2[‚Üê Ê∏ÖÁêÜËµÑÊ∫ê]
    end

    subgraph "‰∏≠Èó¥‰ª∂4: RateLimit"
        RL1[‚Üí Ê£ÄÊü•ÈôêÊµÅ]
        RL2[‚Üê Êõ¥Êñ∞ËÆ°Êï∞]
    end

    subgraph "‰∏öÂä°Â§ÑÁêÜ"
        Handler[Handler ‰∏öÂä°ÈÄªËæë]
    end

    subgraph "ÂìçÂ∫îÊµÅ"
        Response[HTTP Response]
    end

    Request --> L1
    L1 --> R1
    R1 --> A1
    A1 --> RL1
    RL1 --> Handler
    Handler --> RL2
    RL2 --> A2
    A2 --> R2
    R2 --> L2
    L2 --> Response

    style Request fill:#e1f5ff
    style L1 fill:#fff4e1
    style R1 fill:#ffe1f5
    style A1 fill:#e1ffe1
    style RL1 fill:#f5e1ff
    style Handler fill:#ffe1e1
    style Response fill:#e1f5ff
```

**ÊâßË°åÊó∂Â∫èÂõæ**:

```mermaid
sequenceDiagram
    participant Client
    participant Logging
    participant Recovery
    participant Auth
    participant RateLimit
    participant Handler

    Client->>Logging: Request ‚ë†
    Note over Logging: ËÆ∞ÂΩïËØ∑Ê±ÇÂºÄÂßãÊó∂Èó¥

    Logging->>Recovery: next() ‚ë°
    Note over Recovery: ËÆæÁΩÆ defer recover()

    Recovery->>Auth: next() ‚ë¢
    Note over Auth: È™åËØÅ JWT Token

    Auth->>RateLimit: next() ‚ë£
    Note over RateLimit: Ê£ÄÊü•ÈôêÊµÅËßÑÂàô

    RateLimit->>Handler: next() ‚ë§
    Note over Handler: ÊâßË°å‰∏öÂä°ÈÄªËæë

    Handler-->>RateLimit: return ‚ë•
    Note over RateLimit: Êõ¥Êñ∞ËØ∑Ê±ÇËÆ°Êï∞

    RateLimit-->>Auth: return ‚ë¶
    Note over Auth: Ê∏ÖÁêÜËÆ§ËØÅËµÑÊ∫ê

    Auth-->>Recovery: return ‚ëß
    Note over Recovery: Ê£ÄÊü•panic

    Recovery-->>Logging: return ‚ë®
    Note over Logging: ËÆ°ÁÆóÂìçÂ∫îÊó∂Èó¥

    Logging-->>Client: Response ‚ë©
```

### **GoÂÆûÁé∞ÊñπÂºè**

- Ê†áÂáÜÂ∫ìÔºöÈÄöËøá`http.Handler`ÂåÖË£ÖÂÆûÁé∞
- Gin/Echo/FiberÁ≠âÊ°ÜÊû∂ÔºöÈÄöËøá`Use()`Ê≥®ÂÜåÈìæÂºè‰∏≠Èó¥‰ª∂

## üíª **‰ª£Á†ÅÁ§∫‰æã**

### **Ê†áÂáÜÂ∫ì‰∏≠Èó¥‰ª∂ÂÆûÁé∞**

```go
package main
import (
    "log"
    "net/http"
    "time"
)
func Logging(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        next.ServeHTTP(w, r)
        log.Printf("%s %s %v", r.Method, r.URL.Path, time.Since(start))
    })
}
func main() {
    mux := http.NewServeMux()
    mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("Hello"))
    })
    http.ListenAndServe(":8080", Logging(mux))
}
```

### **Gin‰∏≠Èó¥‰ª∂Áî®Ê≥ï**

```go
package main
import (
    "github.com/gin-gonic/gin"
    "log"
    "time"
)
func Logger() gin.HandlerFunc {
    return func(c *gin.Context) {
        t := time.Now()
        c.Next()
        log.Printf("%s %s %v", c.Request.Method, c.Request.URL.Path, time.Since(t))
    }
}
func main() {
    r := gin.New()
    r.Use(Logger())
    r.GET("/", func(c *gin.Context) {
        c.String(200, "Hello with middleware")
    })
    r.Run(":8080")
}
```

### **Echo‰∏≠Èó¥‰ª∂Áî®Ê≥ï**

```go
package main
import (
    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
)
func main() {
    e := echo.New()
    e.Use(middleware.Logger())
    e.Use(middleware.Recover())
    e.GET("/", func(c echo.Context) error {
        return c.String(200, "Hello with middleware")
    })
    e.Logger.Fatal(e.Start(":8080"))
}
```

### **Fiber‰∏≠Èó¥‰ª∂Áî®Ê≥ï**

```go
package main
import (
    "github.com/gofiber/fiber/v2"
    "github.com/gofiber/fiber/v2/middleware/logger"
)
func main() {
    app := fiber.New()
    app.Use(logger.New())
    app.Get("/", func(c *fiber.Ctx) error {
        return c.SendString("Hello with middleware")
    })
    app.Listen(":8080")
}
```

## üß™ **ÊµãËØï‰ª£Á†Å**

```go
package main
import (
    "net/http"
    "net/http/httptest"
    "testing"
)
func TestLoggingMiddleware(t *testing.T) {
    mux := http.NewServeMux()
    mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("OK"))
    })
    handler := Logging(mux)
    req := httptest.NewRequest("GET", "/", nil)
    w := httptest.NewRecorder()
    handler.ServeHTTP(w, req)
    if w.Body.String() != "OK" {
        t.Errorf("unexpected response: %s", w.Body.String())
    }
}
```

## üéØ **ÊúÄ‰Ω≥ÂÆûË∑µ**

- Êó•Âøó„ÄÅÊÅ¢Â§ç„ÄÅËÆ§ËØÅÁ≠âÈÄöÁî®ÂäüËÉΩÂª∫ËÆÆÁî®‰∏≠Èó¥‰ª∂ÂÆûÁé∞
- ‰∏≠Èó¥‰ª∂È°∫Â∫èÂΩ±ÂìçÊâßË°åÈÄªËæëÔºåÈúÄÂêàÁêÜÂÆâÊéí
- ÈîôËØØÂ§ÑÁêÜÂíåÂìçÂ∫îÂª∫ËÆÆÂú®‰∏≠Èó¥‰ª∂Áªü‰∏ÄÂ§ÑÁêÜ
- Áîü‰∫ßÁéØÂ¢ÉÂÖ≥Èó≠debug‰∏≠Èó¥‰ª∂ÔºåÂêàÁêÜÈÖçÁΩÆÊó•Âøó

## üîç **Â∏∏ËßÅÈóÆÈ¢ò**

- Q: ‰∏≠Èó¥‰ª∂ÂíåHandlerÊúâ‰ΩïÂå∫Âà´Ôºü
  A: ‰∏≠Èó¥‰ª∂ÂèØÂåÖË£πHandlerÔºåÂ§ÑÁêÜËØ∑Ê±ÇÂâçÂêéÈÄªËæë
- Q: Â¶Ç‰ΩïÂÆûÁé∞ÂÖ®Â±Ä‰∏éË∑ØÁî±Á∫ß‰∏≠Èó¥‰ª∂Ôºü
  A: ÂÖ®Â±ÄÁî®`Use()`Ê≥®ÂÜåÔºåË∑ØÁî±Á∫ßÁõ¥Êé•ÂåÖË£πHandler
- Q: ‰∏≠Èó¥‰ª∂Â¶Ç‰ΩïÁªàÊ≠¢ËØ∑Ê±ÇÈìæÔºü
  A: Gin/Echo/Fiber‰∏≠ÂèØÁõ¥Êé•ËøîÂõûÂìçÂ∫îÊàñË∞ÉÁî®`Abort()`

## üìö **Êâ©Â±ïÈòÖËØª**

- [GoÂÆòÊñπÊñáÊ°£-http.Handler](https://golang.org/pkg/net/http/#Handler)
- [Gin‰∏≠Èó¥‰ª∂ÊñáÊ°£](https://gin-gonic.com/docs/examples/middleware/)
- [Echo‰∏≠Èó¥‰ª∂ÊñáÊ°£](https://echo.labstack.com/middleware/)
- [Fiber‰∏≠Èó¥‰ª∂ÊñáÊ°£](https://docs.gofiber.io/api/middleware/)

---

## üöÄ **ÂÆåÊï¥ÂÆûÊàòÁ§∫‰æãÔºöÁîü‰∫ßÁ∫ß‰∏≠Èó¥‰ª∂Èìæ**

### Âú∫ÊôØÔºöÁîµÂïÜAPIÊúçÂä°

ËøôÊòØ‰∏Ä‰∏™ÂÆåÊï¥ÁöÑÁîü‰∫ßÁ∫ß‰∏≠Èó¥‰ª∂ÈìæÁ§∫‰æãÔºåÂ±ïÁ§∫Â§ö‰∏™‰∏≠Èó¥‰ª∂Â¶Ç‰ΩïÂçèÂêåÂ∑•‰Ωú„ÄÇ

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "runtime/debug"
    "strings"
    "sync"
    "time"

    "github.com/golang-jwt/jwt/v5"
    "golang.org/x/time/rate"
)

// ==================== ÂÖ®Â±ÄÈÖçÁΩÆ ====================

const (
    jwtSecret = "your-secret-key-change-in-production"
)

type contextKey string

const (
    requestIDKey contextKey = "requestID"
    userIDKey    contextKey = "userID"
    usernameKey  contextKey = "username"
)

// ==================== ‰∏≠Èó¥‰ª∂1: Êó•Âøó‰∏≠Èó¥‰ª∂ ====================

type responseWriter struct {
    http.ResponseWriter
    statusCode int
    size       int
}

func (rw *responseWriter) WriteHeader(statusCode int) {
    rw.statusCode = statusCode
    rw.ResponseWriter.WriteHeader(statusCode)
}

func (rw *responseWriter) Write(b []byte) (int, error) {
    size, err := rw.ResponseWriter.Write(b)
    rw.size += size
    return size, err
}

func LoggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()

        // ÁîüÊàêËØ∑Ê±ÇID
        requestID := fmt.Sprintf("req-%d", time.Now().UnixNano())
        ctx := context.WithValue(r.Context(), requestIDKey, requestID)

        // ÂåÖË£ÖResponseWriter‰ª•ÊçïËé∑Áä∂ÊÄÅÁ†Å
        rw := &responseWriter{
            ResponseWriter: w,
            statusCode:     http.StatusOK,
        }

        // Ê∑ªÂä†ËØ∑Ê±ÇIDÂà∞ÂìçÂ∫îÂ§¥
        rw.Header().Set("X-Request-ID", requestID)

        log.Printf("[%s] --> %s %s from %s", requestID, r.Method, r.URL.Path, r.RemoteAddr)

        next.ServeHTTP(rw, r.WithContext(ctx))

        duration := time.Since(start)
        log.Printf("[%s] <-- %d %s %s %v (%d bytes)",
            requestID, rw.statusCode, r.Method, r.URL.Path, duration, rw.size)
    })
}

// ==================== ‰∏≠Èó¥‰ª∂2: ÊÅ¢Â§ç‰∏≠Èó¥‰ª∂ ====================

func RecoveryMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                requestID, _ := r.Context().Value(requestIDKey).(string)

                log.Printf("[%s] PANIC: %v\n%s", requestID, err, debug.Stack())

                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusInternalServerError)
                json.NewEncoder(w).Encode(map[string]string{
                    "error":      "Internal server error",
                    "request_id": requestID,
                })
            }
        }()

        next.ServeHTTP(w, r)
    })
}

// ==================== ‰∏≠Èó¥‰ª∂3: CORS‰∏≠Èó¥‰ª∂ ====================

func CORSMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
        w.Header().Set("Access-Control-Max-Age", "3600")

        if r.Method == "OPTIONS" {
            w.WriteHeader(http.StatusNoContent)
            return
        }

        next.ServeHTTP(w, r)
    })
}

// ==================== ‰∏≠Èó¥‰ª∂4: ÈôêÊµÅ‰∏≠Èó¥‰ª∂ ====================

type RateLimiter struct {
    limiters map[string]*rate.Limiter
    mu       sync.RWMutex
    rate     rate.Limit
    burst    int
}

func NewRateLimiter(r rate.Limit, b int) *RateLimiter {
    return &RateLimiter{
        limiters: make(map[string]*rate.Limiter),
        rate:     r,
        burst:    b,
    }
}

func (rl *RateLimiter) getLimiter(key string) *rate.Limiter {
    rl.mu.RLock()
    limiter, exists := rl.limiters[key]
    rl.mu.RUnlock()

    if !exists {
        rl.mu.Lock()
        limiter = rate.NewLimiter(rl.rate, rl.burst)
        rl.limiters[key] = limiter
        rl.mu.Unlock()
    }

    return limiter
}

func (rl *RateLimiter) Middleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // ‰ΩøÁî®IP‰Ωú‰∏∫ÈôêÊµÅkey
        ip := r.RemoteAddr
        if idx := strings.LastIndex(ip, ":"); idx != -1 {
            ip = ip[:idx]
        }

        limiter := rl.getLimiter(ip)

        if !limiter.Allow() {
            requestID, _ := r.Context().Value(requestIDKey).(string)
            log.Printf("[%s] Rate limit exceeded for %s", requestID, ip)

            w.Header().Set("Content-Type", "application/json")
            w.WriteHeader(http.StatusTooManyRequests)
            json.NewEncoder(w).Encode(map[string]string{
                "error": "Rate limit exceeded. Please try again later.",
            })
            return
        }

        next.ServeHTTP(w, r)
    })
}

// ==================== ‰∏≠Èó¥‰ª∂5: JWTËÆ§ËØÅ‰∏≠Èó¥‰ª∂ ====================

type Claims struct {
    UserID   int64  `json:"user_id"`
    Username string `json:"username"`
    jwt.RegisteredClaims
}

func AuthMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        authHeader := r.Header.Get("Authorization")

        if authHeader == "" {
            http.Error(w, "Missing authorization header", http.StatusUnauthorized)
            return
        }

        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
        if tokenString == authHeader {
            http.Error(w, "Invalid authorization header format", http.StatusUnauthorized)
            return
        }

        token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
            if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
                return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
            }
            return []byte(jwtSecret), nil
        })

        if err != nil || !token.Valid {
            http.Error(w, "Invalid or expired token", http.StatusUnauthorized)
            return
        }

        claims, ok := token.Claims.(*Claims)
        if !ok {
            http.Error(w, "Invalid token claims", http.StatusUnauthorized)
            return
        }

        // Â∞ÜÁî®Êà∑‰ø°ÊÅØÊ∑ªÂä†Âà∞context
        ctx := r.Context()
        ctx = context.WithValue(ctx, userIDKey, claims.UserID)
        ctx = context.WithValue(ctx, usernameKey, claims.Username)

        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// ==================== ‰∏≠Èó¥‰ª∂6: Ë∂ÖÊó∂‰∏≠Èó¥‰ª∂ ====================

func TimeoutMiddleware(timeout time.Duration) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            ctx, cancel := context.WithTimeout(r.Context(), timeout)
            defer cancel()

            done := make(chan struct{})

            go func() {
                next.ServeHTTP(w, r.WithContext(ctx))
                close(done)
            }()

            select {
            case <-done:
                // ËØ∑Ê±ÇÂÆåÊàê
            case <-ctx.Done():
                requestID, _ := r.Context().Value(requestIDKey).(string)
                log.Printf("[%s] Request timeout", requestID)

                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusGatewayTimeout)
                json.NewEncoder(w).Encode(map[string]string{
                    "error":      "Request timeout",
                    "request_id": requestID,
                })
            }
        })
    }
}

// ==================== HTTPÂ§ÑÁêÜÂô® ====================

// ÁîüÊàêJWT Token
func LoginHandler(w http.ResponseWriter, r *http.Request) {
    var loginReq struct {
        Username string `json:"username"`
        Password string `json:"password"`
    }

    if err := json.NewDecoder(r.Body).Decode(&loginReq); err != nil {
        http.Error(w, "Invalid request body", http.StatusBadRequest)
        return
    }

    // ÁÆÄÂçïÈ™åËØÅÔºàÁîü‰∫ßÁéØÂ¢ÉÈúÄË¶ÅÊï∞ÊçÆÂ∫ìÈ™åËØÅÔºâ
    if loginReq.Username != "admin" || loginReq.Password != "password" {
        http.Error(w, "Invalid credentials", http.StatusUnauthorized)
        return
    }

    // ÁîüÊàêJWT
    claims := Claims{
        UserID:   1,
        Username: loginReq.Username,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    tokenString, err := token.SignedString([]byte(jwtSecret))
    if err != nil {
        http.Error(w, "Failed to generate token", http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]string{
        "token": tokenString,
        "type":  "Bearer",
    })
}

// ‰∫ßÂìÅÂàóË°®ÔºàÈúÄË¶ÅËÆ§ËØÅÔºâ
func ProductsHandler(w http.ResponseWriter, r *http.Request) {
    userID := r.Context().Value(userIDKey).(int64)
    username := r.Context().Value(usernameKey).(string)
    requestID, _ := r.Context().Value(requestIDKey).(string)

    // Ê®°Êãü‰∏öÂä°ÈÄªËæë
    time.Sleep(100 * time.Millisecond)

    products := []map[string]interface{}{
        {"id": 1, "name": "MacBook Pro", "price": 2999.99},
        {"id": 2, "name": "iPhone 15", "price": 999.99},
        {"id": 3, "name": "iPad Air", "price": 599.99},
    }

    response := map[string]interface{}{
        "products":   products,
        "user_id":    userID,
        "username":   username,
        "request_id": requestID,
        "timestamp":  time.Now().Unix(),
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}

// ÂÅ•Â∫∑Ê£ÄÊü•
func HealthHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]string{
        "status": "healthy",
        "time":   time.Now().Format(time.RFC3339),
    })
}

// ÊµãËØïPanicÊÅ¢Â§ç
func PanicHandler(w http.ResponseWriter, r *http.Request) {
    panic("intentional panic for testing recovery middleware")
}

// ==================== ‰∏ªÂáΩÊï∞ ====================

func main() {
    // ÂàõÂª∫ÈôêÊµÅÂô® (ÊØèÁßí10‰∏™ËØ∑Ê±ÇÔºåÁ™ÅÂèë20‰∏™)
    rateLimiter := NewRateLimiter(10, 20)

    // ÂàõÂª∫Ë∑ØÁî±
    mux := http.NewServeMux()

    // ÂÖ¨ÂºÄË∑ØÁî±
    mux.HandleFunc("/health", HealthHandler)
    mux.HandleFunc("/login", LoginHandler)
    mux.HandleFunc("/panic", PanicHandler) // ÊµãËØïpanicÊÅ¢Â§ç

    // Âèó‰øùÊä§Ë∑ØÁî±
    protectedMux := http.NewServeMux()
    protectedMux.HandleFunc("/api/products", ProductsHandler)

    // Â∫îÁî®ËÆ§ËØÅ‰∏≠Èó¥‰ª∂Âà∞Âèó‰øùÊä§Ë∑ØÁî±
    mux.Handle("/api/", AuthMiddleware(protectedMux))

    // ÊûÑÂª∫ÂÆåÊï¥ÁöÑ‰∏≠Èó¥‰ª∂Èìæ
    handler := RecoveryMiddleware(        // ÊúÄÂ§ñÂ±ÇÔºöÊçïËé∑panic
        LoggingMiddleware(                 // Êó•ÂøóËÆ∞ÂΩï
            CORSMiddleware(                // CORSÂ§ÑÁêÜ
                rateLimiter.Middleware(    // ÈôêÊµÅ
                    TimeoutMiddleware(5 * time.Second)(mux), // Ë∂ÖÊó∂ÊéßÂà∂
                ),
            ),
        ),
    )

    // ÂêØÂä®ÊúçÂä°Âô®
    server := &http.Server{
        Addr:         ":8080",
        Handler:      handler,
        ReadTimeout:  10 * time.Second,
        WriteTimeout: 10 * time.Second,
        IdleTimeout:  120 * time.Second,
    }

    log.Println("üöÄ Server starting on :8080")
    log.Println("üìù Middleware chain:")
    log.Println("   1. Recovery (PanicÊçïËé∑)")
    log.Println("   2. Logging (ËØ∑Ê±ÇÊó•Âøó)")
    log.Println("   3. CORS (Ë∑®Âüü)")
    log.Println("   4. RateLimit (ÈôêÊµÅ: 10 req/s)")
    log.Println("   5. Timeout (Ë∂ÖÊó∂: 5s)")
    log.Println("   6. Auth (JWTËÆ§ËØÅ, ‰ªÖ/api/*)")

    if err := server.ListenAndServe(); err != nil {
        log.Fatal(err)
    }
}
```

### ‰ΩøÁî®Á§∫‰æã

**1. ÂêØÂä®ÊúçÂä°Âô®**:

```bash
go mod init middleware-demo
go get github.com/golang-jwt/jwt/v5 golang.org/x/time/rate
go run main.go
```

**2. ÊµãËØïÁôªÂΩïËé∑ÂèñToken**:

```bash
curl -X POST http://localhost:8080/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"password"}'

# ÂìçÂ∫îÔºö
# {
#   "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
#   "type": "Bearer"
# }
```

**3. ‰ΩøÁî®TokenËÆøÈóÆÂèó‰øùÊä§API**:

```bash
TOKEN="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

curl http://localhost:8080/api/products \
  -H "Authorization: Bearer $TOKEN"

# ÂìçÂ∫îÔºö
# {
#   "products": [
#     {"id": 1, "name": "MacBook Pro", "price": 2999.99},
#     {"id": 2, "name": "iPhone 15", "price": 999.99},
#     {"id": 3, "name": "iPad Air", "price": 599.99}
#   ],
#   "user_id": 1,
#   "username": "admin",
#   "request_id": "req-1729584123456789",
#   "timestamp": 1729584123
# }
```

**4. ÊµãËØïÊú™ÊéàÊùÉËÆøÈóÆ**:

```bash
curl http://localhost:8080/api/products

# ÂìçÂ∫îÔºö
# Missing authorization header
```

**5. ÊµãËØïÈôêÊµÅ**:

```bash
# Âø´ÈÄüÂèëÈÄÅ20‰∏™ËØ∑Ê±Ç
for i in {1..20}; do
  curl -s -H "Authorization: Bearer $TOKEN" \
    http://localhost:8080/api/products > /dev/null &
done

# Á¨¨11‰∏™ËØ∑Ê±ÇÂêé‰ºöÊî∂Âà∞Ôºö
# {"error":"Rate limit exceeded. Please try again later."}
```

**6. ÊµãËØïPanicÊÅ¢Â§ç**:

```bash
curl http://localhost:8080/panic

# ÂìçÂ∫îÔºö
# {"error":"Internal server error","request_id":"req-..."}
# ÊúçÂä°Âô®‰∏ç‰ºöÂ¥©Ê∫ÉÔºåÊó•Âøó‰∏≠‰ºöËÆ∞ÂΩïpanic‰ø°ÊÅØÂíåÂ†ÜÊ†à
```

**7. ÊµãËØïÂÅ•Â∫∑Ê£ÄÊü•**:

```bash
curl http://localhost:8080/health

# ÂìçÂ∫îÔºö
# {"status":"healthy","time":"2025-10-22T10:30:45Z"}
```

### Á§∫‰æãÊó•ÂøóËæìÂá∫

```text
üöÄ Server starting on :8080
üìù Middleware chain:
   1. Recovery (PanicÊçïËé∑)
   2. Logging (ËØ∑Ê±ÇÊó•Âøó)
   3. CORS (Ë∑®Âüü)
   4. RateLimit (ÈôêÊµÅ: 10 req/s)
   5. Timeout (Ë∂ÖÊó∂: 5s)
   6. Auth (JWTËÆ§ËØÅ, ‰ªÖ/api/*)

[req-1729584650123456] --> POST /login from 127.0.0.1:54321
[req-1729584650123456] <-- 200 POST /login 2.5ms (125 bytes)

[req-1729584650234567] --> GET /api/products from 127.0.0.1:54322
[req-1729584650234567] <-- 200 GET /api/products 105ms (342 bytes)

[req-1729584650345678] --> GET /api/products from 127.0.0.1:54323
[req-1729584650345678] Rate limit exceeded for 127.0.0.1
[req-1729584650345678] <-- 429 GET /api/products 0.5ms (67 bytes)

[req-1729584650456789] --> GET /panic from 127.0.0.1:54324
[req-1729584650456789] PANIC: intentional panic for testing recovery middleware
goroutine 42 [running]:
runtime/debug.Stack()
        /usr/local/go/src/runtime/debug/stack.go:24 +0x65
... (Â†ÜÊ†à‰ø°ÊÅØ)
[req-1729584650456789] <-- 500 GET /panic 1.2ms (78 bytes)
```

### ‰∏≠Èó¥‰ª∂ÊâßË°åÈ°∫Â∫è

```text
ËØ∑Ê±ÇÊµÅÁ®ã (Ê¥ãËë±Ê®°Âûã):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. Recovery (ÊúÄÂ§ñÂ±Ç)                             ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ   ‚îÇ 2. Logging                                ‚îÇ ‚îÇ
‚îÇ   ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ 3. CORS                             ‚îÇ ‚îÇ ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ 4. RateLimit                  ‚îÇ ‚îÇ ‚îÇ ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ 5. Timeout              ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ 6. Auth (ÂèØÈÄâ)    ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   Handler   ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

ËØ∑Ê±Ç ‚îÄ‚îÄ> 1 ‚îÄ‚îÄ> 2 ‚îÄ‚îÄ> 3 ‚îÄ‚îÄ> 4 ‚îÄ‚îÄ> 5 ‚îÄ‚îÄ> 6 ‚îÄ‚îÄ> Handler
ÂìçÂ∫î <‚îÄ‚îÄ 1 <‚îÄ‚îÄ 2 <‚îÄ‚îÄ 3 <‚îÄ‚îÄ 4 <‚îÄ‚îÄ 5 <‚îÄ‚îÄ 6 <‚îÄ‚îÄ Handler
```

### Áîü‰∫ßÁéØÂ¢É‰ºòÂåñÂª∫ËÆÆ

1. **Êó•Âøó‰ºòÂåñ**Ôºö
   - ‰ΩøÁî®ÁªìÊûÑÂåñÊó•ÂøóÂ∫ì (zap, zerolog)
   - Êó•ÂøóÁ∫ßÂà´ÂèØÈÖçÁΩÆ
   - ÊïèÊÑü‰ø°ÊÅØËÑ±Êïè

2. **ÈôêÊµÅ‰ºòÂåñ**Ôºö
   - ‰ΩøÁî®RedisÂÆûÁé∞ÂàÜÂ∏ÉÂºèÈôêÊµÅ
   - ÊîØÊåÅ‰∏çÂêåAPIÁöÑ‰∏çÂêåÈÄüÁéá
   - Ê∑ªÂä†ÈôêÊµÅÊèêÁ§∫ÂìçÂ∫îÂ§¥

3. **ËÆ§ËØÅ‰ºòÂåñ**Ôºö
   - ‰ΩøÁî®RedisÁºìÂ≠òÂ∑≤È™åËØÅÁöÑtoken
   - ÂÆûÁé∞tokenÂà∑Êñ∞Êú∫Âà∂
   - ÊîØÊåÅÂ§öÁßçËÆ§ËØÅÊñπÂºè (OAuth, API Key)

4. **ÁõëÊéßÈõÜÊàê**Ôºö
   - Ê∑ªÂä†PrometheusÊåáÊ†á‰∏≠Èó¥‰ª∂
   - ËÆ∞ÂΩïËØ∑Ê±ÇËÄóÊó∂„ÄÅÁä∂ÊÄÅÁ†ÅÂàÜÂ∏É
   - ÈõÜÊàêÂàÜÂ∏ÉÂºèËøΩË∏™ (Jaeger, OpenTelemetry)

5. **ÊÄßËÉΩ‰ºòÂåñ**Ôºö
   - ResponseWriterÊ±†Âåñ
   - ÈÅøÂÖç‰∏≠Èó¥‰ª∂‰∏≠ÁöÑÈòªÂ°ûÊìç‰Ωú
   - ÂêàÁêÜËÆæÁΩÆË∂ÖÊó∂Êó∂Èó¥

---

**ÊñáÊ°£Áª¥Êä§ËÄÖ**: Go Documentation Team
**ÊúÄÂêéÊõ¥Êñ∞**: 2025-10-29
**ÊñáÊ°£Áä∂ÊÄÅ**: ÂÆåÊàê
**ÈÄÇÁî®ÁâàÊú¨**: Go 1.25.3+
