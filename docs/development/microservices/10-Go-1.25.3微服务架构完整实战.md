# Go 1.25.3 微服务架构完整实战

**版本**: v1.0
**更新日期**: 2025-10-29
**适用于**: Go 1.25.3

---
## 📋 目录

- [Go 1.25.3 微服务架构完整实战](#go-1253-微服务架构完整实战)
  - [📖 文档说明](#文档说明)
  - [2. 服务注册与发现](#2-服务注册与发现)
  - [3. 负载均衡](#3-负载均衡)
  - [4. 链路追踪](#4-链路追踪)
  - [5. 熔断降级](#5-熔断降级)
  - [6. API网关](#6-api网关)
  - [7. 配置中心](#7-配置中心)
  - [8. 完整示例](#8-完整示例)
  - [📚 最佳实践](#最佳实践)
  - [🎯 总结](#总结)

---

## 📖 文档说明

本文档展示如何使用Go 1.25.3构建**企业级微服务架构**，包含：

- ✅ gRPC服务通信
- ✅ 服务注册与发现
- ✅ 负载均衡
- ✅ 链路追踪
- ✅ 熔断降级
- ✅ API网关
- ✅ 配置中心
- ✅ 完整部署方案

---

### 1.1 定义Proto文件

```protobuf
// user.proto
syntax = "proto3";

package user;
option go_package = "github.com/yourproject/proto/user;user";

// 用户服务
service UserService {
  // 获取用户信息
  rpc GetUser(GetUserRequest) returns (GetUserResponse);

  // 创建用户
  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);

  // 用户列表（流式）
  rpc ListUsers(ListUsersRequest) returns (stream User);
}

// 获取用户请求
message GetUserRequest {
  int64 id = 1;
}

// 获取用户响应
message GetUserResponse {
  User user = 1;
}

// 创建用户请求
message CreateUserRequest {
  string name = 1;
  string email = 2;
}

// 创建用户响应
message CreateUserResponse {
  User user = 1;
}

// 用户列表请求
message ListUsersRequest {
  int32 page = 1;
  int32 page_size = 2;
}

// 用户模型
message User {
  int64 id = 1;
  string name = 2;
  string email = 3;
  int64 created_at = 4;
}
```

### 1.2 实现gRPC服务器

```go
package main

import (
 "Context"
 "fmt"
 "log"
 "net"
 "time"

 "google.golang.org/grpc"
 "google.golang.org/grpc/codes"
 "google.golang.org/grpc/status"

 pb "github.com/yourproject/proto/user"
)

// UserServer 用户服务实现
type UserServer struct {
 pb.UnimplementedUserServiceServer
 // 可以添加数据库连接等
}

// GetUser 获取用户
func (s *UserServer) GetUser(ctx Context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) {
 // 模拟从数据库查询
 if req.Id <= 0 {
  return nil, status.Error(codes.InvalidArgument, "invalid user id")
 }

 user := &pb.User{
  Id:        req.Id,
  Name:      "Test User",
  Email:     "test@example.com",
  CreatedAt: time.Now().Unix(),
 }

 return &pb.GetUserResponse{User: user}, nil
}

// CreateUser 创建用户
func (s *UserServer) CreateUser(ctx Context.Context, req *pb.CreateUserRequest) (*pb.CreateUserResponse, error) {
 // 验证
 if req.Name == "" || req.Email == "" {
  return nil, status.Error(codes.InvalidArgument, "name and email required")
 }

 // 创建用户
 user := &pb.User{
  Id:        1, // 实际应从数据库生成
  Name:      req.Name,
  Email:     req.Email,
  CreatedAt: time.Now().Unix(),
 }

 return &pb.CreateUserResponse{User: user}, nil
}

// ListUsers 用户列表（流式）
func (s *UserServer) ListUsers(req *pb.ListUsersRequest, stream pb.UserService_ListUsersServer) error {
 // 模拟分页查询
 for i := 0; i < 10; i++ {
  user := &pb.User{
   Id:        int64(i + 1),
   Name:      fmt.Sprintf("User%d", i+1),
   Email:     fmt.Sprintf("user%d@example.com", i+1),
   CreatedAt: time.Now().Unix(),
  }

  if err := stream.Send(user); err != nil {
   return err
  }

  time.Sleep(100 * time.Millisecond) // 模拟延迟
 }

 return nil
}

func main() {
 // 创建监听器
 lis, err := net.Listen("tcp", ":50051")
 if err != nil {
  log.Fatalf("failed to listen: %v", err)
 }

 // 创建gRPC服务器
 grpcServer := grpc.NewServer(
  // 添加拦截器
  grpc.UnaryInterceptor(unaryInterceptor),
  grpc.StreamInterceptor(streamInterceptor),
 )

 // 注册服务
 pb.RegisterUserServiceServer(grpcServer, &UserServer{})

 log.Println("gRPC server listening on :50051")

 // 启动服务
 if err := grpcServer.Serve(lis); err != nil {
  log.Fatalf("failed to serve: %v", err)
 }
}

// unaryInterceptor 一元拦截器（日志、认证等）
func unaryInterceptor(
 ctx Context.Context,
 req interface{},
 info *grpc.UnaryServerInfo,
 handler grpc.UnaryHandler,
) (interface{}, error) {
 start := time.Now()

 // 记录请求
 log.Printf("gRPC call: %s", info.FullMethod)

 // 执行处理器
 resp, err := handler(ctx, req)

 // 记录响应
 log.Printf("gRPC call: %s, duration: %v", info.FullMethod, time.Since(start))

 return resp, err
}

// streamInterceptor 流式拦截器
func streamInterceptor(
 srv interface{},
 ss grpc.ServerStream,
 info *grpc.StreamServerInfo,
 handler grpc.StreamHandler,
) error {
 start := time.Now()
 log.Printf("gRPC stream: %s", info.FullMethod)

 err := handler(srv, ss)

 log.Printf("gRPC stream: %s, duration: %v", info.FullMethod, time.Since(start))
 return err
}
```

### 1.3 实现gRPC客户端

```go
package main

import (
 "Context"
 "fmt"
 "io"
 "log"
 "time"

 "google.golang.org/grpc"
 "google.golang.org/grpc/credentials/insecure"

 pb "github.com/yourproject/proto/user"
)

func main() {
 // 建立连接
 conn, err := grpc.NewClient(
  "localhost:50051",
  grpc.WithTransportCredentials(insecure.NewCredentials()),
  // 添加拦截器
  grpc.WithUnaryInterceptor(clientUnaryInterceptor),
 )
 if err != nil {
  log.Fatalf("failed to connect: %v", err)
 }
 defer conn.Close()

 // 创建客户端
 client := pb.NewUserServiceClient(conn)

 // 调用GetUser
 ctx, cancel := Context.WithTimeout(Context.Background(), 5*time.Second)
 defer cancel()

 resp, err := client.GetUser(ctx, &pb.GetUserRequest{Id: 1})
 if err != nil {
  log.Fatalf("GetUser failed: %v", err)
 }
 fmt.Printf("User: %+v\n", resp.User)

 // 调用CreateUser
 createResp, err := client.CreateUser(ctx, &pb.CreateUserRequest{
  Name:  "New User",
  Email: "new@example.com",
 })
 if err != nil {
  log.Fatalf("CreateUser failed: %v", err)
 }
 fmt.Printf("Created: %+v\n", createResp.User)

 // 调用ListUsers（流式）
 stream, err := client.ListUsers(ctx, &pb.ListUsersRequest{
  Page:     1,
  PageSize: 10,
 })
 if err != nil {
  log.Fatalf("ListUsers failed: %v", err)
 }

 for {
  user, err := stream.Recv()
  if err == io.EOF {
   break
  }
  if err != nil {
   log.Fatalf("stream error: %v", err)
  }
  fmt.Printf("Stream user: %+v\n", user)
 }
}

// clientUnaryInterceptor 客户端拦截器
func clientUnaryInterceptor(
 ctx Context.Context,
 method string,
 req, reply interface{},
 cc *grpc.ClientConn,
 invoker grpc.UnaryInvoker,
 opts ...grpc.CallOption,
) error {
 start := time.Now()

 // 可以添加元数据
 // md := metadata.New(map[string]string{"token": "xxx"})
 // ctx = metadata.NewOutgoingContext(ctx, md)

 err := invoker(ctx, method, req, reply, cc, opts...)

 log.Printf("gRPC client call: %s, duration: %v", method, time.Since(start))
 return err
}
```

---

## 2. 服务注册与发现

### 2.1 使用Consul

```go
package registry

import (
 "fmt"
 "log"

 "github.com/hashicorp/consul/api"
)

// ConsulRegistry Consul注册中心
type ConsulRegistry struct {
 client *api.Client
}

// NewConsulRegistry 创建Consul注册中心
func NewConsulRegistry(addr string) (*ConsulRegistry, error) {
 config := api.DefaultConfig()
 config.Address = addr

 client, err := api.NewClient(config)
 if err != nil {
  return nil, err
 }

 return &ConsulRegistry{client: client}, nil
}

// Register 注册服务
func (r *ConsulRegistry) Register(serviceName, serviceID, addr string, port int) error {
 registration := &api.AgentServiceRegistration{
  ID:      serviceID,
  Name:    serviceName,
  Address: addr,
  Port:    port,
  Check: &api.AgentServiceCheck{
   HTTP:                           fmt.Sprintf("http://%s:%d/health", addr, port),
   Timeout:                        "3s",
   Interval:                       "10s",
   DeregisterCriticalServiceAfter: "30s",
  },
 }

 return r.client.Agent().ServiceRegister(registration)
}

// Deregister 注销服务
func (r *ConsulRegistry) Deregister(serviceID string) error {
 return r.client.Agent().ServiceDeregister(serviceID)
}

// Discover 发现服务
func (r *ConsulRegistry) Discover(serviceName string) ([]*api.ServiceEntry, error) {
 services, _, err := r.client.Health().Service(serviceName, "", true, nil)
 if err != nil {
  return nil, err
 }
 return services, nil
}

// Watch 监听服务变化
func (r *ConsulRegistry) Watch(serviceName string, callback func([]*api.ServiceEntry)) {
 var lastIndex uint64

 for {
  services, meta, err := r.client.Health().Service(
   serviceName,
   "",
   true,
   &api.QueryOptions{WaitIndex: lastIndex},
  )
  if err != nil {
   log.Printf("watch error: %v", err)
   continue
  }

  lastIndex = meta.LastIndex
  callback(services)
 }
}

// 使用示例
func ExampleConsul() {
 registry, err := NewConsulRegistry("localhost:8500")
 if err != nil {
  log.Fatal(err)
 }

 // 注册服务
 err = registry.Register("user-service", "user-1", "localhost", 50051)
 if err != nil {
  log.Fatal(err)
 }

 // 发现服务
 services, err := registry.Discover("user-service")
 if err != nil {
  log.Fatal(err)
 }

 for _, service := range services {
  fmt.Printf("Service: %s:%d\n", service.Service.Address, service.Service.Port)
 }

 // 监听服务变化
 go registry.Watch("user-service", func(services []*api.ServiceEntry) {
  log.Printf("Services updated: %d instances", len(services))
 })
}
```

---

## 3. 负载均衡

### 3.1 客户端负载均衡

```go
package loadbalance

import (
 "Context"
 "fmt"
 "sync"
 "sync/atomic"

 "google.golang.org/grpc"
 "google.golang.org/grpc/credentials/insecure"
)

// RoundRobinBalancer 轮询负载均衡器
type RoundRobinBalancer struct {
 conns   []*grpc.ClientConn
 current uint32
 mu      sync.RWMutex
}

// NewRoundRobinBalancer 创建轮询负载均衡器
func NewRoundRobinBalancer(addrs []string) (*RoundRobinBalancer, error) {
 balancer := &RoundRobinBalancer{
  conns: make([]*grpc.ClientConn, 0, len(addrs)),
 }

 for _, addr := range addrs {
  conn, err := grpc.NewClient(
   addr,
   grpc.WithTransportCredentials(insecure.NewCredentials()),
  )
  if err != nil {
   return nil, fmt.Errorf("failed to connect to %s: %w", addr, err)
  }
  balancer.conns = append(balancer.conns, conn)
 }

 return balancer, nil
}

// GetConnection 获取连接（轮询）
func (b *RoundRobinBalancer) GetConnection() *grpc.ClientConn {
 b.mu.RLock()
 defer b.mu.RUnlock()

 if len(b.conns) == 0 {
  return nil
 }

 // 原子递增计数器
 index := atomic.AddUint32(&b.current, 1)
 return b.conns[int(index)%len(b.conns)]
}

// UpdateConnections 更新连接列表
func (b *RoundRobinBalancer) UpdateConnections(addrs []string) error {
 b.mu.Lock()
 defer b.mu.Unlock()

 // 关闭旧连接
 for _, conn := range b.conns {
  conn.Close()
 }

 // 建立新连接
 newConns := make([]*grpc.ClientConn, 0, len(addrs))
 for _, addr := range addrs {
  conn, err := grpc.NewClient(
   addr,
   grpc.WithTransportCredentials(insecure.NewCredentials()),
  )
  if err != nil {
   return err
  }
  newConns = append(newConns, conn)
 }

 b.conns = newConns
 return nil
}

// Close 关闭所有连接
func (b *RoundRobinBalancer) Close() {
 b.mu.Lock()
 defer b.mu.Unlock()

 for _, conn := range b.conns {
  conn.Close()
 }
}

// 使用示例
func ExampleLoadBalancer() {
 addrs := []string{
  "localhost:50051",
  "localhost:50052",
  "localhost:50053",
 }

 balancer, err := NewRoundRobinBalancer(addrs)
 if err != nil {
  log.Fatal(err)
 }
 defer balancer.Close()

 // 使用负载均衡
 for i := 0; i < 10; i++ {
  conn := balancer.GetConnection()
  // 使用conn调用gRPC服务
  fmt.Printf("Request %d using connection: %v\n", i, conn.Target())
 }
}
```

---

## 4. 链路追踪

### 4.1 OpenTelemetry集成

```go
package tracing

import (
 "Context"
 "log"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/exporters/jaeger"
 "go.opentelemetry.io/otel/sdk/resource"
 sdktrace "go.opentelemetry.io/otel/sdk/trace"
 semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
 "go.opentelemetry.io/otel/trace"
)

// InitTracer 初始化追踪器
func InitTracer(serviceName, jaegerEndpoint string) func() {
 // 创建Jaeger导出器
 exporter, err := jaeger.New(
  jaeger.WithCollectorEndpoint(jaeger.WithEndpoint(jaegerEndpoint)),
 )
 if err != nil {
  log.Fatalf("failed to create jaeger exporter: %v", err)
 }

 // 创建追踪提供者
 tp := sdktrace.NewTracerProvider(
  sdktrace.WithBatcher(exporter),
  sdktrace.WithResource(resource.NewWithAttributes(
   semconv.SchemaURL,
   semconv.ServiceNameKey.String(serviceName),
  )),
 )

 // 设置全局追踪提供者
 otel.SetTracerProvider(tp)

 // 返回清理函数
 return func() {
  if err := tp.Shutdown(Context.Background()); err != nil {
   log.Printf("failed to shutdown tracer: %v", err)
  }
 }
}

// StartSpan 开始一个span
func StartSpan(ctx Context.Context, spanName string) (Context.Context, trace.Span) {
 tracer := otel.Tracer("microservice")
 return tracer.Start(ctx, spanName)
}

// 使用示例
func ExampleTracing() {
 // 初始化追踪器
 cleanup := InitTracer("user-service", "http://localhost:14268/api/traces")
 defer cleanup()

 ctx := Context.Background()

 // 创建span
 ctx, span := StartSpan(ctx, "process-user-request")
 defer span.End()

 // 添加事件
 span.AddEvent("processing user data")

 // 嵌套span
 ctx, childSpan := StartSpan(ctx, "database-query")
 // 执行数据库操作
 childSpan.End()

 // 添加属性
 span.SetAttributes(
  semconv.ServiceNameKey.String("user-service"),
 )
}
```

---

## 5. 熔断降级

### 5.1 使用gobreaker

```go
package circuitbreaker

import (
 "Context"
 "errors"
 "fmt"
 "time"

 "github.com/sony/gobreaker"
 "google.golang.org/grpc"
)

// CircuitBreaker 熔断器包装
type CircuitBreaker struct {
 cb *gobreaker.CircuitBreaker
}

// NewCircuitBreaker 创建熔断器
func NewCircuitBreaker(name string) *CircuitBreaker {
 settings := gobreaker.Settings{
  Name:        name,
  MaxRequests: 3,                   // 半开状态最大请求数
  Interval:    10 * time.Second,    // 统计周期
  Timeout:     60 * time.Second,    // 熔断超时
  ReadyToTrip: func(counts gobreaker.Counts) bool {
   // 失败率超过50%则熔断
   failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)
   return counts.Requests >= 3 && failureRatio >= 0.5
  },
  OnStateChange: func(name string, from, to gobreaker.State) {
   fmt.Printf("Circuit breaker '%s' state changed from %s to %s\n", name, from, to)
  },
 }

 return &CircuitBreaker{
  cb: gobreaker.NewCircuitBreaker(settings),
 }
}

// Execute 执行带熔断的操作
func (cb *CircuitBreaker) Execute(fn func() (interface{}, error)) (interface{}, error) {
 return cb.cb.Execute(fn)
}

// UnaryClientInterceptor 熔断拦截器
func (cb *CircuitBreaker) UnaryClientInterceptor() grpc.UnaryClientInterceptor {
 return func(
  ctx Context.Context,
  method string,
  req, reply interface{},
  cc *grpc.ClientConn,
  invoker grpc.UnaryInvoker,
  opts ...grpc.CallOption,
 ) error {
  _, err := cb.Execute(func() (interface{}, error) {
   return nil, invoker(ctx, method, req, reply, cc, opts...)
  })
  return err
 }
}

// 降级处理
func fallbackHandler(serviceName string) func() (interface{}, error) {
 return func() (interface{}, error) {
  // 返回降级响应
  return fmt.Sprintf("Service %s is unavailable, using fallback", serviceName), nil
 }
}

// 使用示例
func ExampleCircuitBreaker() {
 cb := NewCircuitBreaker("user-service")

 // 执行操作
 for i := 0; i < 10; i++ {
  result, err := cb.Execute(func() (interface{}, error) {
   // 模拟服务调用
   if i%2 == 0 {
    return "success", nil
   }
   return nil, errors.New("service error")
  })

  if err != nil {
   // 使用降级
   result, _ = fallbackHandler("user-service")()
  }

  fmt.Printf("Request %d: %v\n", i, result)
  time.Sleep(100 * time.Millisecond)
 }
}
```

---

## 6. API网关

### 6.1 HTTP到gRPC网关

```go
package gateway

import (
 "Context"
 "encoding/json"
 "log"
 "net/http"

 "google.golang.org/grpc"
 "google.golang.org/grpc/credentials/insecure"

 pb "github.com/yourproject/proto/user"
)

// Gateway API网关
type Gateway struct {
 userClient pb.UserServiceClient
}

// NewGateway 创建网关
func NewGateway(userServiceAddr string) (*Gateway, error) {
 conn, err := grpc.NewClient(
  userServiceAddr,
  grpc.WithTransportCredentials(insecure.NewCredentials()),
 )
 if err != nil {
  return nil, err
 }

 return &Gateway{
  userClient: pb.NewUserServiceClient(conn),
 }, nil
}

// HandleGetUser 处理获取用户请求
func (g *Gateway) HandleGetUser(w http.ResponseWriter, r *http.Request) {
 // 解析参数
 id := r.URL.Query().Get("id")
 if id == "" {
  http.Error(w, "id required", http.StatusBadRequest)
  return
 }

 // 调用gRPC服务
 resp, err := g.userClient.GetUser(r.Context(), &pb.GetUserRequest{
  Id: 1, // 实际应解析id
 })
 if err != nil {
  http.Error(w, err.Error(), http.StatusInternalServerError)
  return
 }

 // 返回JSON响应
 w.Header().Set("Content-Type", "application/json")
 json.NewEncoder(w).Encode(resp.User)
}

// HandleCreateUser 处理创建用户请求
func (g *Gateway) HandleCreateUser(w http.ResponseWriter, r *http.Request) {
 var req struct {
  Name  string `json:"name"`
  Email string `json:"email"`
 }

 if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
  http.Error(w, err.Error(), http.StatusBadRequest)
  return
 }

 // 调用gRPC服务
 resp, err := g.userClient.CreateUser(r.Context(), &pb.CreateUserRequest{
  Name:  req.Name,
  Email: req.Email,
 })
 if err != nil {
  http.Error(w, err.Error(), http.StatusInternalServerError)
  return
 }

 // 返回JSON响应
 w.Header().Set("Content-Type", "application/json")
 w.WriteHeader(http.StatusCreated)
 json.NewEncoder(w).Encode(resp.User)
}

// Start 启动网关
func (g *Gateway) Start(addr string) error {
 mux := http.NewServeMux()

 // 注册路由
 mux.HandleFunc("/api/users", func(w http.ResponseWriter, r *http.Request) {
  switch r.Method {
  case http.MethodGet:
   g.HandleGetUser(w, r)
  case http.MethodPost:
   g.HandleCreateUser(w, r)
  default:
   http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
  }
 })

 log.Printf("API Gateway listening on %s", addr)
 return http.ListenAndServe(addr, mux)
}

func main() {
 gateway, err := NewGateway("localhost:50051")
 if err != nil {
  log.Fatal(err)
 }

 if err := gateway.Start(":8080"); err != nil {
  log.Fatal(err)
 }
}
```

---

## 7. 配置中心

### 7.1 Viper配置管理

```go
package config

import (
 "fmt"
 "log"

 "github.com/spf13/viper"
)

// Config 配置结构
type Config struct {
 Server   ServerConfig
 Database DatabaseConfig
 Redis    RedisConfig
 Services ServicesConfig
}

type ServerConfig struct {
 Port int
 Mode string
}

type DatabaseConfig struct {
 Host     string
 Port     int
 User     string
 Password string
 DBName   string
}

type RedisConfig struct {
 Host     string
 Port     int
 Password string
}

type ServicesConfig struct {
 UserService   string
 OrderService  string
 PaymentService string
}

// LoadConfig 加载配置
func LoadConfig(configPath string) (*Config, error) {
 viper.SetConfigFile(configPath)
 viper.SetConfigType("yaml")

 // 设置环境变量前缀
 viper.SetEnvPrefix("APP")
 viper.AutomaticEnv()

 // 读取配置文件
 if err := viper.ReadInConfig(); err != nil {
  return nil, fmt.Errorf("failed to read config: %w", err)
 }

 // 解析配置
 var config Config
 if err := viper.Unmarshal(&config); err != nil {
  return nil, fmt.Errorf("failed to unmarshal config: %w", err)
 }

 return &config, nil
}

// WatchConfig 监听配置变化
func WatchConfig(callback func(*Config)) {
 viper.WatchConfig()
 viper.OnConfigChange(func(e fsnotify.Event) {
  log.Printf("Config file changed: %s", e.Name)

  var config Config
  if err := viper.Unmarshal(&config); err != nil {
   log.Printf("failed to unmarshal config: %v", err)
   return
  }

  callback(&config)
 })
}
```

**config.yaml示例**:

```yaml
server:
  port: 8080
  mode: production

database:
  host: localhost
  port: 5432
  user: postgres
  password: password
  dbname: myapp

redis:
  host: localhost
  port: 6379
  password: ""

services:
  user_service: "localhost:50051"
  order_service: "localhost:50052"
  payment_service: "localhost:50053"
```

---

## 8. 完整示例

### 8.1 用户微服务

```go
package main

import (
 "Context"
 "fmt"
 "log"
 "net"
 "os"
 "os/signal"
 "syscall"

 "google.golang.org/grpc"
 "google.golang.org/grpc/health"
 healthpb "google.golang.org/grpc/health/grpc_health_v1"

 pb "github.com/yourproject/proto/user"
)

type UserMicroservice struct {
 server   *grpc.Server
 registry *ConsulRegistry
 config   *Config
}

func NewUserMicroservice(configPath string) (*UserMicroservice, error) {
 // 加载配置
 config, err := LoadConfig(configPath)
 if err != nil {
  return nil, err
 }

 // 初始化追踪
 cleanup := InitTracer("user-service", "http://localhost:14268/api/traces")
 defer cleanup()

 // 创建注册中心客户端
 registry, err := NewConsulRegistry("localhost:8500")
 if err != nil {
  return nil, err
 }

 // 创建gRPC服务器
 server := grpc.NewServer(
  grpc.UnaryInterceptor(unaryInterceptor),
 )

 // 注册服务
 pb.RegisterUserServiceServer(server, &UserServer{})

 // 注册健康检查
 healthServer := health.NewServer()
 healthpb.RegisterHealthServer(server, healthServer)
 healthServer.SetServingStatus("user-service", healthpb.HealthCheckResponse_SERVING)

 return &UserMicroservice{
  server:   server,
  registry: registry,
  config:   config,
 }, nil
}

func (m *UserMicroservice) Start() error {
 // 监听端口
 lis, err := net.Listen("tcp", fmt.Sprintf(":%d", m.config.Server.Port))
 if err != nil {
  return err
 }

 // 注册到Consul
 serviceID := fmt.Sprintf("user-service-%s", getHostname())
 err = m.registry.Register(
  "user-service",
  serviceID,
  getLocalIP(),
  m.config.Server.Port,
 )
 if err != nil {
  return err
 }

 // 优雅关闭
 go m.gracefulShutdown(serviceID)

 log.Printf("User microservice listening on :%d", m.config.Server.Port)
 return m.server.Serve(lis)
}

func (m *UserMicroservice) gracefulShutdown(serviceID string) {
 quit := make(Channel os.Signal, 1)
 signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

 <-quit
 log.Println("Shutting down server...")

 // 注销服务
 m.registry.Deregister(serviceID)

 // 优雅停止
 m.server.GracefulStop()

 log.Println("Server stopped")
}

func main() {
 ms, err := NewUserMicroservice("config.yaml")
 if err != nil {
  log.Fatal(err)
 }

 if err := ms.Start(); err != nil {
  log.Fatal(err)
 }
}

func getHostname() string {
 hostname, _ := os.Hostname()
 return hostname
}

func getLocalIP() string {
 // 实现获取本地IP
 return "localhost"
}
```

---

## 📚 最佳实践

1. ✅ **服务拆分**: 按业务领域划分服务
2. ✅ **异步通信**: 使用消息队列解耦服务
3. ✅ **熔断降级**: 防止雪崩效应
4. ✅ **链路追踪**: 快速定位问题
5. ✅ **配置中心**: 统一配置管理
6. ✅ **服务网格**: 使用Istio等服务网格
7. ✅ **容器化**: Docker + Kubernetes部署

---

## 🎯 总结
