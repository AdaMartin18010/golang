# Go 1.25.3 å¾®æœåŠ¡æ¶æ„å®Œæ•´å®æˆ˜

**é¡¹ç›®ç±»å‹**: ä¼ä¸šçº§å¾®æœåŠ¡æ¶æ„  
**Goç‰ˆæœ¬**: Go 1.25.3  
**éš¾åº¦ç­‰çº§**: â­â­â­â­â­ (ä¸“å®¶çº§)  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ22æ—¥

---

## ğŸ“– æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£å±•ç¤ºå¦‚ä½•ä½¿ç”¨Go 1.25.3æ„å»º**ä¼ä¸šçº§å¾®æœåŠ¡æ¶æ„**ï¼ŒåŒ…å«ï¼š

- âœ… gRPCæœåŠ¡é€šä¿¡
- âœ… æœåŠ¡æ³¨å†Œä¸å‘ç°
- âœ… è´Ÿè½½å‡è¡¡
- âœ… é“¾è·¯è¿½è¸ª
- âœ… ç†”æ–­é™çº§
- âœ… APIç½‘å…³
- âœ… é…ç½®ä¸­å¿ƒ
- âœ… å®Œæ•´éƒ¨ç½²æ–¹æ¡ˆ

---

## ç›®å½•

1. [gRPCæœåŠ¡](#1-grpcæœåŠ¡)
2. [æœåŠ¡æ³¨å†Œä¸å‘ç°](#2-æœåŠ¡æ³¨å†Œä¸å‘ç°)
3. [è´Ÿè½½å‡è¡¡](#3-è´Ÿè½½å‡è¡¡)
4. [é“¾è·¯è¿½è¸ª](#4-é“¾è·¯è¿½è¸ª)
5. [ç†”æ–­é™çº§](#5-ç†”æ–­é™çº§)
6. [APIç½‘å…³](#6-apiç½‘å…³)
7. [é…ç½®ä¸­å¿ƒ](#7-é…ç½®ä¸­å¿ƒ)
8. [å®Œæ•´ç¤ºä¾‹](#8-å®Œæ•´ç¤ºä¾‹)

---

## 1. gRPCæœåŠ¡

### 1.1 å®šä¹‰Protoæ–‡ä»¶

```protobuf
// user.proto
syntax = "proto3";

package user;
option go_package = "github.com/yourproject/proto/user;user";

// ç”¨æˆ·æœåŠ¡
service UserService {
  // è·å–ç”¨æˆ·ä¿¡æ¯
  rpc GetUser(GetUserRequest) returns (GetUserResponse);
  
  // åˆ›å»ºç”¨æˆ·
  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);
  
  // ç”¨æˆ·åˆ—è¡¨ï¼ˆæµå¼ï¼‰
  rpc ListUsers(ListUsersRequest) returns (stream User);
}

// è·å–ç”¨æˆ·è¯·æ±‚
message GetUserRequest {
  int64 id = 1;
}

// è·å–ç”¨æˆ·å“åº”
message GetUserResponse {
  User user = 1;
}

// åˆ›å»ºç”¨æˆ·è¯·æ±‚
message CreateUserRequest {
  string name = 1;
  string email = 2;
}

// åˆ›å»ºç”¨æˆ·å“åº”
message CreateUserResponse {
  User user = 1;
}

// ç”¨æˆ·åˆ—è¡¨è¯·æ±‚
message ListUsersRequest {
  int32 page = 1;
  int32 page_size = 2;
}

// ç”¨æˆ·æ¨¡å‹
message User {
  int64 id = 1;
  string name = 2;
  string email = 3;
  int64 created_at = 4;
}
```

### 1.2 å®ç°gRPCæœåŠ¡å™¨

```go
package main

import (
 "context"
 "fmt"
 "log"
 "net"
 "time"

 "google.golang.org/grpc"
 "google.golang.org/grpc/codes"
 "google.golang.org/grpc/status"
 
 pb "github.com/yourproject/proto/user"
)

// UserServer ç”¨æˆ·æœåŠ¡å®ç°
type UserServer struct {
 pb.UnimplementedUserServiceServer
 // å¯ä»¥æ·»åŠ æ•°æ®åº“è¿æ¥ç­‰
}

// GetUser è·å–ç”¨æˆ·
func (s *UserServer) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) {
 // æ¨¡æ‹Ÿä»æ•°æ®åº“æŸ¥è¯¢
 if req.Id <= 0 {
  return nil, status.Error(codes.InvalidArgument, "invalid user id")
 }
 
 user := &pb.User{
  Id:        req.Id,
  Name:      "Test User",
  Email:     "test@example.com",
  CreatedAt: time.Now().Unix(),
 }
 
 return &pb.GetUserResponse{User: user}, nil
}

// CreateUser åˆ›å»ºç”¨æˆ·
func (s *UserServer) CreateUser(ctx context.Context, req *pb.CreateUserRequest) (*pb.CreateUserResponse, error) {
 // éªŒè¯
 if req.Name == "" || req.Email == "" {
  return nil, status.Error(codes.InvalidArgument, "name and email required")
 }
 
 // åˆ›å»ºç”¨æˆ·
 user := &pb.User{
  Id:        1, // å®é™…åº”ä»æ•°æ®åº“ç”Ÿæˆ
  Name:      req.Name,
  Email:     req.Email,
  CreatedAt: time.Now().Unix(),
 }
 
 return &pb.CreateUserResponse{User: user}, nil
}

// ListUsers ç”¨æˆ·åˆ—è¡¨ï¼ˆæµå¼ï¼‰
func (s *UserServer) ListUsers(req *pb.ListUsersRequest, stream pb.UserService_ListUsersServer) error {
 // æ¨¡æ‹Ÿåˆ†é¡µæŸ¥è¯¢
 for i := 0; i < 10; i++ {
  user := &pb.User{
   Id:        int64(i + 1),
   Name:      fmt.Sprintf("User%d", i+1),
   Email:     fmt.Sprintf("user%d@example.com", i+1),
   CreatedAt: time.Now().Unix(),
  }
  
  if err := stream.Send(user); err != nil {
   return err
  }
  
  time.Sleep(100 * time.Millisecond) // æ¨¡æ‹Ÿå»¶è¿Ÿ
 }
 
 return nil
}

func main() {
 // åˆ›å»ºç›‘å¬å™¨
 lis, err := net.Listen("tcp", ":50051")
 if err != nil {
  log.Fatalf("failed to listen: %v", err)
 }
 
 // åˆ›å»ºgRPCæœåŠ¡å™¨
 grpcServer := grpc.NewServer(
  // æ·»åŠ æ‹¦æˆªå™¨
  grpc.UnaryInterceptor(unaryInterceptor),
  grpc.StreamInterceptor(streamInterceptor),
 )
 
 // æ³¨å†ŒæœåŠ¡
 pb.RegisterUserServiceServer(grpcServer, &UserServer{})
 
 log.Println("gRPC server listening on :50051")
 
 // å¯åŠ¨æœåŠ¡
 if err := grpcServer.Serve(lis); err != nil {
  log.Fatalf("failed to serve: %v", err)
 }
}

// unaryInterceptor ä¸€å…ƒæ‹¦æˆªå™¨ï¼ˆæ—¥å¿—ã€è®¤è¯ç­‰ï¼‰
func unaryInterceptor(
 ctx context.Context,
 req interface{},
 info *grpc.UnaryServerInfo,
 handler grpc.UnaryHandler,
) (interface{}, error) {
 start := time.Now()
 
 // è®°å½•è¯·æ±‚
 log.Printf("gRPC call: %s", info.FullMethod)
 
 // æ‰§è¡Œå¤„ç†å™¨
 resp, err := handler(ctx, req)
 
 // è®°å½•å“åº”
 log.Printf("gRPC call: %s, duration: %v", info.FullMethod, time.Since(start))
 
 return resp, err
}

// streamInterceptor æµå¼æ‹¦æˆªå™¨
func streamInterceptor(
 srv interface{},
 ss grpc.ServerStream,
 info *grpc.StreamServerInfo,
 handler grpc.StreamHandler,
) error {
 start := time.Now()
 log.Printf("gRPC stream: %s", info.FullMethod)
 
 err := handler(srv, ss)
 
 log.Printf("gRPC stream: %s, duration: %v", info.FullMethod, time.Since(start))
 return err
}
```

### 1.3 å®ç°gRPCå®¢æˆ·ç«¯

```go
package main

import (
 "context"
 "fmt"
 "io"
 "log"
 "time"

 "google.golang.org/grpc"
 "google.golang.org/grpc/credentials/insecure"
 
 pb "github.com/yourproject/proto/user"
)

func main() {
 // å»ºç«‹è¿æ¥
 conn, err := grpc.NewClient(
  "localhost:50051",
  grpc.WithTransportCredentials(insecure.NewCredentials()),
  // æ·»åŠ æ‹¦æˆªå™¨
  grpc.WithUnaryInterceptor(clientUnaryInterceptor),
 )
 if err != nil {
  log.Fatalf("failed to connect: %v", err)
 }
 defer conn.Close()
 
 // åˆ›å»ºå®¢æˆ·ç«¯
 client := pb.NewUserServiceClient(conn)
 
 // è°ƒç”¨GetUser
 ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
 defer cancel()
 
 resp, err := client.GetUser(ctx, &pb.GetUserRequest{Id: 1})
 if err != nil {
  log.Fatalf("GetUser failed: %v", err)
 }
 fmt.Printf("User: %+v\n", resp.User)
 
 // è°ƒç”¨CreateUser
 createResp, err := client.CreateUser(ctx, &pb.CreateUserRequest{
  Name:  "New User",
  Email: "new@example.com",
 })
 if err != nil {
  log.Fatalf("CreateUser failed: %v", err)
 }
 fmt.Printf("Created: %+v\n", createResp.User)
 
 // è°ƒç”¨ListUsersï¼ˆæµå¼ï¼‰
 stream, err := client.ListUsers(ctx, &pb.ListUsersRequest{
  Page:     1,
  PageSize: 10,
 })
 if err != nil {
  log.Fatalf("ListUsers failed: %v", err)
 }
 
 for {
  user, err := stream.Recv()
  if err == io.EOF {
   break
  }
  if err != nil {
   log.Fatalf("stream error: %v", err)
  }
  fmt.Printf("Stream user: %+v\n", user)
 }
}

// clientUnaryInterceptor å®¢æˆ·ç«¯æ‹¦æˆªå™¨
func clientUnaryInterceptor(
 ctx context.Context,
 method string,
 req, reply interface{},
 cc *grpc.ClientConn,
 invoker grpc.UnaryInvoker,
 opts ...grpc.CallOption,
) error {
 start := time.Now()
 
 // å¯ä»¥æ·»åŠ å…ƒæ•°æ®
 // md := metadata.New(map[string]string{"token": "xxx"})
 // ctx = metadata.NewOutgoingContext(ctx, md)
 
 err := invoker(ctx, method, req, reply, cc, opts...)
 
 log.Printf("gRPC client call: %s, duration: %v", method, time.Since(start))
 return err
}
```

---

## 2. æœåŠ¡æ³¨å†Œä¸å‘ç°

### 2.1 ä½¿ç”¨Consul

```go
package registry

import (
 "fmt"
 "log"

 "github.com/hashicorp/consul/api"
)

// ConsulRegistry Consulæ³¨å†Œä¸­å¿ƒ
type ConsulRegistry struct {
 client *api.Client
}

// NewConsulRegistry åˆ›å»ºConsulæ³¨å†Œä¸­å¿ƒ
func NewConsulRegistry(addr string) (*ConsulRegistry, error) {
 config := api.DefaultConfig()
 config.Address = addr
 
 client, err := api.NewClient(config)
 if err != nil {
  return nil, err
 }
 
 return &ConsulRegistry{client: client}, nil
}

// Register æ³¨å†ŒæœåŠ¡
func (r *ConsulRegistry) Register(serviceName, serviceID, addr string, port int) error {
 registration := &api.AgentServiceRegistration{
  ID:      serviceID,
  Name:    serviceName,
  Address: addr,
  Port:    port,
  Check: &api.AgentServiceCheck{
   HTTP:                           fmt.Sprintf("http://%s:%d/health", addr, port),
   Timeout:                        "3s",
   Interval:                       "10s",
   DeregisterCriticalServiceAfter: "30s",
  },
 }
 
 return r.client.Agent().ServiceRegister(registration)
}

// Deregister æ³¨é”€æœåŠ¡
func (r *ConsulRegistry) Deregister(serviceID string) error {
 return r.client.Agent().ServiceDeregister(serviceID)
}

// Discover å‘ç°æœåŠ¡
func (r *ConsulRegistry) Discover(serviceName string) ([]*api.ServiceEntry, error) {
 services, _, err := r.client.Health().Service(serviceName, "", true, nil)
 if err != nil {
  return nil, err
 }
 return services, nil
}

// Watch ç›‘å¬æœåŠ¡å˜åŒ–
func (r *ConsulRegistry) Watch(serviceName string, callback func([]*api.ServiceEntry)) {
 var lastIndex uint64
 
 for {
  services, meta, err := r.client.Health().Service(
   serviceName,
   "",
   true,
   &api.QueryOptions{WaitIndex: lastIndex},
  )
  if err != nil {
   log.Printf("watch error: %v", err)
   continue
  }
  
  lastIndex = meta.LastIndex
  callback(services)
 }
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleConsul() {
 registry, err := NewConsulRegistry("localhost:8500")
 if err != nil {
  log.Fatal(err)
 }
 
 // æ³¨å†ŒæœåŠ¡
 err = registry.Register("user-service", "user-1", "localhost", 50051)
 if err != nil {
  log.Fatal(err)
 }
 
 // å‘ç°æœåŠ¡
 services, err := registry.Discover("user-service")
 if err != nil {
  log.Fatal(err)
 }
 
 for _, service := range services {
  fmt.Printf("Service: %s:%d\n", service.Service.Address, service.Service.Port)
 }
 
 // ç›‘å¬æœåŠ¡å˜åŒ–
 go registry.Watch("user-service", func(services []*api.ServiceEntry) {
  log.Printf("Services updated: %d instances", len(services))
 })
}
```

---

## 3. è´Ÿè½½å‡è¡¡

### 3.1 å®¢æˆ·ç«¯è´Ÿè½½å‡è¡¡

```go
package loadbalance

import (
 "context"
 "fmt"
 "sync"
 "sync/atomic"

 "google.golang.org/grpc"
 "google.golang.org/grpc/credentials/insecure"
)

// RoundRobinBalancer è½®è¯¢è´Ÿè½½å‡è¡¡å™¨
type RoundRobinBalancer struct {
 conns   []*grpc.ClientConn
 current uint32
 mu      sync.RWMutex
}

// NewRoundRobinBalancer åˆ›å»ºè½®è¯¢è´Ÿè½½å‡è¡¡å™¨
func NewRoundRobinBalancer(addrs []string) (*RoundRobinBalancer, error) {
 balancer := &RoundRobinBalancer{
  conns: make([]*grpc.ClientConn, 0, len(addrs)),
 }
 
 for _, addr := range addrs {
  conn, err := grpc.NewClient(
   addr,
   grpc.WithTransportCredentials(insecure.NewCredentials()),
  )
  if err != nil {
   return nil, fmt.Errorf("failed to connect to %s: %w", addr, err)
  }
  balancer.conns = append(balancer.conns, conn)
 }
 
 return balancer, nil
}

// GetConnection è·å–è¿æ¥ï¼ˆè½®è¯¢ï¼‰
func (b *RoundRobinBalancer) GetConnection() *grpc.ClientConn {
 b.mu.RLock()
 defer b.mu.RUnlock()
 
 if len(b.conns) == 0 {
  return nil
 }
 
 // åŸå­é€’å¢è®¡æ•°å™¨
 index := atomic.AddUint32(&b.current, 1)
 return b.conns[int(index)%len(b.conns)]
}

// UpdateConnections æ›´æ–°è¿æ¥åˆ—è¡¨
func (b *RoundRobinBalancer) UpdateConnections(addrs []string) error {
 b.mu.Lock()
 defer b.mu.Unlock()
 
 // å…³é—­æ—§è¿æ¥
 for _, conn := range b.conns {
  conn.Close()
 }
 
 // å»ºç«‹æ–°è¿æ¥
 newConns := make([]*grpc.ClientConn, 0, len(addrs))
 for _, addr := range addrs {
  conn, err := grpc.NewClient(
   addr,
   grpc.WithTransportCredentials(insecure.NewCredentials()),
  )
  if err != nil {
   return err
  }
  newConns = append(newConns, conn)
 }
 
 b.conns = newConns
 return nil
}

// Close å…³é—­æ‰€æœ‰è¿æ¥
func (b *RoundRobinBalancer) Close() {
 b.mu.Lock()
 defer b.mu.Unlock()
 
 for _, conn := range b.conns {
  conn.Close()
 }
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleLoadBalancer() {
 addrs := []string{
  "localhost:50051",
  "localhost:50052",
  "localhost:50053",
 }
 
 balancer, err := NewRoundRobinBalancer(addrs)
 if err != nil {
  log.Fatal(err)
 }
 defer balancer.Close()
 
 // ä½¿ç”¨è´Ÿè½½å‡è¡¡
 for i := 0; i < 10; i++ {
  conn := balancer.GetConnection()
  // ä½¿ç”¨connè°ƒç”¨gRPCæœåŠ¡
  fmt.Printf("Request %d using connection: %v\n", i, conn.Target())
 }
}
```

---

## 4. é“¾è·¯è¿½è¸ª

### 4.1 OpenTelemetryé›†æˆ

```go
package tracing

import (
 "context"
 "log"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/exporters/jaeger"
 "go.opentelemetry.io/otel/sdk/resource"
 sdktrace "go.opentelemetry.io/otel/sdk/trace"
 semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
 "go.opentelemetry.io/otel/trace"
)

// InitTracer åˆå§‹åŒ–è¿½è¸ªå™¨
func InitTracer(serviceName, jaegerEndpoint string) func() {
 // åˆ›å»ºJaegerå¯¼å‡ºå™¨
 exporter, err := jaeger.New(
  jaeger.WithCollectorEndpoint(jaeger.WithEndpoint(jaegerEndpoint)),
 )
 if err != nil {
  log.Fatalf("failed to create jaeger exporter: %v", err)
 }
 
 // åˆ›å»ºè¿½è¸ªæä¾›è€…
 tp := sdktrace.NewTracerProvider(
  sdktrace.WithBatcher(exporter),
  sdktrace.WithResource(resource.NewWithAttributes(
   semconv.SchemaURL,
   semconv.ServiceNameKey.String(serviceName),
  )),
 )
 
 // è®¾ç½®å…¨å±€è¿½è¸ªæä¾›è€…
 otel.SetTracerProvider(tp)
 
 // è¿”å›æ¸…ç†å‡½æ•°
 return func() {
  if err := tp.Shutdown(context.Background()); err != nil {
   log.Printf("failed to shutdown tracer: %v", err)
  }
 }
}

// StartSpan å¼€å§‹ä¸€ä¸ªspan
func StartSpan(ctx context.Context, spanName string) (context.Context, trace.Span) {
 tracer := otel.Tracer("microservice")
 return tracer.Start(ctx, spanName)
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleTracing() {
 // åˆå§‹åŒ–è¿½è¸ªå™¨
 cleanup := InitTracer("user-service", "http://localhost:14268/api/traces")
 defer cleanup()
 
 ctx := context.Background()
 
 // åˆ›å»ºspan
 ctx, span := StartSpan(ctx, "process-user-request")
 defer span.End()
 
 // æ·»åŠ äº‹ä»¶
 span.AddEvent("processing user data")
 
 // åµŒå¥—span
 ctx, childSpan := StartSpan(ctx, "database-query")
 // æ‰§è¡Œæ•°æ®åº“æ“ä½œ
 childSpan.End()
 
 // æ·»åŠ å±æ€§
 span.SetAttributes(
  semconv.ServiceNameKey.String("user-service"),
 )
}
```

---

## 5. ç†”æ–­é™çº§

### 5.1 ä½¿ç”¨gobreaker

```go
package circuitbreaker

import (
 "context"
 "errors"
 "fmt"
 "time"

 "github.com/sony/gobreaker"
 "google.golang.org/grpc"
)

// CircuitBreaker ç†”æ–­å™¨åŒ…è£…
type CircuitBreaker struct {
 cb *gobreaker.CircuitBreaker
}

// NewCircuitBreaker åˆ›å»ºç†”æ–­å™¨
func NewCircuitBreaker(name string) *CircuitBreaker {
 settings := gobreaker.Settings{
  Name:        name,
  MaxRequests: 3,                   // åŠå¼€çŠ¶æ€æœ€å¤§è¯·æ±‚æ•°
  Interval:    10 * time.Second,    // ç»Ÿè®¡å‘¨æœŸ
  Timeout:     60 * time.Second,    // ç†”æ–­è¶…æ—¶
  ReadyToTrip: func(counts gobreaker.Counts) bool {
   // å¤±è´¥ç‡è¶…è¿‡50%åˆ™ç†”æ–­
   failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)
   return counts.Requests >= 3 && failureRatio >= 0.5
  },
  OnStateChange: func(name string, from, to gobreaker.State) {
   fmt.Printf("Circuit breaker '%s' state changed from %s to %s\n", name, from, to)
  },
 }
 
 return &CircuitBreaker{
  cb: gobreaker.NewCircuitBreaker(settings),
 }
}

// Execute æ‰§è¡Œå¸¦ç†”æ–­çš„æ“ä½œ
func (cb *CircuitBreaker) Execute(fn func() (interface{}, error)) (interface{}, error) {
 return cb.cb.Execute(fn)
}

// UnaryClientInterceptor ç†”æ–­æ‹¦æˆªå™¨
func (cb *CircuitBreaker) UnaryClientInterceptor() grpc.UnaryClientInterceptor {
 return func(
  ctx context.Context,
  method string,
  req, reply interface{},
  cc *grpc.ClientConn,
  invoker grpc.UnaryInvoker,
  opts ...grpc.CallOption,
 ) error {
  _, err := cb.Execute(func() (interface{}, error) {
   return nil, invoker(ctx, method, req, reply, cc, opts...)
  })
  return err
 }
}

// é™çº§å¤„ç†
func fallbackHandler(serviceName string) func() (interface{}, error) {
 return func() (interface{}, error) {
  // è¿”å›é™çº§å“åº”
  return fmt.Sprintf("Service %s is unavailable, using fallback", serviceName), nil
 }
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleCircuitBreaker() {
 cb := NewCircuitBreaker("user-service")
 
 // æ‰§è¡Œæ“ä½œ
 for i := 0; i < 10; i++ {
  result, err := cb.Execute(func() (interface{}, error) {
   // æ¨¡æ‹ŸæœåŠ¡è°ƒç”¨
   if i%2 == 0 {
    return "success", nil
   }
   return nil, errors.New("service error")
  })
  
  if err != nil {
   // ä½¿ç”¨é™çº§
   result, _ = fallbackHandler("user-service")()
  }
  
  fmt.Printf("Request %d: %v\n", i, result)
  time.Sleep(100 * time.Millisecond)
 }
}
```

---

## 6. APIç½‘å…³

### 6.1 HTTPåˆ°gRPCç½‘å…³

```go
package gateway

import (
 "context"
 "encoding/json"
 "log"
 "net/http"

 "google.golang.org/grpc"
 "google.golang.org/grpc/credentials/insecure"
 
 pb "github.com/yourproject/proto/user"
)

// Gateway APIç½‘å…³
type Gateway struct {
 userClient pb.UserServiceClient
}

// NewGateway åˆ›å»ºç½‘å…³
func NewGateway(userServiceAddr string) (*Gateway, error) {
 conn, err := grpc.NewClient(
  userServiceAddr,
  grpc.WithTransportCredentials(insecure.NewCredentials()),
 )
 if err != nil {
  return nil, err
 }
 
 return &Gateway{
  userClient: pb.NewUserServiceClient(conn),
 }, nil
}

// HandleGetUser å¤„ç†è·å–ç”¨æˆ·è¯·æ±‚
func (g *Gateway) HandleGetUser(w http.ResponseWriter, r *http.Request) {
 // è§£æå‚æ•°
 id := r.URL.Query().Get("id")
 if id == "" {
  http.Error(w, "id required", http.StatusBadRequest)
  return
 }
 
 // è°ƒç”¨gRPCæœåŠ¡
 resp, err := g.userClient.GetUser(r.Context(), &pb.GetUserRequest{
  Id: 1, // å®é™…åº”è§£æid
 })
 if err != nil {
  http.Error(w, err.Error(), http.StatusInternalServerError)
  return
 }
 
 // è¿”å›JSONå“åº”
 w.Header().Set("Content-Type", "application/json")
 json.NewEncoder(w).Encode(resp.User)
}

// HandleCreateUser å¤„ç†åˆ›å»ºç”¨æˆ·è¯·æ±‚
func (g *Gateway) HandleCreateUser(w http.ResponseWriter, r *http.Request) {
 var req struct {
  Name  string `json:"name"`
  Email string `json:"email"`
 }
 
 if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
  http.Error(w, err.Error(), http.StatusBadRequest)
  return
 }
 
 // è°ƒç”¨gRPCæœåŠ¡
 resp, err := g.userClient.CreateUser(r.Context(), &pb.CreateUserRequest{
  Name:  req.Name,
  Email: req.Email,
 })
 if err != nil {
  http.Error(w, err.Error(), http.StatusInternalServerError)
  return
 }
 
 // è¿”å›JSONå“åº”
 w.Header().Set("Content-Type", "application/json")
 w.WriteHeader(http.StatusCreated)
 json.NewEncoder(w).Encode(resp.User)
}

// Start å¯åŠ¨ç½‘å…³
func (g *Gateway) Start(addr string) error {
 mux := http.NewServeMux()
 
 // æ³¨å†Œè·¯ç”±
 mux.HandleFunc("/api/users", func(w http.ResponseWriter, r *http.Request) {
  switch r.Method {
  case http.MethodGet:
   g.HandleGetUser(w, r)
  case http.MethodPost:
   g.HandleCreateUser(w, r)
  default:
   http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
  }
 })
 
 log.Printf("API Gateway listening on %s", addr)
 return http.ListenAndServe(addr, mux)
}

func main() {
 gateway, err := NewGateway("localhost:50051")
 if err != nil {
  log.Fatal(err)
 }
 
 if err := gateway.Start(":8080"); err != nil {
  log.Fatal(err)
 }
}
```

---

## 7. é…ç½®ä¸­å¿ƒ

### 7.1 Viperé…ç½®ç®¡ç†

```go
package config

import (
 "fmt"
 "log"

 "github.com/spf13/viper"
)

// Config é…ç½®ç»“æ„
type Config struct {
 Server   ServerConfig
 Database DatabaseConfig
 Redis    RedisConfig
 Services ServicesConfig
}

type ServerConfig struct {
 Port int
 Mode string
}

type DatabaseConfig struct {
 Host     string
 Port     int
 User     string
 Password string
 DBName   string
}

type RedisConfig struct {
 Host     string
 Port     int
 Password string
}

type ServicesConfig struct {
 UserService   string
 OrderService  string
 PaymentService string
}

// LoadConfig åŠ è½½é…ç½®
func LoadConfig(configPath string) (*Config, error) {
 viper.SetConfigFile(configPath)
 viper.SetConfigType("yaml")
 
 // è®¾ç½®ç¯å¢ƒå˜é‡å‰ç¼€
 viper.SetEnvPrefix("APP")
 viper.AutomaticEnv()
 
 // è¯»å–é…ç½®æ–‡ä»¶
 if err := viper.ReadInConfig(); err != nil {
  return nil, fmt.Errorf("failed to read config: %w", err)
 }
 
 // è§£æé…ç½®
 var config Config
 if err := viper.Unmarshal(&config); err != nil {
  return nil, fmt.Errorf("failed to unmarshal config: %w", err)
 }
 
 return &config, nil
}

// WatchConfig ç›‘å¬é…ç½®å˜åŒ–
func WatchConfig(callback func(*Config)) {
 viper.WatchConfig()
 viper.OnConfigChange(func(e fsnotify.Event) {
  log.Printf("Config file changed: %s", e.Name)
  
  var config Config
  if err := viper.Unmarshal(&config); err != nil {
   log.Printf("failed to unmarshal config: %v", err)
   return
  }
  
  callback(&config)
 })
}
```

**config.yamlç¤ºä¾‹**:

```yaml
server:
  port: 8080
  mode: production

database:
  host: localhost
  port: 5432
  user: postgres
  password: password
  dbname: myapp

redis:
  host: localhost
  port: 6379
  password: ""

services:
  user_service: "localhost:50051"
  order_service: "localhost:50052"
  payment_service: "localhost:50053"
```

---

## 8. å®Œæ•´ç¤ºä¾‹

### 8.1 ç”¨æˆ·å¾®æœåŠ¡

```go
package main

import (
 "context"
 "fmt"
 "log"
 "net"
 "os"
 "os/signal"
 "syscall"

 "google.golang.org/grpc"
 "google.golang.org/grpc/health"
 healthpb "google.golang.org/grpc/health/grpc_health_v1"
 
 pb "github.com/yourproject/proto/user"
)

type UserMicroservice struct {
 server   *grpc.Server
 registry *ConsulRegistry
 config   *Config
}

func NewUserMicroservice(configPath string) (*UserMicroservice, error) {
 // åŠ è½½é…ç½®
 config, err := LoadConfig(configPath)
 if err != nil {
  return nil, err
 }
 
 // åˆå§‹åŒ–è¿½è¸ª
 cleanup := InitTracer("user-service", "http://localhost:14268/api/traces")
 defer cleanup()
 
 // åˆ›å»ºæ³¨å†Œä¸­å¿ƒå®¢æˆ·ç«¯
 registry, err := NewConsulRegistry("localhost:8500")
 if err != nil {
  return nil, err
 }
 
 // åˆ›å»ºgRPCæœåŠ¡å™¨
 server := grpc.NewServer(
  grpc.UnaryInterceptor(unaryInterceptor),
 )
 
 // æ³¨å†ŒæœåŠ¡
 pb.RegisterUserServiceServer(server, &UserServer{})
 
 // æ³¨å†Œå¥åº·æ£€æŸ¥
 healthServer := health.NewServer()
 healthpb.RegisterHealthServer(server, healthServer)
 healthServer.SetServingStatus("user-service", healthpb.HealthCheckResponse_SERVING)
 
 return &UserMicroservice{
  server:   server,
  registry: registry,
  config:   config,
 }, nil
}

func (m *UserMicroservice) Start() error {
 // ç›‘å¬ç«¯å£
 lis, err := net.Listen("tcp", fmt.Sprintf(":%d", m.config.Server.Port))
 if err != nil {
  return err
 }
 
 // æ³¨å†Œåˆ°Consul
 serviceID := fmt.Sprintf("user-service-%s", getHostname())
 err = m.registry.Register(
  "user-service",
  serviceID,
  getLocalIP(),
  m.config.Server.Port,
 )
 if err != nil {
  return err
 }
 
 // ä¼˜é›…å…³é—­
 go m.gracefulShutdown(serviceID)
 
 log.Printf("User microservice listening on :%d", m.config.Server.Port)
 return m.server.Serve(lis)
}

func (m *UserMicroservice) gracefulShutdown(serviceID string) {
 quit := make(chan os.Signal, 1)
 signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
 
 <-quit
 log.Println("Shutting down server...")
 
 // æ³¨é”€æœåŠ¡
 m.registry.Deregister(serviceID)
 
 // ä¼˜é›…åœæ­¢
 m.server.GracefulStop()
 
 log.Println("Server stopped")
}

func main() {
 ms, err := NewUserMicroservice("config.yaml")
 if err != nil {
  log.Fatal(err)
 }
 
 if err := ms.Start(); err != nil {
  log.Fatal(err)
 }
}

func getHostname() string {
 hostname, _ := os.Hostname()
 return hostname
}

func getLocalIP() string {
 // å®ç°è·å–æœ¬åœ°IP
 return "localhost"
}
```

---

## ğŸ“š æœ€ä½³å®è·µ

1. âœ… **æœåŠ¡æ‹†åˆ†**: æŒ‰ä¸šåŠ¡é¢†åŸŸåˆ’åˆ†æœåŠ¡
2. âœ… **å¼‚æ­¥é€šä¿¡**: ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—è§£è€¦æœåŠ¡
3. âœ… **ç†”æ–­é™çº§**: é˜²æ­¢é›ªå´©æ•ˆåº”
4. âœ… **é“¾è·¯è¿½è¸ª**: å¿«é€Ÿå®šä½é—®é¢˜
5. âœ… **é…ç½®ä¸­å¿ƒ**: ç»Ÿä¸€é…ç½®ç®¡ç†
6. âœ… **æœåŠ¡ç½‘æ ¼**: ä½¿ç”¨Istioç­‰æœåŠ¡ç½‘æ ¼
7. âœ… **å®¹å™¨åŒ–**: Docker + Kuberneteséƒ¨ç½²

---

## ğŸ¯ æ€»ç»“

Go 1.25.3å¾®æœåŠ¡æ¶æ„è¦ç‚¹ï¼š

- âœ… gRPCé«˜æ€§èƒ½RPCé€šä¿¡
- âœ… ConsulæœåŠ¡æ³¨å†Œä¸å‘ç°
- âœ… å®¢æˆ·ç«¯è´Ÿè½½å‡è¡¡
- âœ… OpenTelemetryé“¾è·¯è¿½è¸ª
- âœ… Circuit Breakerç†”æ–­ä¿æŠ¤
- âœ… API Gatewayç»Ÿä¸€å…¥å£
- âœ… é…ç½®ä¸­å¿ƒé›†ä¸­ç®¡ç†

---

<div align="center">

**æ„å»ºä¼ä¸šçº§å¾®æœåŠ¡æ¶æ„**:

[ğŸ“š è¿”å›ç›®å½•](../README.md) | [ğŸ“– ä¸‹ä¸€ç« ](11-æœåŠ¡ç½‘æ ¼.md)

Made with â¤ï¸ for Go Developers

</div>

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-10-22  
**Goç‰ˆæœ¬**: Go 1.25.3  
**ç”Ÿäº§å°±ç»ª**: âœ…
