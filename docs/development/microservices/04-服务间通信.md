# æœåŠ¡é—´é€šä¿¡

> **ç®€ä»‹**: æ·±å…¥ç†è§£å¾®æœåŠ¡é—´çš„åŒæ­¥ä¸å¼‚æ­¥é€šä¿¡æ¨¡å¼ï¼ŒæŒæ¡HTTPã€gRPCå’Œæ¶ˆæ¯é˜Ÿåˆ—çš„å®æˆ˜åº”ç”¨
> **ç‰ˆæœ¬**: Go 1.23+  
> **éš¾åº¦**: â­â­â­â­  
> **æ ‡ç­¾**: #å¾®æœåŠ¡ #é€šä¿¡ #gRPC #æ¶ˆæ¯é˜Ÿåˆ—

<!-- TOC START -->
- [æœåŠ¡é—´é€šä¿¡](#æœåŠ¡é—´é€šä¿¡)
  - [ğŸ“š ç†è®ºåˆ†æ](#-ç†è®ºåˆ†æ)
    - [é€šä¿¡æ¨¡å¼å¯¹æ¯”](#é€šä¿¡æ¨¡å¼å¯¹æ¯”)
    - [åŒæ­¥é€šä¿¡](#åŒæ­¥é€šä¿¡)
    - [å¼‚æ­¥é€šä¿¡](#å¼‚æ­¥é€šä¿¡)
    - [é€šä¿¡å¯é æ€§](#é€šä¿¡å¯é æ€§)
  - [ğŸ’» ä»£ç ç¤ºä¾‹](#-ä»£ç ç¤ºä¾‹)
    - [HTTPå®¢æˆ·ç«¯å®ç°](#httpå®¢æˆ·ç«¯å®ç°)
    - [gRPCå®¢æˆ·ç«¯å®ç°](#grpcå®¢æˆ·ç«¯å®ç°)
    - [æ¶ˆæ¯é˜Ÿåˆ—å®ç°](#æ¶ˆæ¯é˜Ÿåˆ—å®ç°)
    - [äº‹ä»¶é©±åŠ¨æ¶æ„](#äº‹ä»¶é©±åŠ¨æ¶æ„)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
  - [ğŸ” å¸¸è§é—®é¢˜](#-å¸¸è§é—®é¢˜)
  - [ğŸ“š æ‰©å±•é˜…è¯»](#-æ‰©å±•é˜…è¯»)
  - [âœ… è½åœ°æ£€æŸ¥æ¸…å•](#-è½åœ°æ£€æŸ¥æ¸…å•)
  - [ğŸ§ª æœ¬åœ°å¿«é€ŸéªŒè¯](#-æœ¬åœ°å¿«é€ŸéªŒè¯)
<!-- TOC END -->


## ğŸ“‹ ç›®å½•


- [ğŸ“š ç†è®ºåˆ†æ](#-ç†è®ºåˆ†æ)
  - [é€šä¿¡æ¨¡å¼å¯¹æ¯”](#é€šä¿¡æ¨¡å¼å¯¹æ¯”)
  - [åŒæ­¥é€šä¿¡](#åŒæ­¥é€šä¿¡)
  - [å¼‚æ­¥é€šä¿¡](#å¼‚æ­¥é€šä¿¡)
  - [é€šä¿¡å¯é æ€§](#é€šä¿¡å¯é æ€§)
- [ğŸ’» ä»£ç ç¤ºä¾‹](#-ä»£ç ç¤ºä¾‹)
  - [HTTPå®¢æˆ·ç«¯å®ç°](#httpå®¢æˆ·ç«¯å®ç°)
  - [gRPCå®¢æˆ·ç«¯å®ç°](#grpcå®¢æˆ·ç«¯å®ç°)
  - [æ¶ˆæ¯é˜Ÿåˆ—å®ç°](#æ¶ˆæ¯é˜Ÿåˆ—å®ç°)
  - [äº‹ä»¶é©±åŠ¨æ¶æ„](#äº‹ä»¶é©±åŠ¨æ¶æ„)
- [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
- [ğŸ” å¸¸è§é—®é¢˜](#-å¸¸è§é—®é¢˜)
- [ğŸ“š æ‰©å±•é˜…è¯»](#-æ‰©å±•é˜…è¯»)
- [âœ… è½åœ°æ£€æŸ¥æ¸…å•](#-è½åœ°æ£€æŸ¥æ¸…å•)
- [ğŸ§ª æœ¬åœ°å¿«é€ŸéªŒè¯](#-æœ¬åœ°å¿«é€ŸéªŒè¯)

## ğŸ“š ç†è®ºåˆ†æ

### é€šä¿¡æ¨¡å¼å¯¹æ¯”

| é€šä¿¡æ¨¡å¼ | åè®® | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ | ç¼ºç‚¹ |
|----------|------|------|----------|------|
| åŒæ­¥HTTP | HTTP/1.1, HTTP/2 | ç®€å•ã€é€šç”¨ã€æ˜“è°ƒè¯• | æŸ¥è¯¢ã€ç®€å•CRUD | è€¦åˆåº¦é«˜ã€æ€§èƒ½ä¸€èˆ¬ |
| åŒæ­¥gRPC | gRPC | é«˜æ€§èƒ½ã€å¼ºç±»å‹ã€æµå¼ | å†…éƒ¨æœåŠ¡è°ƒç”¨ | å­¦ä¹ æˆæœ¬ã€è°ƒè¯•å¤æ‚ |
| å¼‚æ­¥æ¶ˆæ¯ | Kafka, RabbitMQ, NATS | è§£è€¦ã€å‰Šå³°å¡«è°· | äº‹ä»¶é©±åŠ¨ã€æ‰¹å¤„ç† | å¤æ‚åº¦é«˜ã€ä¸€è‡´æ€§æŒ‘æˆ˜ |
| äº‹ä»¶æµ | Kafka Streams, Pulsar | å®æ—¶å¤„ç†ã€æµå¼è®¡ç®— | å®æ—¶åˆ†æã€CQRS | èµ„æºæ¶ˆè€—å¤§ |

### åŒæ­¥é€šä¿¡

**HTTP/REST**:

- åŸºäºHTTPåè®®ï¼Œä½¿ç”¨JSON/XMLæ ¼å¼
- æ”¯æŒç¼“å­˜ã€é‡è¯•ã€è¶…æ—¶ç­‰æ ‡å‡†æœºåˆ¶
- é€‚åˆè·¨è¯­è¨€ã€è·¨å¹³å°çš„é›†æˆ

**gRPC**:

- åŸºäºHTTP/2å’ŒProtocol Buffers
- æ”¯æŒåŒå‘æµã€æµå¼ä¼ è¾“
- è‡ªåŠ¨ç”Ÿæˆå®¢æˆ·ç«¯ä»£ç ï¼Œç±»å‹å®‰å…¨

### å¼‚æ­¥é€šä¿¡

**æ¶ˆæ¯é˜Ÿåˆ—æ¨¡å¼**:

- å‘å¸ƒ/è®¢é˜…ï¼šä¸€å¯¹å¤šæ¶ˆæ¯åˆ†å‘
- ç‚¹å¯¹ç‚¹ï¼šä¸€å¯¹ä¸€æ¶ˆæ¯ä¼ é€’
- è¯·æ±‚/å“åº”ï¼šå¼‚æ­¥RPCæ¨¡å¼

**äº‹ä»¶é©±åŠ¨æ¶æ„**:

- äº‹ä»¶æº¯æºï¼šä»¥äº‹ä»¶ä¸ºä¸­å¿ƒçš„æ•°æ®æ¨¡å‹
- CQRSï¼šå‘½ä»¤æŸ¥è¯¢èŒè´£åˆ†ç¦»
- Sagaæ¨¡å¼ï¼šåˆ†å¸ƒå¼äº‹åŠ¡ç®¡ç†

### é€šä¿¡å¯é æ€§

- **é‡è¯•æœºåˆ¶**ï¼šæŒ‡æ•°é€€é¿ã€æŠ–åŠ¨ã€æœ€å¤§é‡è¯•æ¬¡æ•°
- **ç†”æ–­å™¨**ï¼šé˜²æ­¢çº§è”æ•…éšœï¼Œå¿«é€Ÿå¤±è´¥
- **è¶…æ—¶æ§åˆ¶**ï¼šé¿å…é•¿æ—¶é—´ç­‰å¾…
- **å¹‚ç­‰æ€§**ï¼šç¡®ä¿é‡å¤è¯·æ±‚çš„å‰¯ä½œç”¨ä¸€è‡´
- **æ¶ˆæ¯ç¡®è®¤**ï¼šä¿è¯æ¶ˆæ¯è‡³å°‘æŠ•é€’ä¸€æ¬¡

## ğŸ’» ä»£ç ç¤ºä¾‹

### HTTPå®¢æˆ·ç«¯å®ç°

```go
package main

import (
    "bytes"
    "context"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "time"
)

type HTTPClient struct {
    client  *http.Client
    baseURL string
    retries int
}

type RequestConfig struct {
    Timeout time.Duration
    Headers map[string]string
}

type User struct {
    ID   int    `json:"id"`
    Name string `json:"name"`
    Email string `json:"email"`
}

func NewHTTPClient(baseURL string) *HTTPClient {
    return &HTTPClient{
        client: &http.Client{
            Timeout: 30 * time.Second,
        },
        baseURL: baseURL,
        retries: 3,
    }
}

func (c *HTTPClient) Get(ctx context.Context, path string, config *RequestConfig) (*http.Response, error) {
    return c.doRequest(ctx, "GET", path, nil, config)
}

func (c *HTTPClient) Post(ctx context.Context, path string, body interface{}, config *RequestConfig) (*http.Response, error) {
    jsonBody, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    return c.doRequest(ctx, "POST", path, jsonBody, config)
}

func (c *HTTPClient) doRequest(ctx context.Context, method, path string, body []byte, config *RequestConfig) (*http.Response, error) {
    url := c.baseURL + path
    
    var req *http.Request
    var err error
    
    if body != nil {
        req, err = http.NewRequestWithContext(ctx, method, url, bytes.NewBuffer(body))
    } else {
        req, err = http.NewRequestWithContext(ctx, method, url, nil)
    }
    
    if err != nil {
        return nil, err
    }
    
    // è®¾ç½®é»˜è®¤å¤´éƒ¨
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("User-Agent", "go-http-client/1.0")
    
    // è®¾ç½®è‡ªå®šä¹‰å¤´éƒ¨
    if config != nil && config.Headers != nil {
        for k, v := range config.Headers {
            req.Header.Set(k, v)
        }
    }
    
    // é‡è¯•æœºåˆ¶
    var resp *http.Response
    for i := 0; i <= c.retries; i++ {
        resp, err = c.client.Do(req)
        if err == nil && resp.StatusCode < 500 {
            break
        }
        
        if i < c.retries {
            // æŒ‡æ•°é€€é¿
            backoff := time.Duration(1<<uint(i)) * time.Second
            time.Sleep(backoff)
        }
    }
    
    return resp, err
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    client := NewHTTPClient("http://localhost:8080")
    
    // è·å–ç”¨æˆ·ä¿¡æ¯
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    resp, err := client.Get(ctx, "/api/users/1", nil)
    if err != nil {
        fmt.Printf("è¯·æ±‚å¤±è´¥: %v\n", err)
        return
    }
    defer resp.Body.Close()
    
    if resp.StatusCode == http.StatusOK {
        var user User
        if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
            fmt.Printf("è§£æå“åº”å¤±è´¥: %v\n", err)
            return
        }
        fmt.Printf("ç”¨æˆ·ä¿¡æ¯: %+v\n", user)
    }
}
```

### gRPCå®¢æˆ·ç«¯å®ç°

```go
package main

import (
    "context"
    "fmt"
    "log"
    "time"

    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
    pb "path/to/proto"
)

type GRPCClient struct {
    conn   *grpc.ClientConn
    client pb.UserServiceClient
}

func NewGRPCClient(address string) (*GRPCClient, error) {
    // è¿æ¥é…ç½®
    opts := []grpc.DialOption{
        grpc.WithTransportCredentials(insecure.NewCredentials()),
        grpc.WithTimeout(30 * time.Second),
        grpc.WithDefaultCallOptions(
            grpc.MaxCallRecvMsgSize(4*1024*1024), // 4MB
            grpc.MaxCallSendMsgSize(4*1024*1024), // 4MB
        ),
    }
    
    conn, err := grpc.Dial(address, opts...)
    if err != nil {
        return nil, err
    }
    
    client := pb.NewUserServiceClient(conn)
    
    return &GRPCClient{
        conn:   conn,
        client: client,
    }, nil
}

func (c *GRPCClient) GetUser(ctx context.Context, userID int64) (*pb.User, error) {
    req := &pb.GetUserRequest{
        UserId: userID,
    }
    
    // è®¾ç½®è¶…æ—¶
    ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
    defer cancel()
    
    resp, err := c.client.GetUser(ctx, req)
    if err != nil {
        return nil, err
    }
    
    return resp.User, nil
}

func (c *GRPCClient) CreateUser(ctx context.Context, name, email string) (*pb.User, error) {
    req := &pb.CreateUserRequest{
        Name:  name,
        Email: email,
    }
    
    ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
    defer cancel()
    
    resp, err := c.client.CreateUser(ctx, req)
    if err != nil {
        return nil, err
    }
    
    return resp.User, nil
}

func (c *GRPCClient) Close() error {
    return c.conn.Close()
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    client, err := NewGRPCClient("localhost:50051")
    if err != nil {
        log.Fatal(err)
    }
    defer client.Close()
    
    // è·å–ç”¨æˆ·
    user, err := client.GetUser(context.Background(), 1)
    if err != nil {
        log.Printf("è·å–ç”¨æˆ·å¤±è´¥: %v", err)
        return
    }
    fmt.Printf("ç”¨æˆ·ä¿¡æ¯: %+v\n", user)
    
    // åˆ›å»ºç”¨æˆ·
    newUser, err := client.CreateUser(context.Background(), "Alice", "alice@example.com")
    if err != nil {
        log.Printf("åˆ›å»ºç”¨æˆ·å¤±è´¥: %v", err)
        return
    }
    fmt.Printf("æ–°ç”¨æˆ·: %+v\n", newUser)
}
```

### æ¶ˆæ¯é˜Ÿåˆ—å®ç°

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "time"

    "github.com/nats-io/nats.go"
)

type MessageQueue struct {
    conn *nats.Conn
}

type Event struct {
    ID        string    `json:"id"`
    Type      string    `json:"type"`
    Data      interface{} `json:"data"`
    Timestamp time.Time `json:"timestamp"`
}

func NewMessageQueue(url string) (*MessageQueue, error) {
    conn, err := nats.Connect(url)
    if err != nil {
        return nil, err
    }
    
    return &MessageQueue{conn: conn}, nil
}

func (mq *MessageQueue) Publish(subject string, event *Event) error {
    data, err := json.Marshal(event)
    if err != nil {
        return err
    }
    
    return mq.conn.Publish(subject, data)
}

func (mq *MessageQueue) Subscribe(subject string, handler func(*Event)) error {
    _, err := mq.conn.Subscribe(subject, func(msg *nats.Msg) {
        var event Event
        if err := json.Unmarshal(msg.Data, &event); err != nil {
            log.Printf("è§£ææ¶ˆæ¯å¤±è´¥: %v", err)
            return
        }
        
        handler(&event)
    })
    
    return err
}

func (mq *MessageQueue) Request(subject string, event *Event, timeout time.Duration) (*Event, error) {
    data, err := json.Marshal(event)
    if err != nil {
        return nil, err
    }
    
    msg, err := mq.conn.Request(subject, data, timeout)
    if err != nil {
        return nil, err
    }
    
    var response Event
    if err := json.Unmarshal(msg.Data, &response); err != nil {
        return nil, err
    }
    
    return &response, nil
}

func (mq *MessageQueue) Close() {
    mq.conn.Close()
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    mq, err := NewMessageQueue("nats://localhost:4222")
    if err != nil {
        log.Fatal(err)
    }
    defer mq.Close()
    
    // å‘å¸ƒäº‹ä»¶
    event := &Event{
        ID:        "1",
        Type:      "user.created",
        Data:      map[string]interface{}{"name": "Alice", "email": "alice@example.com"},
        Timestamp: time.Now(),
    }
    
    err = mq.Publish("user.events", event)
    if err != nil {
        log.Printf("å‘å¸ƒäº‹ä»¶å¤±è´¥: %v", err)
        return
    }
    
    // è®¢é˜…äº‹ä»¶
    err = mq.Subscribe("user.events", func(event *Event) {
        fmt.Printf("æ”¶åˆ°äº‹ä»¶: %+v\n", event)
    })
    if err != nil {
        log.Printf("è®¢é˜…å¤±è´¥: %v", err)
        return
    }
    
    // è¯·æ±‚/å“åº”æ¨¡å¼
    request := &Event{
        ID:   "2",
        Type: "user.get",
        Data: map[string]interface{}{"id": 1},
    }
    
    response, err := mq.Request("user.requests", request, 5*time.Second)
    if err != nil {
        log.Printf("è¯·æ±‚å¤±è´¥: %v", err)
        return
    }
    
    fmt.Printf("å“åº”: %+v\n", response)
    
    // ä¿æŒè¿è¡Œ
    select {}
}
```

### äº‹ä»¶é©±åŠ¨æ¶æ„

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "sync"
    "time"
)

type EventStore struct {
    events []Event
    mutex  sync.RWMutex
}

type Event struct {
    ID        string                 `json:"id"`
    Type      string                 `json:"type"`
    AggregateID string               `json:"aggregate_id"`
    Data      map[string]interface{} `json:"data"`
    Version   int                    `json:"version"`
    Timestamp time.Time              `json:"timestamp"`
}

type EventHandler interface {
    Handle(event *Event) error
}

type UserService struct {
    eventStore *EventStore
    handlers   map[string][]EventHandler
}

func NewEventStore() *EventStore {
    return &EventStore{
        events: make([]Event, 0),
    }
}

func (es *EventStore) Append(event *Event) error {
    es.mutex.Lock()
    defer es.mutex.Unlock()
    
    event.Version = len(es.events) + 1
    event.Timestamp = time.Now()
    
    es.events = append(es.events, *event)
    return nil
}

func (es *EventStore) GetEvents(aggregateID string) ([]Event, error) {
    es.mutex.RLock()
    defer es.mutex.RUnlock()
    
    var events []Event
    for _, event := range es.events {
        if event.AggregateID == aggregateID {
            events = append(events, event)
        }
    }
    
    return events, nil
}

func NewUserService(eventStore *EventStore) *UserService {
    return &UserService{
        eventStore: eventStore,
        handlers:   make(map[string][]EventHandler),
    }
}

func (us *UserService) RegisterHandler(eventType string, handler EventHandler) {
    us.handlers[eventType] = append(us.handlers[eventType], handler)
}

func (us *UserService) PublishEvent(event *Event) error {
    // å­˜å‚¨äº‹ä»¶
    if err := us.eventStore.Append(event); err != nil {
        return err
    }
    
    // åˆ†å‘äº‹ä»¶
    handlers := us.handlers[event.Type]
    for _, handler := range handlers {
        go func(h EventHandler) {
            if err := h.Handle(event); err != nil {
                log.Printf("äº‹ä»¶å¤„ç†å¤±è´¥: %v", err)
            }
        }(handler)
    }
    
    return nil
}

func (us *UserService) CreateUser(name, email string) error {
    event := &Event{
        ID:          fmt.Sprintf("user-%d", time.Now().UnixNano()),
        Type:        "user.created",
        AggregateID: "user-1",
        Data: map[string]interface{}{
            "name":  name,
            "email": email,
        },
    }
    
    return us.PublishEvent(event)
}

// äº‹ä»¶å¤„ç†å™¨ç¤ºä¾‹
type EmailNotificationHandler struct{}

func (h *EmailNotificationHandler) Handle(event *Event) error {
    if event.Type == "user.created" {
        email := event.Data["email"].(string)
        fmt.Printf("å‘é€æ¬¢è¿é‚®ä»¶åˆ°: %s\n", email)
    }
    return nil
}

type AuditLogHandler struct{}

func (h *AuditLogHandler) Handle(event *Event) error {
    data, _ := json.Marshal(event)
    fmt.Printf("å®¡è®¡æ—¥å¿—: %s\n", string(data))
    return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    eventStore := NewEventStore()
    userService := NewUserService(eventStore)
    
    // æ³¨å†Œäº‹ä»¶å¤„ç†å™¨
    userService.RegisterHandler("user.created", &EmailNotificationHandler{})
    userService.RegisterHandler("user.created", &AuditLogHandler{})
    
    // åˆ›å»ºç”¨æˆ·
    err := userService.CreateUser("Alice", "alice@example.com")
    if err != nil {
        log.Printf("åˆ›å»ºç”¨æˆ·å¤±è´¥: %v", err)
        return
    }
    
    // ç­‰å¾…äº‹ä»¶å¤„ç†
    time.Sleep(1 * time.Second)
    
    // æŸ¥è¯¢äº‹ä»¶
    events, err := eventStore.GetEvents("user-1")
    if err != nil {
        log.Printf("æŸ¥è¯¢äº‹ä»¶å¤±è´¥: %v", err)
        return
    }
    
    fmt.Printf("ç”¨æˆ·äº‹ä»¶å†å²: %+v\n", events)
}
```

## ğŸ¯ æœ€ä½³å®è·µ

1. **é€‰æ‹©åˆé€‚çš„é€šä¿¡æ¨¡å¼**
   - æŸ¥è¯¢æ“ä½œä½¿ç”¨HTTP/REST
   - å†…éƒ¨æœåŠ¡è°ƒç”¨ä½¿ç”¨gRPC
   - å¼‚æ­¥å¤„ç†ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—
   - å®æ—¶æ•°æ®ä½¿ç”¨WebSocket

2. **å®ç°å¯é çš„é€šä¿¡**
   - è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
   - å®ç°é‡è¯•æœºåˆ¶å’Œç†”æ–­å™¨
   - ä½¿ç”¨å¹‚ç­‰æ€§è®¾è®¡
   - æ·»åŠ ç›‘æ§å’Œå‘Šè­¦

3. **ä¼˜åŒ–æ€§èƒ½**
   - ä½¿ç”¨è¿æ¥æ± 
   - å®ç°è¯·æ±‚æ‰¹å¤„ç†
   - å¯ç”¨å‹ç¼©å’Œç¼“å­˜
   - ç›‘æ§å»¶è¿Ÿå’Œååé‡

4. **ä¿è¯æ•°æ®ä¸€è‡´æ€§**
   - ä½¿ç”¨Sagaæ¨¡å¼å¤„ç†åˆ†å¸ƒå¼äº‹åŠ¡
   - å®ç°æœ€ç»ˆä¸€è‡´æ€§
   - ä½¿ç”¨äº‹ä»¶æº¯æº
   - æ·»åŠ è¡¥å¿æœºåˆ¶

## ğŸ” å¸¸è§é—®é¢˜

1. **ç½‘ç»œåˆ†åŒºé—®é¢˜**
   - å®ç°ç†”æ–­å™¨é¿å…çº§è”æ•…éšœ
   - ä½¿ç”¨è¶…æ—¶å’Œé‡è¯•æœºåˆ¶
   - è®¾è®¡é™çº§æ–¹æ¡ˆ

2. **æ•°æ®ä¸€è‡´æ€§é—®é¢˜**
   - é¿å…åˆ†å¸ƒå¼äº‹åŠ¡
   - ä½¿ç”¨æœ€ç»ˆä¸€è‡´æ€§
   - å®ç°è¡¥å¿æœºåˆ¶

3. **æ€§èƒ½ç“¶é¢ˆé—®é¢˜**
   - ä¼˜åŒ–ç½‘ç»œè°ƒç”¨
   - ä½¿ç”¨å¼‚æ­¥å¤„ç†
   - å®ç°ç¼“å­˜ç­–ç•¥

4. **è°ƒè¯•å›°éš¾é—®é¢˜**
   - æ·»åŠ åˆ†å¸ƒå¼è¿½è¸ª
   - ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—
   - å®ç°å¥åº·æ£€æŸ¥

## ğŸ“š æ‰©å±•é˜…è¯»

- [gRPCå®˜æ–¹æ–‡æ¡£](https://grpc.io/docs/)
- [NATSå®˜æ–¹æ–‡æ¡£](https://docs.nats.io/)
- [äº‹ä»¶é©±åŠ¨æ¶æ„æ¨¡å¼](https://microservices.io/patterns/data/event-driven-architecture.html)
- [Sagaæ¨¡å¼](https://microservices.io/patterns/data/saga.html)

## âœ… è½åœ°æ£€æŸ¥æ¸…å•

- é€šä¿¡åè®®é€‰æ‹©ï¼šHTTP/gRPC/æ¶ˆæ¯é˜Ÿåˆ—çš„é€‚ç”¨åœºæ™¯æ˜ç¡®
- å¯é æ€§ä¿éšœï¼šè¶…æ—¶ã€é‡è¯•ã€ç†”æ–­ã€å¹‚ç­‰æ€§è®¾è®¡å®Œæ•´
- æ€§èƒ½ä¼˜åŒ–ï¼šè¿æ¥æ± ã€æ‰¹å¤„ç†ã€å‹ç¼©ã€ç¼“å­˜ç­–ç•¥åˆ°ä½
- ç›‘æ§å‘Šè­¦ï¼šå»¶è¿Ÿã€ååé‡ã€é”™è¯¯ç‡ã€å¯ç”¨æ€§æŒ‡æ ‡è¦†ç›–
- å®‰å…¨é˜²æŠ¤ï¼šTLS/mTLSã€è®¤è¯æˆæƒã€é€Ÿç‡é™åˆ¶
- æ•°æ®ä¸€è‡´æ€§ï¼šSaga/è¡¥å¿ã€æœ€ç»ˆä¸€è‡´ã€äº‹ä»¶æº¯æºæ–¹æ¡ˆ

## ğŸ§ª æœ¬åœ°å¿«é€ŸéªŒè¯

1. å¯åŠ¨ä¾èµ–æœåŠ¡ï¼š
   - NATS: `nats-server`
   - gRPCæœåŠ¡ç«¯ï¼ˆå‚è€ƒå‰é¢çš„ç¤ºä¾‹ï¼‰
2. è¿è¡ŒHTTPå®¢æˆ·ç«¯ç¤ºä¾‹ï¼ŒéªŒè¯é‡è¯•å’Œè¶…æ—¶æœºåˆ¶
3. è¿è¡ŒgRPCå®¢æˆ·ç«¯ç¤ºä¾‹ï¼Œæµ‹è¯•æµå¼ä¼ è¾“
4. è¿è¡Œæ¶ˆæ¯é˜Ÿåˆ—ç¤ºä¾‹ï¼ŒéªŒè¯å‘å¸ƒ/è®¢é˜…å’Œè¯·æ±‚/å“åº”
5. è¿è¡Œäº‹ä»¶é©±åŠ¨ç¤ºä¾‹ï¼Œè§‚å¯Ÿäº‹ä»¶å­˜å‚¨å’Œå¤„ç†å™¨æ‰§è¡Œ
6. ä½¿ç”¨å‹æµ‹å·¥å…·éªŒè¯æ€§èƒ½å’Œå¯é æ€§æŒ‡æ ‡

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ20æ—¥  
**æ–‡æ¡£çŠ¶æ€**: å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
