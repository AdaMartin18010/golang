# 监控与追踪

**版本**: v1.0  
**更新日期**: 2025-10-29  
**适用于**: Go 1.23+

---

## 📋 目录


- [📚 理论分析](#理论分析)
  - [可观测性三大支柱](#可观测性三大支柱)
  - [监控指标体系](#监控指标体系)
  - [分布式追踪原理](#分布式追踪原理)
  - [告警与SLO设计](#告警与slo设计)
- [💻 代码示例](#代码示例)
  - [Prometheus指标收集](#prometheus指标收集)
  - [Jaeger分布式追踪](#jaeger分布式追踪)
  - [结构化日志](#结构化日志)
  - [健康检查与探针](#健康检查与探针)
- [🎯 最佳实践](#最佳实践)
- [🔍 常见问题](#常见问题)
- [📚 扩展阅读](#扩展阅读)
- [✅ 落地检查清单](#落地检查清单)
- [🧪 本地快速验证](#本地快速验证)

## 📚 理论分析

### 可观测性三大支柱

**Metrics（指标）**:

- 数值型数据，用于监控系统状态
- 支持聚合、查询、告警
- 适合监控趋势和异常

**Logs（日志）**:

- 事件记录，包含时间戳和上下文
- 结构化日志便于分析
- 适合问题排查和审计

**Traces（追踪）**:

- 请求在分布式系统中的完整路径
- 显示服务间的调用关系
- 适合性能分析和依赖分析

### 监控指标体系

**RED指标（面向请求）**:

- Rate（速率）：每秒请求数
- Errors（错误）：错误率
- Duration（持续时间）：响应时间

**USE指标（面向资源）**:

- Utilization（利用率）：资源使用率
- Saturation（饱和度）：资源排队情况
- Errors（错误）：资源错误率

**业务指标**:

- 用户活跃度、转化率
- 业务关键路径指标
- 自定义业务KPI

### 分布式追踪原理

```text
请求ID: trace-123
┌─────────────────────────────────────────────────────────────┐
│ 前端服务 (100ms)                                            │
│ ├─ API网关 (20ms)                                          │
│ │  ├─ 用户服务 (50ms)                                      │
│ │  │  └─ 数据库 (30ms)                                     │
│ │  └─ 订单服务 (80ms)                                      │
│ │     ├─ 支付服务 (60ms)                                   │
│ │     └─ 库存服务 (40ms)                                   │
└─────────────────────────────────────────────────────────────┘
```

### 告警与SLO设计

**SLO（Service Level Objectives）**:

- 可用性：99.9% uptime
- 延迟：95%请求 < 200ms
- 错误率：< 0.1%

**告警策略**:

- 基于SLO的告警阈值
- 多级告警（Warning/Critical）
- 告警抑制和聚合

## 💻 代码示例

### Prometheus指标收集

```go
package main

import (
    "net/http"
    "time"

    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
    "github.com/prometheus/client_golang/prometheus/promhttp"
)

type Metrics struct {
    // HTTP请求指标
    httpRequestsTotal    *prometheus.CounterVec
    httpRequestDuration  *prometheus.HistogramVec
    httpRequestsInFlight prometheus.Gauge
    
    // 业务指标
    activeUsers     prometheus.Gauge
    ordersProcessed *prometheus.CounterVec
    cacheHits       *prometheus.CounterVec
}

func NewMetrics() *Metrics {
    return &Metrics{
        httpRequestsTotal: promauto.NewCounterVec(
            prometheus.CounterOpts{
                Name: "http_requests_total",
                Help: "Total number of HTTP requests",
            },
            []string{"method", "endpoint", "status"},
        ),
        
        httpRequestDuration: promauto.NewHistogramVec(
            prometheus.HistogramOpts{
                Name:    "http_request_duration_seconds",
                Help:    "HTTP request duration in seconds",
                Buckets: prometheus.DefBuckets,
            },
            []string{"method", "endpoint"},
        ),
        
        httpRequestsInFlight: promauto.NewGauge(
            prometheus.GaugeOpts{
                Name: "http_requests_in_flight",
                Help: "Current number of HTTP requests being processed",
            },
        ),
        
        activeUsers: promauto.NewGauge(
            prometheus.GaugeOpts{
                Name: "active_users_total",
                Help: "Current number of active users",
            },
        ),
        
        ordersProcessed: promauto.NewCounterVec(
            prometheus.CounterOpts{
                Name: "orders_processed_total",
                Help: "Total number of orders processed",
            },
            []string{"status", "payment_method"},
        ),
        
        cacheHits: promauto.NewCounterVec(
            prometheus.CounterOpts{
                Name: "cache_hits_total",
                Help: "Total number of cache hits",
            },
            []string{"cache_type"},
        ),
    }
}

func (m *Metrics) RecordHTTPRequest(method, endpoint, status string, duration time.Duration) {
    m.httpRequestsTotal.WithLabelValues(method, endpoint, status).Inc()
    m.httpRequestDuration.WithLabelValues(method, endpoint).Observe(duration.Seconds())
}

func (m *Metrics) IncHTTPRequestsInFlight() {
    m.httpRequestsInFlight.Inc()
}

func (m *Metrics) DecHTTPRequestsInFlight() {
    m.httpRequestsInFlight.Dec()
}

func (m *Metrics) SetActiveUsers(count float64) {
    m.activeUsers.Set(count)
}

func (m *Metrics) RecordOrderProcessed(status, paymentMethod string) {
    m.ordersProcessed.WithLabelValues(status, paymentMethod).Inc()
}

func (m *Metrics) RecordCacheHit(cacheType string) {
    m.cacheHits.WithLabelValues(cacheType).Inc()
}

// HTTP中间件
func MetricsMiddleware(metrics *Metrics) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()
            metrics.IncHTTPRequestsInFlight()
            defer metrics.DecHTTPRequestsInFlight()
            
            // 包装ResponseWriter以捕获状态码
            rw := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
            
            next.ServeHTTP(rw, r)
            
            duration := time.Since(start)
            status := http.StatusText(rw.statusCode)
            metrics.RecordHTTPRequest(r.Method, r.URL.Path, status, duration)
        })
    }
}

type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}

// 使用示例
func main() {
    metrics := NewMetrics()
    
    // 设置路由
    mux := http.NewServeMux()
    
    // 业务路由
    mux.HandleFunc("/api/users", func(w http.ResponseWriter, r *http.Request) {
        // 模拟业务逻辑
        time.Sleep(100 * time.Millisecond)
        w.Write([]byte("Users endpoint"))
    })
    
    mux.HandleFunc("/api/orders", func(w http.ResponseWriter, r *http.Request) {
        // 模拟订单处理
        metrics.RecordOrderProcessed("success", "credit_card")
        w.Write([]byte("Orders endpoint"))
    })
    
    // 指标端点
    mux.Handle("/metrics", promhttp.Handler())
    
    // 应用中间件
    handler := MetricsMiddleware(metrics)(mux)
    
    // 模拟业务指标更新
    go func() {
        ticker := time.NewTicker(5 * time.Second)
        defer ticker.Stop()
        
        for range ticker.C {
            // 模拟活跃用户数
            metrics.SetActiveUsers(1000 + float64(time.Now().Unix()%100))
            
            // 模拟缓存命中
            metrics.RecordCacheHit("redis")
        }
    }()
    
    // 启动服务器
    server := &http.Server{
        Addr:    ":8080",
        Handler: handler,
    }
    
    log.Println("服务器启动在 :8080")
    log.Println("指标端点: http://localhost:8080/metrics")
    log.Fatal(server.ListenAndServe())
}
```

### Jaeger分布式追踪

```go
package main

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "time"

    "github.com/opentracing/opentracing-go"
    "github.com/opentracing/opentracing-go/ext"
    "github.com/uber/jaeger-client-go"
    "github.com/uber/jaeger-client-go/config"
)

func initTracer() (opentracing.Tracer, error) {
    cfg := config.Configuration{
        ServiceName: "user-service",
        Sampler: &config.SamplerConfig{
            Type:  jaeger.SamplerTypeConst,
            Param: 1,
        },
        Reporter: &config.ReporterConfig{
            LogSpans:           true,
            LocalAgentHostPort: "localhost:6831",
        },
    }
    
    tracer, _, err := cfg.NewTracer()
    if err != nil {
        return nil, err
    }
    
    opentracing.SetGlobalTracer(tracer)
    return tracer, nil
}

func TracingMiddleware() func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // 从请求头中提取追踪信息
            spanCtx, _ := opentracing.GlobalTracer().Extract(
                opentracing.HTTPHeaders,
                opentracing.HTTPHeadersCarrier(r.Header),
            )
            
            // 创建新的span
            span := opentracing.GlobalTracer().StartSpan(
                r.Method+" "+r.URL.Path,
                ext.RPCServerOption(spanCtx),
                ext.SpanKindRPCServer,
            )
            defer span.Finish()
            
            // 设置span标签
            ext.HTTPMethod.Set(span, r.Method)
            ext.HTTPUrl.Set(span, r.URL.String())
            span.SetTag("component", "http")
            
            // 将span添加到上下文
            ctx := opentracing.ContextWithSpan(r.Context(), span)
            r = r.WithContext(ctx)
            
            // 包装ResponseWriter以捕获状态码
            rw := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
            
            next.ServeHTTP(rw, r)
            
            // 设置响应状态码
            ext.HTTPStatusCode.Set(span, uint16(rw.statusCode))
        })
    }
}

func callExternalService(ctx context.Context, serviceName, endpoint string) error {
    span, ctx := opentracing.StartSpanFromContext(ctx, "call_external_service")
    defer span.Finish()
    
    span.SetTag("service.name", serviceName)
    span.SetTag("service.endpoint", endpoint)
    
    // 模拟外部服务调用
    time.Sleep(50 * time.Millisecond)
    
    // 模拟偶尔的错误
    if time.Now().UnixNano()%10 == 0 {
        span.SetTag("error", true)
        return fmt.Errorf("external service error")
    }
    
    return nil
}

func databaseQuery(ctx context.Context, query string) error {
    span, ctx := opentracing.StartSpanFromContext(ctx, "database_query")
    defer span.Finish()
    
    span.SetTag("db.statement", query)
    span.SetTag("db.type", "postgresql")
    
    // 模拟数据库查询
    time.Sleep(30 * time.Millisecond)
    
    return nil
}

func getUserHandler(w http.ResponseWriter, r *http.Request) {
    span, ctx := opentracing.StartSpanFromContext(r.Context(), "get_user_handler")
    defer span.Finish()
    
    userID := r.URL.Query().Get("id")
    span.SetTag("user.id", userID)
    
    // 数据库查询
    if err := databaseQuery(ctx, "SELECT * FROM users WHERE id = ?"); err != nil {
        span.SetTag("error", true)
        http.Error(w, "Database error", http.StatusInternalServerError)
        return
    }
    
    // 调用外部服务
    if err := callExternalService(ctx, "notification-service", "/send-notification"); err != nil {
        span.SetTag("error", true)
        log.Printf("Notification service error: %v", err)
    }
    
    w.Write([]byte(fmt.Sprintf("User %s retrieved", userID)))
}

func createOrderHandler(w http.ResponseWriter, r *http.Request) {
    span, ctx := opentracing.StartSpanFromContext(r.Context(), "create_order_handler")
    defer span.Finish()
    
    // 模拟订单创建流程
    steps := []string{"validate_input", "check_inventory", "process_payment", "create_order"}
    
    for _, step := range steps {
        stepSpan, stepCtx := opentracing.StartSpanFromContext(ctx, step)
        
        // 模拟每个步骤的处理时间
        time.Sleep(time.Duration(20+time.Now().UnixNano()%30) * time.Millisecond)
        
        stepSpan.SetTag("step", step)
        stepSpan.Finish()
        
        ctx = stepCtx
    }
    
    w.Write([]byte("Order created successfully"))
}

// 使用示例
func main() {
    // 初始化追踪器
    tracer, err := initTracer()
    if err != nil {
        log.Fatal(err)
    }
    defer tracer.Close()
    
    // 设置路由
    mux := http.NewServeMux()
    mux.HandleFunc("/api/users", getUserHandler)
    mux.HandleFunc("/api/orders", createOrderHandler)
    
    // 应用追踪中间件
    handler := TracingMiddleware()(mux)
    
    // 启动服务器
    server := &http.Server{
        Addr:    ":8080",
        Handler: handler,
    }
    
    log.Println("服务器启动在 :8080")
    log.Println("Jaeger UI: http://localhost:16686")
    log.Fatal(server.ListenAndServe())
}
```

### 结构化日志

```go
package main

import (
    "context"
    "log"
    "net/http"
    "os"
    "time"

    "go.uber.org/zap"
    "go.uber.org/zap/zapcore"
)

type Logger struct {
    *zap.Logger
}

func NewLogger() *Logger {
    config := zap.NewProductionConfig()
    config.EncoderConfig.TimeKey = "timestamp"
    config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
    config.EncoderConfig.LevelKey = "level"
    config.EncoderConfig.MessageKey = "message"
    config.EncoderConfig.CallerKey = "caller"
    
    logger, err := config.Build()
    if err != nil {
        log.Fatal(err)
    }
    
    return &Logger{Logger: logger}
}

func (l *Logger) WithContext(ctx context.Context) *zap.Logger {
    // 从上下文获取追踪ID
    if traceID := ctx.Value("trace_id"); traceID != nil {
        return l.Logger.With(zap.String("trace_id", traceID.(string)))
    }
    return l.Logger
}

func (l *Logger) LogHTTPRequest(r *http.Request, statusCode int, duration time.Duration) {
    l.Info("HTTP request",
        zap.String("method", r.Method),
        zap.String("path", r.URL.Path),
        zap.String("query", r.URL.RawQuery),
        zap.String("user_agent", r.UserAgent()),
        zap.String("remote_addr", r.RemoteAddr),
        zap.Int("status_code", statusCode),
        zap.Duration("duration", duration),
    )
}

func (l *Logger) LogBusinessEvent(event string, fields ...zap.Field) {
    l.Info("Business event",
        append([]zap.Field{zap.String("event", event)}, fields...)...,
    )
}

func (l *Logger) LogError(err error, message string, fields ...zap.Field) {
    l.Error(message,
        append([]zap.Field{zap.Error(err)}, fields...)...,
    )
}

// 日志中间件
func LoggingMiddleware(logger *Logger) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()
            
            // 生成追踪ID
            traceID := generateTraceID()
            ctx := context.WithValue(r.Context(), "trace_id", traceID)
            r = r.WithContext(ctx)
            
            // 包装ResponseWriter
            rw := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
            
            next.ServeHTTP(rw, r)
            
            duration := time.Since(start)
            logger.LogHTTPRequest(r, rw.statusCode, duration)
        })
    }
}

func generateTraceID() string {
    return fmt.Sprintf("trace-%d", time.Now().UnixNano())
}

// 业务服务示例
type UserService struct {
    logger *Logger
}

func NewUserService(logger *Logger) *UserService {
    return &UserService{logger: logger}
}

func (s *UserService) GetUser(ctx context.Context, userID string) (*User, error) {
    logger := s.logger.WithContext(ctx)
    
    logger.Info("Getting user",
        zap.String("user_id", userID),
    )
    
    // 模拟数据库查询
    time.Sleep(100 * time.Millisecond)
    
    user := &User{
        ID:    userID,
        Name:  "John Doe",
        Email: "john@example.com",
    }
    
    logger.Info("User retrieved successfully",
        zap.String("user_id", userID),
        zap.String("user_name", user.Name),
    )
    
    return user, nil
}

func (s *UserService) CreateUser(ctx context.Context, user *User) error {
    logger := s.logger.WithContext(ctx)
    
    logger.Info("Creating user",
        zap.String("user_name", user.Name),
        zap.String("user_email", user.Email),
    )
    
    // 模拟创建用户
    time.Sleep(50 * time.Millisecond)
    
    logger.LogBusinessEvent("user_created",
        zap.String("user_id", user.ID),
        zap.String("user_name", user.Name),
    )
    
    return nil
}

type User struct {
    ID    string `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

// 使用示例
func main() {
    logger := NewLogger()
    defer logger.Sync()
    
    userService := NewUserService(logger)
    
    // 设置路由
    mux := http.NewServeMux()
    
    mux.HandleFunc("/api/users", func(w http.ResponseWriter, r *http.Request) {
        ctx := r.Context()
        
        if r.Method == "GET" {
            userID := r.URL.Query().Get("id")
            user, err := userService.GetUser(ctx, userID)
            if err != nil {
                logger.LogError(err, "Failed to get user",
                    zap.String("user_id", userID),
                )
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
            }
            
            w.Header().Set("Content-Type", "application/json")
            w.Write([]byte(fmt.Sprintf(`{"id":"%s","name":"%s","email":"%s"}`, 
                user.ID, user.Name, user.Email)))
        } else if r.Method == "POST" {
            user := &User{
                ID:    "123",
                Name:  "Jane Doe",
                Email: "jane@example.com",
            }
            
            if err := userService.CreateUser(ctx, user); err != nil {
                logger.LogError(err, "Failed to create user")
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
            }
            
            w.WriteHeader(http.StatusCreated)
            w.Write([]byte("User created"))
        }
    })
    
    // 应用日志中间件
    handler := LoggingMiddleware(logger)(mux)
    
    // 启动服务器
    server := &http.Server{
        Addr:    ":8080",
        Handler: handler,
    }
    
    logger.Info("Server starting",
        zap.String("addr", ":8080"),
    )
    
    log.Fatal(server.ListenAndServe())
}
```

### 健康检查与探针

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
    "net/http"
    "time"

    _ "github.com/lib/pq"
    "github.com/redis/go-redis/v9"
)

type HealthChecker struct {
    checks map[string]func() error
}

func NewHealthChecker() *HealthChecker {
    return &HealthChecker{
        checks: make(map[string]func() error),
    }
}

func (hc *HealthChecker) AddCheck(name string, check func() error) {
    hc.checks[name] = check
}

func (hc *HealthChecker) CheckHealth() map[string]error {
    results := make(map[string]error)
    
    for name, check := range hc.checks {
        results[name] = check()
    }
    
    return results
}

func (hc *HealthChecker) IsHealthy() bool {
    results := hc.CheckHealth()
    for _, err := range results {
        if err != nil {
            return false
        }
    }
    return true
}

func (hc *HealthChecker) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    results := hc.CheckHealth()
    
    w.Header().Set("Content-Type", "application/json")
    
    if hc.IsHealthy() {
        w.WriteHeader(http.StatusOK)
        fmt.Fprintf(w, `{"status":"healthy","checks":%v}`, results)
    } else {
        w.WriteHeader(http.StatusServiceUnavailable)
        fmt.Fprintf(w, `{"status":"unhealthy","checks":%v}`, results)
    }
}

// 数据库健康检查
func (hc *HealthChecker) AddDatabaseCheck(db *sql.DB) {
    hc.AddCheck("database", func() error {
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        
        if err := db.PingContext(ctx); err != nil {
            return fmt.Errorf("database ping failed: %w", err)
        }
        
        // 执行简单查询
        var result int
        if err := db.QueryRowContext(ctx, "SELECT 1").Scan(&result); err != nil {
            return fmt.Errorf("database query failed: %w", err)
        }
        
        return nil
    })
}

// Redis健康检查
func (hc *HealthChecker) AddRedisCheck(rdb *redis.Client) {
    hc.AddCheck("redis", func() error {
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        
        if err := rdb.Ping(ctx).Err(); err != nil {
            return fmt.Errorf("redis ping failed: %w", err)
        }
        
        return nil
    })
}

// 外部服务健康检查
func (hc *HealthChecker) AddExternalServiceCheck(name, url string) {
    hc.AddCheck(name, func() error {
        client := &http.Client{
            Timeout: 5 * time.Second,
        }
        
        resp, err := client.Get(url)
        if err != nil {
            return fmt.Errorf("external service %s check failed: %w", name, err)
        }
        defer resp.Body.Close()
        
        if resp.StatusCode >= 400 {
            return fmt.Errorf("external service %s returned status %d", name, resp.StatusCode)
        }
        
        return nil
    })
}

// 内存健康检查
func (hc *HealthChecker) AddMemoryCheck() {
    hc.AddCheck("memory", func() error {
        // 这里可以添加内存使用率检查
        // 示例：检查内存使用率是否超过阈值
        return nil
    })
}

// 磁盘健康检查
func (hc *HealthChecker) AddDiskCheck() {
    hc.AddCheck("disk", func() error {
        // 这里可以添加磁盘空间检查
        // 示例：检查磁盘使用率是否超过阈值
        return nil
    })
}

// 使用示例
func main() {
    checker := NewHealthChecker()
    
    // 添加各种健康检查
    checker.AddMemoryCheck()
    checker.AddDiskCheck()
    
    // 模拟数据库连接
    db, err := sql.Open("postgres", "user=postgres dbname=test sslmode=disable")
    if err == nil {
        checker.AddDatabaseCheck(db)
    }
    
    // 模拟Redis连接
    rdb := redis.NewClient(&redis.Options{
        Addr: "localhost:6379",
    })
    checker.AddRedisCheck(rdb)
    
    // 添加外部服务检查
    checker.AddExternalServiceCheck("payment-service", "http://localhost:8081/health")
    checker.AddExternalServiceCheck("notification-service", "http://localhost:8082/health")
    
    // 设置路由
    mux := http.NewServeMux()
    
    // 健康检查端点
    mux.Handle("/health", checker)
    
    // 就绪检查端点（更严格的检查）
    mux.HandleFunc("/ready", func(w http.ResponseWriter, r *http.Request) {
        // 只检查关键依赖
        criticalChecks := []string{"database", "redis"}
        allHealthy := true
        
        for _, checkName := range criticalChecks {
            if check, exists := checker.checks[checkName]; exists {
                if err := check(); err != nil {
                    allHealthy = false
                    break
                }
            }
        }
        
        if allHealthy {
            w.WriteHeader(http.StatusOK)
            w.Write([]byte("ready"))
        } else {
            w.WriteHeader(http.StatusServiceUnavailable)
            w.Write([]byte("not ready"))
        }
    })
    
    // 存活检查端点（最简单的检查）
    mux.HandleFunc("/live", func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("alive"))
    })
    
    // 业务路由
    mux.HandleFunc("/api/users", func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("Users endpoint"))
    })
    
    // 启动服务器
    server := &http.Server{
        Addr:    ":8080",
        Handler: mux,
    }
    
    log.Println("服务器启动在 :8080")
    log.Println("健康检查端点:")
    log.Println("  /health - 完整健康检查")
    log.Println("  /ready  - 就绪检查")
    log.Println("  /live   - 存活检查")
    
    log.Fatal(server.ListenAndServe())
}
```

## 🎯 最佳实践

1. **监控策略**
   - 使用RED和USE指标
   - 设置合理的告警阈值
   - 实现多级告警

2. **日志管理**
   - 使用结构化日志
   - 包含追踪ID
   - 设置日志级别

3. **追踪设计**
   - 在服务边界创建span
   - 添加有意义的标签
   - 控制采样率

4. **健康检查**
   - 区分liveness和readiness
   - 检查关键依赖
   - 设置合理的超时

## 🔍 常见问题

1. **监控数据过多**
   - 合理设置指标维度
   - 使用采样减少数据量
   - 定期清理历史数据

2. **告警风暴**
   - 设置告警抑制规则
   - 使用告警聚合
   - 分级告警处理

3. **追踪性能影响**
   - 控制采样率
   - 异步发送追踪数据
   - 优化span创建

4. **日志存储成本**
   - 设置日志保留策略
   - 使用日志压缩
   - 分级存储

## 📚 扩展阅读

- [Prometheus官方文档](https://prometheus.io/docs/)
- [Jaeger官方文档](https://www.jaegertracing.io/docs/)
- [Zap日志库](https://github.com/uber-go/zap)
- [可观测性最佳实践](https://sre.google/sre-book/monitoring-distributed-systems/)

## ✅ 落地检查清单

- 监控体系：RED/USE指标覆盖、告警规则、SLO定义
- 分布式追踪：采样策略、span标签、性能影响控制
- 结构化日志：日志格式、追踪ID、日志级别管理
- 健康检查：liveness/readiness区分、依赖检查、超时设置
- 告警管理：阈值设置、抑制规则、升级策略
- 存储管理：数据保留、压缩策略、成本控制

## 🧪 本地快速验证

1. 启动监控栈：
   - Prometheus: `prometheus --config.file=prometheus.yml`
   - Jaeger: `jaeger-all-in-one`
   - Grafana: `grafana-server`
2. 运行Prometheus指标收集示例，访问 `/metrics` 端点
3. 运行Jaeger分布式追踪示例，在Jaeger UI中查看追踪
4. 运行结构化日志示例，观察JSON格式日志输出
5. 运行健康检查示例，测试 `/health`、`/ready`、`/live` 端点
6. 使用压测工具验证监控数据的准确性

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025-10-29  
**文档状态**: 完成  
**适用版本**: Go 1.25.3+
