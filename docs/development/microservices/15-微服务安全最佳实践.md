# 15. ğŸ”’ å¾®æœåŠ¡å®‰å…¨æœ€ä½³å®è·µ

> ğŸ“š **ç®€ä»‹**ï¼šæœ¬æ–‡æ¡£å…¨é¢æ¢è®¨å¾®æœåŠ¡æ¶æ„ä¸­çš„å®‰å…¨å®è·µï¼Œæ¶µç›–è®¤è¯æˆæƒã€ç½‘ç»œå®‰å…¨ã€æ•°æ®åŠ å¯†ã€APIå®‰å…¨ã€å®¹å™¨å®‰å…¨å’Œå®‰å…¨å®¡è®¡ç­‰æ ¸å¿ƒä¸»é¢˜ã€‚é€šè¿‡æœ¬æ–‡ï¼Œè¯»è€…å°†æŒæ¡æ„å»ºå®‰å…¨å¯é å¾®æœåŠ¡ç³»ç»Ÿçš„å…³é”®æŠ€æœ¯å’Œæœ€ä½³å®è·µã€‚

## ğŸ“‹ ç›®å½•

- [15. ğŸ”’ å¾®æœåŠ¡å®‰å…¨æœ€ä½³å®è·µ](#15--å¾®æœåŠ¡å®‰å…¨æœ€ä½³å®è·µ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [15.1 ğŸ“š å®‰å…¨æ¶æ„æ¦‚è¿°](#151--å®‰å…¨æ¶æ„æ¦‚è¿°)
  - [15.2 ğŸ” è®¤è¯ä¸æˆæƒ](#152--è®¤è¯ä¸æˆæƒ)
    - [OAuth 2.0 + OpenID Connect](#oauth-20--openid-connect)
    - [RBACæƒé™æ§åˆ¶](#rbacæƒé™æ§åˆ¶)
    - [mTLSåŒå‘è®¤è¯](#mtlsåŒå‘è®¤è¯)
  - [15.3 ğŸŒ ç½‘ç»œå®‰å…¨](#153--ç½‘ç»œå®‰å…¨)
    - [Kubernetes NetworkPolicy](#kubernetes-networkpolicy)
    - [Istioæˆæƒç­–ç•¥](#istioæˆæƒç­–ç•¥)
  - [15.4 ğŸ”‘ å¯†é’¥ä¸Secretç®¡ç†](#154--å¯†é’¥ä¸secretç®¡ç†)
    - [HashiCorp Vaulté›†æˆ](#hashicorp-vaulté›†æˆ)
    - [Sealed Secrets](#sealed-secrets)
  - [15.5 ğŸ“¡ APIå®‰å…¨](#155--apiå®‰å…¨)
    - [è¾“å…¥éªŒè¯](#è¾“å…¥éªŒè¯)
    - [SQLæ³¨å…¥é˜²æŠ¤](#sqlæ³¨å…¥é˜²æŠ¤)
    - [XSSé˜²æŠ¤](#xssé˜²æŠ¤)
    - [CORSé…ç½®](#corsé…ç½®)
    - [Rate Limiting](#rate-limiting)
  - [15.6 ğŸ³ å®¹å™¨å®‰å…¨](#156--å®¹å™¨å®‰å…¨)
    - [Dockerfileå®‰å…¨å®è·µ](#dockerfileå®‰å…¨å®è·µ)
    - [Pod Security Standards](#pod-security-standards)
    - [é•œåƒæ‰«æ](#é•œåƒæ‰«æ)
  - [15.7 ğŸ“Š å®‰å…¨å®¡è®¡ä¸ç›‘æ§](#157--å®‰å…¨å®¡è®¡ä¸ç›‘æ§)
    - [Kuberneteså®¡è®¡æ—¥å¿—](#kuberneteså®¡è®¡æ—¥å¿—)
    - [Falcoå…¥ä¾µæ£€æµ‹](#falcoå…¥ä¾µæ£€æµ‹)
    - [å®‰å…¨äº‹ä»¶å‘Šè­¦](#å®‰å…¨äº‹ä»¶å‘Šè­¦)
  - [15.8 ğŸ›¡ï¸ é˜²æŠ¤æªæ–½](#158-ï¸-é˜²æŠ¤æªæ–½)
    - [DDoSé˜²æŠ¤](#ddosé˜²æŠ¤)
    - [WAFé›†æˆ](#wafé›†æˆ)
  - [15.9 ğŸ¯ æœ€ä½³å®è·µ](#159--æœ€ä½³å®è·µ)
  - [15.10 âš ï¸ å¸¸è§é—®é¢˜](#1510-ï¸-å¸¸è§é—®é¢˜)
    - [Q1: å¦‚ä½•é˜²æ­¢JWTè¢«ç›—ç”¨ï¼Ÿ](#q1-å¦‚ä½•é˜²æ­¢jwtè¢«ç›—ç”¨)
    - [Q2: æ•æ„Ÿæ•°æ®å¦‚ä½•è„±æ•ï¼Ÿ](#q2-æ•æ„Ÿæ•°æ®å¦‚ä½•è„±æ•)
    - [Q3: å¦‚ä½•é˜²æ­¢æš´åŠ›ç ´è§£ï¼Ÿ](#q3-å¦‚ä½•é˜²æ­¢æš´åŠ›ç ´è§£)
  - [15.11 ğŸ“š æ‰©å±•é˜…è¯»](#1511--æ‰©å±•é˜…è¯»)
    - [å®˜æ–¹æ–‡æ¡£](#å®˜æ–¹æ–‡æ¡£)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)

## 15.1 ğŸ“š å®‰å…¨æ¶æ„æ¦‚è¿°

**çºµæ·±é˜²å¾¡**: å¤šå±‚å®‰å…¨æªæ–½ï¼Œé¿å…å•ç‚¹å¤±è´¥ã€‚

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         è¾¹ç•Œå®‰å…¨                         â”‚
â”‚  WAF Â· DDoSé˜²æŠ¤ Â· å…¥ä¾µæ£€æµ‹              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ç½‘ç»œå®‰å…¨                         â”‚
â”‚  NetworkPolicy Â· Service Mesh Â· mTLS    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         åº”ç”¨å®‰å…¨                         â”‚
â”‚  è®¤è¯æˆæƒ Â· APIç½‘å…³ Â· é™æµ              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         æ•°æ®å®‰å…¨                         â”‚
â”‚  åŠ å¯†å­˜å‚¨ Â· ä¼ è¾“åŠ å¯† Â· æ•æ„Ÿæ•°æ®è„±æ•    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         åŸºç¡€è®¾æ–½å®‰å…¨                     â”‚
â”‚  RBAC Â· Pod Security Â· é•œåƒæ‰«æ         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**CIAä¸‰å…ƒç»„**:

- **Confidentialityï¼ˆæœºå¯†æ€§ï¼‰**: é˜²æ­¢æœªæˆæƒè®¿é—®
- **Integrityï¼ˆå®Œæ•´æ€§ï¼‰**: ç¡®ä¿æ•°æ®æœªè¢«ç¯¡æ”¹
- **Availabilityï¼ˆå¯ç”¨æ€§ï¼‰**: ç¡®ä¿æœåŠ¡æŒç»­å¯ç”¨

## 15.2 ğŸ” è®¤è¯ä¸æˆæƒ

### OAuth 2.0 + OpenID Connect

**Goå®ç°OAuth2æœåŠ¡å™¨**:

```go
package main

import (
    "github.com/go-oauth2/oauth2/v4/server"
    "github.com/go-oauth2/oauth2/v4/manage"
    "github.com/go-oauth2/oauth2/v4/store"
    "github.com/golang-jwt/jwt/v4"
)

func SetupOAuth2Server() *server.Server {
    manager := manage.NewDefaultManager()
    manager.MustTokenStorage(store.NewMemoryTokenStore())

    // é…ç½®JWTè®¿é—®Token
    manager.MapAccessGenerate(jwt.NewJWT())

    srv := server.NewDefaultServer(manager)
    srv.SetAllowGetAccessRequest(true)
    srv.SetClientInfoHandler(server.ClientFormHandler)

    return srv
}
```

**å®¢æˆ·ç«¯éªŒè¯**:

```go
import (
    "github.com/golang-jwt/jwt/v4"
)

type Claims struct {
    UserID string   `json:"user_id"`
    Roles  []string `json:"roles"`
    jwt.RegisteredClaims
}

func ValidateToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        return []byte(os.Getenv("JWT_SECRET")), nil
    })

    if err != nil {
        return nil, err
    }

    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }

    return nil, errors.New("invalid token")
}

// ä¸­é—´ä»¶
func AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(401, gin.H{"error": "missing authorization header"})
            c.Abort()
            return
        }

        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
        claims, err := ValidateToken(tokenString)
        if err != nil {
            c.JSON(401, gin.H{"error": "invalid token"})
            c.Abort()
            return
        }

        c.Set("user_id", claims.UserID)
        c.Set("roles", claims.Roles)
        c.Next()
    }
}
```

### RBACæƒé™æ§åˆ¶

```go
type Permission string

const (
    PermUserRead   Permission = "user:read"
    PermUserWrite  Permission = "user:write"
    PermOrderRead  Permission = "order:read"
    PermOrderWrite Permission = "order:write"
)

type Role struct {
    Name        string
    Permissions []Permission
}

var roles = map[string]*Role{
    "admin": {
        Name: "admin",
        Permissions: []Permission{
            PermUserRead, PermUserWrite,
            PermOrderRead, PermOrderWrite,
        },
    },
    "user": {
        Name: "user",
        Permissions: []Permission{
            PermUserRead, PermOrderRead,
        },
    },
}

func RequirePermission(perm Permission) gin.HandlerFunc {
    return func(c *gin.Context) {
        userRoles := c.GetStringSlice("roles")

        for _, roleName := range userRoles {
            if role, ok := roles[roleName]; ok {
                for _, p := range role.Permissions {
                    if p == perm {
                        c.Next()
                        return
                    }
                }
            }
        }

        c.JSON(403, gin.H{"error": "insufficient permissions"})
        c.Abort()
    }
}

// ä½¿ç”¨
r.GET("/api/users", AuthMiddleware(), RequirePermission(PermUserRead), getUsersHandler)
r.POST("/api/users", AuthMiddleware(), RequirePermission(PermUserWrite), createUserHandler)
```

### mTLSåŒå‘è®¤è¯

**ç”Ÿæˆè¯ä¹¦**:

```bash
# CAè¯ä¹¦
openssl req -x509 -newkey rsa:4096 -days 365 -nodes \
  -keyout ca-key.pem -out ca-cert.pem \
  -subj "/CN=My CA"

# æœåŠ¡å™¨è¯ä¹¦
openssl req -newkey rsa:4096 -nodes \
  -keyout server-key.pem -out server-req.pem \
  -subj "/CN=localhost"

openssl x509 -req -in server-req.pem -days 60 \
  -CA ca-cert.pem -CAkey ca-key.pem -CAcreateserial \
  -out server-cert.pem

# å®¢æˆ·ç«¯è¯ä¹¦
openssl req -newkey rsa:4096 -nodes \
  -keyout client-key.pem -out client-req.pem \
  -subj "/CN=client"

openssl x509 -req -in client-req.pem -days 60 \
  -CA ca-cert.pem -CAkey ca-key.pem -CAcreateserial \
  -out client-cert.pem
```

**GoæœåŠ¡å™¨mTLS**:

```go
import (
    "crypto/tls"
    "crypto/x509"
)

func StartTLSServer() {
    // åŠ è½½æœåŠ¡å™¨è¯ä¹¦
    serverCert, err := tls.LoadX509KeyPair("server-cert.pem", "server-key.pem")
    if err != nil {
        log.Fatal(err)
    }

    // åŠ è½½CAè¯ä¹¦ï¼ˆç”¨äºéªŒè¯å®¢æˆ·ç«¯ï¼‰
    caCert, err := os.ReadFile("ca-cert.pem")
    if err != nil {
        log.Fatal(err)
    }

    caCertPool := x509.NewCertPool()
    caCertPool.AppendCertsFromPEM(caCert)

    tlsConfig := &tls.Config{
        Certificates: []tls.Certificate{serverCert},
        ClientAuth:   tls.RequireAndVerifyClientCert,
        ClientCAs:    caCertPool,
        MinVersion:   tls.VersionTLS13,
    }

    server := &http.Server{
        Addr:      ":8443",
        TLSConfig: tlsConfig,
    }

    log.Fatal(server.ListenAndServeTLS("", ""))
}
```

## 15.3 ğŸŒ ç½‘ç»œå®‰å…¨

### Kubernetes NetworkPolicy

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: user-service-policy
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: user-service
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: production
    - podSelector:
        matchLabels:
          app: api-gateway
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: database
    ports:
    - protocol: TCP
      port: 3306
  - to:
    - namespaceSelector:
        matchLabels:
          name: kube-system
    ports:
    - protocol: TCP
      port: 53  # DNS
```

### Istioæˆæƒç­–ç•¥

```yaml
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: user-service-authz
  namespace: production
spec:
  selector:
    matchLabels:
      app: user-service
  action: ALLOW
  rules:
  - from:
    - source:
        principals: ["cluster.local/ns/production/sa/api-gateway"]
    to:
    - operation:
        methods: ["GET", "POST"]
        paths: ["/api/users/*"]
    when:
    - key: request.auth.claims[role]
      values: ["admin", "user"]
```

## 15.4 ğŸ”‘ å¯†é’¥ä¸Secretç®¡ç†

### HashiCorp Vaulté›†æˆ

```go
package main

import (
    vault "github.com/hashicorp/vault/api"
)

type VaultClient struct {
    client *vault.Client
}

func NewVaultClient(address, token string) (*VaultClient, error) {
    config := vault.DefaultConfig()
    config.Address = address

    client, err := vault.NewClient(config)
    if err != nil {
        return nil, err
    }

    client.SetToken(token)

    return &VaultClient{client: client}, nil
}

func (vc *VaultClient) GetSecret(path string) (map[string]interface{}, error) {
    secret, err := vc.client.Logical().Read(path)
    if err != nil {
        return nil, err
    }

    if secret == nil {
        return nil, errors.New("secret not found")
    }

    return secret.Data, nil
}

// ä½¿ç”¨
func main() {
    vaultClient, _ := NewVaultClient("https://vault.example.com", os.Getenv("VAULT_TOKEN"))

    secrets, _ := vaultClient.GetSecret("secret/data/database")
    dbPassword := secrets["data"].(map[string]interface{})["password"].(string)

    // ä½¿ç”¨å¯†ç è¿æ¥æ•°æ®åº“
    db, _ := sql.Open("mysql", fmt.Sprintf("user:root@tcp(localhost:3306)/mydb?password=%s", dbPassword))
}
```

### Sealed Secrets

```yaml
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: db-credentials
  namespace: production
spec:
  encryptedData:
    password: AgBvXk5...encrypted...
    username: AgCqRt...encrypted...
  template:
    metadata:
      name: db-credentials
      namespace: production
    type: Opaque
```

## 15.5 ğŸ“¡ APIå®‰å…¨

### è¾“å…¥éªŒè¯

```go
import "github.com/go-playground/validator/v10"

type CreateUserRequest struct {
    Username string `json:"username" validate:"required,min=3,max=20,alphanum"`
    Email    string `json:"email" validate:"required,email"`
    Password string `json:"password" validate:"required,min=8,containsany=!@#$%^&*"`
    Age      int    `json:"age" validate:"required,gte=18,lte=120"`
}

var validate = validator.New()

func createUserHandler(c *gin.Context) {
    var req CreateUserRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": "invalid JSON"})
        return
    }

    if err := validate.Struct(req); err != nil {
        errors := err.(validator.ValidationErrors)
        c.JSON(400, gin.H{"errors": errors.Error()})
        return
    }

    // åˆ›å»ºç”¨æˆ·...
}
```

### SQLæ³¨å…¥é˜²æŠ¤

```go
// âŒ ä¸å®‰å…¨çš„å†™æ³•
func getUserByID(id string) (*User, error) {
    query := fmt.Sprintf("SELECT * FROM users WHERE id = '%s'", id) // SQLæ³¨å…¥é£é™©ï¼
    row := db.QueryRow(query)
    // ...
}

// âœ… å®‰å…¨çš„å†™æ³•
func getUserByID(id string) (*User, error) {
    query := "SELECT * FROM users WHERE id = ?"
    row := db.QueryRow(query, id) // ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
    // ...
}
```

### XSSé˜²æŠ¤

```go
import "html"

func sanitizeInput(input string) string {
    return html.EscapeString(input)
}

func createCommentHandler(c *gin.Context) {
    var req struct {
        Content string `json:"content"`
    }
    c.ShouldBindJSON(&req)

    // æ¸…ç†è¾“å…¥
    sanitizedContent := sanitizeInput(req.Content)

    // å­˜å‚¨åˆ°æ•°æ®åº“
    saveComment(sanitizedContent)
}
```

### CORSé…ç½®

```go
import "github.com/gin-contrib/cors"

func main() {
    r := gin.Default()

    // CORSä¸­é—´ä»¶
    r.Use(cors.New(cors.Config{
        AllowOrigins:     []string{"https://trusted-domain.com"},
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE"},
        AllowHeaders:     []string{"Origin", "Content-Type", "Authorization"},
        ExposeHeaders:    []string{"Content-Length"},
        AllowCredentials: true,
        MaxAge:           12 * time.Hour,
    }))

    r.Run(":8080")
}
```

### Rate Limiting

```go
import "golang.org/x/time/rate"

type IPRateLimiter struct {
    limiters map[string]*rate.Limiter
    mu       sync.RWMutex
    r        rate.Limit
    b        int
}

func NewIPRateLimiter(r rate.Limit, b int) *IPRateLimiter {
    return &IPRateLimiter{
        limiters: make(map[string]*rate.Limiter),
        r:        r,
        b:        b,
    }
}

func (i *IPRateLimiter) GetLimiter(ip string) *rate.Limiter {
    i.mu.Lock()
    defer i.mu.Unlock()

    limiter, exists := i.limiters[ip]
    if !exists {
        limiter = rate.NewLimiter(i.r, i.b)
        i.limiters[ip] = limiter
    }

    return limiter
}

func RateLimitMiddleware(limiter *IPRateLimiter) gin.HandlerFunc {
    return func(c *gin.Context) {
        ip := c.ClientIP()
        l := limiter.GetLimiter(ip)

        if !l.Allow() {
            c.JSON(429, gin.H{"error": "too many requests"})
            c.Abort()
            return
        }

        c.Next()
    }
}
```

## 15.6 ğŸ³ å®¹å™¨å®‰å…¨

### Dockerfileå®‰å…¨å®è·µ

```dockerfile
# ä½¿ç”¨å®˜æ–¹é•œåƒ
FROM golang:1.21-alpine AS builder

# è¿è¡Œä¸ºérootç”¨æˆ·
RUN adduser -D appuser

# å®‰å…¨çš„ä¾èµ–ä¸‹è½½
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download && go mod verify

COPY . .
RUN CGO_ENABLED=0 go build -ldflags="-s -w" -o main .

# æœ€å°è¿è¡Œé•œåƒ
FROM scratch

# å¤åˆ¶CAè¯ä¹¦
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

# å¤åˆ¶passwd
COPY --from=builder /etc/passwd /etc/passwd

# å¤åˆ¶äºŒè¿›åˆ¶æ–‡ä»¶
COPY --from=builder /app/main /main

# åˆ‡æ¢åˆ°érootç”¨æˆ·
USER appuser

EXPOSE 8080
ENTRYPOINT ["/main"]
```

### Pod Security Standards

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secure-pod
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 2000
    seccompProfile:
      type: RuntimeDefault
  containers:
  - name: app
    image: myapp:latest
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      capabilities:
        drop:
        - ALL
        add:
        - NET_BIND_SERVICE
    volumeMounts:
    - name: tmp
      mountPath: /tmp
  volumes:
  - name: tmp
    emptyDir: {}
```

### é•œåƒæ‰«æ

```yaml
# Trivyæ‰«æ
apiVersion: batch/v1
kind: CronJob
metadata:
  name: image-scanner
spec:
  schedule: "0 2 * * *"
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: trivy
            image: aquasec/trivy:latest
            command:
            - trivy
            - image
            - --severity
            - HIGH,CRITICAL
            - myregistry/user-service:latest
          restartPolicy: OnFailure
```

## 15.7 ğŸ“Š å®‰å…¨å®¡è®¡ä¸ç›‘æ§

### Kuberneteså®¡è®¡æ—¥å¿—

```yaml
apiVersion: audit.k8s.io/v1
kind: Policy
rules:
- level: RequestResponse
  verbs: ["create", "update", "patch", "delete"]
  resources:
  - group: ""
    resources: ["secrets", "configmaps"]
- level: Metadata
  omitStages:
  - RequestReceived
```

### Falcoå…¥ä¾µæ£€æµ‹

```yaml
# Falcoè§„åˆ™
- rule: Unauthorized Process
  desc: Detect unauthorized process in container
  condition: >
    spawned_process and
    container and
    not proc.name in (allowed_processes)
  output: >
    Unauthorized process started
    (user=%user.name command=%proc.cmdline container=%container.id)
  priority: WARNING
```

### å®‰å…¨äº‹ä»¶å‘Šè­¦

```go
type SecurityEvent struct {
    Timestamp time.Time
    Type      string
    Severity  string
    Message   string
    UserID    string
    IP        string
}

func LogSecurityEvent(event SecurityEvent) {
    log.WithFields(logrus.Fields{
        "type":     event.Type,
        "severity": event.Severity,
        "user_id":  event.UserID,
        "ip":       event.IP,
    }).Warn(event.Message)

    // å‘é€åˆ°SIEMç³»ç»Ÿ
    if event.Severity == "CRITICAL" {
        sendToSIEM(event)
        alertSecurityTeam(event)
    }
}

// ä½¿ç”¨
func loginHandler(c *gin.Context) {
    // ...éªŒè¯å¤±è´¥
    LogSecurityEvent(SecurityEvent{
        Timestamp: time.Now(),
        Type:      "AUTH_FAILED",
        Severity:  "WARNING",
        Message:   "Failed login attempt",
        UserID:    username,
        IP:        c.ClientIP(),
    })
}
```

## 15.8 ğŸ›¡ï¸ é˜²æŠ¤æªæ–½

### DDoSé˜²æŠ¤

**é™æµç­–ç•¥**:

```go
// åˆ†å¸ƒå¼é™æµï¼ˆRedisï¼‰
import "github.com/go-redis/redis_rate/v10"

func DistributedRateLimit(ctx context.Context, key string) bool {
    res, err := limiter.Allow(ctx, key, redis_rate.PerMinute(100))
    return err == nil && res.Allowed > 0
}
```

### WAFé›†æˆ

**OWASP ModSecurityè§„åˆ™**:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: api-ingress
  annotations:
    nginx.ingress.kubernetes.io/enable-modsecurity: "true"
    nginx.ingress.kubernetes.io/enable-owasp-core-rules: "true"
    nginx.ingress.kubernetes.io/modsecurity-snippet: |
      SecRuleEngine On
      SecRule REQUEST_URI "@contains /admin" "id:1,deny,status:403"
```

## 15.9 ğŸ¯ æœ€ä½³å®è·µ

1. **æœ€å°æƒé™åŸåˆ™**: æˆäºˆæœ€å°å¿…è¦æƒé™
2. **é»˜è®¤æ‹’ç»**: ç™½åå•æ¨¡å¼ï¼Œé»˜è®¤æ‹’ç»è®¿é—®
3. **æ·±åº¦é˜²å¾¡**: å¤šå±‚å®‰å…¨æªæ–½
4. **åŠ å¯†ä¼ è¾“**: æ‰€æœ‰é€šä¿¡å¯ç”¨TLS
5. **æ•æ„Ÿæ•°æ®åŠ å¯†**: é™æ€æ•°æ®åŠ å¯†å­˜å‚¨
6. **å®šæœŸæ›´æ–°**: åŠæ—¶æ‰“å®‰å…¨è¡¥ä¸
7. **å®‰å…¨å®¡è®¡**: è®°å½•å’Œç›‘æ§å®‰å…¨äº‹ä»¶
8. **è¾“å…¥éªŒè¯**: éªŒè¯æ‰€æœ‰å¤–éƒ¨è¾“å…¥
9. **å®‰å…¨ç¼–ç **: éµå¾ªå®‰å…¨ç¼–ç è§„èŒƒ
10. **å®šæœŸæ¼”ç»ƒ**: è¿›è¡Œå®‰å…¨æ¸—é€æµ‹è¯•

## 15.10 âš ï¸ å¸¸è§é—®é¢˜

### Q1: å¦‚ä½•é˜²æ­¢JWTè¢«ç›—ç”¨ï¼Ÿ

**A**:

- ä½¿ç”¨çŸ­æœŸToken + Refresh Token
- å¯ç”¨Tokené»‘åå•
- ç»‘å®šè®¾å¤‡æŒ‡çº¹
- ç›‘æ§å¼‚å¸¸ç™»å½•

### Q2: æ•æ„Ÿæ•°æ®å¦‚ä½•è„±æ•ï¼Ÿ

**A**:

```go
func MaskEmail(email string) string {
    parts := strings.Split(email, "@")
    if len(parts) != 2 {
        return "***"
    }
    return parts[0][:2] + "***@" + parts[1]
}

func MaskPhone(phone string) string {
    if len(phone) < 11 {
        return "***"
    }
    return phone[:3] + "****" + phone[7:]
}
```

### Q3: å¦‚ä½•é˜²æ­¢æš´åŠ›ç ´è§£ï¼Ÿ

**A**:

- é™åˆ¶ç™»å½•å°è¯•æ¬¡æ•°
- è´¦æˆ·é”å®šæœºåˆ¶
- CAPTCHAéªŒè¯
- å»¶è¿Ÿå“åº”

## 15.11 ğŸ“š æ‰©å±•é˜…è¯»

### å®˜æ–¹æ–‡æ¡£

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [Kuberneteså®‰å…¨](https://kubernetes.io/docs/concepts/security/)
- [Istioå®‰å…¨](https://istio.io/latest/docs/concepts/security/)

### ç›¸å…³æ–‡æ¡£

- [10-é«˜æ€§èƒ½å¾®æœåŠ¡æ¶æ„.md](./10-é«˜æ€§èƒ½å¾®æœåŠ¡æ¶æ„.md)
- [11-Kuberneteså¾®æœåŠ¡éƒ¨ç½².md](./11-Kuberneteså¾®æœåŠ¡éƒ¨ç½².md)
- [../03-Webå¼€å‘/00-Goè®¤è¯ä¸æˆæƒæ·±åº¦å®æˆ˜æŒ‡å—.md](../03-Webå¼€å‘/00-Goè®¤è¯ä¸æˆæƒæ·±åº¦å®æˆ˜æŒ‡å—.md)

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team
**æœ€åæ›´æ–°**: 2025-10-29
**æ–‡æ¡£çŠ¶æ€**: å®Œæˆ
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+, Kubernetes 1.27+
