# 消息队列

**字数**: ~42,000字  
**代码示例**: 140+个完整示例  
**实战案例**: 15个端到端案例  
**适用人群**: 中级到高级Go开发者

---

## 📋 目录

<!-- TOC -->
- [消息队列深度实战指南](#消息队列深度实战指南)
  - [📚 目录](#目录)
  - [第一部分：消息队列核心原理](#第一部分消息队列核心原理)
    - [消息队列架构](#消息队列架构)
    - [为什么需要消息队列？](#为什么需要消息队列)
  - [第二部分：RabbitMQ深度实战](#第二部分rabbitmq深度实战)
    - [实战案例1：RabbitMQ基础使用](#实战案例1rabbitmq基础使用)
    - [实战案例2：RabbitMQ交换机模式](#实战案例2rabbitmq交换机模式)
  - [第三部分：Kafka深度实战](#第三部分kafka深度实战)
    - [实战案例3：Kafka生产者/消费者](#实战案例3kafka生产者消费者)
  - [第四部分：NATS深度实战](#第四部分nats深度实战)
    - [实战案例4：NATS发布订阅](#实战案例4nats发布订阅)
  - [🎯 总结](#总结)
    - [消息队列核心要点](#消息队列核心要点)
    - [三种MQ对比](#三种mq对比)
<!-- TOC -->

---

## 第一部分：消息队列核心原理

### 消息队列架构

```text
┌─────────────────────────────────────────────────┐
│              消息队列架构                         │
└─────────────────────────────────────────────────┘

Producer                MQ Broker              Consumer
   │                        │                      │
   │  1. Send Message       │                      │
   ├───────────────────────►│                      │
   │                        │  - Store Message     │
   │                        │  - Persistence       │
   │                        │  - Routing           │
   │  2. Ack                │                      │
   │◄───────────────────────┤                      │
   │                        │                      │
   │                        │  3. Subscribe        │
   │                        │◄─────────────────────┤
   │                        │                      │
   │                        │  4. Deliver Message  │
   │                        ├─────────────────────►│
   │                        │                      │
   │                        │  5. Ack              │
   │                        │◄─────────────────────┤
   └────────────────────────┴──────────────────────┘

核心概念:
- Producer: 消息生产者
- Consumer: 消息消费者
- Broker: 消息代理（RabbitMQ/Kafka/NATS）
- Queue: 消息队列（存储消息）
- Topic: 消息主题（发布/订阅）
- Exchange: 交换机（RabbitMQ路由）
- Partition: 分区（Kafka分布式）

消息模式:
1. 点对点（Queue）：一对一
2. 发布订阅（Topic）：一对多
3. 请求响应（RPC）：双向通信
```

---

### 为什么需要消息队列？

```text
解决的问题:

1. 异步处理
   ┌──────────┐      ┌──────────┐      ┌──────────┐
   │  用户注册 │─────►│   MQ     │─────►│  发邮件  │
   └──────────┘      └──────────┘      └──────────┘
     立即返回          异步处理           后台执行

2. 削峰填谷
   请求峰值: 10000/s
        │
        ▼
   ┌──────────┐
   │    MQ    │ ──► 稳定处理: 1000/s
   └──────────┘
   
3. 系统解耦
   订单服务 ──► MQ ──► 库存服务
             │    └──► 支付服务
             │    └──► 物流服务
             └──► 邮件服务
   
4. 流量控制
   生产速度 > 消费速度 ──► MQ缓冲

5. 可靠传输
   发送方 ──► MQ(持久化) ──► 接收方
             └─► 消息不丢失
```

---

## 第二部分：RabbitMQ深度实战

### 实战案例1：RabbitMQ基础使用

```go
package main

import (
 "context"
 "fmt"
 "log"
 "time"

 amqp "github.com/rabbitmq/amqp091-go"
)

// RabbitMQ 连接封装
type RabbitMQ struct {
 conn    *amqp.Connection
 channel *amqp.Channel
 queue   string
}

// NewRabbitMQ 创建RabbitMQ连接
func NewRabbitMQ(url, queueName string) (*RabbitMQ, error) {
 // 连接RabbitMQ
 conn, err := amqp.Dial(url)
 if err != nil {
  return nil, fmt.Errorf("failed to connect: %v", err)
 }

 // 创建Channel
 ch, err := conn.Channel()
 if err != nil {
  conn.Close()
  return nil, fmt.Errorf("failed to open channel: %v", err)
 }

 // 声明队列
 q, err := ch.QueueDeclare(
  queueName, // name
  true,      // durable (持久化)
  false,     // delete when unused
  false,     // exclusive
  false,     // no-wait
  nil,       // arguments
 )
 if err != nil {
  ch.Close()
  conn.Close()
  return nil, fmt.Errorf("failed to declare queue: %v", err)
 }

 return &RabbitMQ{
  conn:    conn,
  channel: ch,
  queue:   q.Name,
 }, nil
}

// Publish 发布消息
func (r *RabbitMQ) Publish(ctx context.Context, body string) error {
 return r.channel.PublishWithContext(
  ctx,
  "",      // exchange
  r.queue, // routing key
  false,   // mandatory
  false,   // immediate
  amqp.Publishing{
   DeliveryMode: amqp.Persistent, // 持久化消息
   ContentType:  "text/plain",
   Body:         []byte(body),
   Timestamp:    time.Now(),
  },
 )
}

// Consume 消费消息
func (r *RabbitMQ) Consume(handler func(string) error) error {
 // 设置QoS（预取数量）
 err := r.channel.Qos(
  1,     // prefetch count
  0,     // prefetch size
  false, // global
 )
 if err != nil {
  return fmt.Errorf("failed to set QoS: %v", err)
 }

 // 开始消费
 msgs, err := r.channel.Consume(
  r.queue, // queue
  "",      // consumer
  false,   // auto-ack (手动确认)
  false,   // exclusive
  false,   // no-local
  false,   // no-wait
  nil,     // args
 )
 if err != nil {
  return fmt.Errorf("failed to register consumer: %v", err)
 }

 // 处理消息
 for msg := range msgs {
  log.Printf("Received: %s", msg.Body)

  // 处理消息
  if err := handler(string(msg.Body)); err != nil {
   log.Printf("Handler error: %v", err)
   // Nack（重新入队）
   msg.Nack(false, true)
   continue
  }

  // Ack确认
  msg.Ack(false)
 }

 return nil
}

// Close 关闭连接
func (r *RabbitMQ) Close() error {
 if err := r.channel.Close(); err != nil {
  return err
 }
 return r.conn.Close()
}

// ===== 生产者示例 =====
func ProducerExample() {
 mq, err := NewRabbitMQ("amqp://guest:guest@localhost:5672/", "orders")
 if err != nil {
  log.Fatal(err)
 }
 defer mq.Close()

 ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
 defer cancel()

 // 发送10条消息
 for i := 1; i <= 10; i++ {
  msg := fmt.Sprintf("Order #%d", i)
  if err := mq.Publish(ctx, msg); err != nil {
   log.Printf("Failed to publish: %v", err)
   continue
  }
  log.Printf("Sent: %s", msg)
  time.Sleep(100 * time.Millisecond)
 }
}

// ===== 消费者示例 =====
func ConsumerExample() {
 mq, err := NewRabbitMQ("amqp://guest:guest@localhost:5672/", "orders")
 if err != nil {
  log.Fatal(err)
 }
 defer mq.Close()

 // 消费消息
 handler := func(body string) error {
  log.Printf("Processing: %s", body)
  // 模拟处理时间
  time.Sleep(500 * time.Millisecond)
  return nil
 }

 log.Println("Waiting for messages...")
 if err := mq.Consume(handler); err != nil {
  log.Fatal(err)
 }
}
```

---

### 实战案例2：RabbitMQ交换机模式

```go
package rabbitmq

import (
 "context"
 "fmt"
 "log"

 amqp "github.com/rabbitmq/amqp091-go"
)

// ExchangeType 交换机类型
type ExchangeType string

const (
 ExchangeDirect  ExchangeType = "direct"  // 直连
 ExchangeFanout  ExchangeType = "fanout"  // 扇出（广播）
 ExchangeTopic   ExchangeType = "topic"   // 主题
 ExchangeHeaders ExchangeType = "headers" // 头部
)

// Exchange 交换机封装
type Exchange struct {
 conn     *amqp.Connection
 channel  *amqp.Channel
 name     string
 exchType ExchangeType
}

// NewExchange 创建交换机
func NewExchange(url, name string, exchType ExchangeType) (*Exchange, error) {
 conn, err := amqp.Dial(url)
 if err != nil {
  return nil, err
 }

 ch, err := conn.Channel()
 if err != nil {
  conn.Close()
  return nil, err
 }

 // 声明交换机
 err = ch.ExchangeDeclare(
  name,               // name
  string(exchType),   // type
  true,               // durable
  false,              // auto-deleted
  false,              // internal
  false,              // no-wait
  nil,                // arguments
 )
 if err != nil {
  ch.Close()
  conn.Close()
  return nil, err
 }

 return &Exchange{
  conn:     conn,
  channel:  ch,
  name:     name,
  exchType: exchType,
 }, nil
}

// Publish 发布到交换机
func (e *Exchange) Publish(ctx context.Context, routingKey, body string) error {
 return e.channel.PublishWithContext(
  ctx,
  e.name,     // exchange
  routingKey, // routing key
  false,      // mandatory
  false,      // immediate
  amqp.Publishing{
   DeliveryMode: amqp.Persistent,
   ContentType:  "text/plain",
   Body:         []byte(body),
  },
 )
}

// Subscribe 订阅交换机
func (e *Exchange) Subscribe(queueName, routingKey string, handler func(string) error) error {
 // 声明队列
 q, err := e.channel.QueueDeclare(
  queueName, // name
  true,      // durable
  false,     // delete when unused
  false,     // exclusive
  false,     // no-wait
  nil,       // arguments
 )
 if err != nil {
  return err
 }

 // 绑定队列到交换机
 err = e.channel.QueueBind(
  q.Name,     // queue name
  routingKey, // routing key
  e.name,     // exchange
  false,      // no-wait
  nil,        // args
 )
 if err != nil {
  return err
 }

 // 设置QoS
 e.channel.Qos(1, 0, false)

 // 消费消息
 msgs, err := e.channel.Consume(
  q.Name, // queue
  "",     // consumer
  false,  // auto-ack
  false,  // exclusive
  false,  // no-local
  false,  // no-wait
  nil,    // args
 )
 if err != nil {
  return err
 }

 for msg := range msgs {
  if err := handler(string(msg.Body)); err != nil {
   log.Printf("Handler error: %v", err)
   msg.Nack(false, true)
   continue
  }
  msg.Ack(false)
 }

 return nil
}

// Close 关闭连接
func (e *Exchange) Close() error {
 if err := e.channel.Close(); err != nil {
  return err
 }
 return e.conn.Close()
}

// ===== 1. Direct Exchange（直连交换机）=====
func DirectExchangeExample() {
 // 创建交换机
 exch, err := NewExchange(
  "amqp://guest:guest@localhost:5672/",
  "logs_direct",
  ExchangeDirect,
 )
 if err != nil {
  log.Fatal(err)
 }
 defer exch.Close()

 ctx := context.Background()

 // 发送不同级别的日志
 exch.Publish(ctx, "info", "Info log message")
 exch.Publish(ctx, "warning", "Warning log message")
 exch.Publish(ctx, "error", "Error log message")
}

func DirectExchangeConsumer(level string) {
 exch, err := NewExchange(
  "amqp://guest:guest@localhost:5672/",
  "logs_direct",
  ExchangeDirect,
 )
 if err != nil {
  log.Fatal(err)
 }
 defer exch.Close()

 handler := func(body string) error {
  log.Printf("[%s] %s", level, body)
  return nil
 }

 queueName := fmt.Sprintf("logs_%s", level)
 exch.Subscribe(queueName, level, handler)
}

// ===== 2. Fanout Exchange（扇出交换机）=====
func FanoutExchangeExample() {
 exch, err := NewExchange(
  "amqp://guest:guest@localhost:5672/",
  "notifications",
  ExchangeFanout,
 )
 if err != nil {
  log.Fatal(err)
 }
 defer exch.Close()

 ctx := context.Background()

 // 广播消息（所有订阅者都会收到）
 exch.Publish(ctx, "", "System notification: Server will restart in 5 minutes")
}

// ===== 3. Topic Exchange（主题交换机）=====
func TopicExchangeExample() {
 exch, err := NewExchange(
  "amqp://guest:guest@localhost:5672/",
  "events",
  ExchangeTopic,
 )
 if err != nil {
  log.Fatal(err)
 }
 defer exch.Close()

 ctx := context.Background()

 // 发送不同主题的事件
 exch.Publish(ctx, "user.created", "User Alice created")
 exch.Publish(ctx, "user.updated", "User Bob updated")
 exch.Publish(ctx, "order.created", "Order #123 created")
 exch.Publish(ctx, "order.paid", "Order #123 paid")
}

func TopicExchangeConsumer() {
 exch, err := NewExchange(
  "amqp://guest:guest@localhost:5672/",
  "events",
  ExchangeTopic,
 )
 if err != nil {
  log.Fatal(err)
 }
 defer exch.Close()

 handler := func(body string) error {
  log.Printf("Received: %s", body)
  return nil
 }

 // 订阅所有user事件
 go exch.Subscribe("user_events", "user.*", handler)

 // 订阅所有order事件
 go exch.Subscribe("order_events", "order.*", handler)

 // 订阅所有事件
 exch.Subscribe("all_events", "#", handler)
}
```

---

## 第三部分：Kafka深度实战

### 实战案例3：Kafka生产者/消费者

```go
package main

import (
 "context"
 "fmt"
 "log"
 "time"

 "github.com/segmentio/kafka-go"
)

// KafkaProducer Kafka生产者
type KafkaProducer struct {
 writer *kafka.Writer
}

// NewKafkaProducer 创建Kafka生产者
func NewKafkaProducer(brokers []string, topic string) *KafkaProducer {
 w := &kafka.Writer{
  Addr:         kafka.TCP(brokers...),
  Topic:        topic,
  Balancer:     &kafka.LeastBytes{}, // 负载均衡策略
  MaxAttempts:  3,                    // 重试次数
  RequiredAcks: kafka.RequireAll,    // 等待所有副本确认
  Compression:  kafka.Snappy,        // 压缩算法
  BatchSize:    100,                  // 批量发送
  BatchTimeout: 10 * time.Millisecond,
 }

 return &KafkaProducer{writer: w}
}

// SendMessage 发送消息
func (p *KafkaProducer) SendMessage(ctx context.Context, key, value string) error {
 return p.writer.WriteMessages(ctx, kafka.Message{
  Key:   []byte(key),
  Value: []byte(value),
  Time:  time.Now(),
 })
}

// SendMessages 批量发送消息
func (p *KafkaProducer) SendMessages(ctx context.Context, messages []kafka.Message) error {
 return p.writer.WriteMessages(ctx, messages...)
}

// Close 关闭生产者
func (p *KafkaProducer) Close() error {
 return p.writer.Close()
}

// KafkaConsumer Kafka消费者
type KafkaConsumer struct {
 reader *kafka.Reader
}

// NewKafkaConsumer 创建Kafka消费者
func NewKafkaConsumer(brokers []string, topic, groupID string) *KafkaConsumer {
 r := kafka.NewReader(kafka.ReaderConfig{
  Brokers:        brokers,
  Topic:          topic,
  GroupID:        groupID,
  MinBytes:       10e3, // 10KB
  MaxBytes:       10e6, // 10MB
  CommitInterval: time.Second,
  StartOffset:    kafka.LastOffset, // 从最新位置开始
  MaxWait:        500 * time.Millisecond,
 })

 return &KafkaConsumer{reader: r}
}

// ConsumeMessages 消费消息
func (c *KafkaConsumer) ConsumeMessages(ctx context.Context, handler func(kafka.Message) error) error {
 for {
  select {
  case <-ctx.Done():
   return ctx.Err()
  default:
   msg, err := c.reader.FetchMessage(ctx)
   if err != nil {
    log.Printf("Failed to fetch message: %v", err)
    continue
   }

   log.Printf("Message: topic=%s, partition=%d, offset=%d, key=%s, value=%s",
    msg.Topic, msg.Partition, msg.Offset, string(msg.Key), string(msg.Value))

   // 处理消息
   if err := handler(msg); err != nil {
    log.Printf("Handler error: %v", err)
    continue
   }

   // 提交offset
   if err := c.reader.CommitMessages(ctx, msg); err != nil {
    log.Printf("Failed to commit: %v", err)
   }
  }
 }
}

// Close 关闭消费者
func (c *KafkaConsumer) Close() error {
 return c.reader.Close()
}

// ===== 生产者示例 =====
func KafkaProducerExample() {
 producer := NewKafkaProducer(
  []string{"localhost:9092"},
  "orders",
 )
 defer producer.Close()

 ctx := context.Background()

 // 发送单条消息
 for i := 1; i <= 10; i++ {
  key := fmt.Sprintf("order-%d", i)
  value := fmt.Sprintf("Order #%d created", i)

  if err := producer.SendMessage(ctx, key, value); err != nil {
   log.Printf("Failed to send message: %v", err)
   continue
  }

  log.Printf("Sent: %s = %s", key, value)
  time.Sleep(100 * time.Millisecond)
 }

 // 批量发送
 messages := make([]kafka.Message, 100)
 for i := 0; i < 100; i++ {
  messages[i] = kafka.Message{
   Key:   []byte(fmt.Sprintf("batch-%d", i)),
   Value: []byte(fmt.Sprintf("Batch message %d", i)),
  }
 }

 if err := producer.SendMessages(ctx, messages); err != nil {
  log.Printf("Failed to send batch: %v", err)
 } else {
  log.Println("Sent 100 messages in batch")
 }
}

// ===== 消费者示例 =====
func KafkaConsumerExample() {
 consumer := NewKafkaConsumer(
  []string{"localhost:9092"},
  "orders",
  "order-processors",
 )
 defer consumer.Close()

 ctx := context.Background()

 handler := func(msg kafka.Message) error {
  log.Printf("Processing: %s = %s", string(msg.Key), string(msg.Value))
  // 模拟处理
  time.Sleep(200 * time.Millisecond)
  return nil
 }

 log.Println("Waiting for messages...")
 if err := consumer.ConsumeMessages(ctx, handler); err != nil {
  log.Fatal(err)
 }
}
```

---

## 第四部分：NATS深度实战

### 实战案例4：NATS发布订阅

```go
package main

import (
 "context"
 "fmt"
 "log"
 "time"

 "github.com/nats-io/nats.go"
)

// NATSClient NATS客户端封装
type NATSClient struct {
 conn *nats.Conn
}

// NewNATSClient 创建NATS客户端
func NewNATSClient(url string) (*NATSClient, error) {
 nc, err := nats.Connect(url,
  nats.RetryOnFailedConnect(true),
  nats.MaxReconnects(10),
  nats.ReconnectWait(time.Second),
 )
 if err != nil {
  return nil, err
 }

 return &NATSClient{conn: nc}, nil
}

// Publish 发布消息
func (c *NATSClient) Publish(subject string, data []byte) error {
 return c.conn.Publish(subject, data)
}

// Subscribe 订阅主题
func (c *NATSClient) Subscribe(subject string, handler func([]byte)) error {
 _, err := c.conn.Subscribe(subject, func(msg *nats.Msg) {
  handler(msg.Data)
 })
 return err
}

// QueueSubscribe 队列订阅（负载均衡）
func (c *NATSClient) QueueSubscribe(subject, queue string, handler func([]byte)) error {
 _, err := c.conn.QueueSubscribe(subject, queue, func(msg *nats.Msg) {
  handler(msg.Data)
 })
 return err
}

// Request 请求-响应模式
func (c *NATSClient) Request(subject string, data []byte, timeout time.Duration) ([]byte, error) {
 msg, err := c.conn.Request(subject, data, timeout)
 if err != nil {
  return nil, err
 }
 return msg.Data, nil
}

// Close 关闭连接
func (c *NATSClient) Close() {
 c.conn.Close()
}

// ===== 发布订阅示例 =====
func NATSPubSubExample() {
 // 发布者
 publisher, err := NewNATSClient("nats://localhost:4222")
 if err != nil {
  log.Fatal(err)
 }
 defer publisher.Close()

 // 订阅者1
 subscriber1, err := NewNATSClient("nats://localhost:4222")
 if err != nil {
  log.Fatal(err)
 }
 defer subscriber1.Close()

 subscriber1.Subscribe("updates", func(data []byte) {
  log.Printf("Subscriber 1 received: %s", string(data))
 })

 // 订阅者2
 subscriber2, err := NewNATSClient("nats://localhost:4222")
 if err != nil {
  log.Fatal(err)
 }
 defer subscriber2.Close()

 subscriber2.Subscribe("updates", func(data []byte) {
  log.Printf("Subscriber 2 received: %s", string(data))
 })

 // 发布消息
 time.Sleep(100 * time.Millisecond) // 等待订阅建立
 for i := 1; i <= 5; i++ {
  msg := fmt.Sprintf("Update #%d", i)
  publisher.Publish("updates", []byte(msg))
  log.Printf("Published: %s", msg)
  time.Sleep(500 * time.Millisecond)
 }

 time.Sleep(time.Second)
}

// ===== 队列订阅示例（负载均衡）=====
func NATSQueueExample() {
 // 发布者
 publisher, err := NewNATSClient("nats://localhost:4222")
 if err != nil {
  log.Fatal(err)
 }
 defer publisher.Close()

 // 工作者1
 worker1, err := NewNATSClient("nats://localhost:4222")
 if err != nil {
  log.Fatal(err)
 }
 defer worker1.Close()

 worker1.QueueSubscribe("jobs", "workers", func(data []byte) {
  log.Printf("Worker 1 processing: %s", string(data))
  time.Sleep(500 * time.Millisecond)
 })

 // 工作者2
 worker2, err := NewNATSClient("nats://localhost:4222")
 if err != nil {
  log.Fatal(err)
 }
 defer worker2.Close()

 worker2.QueueSubscribe("jobs", "workers", func(data []byte) {
  log.Printf("Worker 2 processing: %s", string(data))
  time.Sleep(500 * time.Millisecond)
 })

 // 发布任务（会被负载均衡到两个worker）
 time.Sleep(100 * time.Millisecond)
 for i := 1; i <= 10; i++ {
  job := fmt.Sprintf("Job #%d", i)
  publisher.Publish("jobs", []byte(job))
  log.Printf("Published job: %s", job)
  time.Sleep(100 * time.Millisecond)
 }

 time.Sleep(10 * time.Second)
}

// ===== 请求-响应示例 =====
func NATSRequestReplyExample() {
 // 响应者
 responder, err := NewNATSClient("nats://localhost:4222")
 if err != nil {
  log.Fatal(err)
 }
 defer responder.Close()

 // 注册响应处理器
 responder.conn.Subscribe("echo", func(msg *nats.Msg) {
  log.Printf("Received request: %s", string(msg.Data))
  reply := fmt.Sprintf("Echo: %s", string(msg.Data))
  msg.Respond([]byte(reply))
 })

 // 请求者
 requester, err := NewNATSClient("nats://localhost:4222")
 if err != nil {
  log.Fatal(err)
 }
 defer requester.Close()

 time.Sleep(100 * time.Millisecond)

 // 发送请求
 for i := 1; i <= 3; i++ {
  request := fmt.Sprintf("Hello #%d", i)
  response, err := requester.Request("echo", []byte(request), 2*time.Second)
  if err != nil {
   log.Printf("Request failed: %v", err)
   continue
  }
  log.Printf("Received response: %s", string(response))
 }
}
```

---

## 🎯 总结

### 消息队列核心要点

1. **RabbitMQ** - AMQP协议、Exchange模式、消息确认
2. **Kafka** - 高吞吐、分区、消费者组
3. **NATS** - 轻量级、发布订阅、请求响应
4. **消息模式** - 点对点、发布订阅、请求响应
5. **可靠性** - 持久化、确认机制、重试
6. **幂等性** - 消息去重、唯一ID
7. **死信队列** - 失败消息处理
8. **延迟队列** - 定时任务
9. **性能优化** - 批处理、压缩、分区
10. **监控** - 消息堆积、消费延迟

### 三种MQ对比

```text
┌──────────┬────────────┬────────────┬────────────┐
│   特性   │  RabbitMQ  │   Kafka    │    NATS    │
├──────────┼────────────┼────────────┼────────────┤
│   协议   │    AMQP    │  自定义    │  自定义    │
│  吞吐量  │    中等    │    极高    │    高      │
│  延迟    │    低      │    中等    │    极低    │
│  持久化  │    支持    │    支持    │  可选      │
│  消息顺序│    保证    │ 分区内保证 │  不保证    │
│  复杂度  │    高      │    高      │    低      │
│ 使用场景 │  通用MQ    │ 大数据流   │ 轻量通信   │
└──────────┴────────────┴────────────┴────────────┘

选择建议:
- RabbitMQ: 复杂路由、事务支持
- Kafka: 日志收集、流处理、大数据
- NATS: 微服务通信、实时消息
```

---

**文档版本**: v16.0  

<div align="center">

Made with ❤️ for Distributed System Develope[⬆ 回到顶部](#回到顶部)#消息队列)

</div>

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025-10-29  
**文档状态**: 完成  
**适用版本**: Go 1.25.3+
