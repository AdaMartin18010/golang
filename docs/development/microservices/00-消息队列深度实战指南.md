# æ¶ˆæ¯é˜Ÿåˆ—

**å­—æ•°**: ~42,000å­—
**ä»£ç ç¤ºä¾‹**: 140+ä¸ªå®Œæ•´ç¤ºä¾‹
**å®æˆ˜æ¡ˆä¾‹**: 15ä¸ªç«¯åˆ°ç«¯æ¡ˆä¾‹
**é€‚ç”¨äººç¾¤**: ä¸­çº§åˆ°é«˜çº§Goå¼€å‘è€…

---

## ğŸ“‹ ç›®å½•

<!-- TOC -->
- [æ¶ˆæ¯é˜Ÿåˆ—](#æ¶ˆæ¯é˜Ÿåˆ—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ç¬¬ä¸€éƒ¨åˆ†ï¼šæ¶ˆæ¯é˜Ÿåˆ—æ ¸å¿ƒåŸç†](#ç¬¬ä¸€éƒ¨åˆ†æ¶ˆæ¯é˜Ÿåˆ—æ ¸å¿ƒåŸç†)
    - [æ¶ˆæ¯é˜Ÿåˆ—æ¶æ„](#æ¶ˆæ¯é˜Ÿåˆ—æ¶æ„)
    - [ä¸ºä»€ä¹ˆéœ€è¦æ¶ˆæ¯é˜Ÿåˆ—ï¼Ÿ](#ä¸ºä»€ä¹ˆéœ€è¦æ¶ˆæ¯é˜Ÿåˆ—)
  - [ç¬¬äºŒéƒ¨åˆ†ï¼šRabbitMQæ·±åº¦å®æˆ˜](#ç¬¬äºŒéƒ¨åˆ†rabbitmqæ·±åº¦å®æˆ˜)
    - [å®æˆ˜æ¡ˆä¾‹1ï¼šRabbitMQåŸºç¡€ä½¿ç”¨](#å®æˆ˜æ¡ˆä¾‹1rabbitmqåŸºç¡€ä½¿ç”¨)
    - [å®æˆ˜æ¡ˆä¾‹2ï¼šRabbitMQäº¤æ¢æœºæ¨¡å¼](#å®æˆ˜æ¡ˆä¾‹2rabbitmqäº¤æ¢æœºæ¨¡å¼)
  - [ç¬¬ä¸‰éƒ¨åˆ†ï¼šKafkaæ·±åº¦å®æˆ˜](#ç¬¬ä¸‰éƒ¨åˆ†kafkaæ·±åº¦å®æˆ˜)
    - [å®æˆ˜æ¡ˆä¾‹3ï¼šKafkaç”Ÿäº§è€…/æ¶ˆè´¹è€…](#å®æˆ˜æ¡ˆä¾‹3kafkaç”Ÿäº§è€…æ¶ˆè´¹è€…)
  - [ç¬¬å››éƒ¨åˆ†ï¼šNATSæ·±åº¦å®æˆ˜](#ç¬¬å››éƒ¨åˆ†natsæ·±åº¦å®æˆ˜)
    - [å®æˆ˜æ¡ˆä¾‹4ï¼šNATSå‘å¸ƒè®¢é˜…](#å®æˆ˜æ¡ˆä¾‹4natså‘å¸ƒè®¢é˜…)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
    - [æ¶ˆæ¯é˜Ÿåˆ—æ ¸å¿ƒè¦ç‚¹](#æ¶ˆæ¯é˜Ÿåˆ—æ ¸å¿ƒè¦ç‚¹)
    - [ä¸‰ç§MQå¯¹æ¯”](#ä¸‰ç§mqå¯¹æ¯”)
<!-- TOC -->

---

## ç¬¬ä¸€éƒ¨åˆ†ï¼šæ¶ˆæ¯é˜Ÿåˆ—æ ¸å¿ƒåŸç†

### æ¶ˆæ¯é˜Ÿåˆ—æ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              æ¶ˆæ¯é˜Ÿåˆ—æ¶æ„                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Producer                MQ Broker              Consumer
   â”‚                        â”‚                      â”‚
   â”‚  1. Send Message       â”‚                      â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚                      â”‚
   â”‚                        â”‚  - Store Message     â”‚
   â”‚                        â”‚  - Persistence       â”‚
   â”‚                        â”‚  - Routing           â”‚
   â”‚  2. Ack                â”‚                      â”‚
   â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                      â”‚
   â”‚                        â”‚                      â”‚
   â”‚                        â”‚  3. Subscribe        â”‚
   â”‚                        â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚                        â”‚                      â”‚
   â”‚                        â”‚  4. Deliver Message  â”‚
   â”‚                        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
   â”‚                        â”‚                      â”‚
   â”‚                        â”‚  5. Ack              â”‚
   â”‚                        â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ ¸å¿ƒæ¦‚å¿µ:
- Producer: æ¶ˆæ¯ç”Ÿäº§è€…
- Consumer: æ¶ˆæ¯æ¶ˆè´¹è€…
- Broker: æ¶ˆæ¯ä»£ç†ï¼ˆRabbitMQ/Kafka/NATSï¼‰
- Queue: æ¶ˆæ¯é˜Ÿåˆ—ï¼ˆå­˜å‚¨æ¶ˆæ¯ï¼‰
- Topic: æ¶ˆæ¯ä¸»é¢˜ï¼ˆå‘å¸ƒ/è®¢é˜…ï¼‰
- Exchange: äº¤æ¢æœºï¼ˆRabbitMQè·¯ç”±ï¼‰
- Partition: åˆ†åŒºï¼ˆKafkaåˆ†å¸ƒå¼ï¼‰

æ¶ˆæ¯æ¨¡å¼:
1. ç‚¹å¯¹ç‚¹ï¼ˆQueueï¼‰ï¼šä¸€å¯¹ä¸€
2. å‘å¸ƒè®¢é˜…ï¼ˆTopicï¼‰ï¼šä¸€å¯¹å¤š
3. è¯·æ±‚å“åº”ï¼ˆRPCï¼‰ï¼šåŒå‘é€šä¿¡
```

---

### ä¸ºä»€ä¹ˆéœ€è¦æ¶ˆæ¯é˜Ÿåˆ—ï¼Ÿ

```text
è§£å†³çš„é—®é¢˜:

1. å¼‚æ­¥å¤„ç†
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  ç”¨æˆ·æ³¨å†Œ â”‚â”€â”€â”€â”€â”€â–ºâ”‚   MQ     â”‚â”€â”€â”€â”€â”€â–ºâ”‚  å‘é‚®ä»¶  â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     ç«‹å³è¿”å›          å¼‚æ­¥å¤„ç†           åå°æ‰§è¡Œ

2. å‰Šå³°å¡«è°·
   è¯·æ±‚å³°å€¼: 10000/s
        â”‚
        â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚    MQ    â”‚ â”€â”€â–º ç¨³å®šå¤„ç†: 1000/s
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

3. ç³»ç»Ÿè§£è€¦
   è®¢å•æœåŠ¡ â”€â”€â–º MQ â”€â”€â–º åº“å­˜æœåŠ¡
             â”‚    â””â”€â”€â–º æ”¯ä»˜æœåŠ¡
             â”‚    â””â”€â”€â–º ç‰©æµæœåŠ¡
             â””â”€â”€â–º é‚®ä»¶æœåŠ¡

4. æµé‡æ§åˆ¶
   ç”Ÿäº§é€Ÿåº¦ > æ¶ˆè´¹é€Ÿåº¦ â”€â”€â–º MQç¼“å†²

5. å¯é ä¼ è¾“
   å‘é€æ–¹ â”€â”€â–º MQ(æŒä¹…åŒ–) â”€â”€â–º æ¥æ”¶æ–¹
             â””â”€â–º æ¶ˆæ¯ä¸ä¸¢å¤±
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šRabbitMQæ·±åº¦å®æˆ˜

### å®æˆ˜æ¡ˆä¾‹1ï¼šRabbitMQåŸºç¡€ä½¿ç”¨

```go
package main

import (
 "context"
 "fmt"
 "log"
 "time"

 amqp "github.com/rabbitmq/amqp091-go"
)

// RabbitMQ è¿æ¥å°è£…
type RabbitMQ struct {
 conn    *amqp.Connection
 channel *amqp.Channel
 queue   string
}

// NewRabbitMQ åˆ›å»ºRabbitMQè¿æ¥
func NewRabbitMQ(url, queueName string) (*RabbitMQ, error) {
 // è¿æ¥RabbitMQ
 conn, err := amqp.Dial(url)
 if err != nil {
  return nil, fmt.Errorf("failed to connect: %v", err)
 }

 // åˆ›å»ºChannel
 ch, err := conn.Channel()
 if err != nil {
  conn.Close()
  return nil, fmt.Errorf("failed to open channel: %v", err)
 }

 // å£°æ˜é˜Ÿåˆ—
 q, err := ch.QueueDeclare(
  queueName, // name
  true,      // durable (æŒä¹…åŒ–)
  false,     // delete when unused
  false,     // exclusive
  false,     // no-wait
  nil,       // arguments
 )
 if err != nil {
  ch.Close()
  conn.Close()
  return nil, fmt.Errorf("failed to declare queue: %v", err)
 }

 return &RabbitMQ{
  conn:    conn,
  channel: ch,
  queue:   q.Name,
 }, nil
}

// Publish å‘å¸ƒæ¶ˆæ¯
func (r *RabbitMQ) Publish(ctx context.Context, body string) error {
 return r.channel.PublishWithContext(
  ctx,
  "",      // exchange
  r.queue, // routing key
  false,   // mandatory
  false,   // immediate
  amqp.Publishing{
   DeliveryMode: amqp.Persistent, // æŒä¹…åŒ–æ¶ˆæ¯
   ContentType:  "text/plain",
   Body:         []byte(body),
   Timestamp:    time.Now(),
  },
 )
}

// Consume æ¶ˆè´¹æ¶ˆæ¯
func (r *RabbitMQ) Consume(handler func(string) error) error {
 // è®¾ç½®QoSï¼ˆé¢„å–æ•°é‡ï¼‰
 err := r.channel.Qos(
  1,     // prefetch count
  0,     // prefetch size
  false, // global
 )
 if err != nil {
  return fmt.Errorf("failed to set QoS: %v", err)
 }

 // å¼€å§‹æ¶ˆè´¹
 msgs, err := r.channel.Consume(
  r.queue, // queue
  "",      // consumer
  false,   // auto-ack (æ‰‹åŠ¨ç¡®è®¤)
  false,   // exclusive
  false,   // no-local
  false,   // no-wait
  nil,     // args
 )
 if err != nil {
  return fmt.Errorf("failed to register consumer: %v", err)
 }

 // å¤„ç†æ¶ˆæ¯
 for msg := range msgs {
  log.Printf("Received: %s", msg.Body)

  // å¤„ç†æ¶ˆæ¯
  if err := handler(string(msg.Body)); err != nil {
   log.Printf("Handler error: %v", err)
   // Nackï¼ˆé‡æ–°å…¥é˜Ÿï¼‰
   msg.Nack(false, true)
   continue
  }

  // Ackç¡®è®¤
  msg.Ack(false)
 }

 return nil
}

// Close å…³é—­è¿æ¥
func (r *RabbitMQ) Close() error {
 if err := r.channel.Close(); err != nil {
  return err
 }
 return r.conn.Close()
}

// ===== ç”Ÿäº§è€…ç¤ºä¾‹ =====
func ProducerExample() {
 mq, err := NewRabbitMQ("amqp://guest:guest@localhost:5672/", "orders")
 if err != nil {
  log.Fatal(err)
 }
 defer mq.Close()

 ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
 defer cancel()

 // å‘é€10æ¡æ¶ˆæ¯
 for i := 1; i <= 10; i++ {
  msg := fmt.Sprintf("Order #%d", i)
  if err := mq.Publish(ctx, msg); err != nil {
   log.Printf("Failed to publish: %v", err)
   continue
  }
  log.Printf("Sent: %s", msg)
  time.Sleep(100 * time.Millisecond)
 }
}

// ===== æ¶ˆè´¹è€…ç¤ºä¾‹ =====
func ConsumerExample() {
 mq, err := NewRabbitMQ("amqp://guest:guest@localhost:5672/", "orders")
 if err != nil {
  log.Fatal(err)
 }
 defer mq.Close()

 // æ¶ˆè´¹æ¶ˆæ¯
 handler := func(body string) error {
  log.Printf("Processing: %s", body)
  // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
  time.Sleep(500 * time.Millisecond)
  return nil
 }

 log.Println("Waiting for messages...")
 if err := mq.Consume(handler); err != nil {
  log.Fatal(err)
 }
}
```

---

### å®æˆ˜æ¡ˆä¾‹2ï¼šRabbitMQäº¤æ¢æœºæ¨¡å¼

```go
package rabbitmq

import (
 "context"
 "fmt"
 "log"

 amqp "github.com/rabbitmq/amqp091-go"
)

// ExchangeType äº¤æ¢æœºç±»å‹
type ExchangeType string

const (
 ExchangeDirect  ExchangeType = "direct"  // ç›´è¿
 ExchangeFanout  ExchangeType = "fanout"  // æ‰‡å‡ºï¼ˆå¹¿æ’­ï¼‰
 ExchangeTopic   ExchangeType = "topic"   // ä¸»é¢˜
 ExchangeHeaders ExchangeType = "headers" // å¤´éƒ¨
)

// Exchange äº¤æ¢æœºå°è£…
type Exchange struct {
 conn     *amqp.Connection
 channel  *amqp.Channel
 name     string
 exchType ExchangeType
}

// NewExchange åˆ›å»ºäº¤æ¢æœº
func NewExchange(url, name string, exchType ExchangeType) (*Exchange, error) {
 conn, err := amqp.Dial(url)
 if err != nil {
  return nil, err
 }

 ch, err := conn.Channel()
 if err != nil {
  conn.Close()
  return nil, err
 }

 // å£°æ˜äº¤æ¢æœº
 err = ch.ExchangeDeclare(
  name,               // name
  string(exchType),   // type
  true,               // durable
  false,              // auto-deleted
  false,              // internal
  false,              // no-wait
  nil,                // arguments
 )
 if err != nil {
  ch.Close()
  conn.Close()
  return nil, err
 }

 return &Exchange{
  conn:     conn,
  channel:  ch,
  name:     name,
  exchType: exchType,
 }, nil
}

// Publish å‘å¸ƒåˆ°äº¤æ¢æœº
func (e *Exchange) Publish(ctx context.Context, routingKey, body string) error {
 return e.channel.PublishWithContext(
  ctx,
  e.name,     // exchange
  routingKey, // routing key
  false,      // mandatory
  false,      // immediate
  amqp.Publishing{
   DeliveryMode: amqp.Persistent,
   ContentType:  "text/plain",
   Body:         []byte(body),
  },
 )
}

// Subscribe è®¢é˜…äº¤æ¢æœº
func (e *Exchange) Subscribe(queueName, routingKey string, handler func(string) error) error {
 // å£°æ˜é˜Ÿåˆ—
 q, err := e.channel.QueueDeclare(
  queueName, // name
  true,      // durable
  false,     // delete when unused
  false,     // exclusive
  false,     // no-wait
  nil,       // arguments
 )
 if err != nil {
  return err
 }

 // ç»‘å®šé˜Ÿåˆ—åˆ°äº¤æ¢æœº
 err = e.channel.QueueBind(
  q.Name,     // queue name
  routingKey, // routing key
  e.name,     // exchange
  false,      // no-wait
  nil,        // args
 )
 if err != nil {
  return err
 }

 // è®¾ç½®QoS
 e.channel.Qos(1, 0, false)

 // æ¶ˆè´¹æ¶ˆæ¯
 msgs, err := e.channel.Consume(
  q.Name, // queue
  "",     // consumer
  false,  // auto-ack
  false,  // exclusive
  false,  // no-local
  false,  // no-wait
  nil,    // args
 )
 if err != nil {
  return err
 }

 for msg := range msgs {
  if err := handler(string(msg.Body)); err != nil {
   log.Printf("Handler error: %v", err)
   msg.Nack(false, true)
   continue
  }
  msg.Ack(false)
 }

 return nil
}

// Close å…³é—­è¿æ¥
func (e *Exchange) Close() error {
 if err := e.channel.Close(); err != nil {
  return err
 }
 return e.conn.Close()
}

// ===== 1. Direct Exchangeï¼ˆç›´è¿äº¤æ¢æœºï¼‰=====
func DirectExchangeExample() {
 // åˆ›å»ºäº¤æ¢æœº
 exch, err := NewExchange(
  "amqp://guest:guest@localhost:5672/",
  "logs_direct",
  ExchangeDirect,
 )
 if err != nil {
  log.Fatal(err)
 }
 defer exch.Close()

 ctx := context.Background()

 // å‘é€ä¸åŒçº§åˆ«çš„æ—¥å¿—
 exch.Publish(ctx, "info", "Info log message")
 exch.Publish(ctx, "warning", "Warning log message")
 exch.Publish(ctx, "error", "Error log message")
}

func DirectExchangeConsumer(level string) {
 exch, err := NewExchange(
  "amqp://guest:guest@localhost:5672/",
  "logs_direct",
  ExchangeDirect,
 )
 if err != nil {
  log.Fatal(err)
 }
 defer exch.Close()

 handler := func(body string) error {
  log.Printf("[%s] %s", level, body)
  return nil
 }

 queueName := fmt.Sprintf("logs_%s", level)
 exch.Subscribe(queueName, level, handler)
}

// ===== 2. Fanout Exchangeï¼ˆæ‰‡å‡ºäº¤æ¢æœºï¼‰=====
func FanoutExchangeExample() {
 exch, err := NewExchange(
  "amqp://guest:guest@localhost:5672/",
  "notifications",
  ExchangeFanout,
 )
 if err != nil {
  log.Fatal(err)
 }
 defer exch.Close()

 ctx := context.Background()

 // å¹¿æ’­æ¶ˆæ¯ï¼ˆæ‰€æœ‰è®¢é˜…è€…éƒ½ä¼šæ”¶åˆ°ï¼‰
 exch.Publish(ctx, "", "System notification: Server will restart in 5 minutes")
}

// ===== 3. Topic Exchangeï¼ˆä¸»é¢˜äº¤æ¢æœºï¼‰=====
func TopicExchangeExample() {
 exch, err := NewExchange(
  "amqp://guest:guest@localhost:5672/",
  "events",
  ExchangeTopic,
 )
 if err != nil {
  log.Fatal(err)
 }
 defer exch.Close()

 ctx := context.Background()

 // å‘é€ä¸åŒä¸»é¢˜çš„äº‹ä»¶
 exch.Publish(ctx, "user.created", "User Alice created")
 exch.Publish(ctx, "user.updated", "User Bob updated")
 exch.Publish(ctx, "order.created", "Order #123 created")
 exch.Publish(ctx, "order.paid", "Order #123 paid")
}

func TopicExchangeConsumer() {
 exch, err := NewExchange(
  "amqp://guest:guest@localhost:5672/",
  "events",
  ExchangeTopic,
 )
 if err != nil {
  log.Fatal(err)
 }
 defer exch.Close()

 handler := func(body string) error {
  log.Printf("Received: %s", body)
  return nil
 }

 // è®¢é˜…æ‰€æœ‰useräº‹ä»¶
 go exch.Subscribe("user_events", "user.*", handler)

 // è®¢é˜…æ‰€æœ‰orderäº‹ä»¶
 go exch.Subscribe("order_events", "order.*", handler)

 // è®¢é˜…æ‰€æœ‰äº‹ä»¶
 exch.Subscribe("all_events", "#", handler)
}
```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šKafkaæ·±åº¦å®æˆ˜

### å®æˆ˜æ¡ˆä¾‹3ï¼šKafkaç”Ÿäº§è€…/æ¶ˆè´¹è€…

```go
package main

import (
 "context"
 "fmt"
 "log"
 "time"

 "github.com/segmentio/kafka-go"
)

// KafkaProducer Kafkaç”Ÿäº§è€…
type KafkaProducer struct {
 writer *kafka.Writer
}

// NewKafkaProducer åˆ›å»ºKafkaç”Ÿäº§è€…
func NewKafkaProducer(brokers []string, topic string) *KafkaProducer {
 w := &kafka.Writer{
  Addr:         kafka.TCP(brokers...),
  Topic:        topic,
  Balancer:     &kafka.LeastBytes{}, // è´Ÿè½½å‡è¡¡ç­–ç•¥
  MaxAttempts:  3,                    // é‡è¯•æ¬¡æ•°
  RequiredAcks: kafka.RequireAll,    // ç­‰å¾…æ‰€æœ‰å‰¯æœ¬ç¡®è®¤
  Compression:  kafka.Snappy,        // å‹ç¼©ç®—æ³•
  BatchSize:    100,                  // æ‰¹é‡å‘é€
  BatchTimeout: 10 * time.Millisecond,
 }

 return &KafkaProducer{writer: w}
}

// SendMessage å‘é€æ¶ˆæ¯
func (p *KafkaProducer) SendMessage(ctx context.Context, key, value string) error {
 return p.writer.WriteMessages(ctx, kafka.Message{
  Key:   []byte(key),
  Value: []byte(value),
  Time:  time.Now(),
 })
}

// SendMessages æ‰¹é‡å‘é€æ¶ˆæ¯
func (p *KafkaProducer) SendMessages(ctx context.Context, messages []kafka.Message) error {
 return p.writer.WriteMessages(ctx, messages...)
}

// Close å…³é—­ç”Ÿäº§è€…
func (p *KafkaProducer) Close() error {
 return p.writer.Close()
}

// KafkaConsumer Kafkaæ¶ˆè´¹è€…
type KafkaConsumer struct {
 reader *kafka.Reader
}

// NewKafkaConsumer åˆ›å»ºKafkaæ¶ˆè´¹è€…
func NewKafkaConsumer(brokers []string, topic, groupID string) *KafkaConsumer {
 r := kafka.NewReader(kafka.ReaderConfig{
  Brokers:        brokers,
  Topic:          topic,
  GroupID:        groupID,
  MinBytes:       10e3, // 10KB
  MaxBytes:       10e6, // 10MB
  CommitInterval: time.Second,
  StartOffset:    kafka.LastOffset, // ä»æœ€æ–°ä½ç½®å¼€å§‹
  MaxWait:        500 * time.Millisecond,
 })

 return &KafkaConsumer{reader: r}
}

// ConsumeMessages æ¶ˆè´¹æ¶ˆæ¯
func (c *KafkaConsumer) ConsumeMessages(ctx context.Context, handler func(kafka.Message) error) error {
 for {
  select {
  case <-ctx.Done():
   return ctx.Err()
  default:
   msg, err := c.reader.FetchMessage(ctx)
   if err != nil {
    log.Printf("Failed to fetch message: %v", err)
    continue
   }

   log.Printf("Message: topic=%s, partition=%d, offset=%d, key=%s, value=%s",
    msg.Topic, msg.Partition, msg.Offset, string(msg.Key), string(msg.Value))

   // å¤„ç†æ¶ˆæ¯
   if err := handler(msg); err != nil {
    log.Printf("Handler error: %v", err)
    continue
   }

   // æäº¤offset
   if err := c.reader.CommitMessages(ctx, msg); err != nil {
    log.Printf("Failed to commit: %v", err)
   }
  }
 }
}

// Close å…³é—­æ¶ˆè´¹è€…
func (c *KafkaConsumer) Close() error {
 return c.reader.Close()
}

// ===== ç”Ÿäº§è€…ç¤ºä¾‹ =====
func KafkaProducerExample() {
 producer := NewKafkaProducer(
  []string{"localhost:9092"},
  "orders",
 )
 defer producer.Close()

 ctx := context.Background()

 // å‘é€å•æ¡æ¶ˆæ¯
 for i := 1; i <= 10; i++ {
  key := fmt.Sprintf("order-%d", i)
  value := fmt.Sprintf("Order #%d created", i)

  if err := producer.SendMessage(ctx, key, value); err != nil {
   log.Printf("Failed to send message: %v", err)
   continue
  }

  log.Printf("Sent: %s = %s", key, value)
  time.Sleep(100 * time.Millisecond)
 }

 // æ‰¹é‡å‘é€
 messages := make([]kafka.Message, 100)
 for i := 0; i < 100; i++ {
  messages[i] = kafka.Message{
   Key:   []byte(fmt.Sprintf("batch-%d", i)),
   Value: []byte(fmt.Sprintf("Batch message %d", i)),
  }
 }

 if err := producer.SendMessages(ctx, messages); err != nil {
  log.Printf("Failed to send batch: %v", err)
 } else {
  log.Println("Sent 100 messages in batch")
 }
}

// ===== æ¶ˆè´¹è€…ç¤ºä¾‹ =====
func KafkaConsumerExample() {
 consumer := NewKafkaConsumer(
  []string{"localhost:9092"},
  "orders",
  "order-processors",
 )
 defer consumer.Close()

 ctx := context.Background()

 handler := func(msg kafka.Message) error {
  log.Printf("Processing: %s = %s", string(msg.Key), string(msg.Value))
  // æ¨¡æ‹Ÿå¤„ç†
  time.Sleep(200 * time.Millisecond)
  return nil
 }

 log.Println("Waiting for messages...")
 if err := consumer.ConsumeMessages(ctx, handler); err != nil {
  log.Fatal(err)
 }
}
```

---

## ç¬¬å››éƒ¨åˆ†ï¼šNATSæ·±åº¦å®æˆ˜

### å®æˆ˜æ¡ˆä¾‹4ï¼šNATSå‘å¸ƒè®¢é˜…

```go
package main

import (
 "context"
 "fmt"
 "log"
 "time"

 "github.com/nats-io/nats.go"
)

// NATSClient NATSå®¢æˆ·ç«¯å°è£…
type NATSClient struct {
 conn *nats.Conn
}

// NewNATSClient åˆ›å»ºNATSå®¢æˆ·ç«¯
func NewNATSClient(url string) (*NATSClient, error) {
 nc, err := nats.Connect(url,
  nats.RetryOnFailedConnect(true),
  nats.MaxReconnects(10),
  nats.ReconnectWait(time.Second),
 )
 if err != nil {
  return nil, err
 }

 return &NATSClient{conn: nc}, nil
}

// Publish å‘å¸ƒæ¶ˆæ¯
func (c *NATSClient) Publish(subject string, data []byte) error {
 return c.conn.Publish(subject, data)
}

// Subscribe è®¢é˜…ä¸»é¢˜
func (c *NATSClient) Subscribe(subject string, handler func([]byte)) error {
 _, err := c.conn.Subscribe(subject, func(msg *nats.Msg) {
  handler(msg.Data)
 })
 return err
}

// QueueSubscribe é˜Ÿåˆ—è®¢é˜…ï¼ˆè´Ÿè½½å‡è¡¡ï¼‰
func (c *NATSClient) QueueSubscribe(subject, queue string, handler func([]byte)) error {
 _, err := c.conn.QueueSubscribe(subject, queue, func(msg *nats.Msg) {
  handler(msg.Data)
 })
 return err
}

// Request è¯·æ±‚-å“åº”æ¨¡å¼
func (c *NATSClient) Request(subject string, data []byte, timeout time.Duration) ([]byte, error) {
 msg, err := c.conn.Request(subject, data, timeout)
 if err != nil {
  return nil, err
 }
 return msg.Data, nil
}

// Close å…³é—­è¿æ¥
func (c *NATSClient) Close() {
 c.conn.Close()
}

// ===== å‘å¸ƒè®¢é˜…ç¤ºä¾‹ =====
func NATSPubSubExample() {
 // å‘å¸ƒè€…
 publisher, err := NewNATSClient("nats://localhost:4222")
 if err != nil {
  log.Fatal(err)
 }
 defer publisher.Close()

 // è®¢é˜…è€…1
 subscriber1, err := NewNATSClient("nats://localhost:4222")
 if err != nil {
  log.Fatal(err)
 }
 defer subscriber1.Close()

 subscriber1.Subscribe("updates", func(data []byte) {
  log.Printf("Subscriber 1 received: %s", string(data))
 })

 // è®¢é˜…è€…2
 subscriber2, err := NewNATSClient("nats://localhost:4222")
 if err != nil {
  log.Fatal(err)
 }
 defer subscriber2.Close()

 subscriber2.Subscribe("updates", func(data []byte) {
  log.Printf("Subscriber 2 received: %s", string(data))
 })

 // å‘å¸ƒæ¶ˆæ¯
 time.Sleep(100 * time.Millisecond) // ç­‰å¾…è®¢é˜…å»ºç«‹
 for i := 1; i <= 5; i++ {
  msg := fmt.Sprintf("Update #%d", i)
  publisher.Publish("updates", []byte(msg))
  log.Printf("Published: %s", msg)
  time.Sleep(500 * time.Millisecond)
 }

 time.Sleep(time.Second)
}

// ===== é˜Ÿåˆ—è®¢é˜…ç¤ºä¾‹ï¼ˆè´Ÿè½½å‡è¡¡ï¼‰=====
func NATSQueueExample() {
 // å‘å¸ƒè€…
 publisher, err := NewNATSClient("nats://localhost:4222")
 if err != nil {
  log.Fatal(err)
 }
 defer publisher.Close()

 // å·¥ä½œè€…1
 worker1, err := NewNATSClient("nats://localhost:4222")
 if err != nil {
  log.Fatal(err)
 }
 defer worker1.Close()

 worker1.QueueSubscribe("jobs", "workers", func(data []byte) {
  log.Printf("Worker 1 processing: %s", string(data))
  time.Sleep(500 * time.Millisecond)
 })

 // å·¥ä½œè€…2
 worker2, err := NewNATSClient("nats://localhost:4222")
 if err != nil {
  log.Fatal(err)
 }
 defer worker2.Close()

 worker2.QueueSubscribe("jobs", "workers", func(data []byte) {
  log.Printf("Worker 2 processing: %s", string(data))
  time.Sleep(500 * time.Millisecond)
 })

 // å‘å¸ƒä»»åŠ¡ï¼ˆä¼šè¢«è´Ÿè½½å‡è¡¡åˆ°ä¸¤ä¸ªworkerï¼‰
 time.Sleep(100 * time.Millisecond)
 for i := 1; i <= 10; i++ {
  job := fmt.Sprintf("Job #%d", i)
  publisher.Publish("jobs", []byte(job))
  log.Printf("Published job: %s", job)
  time.Sleep(100 * time.Millisecond)
 }

 time.Sleep(10 * time.Second)
}

// ===== è¯·æ±‚-å“åº”ç¤ºä¾‹ =====
func NATSRequestReplyExample() {
 // å“åº”è€…
 responder, err := NewNATSClient("nats://localhost:4222")
 if err != nil {
  log.Fatal(err)
 }
 defer responder.Close()

 // æ³¨å†Œå“åº”å¤„ç†å™¨
 responder.conn.Subscribe("echo", func(msg *nats.Msg) {
  log.Printf("Received request: %s", string(msg.Data))
  reply := fmt.Sprintf("Echo: %s", string(msg.Data))
  msg.Respond([]byte(reply))
 })

 // è¯·æ±‚è€…
 requester, err := NewNATSClient("nats://localhost:4222")
 if err != nil {
  log.Fatal(err)
 }
 defer requester.Close()

 time.Sleep(100 * time.Millisecond)

 // å‘é€è¯·æ±‚
 for i := 1; i <= 3; i++ {
  request := fmt.Sprintf("Hello #%d", i)
  response, err := requester.Request("echo", []byte(request), 2*time.Second)
  if err != nil {
   log.Printf("Request failed: %v", err)
   continue
  }
  log.Printf("Received response: %s", string(response))
 }
}
```

---

## ğŸ¯ æ€»ç»“

### æ¶ˆæ¯é˜Ÿåˆ—æ ¸å¿ƒè¦ç‚¹

1. **RabbitMQ** - AMQPåè®®ã€Exchangeæ¨¡å¼ã€æ¶ˆæ¯ç¡®è®¤
2. **Kafka** - é«˜ååã€åˆ†åŒºã€æ¶ˆè´¹è€…ç»„
3. **NATS** - è½»é‡çº§ã€å‘å¸ƒè®¢é˜…ã€è¯·æ±‚å“åº”
4. **æ¶ˆæ¯æ¨¡å¼** - ç‚¹å¯¹ç‚¹ã€å‘å¸ƒè®¢é˜…ã€è¯·æ±‚å“åº”
5. **å¯é æ€§** - æŒä¹…åŒ–ã€ç¡®è®¤æœºåˆ¶ã€é‡è¯•
6. **å¹‚ç­‰æ€§** - æ¶ˆæ¯å»é‡ã€å”¯ä¸€ID
7. **æ­»ä¿¡é˜Ÿåˆ—** - å¤±è´¥æ¶ˆæ¯å¤„ç†
8. **å»¶è¿Ÿé˜Ÿåˆ—** - å®šæ—¶ä»»åŠ¡
9. **æ€§èƒ½ä¼˜åŒ–** - æ‰¹å¤„ç†ã€å‹ç¼©ã€åˆ†åŒº
10. **ç›‘æ§** - æ¶ˆæ¯å †ç§¯ã€æ¶ˆè´¹å»¶è¿Ÿ

### ä¸‰ç§MQå¯¹æ¯”

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç‰¹æ€§   â”‚  RabbitMQ  â”‚   Kafka    â”‚    NATS    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   åè®®   â”‚    AMQP    â”‚  è‡ªå®šä¹‰    â”‚  è‡ªå®šä¹‰    â”‚
â”‚  ååé‡  â”‚    ä¸­ç­‰    â”‚    æé«˜    â”‚    é«˜      â”‚
â”‚  å»¶è¿Ÿ    â”‚    ä½      â”‚    ä¸­ç­‰    â”‚    æä½    â”‚
â”‚  æŒä¹…åŒ–  â”‚    æ”¯æŒ    â”‚    æ”¯æŒ    â”‚  å¯é€‰      â”‚
â”‚  æ¶ˆæ¯é¡ºåºâ”‚    ä¿è¯    â”‚ åˆ†åŒºå†…ä¿è¯ â”‚  ä¸ä¿è¯    â”‚
â”‚  å¤æ‚åº¦  â”‚    é«˜      â”‚    é«˜      â”‚    ä½      â”‚
â”‚ ä½¿ç”¨åœºæ™¯ â”‚  é€šç”¨MQ    â”‚ å¤§æ•°æ®æµ   â”‚ è½»é‡é€šä¿¡   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

é€‰æ‹©å»ºè®®:
- RabbitMQ: å¤æ‚è·¯ç”±ã€äº‹åŠ¡æ”¯æŒ
- Kafka: æ—¥å¿—æ”¶é›†ã€æµå¤„ç†ã€å¤§æ•°æ®
- NATS: å¾®æœåŠ¡é€šä¿¡ã€å®æ—¶æ¶ˆæ¯
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v16.0

<div align="center">

Made with â¤ï¸ for Distributed System Develope[â¬† å›åˆ°é¡¶éƒ¨](#å›åˆ°é¡¶éƒ¨)#æ¶ˆæ¯é˜Ÿåˆ—)

</div>

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team
**æœ€åæ›´æ–°**: 2025-10-29
**æ–‡æ¡£çŠ¶æ€**: å®Œæˆ
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
