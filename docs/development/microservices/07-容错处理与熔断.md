# å®¹é”™å¤„ç†ä¸ç†”æ–­

**ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2025-10-29
**é€‚ç”¨äº**: Go 1.23+

---

## ğŸ“‹ ç›®å½•

- [å®¹é”™å¤„ç†ä¸ç†”æ–­](#å®¹é”™å¤„ç†ä¸ç†”æ–­)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“š ç†è®ºåˆ†æ](#-ç†è®ºåˆ†æ)
    - [å®¹é”™æ¨¡å¼](#å®¹é”™æ¨¡å¼)
      - [æ•…éšœè½¬ç§»ï¼ˆFailoverï¼‰](#æ•…éšœè½¬ç§»failover)
      - [éš”ç¦»æ¨¡å¼ï¼ˆBulkheadï¼‰](#éš”ç¦»æ¨¡å¼bulkhead)
    - [ç†”æ–­å™¨æ¨¡å¼](#ç†”æ–­å™¨æ¨¡å¼)
    - [é‡è¯•ç­–ç•¥](#é‡è¯•ç­–ç•¥)
      - [æŒ‡æ•°é€€é¿](#æŒ‡æ•°é€€é¿)
    - [é™çº§ç­–ç•¥](#é™çº§ç­–ç•¥)
  - [ğŸ’» ä»£ç ç¤ºä¾‹](#-ä»£ç ç¤ºä¾‹)
    - [ç†”æ–­å™¨å®ç°](#ç†”æ–­å™¨å®ç°)
    - [é‡è¯•æœºåˆ¶](#é‡è¯•æœºåˆ¶)
    - [è¶…æ—¶æ§åˆ¶](#è¶…æ—¶æ§åˆ¶)
    - [é™çº§å¤„ç†](#é™çº§å¤„ç†)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
  - [ğŸ” å¸¸è§é—®é¢˜](#-å¸¸è§é—®é¢˜)
  - [ğŸ“š æ‰©å±•é˜…è¯»](#-æ‰©å±•é˜…è¯»)
  - [âœ… è½åœ°æ£€æŸ¥æ¸…å•](#-è½åœ°æ£€æŸ¥æ¸…å•)
  - [ğŸ§ª æœ¬åœ°å¿«é€ŸéªŒè¯](#-æœ¬åœ°å¿«é€ŸéªŒè¯)

## ğŸ“š ç†è®ºåˆ†æ

### å®¹é”™æ¨¡å¼

#### æ•…éšœè½¬ç§»ï¼ˆFailoverï¼‰

- ä¸»å¤‡åˆ‡æ¢ï¼šä¸»æœåŠ¡æ•…éšœæ—¶åˆ‡æ¢åˆ°å¤‡ç”¨æœåŠ¡
- å¿«é€Ÿå¤±è´¥ï¼šæ£€æµ‹åˆ°æ•…éšœç«‹å³è¿”å›é”™è¯¯
- ä¼˜é›…é™çº§ï¼šå‡å°‘åŠŸèƒ½è€Œéå®Œå…¨å¤±è´¥

#### éš”ç¦»æ¨¡å¼ï¼ˆBulkheadï¼‰

- çº¿ç¨‹æ± éš”ç¦»ï¼šä¸åŒæœåŠ¡ä½¿ç”¨ç‹¬ç«‹çš„çº¿ç¨‹æ± 
- èµ„æºéš”ç¦»ï¼šé™åˆ¶å•ä¸ªæœåŠ¡çš„èµ„æºä½¿ç”¨
- æ•°æ®éš”ç¦»ï¼šé¿å…å…±äº«èµ„æºå¯¼è‡´çš„è¿é”æ•…éšœ

### ç†”æ–­å™¨æ¨¡å¼

ç†”æ–­å™¨æœ‰ä¸‰ç§çŠ¶æ€ï¼š

- **å…³é—­ï¼ˆClosedï¼‰**ï¼šæ­£å¸¸è¯·æ±‚é€šè¿‡
- **æ‰“å¼€ï¼ˆOpenï¼‰**ï¼šå¿«é€Ÿå¤±è´¥ï¼Œä¸è°ƒç”¨ä¸‹æ¸¸æœåŠ¡
- **åŠå¼€ï¼ˆHalf-Openï¼‰**ï¼šå°è¯•å°‘é‡è¯·æ±‚æµ‹è¯•æœåŠ¡æ¢å¤

### é‡è¯•ç­–ç•¥

#### æŒ‡æ•°é€€é¿

- é‡è¯•é—´éš”é€æ¸å¢åŠ ï¼š1s, 2s, 4s, 8s
- é¿å…å¯¹ä¸‹æ¸¸æœåŠ¡é€ æˆå‹åŠ›
- æ·»åŠ éšæœºæŠ–åŠ¨é¿å…æƒŠç¾¤æ•ˆåº”

### é™çº§ç­–ç•¥

- **åŠŸèƒ½é™çº§**ï¼šå…³é—­éæ ¸å¿ƒåŠŸèƒ½
- **æ•°æ®é™çº§**ï¼šä½¿ç”¨ç¼“å­˜æ•°æ®è€Œéå®æ—¶æ•°æ®
- **æœåŠ¡é™çº§**ï¼šä½¿ç”¨å¤‡ç”¨æœåŠ¡æˆ–é»˜è®¤å“åº”

## ğŸ’» ä»£ç ç¤ºä¾‹

### ç†”æ–­å™¨å®ç°

```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

type CircuitState int

const (
    CircuitClosed CircuitState = iota
    CircuitOpen
    CircuitHalfOpen
)

type CircuitBreaker struct {
    maxFailures    int
    timeout        time.Duration
    failures       int
    lastFailure    time.Time
    state          CircuitState
    mutex          sync.RWMutex
    successCount   int
    halfOpenMax    int
}

func NewCircuitBreaker(maxFailures int, timeout time.Duration) *CircuitBreaker {
    return &CircuitBreaker{
        maxFailures: maxFailures,
        timeout:     timeout,
        state:       CircuitClosed,
        halfOpenMax: 3,
    }
}

func (cb *CircuitBreaker) Call(fn func() error) error {
    cb.mutex.Lock()
    defer cb.mutex.Unlock()

    if cb.state == CircuitOpen {
        if time.Since(cb.lastFailure) > cb.timeout {
            cb.state = CircuitHalfOpen
            cb.successCount = 0
        } else {
            return fmt.Errorf("circuit breaker is open")
        }
    }

    err := fn()

    if err != nil {
        cb.onFailure()
        return err
    }

    cb.onSuccess()
    return nil
}

func (cb *CircuitBreaker) onFailure() {
    cb.failures++
    cb.lastFailure = time.Now()

    if cb.failures >= cb.maxFailures {
        cb.state = CircuitOpen
    }
}

func (cb *CircuitBreaker) onSuccess() {
    cb.failures = 0
    cb.successCount++

    if cb.state == CircuitHalfOpen && cb.successCount >= cb.halfOpenMax {
        cb.state = CircuitClosed
        cb.successCount = 0
    }
}

func (cb *CircuitBreaker) State() CircuitState {
    cb.mutex.RLock()
    defer cb.mutex.RUnlock()
    return cb.state
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    breaker := NewCircuitBreaker(3, 30*time.Second)

    for i := 0; i < 10; i++ {
        err := breaker.Call(func() error {
            // æ¨¡æ‹ŸæœåŠ¡è°ƒç”¨
            if i < 5 {
                return fmt.Errorf("service error")
            }
            return nil
        })

        if err != nil {
            fmt.Printf("è°ƒç”¨å¤±è´¥: %v, ç†”æ–­å™¨çŠ¶æ€: %v\n", err, breaker.State())
        } else {
            fmt.Printf("è°ƒç”¨æˆåŠŸ, ç†”æ–­å™¨çŠ¶æ€: %v\n", breaker.State())
        }

        time.Sleep(1 * time.Second)
    }
}
```

### é‡è¯•æœºåˆ¶

```go
package main

import (
    "context"
    "errors"
    "fmt"
    "math"
    "math/rand"
    "time"
)

type RetryConfig struct {
    MaxRetries int
    BaseDelay  time.Duration
    MaxDelay   time.Duration
    Backoff    float64
    Jitter     bool
}

func NewRetryConfig() *RetryConfig {
    return &RetryConfig{
        MaxRetries: 3,
        BaseDelay:  100 * time.Millisecond,
        MaxDelay:   5 * time.Second,
        Backoff:    2.0,
        Jitter:     true,
    }
}

type Retryer struct {
    config *RetryConfig
}

func NewRetryer(config *RetryConfig) *Retryer {
    if config == nil {
        config = NewRetryConfig()
    }
    return &Retryer{config: config}
}

func (r *Retryer) Execute(ctx context.Context, fn func() error) error {
    var lastErr error

    for attempt := 0; attempt <= r.config.MaxRetries; attempt++ {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
        }

        if err := fn(); err != nil {
            lastErr = err

            // æœ€åä¸€æ¬¡é‡è¯•å¤±è´¥
            if attempt == r.config.MaxRetries {
                break
            }

            // è®¡ç®—å»¶è¿Ÿæ—¶é—´
            delay := r.calculateDelay(attempt)

            // ç­‰å¾…é‡è¯•
            select {
            case <-ctx.Done():
                return ctx.Err()
            case <-time.After(delay):
                continue
            }
        } else {
            return nil // æˆåŠŸ
        }
    }

    return fmt.Errorf("é‡è¯•%dæ¬¡åä»ç„¶å¤±è´¥: %w", r.config.MaxRetries, lastErr)
}

func (r *Retryer) calculateDelay(attempt int) time.Duration {
    delay := float64(r.config.BaseDelay) * math.Pow(r.config.Backoff, float64(attempt))

    if delay > float64(r.config.MaxDelay) {
        delay = float64(r.config.MaxDelay)
    }

    if r.config.Jitter {
        // æ·»åŠ Â±25%çš„éšæœºæŠ–åŠ¨
        jitter := delay * 0.25 * (2*rand.Float64() - 1)
        delay += jitter
    }

    return time.Duration(delay)
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    retryer := NewRetryer(NewRetryConfig())

    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    err := retryer.Execute(ctx, func() error {
        // æ¨¡æ‹Ÿå¯èƒ½å¤±è´¥çš„æ“ä½œ
        if rand.Float64() < 0.7 {
            return errors.New("temporary failure")
        }
        fmt.Println("æ“ä½œæˆåŠŸ!")
        return nil
    })

    if err != nil {
        fmt.Printf("æœ€ç»ˆå¤±è´¥: %v\n", err)
    }
}
```

### è¶…æ—¶æ§åˆ¶

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "time"
)

type TimeoutConfig struct {
    ConnectTimeout   time.Duration
    RequestTimeout   time.Duration
    ReadTimeout      time.Duration
    WriteTimeout     time.Duration
}

func NewTimeoutConfig() *TimeoutConfig {
    return &TimeoutConfig{
        ConnectTimeout: 5 * time.Second,
        RequestTimeout: 30 * time.Second,
        ReadTimeout:    10 * time.Second,
        WriteTimeout:   10 * time.Second,
    }
}

type TimeoutHTTPClient struct {
    client *http.Client
    config *TimeoutConfig
}

func NewTimeoutHTTPClient(config *TimeoutConfig) *TimeoutHTTPClient {
    if config == nil {
        config = NewTimeoutConfig()
    }

    client := &http.Client{
        Timeout: config.RequestTimeout,
        Transport: &http.Transport{
            DialContext: (&net.Dialer{
                Timeout: config.ConnectTimeout,
            }).DialContext,
            ResponseHeaderTimeout: config.ReadTimeout,
        },
    }

    return &TimeoutHTTPClient{
        client: client,
        config: config,
    }
}

func (tc *TimeoutHTTPClient) Do(ctx context.Context, req *http.Request) (*http.Response, error) {
    // åˆ›å»ºä¸€ä¸ªå¸¦è¶…æ—¶çš„ä¸Šä¸‹æ–‡
    timeoutCtx, cancel := context.WithTimeout(ctx, tc.config.RequestTimeout)
    defer cancel()

    // å°†è¶…æ—¶ä¸Šä¸‹æ–‡ä¼ é€’ç»™è¯·æ±‚
    req = req.WithContext(timeoutCtx)

    return tc.client.Do(req)
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    client := NewTimeoutHTTPClient(NewTimeoutConfig())

    ctx := context.Background()

    // åˆ›å»ºè¯·æ±‚
    req, err := http.NewRequestWithContext(ctx, "GET", "http://httpbin.org/delay/2", nil)
    if err != nil {
        fmt.Printf("åˆ›å»ºè¯·æ±‚å¤±è´¥: %v\n", err)
        return
    }

    // å‘é€è¯·æ±‚
    resp, err := client.Do(ctx, req)
    if err != nil {
        fmt.Printf("è¯·æ±‚å¤±è´¥: %v\n", err)
        return
    }
    defer resp.Body.Close()

    fmt.Printf("è¯·æ±‚æˆåŠŸï¼ŒçŠ¶æ€ç : %d\n", resp.StatusCode)
}
```

### é™çº§å¤„ç†

```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

type DegradationManager struct {
    fallbacks map[string]func(context.Context) (interface{}, error)
    mutex     sync.RWMutex
}

func NewDegradationManager() *DegradationManager {
    return &DegradationManager{
        fallbacks: make(map[string]func(context.Context) (interface{}, error)),
    }
}

func (dm *DegradationManager) RegisterFallback(name string, fallback func(context.Context) (interface{}, error)) {
    dm.mutex.Lock()
    defer dm.mutex.Unlock()
    dm.fallbacks[name] = fallback
}

func (dm *DegradationManager) ExecuteWithFallback(ctx context.Context, name string, primary func(context.Context) (interface{}, error)) (interface{}, error) {
    // å°è¯•ä¸»è¦åŠŸèƒ½
    result, err := primary(ctx)
    if err == nil {
        return result, nil
    }

    // ä¸»è¦åŠŸèƒ½å¤±è´¥ï¼Œå°è¯•é™çº§
    dm.mutex.RLock()
    fallback, exists := dm.fallbacks[name]
    dm.mutex.RUnlock()

    if !exists {
        return nil, fmt.Errorf("ä¸»è¦åŠŸèƒ½å¤±è´¥ä¸”æ— é™çº§ç­–ç•¥: %w", err)
    }

    fmt.Printf("ä¸»è¦åŠŸèƒ½å¤±è´¥ï¼Œå¯ç”¨é™çº§ç­–ç•¥: %s\n", name)
    return fallback(ctx)
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    dm := NewDegradationManager()

    // æ³¨å†Œé™çº§ç­–ç•¥
    dm.RegisterFallback("user_service", func(ctx context.Context) (interface{}, error) {
        // è¿”å›ç¼“å­˜çš„ç”¨æˆ·æ•°æ®
        return map[string]interface{}{
            "id":    1,
            "name":  "ç¼“å­˜ç”¨æˆ·",
            "email": "cached@example.com",
        }, nil
    })

    dm.RegisterFallback("notification_service", func(ctx context.Context) (interface{}, error) {
        // é™çº§åˆ°é‚®ä»¶é€šçŸ¥
        fmt.Println("é™çº§åˆ°é‚®ä»¶é€šçŸ¥")
        return "é‚®ä»¶å·²å‘é€", nil
    })

    // æ¨¡æ‹Ÿä¸»è¦åŠŸèƒ½å¤±è´¥
    result, err := dm.ExecuteWithFallback(
        context.Background(),
        "user_service",
        func(ctx context.Context) (interface{}, error) {
            // æ¨¡æ‹Ÿç½‘ç»œé”™è¯¯
            return nil, fmt.Errorf("ç½‘ç»œè¿æ¥å¤±è´¥")
        },
    )

    if err != nil {
        fmt.Printf("æ‰§è¡Œå¤±è´¥: %v\n", err)
    } else {
        fmt.Printf("æ‰§è¡ŒæˆåŠŸ: %v\n", result)
    }
}
```

## ğŸ¯ æœ€ä½³å®è·µ

1. **ç†”æ–­å™¨é…ç½®**
   - åˆç†è®¾ç½®å¤±è´¥é˜ˆå€¼
   - é€‚å½“çš„è¶…æ—¶æ—¶é—´
   - ç›‘æ§ç†”æ–­å™¨çŠ¶æ€

2. **é‡è¯•ç­–ç•¥**
   - ä½¿ç”¨æŒ‡æ•°é€€é¿
   - æ·»åŠ éšæœºæŠ–åŠ¨
   - è®¾ç½®æœ€å¤§é‡è¯•æ¬¡æ•°

3. **è¶…æ—¶æ§åˆ¶**
   - åˆ†å±‚è®¾ç½®è¶…æ—¶æ—¶é—´
   - ä½¿ç”¨ä¸Šä¸‹æ–‡ä¼ é€’è¶…æ—¶
   - ç›‘æ§è¶…æ—¶æƒ…å†µ

4. **é™çº§ç­–ç•¥**
   - é¢„å…ˆè®¾è®¡é™çº§æ–¹æ¡ˆ
   - å¿«é€Ÿåˆ‡æ¢é™çº§ç­–ç•¥
   - ä¿ç•™æ ¸å¿ƒåŠŸèƒ½

## ğŸ” å¸¸è§é—®é¢˜

1. **ç†”æ–­å™¨è¯¯è§¦å‘**
   - è°ƒæ•´å¤±è´¥é˜ˆå€¼
   - åŒºåˆ†ä¸´æ—¶å’Œæ°¸ä¹…æ•…éšœ
   - æ·»åŠ ç™½åå•æœºåˆ¶

2. **é‡è¯•é£æš´**
   - æ§åˆ¶é‡è¯•é¢‘ç‡
   - ä½¿ç”¨é€€é¿ç­–ç•¥
   - æ·»åŠ é‡è¯•é™åˆ¶

3. **è¶…æ—¶è®¾ç½®ä¸å½“**
   - æ ¹æ®ä¸šåŠ¡åœºæ™¯è®¾ç½®
   - è€ƒè™‘ç½‘ç»œå»¶è¿Ÿ
   - ç›‘æ§è¶…æ—¶åˆ†å¸ƒ

4. **é™çº§ç­–ç•¥å¤æ‚**
   - ç®€åŒ–é™çº§é€»è¾‘
   - æµ‹è¯•é™çº§åœºæ™¯
   - æ–‡æ¡£åŒ–é™çº§æµç¨‹

## ğŸ“š æ‰©å±•é˜…è¯»

- [Hystrixç†”æ–­å™¨](https://github.com/Netflix/Hystrix)
- [Sentinelæµé‡æ§åˆ¶](https://sentinelguard.io/)
- [Resilience4j](https://resilience4j.readme.io/)
- [å¾®æœåŠ¡å®¹é”™æ¨¡å¼](https://microservices.io/patterns/reliability/circuit-breaker.html)

## âœ… è½åœ°æ£€æŸ¥æ¸…å•

- ç†”æ–­å™¨é…ç½®ï¼šå¤±è´¥é˜ˆå€¼ã€è¶…æ—¶æ—¶é—´ã€çŠ¶æ€ç›‘æ§
- é‡è¯•ç­–ç•¥ï¼šé€€é¿ç®—æ³•ã€æŠ–åŠ¨ã€æœ€å¤§é‡è¯•æ¬¡æ•°
- è¶…æ—¶æ§åˆ¶ï¼šè¿æ¥è¶…æ—¶ã€è¯·æ±‚è¶…æ—¶ã€åˆ†å±‚è¶…æ—¶
- é™çº§ç­–ç•¥ï¼šé™çº§æ–¹æ¡ˆã€åˆ‡æ¢æœºåˆ¶ã€æ ¸å¿ƒåŠŸèƒ½ä¿ç•™
- ç›‘æ§å‘Šè­¦ï¼šç†”æ–­çŠ¶æ€ã€é‡è¯•æ¬¡æ•°ã€è¶…æ—¶åˆ†å¸ƒ
- æµ‹è¯•éªŒè¯ï¼šæ•…éšœæ³¨å…¥ã€å‹åŠ›æµ‹è¯•ã€é™çº§æ¼”ç»ƒ

## ğŸ§ª æœ¬åœ°å¿«é€ŸéªŒè¯

1. è¿è¡Œç†”æ–­å™¨ç¤ºä¾‹ï¼Œè§‚å¯ŸçŠ¶æ€åˆ‡æ¢
2. è¿è¡Œé‡è¯•æœºåˆ¶ç¤ºä¾‹ï¼ŒéªŒè¯é€€é¿ç­–ç•¥
3. è¿è¡Œè¶…æ—¶æ§åˆ¶ç¤ºä¾‹ï¼Œæµ‹è¯•è¶…æ—¶å¤„ç†
4. è¿è¡Œé™çº§å¤„ç†ç¤ºä¾‹ï¼ŒéªŒè¯é™çº§é€»è¾‘
5. æ¨¡æ‹Ÿç½‘ç»œæ•…éšœï¼Œæµ‹è¯•å®¹é”™æœºåˆ¶
6. ä½¿ç”¨å‹æµ‹å·¥å…·éªŒè¯å®¹é”™æ€§èƒ½

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team
**æœ€åæ›´æ–°**: 2025-10-29
**æ–‡æ¡£çŠ¶æ€**: å®Œæˆ
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
