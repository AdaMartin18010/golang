# 容错处理与熔断

**版本**: v1.0
**更新日期**: 2025-10-29
**适用于**: Go 1.23+

---

## 📋 目录

- [容错处理与熔断](#容错处理与熔断)
  - [📋 目录](#-目录)
  - [📚 理论分析](#-理论分析)
    - [容错模式](#容错模式)
      - [故障转移（Failover）](#故障转移failover)
      - [隔离模式（Bulkhead）](#隔离模式bulkhead)
    - [熔断器模式](#熔断器模式)
    - [重试策略](#重试策略)
      - [指数退避](#指数退避)
    - [降级策略](#降级策略)
  - [💻 代码示例](#-代码示例)
    - [熔断器实现](#熔断器实现)
    - [重试机制](#重试机制)
    - [超时控制](#超时控制)
    - [降级处理](#降级处理)
  - [🎯 最佳实践](#-最佳实践)
  - [🔍 常见问题](#-常见问题)
  - [📚 扩展阅读](#-扩展阅读)
  - [✅ 落地检查清单](#-落地检查清单)
  - [🧪 本地快速验证](#-本地快速验证)

## 📚 理论分析

### 容错模式

#### 故障转移（Failover）

- 主备切换：主服务故障时切换到备用服务
- 快速失败：检测到故障立即返回错误
- 优雅降级：减少功能而非完全失败

#### 隔离模式（Bulkhead）

- 线程池隔离：不同服务使用独立的线程池
- 资源隔离：限制单个服务的资源使用
- 数据隔离：避免共享资源导致的连锁故障

### 熔断器模式

熔断器有三种状态：

- **关闭（Closed）**：正常请求通过
- **打开（Open）**：快速失败，不调用下游服务
- **半开（Half-Open）**：尝试少量请求测试服务恢复

### 重试策略

#### 指数退避

- 重试间隔逐渐增加：1s, 2s, 4s, 8s
- 避免对下游服务造成压力
- 添加随机抖动避免惊群效应

### 降级策略

- **功能降级**：关闭非核心功能
- **数据降级**：使用缓存数据而非实时数据
- **服务降级**：使用备用服务或默认响应

## 💻 代码示例

### 熔断器实现

```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

type CircuitState int

const (
    CircuitClosed CircuitState = iota
    CircuitOpen
    CircuitHalfOpen
)

type CircuitBreaker struct {
    maxFailures    int
    timeout        time.Duration
    failures       int
    lastFailure    time.Time
    state          CircuitState
    mutex          sync.RWMutex
    successCount   int
    halfOpenMax    int
}

func NewCircuitBreaker(maxFailures int, timeout time.Duration) *CircuitBreaker {
    return &CircuitBreaker{
        maxFailures: maxFailures,
        timeout:     timeout,
        state:       CircuitClosed,
        halfOpenMax: 3,
    }
}

func (cb *CircuitBreaker) Call(fn func() error) error {
    cb.mutex.Lock()
    defer cb.mutex.Unlock()

    if cb.state == CircuitOpen {
        if time.Since(cb.lastFailure) > cb.timeout {
            cb.state = CircuitHalfOpen
            cb.successCount = 0
        } else {
            return fmt.Errorf("circuit breaker is open")
        }
    }

    err := fn()

    if err != nil {
        cb.onFailure()
        return err
    }

    cb.onSuccess()
    return nil
}

func (cb *CircuitBreaker) onFailure() {
    cb.failures++
    cb.lastFailure = time.Now()

    if cb.failures >= cb.maxFailures {
        cb.state = CircuitOpen
    }
}

func (cb *CircuitBreaker) onSuccess() {
    cb.failures = 0
    cb.successCount++

    if cb.state == CircuitHalfOpen && cb.successCount >= cb.halfOpenMax {
        cb.state = CircuitClosed
        cb.successCount = 0
    }
}

func (cb *CircuitBreaker) State() CircuitState {
    cb.mutex.RLock()
    defer cb.mutex.RUnlock()
    return cb.state
}

// 使用示例
func main() {
    breaker := NewCircuitBreaker(3, 30*time.Second)

    for i := 0; i < 10; i++ {
        err := breaker.Call(func() error {
            // 模拟服务调用
            if i < 5 {
                return fmt.Errorf("service error")
            }
            return nil
        })

        if err != nil {
            fmt.Printf("调用失败: %v, 熔断器状态: %v\n", err, breaker.State())
        } else {
            fmt.Printf("调用成功, 熔断器状态: %v\n", breaker.State())
        }

        time.Sleep(1 * time.Second)
    }
}
```

### 重试机制

```go
package main

import (
    "context"
    "errors"
    "fmt"
    "math"
    "math/rand"
    "time"
)

type RetryConfig struct {
    MaxRetries int
    BaseDelay  time.Duration
    MaxDelay   time.Duration
    Backoff    float64
    Jitter     bool
}

func NewRetryConfig() *RetryConfig {
    return &RetryConfig{
        MaxRetries: 3,
        BaseDelay:  100 * time.Millisecond,
        MaxDelay:   5 * time.Second,
        Backoff:    2.0,
        Jitter:     true,
    }
}

type Retryer struct {
    config *RetryConfig
}

func NewRetryer(config *RetryConfig) *Retryer {
    if config == nil {
        config = NewRetryConfig()
    }
    return &Retryer{config: config}
}

func (r *Retryer) Execute(ctx context.Context, fn func() error) error {
    var lastErr error

    for attempt := 0; attempt <= r.config.MaxRetries; attempt++ {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
        }

        if err := fn(); err != nil {
            lastErr = err

            // 最后一次重试失败
            if attempt == r.config.MaxRetries {
                break
            }

            // 计算延迟时间
            delay := r.calculateDelay(attempt)

            // 等待重试
            select {
            case <-ctx.Done():
                return ctx.Err()
            case <-time.After(delay):
                continue
            }
        } else {
            return nil // 成功
        }
    }

    return fmt.Errorf("重试%d次后仍然失败: %w", r.config.MaxRetries, lastErr)
}

func (r *Retryer) calculateDelay(attempt int) time.Duration {
    delay := float64(r.config.BaseDelay) * math.Pow(r.config.Backoff, float64(attempt))

    if delay > float64(r.config.MaxDelay) {
        delay = float64(r.config.MaxDelay)
    }

    if r.config.Jitter {
        // 添加±25%的随机抖动
        jitter := delay * 0.25 * (2*rand.Float64() - 1)
        delay += jitter
    }

    return time.Duration(delay)
}

// 使用示例
func main() {
    retryer := NewRetryer(NewRetryConfig())

    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    err := retryer.Execute(ctx, func() error {
        // 模拟可能失败的操作
        if rand.Float64() < 0.7 {
            return errors.New("temporary failure")
        }
        fmt.Println("操作成功!")
        return nil
    })

    if err != nil {
        fmt.Printf("最终失败: %v\n", err)
    }
}
```

### 超时控制

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "time"
)

type TimeoutConfig struct {
    ConnectTimeout   time.Duration
    RequestTimeout   time.Duration
    ReadTimeout      time.Duration
    WriteTimeout     time.Duration
}

func NewTimeoutConfig() *TimeoutConfig {
    return &TimeoutConfig{
        ConnectTimeout: 5 * time.Second,
        RequestTimeout: 30 * time.Second,
        ReadTimeout:    10 * time.Second,
        WriteTimeout:   10 * time.Second,
    }
}

type TimeoutHTTPClient struct {
    client *http.Client
    config *TimeoutConfig
}

func NewTimeoutHTTPClient(config *TimeoutConfig) *TimeoutHTTPClient {
    if config == nil {
        config = NewTimeoutConfig()
    }

    client := &http.Client{
        Timeout: config.RequestTimeout,
        Transport: &http.Transport{
            DialContext: (&net.Dialer{
                Timeout: config.ConnectTimeout,
            }).DialContext,
            ResponseHeaderTimeout: config.ReadTimeout,
        },
    }

    return &TimeoutHTTPClient{
        client: client,
        config: config,
    }
}

func (tc *TimeoutHTTPClient) Do(ctx context.Context, req *http.Request) (*http.Response, error) {
    // 创建一个带超时的上下文
    timeoutCtx, cancel := context.WithTimeout(ctx, tc.config.RequestTimeout)
    defer cancel()

    // 将超时上下文传递给请求
    req = req.WithContext(timeoutCtx)

    return tc.client.Do(req)
}

// 使用示例
func main() {
    client := NewTimeoutHTTPClient(NewTimeoutConfig())

    ctx := context.Background()

    // 创建请求
    req, err := http.NewRequestWithContext(ctx, "GET", "http://httpbin.org/delay/2", nil)
    if err != nil {
        fmt.Printf("创建请求失败: %v\n", err)
        return
    }

    // 发送请求
    resp, err := client.Do(ctx, req)
    if err != nil {
        fmt.Printf("请求失败: %v\n", err)
        return
    }
    defer resp.Body.Close()

    fmt.Printf("请求成功，状态码: %d\n", resp.StatusCode)
}
```

### 降级处理

```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

type DegradationManager struct {
    fallbacks map[string]func(context.Context) (interface{}, error)
    mutex     sync.RWMutex
}

func NewDegradationManager() *DegradationManager {
    return &DegradationManager{
        fallbacks: make(map[string]func(context.Context) (interface{}, error)),
    }
}

func (dm *DegradationManager) RegisterFallback(name string, fallback func(context.Context) (interface{}, error)) {
    dm.mutex.Lock()
    defer dm.mutex.Unlock()
    dm.fallbacks[name] = fallback
}

func (dm *DegradationManager) ExecuteWithFallback(ctx context.Context, name string, primary func(context.Context) (interface{}, error)) (interface{}, error) {
    // 尝试主要功能
    result, err := primary(ctx)
    if err == nil {
        return result, nil
    }

    // 主要功能失败，尝试降级
    dm.mutex.RLock()
    fallback, exists := dm.fallbacks[name]
    dm.mutex.RUnlock()

    if !exists {
        return nil, fmt.Errorf("主要功能失败且无降级策略: %w", err)
    }

    fmt.Printf("主要功能失败，启用降级策略: %s\n", name)
    return fallback(ctx)
}

// 使用示例
func main() {
    dm := NewDegradationManager()

    // 注册降级策略
    dm.RegisterFallback("user_service", func(ctx context.Context) (interface{}, error) {
        // 返回缓存的用户数据
        return map[string]interface{}{
            "id":    1,
            "name":  "缓存用户",
            "email": "cached@example.com",
        }, nil
    })

    dm.RegisterFallback("notification_service", func(ctx context.Context) (interface{}, error) {
        // 降级到邮件通知
        fmt.Println("降级到邮件通知")
        return "邮件已发送", nil
    })

    // 模拟主要功能失败
    result, err := dm.ExecuteWithFallback(
        context.Background(),
        "user_service",
        func(ctx context.Context) (interface{}, error) {
            // 模拟网络错误
            return nil, fmt.Errorf("网络连接失败")
        },
    )

    if err != nil {
        fmt.Printf("执行失败: %v\n", err)
    } else {
        fmt.Printf("执行成功: %v\n", result)
    }
}
```

## 🎯 最佳实践

1. **熔断器配置**
   - 合理设置失败阈值
   - 适当的超时时间
   - 监控熔断器状态

2. **重试策略**
   - 使用指数退避
   - 添加随机抖动
   - 设置最大重试次数

3. **超时控制**
   - 分层设置超时时间
   - 使用上下文传递超时
   - 监控超时情况

4. **降级策略**
   - 预先设计降级方案
   - 快速切换降级策略
   - 保留核心功能

## 🔍 常见问题

1. **熔断器误触发**
   - 调整失败阈值
   - 区分临时和永久故障
   - 添加白名单机制

2. **重试风暴**
   - 控制重试频率
   - 使用退避策略
   - 添加重试限制

3. **超时设置不当**
   - 根据业务场景设置
   - 考虑网络延迟
   - 监控超时分布

4. **降级策略复杂**
   - 简化降级逻辑
   - 测试降级场景
   - 文档化降级流程

## 📚 扩展阅读

- [Hystrix熔断器](https://github.com/Netflix/Hystrix)
- [Sentinel流量控制](https://sentinelguard.io/)
- [Resilience4j](https://resilience4j.readme.io/)
- [微服务容错模式](https://microservices.io/patterns/reliability/circuit-breaker.html)

## ✅ 落地检查清单

- 熔断器配置：失败阈值、超时时间、状态监控
- 重试策略：退避算法、抖动、最大重试次数
- 超时控制：连接超时、请求超时、分层超时
- 降级策略：降级方案、切换机制、核心功能保留
- 监控告警：熔断状态、重试次数、超时分布
- 测试验证：故障注入、压力测试、降级演练

## 🧪 本地快速验证

1. 运行熔断器示例，观察状态切换
2. 运行重试机制示例，验证退避策略
3. 运行超时控制示例，测试超时处理
4. 运行降级处理示例，验证降级逻辑
5. 模拟网络故障，测试容错机制
6. 使用压测工具验证容错性能

---

**文档维护者**: Go Documentation Team
**最后更新**: 2025-10-29
**文档状态**: 完成
**适用版本**: Go 1.25.3+
