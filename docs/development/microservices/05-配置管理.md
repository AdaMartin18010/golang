# 配置管理

> **简介**: 微服务配置管理最佳实践，掌握Consul、etcd配置中心和配置热更新技术
> **版本**: Go 1.23+  
> **难度**: ⭐⭐⭐⭐  
> **标签**: #微服务 #配置管理 #Consul #热更新

<!-- TOC START -->
- [配置管理](#配置管理)
  - [📚 理论分析](#-理论分析)
    - [配置管理挑战](#配置管理挑战)
    - [配置中心架构](#配置中心架构)
    - [配置分类与策略](#配置分类与策略)
    - [配置安全与权限](#配置安全与权限)
  - [💻 代码示例](#-代码示例)
    - [Consul配置中心](#consul配置中心)
    - [etcd配置管理](#etcd配置管理)
    - [配置热更新](#配置热更新)
    - [配置加密与解密](#配置加密与解密)
  - [🎯 最佳实践](#-最佳实践)
  - [🔍 常见问题](#-常见问题)
  - [📚 扩展阅读](#-扩展阅读)
  - [✅ 落地检查清单](#-落地检查清单)
  - [🧪 本地快速验证](#-本地快速验证)
<!-- TOC END -->


## 📋 目录

- [1. 📚 理论分析](#-理论分析)
- [2. 💻 代码示例](#-代码示例)
- [3. 🎯 最佳实践](#-最佳实践)
- [4. 🔍 常见问题](#-常见问题)
- [5. 📚 扩展阅读](#-扩展阅读)
- [6. ✅ 落地检查清单](#-落地检查清单)
- [7. 🧪 本地快速验证](#-本地快速验证)

---

## 📚 理论分析

### 配置管理挑战

微服务架构中的配置管理面临以下挑战：

- **配置分散**：多个服务需要不同的配置
- **环境隔离**：开发、测试、生产环境配置差异
- **动态更新**：运行时配置变更需求
- **安全敏感**：数据库密码、API密钥等敏感信息
- **版本管理**：配置变更的版本控制和回滚
- **一致性保证**：多实例配置同步问题

### 配置中心架构

```text
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   配置中心       │    │   配置客户端     │    │   微服务实例    │
│                 │    │                 │    │                 │
│  Consul/etcd    │◀───│  SDK/Watch      │◀───│  应用配置       │
│  Nacos/Apollo   │    │  热更新          │    │  环境变量       │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 配置分类与策略

| 配置类型 | 特点 | 管理策略 | 示例 |
|----------|------|----------|------|
| 静态配置 | 启动时确定，运行时不变 | 版本控制、环境隔离 | 服务端口、日志级别 |
| 动态配置 | 运行时可变 | 热更新、版本管理 | 限流阈值、功能开关 |
| 敏感配置 | 包含密码、密钥 | 加密存储、权限控制 | 数据库密码、API密钥 |
| 业务配置 | 业务逻辑相关 | 业务团队管理 | 业务规则、阈值参数 |

### 配置安全与权限

- **加密存储**：敏感配置加密后存储
- **访问控制**：基于角色的配置访问权限
- **审计日志**：配置变更的完整审计
- **密钥轮换**：定期更新敏感配置
- **最小权限**：服务只能访问必要的配置

## 💻 代码示例

### Consul配置中心

```go
package main

import (
    "encoding/json"
    "fmt"
    "log"
    "time"

    "github.com/hashicorp/consul/api"
)

type ConfigManager struct {
    client *api.Client
    prefix string
}

type AppConfig struct {
    Database struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Username string `json:"username"`
        Password string `json:"password"`
        Database string `json:"database"`
    } `json:"database"`
    
    Redis struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Password string `json:"password"`
    } `json:"redis"`
    
    Service struct {
        Name    string `json:"name"`
        Version string `json:"version"`
        Port    int    `json:"port"`
    } `json:"service"`
}

func NewConfigManager(address, prefix string) (*ConfigManager, error) {
    config := api.DefaultConfig()
    config.Address = address
    
    client, err := api.NewClient(config)
    if err != nil {
        return nil, err
    }
    
    return &ConfigManager{
        client: client,
        prefix: prefix,
    }, nil
}

func (cm *ConfigManager) GetConfig(key string) (string, error) {
    kv, _, err := cm.client.KV().Get(cm.prefix+key, nil)
    if err != nil {
        return "", err
    }
    
    if kv == nil {
        return "", fmt.Errorf("配置不存在: %s", key)
    }
    
    return string(kv.Value), nil
}

func (cm *ConfigManager) SetConfig(key, value string) error {
    _, err := cm.client.KV().Put(&api.KVPair{
        Key:   cm.prefix + key,
        Value: []byte(value),
    }, nil)
    
    return err
}

func (cm *ConfigManager) GetAppConfig() (*AppConfig, error) {
    configData, err := cm.GetConfig("app.json")
    if err != nil {
        return nil, err
    }
    
    var config AppConfig
    if err := json.Unmarshal([]byte(configData), &config); err != nil {
        return nil, err
    }
    
    return &config, nil
}

func (cm *ConfigManager) SetAppConfig(config *AppConfig) error {
    configData, err := json.MarshalIndent(config, "", "  ")
    if err != nil {
        return err
    }
    
    return cm.SetConfig("app.json", string(configData))
}

func (cm *ConfigManager) WatchConfig(key string, callback func(string)) error {
    queryOptions := &api.QueryOptions{
        WaitIndex: 0,
        WaitTime:  10 * time.Second,
    }
    
    go func() {
        for {
            kv, meta, err := cm.client.KV().Get(cm.prefix+key, queryOptions)
            if err != nil {
                log.Printf("监听配置失败: %v", err)
                time.Sleep(5 * time.Second)
                continue
            }
            
            if kv != nil {
                callback(string(kv.Value))
            }
            
            queryOptions.WaitIndex = meta.LastIndex
        }
    }()
    
    return nil
}

// 使用示例
func main() {
    // 创建配置管理器
    cm, err := NewConfigManager("localhost:8500", "config/")
    if err != nil {
        log.Fatal(err)
    }
    
    // 设置初始配置
    config := &AppConfig{}
    config.Database.Host = "localhost"
    config.Database.Port = 5432
    config.Database.Username = "user"
    config.Database.Password = "password"
    config.Database.Database = "mydb"
    
    config.Redis.Host = "localhost"
    config.Redis.Port = 6379
    config.Redis.Password = ""
    
    config.Service.Name = "user-service"
    config.Service.Version = "1.0.0"
    config.Service.Port = 8080
    
    if err := cm.SetAppConfig(config); err != nil {
        log.Fatal(err)
    }
    
    // 获取配置
    appConfig, err := cm.GetAppConfig()
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("应用配置: %+v\n", appConfig)
    
    // 监听配置变更
    cm.WatchConfig("app.json", func(value string) {
        var newConfig AppConfig
        if err := json.Unmarshal([]byte(value), &newConfig); err != nil {
            log.Printf("解析新配置失败: %v", err)
            return
        }
        
        fmt.Printf("配置已更新: %+v\n", newConfig)
        // 这里可以重新加载配置
    })
    
    // 保持运行
    select {}
}
```

### etcd配置管理

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "time"

    "go.etcd.io/etcd/clientv3"
)

type EtcdConfigManager struct {
    client *clientv3.Client
    prefix string
}

func NewEtcdConfigManager(endpoints []string, prefix string) (*EtcdConfigManager, error) {
    client, err := clientv3.New(clientv3.Config{
        Endpoints:   endpoints,
        DialTimeout: 5 * time.Second,
    })
    if err != nil {
        return nil, err
    }
    
    return &EtcdConfigManager{
        client: client,
        prefix: prefix,
    }, nil
}

func (ecm *EtcdConfigManager) GetConfig(key string) (string, error) {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    resp, err := ecm.client.Get(ctx, ecm.prefix+key)
    if err != nil {
        return "", err
    }
    
    if len(resp.Kvs) == 0 {
        return "", fmt.Errorf("配置不存在: %s", key)
    }
    
    return string(resp.Kvs[0].Value), nil
}

func (ecm *EtcdConfigManager) SetConfig(key, value string) error {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    _, err := ecm.client.Put(ctx, ecm.prefix+key, value)
    return err
}

func (ecm *EtcdConfigManager) WatchConfig(key string, callback func(string)) error {
    go func() {
        watchCh := ecm.client.Watch(context.Background(), ecm.prefix+key)
        
        for wresp := range watchCh {
            for _, ev := range wresp.Events {
                if ev.Type == clientv3.EventTypePut {
                    callback(string(ev.Kv.Value))
                }
            }
        }
    }()
    
    return nil
}

func (ecm *EtcdConfigManager) GetConfigsWithPrefix(prefix string) (map[string]string, error) {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    resp, err := ecm.client.Get(ctx, ecm.prefix+prefix, clientv3.WithPrefix())
    if err != nil {
        return nil, err
    }
    
    configs := make(map[string]string)
    for _, kv := range resp.Kvs {
        key := string(kv.Key)
        value := string(kv.Value)
        configs[key] = value
    }
    
    return configs, nil
}

func (ecm *EtcdConfigManager) Close() error {
    return ecm.client.Close()
}

// 使用示例
func main() {
    // 创建etcd配置管理器
    ecm, err := NewEtcdConfigManager([]string{"localhost:2379"}, "config/")
    if err != nil {
        log.Fatal(err)
    }
    defer ecm.Close()
    
    // 设置配置
    configs := map[string]string{
        "database.host":     "localhost",
        "database.port":     "5432",
        "database.username": "user",
        "database.password": "password",
        "redis.host":        "localhost",
        "redis.port":        "6379",
        "service.name":      "user-service",
        "service.port":      "8080",
    }
    
    for key, value := range configs {
        if err := ecm.SetConfig(key, value); err != nil {
            log.Printf("设置配置失败 %s: %v", key, err)
        }
    }
    
    // 获取单个配置
    host, err := ecm.GetConfig("database.host")
    if err != nil {
        log.Printf("获取配置失败: %v", err)
    } else {
        fmt.Printf("数据库主机: %s\n", host)
    }
    
    // 获取所有配置
    allConfigs, err := ecm.GetConfigsWithPrefix("")
    if err != nil {
        log.Printf("获取所有配置失败: %v", err)
    } else {
        fmt.Printf("所有配置: %+v\n", allConfigs)
    }
    
    // 监听配置变更
    ecm.WatchConfig("database.host", func(value string) {
        fmt.Printf("数据库主机已更新为: %s\n", value)
    })
    
    // 保持运行
    select {}
}
```

### 配置热更新

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "sync"
    "time"
)

type Config struct {
    Database struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Username string `json:"username"`
        Password string `json:"password"`
    } `json:"database"`
    
    Redis struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Password string `json:"password"`
    } `json:"redis"`
    
    Service struct {
        Name    string `json:"name"`
        Version string `json:"version"`
        Port    int    `json:"port"`
    } `json:"service"`
    
    Features struct {
        EnableCache    bool `json:"enable_cache"`
        EnableMetrics  bool `json:"enable_metrics"`
        MaxConnections int  `json:"max_connections"`
    } `json:"features"`
}

type ConfigManager struct {
    config      *Config
    mutex       sync.RWMutex
    watchers    []func(*Config)
    watcherMutex sync.RWMutex
}

func NewConfigManager() *ConfigManager {
    return &ConfigManager{
        config:   &Config{},
        watchers: make([]func(*Config), 0),
    }
}

func (cm *ConfigManager) GetConfig() *Config {
    cm.mutex.RLock()
    defer cm.mutex.RUnlock()
    
    // 返回配置的副本
    configCopy := *cm.config
    return &configCopy
}

func (cm *ConfigManager) UpdateConfig(configData []byte) error {
    var newConfig Config
    if err := json.Unmarshal(configData, &newConfig); err != nil {
        return err
    }
    
    cm.mutex.Lock()
    oldConfig := cm.config
    cm.config = &newConfig
    cm.mutex.Unlock()
    
    // 通知所有观察者
    cm.notifyWatchers(&newConfig)
    
    log.Printf("配置已更新，旧配置: %+v, 新配置: %+v", oldConfig, &newConfig)
    
    return nil
}

func (cm *ConfigManager) AddWatcher(watcher func(*Config)) {
    cm.watcherMutex.Lock()
    defer cm.watcherMutex.Unlock()
    
    cm.watchers = append(cm.watchers, watcher)
}

func (cm *ConfigManager) notifyWatchers(config *Config) {
    cm.watcherMutex.RLock()
    watchers := make([]func(*Config), len(cm.watchers))
    copy(watchers, cm.watchers)
    cm.watcherMutex.RUnlock()
    
    for _, watcher := range watchers {
        go watcher(config)
    }
}

// 配置热更新服务
type ConfigUpdateService struct {
    configManager *ConfigManager
    updateChannel chan []byte
}

func NewConfigUpdateService(configManager *ConfigManager) *ConfigUpdateService {
    return &ConfigUpdateService{
        configManager: configManager,
        updateChannel: make(chan []byte, 100),
    }
}

func (cus *ConfigUpdateService) Start(ctx context.Context) {
    go func() {
        for {
            select {
            case configData := <-cus.updateChannel:
                if err := cus.configManager.UpdateConfig(configData); err != nil {
                    log.Printf("更新配置失败: %v", err)
                }
            case <-ctx.Done():
                return
            }
        }
    }()
}

func (cus *ConfigUpdateService) UpdateConfig(configData []byte) {
    select {
    case cus.updateChannel <- configData:
    default:
        log.Printf("配置更新通道已满，丢弃更新")
    }
}

// 使用示例
func main() {
    configManager := NewConfigManager()
    updateService := NewConfigUpdateService(configManager)
    
    // 启动配置更新服务
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    updateService.Start(ctx)
    
    // 添加配置观察者
    configManager.AddWatcher(func(config *Config) {
        fmt.Printf("配置观察者1收到更新: %+v\n", config)
    })
    
    configManager.AddWatcher(func(config *Config) {
        fmt.Printf("配置观察者2收到更新: %+v\n", config)
    })
    
    // 模拟配置更新
    config1 := Config{}
    config1.Database.Host = "localhost"
    config1.Database.Port = 5432
    config1.Service.Name = "user-service"
    config1.Features.EnableCache = true
    
    configData1, _ := json.Marshal(config1)
    updateService.UpdateConfig(configData1)
    
    time.Sleep(1 * time.Second)
    
    // 再次更新配置
    config2 := Config{}
    config2.Database.Host = "remote-host"
    config2.Database.Port = 3306
    config2.Service.Name = "user-service-v2"
    config2.Features.EnableCache = false
    config2.Features.MaxConnections = 100
    
    configData2, _ := json.Marshal(config2)
    updateService.UpdateConfig(configData2)
    
    time.Sleep(1 * time.Second)
    
    // 获取当前配置
    currentConfig := configManager.GetConfig()
    fmt.Printf("当前配置: %+v\n", currentConfig)
}
```

### 配置加密与解密

```go
package main

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "encoding/base64"
    "encoding/json"
    "fmt"
    "io"
    "log"
)

type EncryptedConfig struct {
    EncryptedData string `json:"encrypted_data"`
    KeyID         string `json:"key_id"`
}

type ConfigEncryption struct {
    keys map[string][]byte
}

func NewConfigEncryption() *ConfigEncryption {
    return &ConfigEncryption{
        keys: make(map[string][]byte),
    }
}

func (ce *ConfigEncryption) AddKey(keyID string, key []byte) {
    ce.keys[keyID] = key
}

func (ce *ConfigEncryption) EncryptConfig(config interface{}, keyID string) (*EncryptedConfig, error) {
    key, exists := ce.keys[keyID]
    if !exists {
        return nil, fmt.Errorf("密钥不存在: %s", keyID)
    }
    
    // 序列化配置
    configData, err := json.Marshal(config)
    if err != nil {
        return nil, err
    }
    
    // 加密数据
    encryptedData, err := ce.encrypt(configData, key)
    if err != nil {
        return nil, err
    }
    
    return &EncryptedConfig{
        EncryptedData: base64.StdEncoding.EncodeToString(encryptedData),
        KeyID:         keyID,
    }, nil
}

func (ce *ConfigEncryption) DecryptConfig(encryptedConfig *EncryptedConfig, target interface{}) error {
    key, exists := ce.keys[encryptedConfig.KeyID]
    if !exists {
        return fmt.Errorf("密钥不存在: %s", encryptedConfig.KeyID)
    }
    
    // 解码base64
    encryptedData, err := base64.StdEncoding.DecodeString(encryptedConfig.EncryptedData)
    if err != nil {
        return err
    }
    
    // 解密数据
    decryptedData, err := ce.decrypt(encryptedData, key)
    if err != nil {
        return err
    }
    
    // 反序列化配置
    return json.Unmarshal(decryptedData, target)
}

func (ce *ConfigEncryption) encrypt(data []byte, key []byte) ([]byte, error) {
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }
    
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }
    
    nonce := make([]byte, gcm.NonceSize())
    if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
        return nil, err
    }
    
    ciphertext := gcm.Seal(nonce, nonce, data, nil)
    return ciphertext, nil
}

func (ce *ConfigEncryption) decrypt(data []byte, key []byte) ([]byte, error) {
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }
    
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }
    
    nonceSize := gcm.NonceSize()
    if len(data) < nonceSize {
        return nil, fmt.Errorf("密文太短")
    }
    
    nonce, ciphertext := data[:nonceSize], data[nonceSize:]
    plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return nil, err
    }
    
    return plaintext, nil
}

// 使用示例
func main() {
    encryption := NewConfigEncryption()
    
    // 生成密钥（实际应用中应该从安全的地方获取）
    key := make([]byte, 32) // AES-256
    if _, err := io.ReadFull(rand.Reader, key); err != nil {
        log.Fatal(err)
    }
    
    encryption.AddKey("key1", key)
    
    // 配置数据
    config := map[string]interface{}{
        "database": map[string]interface{}{
            "host":     "localhost",
            "port":     5432,
            "username": "user",
            "password": "secret_password",
        },
        "api_key": "sk-1234567890abcdef",
    }
    
    // 加密配置
    encryptedConfig, err := encryption.EncryptConfig(config, "key1")
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("加密后的配置: %+v\n", encryptedConfig)
    
    // 解密配置
    var decryptedConfig map[string]interface{}
    if err := encryption.DecryptConfig(encryptedConfig, &decryptedConfig); err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("解密后的配置: %+v\n", decryptedConfig)
}
```

## 🎯 最佳实践

1. **配置分层管理**
   - 环境配置：开发、测试、生产
   - 服务配置：每个服务的特定配置
   - 全局配置：所有服务共享的配置

2. **配置版本控制**
   - 使用Git管理配置文件
   - 配置变更的代码审查
   - 配置回滚机制

3. **配置安全**
   - 敏感配置加密存储
   - 基于角色的访问控制
   - 配置变更审计

4. **配置监控**
   - 配置变更通知
   - 配置使用情况监控
   - 配置错误告警

## 🔍 常见问题

1. **配置不一致问题**
   - 使用配置中心统一管理
   - 实现配置同步机制
   - 添加配置校验

2. **配置泄露问题**
   - 敏感配置加密存储
   - 限制配置访问权限
   - 定期轮换密钥

3. **配置更新问题**
   - 实现配置热更新
   - 添加配置变更通知
   - 支持配置回滚

4. **配置性能问题**
   - 使用配置缓存
   - 优化配置查询
   - 减少配置网络调用

## 📚 扩展阅读

- [Consul KV存储](https://www.consul.io/docs/kv)
- [etcd官方文档](https://etcd.io/docs/)
- [Nacos配置管理](https://nacos.io/zh-cn/docs/quick-start.html)
- [Apollo配置中心](https://github.com/ctripcorp/apollo)

## ✅ 落地检查清单

- 配置中心选型：Consul/etcd/Nacos/Apollo 的适用场景明确
- 配置分类管理：静态/动态/敏感/业务配置的分类策略
- 环境隔离：开发/测试/生产环境的配置隔离方案
- 安全防护：敏感配置加密、访问控制、审计日志
- 热更新机制：配置变更通知、观察者模式、回滚能力
- 监控告警：配置使用情况、变更历史、错误告警

## 🧪 本地快速验证

1. 启动配置中心：
   - Consul: `consul agent -dev`
   - etcd: `etcd --listen-client-urls=http://0.0.0.0:2379`
2. 运行Consul配置中心示例，验证配置存储和获取
3. 运行etcd配置管理示例，测试配置监听和批量操作
4. 运行配置热更新示例，观察配置变更通知机制
5. 运行配置加密示例，验证敏感配置的加密存储
6. 使用配置中心Web UI验证配置管理功能

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025年10月20日  
**文档状态**: 完成  
**适用版本**: Go 1.25.3+
