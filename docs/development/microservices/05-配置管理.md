# é…ç½®ç®¡ç†

> **ç®€ä»‹**: å¾®æœåŠ¡é…ç½®ç®¡ç†æœ€ä½³å®è·µï¼ŒæŒæ¡Consulã€etcdé…ç½®ä¸­å¿ƒå’Œé…ç½®çƒ­æ›´æ–°æŠ€æœ¯
> **ç‰ˆæœ¬**: Go 1.23+  
> **éš¾åº¦**: â­â­â­â­  
> **æ ‡ç­¾**: #å¾®æœåŠ¡ #é…ç½®ç®¡ç† #Consul #çƒ­æ›´æ–°

<!-- TOC START -->
- [é…ç½®ç®¡ç†](#é…ç½®ç®¡ç†)
  - [ğŸ“š ç†è®ºåˆ†æ](#-ç†è®ºåˆ†æ)
    - [é…ç½®ç®¡ç†æŒ‘æˆ˜](#é…ç½®ç®¡ç†æŒ‘æˆ˜)
    - [é…ç½®ä¸­å¿ƒæ¶æ„](#é…ç½®ä¸­å¿ƒæ¶æ„)
    - [é…ç½®åˆ†ç±»ä¸ç­–ç•¥](#é…ç½®åˆ†ç±»ä¸ç­–ç•¥)
    - [é…ç½®å®‰å…¨ä¸æƒé™](#é…ç½®å®‰å…¨ä¸æƒé™)
  - [ğŸ’» ä»£ç ç¤ºä¾‹](#-ä»£ç ç¤ºä¾‹)
    - [Consulé…ç½®ä¸­å¿ƒ](#consulé…ç½®ä¸­å¿ƒ)
    - [etcdé…ç½®ç®¡ç†](#etcdé…ç½®ç®¡ç†)
    - [é…ç½®çƒ­æ›´æ–°](#é…ç½®çƒ­æ›´æ–°)
    - [é…ç½®åŠ å¯†ä¸è§£å¯†](#é…ç½®åŠ å¯†ä¸è§£å¯†)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
  - [ğŸ” å¸¸è§é—®é¢˜](#-å¸¸è§é—®é¢˜)
  - [ğŸ“š æ‰©å±•é˜…è¯»](#-æ‰©å±•é˜…è¯»)
  - [âœ… è½åœ°æ£€æŸ¥æ¸…å•](#-è½åœ°æ£€æŸ¥æ¸…å•)
  - [ğŸ§ª æœ¬åœ°å¿«é€ŸéªŒè¯](#-æœ¬åœ°å¿«é€ŸéªŒè¯)
<!-- TOC END -->


## ğŸ“‹ ç›®å½•


- [ğŸ“š ç†è®ºåˆ†æ](#-ç†è®ºåˆ†æ)
  - [é…ç½®ç®¡ç†æŒ‘æˆ˜](#é…ç½®ç®¡ç†æŒ‘æˆ˜)
  - [é…ç½®ä¸­å¿ƒæ¶æ„](#é…ç½®ä¸­å¿ƒæ¶æ„)
  - [é…ç½®åˆ†ç±»ä¸ç­–ç•¥](#é…ç½®åˆ†ç±»ä¸ç­–ç•¥)
  - [é…ç½®å®‰å…¨ä¸æƒé™](#é…ç½®å®‰å…¨ä¸æƒé™)
- [ğŸ’» ä»£ç ç¤ºä¾‹](#-ä»£ç ç¤ºä¾‹)
  - [Consulé…ç½®ä¸­å¿ƒ](#consulé…ç½®ä¸­å¿ƒ)
  - [etcdé…ç½®ç®¡ç†](#etcdé…ç½®ç®¡ç†)
  - [é…ç½®çƒ­æ›´æ–°](#é…ç½®çƒ­æ›´æ–°)
  - [é…ç½®åŠ å¯†ä¸è§£å¯†](#é…ç½®åŠ å¯†ä¸è§£å¯†)
- [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
- [ğŸ” å¸¸è§é—®é¢˜](#-å¸¸è§é—®é¢˜)
- [ğŸ“š æ‰©å±•é˜…è¯»](#-æ‰©å±•é˜…è¯»)
- [âœ… è½åœ°æ£€æŸ¥æ¸…å•](#-è½åœ°æ£€æŸ¥æ¸…å•)
- [ğŸ§ª æœ¬åœ°å¿«é€ŸéªŒè¯](#-æœ¬åœ°å¿«é€ŸéªŒè¯)

## ğŸ“š ç†è®ºåˆ†æ

### é…ç½®ç®¡ç†æŒ‘æˆ˜

å¾®æœåŠ¡æ¶æ„ä¸­çš„é…ç½®ç®¡ç†é¢ä¸´ä»¥ä¸‹æŒ‘æˆ˜ï¼š

- **é…ç½®åˆ†æ•£**ï¼šå¤šä¸ªæœåŠ¡éœ€è¦ä¸åŒçš„é…ç½®
- **ç¯å¢ƒéš”ç¦»**ï¼šå¼€å‘ã€æµ‹è¯•ã€ç”Ÿäº§ç¯å¢ƒé…ç½®å·®å¼‚
- **åŠ¨æ€æ›´æ–°**ï¼šè¿è¡Œæ—¶é…ç½®å˜æ›´éœ€æ±‚
- **å®‰å…¨æ•æ„Ÿ**ï¼šæ•°æ®åº“å¯†ç ã€APIå¯†é’¥ç­‰æ•æ„Ÿä¿¡æ¯
- **ç‰ˆæœ¬ç®¡ç†**ï¼šé…ç½®å˜æ›´çš„ç‰ˆæœ¬æ§åˆ¶å’Œå›æ»š
- **ä¸€è‡´æ€§ä¿è¯**ï¼šå¤šå®ä¾‹é…ç½®åŒæ­¥é—®é¢˜

### é…ç½®ä¸­å¿ƒæ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   é…ç½®ä¸­å¿ƒ       â”‚    â”‚   é…ç½®å®¢æˆ·ç«¯     â”‚    â”‚   å¾®æœåŠ¡å®ä¾‹    â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚  Consul/etcd    â”‚â—€â”€â”€â”€â”‚  SDK/Watch      â”‚â—€â”€â”€â”€â”‚  åº”ç”¨é…ç½®       â”‚
â”‚  Nacos/Apollo   â”‚    â”‚  çƒ­æ›´æ–°          â”‚    â”‚  ç¯å¢ƒå˜é‡       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### é…ç½®åˆ†ç±»ä¸ç­–ç•¥

| é…ç½®ç±»å‹ | ç‰¹ç‚¹ | ç®¡ç†ç­–ç•¥ | ç¤ºä¾‹ |
|----------|------|----------|------|
| é™æ€é…ç½® | å¯åŠ¨æ—¶ç¡®å®šï¼Œè¿è¡Œæ—¶ä¸å˜ | ç‰ˆæœ¬æ§åˆ¶ã€ç¯å¢ƒéš”ç¦» | æœåŠ¡ç«¯å£ã€æ—¥å¿—çº§åˆ« |
| åŠ¨æ€é…ç½® | è¿è¡Œæ—¶å¯å˜ | çƒ­æ›´æ–°ã€ç‰ˆæœ¬ç®¡ç† | é™æµé˜ˆå€¼ã€åŠŸèƒ½å¼€å…³ |
| æ•æ„Ÿé…ç½® | åŒ…å«å¯†ç ã€å¯†é’¥ | åŠ å¯†å­˜å‚¨ã€æƒé™æ§åˆ¶ | æ•°æ®åº“å¯†ç ã€APIå¯†é’¥ |
| ä¸šåŠ¡é…ç½® | ä¸šåŠ¡é€»è¾‘ç›¸å…³ | ä¸šåŠ¡å›¢é˜Ÿç®¡ç† | ä¸šåŠ¡è§„åˆ™ã€é˜ˆå€¼å‚æ•° |

### é…ç½®å®‰å…¨ä¸æƒé™

- **åŠ å¯†å­˜å‚¨**ï¼šæ•æ„Ÿé…ç½®åŠ å¯†åå­˜å‚¨
- **è®¿é—®æ§åˆ¶**ï¼šåŸºäºè§’è‰²çš„é…ç½®è®¿é—®æƒé™
- **å®¡è®¡æ—¥å¿—**ï¼šé…ç½®å˜æ›´çš„å®Œæ•´å®¡è®¡
- **å¯†é’¥è½®æ¢**ï¼šå®šæœŸæ›´æ–°æ•æ„Ÿé…ç½®
- **æœ€å°æƒé™**ï¼šæœåŠ¡åªèƒ½è®¿é—®å¿…è¦çš„é…ç½®

## ğŸ’» ä»£ç ç¤ºä¾‹

### Consulé…ç½®ä¸­å¿ƒ

```go
package main

import (
    "encoding/json"
    "fmt"
    "log"
    "time"

    "github.com/hashicorp/consul/api"
)

type ConfigManager struct {
    client *api.Client
    prefix string
}

type AppConfig struct {
    Database struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Username string `json:"username"`
        Password string `json:"password"`
        Database string `json:"database"`
    } `json:"database"`
    
    Redis struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Password string `json:"password"`
    } `json:"redis"`
    
    Service struct {
        Name    string `json:"name"`
        Version string `json:"version"`
        Port    int    `json:"port"`
    } `json:"service"`
}

func NewConfigManager(address, prefix string) (*ConfigManager, error) {
    config := api.DefaultConfig()
    config.Address = address
    
    client, err := api.NewClient(config)
    if err != nil {
        return nil, err
    }
    
    return &ConfigManager{
        client: client,
        prefix: prefix,
    }, nil
}

func (cm *ConfigManager) GetConfig(key string) (string, error) {
    kv, _, err := cm.client.KV().Get(cm.prefix+key, nil)
    if err != nil {
        return "", err
    }
    
    if kv == nil {
        return "", fmt.Errorf("é…ç½®ä¸å­˜åœ¨: %s", key)
    }
    
    return string(kv.Value), nil
}

func (cm *ConfigManager) SetConfig(key, value string) error {
    _, err := cm.client.KV().Put(&api.KVPair{
        Key:   cm.prefix + key,
        Value: []byte(value),
    }, nil)
    
    return err
}

func (cm *ConfigManager) GetAppConfig() (*AppConfig, error) {
    configData, err := cm.GetConfig("app.json")
    if err != nil {
        return nil, err
    }
    
    var config AppConfig
    if err := json.Unmarshal([]byte(configData), &config); err != nil {
        return nil, err
    }
    
    return &config, nil
}

func (cm *ConfigManager) SetAppConfig(config *AppConfig) error {
    configData, err := json.MarshalIndent(config, "", "  ")
    if err != nil {
        return err
    }
    
    return cm.SetConfig("app.json", string(configData))
}

func (cm *ConfigManager) WatchConfig(key string, callback func(string)) error {
    queryOptions := &api.QueryOptions{
        WaitIndex: 0,
        WaitTime:  10 * time.Second,
    }
    
    go func() {
        for {
            kv, meta, err := cm.client.KV().Get(cm.prefix+key, queryOptions)
            if err != nil {
                log.Printf("ç›‘å¬é…ç½®å¤±è´¥: %v", err)
                time.Sleep(5 * time.Second)
                continue
            }
            
            if kv != nil {
                callback(string(kv.Value))
            }
            
            queryOptions.WaitIndex = meta.LastIndex
        }
    }()
    
    return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    // åˆ›å»ºé…ç½®ç®¡ç†å™¨
    cm, err := NewConfigManager("localhost:8500", "config/")
    if err != nil {
        log.Fatal(err)
    }
    
    // è®¾ç½®åˆå§‹é…ç½®
    config := &AppConfig{}
    config.Database.Host = "localhost"
    config.Database.Port = 5432
    config.Database.Username = "user"
    config.Database.Password = "password"
    config.Database.Database = "mydb"
    
    config.Redis.Host = "localhost"
    config.Redis.Port = 6379
    config.Redis.Password = ""
    
    config.Service.Name = "user-service"
    config.Service.Version = "1.0.0"
    config.Service.Port = 8080
    
    if err := cm.SetAppConfig(config); err != nil {
        log.Fatal(err)
    }
    
    // è·å–é…ç½®
    appConfig, err := cm.GetAppConfig()
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("åº”ç”¨é…ç½®: %+v\n", appConfig)
    
    // ç›‘å¬é…ç½®å˜æ›´
    cm.WatchConfig("app.json", func(value string) {
        var newConfig AppConfig
        if err := json.Unmarshal([]byte(value), &newConfig); err != nil {
            log.Printf("è§£ææ–°é…ç½®å¤±è´¥: %v", err)
            return
        }
        
        fmt.Printf("é…ç½®å·²æ›´æ–°: %+v\n", newConfig)
        // è¿™é‡Œå¯ä»¥é‡æ–°åŠ è½½é…ç½®
    })
    
    // ä¿æŒè¿è¡Œ
    select {}
}
```

### etcdé…ç½®ç®¡ç†

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "time"

    "go.etcd.io/etcd/clientv3"
)

type EtcdConfigManager struct {
    client *clientv3.Client
    prefix string
}

func NewEtcdConfigManager(endpoints []string, prefix string) (*EtcdConfigManager, error) {
    client, err := clientv3.New(clientv3.Config{
        Endpoints:   endpoints,
        DialTimeout: 5 * time.Second,
    })
    if err != nil {
        return nil, err
    }
    
    return &EtcdConfigManager{
        client: client,
        prefix: prefix,
    }, nil
}

func (ecm *EtcdConfigManager) GetConfig(key string) (string, error) {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    resp, err := ecm.client.Get(ctx, ecm.prefix+key)
    if err != nil {
        return "", err
    }
    
    if len(resp.Kvs) == 0 {
        return "", fmt.Errorf("é…ç½®ä¸å­˜åœ¨: %s", key)
    }
    
    return string(resp.Kvs[0].Value), nil
}

func (ecm *EtcdConfigManager) SetConfig(key, value string) error {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    _, err := ecm.client.Put(ctx, ecm.prefix+key, value)
    return err
}

func (ecm *EtcdConfigManager) WatchConfig(key string, callback func(string)) error {
    go func() {
        watchCh := ecm.client.Watch(context.Background(), ecm.prefix+key)
        
        for wresp := range watchCh {
            for _, ev := range wresp.Events {
                if ev.Type == clientv3.EventTypePut {
                    callback(string(ev.Kv.Value))
                }
            }
        }
    }()
    
    return nil
}

func (ecm *EtcdConfigManager) GetConfigsWithPrefix(prefix string) (map[string]string, error) {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    resp, err := ecm.client.Get(ctx, ecm.prefix+prefix, clientv3.WithPrefix())
    if err != nil {
        return nil, err
    }
    
    configs := make(map[string]string)
    for _, kv := range resp.Kvs {
        key := string(kv.Key)
        value := string(kv.Value)
        configs[key] = value
    }
    
    return configs, nil
}

func (ecm *EtcdConfigManager) Close() error {
    return ecm.client.Close()
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    // åˆ›å»ºetcdé…ç½®ç®¡ç†å™¨
    ecm, err := NewEtcdConfigManager([]string{"localhost:2379"}, "config/")
    if err != nil {
        log.Fatal(err)
    }
    defer ecm.Close()
    
    // è®¾ç½®é…ç½®
    configs := map[string]string{
        "database.host":     "localhost",
        "database.port":     "5432",
        "database.username": "user",
        "database.password": "password",
        "redis.host":        "localhost",
        "redis.port":        "6379",
        "service.name":      "user-service",
        "service.port":      "8080",
    }
    
    for key, value := range configs {
        if err := ecm.SetConfig(key, value); err != nil {
            log.Printf("è®¾ç½®é…ç½®å¤±è´¥ %s: %v", key, err)
        }
    }
    
    // è·å–å•ä¸ªé…ç½®
    host, err := ecm.GetConfig("database.host")
    if err != nil {
        log.Printf("è·å–é…ç½®å¤±è´¥: %v", err)
    } else {
        fmt.Printf("æ•°æ®åº“ä¸»æœº: %s\n", host)
    }
    
    // è·å–æ‰€æœ‰é…ç½®
    allConfigs, err := ecm.GetConfigsWithPrefix("")
    if err != nil {
        log.Printf("è·å–æ‰€æœ‰é…ç½®å¤±è´¥: %v", err)
    } else {
        fmt.Printf("æ‰€æœ‰é…ç½®: %+v\n", allConfigs)
    }
    
    // ç›‘å¬é…ç½®å˜æ›´
    ecm.WatchConfig("database.host", func(value string) {
        fmt.Printf("æ•°æ®åº“ä¸»æœºå·²æ›´æ–°ä¸º: %s\n", value)
    })
    
    // ä¿æŒè¿è¡Œ
    select {}
}
```

### é…ç½®çƒ­æ›´æ–°

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "sync"
    "time"
)

type Config struct {
    Database struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Username string `json:"username"`
        Password string `json:"password"`
    } `json:"database"`
    
    Redis struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Password string `json:"password"`
    } `json:"redis"`
    
    Service struct {
        Name    string `json:"name"`
        Version string `json:"version"`
        Port    int    `json:"port"`
    } `json:"service"`
    
    Features struct {
        EnableCache    bool `json:"enable_cache"`
        EnableMetrics  bool `json:"enable_metrics"`
        MaxConnections int  `json:"max_connections"`
    } `json:"features"`
}

type ConfigManager struct {
    config      *Config
    mutex       sync.RWMutex
    watchers    []func(*Config)
    watcherMutex sync.RWMutex
}

func NewConfigManager() *ConfigManager {
    return &ConfigManager{
        config:   &Config{},
        watchers: make([]func(*Config), 0),
    }
}

func (cm *ConfigManager) GetConfig() *Config {
    cm.mutex.RLock()
    defer cm.mutex.RUnlock()
    
    // è¿”å›é…ç½®çš„å‰¯æœ¬
    configCopy := *cm.config
    return &configCopy
}

func (cm *ConfigManager) UpdateConfig(configData []byte) error {
    var newConfig Config
    if err := json.Unmarshal(configData, &newConfig); err != nil {
        return err
    }
    
    cm.mutex.Lock()
    oldConfig := cm.config
    cm.config = &newConfig
    cm.mutex.Unlock()
    
    // é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€…
    cm.notifyWatchers(&newConfig)
    
    log.Printf("é…ç½®å·²æ›´æ–°ï¼Œæ—§é…ç½®: %+v, æ–°é…ç½®: %+v", oldConfig, &newConfig)
    
    return nil
}

func (cm *ConfigManager) AddWatcher(watcher func(*Config)) {
    cm.watcherMutex.Lock()
    defer cm.watcherMutex.Unlock()
    
    cm.watchers = append(cm.watchers, watcher)
}

func (cm *ConfigManager) notifyWatchers(config *Config) {
    cm.watcherMutex.RLock()
    watchers := make([]func(*Config), len(cm.watchers))
    copy(watchers, cm.watchers)
    cm.watcherMutex.RUnlock()
    
    for _, watcher := range watchers {
        go watcher(config)
    }
}

// é…ç½®çƒ­æ›´æ–°æœåŠ¡
type ConfigUpdateService struct {
    configManager *ConfigManager
    updateChannel chan []byte
}

func NewConfigUpdateService(configManager *ConfigManager) *ConfigUpdateService {
    return &ConfigUpdateService{
        configManager: configManager,
        updateChannel: make(chan []byte, 100),
    }
}

func (cus *ConfigUpdateService) Start(ctx context.Context) {
    go func() {
        for {
            select {
            case configData := <-cus.updateChannel:
                if err := cus.configManager.UpdateConfig(configData); err != nil {
                    log.Printf("æ›´æ–°é…ç½®å¤±è´¥: %v", err)
                }
            case <-ctx.Done():
                return
            }
        }
    }()
}

func (cus *ConfigUpdateService) UpdateConfig(configData []byte) {
    select {
    case cus.updateChannel <- configData:
    default:
        log.Printf("é…ç½®æ›´æ–°é€šé“å·²æ»¡ï¼Œä¸¢å¼ƒæ›´æ–°")
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    configManager := NewConfigManager()
    updateService := NewConfigUpdateService(configManager)
    
    // å¯åŠ¨é…ç½®æ›´æ–°æœåŠ¡
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    updateService.Start(ctx)
    
    // æ·»åŠ é…ç½®è§‚å¯Ÿè€…
    configManager.AddWatcher(func(config *Config) {
        fmt.Printf("é…ç½®è§‚å¯Ÿè€…1æ”¶åˆ°æ›´æ–°: %+v\n", config)
    })
    
    configManager.AddWatcher(func(config *Config) {
        fmt.Printf("é…ç½®è§‚å¯Ÿè€…2æ”¶åˆ°æ›´æ–°: %+v\n", config)
    })
    
    // æ¨¡æ‹Ÿé…ç½®æ›´æ–°
    config1 := Config{}
    config1.Database.Host = "localhost"
    config1.Database.Port = 5432
    config1.Service.Name = "user-service"
    config1.Features.EnableCache = true
    
    configData1, _ := json.Marshal(config1)
    updateService.UpdateConfig(configData1)
    
    time.Sleep(1 * time.Second)
    
    // å†æ¬¡æ›´æ–°é…ç½®
    config2 := Config{}
    config2.Database.Host = "remote-host"
    config2.Database.Port = 3306
    config2.Service.Name = "user-service-v2"
    config2.Features.EnableCache = false
    config2.Features.MaxConnections = 100
    
    configData2, _ := json.Marshal(config2)
    updateService.UpdateConfig(configData2)
    
    time.Sleep(1 * time.Second)
    
    // è·å–å½“å‰é…ç½®
    currentConfig := configManager.GetConfig()
    fmt.Printf("å½“å‰é…ç½®: %+v\n", currentConfig)
}
```

### é…ç½®åŠ å¯†ä¸è§£å¯†

```go
package main

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "encoding/base64"
    "encoding/json"
    "fmt"
    "io"
    "log"
)

type EncryptedConfig struct {
    EncryptedData string `json:"encrypted_data"`
    KeyID         string `json:"key_id"`
}

type ConfigEncryption struct {
    keys map[string][]byte
}

func NewConfigEncryption() *ConfigEncryption {
    return &ConfigEncryption{
        keys: make(map[string][]byte),
    }
}

func (ce *ConfigEncryption) AddKey(keyID string, key []byte) {
    ce.keys[keyID] = key
}

func (ce *ConfigEncryption) EncryptConfig(config interface{}, keyID string) (*EncryptedConfig, error) {
    key, exists := ce.keys[keyID]
    if !exists {
        return nil, fmt.Errorf("å¯†é’¥ä¸å­˜åœ¨: %s", keyID)
    }
    
    // åºåˆ—åŒ–é…ç½®
    configData, err := json.Marshal(config)
    if err != nil {
        return nil, err
    }
    
    // åŠ å¯†æ•°æ®
    encryptedData, err := ce.encrypt(configData, key)
    if err != nil {
        return nil, err
    }
    
    return &EncryptedConfig{
        EncryptedData: base64.StdEncoding.EncodeToString(encryptedData),
        KeyID:         keyID,
    }, nil
}

func (ce *ConfigEncryption) DecryptConfig(encryptedConfig *EncryptedConfig, target interface{}) error {
    key, exists := ce.keys[encryptedConfig.KeyID]
    if !exists {
        return fmt.Errorf("å¯†é’¥ä¸å­˜åœ¨: %s", encryptedConfig.KeyID)
    }
    
    // è§£ç base64
    encryptedData, err := base64.StdEncoding.DecodeString(encryptedConfig.EncryptedData)
    if err != nil {
        return err
    }
    
    // è§£å¯†æ•°æ®
    decryptedData, err := ce.decrypt(encryptedData, key)
    if err != nil {
        return err
    }
    
    // ååºåˆ—åŒ–é…ç½®
    return json.Unmarshal(decryptedData, target)
}

func (ce *ConfigEncryption) encrypt(data []byte, key []byte) ([]byte, error) {
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }
    
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }
    
    nonce := make([]byte, gcm.NonceSize())
    if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
        return nil, err
    }
    
    ciphertext := gcm.Seal(nonce, nonce, data, nil)
    return ciphertext, nil
}

func (ce *ConfigEncryption) decrypt(data []byte, key []byte) ([]byte, error) {
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }
    
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }
    
    nonceSize := gcm.NonceSize()
    if len(data) < nonceSize {
        return nil, fmt.Errorf("å¯†æ–‡å¤ªçŸ­")
    }
    
    nonce, ciphertext := data[:nonceSize], data[nonceSize:]
    plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return nil, err
    }
    
    return plaintext, nil
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    encryption := NewConfigEncryption()
    
    // ç”Ÿæˆå¯†é’¥ï¼ˆå®é™…åº”ç”¨ä¸­åº”è¯¥ä»å®‰å…¨çš„åœ°æ–¹è·å–ï¼‰
    key := make([]byte, 32) // AES-256
    if _, err := io.ReadFull(rand.Reader, key); err != nil {
        log.Fatal(err)
    }
    
    encryption.AddKey("key1", key)
    
    // é…ç½®æ•°æ®
    config := map[string]interface{}{
        "database": map[string]interface{}{
            "host":     "localhost",
            "port":     5432,
            "username": "user",
            "password": "secret_password",
        },
        "api_key": "sk-1234567890abcdef",
    }
    
    // åŠ å¯†é…ç½®
    encryptedConfig, err := encryption.EncryptConfig(config, "key1")
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("åŠ å¯†åçš„é…ç½®: %+v\n", encryptedConfig)
    
    // è§£å¯†é…ç½®
    var decryptedConfig map[string]interface{}
    if err := encryption.DecryptConfig(encryptedConfig, &decryptedConfig); err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("è§£å¯†åçš„é…ç½®: %+v\n", decryptedConfig)
}
```

## ğŸ¯ æœ€ä½³å®è·µ

1. **é…ç½®åˆ†å±‚ç®¡ç†**
   - ç¯å¢ƒé…ç½®ï¼šå¼€å‘ã€æµ‹è¯•ã€ç”Ÿäº§
   - æœåŠ¡é…ç½®ï¼šæ¯ä¸ªæœåŠ¡çš„ç‰¹å®šé…ç½®
   - å…¨å±€é…ç½®ï¼šæ‰€æœ‰æœåŠ¡å…±äº«çš„é…ç½®

2. **é…ç½®ç‰ˆæœ¬æ§åˆ¶**
   - ä½¿ç”¨Gitç®¡ç†é…ç½®æ–‡ä»¶
   - é…ç½®å˜æ›´çš„ä»£ç å®¡æŸ¥
   - é…ç½®å›æ»šæœºåˆ¶

3. **é…ç½®å®‰å…¨**
   - æ•æ„Ÿé…ç½®åŠ å¯†å­˜å‚¨
   - åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶
   - é…ç½®å˜æ›´å®¡è®¡

4. **é…ç½®ç›‘æ§**
   - é…ç½®å˜æ›´é€šçŸ¥
   - é…ç½®ä½¿ç”¨æƒ…å†µç›‘æ§
   - é…ç½®é”™è¯¯å‘Šè­¦

## ğŸ” å¸¸è§é—®é¢˜

1. **é…ç½®ä¸ä¸€è‡´é—®é¢˜**
   - ä½¿ç”¨é…ç½®ä¸­å¿ƒç»Ÿä¸€ç®¡ç†
   - å®ç°é…ç½®åŒæ­¥æœºåˆ¶
   - æ·»åŠ é…ç½®æ ¡éªŒ

2. **é…ç½®æ³„éœ²é—®é¢˜**
   - æ•æ„Ÿé…ç½®åŠ å¯†å­˜å‚¨
   - é™åˆ¶é…ç½®è®¿é—®æƒé™
   - å®šæœŸè½®æ¢å¯†é’¥

3. **é…ç½®æ›´æ–°é—®é¢˜**
   - å®ç°é…ç½®çƒ­æ›´æ–°
   - æ·»åŠ é…ç½®å˜æ›´é€šçŸ¥
   - æ”¯æŒé…ç½®å›æ»š

4. **é…ç½®æ€§èƒ½é—®é¢˜**
   - ä½¿ç”¨é…ç½®ç¼“å­˜
   - ä¼˜åŒ–é…ç½®æŸ¥è¯¢
   - å‡å°‘é…ç½®ç½‘ç»œè°ƒç”¨

## ğŸ“š æ‰©å±•é˜…è¯»

- [Consul KVå­˜å‚¨](https://www.consul.io/docs/kv)
- [etcdå®˜æ–¹æ–‡æ¡£](https://etcd.io/docs/)
- [Nacosé…ç½®ç®¡ç†](https://nacos.io/zh-cn/docs/quick-start.html)
- [Apolloé…ç½®ä¸­å¿ƒ](https://github.com/ctripcorp/apollo)

## âœ… è½åœ°æ£€æŸ¥æ¸…å•

- é…ç½®ä¸­å¿ƒé€‰å‹ï¼šConsul/etcd/Nacos/Apollo çš„é€‚ç”¨åœºæ™¯æ˜ç¡®
- é…ç½®åˆ†ç±»ç®¡ç†ï¼šé™æ€/åŠ¨æ€/æ•æ„Ÿ/ä¸šåŠ¡é…ç½®çš„åˆ†ç±»ç­–ç•¥
- ç¯å¢ƒéš”ç¦»ï¼šå¼€å‘/æµ‹è¯•/ç”Ÿäº§ç¯å¢ƒçš„é…ç½®éš”ç¦»æ–¹æ¡ˆ
- å®‰å…¨é˜²æŠ¤ï¼šæ•æ„Ÿé…ç½®åŠ å¯†ã€è®¿é—®æ§åˆ¶ã€å®¡è®¡æ—¥å¿—
- çƒ­æ›´æ–°æœºåˆ¶ï¼šé…ç½®å˜æ›´é€šçŸ¥ã€è§‚å¯Ÿè€…æ¨¡å¼ã€å›æ»šèƒ½åŠ›
- ç›‘æ§å‘Šè­¦ï¼šé…ç½®ä½¿ç”¨æƒ…å†µã€å˜æ›´å†å²ã€é”™è¯¯å‘Šè­¦

## ğŸ§ª æœ¬åœ°å¿«é€ŸéªŒè¯

1. å¯åŠ¨é…ç½®ä¸­å¿ƒï¼š
   - Consul: `consul agent -dev`
   - etcd: `etcd --listen-client-urls=http://0.0.0.0:2379`
2. è¿è¡ŒConsulé…ç½®ä¸­å¿ƒç¤ºä¾‹ï¼ŒéªŒè¯é…ç½®å­˜å‚¨å’Œè·å–
3. è¿è¡Œetcdé…ç½®ç®¡ç†ç¤ºä¾‹ï¼Œæµ‹è¯•é…ç½®ç›‘å¬å’Œæ‰¹é‡æ“ä½œ
4. è¿è¡Œé…ç½®çƒ­æ›´æ–°ç¤ºä¾‹ï¼Œè§‚å¯Ÿé…ç½®å˜æ›´é€šçŸ¥æœºåˆ¶
5. è¿è¡Œé…ç½®åŠ å¯†ç¤ºä¾‹ï¼ŒéªŒè¯æ•æ„Ÿé…ç½®çš„åŠ å¯†å­˜å‚¨
6. ä½¿ç”¨é…ç½®ä¸­å¿ƒWeb UIéªŒè¯é…ç½®ç®¡ç†åŠŸèƒ½

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ20æ—¥  
**æ–‡æ¡£çŠ¶æ€**: å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
