# å¾®æœåŠ¡æ¶æ„

> **ç®€ä»‹**: å¾®æœåŠ¡æ¶æ„å®Œæ•´æŒ‡å—ï¼ŒåŒ…æ‹¬æ¶æ„åŸåˆ™ã€è®¾è®¡æ¨¡å¼ã€é€šä¿¡æœºåˆ¶å’Œæœ€ä½³å®è·µ

> **ç‰ˆæœ¬**: Go 1.25.3  
> **éš¾åº¦**: â­â­â­â­  
> **æ ‡ç­¾**: #å¾®æœåŠ¡ #æ¶æ„ #åˆ†å¸ƒå¼

---

## ğŸ“š ç›®å½•

1. [å¾®æœåŠ¡æ¦‚è¿°](#å¾®æœåŠ¡æ¦‚è¿°)
2. [æœåŠ¡æ‹†åˆ†](#æœåŠ¡æ‹†åˆ†)
3. [é€šä¿¡æœºåˆ¶](#é€šä¿¡æœºåˆ¶)
4. [æœåŠ¡å‘ç°](#æœåŠ¡å‘ç°)
5. [é…ç½®ç®¡ç†](#é…ç½®ç®¡ç†)
6. [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

---

## 1. å¾®æœåŠ¡æ¦‚è¿°

### å¾®æœåŠ¡æ¶æ„ç‰¹ç‚¹

**ä¼˜åŠ¿**:
- âœ… ç‹¬ç«‹éƒ¨ç½²
- âœ… æŠ€æœ¯æ ˆçµæ´»
- âœ… æ•…éšœéš”ç¦»
- âœ… æ˜“äºæ‰©å±•
- âœ… å›¢é˜Ÿè‡ªæ²»

**æŒ‘æˆ˜**:
- âŒ åˆ†å¸ƒå¼å¤æ‚æ€§
- âŒ æ•°æ®ä¸€è‡´æ€§
- âŒ æœåŠ¡æ²»ç†
- âŒ æµ‹è¯•å¤æ‚
- âŒ è¿ç»´æˆæœ¬

---

### å•ä½“ vs å¾®æœåŠ¡

| ç‰¹æ€§ | å•ä½“åº”ç”¨ | å¾®æœåŠ¡ |
|------|---------|--------|
| **éƒ¨ç½²** | æ•´ä½“éƒ¨ç½² | ç‹¬ç«‹éƒ¨ç½² |
| **æ‰©å±•** | å‚ç›´æ‰©å±• | æ°´å¹³æ‰©å±• |
| **æŠ€æœ¯æ ˆ** | ç»Ÿä¸€ | çµæ´» |
| **å¼€å‘** | ç®€å• | å¤æ‚ |
| **ç»´æŠ¤** | é›†ä¸­ | åˆ†æ•£ |
| **æ•…éšœ** | å…¨å±€å½±å“ | å±€éƒ¨éš”ç¦» |

---

## 2. æœåŠ¡æ‹†åˆ†

### æ‹†åˆ†åŸåˆ™

```go
// âŒ å•ä½“åº”ç”¨
type MonolithService struct {
    userRepo    *UserRepository
    orderRepo   *OrderRepository
    productRepo *ProductRepository
    paymentRepo *PaymentRepository
}

// âœ… å¾®æœåŠ¡æ‹†åˆ†
// ç”¨æˆ·æœåŠ¡
type UserService struct {
    userRepo *UserRepository
}

// è®¢å•æœåŠ¡
type OrderService struct {
    orderRepo    *OrderRepository
    userClient   *UserClient      // è°ƒç”¨ç”¨æˆ·æœåŠ¡
    productClient *ProductClient  // è°ƒç”¨äº§å“æœåŠ¡
}

// äº§å“æœåŠ¡
type ProductService struct {
    productRepo *ProductRepository
}

// æ”¯ä»˜æœåŠ¡
type PaymentService struct {
    paymentRepo  *PaymentRepository
    orderClient  *OrderClient     // è°ƒç”¨è®¢å•æœåŠ¡
}
```

---

### æŒ‰ä¸šåŠ¡èƒ½åŠ›æ‹†åˆ†

```
ç”µå•†ç³»ç»Ÿå¾®æœåŠ¡æ‹†åˆ†ï¼š

â”œâ”€â”€ ç”¨æˆ·æœåŠ¡ (User Service)
â”‚   â”œâ”€â”€ ç”¨æˆ·æ³¨å†Œ/ç™»å½•
â”‚   â”œâ”€â”€ ç”¨æˆ·ä¿¡æ¯ç®¡ç†
â”‚   â””â”€â”€ ç”¨æˆ·è®¤è¯/æˆæƒ
â”‚
â”œâ”€â”€ äº§å“æœåŠ¡ (Product Service)
â”‚   â”œâ”€â”€ äº§å“ç›®å½•
â”‚   â”œâ”€â”€ äº§å“æœç´¢
â”‚   â””â”€â”€ åº“å­˜ç®¡ç†
â”‚
â”œâ”€â”€ è®¢å•æœåŠ¡ (Order Service)
â”‚   â”œâ”€â”€ è®¢å•åˆ›å»º
â”‚   â”œâ”€â”€ è®¢å•æŸ¥è¯¢
â”‚   â””â”€â”€ è®¢å•çŠ¶æ€ç®¡ç†
â”‚
â”œâ”€â”€ æ”¯ä»˜æœåŠ¡ (Payment Service)
â”‚   â”œâ”€â”€ æ”¯ä»˜å¤„ç†
â”‚   â”œâ”€â”€ é€€æ¬¾å¤„ç†
â”‚   â””â”€â”€ æ”¯ä»˜å›è°ƒ
â”‚
â””â”€â”€ é€šçŸ¥æœåŠ¡ (Notification Service)
    â”œâ”€â”€ é‚®ä»¶é€šçŸ¥
    â”œâ”€â”€ çŸ­ä¿¡é€šçŸ¥
    â””â”€â”€ æ¨é€é€šçŸ¥
```

---

### æœåŠ¡è¾¹ç•Œå®šä¹‰

```go
// ç”¨æˆ·æœåŠ¡ API
type UserService interface {
    // ç”¨æˆ·ç®¡ç†
    CreateUser(ctx context.Context, req *CreateUserRequest) (*User, error)
    GetUser(ctx context.Context, id string) (*User, error)
    UpdateUser(ctx context.Context, req *UpdateUserRequest) (*User, error)
    
    // è®¤è¯
    Login(ctx context.Context, req *LoginRequest) (*AuthToken, error)
    ValidateToken(ctx context.Context, token string) (*User, error)
}

// è®¢å•æœåŠ¡ API
type OrderService interface {
    // è®¢å•ç®¡ç†
    CreateOrder(ctx context.Context, req *CreateOrderRequest) (*Order, error)
    GetOrder(ctx context.Context, id string) (*Order, error)
    ListOrders(ctx context.Context, userID string) ([]*Order, error)
    
    // è®¢å•çŠ¶æ€
    UpdateOrderStatus(ctx context.Context, id string, status OrderStatus) error
    CancelOrder(ctx context.Context, id string) error
}
```

---

## 3. é€šä¿¡æœºåˆ¶

### HTTP/RESTé€šä¿¡

```go
// è®¢å•æœåŠ¡è°ƒç”¨ç”¨æˆ·æœåŠ¡
type UserClient struct {
    baseURL string
    client  *http.Client
}

func NewUserClient(baseURL string) *UserClient {
    return &UserClient{
        baseURL: baseURL,
        client: &http.Client{
            Timeout: 10 * time.Second,
        },
    }
}

func (c *UserClient) GetUser(ctx context.Context, userID string) (*User, error) {
    url := fmt.Sprintf("%s/users/%s", c.baseURL, userID)
    
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, err
    }
    
    resp, err := c.client.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("unexpected status: %d", resp.StatusCode)
    }
    
    var user User
    if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
        return nil, err
    }
    
    return &user, nil
}
```

---

### gRPCé€šä¿¡

```protobuf
// user.proto
syntax = "proto3";

package user;

service UserService {
    rpc GetUser(GetUserRequest) returns (User);
    rpc CreateUser(CreateUserRequest) returns (User);
}

message GetUserRequest {
    string id = 1;
}

message User {
    string id = 1;
    string name = 2;
    string email = 3;
}
```

**Goå®ç°**:
```go
// æœåŠ¡ç«¯
type userServiceServer struct {
    pb.UnimplementedUserServiceServer
    repo *UserRepository
}

func (s *userServiceServer) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.User, error) {
    user, err := s.repo.FindByID(ctx, req.Id)
    if err != nil {
        return nil, status.Error(codes.NotFound, "user not found")
    }
    
    return &pb.User{
        Id:    user.ID,
        Name:  user.Name,
        Email: user.Email,
    }, nil
}

// å®¢æˆ·ç«¯
type UserClient struct {
    client pb.UserServiceClient
}

func NewUserClient(conn *grpc.ClientConn) *UserClient {
    return &UserClient{
        client: pb.NewUserServiceClient(conn),
    }
}

func (c *UserClient) GetUser(ctx context.Context, userID string) (*pb.User, error) {
    return c.client.GetUser(ctx, &pb.GetUserRequest{
        Id: userID,
    })
}
```

---

### æ¶ˆæ¯é˜Ÿåˆ—é€šä¿¡

```go
// è®¢å•æœåŠ¡å‘å¸ƒè®¢å•åˆ›å»ºäº‹ä»¶
type OrderEventPublisher struct {
    producer *kafka.Producer
}

func (p *OrderEventPublisher) PublishOrderCreated(order *Order) error {
    event := OrderCreatedEvent{
        OrderID:   order.ID,
        UserID:    order.UserID,
        Amount:    order.Amount,
        Timestamp: time.Now(),
    }
    
    data, err := json.Marshal(event)
    if err != nil {
        return err
    }
    
    return p.producer.Produce(&kafka.Message{
        TopicPartition: kafka.TopicPartition{
            Topic:     kafka.StringToTopicName("order.created"),
            Partition: kafka.PartitionAny,
        },
        Value: data,
    }, nil)
}

// é€šçŸ¥æœåŠ¡è®¢é˜…è®¢å•åˆ›å»ºäº‹ä»¶
type NotificationService struct {
    consumer *kafka.Consumer
}

func (s *NotificationService) Start() error {
    s.consumer.Subscribe("order.created", nil)
    
    for {
        msg, err := s.consumer.ReadMessage(-1)
        if err != nil {
            return err
        }
        
        var event OrderCreatedEvent
        if err := json.Unmarshal(msg.Value, &event); err != nil {
            log.Printf("Failed to unmarshal event: %v", err)
            continue
        }
        
        // å‘é€é€šçŸ¥
        s.sendOrderNotification(event)
    }
}
```

---

## 4. æœåŠ¡å‘ç°

### ConsulæœåŠ¡æ³¨å†Œ

```go
import "github.com/hashicorp/consul/api"

type ServiceRegistry struct {
    client *api.Client
}

func NewServiceRegistry(consulAddr string) (*ServiceRegistry, error) {
    config := api.DefaultConfig()
    config.Address = consulAddr
    
    client, err := api.NewClient(config)
    if err != nil {
        return nil, err
    }
    
    return &ServiceRegistry{client: client}, nil
}

// æ³¨å†ŒæœåŠ¡
func (r *ServiceRegistry) Register(serviceID, serviceName, address string, port int) error {
    registration := &api.AgentServiceRegistration{
        ID:      serviceID,
        Name:    serviceName,
        Address: address,
        Port:    port,
        Check: &api.AgentServiceCheck{
            HTTP:     fmt.Sprintf("http://%s:%d/health", address, port),
            Interval: "10s",
            Timeout:  "3s",
        },
    }
    
    return r.client.Agent().ServiceRegister(registration)
}

// æ³¨é”€æœåŠ¡
func (r *ServiceRegistry) Deregister(serviceID string) error {
    return r.client.Agent().ServiceDeregister(serviceID)
}

// å‘ç°æœåŠ¡
func (r *ServiceRegistry) Discover(serviceName string) ([]*api.ServiceEntry, error) {
    services, _, err := r.client.Health().Service(serviceName, "", true, nil)
    return services, err
}
```

---

### è´Ÿè½½å‡è¡¡

```go
type LoadBalancer struct {
    registry *ServiceRegistry
    strategy LoadBalanceStrategy
}

type LoadBalanceStrategy interface {
    Select(services []*api.ServiceEntry) *api.ServiceEntry
}

// è½®è¯¢ç­–ç•¥
type RoundRobinStrategy struct {
    counter uint32
}

func (s *RoundRobinStrategy) Select(services []*api.ServiceEntry) *api.ServiceEntry {
    if len(services) == 0 {
        return nil
    }
    
    index := atomic.AddUint32(&s.counter, 1) % uint32(len(services))
    return services[index]
}

// éšæœºç­–ç•¥
type RandomStrategy struct{}

func (s *RandomStrategy) Select(services []*api.ServiceEntry) *api.ServiceEntry {
    if len(services) == 0 {
        return nil
    }
    
    return services[rand.Intn(len(services))]
}

// ä½¿ç”¨
func (lb *LoadBalancer) GetService(serviceName string) (string, error) {
    services, err := lb.registry.Discover(serviceName)
    if err != nil {
        return "", err
    }
    
    selected := lb.strategy.Select(services)
    if selected == nil {
        return "", errors.New("no service available")
    }
    
    return fmt.Sprintf("http://%s:%d", 
        selected.Service.Address, 
        selected.Service.Port), nil
}
```

---

## 5. é…ç½®ç®¡ç†

### Consul KVé…ç½®

```go
type ConfigManager struct {
    client *api.Client
    prefix string
}

func NewConfigManager(consulAddr, prefix string) (*ConfigManager, error) {
    config := api.DefaultConfig()
    config.Address = consulAddr
    
    client, err := api.NewClient(config)
    if err != nil {
        return nil, err
    }
    
    return &ConfigManager{
        client: client,
        prefix: prefix,
    }, nil
}

// è·å–é…ç½®
func (m *ConfigManager) Get(key string) (string, error) {
    fullKey := fmt.Sprintf("%s/%s", m.prefix, key)
    
    pair, _, err := m.client.KV().Get(fullKey, nil)
    if err != nil {
        return "", err
    }
    
    if pair == nil {
        return "", fmt.Errorf("key not found: %s", key)
    }
    
    return string(pair.Value), nil
}

// è®¾ç½®é…ç½®
func (m *ConfigManager) Set(key, value string) error {
    fullKey := fmt.Sprintf("%s/%s", m.prefix, key)
    
    pair := &api.KVPair{
        Key:   fullKey,
        Value: []byte(value),
    }
    
    _, err := m.client.KV().Put(pair, nil)
    return err
}

// ç›‘å¬é…ç½®å˜æ›´
func (m *ConfigManager) Watch(key string, callback func(string)) {
    fullKey := fmt.Sprintf("%s/%s", m.prefix, key)
    var lastIndex uint64
    
    for {
        pair, meta, err := m.client.KV().Get(fullKey, &api.QueryOptions{
            WaitIndex: lastIndex,
        })
        
        if err != nil {
            log.Printf("Watch error: %v", err)
            time.Sleep(5 * time.Second)
            continue
        }
        
        if pair != nil && meta.LastIndex > lastIndex {
            lastIndex = meta.LastIndex
            callback(string(pair.Value))
        }
    }
}
```

---

## 6. æœ€ä½³å®è·µ

### 1. API Gateway

```go
type APIGateway struct {
    userClient    *UserClient
    orderClient   *OrderClient
    productClient *ProductClient
}

func (g *APIGateway) HandleRequest(w http.ResponseWriter, r *http.Request) {
    // è®¤è¯
    token := r.Header.Get("Authorization")
    user, err := g.userClient.ValidateToken(r.Context(), token)
    if err != nil {
        http.Error(w, "Unauthorized", http.StatusUnauthorized)
        return
    }
    
    // è·¯ç”±åˆ°å…·ä½“æœåŠ¡
    switch {
    case strings.HasPrefix(r.URL.Path, "/api/users"):
        g.proxyToUserService(w, r)
    case strings.HasPrefix(r.URL.Path, "/api/orders"):
        g.proxyToOrderService(w, r, user)
    case strings.HasPrefix(r.URL.Path, "/api/products"):
        g.proxyToProductService(w, r)
    default:
        http.NotFound(w, r)
    }
}
```

---

### 2. ç†”æ–­å™¨

```go
import "github.com/sony/gobreaker"

type UserClient struct {
    baseURL string
    breaker *gobreaker.CircuitBreaker
}

func NewUserClient(baseURL string) *UserClient {
    settings := gobreaker.Settings{
        Name:        "UserService",
        MaxRequests: 3,
        Interval:    10 * time.Second,
        Timeout:     60 * time.Second,
        ReadyToTrip: func(counts gobreaker.Counts) bool {
            failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)
            return counts.Requests >= 3 && failureRatio >= 0.6
        },
    }
    
    return &UserClient{
        baseURL: baseURL,
        breaker: gobreaker.NewCircuitBreaker(settings),
    }
}

func (c *UserClient) GetUser(ctx context.Context, userID string) (*User, error) {
    result, err := c.breaker.Execute(func() (interface{}, error) {
        return c.doGetUser(ctx, userID)
    })
    
    if err != nil {
        return nil, err
    }
    
    return result.(*User), nil
}
```

---

### 3. é™æµ

```go
import "golang.org/x/time/rate"

type RateLimitedService struct {
    limiter *rate.Limiter
    service UserService
}

func NewRateLimitedService(rps int, service UserService) *RateLimitedService {
    return &RateLimitedService{
        limiter: rate.NewLimiter(rate.Limit(rps), rps),
        service: service,
    }
}

func (s *RateLimitedService) GetUser(ctx context.Context, userID string) (*User, error) {
    if err := s.limiter.Wait(ctx); err != nil {
        return nil, fmt.Errorf("rate limit exceeded: %w", err)
    }
    
    return s.service.GetUser(ctx, userID)
}
```

---

### 4. åˆ†å¸ƒå¼è¿½è¸ª

```go
import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

func (s *OrderService) CreateOrder(ctx context.Context, req *CreateOrderRequest) (*Order, error) {
    tracer := otel.Tracer("order-service")
    ctx, span := tracer.Start(ctx, "CreateOrder")
    defer span.End()
    
    // éªŒè¯ç”¨æˆ·
    _, span1 := tracer.Start(ctx, "ValidateUser")
    user, err := s.userClient.GetUser(ctx, req.UserID)
    span1.End()
    if err != nil {
        return nil, err
    }
    
    // åˆ›å»ºè®¢å•
    _, span2 := tracer.Start(ctx, "SaveOrder")
    order, err := s.orderRepo.Save(ctx, req)
    span2.End()
    if err != nil {
        return nil, err
    }
    
    // å‘å¸ƒäº‹ä»¶
    _, span3 := tracer.Start(ctx, "PublishEvent")
    s.eventPublisher.PublishOrderCreated(order)
    span3.End()
    
    return order, nil
}
```

---

### 5. å¥åº·æ£€æŸ¥

```go
type HealthChecker struct {
    db       *sql.DB
    registry *ServiceRegistry
}

func (h *HealthChecker) Check(w http.ResponseWriter, r *http.Request) {
    status := map[string]string{
        "status": "UP",
    }
    
    // æ£€æŸ¥æ•°æ®åº“
    if err := h.db.Ping(); err != nil {
        status["database"] = "DOWN"
        status["status"] = "DOWN"
    } else {
        status["database"] = "UP"
    }
    
    // æ£€æŸ¥ä¾èµ–æœåŠ¡
    services, err := h.registry.Discover("user-service")
    if err != nil || len(services) == 0 {
        status["user-service"] = "DOWN"
        status["status"] = "DEGRADED"
    } else {
        status["user-service"] = "UP"
    }
    
    code := http.StatusOK
    if status["status"] == "DOWN" {
        code = http.StatusServiceUnavailable
    }
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(code)
    json.NewEncoder(w).Encode(status)
}
```

---

### 6. ä¼˜é›…å…³é—­

```go
func (s *Server) Start() error {
    // æ³¨å†ŒæœåŠ¡
    if err := s.registry.Register(s.serviceID, s.serviceName, s.host, s.port); err != nil {
        return err
    }
    
    // å¯åŠ¨HTTPæœåŠ¡å™¨
    server := &http.Server{
        Addr:    fmt.Sprintf(":%d", s.port),
        Handler: s.handler,
    }
    
    // ç›‘å¬ä¿¡å·
    stop := make(chan os.Signal, 1)
    signal.Notify(stop, os.Interrupt, syscall.SIGTERM)
    
    go func() {
        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Printf("Server error: %v", err)
        }
    }()
    
    <-stop
    log.Println("Shutting down server...")
    
    // æ³¨é”€æœåŠ¡
    s.registry.Deregister(s.serviceID)
    
    // ä¼˜é›…å…³é—­
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    return server.Shutdown(ctx)
}
```

---

## ğŸ”— ç›¸å…³èµ„æº

- [åˆ†å¸ƒå¼ç³»ç»Ÿ](../../advanced/distributed/README.md)
- [æœåŠ¡ç½‘æ ¼](./04-æœåŠ¡ç½‘æ ¼.md)
- [APIç½‘å…³](./05-APIç½‘å…³.md)

---

**æœ€åæ›´æ–°**: 2025-10-28  
**Goç‰ˆæœ¬**: 1.25.3

