# 微服务架构

> **简介**: 微服务架构完整指南，包括架构原则、设计模式、通信机制和最佳实践

> **版本**: Go 1.25.3  
> **难度**: ⭐⭐⭐⭐  
> **标签**: #微服务 #架构 #分布式

---

## 📚 目录

1. [微服务概述](#微服务概述)
2. [服务拆分](#服务拆分)
3. [通信机制](#通信机制)
4. [服务发现](#服务发现)
5. [配置管理](#配置管理)
6. [最佳实践](#最佳实践)

---

## 1. 微服务概述

### 微服务架构特点

**优势**:
- ✅ 独立部署
- ✅ 技术栈灵活
- ✅ 故障隔离
- ✅ 易于扩展
- ✅ 团队自治

**挑战**:
- ❌ 分布式复杂性
- ❌ 数据一致性
- ❌ 服务治理
- ❌ 测试复杂
- ❌ 运维成本

---

### 单体 vs 微服务

| 特性 | 单体应用 | 微服务 |
|------|---------|--------|
| **部署** | 整体部署 | 独立部署 |
| **扩展** | 垂直扩展 | 水平扩展 |
| **技术栈** | 统一 | 灵活 |
| **开发** | 简单 | 复杂 |
| **维护** | 集中 | 分散 |
| **故障** | 全局影响 | 局部隔离 |

---

## 2. 服务拆分

### 拆分原则

```go
// ❌ 单体应用
type MonolithService struct {
    userRepo    *UserRepository
    orderRepo   *OrderRepository
    productRepo *ProductRepository
    paymentRepo *PaymentRepository
}

// ✅ 微服务拆分
// 用户服务
type UserService struct {
    userRepo *UserRepository
}

// 订单服务
type OrderService struct {
    orderRepo    *OrderRepository
    userClient   *UserClient      // 调用用户服务
    productClient *ProductClient  // 调用产品服务
}

// 产品服务
type ProductService struct {
    productRepo *ProductRepository
}

// 支付服务
type PaymentService struct {
    paymentRepo  *PaymentRepository
    orderClient  *OrderClient     // 调用订单服务
}
```

---

### 按业务能力拆分

```
电商系统微服务拆分：

├── 用户服务 (User Service)
│   ├── 用户注册/登录
│   ├── 用户信息管理
│   └── 用户认证/授权
│
├── 产品服务 (Product Service)
│   ├── 产品目录
│   ├── 产品搜索
│   └── 库存管理
│
├── 订单服务 (Order Service)
│   ├── 订单创建
│   ├── 订单查询
│   └── 订单状态管理
│
├── 支付服务 (Payment Service)
│   ├── 支付处理
│   ├── 退款处理
│   └── 支付回调
│
└── 通知服务 (Notification Service)
    ├── 邮件通知
    ├── 短信通知
    └── 推送通知
```

---

### 服务边界定义

```go
// 用户服务 API
type UserService interface {
    // 用户管理
    CreateUser(ctx context.Context, req *CreateUserRequest) (*User, error)
    GetUser(ctx context.Context, id string) (*User, error)
    UpdateUser(ctx context.Context, req *UpdateUserRequest) (*User, error)
    
    // 认证
    Login(ctx context.Context, req *LoginRequest) (*AuthToken, error)
    ValidateToken(ctx context.Context, token string) (*User, error)
}

// 订单服务 API
type OrderService interface {
    // 订单管理
    CreateOrder(ctx context.Context, req *CreateOrderRequest) (*Order, error)
    GetOrder(ctx context.Context, id string) (*Order, error)
    ListOrders(ctx context.Context, userID string) ([]*Order, error)
    
    // 订单状态
    UpdateOrderStatus(ctx context.Context, id string, status OrderStatus) error
    CancelOrder(ctx context.Context, id string) error
}
```

---

## 3. 通信机制

### HTTP/REST通信

```go
// 订单服务调用用户服务
type UserClient struct {
    baseURL string
    client  *http.Client
}

func NewUserClient(baseURL string) *UserClient {
    return &UserClient{
        baseURL: baseURL,
        client: &http.Client{
            Timeout: 10 * time.Second,
        },
    }
}

func (c *UserClient) GetUser(ctx context.Context, userID string) (*User, error) {
    url := fmt.Sprintf("%s/users/%s", c.baseURL, userID)
    
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, err
    }
    
    resp, err := c.client.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("unexpected status: %d", resp.StatusCode)
    }
    
    var user User
    if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
        return nil, err
    }
    
    return &user, nil
}
```

---

### gRPC通信

```protobuf
// user.proto
syntax = "proto3";

package user;

service UserService {
    rpc GetUser(GetUserRequest) returns (User);
    rpc CreateUser(CreateUserRequest) returns (User);
}

message GetUserRequest {
    string id = 1;
}

message User {
    string id = 1;
    string name = 2;
    string email = 3;
}
```

**Go实现**:
```go
// 服务端
type userServiceServer struct {
    pb.UnimplementedUserServiceServer
    repo *UserRepository
}

func (s *userServiceServer) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.User, error) {
    user, err := s.repo.FindByID(ctx, req.Id)
    if err != nil {
        return nil, status.Error(codes.NotFound, "user not found")
    }
    
    return &pb.User{
        Id:    user.ID,
        Name:  user.Name,
        Email: user.Email,
    }, nil
}

// 客户端
type UserClient struct {
    client pb.UserServiceClient
}

func NewUserClient(conn *grpc.ClientConn) *UserClient {
    return &UserClient{
        client: pb.NewUserServiceClient(conn),
    }
}

func (c *UserClient) GetUser(ctx context.Context, userID string) (*pb.User, error) {
    return c.client.GetUser(ctx, &pb.GetUserRequest{
        Id: userID,
    })
}
```

---

### 消息队列通信

```go
// 订单服务发布订单创建事件
type OrderEventPublisher struct {
    producer *kafka.Producer
}

func (p *OrderEventPublisher) PublishOrderCreated(order *Order) error {
    event := OrderCreatedEvent{
        OrderID:   order.ID,
        UserID:    order.UserID,
        Amount:    order.Amount,
        Timestamp: time.Now(),
    }
    
    data, err := json.Marshal(event)
    if err != nil {
        return err
    }
    
    return p.producer.Produce(&kafka.Message{
        TopicPartition: kafka.TopicPartition{
            Topic:     kafka.StringToTopicName("order.created"),
            Partition: kafka.PartitionAny,
        },
        Value: data,
    }, nil)
}

// 通知服务订阅订单创建事件
type NotificationService struct {
    consumer *kafka.Consumer
}

func (s *NotificationService) Start() error {
    s.consumer.Subscribe("order.created", nil)
    
    for {
        msg, err := s.consumer.ReadMessage(-1)
        if err != nil {
            return err
        }
        
        var event OrderCreatedEvent
        if err := json.Unmarshal(msg.Value, &event); err != nil {
            log.Printf("Failed to unmarshal event: %v", err)
            continue
        }
        
        // 发送通知
        s.sendOrderNotification(event)
    }
}
```

---

## 4. 服务发现

### Consul服务注册

```go
import "github.com/hashicorp/consul/api"

type ServiceRegistry struct {
    client *api.Client
}

func NewServiceRegistry(consulAddr string) (*ServiceRegistry, error) {
    config := api.DefaultConfig()
    config.Address = consulAddr
    
    client, err := api.NewClient(config)
    if err != nil {
        return nil, err
    }
    
    return &ServiceRegistry{client: client}, nil
}

// 注册服务
func (r *ServiceRegistry) Register(serviceID, serviceName, address string, port int) error {
    registration := &api.AgentServiceRegistration{
        ID:      serviceID,
        Name:    serviceName,
        Address: address,
        Port:    port,
        Check: &api.AgentServiceCheck{
            HTTP:     fmt.Sprintf("http://%s:%d/health", address, port),
            Interval: "10s",
            Timeout:  "3s",
        },
    }
    
    return r.client.Agent().ServiceRegister(registration)
}

// 注销服务
func (r *ServiceRegistry) Deregister(serviceID string) error {
    return r.client.Agent().ServiceDeregister(serviceID)
}

// 发现服务
func (r *ServiceRegistry) Discover(serviceName string) ([]*api.ServiceEntry, error) {
    services, _, err := r.client.Health().Service(serviceName, "", true, nil)
    return services, err
}
```

---

### 负载均衡

```go
type LoadBalancer struct {
    registry *ServiceRegistry
    strategy LoadBalanceStrategy
}

type LoadBalanceStrategy interface {
    Select(services []*api.ServiceEntry) *api.ServiceEntry
}

// 轮询策略
type RoundRobinStrategy struct {
    counter uint32
}

func (s *RoundRobinStrategy) Select(services []*api.ServiceEntry) *api.ServiceEntry {
    if len(services) == 0 {
        return nil
    }
    
    index := atomic.AddUint32(&s.counter, 1) % uint32(len(services))
    return services[index]
}

// 随机策略
type RandomStrategy struct{}

func (s *RandomStrategy) Select(services []*api.ServiceEntry) *api.ServiceEntry {
    if len(services) == 0 {
        return nil
    }
    
    return services[rand.Intn(len(services))]
}

// 使用
func (lb *LoadBalancer) GetService(serviceName string) (string, error) {
    services, err := lb.registry.Discover(serviceName)
    if err != nil {
        return "", err
    }
    
    selected := lb.strategy.Select(services)
    if selected == nil {
        return "", errors.New("no service available")
    }
    
    return fmt.Sprintf("http://%s:%d", 
        selected.Service.Address, 
        selected.Service.Port), nil
}
```

---

## 5. 配置管理

### Consul KV配置

```go
type ConfigManager struct {
    client *api.Client
    prefix string
}

func NewConfigManager(consulAddr, prefix string) (*ConfigManager, error) {
    config := api.DefaultConfig()
    config.Address = consulAddr
    
    client, err := api.NewClient(config)
    if err != nil {
        return nil, err
    }
    
    return &ConfigManager{
        client: client,
        prefix: prefix,
    }, nil
}

// 获取配置
func (m *ConfigManager) Get(key string) (string, error) {
    fullKey := fmt.Sprintf("%s/%s", m.prefix, key)
    
    pair, _, err := m.client.KV().Get(fullKey, nil)
    if err != nil {
        return "", err
    }
    
    if pair == nil {
        return "", fmt.Errorf("key not found: %s", key)
    }
    
    return string(pair.Value), nil
}

// 设置配置
func (m *ConfigManager) Set(key, value string) error {
    fullKey := fmt.Sprintf("%s/%s", m.prefix, key)
    
    pair := &api.KVPair{
        Key:   fullKey,
        Value: []byte(value),
    }
    
    _, err := m.client.KV().Put(pair, nil)
    return err
}

// 监听配置变更
func (m *ConfigManager) Watch(key string, callback func(string)) {
    fullKey := fmt.Sprintf("%s/%s", m.prefix, key)
    var lastIndex uint64
    
    for {
        pair, meta, err := m.client.KV().Get(fullKey, &api.QueryOptions{
            WaitIndex: lastIndex,
        })
        
        if err != nil {
            log.Printf("Watch error: %v", err)
            time.Sleep(5 * time.Second)
            continue
        }
        
        if pair != nil && meta.LastIndex > lastIndex {
            lastIndex = meta.LastIndex
            callback(string(pair.Value))
        }
    }
}
```

---

## 6. 最佳实践

### 1. API Gateway

```go
type APIGateway struct {
    userClient    *UserClient
    orderClient   *OrderClient
    productClient *ProductClient
}

func (g *APIGateway) HandleRequest(w http.ResponseWriter, r *http.Request) {
    // 认证
    token := r.Header.Get("Authorization")
    user, err := g.userClient.ValidateToken(r.Context(), token)
    if err != nil {
        http.Error(w, "Unauthorized", http.StatusUnauthorized)
        return
    }
    
    // 路由到具体服务
    switch {
    case strings.HasPrefix(r.URL.Path, "/api/users"):
        g.proxyToUserService(w, r)
    case strings.HasPrefix(r.URL.Path, "/api/orders"):
        g.proxyToOrderService(w, r, user)
    case strings.HasPrefix(r.URL.Path, "/api/products"):
        g.proxyToProductService(w, r)
    default:
        http.NotFound(w, r)
    }
}
```

---

### 2. 熔断器

```go
import "github.com/sony/gobreaker"

type UserClient struct {
    baseURL string
    breaker *gobreaker.CircuitBreaker
}

func NewUserClient(baseURL string) *UserClient {
    settings := gobreaker.Settings{
        Name:        "UserService",
        MaxRequests: 3,
        Interval:    10 * time.Second,
        Timeout:     60 * time.Second,
        ReadyToTrip: func(counts gobreaker.Counts) bool {
            failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)
            return counts.Requests >= 3 && failureRatio >= 0.6
        },
    }
    
    return &UserClient{
        baseURL: baseURL,
        breaker: gobreaker.NewCircuitBreaker(settings),
    }
}

func (c *UserClient) GetUser(ctx context.Context, userID string) (*User, error) {
    result, err := c.breaker.Execute(func() (interface{}, error) {
        return c.doGetUser(ctx, userID)
    })
    
    if err != nil {
        return nil, err
    }
    
    return result.(*User), nil
}
```

---

### 3. 限流

```go
import "golang.org/x/time/rate"

type RateLimitedService struct {
    limiter *rate.Limiter
    service UserService
}

func NewRateLimitedService(rps int, service UserService) *RateLimitedService {
    return &RateLimitedService{
        limiter: rate.NewLimiter(rate.Limit(rps), rps),
        service: service,
    }
}

func (s *RateLimitedService) GetUser(ctx context.Context, userID string) (*User, error) {
    if err := s.limiter.Wait(ctx); err != nil {
        return nil, fmt.Errorf("rate limit exceeded: %w", err)
    }
    
    return s.service.GetUser(ctx, userID)
}
```

---

### 4. 分布式追踪

```go
import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

func (s *OrderService) CreateOrder(ctx context.Context, req *CreateOrderRequest) (*Order, error) {
    tracer := otel.Tracer("order-service")
    ctx, span := tracer.Start(ctx, "CreateOrder")
    defer span.End()
    
    // 验证用户
    _, span1 := tracer.Start(ctx, "ValidateUser")
    user, err := s.userClient.GetUser(ctx, req.UserID)
    span1.End()
    if err != nil {
        return nil, err
    }
    
    // 创建订单
    _, span2 := tracer.Start(ctx, "SaveOrder")
    order, err := s.orderRepo.Save(ctx, req)
    span2.End()
    if err != nil {
        return nil, err
    }
    
    // 发布事件
    _, span3 := tracer.Start(ctx, "PublishEvent")
    s.eventPublisher.PublishOrderCreated(order)
    span3.End()
    
    return order, nil
}
```

---

### 5. 健康检查

```go
type HealthChecker struct {
    db       *sql.DB
    registry *ServiceRegistry
}

func (h *HealthChecker) Check(w http.ResponseWriter, r *http.Request) {
    status := map[string]string{
        "status": "UP",
    }
    
    // 检查数据库
    if err := h.db.Ping(); err != nil {
        status["database"] = "DOWN"
        status["status"] = "DOWN"
    } else {
        status["database"] = "UP"
    }
    
    // 检查依赖服务
    services, err := h.registry.Discover("user-service")
    if err != nil || len(services) == 0 {
        status["user-service"] = "DOWN"
        status["status"] = "DEGRADED"
    } else {
        status["user-service"] = "UP"
    }
    
    code := http.StatusOK
    if status["status"] == "DOWN" {
        code = http.StatusServiceUnavailable
    }
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(code)
    json.NewEncoder(w).Encode(status)
}
```

---

### 6. 优雅关闭

```go
func (s *Server) Start() error {
    // 注册服务
    if err := s.registry.Register(s.serviceID, s.serviceName, s.host, s.port); err != nil {
        return err
    }
    
    // 启动HTTP服务器
    server := &http.Server{
        Addr:    fmt.Sprintf(":%d", s.port),
        Handler: s.handler,
    }
    
    // 监听信号
    stop := make(chan os.Signal, 1)
    signal.Notify(stop, os.Interrupt, syscall.SIGTERM)
    
    go func() {
        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Printf("Server error: %v", err)
        }
    }()
    
    <-stop
    log.Println("Shutting down server...")
    
    // 注销服务
    s.registry.Deregister(s.serviceID)
    
    // 优雅关闭
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    return server.Shutdown(ctx)
}
```

---

## 🔗 相关资源

- [分布式系统](../../advanced/distributed/README.md)
- [服务网格](./04-服务网格.md)
- [API网关](./05-API网关.md)

---

**最后更新**: 2025-10-28  
**Go版本**: 1.25.3

