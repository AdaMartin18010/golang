# å¾®æœåŠ¡æ¶æ„

> **ç®€ä»‹**: å¾®æœåŠ¡æ¶æ„å®Œæ•´æŒ‡å—ï¼ŒåŒ…æ‹¬æ¶æ„åŸåˆ™ã€è®¾è®¡æ¨¡å¼ã€é€šä¿¡æœºåˆ¶å’Œæœ€ä½³å®è·µ

> **ç‰ˆæœ¬**: Go 1.25.3  
> **éš¾åº¦**: â­â­â­â­  
> **æ ‡ç­¾**: #å¾®æœåŠ¡ #æ¶æ„ #åˆ†å¸ƒå¼

---

## ğŸ“‹ ç›®å½•


- [1. å¾®æœåŠ¡æ¦‚è¿°](#1-å¾®æœåŠ¡æ¦‚è¿°)
  - [å¾®æœåŠ¡æ¶æ„ç‰¹ç‚¹](#å¾®æœåŠ¡æ¶æ„ç‰¹ç‚¹)
  - [å•ä½“ vs å¾®æœåŠ¡](#å•ä½“-vs-å¾®æœåŠ¡)
- [2. æœåŠ¡æ‹†åˆ†](#2-æœåŠ¡æ‹†åˆ†)
  - [æ‹†åˆ†åŸåˆ™](#æ‹†åˆ†åŸåˆ™)
  - [æŒ‰ä¸šåŠ¡èƒ½åŠ›æ‹†åˆ†](#æŒ‰ä¸šåŠ¡èƒ½åŠ›æ‹†åˆ†)
  - [æœåŠ¡è¾¹ç•Œå®šä¹‰](#æœåŠ¡è¾¹ç•Œå®šä¹‰)
- [3. é€šä¿¡æœºåˆ¶](#3-é€šä¿¡æœºåˆ¶)
  - [HTTP/RESTé€šä¿¡](#httpresté€šä¿¡)
  - [gRPCé€šä¿¡](#grpcé€šä¿¡)
  - [æ¶ˆæ¯é˜Ÿåˆ—é€šä¿¡](#æ¶ˆæ¯é˜Ÿåˆ—é€šä¿¡)
- [4. æœåŠ¡å‘ç°](#4-æœåŠ¡å‘ç°)
  - [ConsulæœåŠ¡æ³¨å†Œ](#consulæœåŠ¡æ³¨å†Œ)
  - [è´Ÿè½½å‡è¡¡](#è´Ÿè½½å‡è¡¡)
- [5. é…ç½®ç®¡ç†](#5-é…ç½®ç®¡ç†)
  - [Consul KVé…ç½®](#consul-kvé…ç½®)
- [6. æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)
  - [1. API Gateway](#1-api-gateway)
  - [2. ç†”æ–­å™¨](#2-ç†”æ–­å™¨)
  - [3. é™æµ](#3-é™æµ)
  - [4. åˆ†å¸ƒå¼è¿½è¸ª](#4-åˆ†å¸ƒå¼è¿½è¸ª)
  - [5. å¥åº·æ£€æŸ¥](#5-å¥åº·æ£€æŸ¥)
  - [6. ä¼˜é›…å…³é—­](#6-ä¼˜é›…å…³é—­)
- [ğŸ’¼ å®Œæ•´å®æˆ˜æ¡ˆä¾‹ï¼šç”µå•†å¾®æœåŠ¡ç³»ç»Ÿ](#-å®Œæ•´å®æˆ˜æ¡ˆä¾‹ç”µå•†å¾®æœåŠ¡ç³»ç»Ÿ)
  - [ç³»ç»Ÿæ¶æ„è®¾è®¡](#ç³»ç»Ÿæ¶æ„è®¾è®¡)
  - [æœåŠ¡1: ç”¨æˆ·æœåŠ¡](#æœåŠ¡1-ç”¨æˆ·æœåŠ¡)
  - [æœåŠ¡2: è®¢å•æœåŠ¡](#æœåŠ¡2-è®¢å•æœåŠ¡)
  - [æœåŠ¡3: äº§å“æœåŠ¡](#æœåŠ¡3-äº§å“æœåŠ¡)
  - [API Gatewayé…ç½®](#api-gatewayé…ç½®)
  - [Docker Composeéƒ¨ç½²](#docker-composeéƒ¨ç½²)
  - [ç›‘æ§å’Œè¿½è¸ª](#ç›‘æ§å’Œè¿½è¸ª)
  - [æ€§èƒ½ä¼˜åŒ–ç»“æœ](#æ€§èƒ½ä¼˜åŒ–ç»“æœ)
  - [æ•…éšœå¤„ç†æ¡ˆä¾‹](#æ•…éšœå¤„ç†æ¡ˆä¾‹)
- [ğŸ”— ç›¸å…³èµ„æº](#-ç›¸å…³èµ„æº)

## 1. å¾®æœåŠ¡æ¦‚è¿°

### å¾®æœåŠ¡æ¶æ„ç‰¹ç‚¹

**ä¼˜åŠ¿**:
- âœ… ç‹¬ç«‹éƒ¨ç½²
- âœ… æŠ€æœ¯æ ˆçµæ´»
- âœ… æ•…éšœéš”ç¦»
- âœ… æ˜“äºæ‰©å±•
- âœ… å›¢é˜Ÿè‡ªæ²»

**æŒ‘æˆ˜**:
- âŒ åˆ†å¸ƒå¼å¤æ‚æ€§
- âŒ æ•°æ®ä¸€è‡´æ€§
- âŒ æœåŠ¡æ²»ç†
- âŒ æµ‹è¯•å¤æ‚
- âŒ è¿ç»´æˆæœ¬

---

### å•ä½“ vs å¾®æœåŠ¡

| ç‰¹æ€§ | å•ä½“åº”ç”¨ | å¾®æœåŠ¡ |
|------|---------|--------|
| **éƒ¨ç½²** | æ•´ä½“éƒ¨ç½² | ç‹¬ç«‹éƒ¨ç½² |
| **æ‰©å±•** | å‚ç›´æ‰©å±• | æ°´å¹³æ‰©å±• |
| **æŠ€æœ¯æ ˆ** | ç»Ÿä¸€ | çµæ´» |
| **å¼€å‘** | ç®€å• | å¤æ‚ |
| **ç»´æŠ¤** | é›†ä¸­ | åˆ†æ•£ |
| **æ•…éšœ** | å…¨å±€å½±å“ | å±€éƒ¨éš”ç¦» |

---

## 2. æœåŠ¡æ‹†åˆ†

### æ‹†åˆ†åŸåˆ™

```go
// âŒ å•ä½“åº”ç”¨
type MonolithService struct {
    userRepo    *UserRepository
    orderRepo   *OrderRepository
    productRepo *ProductRepository
    paymentRepo *PaymentRepository
}

// âœ… å¾®æœåŠ¡æ‹†åˆ†
// ç”¨æˆ·æœåŠ¡
type UserService struct {
    userRepo *UserRepository
}

// è®¢å•æœåŠ¡
type OrderService struct {
    orderRepo    *OrderRepository
    userClient   *UserClient      // è°ƒç”¨ç”¨æˆ·æœåŠ¡
    productClient *ProductClient  // è°ƒç”¨äº§å“æœåŠ¡
}

// äº§å“æœåŠ¡
type ProductService struct {
    productRepo *ProductRepository
}

// æ”¯ä»˜æœåŠ¡
type PaymentService struct {
    paymentRepo  *PaymentRepository
    orderClient  *OrderClient     // è°ƒç”¨è®¢å•æœåŠ¡
}
```

---

### æŒ‰ä¸šåŠ¡èƒ½åŠ›æ‹†åˆ†

```
ç”µå•†ç³»ç»Ÿå¾®æœåŠ¡æ‹†åˆ†ï¼š

â”œâ”€â”€ ç”¨æˆ·æœåŠ¡ (User Service)
â”‚   â”œâ”€â”€ ç”¨æˆ·æ³¨å†Œ/ç™»å½•
â”‚   â”œâ”€â”€ ç”¨æˆ·ä¿¡æ¯ç®¡ç†
â”‚   â””â”€â”€ ç”¨æˆ·è®¤è¯/æˆæƒ
â”‚
â”œâ”€â”€ äº§å“æœåŠ¡ (Product Service)
â”‚   â”œâ”€â”€ äº§å“ç›®å½•
â”‚   â”œâ”€â”€ äº§å“æœç´¢
â”‚   â””â”€â”€ åº“å­˜ç®¡ç†
â”‚
â”œâ”€â”€ è®¢å•æœåŠ¡ (Order Service)
â”‚   â”œâ”€â”€ è®¢å•åˆ›å»º
â”‚   â”œâ”€â”€ è®¢å•æŸ¥è¯¢
â”‚   â””â”€â”€ è®¢å•çŠ¶æ€ç®¡ç†
â”‚
â”œâ”€â”€ æ”¯ä»˜æœåŠ¡ (Payment Service)
â”‚   â”œâ”€â”€ æ”¯ä»˜å¤„ç†
â”‚   â”œâ”€â”€ é€€æ¬¾å¤„ç†
â”‚   â””â”€â”€ æ”¯ä»˜å›è°ƒ
â”‚
â””â”€â”€ é€šçŸ¥æœåŠ¡ (Notification Service)
    â”œâ”€â”€ é‚®ä»¶é€šçŸ¥
    â”œâ”€â”€ çŸ­ä¿¡é€šçŸ¥
    â””â”€â”€ æ¨é€é€šçŸ¥
```

---

### æœåŠ¡è¾¹ç•Œå®šä¹‰

```go
// ç”¨æˆ·æœåŠ¡ API
type UserService interface {
    // ç”¨æˆ·ç®¡ç†
    CreateUser(ctx context.Context, req *CreateUserRequest) (*User, error)
    GetUser(ctx context.Context, id string) (*User, error)
    UpdateUser(ctx context.Context, req *UpdateUserRequest) (*User, error)
    
    // è®¤è¯
    Login(ctx context.Context, req *LoginRequest) (*AuthToken, error)
    ValidateToken(ctx context.Context, token string) (*User, error)
}

// è®¢å•æœåŠ¡ API
type OrderService interface {
    // è®¢å•ç®¡ç†
    CreateOrder(ctx context.Context, req *CreateOrderRequest) (*Order, error)
    GetOrder(ctx context.Context, id string) (*Order, error)
    ListOrders(ctx context.Context, userID string) ([]*Order, error)
    
    // è®¢å•çŠ¶æ€
    UpdateOrderStatus(ctx context.Context, id string, status OrderStatus) error
    CancelOrder(ctx context.Context, id string) error
}
```

---

## 3. é€šä¿¡æœºåˆ¶

### HTTP/RESTé€šä¿¡

```go
// è®¢å•æœåŠ¡è°ƒç”¨ç”¨æˆ·æœåŠ¡
type UserClient struct {
    baseURL string
    client  *http.Client
}

func NewUserClient(baseURL string) *UserClient {
    return &UserClient{
        baseURL: baseURL,
        client: &http.Client{
            Timeout: 10 * time.Second,
        },
    }
}

func (c *UserClient) GetUser(ctx context.Context, userID string) (*User, error) {
    url := fmt.Sprintf("%s/users/%s", c.baseURL, userID)
    
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, err
    }
    
    resp, err := c.client.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("unexpected status: %d", resp.StatusCode)
    }
    
    var user User
    if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
        return nil, err
    }
    
    return &user, nil
}
```

---

### gRPCé€šä¿¡

```protobuf
// user.proto
syntax = "proto3";

package user;

service UserService {
    rpc GetUser(GetUserRequest) returns (User);
    rpc CreateUser(CreateUserRequest) returns (User);
}

message GetUserRequest {
    string id = 1;
}

message User {
    string id = 1;
    string name = 2;
    string email = 3;
}
```

**Goå®ç°**:
```go
// æœåŠ¡ç«¯
type userServiceServer struct {
    pb.UnimplementedUserServiceServer
    repo *UserRepository
}

func (s *userServiceServer) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.User, error) {
    user, err := s.repo.FindByID(ctx, req.Id)
    if err != nil {
        return nil, status.Error(codes.NotFound, "user not found")
    }
    
    return &pb.User{
        Id:    user.ID,
        Name:  user.Name,
        Email: user.Email,
    }, nil
}

// å®¢æˆ·ç«¯
type UserClient struct {
    client pb.UserServiceClient
}

func NewUserClient(conn *grpc.ClientConn) *UserClient {
    return &UserClient{
        client: pb.NewUserServiceClient(conn),
    }
}

func (c *UserClient) GetUser(ctx context.Context, userID string) (*pb.User, error) {
    return c.client.GetUser(ctx, &pb.GetUserRequest{
        Id: userID,
    })
}
```

---

### æ¶ˆæ¯é˜Ÿåˆ—é€šä¿¡

```go
// è®¢å•æœåŠ¡å‘å¸ƒè®¢å•åˆ›å»ºäº‹ä»¶
type OrderEventPublisher struct {
    producer *kafka.Producer
}

func (p *OrderEventPublisher) PublishOrderCreated(order *Order) error {
    event := OrderCreatedEvent{
        OrderID:   order.ID,
        UserID:    order.UserID,
        Amount:    order.Amount,
        Timestamp: time.Now(),
    }
    
    data, err := json.Marshal(event)
    if err != nil {
        return err
    }
    
    return p.producer.Produce(&kafka.Message{
        TopicPartition: kafka.TopicPartition{
            Topic:     kafka.StringToTopicName("order.created"),
            Partition: kafka.PartitionAny,
        },
        Value: data,
    }, nil)
}

// é€šçŸ¥æœåŠ¡è®¢é˜…è®¢å•åˆ›å»ºäº‹ä»¶
type NotificationService struct {
    consumer *kafka.Consumer
}

func (s *NotificationService) Start() error {
    s.consumer.Subscribe("order.created", nil)
    
    for {
        msg, err := s.consumer.ReadMessage(-1)
        if err != nil {
            return err
        }
        
        var event OrderCreatedEvent
        if err := json.Unmarshal(msg.Value, &event); err != nil {
            log.Printf("Failed to unmarshal event: %v", err)
            continue
        }
        
        // å‘é€é€šçŸ¥
        s.sendOrderNotification(event)
    }
}
```

---

## 4. æœåŠ¡å‘ç°

### ConsulæœåŠ¡æ³¨å†Œ

```go
import "github.com/hashicorp/consul/api"

type ServiceRegistry struct {
    client *api.Client
}

func NewServiceRegistry(consulAddr string) (*ServiceRegistry, error) {
    config := api.DefaultConfig()
    config.Address = consulAddr
    
    client, err := api.NewClient(config)
    if err != nil {
        return nil, err
    }
    
    return &ServiceRegistry{client: client}, nil
}

// æ³¨å†ŒæœåŠ¡
func (r *ServiceRegistry) Register(serviceID, serviceName, address string, port int) error {
    registration := &api.AgentServiceRegistration{
        ID:      serviceID,
        Name:    serviceName,
        Address: address,
        Port:    port,
        Check: &api.AgentServiceCheck{
            HTTP:     fmt.Sprintf("http://%s:%d/health", address, port),
            Interval: "10s",
            Timeout:  "3s",
        },
    }
    
    return r.client.Agent().ServiceRegister(registration)
}

// æ³¨é”€æœåŠ¡
func (r *ServiceRegistry) Deregister(serviceID string) error {
    return r.client.Agent().ServiceDeregister(serviceID)
}

// å‘ç°æœåŠ¡
func (r *ServiceRegistry) Discover(serviceName string) ([]*api.ServiceEntry, error) {
    services, _, err := r.client.Health().Service(serviceName, "", true, nil)
    return services, err
}
```

---

### è´Ÿè½½å‡è¡¡

```go
type LoadBalancer struct {
    registry *ServiceRegistry
    strategy LoadBalanceStrategy
}

type LoadBalanceStrategy interface {
    Select(services []*api.ServiceEntry) *api.ServiceEntry
}

// è½®è¯¢ç­–ç•¥
type RoundRobinStrategy struct {
    counter uint32
}

func (s *RoundRobinStrategy) Select(services []*api.ServiceEntry) *api.ServiceEntry {
    if len(services) == 0 {
        return nil
    }
    
    index := atomic.AddUint32(&s.counter, 1) % uint32(len(services))
    return services[index]
}

// éšæœºç­–ç•¥
type RandomStrategy struct{}

func (s *RandomStrategy) Select(services []*api.ServiceEntry) *api.ServiceEntry {
    if len(services) == 0 {
        return nil
    }
    
    return services[rand.Intn(len(services))]
}

// ä½¿ç”¨
func (lb *LoadBalancer) GetService(serviceName string) (string, error) {
    services, err := lb.registry.Discover(serviceName)
    if err != nil {
        return "", err
    }
    
    selected := lb.strategy.Select(services)
    if selected == nil {
        return "", errors.New("no service available")
    }
    
    return fmt.Sprintf("http://%s:%d", 
        selected.Service.Address, 
        selected.Service.Port), nil
}
```

---

## 5. é…ç½®ç®¡ç†

### Consul KVé…ç½®

```go
type ConfigManager struct {
    client *api.Client
    prefix string
}

func NewConfigManager(consulAddr, prefix string) (*ConfigManager, error) {
    config := api.DefaultConfig()
    config.Address = consulAddr
    
    client, err := api.NewClient(config)
    if err != nil {
        return nil, err
    }
    
    return &ConfigManager{
        client: client,
        prefix: prefix,
    }, nil
}

// è·å–é…ç½®
func (m *ConfigManager) Get(key string) (string, error) {
    fullKey := fmt.Sprintf("%s/%s", m.prefix, key)
    
    pair, _, err := m.client.KV().Get(fullKey, nil)
    if err != nil {
        return "", err
    }
    
    if pair == nil {
        return "", fmt.Errorf("key not found: %s", key)
    }
    
    return string(pair.Value), nil
}

// è®¾ç½®é…ç½®
func (m *ConfigManager) Set(key, value string) error {
    fullKey := fmt.Sprintf("%s/%s", m.prefix, key)
    
    pair := &api.KVPair{
        Key:   fullKey,
        Value: []byte(value),
    }
    
    _, err := m.client.KV().Put(pair, nil)
    return err
}

// ç›‘å¬é…ç½®å˜æ›´
func (m *ConfigManager) Watch(key string, callback func(string)) {
    fullKey := fmt.Sprintf("%s/%s", m.prefix, key)
    var lastIndex uint64
    
    for {
        pair, meta, err := m.client.KV().Get(fullKey, &api.QueryOptions{
            WaitIndex: lastIndex,
        })
        
        if err != nil {
            log.Printf("Watch error: %v", err)
            time.Sleep(5 * time.Second)
            continue
        }
        
        if pair != nil && meta.LastIndex > lastIndex {
            lastIndex = meta.LastIndex
            callback(string(pair.Value))
        }
    }
}
```

---

## 6. æœ€ä½³å®è·µ

### 1. API Gateway

```go
type APIGateway struct {
    userClient    *UserClient
    orderClient   *OrderClient
    productClient *ProductClient
}

func (g *APIGateway) HandleRequest(w http.ResponseWriter, r *http.Request) {
    // è®¤è¯
    token := r.Header.Get("Authorization")
    user, err := g.userClient.ValidateToken(r.Context(), token)
    if err != nil {
        http.Error(w, "Unauthorized", http.StatusUnauthorized)
        return
    }
    
    // è·¯ç”±åˆ°å…·ä½“æœåŠ¡
    switch {
    case strings.HasPrefix(r.URL.Path, "/api/users"):
        g.proxyToUserService(w, r)
    case strings.HasPrefix(r.URL.Path, "/api/orders"):
        g.proxyToOrderService(w, r, user)
    case strings.HasPrefix(r.URL.Path, "/api/products"):
        g.proxyToProductService(w, r)
    default:
        http.NotFound(w, r)
    }
}
```

---

### 2. ç†”æ–­å™¨

```go
import "github.com/sony/gobreaker"

type UserClient struct {
    baseURL string
    breaker *gobreaker.CircuitBreaker
}

func NewUserClient(baseURL string) *UserClient {
    settings := gobreaker.Settings{
        Name:        "UserService",
        MaxRequests: 3,
        Interval:    10 * time.Second,
        Timeout:     60 * time.Second,
        ReadyToTrip: func(counts gobreaker.Counts) bool {
            failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)
            return counts.Requests >= 3 && failureRatio >= 0.6
        },
    }
    
    return &UserClient{
        baseURL: baseURL,
        breaker: gobreaker.NewCircuitBreaker(settings),
    }
}

func (c *UserClient) GetUser(ctx context.Context, userID string) (*User, error) {
    result, err := c.breaker.Execute(func() (interface{}, error) {
        return c.doGetUser(ctx, userID)
    })
    
    if err != nil {
        return nil, err
    }
    
    return result.(*User), nil
}
```

---

### 3. é™æµ

```go
import "golang.org/x/time/rate"

type RateLimitedService struct {
    limiter *rate.Limiter
    service UserService
}

func NewRateLimitedService(rps int, service UserService) *RateLimitedService {
    return &RateLimitedService{
        limiter: rate.NewLimiter(rate.Limit(rps), rps),
        service: service,
    }
}

func (s *RateLimitedService) GetUser(ctx context.Context, userID string) (*User, error) {
    if err := s.limiter.Wait(ctx); err != nil {
        return nil, fmt.Errorf("rate limit exceeded: %w", err)
    }
    
    return s.service.GetUser(ctx, userID)
}
```

---

### 4. åˆ†å¸ƒå¼è¿½è¸ª

```go
import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

func (s *OrderService) CreateOrder(ctx context.Context, req *CreateOrderRequest) (*Order, error) {
    tracer := otel.Tracer("order-service")
    ctx, span := tracer.Start(ctx, "CreateOrder")
    defer span.End()
    
    // éªŒè¯ç”¨æˆ·
    _, span1 := tracer.Start(ctx, "ValidateUser")
    user, err := s.userClient.GetUser(ctx, req.UserID)
    span1.End()
    if err != nil {
        return nil, err
    }
    
    // åˆ›å»ºè®¢å•
    _, span2 := tracer.Start(ctx, "SaveOrder")
    order, err := s.orderRepo.Save(ctx, req)
    span2.End()
    if err != nil {
        return nil, err
    }
    
    // å‘å¸ƒäº‹ä»¶
    _, span3 := tracer.Start(ctx, "PublishEvent")
    s.eventPublisher.PublishOrderCreated(order)
    span3.End()
    
    return order, nil
}
```

---

### 5. å¥åº·æ£€æŸ¥

```go
type HealthChecker struct {
    db       *sql.DB
    registry *ServiceRegistry
}

func (h *HealthChecker) Check(w http.ResponseWriter, r *http.Request) {
    status := map[string]string{
        "status": "UP",
    }
    
    // æ£€æŸ¥æ•°æ®åº“
    if err := h.db.Ping(); err != nil {
        status["database"] = "DOWN"
        status["status"] = "DOWN"
    } else {
        status["database"] = "UP"
    }
    
    // æ£€æŸ¥ä¾èµ–æœåŠ¡
    services, err := h.registry.Discover("user-service")
    if err != nil || len(services) == 0 {
        status["user-service"] = "DOWN"
        status["status"] = "DEGRADED"
    } else {
        status["user-service"] = "UP"
    }
    
    code := http.StatusOK
    if status["status"] == "DOWN" {
        code = http.StatusServiceUnavailable
    }
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(code)
    json.NewEncoder(w).Encode(status)
}
```

---

### 6. ä¼˜é›…å…³é—­

```go
func (s *Server) Start() error {
    // æ³¨å†ŒæœåŠ¡
    if err := s.registry.Register(s.serviceID, s.serviceName, s.host, s.port); err != nil {
        return err
    }
    
    // å¯åŠ¨HTTPæœåŠ¡å™¨
    server := &http.Server{
        Addr:    fmt.Sprintf(":%d", s.port),
        Handler: s.handler,
    }
    
    // ç›‘å¬ä¿¡å·
    stop := make(chan os.Signal, 1)
    signal.Notify(stop, os.Interrupt, syscall.SIGTERM)
    
    go func() {
        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Printf("Server error: %v", err)
        }
    }()
    
    <-stop
    log.Println("Shutting down server...")
    
    // æ³¨é”€æœåŠ¡
    s.registry.Deregister(s.serviceID)
    
    // ä¼˜é›…å…³é—­
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    return server.Shutdown(ctx)
}
```

---

---

## ğŸ’¼ å®Œæ•´å®æˆ˜æ¡ˆä¾‹ï¼šç”µå•†å¾®æœåŠ¡ç³»ç»Ÿ

### ç³»ç»Ÿæ¶æ„è®¾è®¡

```
                    [å®¢æˆ·ç«¯/å‰ç«¯]
                          |
                          â†“
                    [API Gateway]
                    (Kong/APISIX)
                          |
        +-----------------+------------------+
        â†“                 â†“                  â†“
   [ç”¨æˆ·æœåŠ¡]        [è®¢å•æœåŠ¡]         [äº§å“æœåŠ¡]
   User Service    Order Service    Product Service
        |                 |                  |
        â†“                 â†“                  â†“
   [ç”¨æˆ·DB]          [è®¢å•DB]           [äº§å“DB]
   PostgreSQL       PostgreSQL        PostgreSQL
        
        +------------------+------------------+
                          â†“
                    [æ¶ˆæ¯é˜Ÿåˆ—]
                     (Kafka)
                          |
                          â†“
                    [é€šçŸ¥æœåŠ¡]
                Notification Service
```

---

### æœåŠ¡1: ç”¨æˆ·æœåŠ¡

```go
// cmd/user-service/main.go
package main

import (
    "context"
    "log"
    "net"
    
    "google.golang.org/grpc"
    "github.com/mycompany/ecommerce/proto/user"
    "github.com/mycompany/ecommerce/internal/user/service"
    "github.com/mycompany/ecommerce/internal/user/repository"
)

func main() {
    // è¿æ¥æ•°æ®åº“
    db, err := connectDB()
    if err != nil {
        log.Fatal(err)
    }
    
    // åˆå§‹åŒ–Repository
    userRepo := repository.NewUserRepository(db)
    
    // åˆå§‹åŒ–Service
    userService := service.NewUserService(userRepo)
    
    // åˆ›å»ºgRPCæœåŠ¡å™¨
    grpcServer := grpc.NewServer(
        grpc.UnaryInterceptor(loggingInterceptor),
        grpc.UnaryInterceptor(tracingInterceptor),
    )
    
    // æ³¨å†ŒæœåŠ¡
    user.RegisterUserServiceServer(grpcServer, userService)
    
    // å¯åŠ¨æœåŠ¡å™¨
    lis, err := net.Listen("tcp", ":50051")
    if err != nil {
        log.Fatal(err)
    }
    
    log.Println("User service listening on :50051")
    if err := grpcServer.Serve(lis); err != nil {
        log.Fatal(err)
    }
}
```

**ç”¨æˆ·æœåŠ¡å®ç°**:

```go
// internal/user/service/service.go
package service

import (
    "context"
    "errors"
    
    pb "github.com/mycompany/ecommerce/proto/user"
    "github.com/mycompany/ecommerce/internal/user/repository"
)

type UserService struct {
    pb.UnimplementedUserServiceServer
    repo *repository.UserRepository
}

func NewUserService(repo *repository.UserRepository) *UserService {
    return &UserService{repo: repo}
}

func (s *UserService) CreateUser(ctx context.Context, req *pb.CreateUserRequest) (*pb.User, error) {
    // éªŒè¯è¯·æ±‚
    if err := validateCreateUser(req); err != nil {
        return nil, err
    }
    
    // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
    existing, _ := s.repo.FindByEmail(ctx, req.Email)
    if existing != nil {
        return nil, errors.New("email already exists")
    }
    
    // åˆ›å»ºç”¨æˆ·
    user := &repository.User{
        Name:     req.Name,
        Email:    req.Email,
        Password: hashPassword(req.Password),
    }
    
    if err := s.repo.Create(ctx, user); err != nil {
        return nil, err
    }
    
    return &pb.User{
        Id:    user.ID,
        Name:  user.Name,
        Email: user.Email,
    }, nil
}

func (s *UserService) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.User, error) {
    user, err := s.repo.FindByID(ctx, req.Id)
    if err != nil {
        return nil, err
    }
    
    return &pb.User{
        Id:    user.ID,
        Name:  user.Name,
        Email: user.Email,
    }, nil
}
```

---

### æœåŠ¡2: è®¢å•æœåŠ¡

```go
// internal/order/service/service.go
package service

import (
    "context"
    
    pb "github.com/mycompany/ecommerce/proto/order"
    userpb "github.com/mycompany/ecommerce/proto/user"
    productpb "github.com/mycompany/ecommerce/proto/product"
)

type OrderService struct {
    pb.UnimplementedOrderServiceServer
    repo          *repository.OrderRepository
    userClient    userpb.UserServiceClient
    productClient productpb.ProductServiceClient
    eventBus      *kafka.Producer
}

func (s *OrderService) CreateOrder(ctx context.Context, req *pb.CreateOrderRequest) (*pb.Order, error) {
    // 1. éªŒè¯ç”¨æˆ·
    user, err := s.userClient.GetUser(ctx, &userpb.GetUserRequest{
        Id: req.UserId,
    })
    if err != nil {
        return nil, err
    }
    
    // 2. éªŒè¯äº§å“å’Œè®¡ç®—ä»·æ ¼
    var totalAmount float64
    for _, item := range req.Items {
        product, err := s.productClient.GetProduct(ctx, &productpb.GetProductRequest{
            Id: item.ProductId,
        })
        if err != nil {
            return nil, err
        }
        
        // æ£€æŸ¥åº“å­˜
        if product.Stock < item.Quantity {
            return nil, errors.New("insufficient stock")
        }
        
        totalAmount += product.Price * float64(item.Quantity)
    }
    
    // 3. åˆ›å»ºè®¢å•
    order := &repository.Order{
        UserID:      req.UserId,
        TotalAmount: totalAmount,
        Status:      "pending",
    }
    
    if err := s.repo.Create(ctx, order); err != nil {
        return nil, err
    }
    
    // 4. å‘å¸ƒè®¢å•åˆ›å»ºäº‹ä»¶
    event := OrderCreatedEvent{
        OrderID:     order.ID,
        UserID:      order.UserID,
        TotalAmount: order.TotalAmount,
        Timestamp:   time.Now(),
    }
    
    if err := s.publishEvent("order.created", event); err != nil {
        log.Printf("Failed to publish event: %v", err)
    }
    
    return &pb.Order{
        Id:          order.ID,
        UserId:      order.UserID,
        TotalAmount: order.TotalAmount,
        Status:      order.Status,
    }, nil
}
```

---

### æœåŠ¡3: äº§å“æœåŠ¡

```go
// internal/product/service/service.go
package service

import (
    "context"
    
    pb "github.com/mycompany/ecommerce/proto/product"
)

type ProductService struct {
    pb.UnimplementedProductServiceServer
    repo  *repository.ProductRepository
    cache *redis.Client
}

func (s *ProductService) GetProduct(ctx context.Context, req *pb.GetProductRequest) (*pb.Product, error) {
    // 1. å°è¯•ä»ç¼“å­˜è·å–
    cacheKey := fmt.Sprintf("product:%s", req.Id)
    if cached, err := s.cache.Get(ctx, cacheKey).Result(); err == nil {
        var product pb.Product
        if err := json.Unmarshal([]byte(cached), &product); err == nil {
            return &product, nil
        }
    }
    
    // 2. ä»æ•°æ®åº“è·å–
    product, err := s.repo.FindByID(ctx, req.Id)
    if err != nil {
        return nil, err
    }
    
    // 3. å†™å…¥ç¼“å­˜
    if data, err := json.Marshal(product); err == nil {
        s.cache.Set(ctx, cacheKey, data, 10*time.Minute)
    }
    
    return &pb.Product{
        Id:          product.ID,
        Name:        product.Name,
        Description: product.Description,
        Price:       product.Price,
        Stock:       product.Stock,
    }, nil
}

func (s *ProductService) UpdateStock(ctx context.Context, req *pb.UpdateStockRequest) (*pb.Product, error) {
    // ä½¿ç”¨åˆ†å¸ƒå¼é”é˜²æ­¢å¹¶å‘é—®é¢˜
    lockKey := fmt.Sprintf("lock:product:%s", req.ProductId)
    lock := s.acquireDistributedLock(ctx, lockKey)
    defer lock.Release()
    
    // æ›´æ–°åº“å­˜
    product, err := s.repo.FindByID(ctx, req.ProductId)
    if err != nil {
        return nil, err
    }
    
    newStock := product.Stock + req.Delta
    if newStock < 0 {
        return nil, errors.New("insufficient stock")
    }
    
    product.Stock = newStock
    if err := s.repo.Update(ctx, product); err != nil {
        return nil, err
    }
    
    // æ¸…é™¤ç¼“å­˜
    cacheKey := fmt.Sprintf("product:%s", req.ProductId)
    s.cache.Del(ctx, cacheKey)
    
    return &pb.Product{
        Id:    product.ID,
        Name:  product.Name,
        Price: product.Price,
        Stock: product.Stock,
    }, nil
}
```

---

### API Gatewayé…ç½®

```yaml
# kong.yml
services:
  - name: user-service
    url: http://user-service:50051
    routes:
      - name: user-route
        paths:
          - /api/users
        methods:
          - GET
          - POST
        plugins:
          - name: rate-limiting
            config:
              minute: 100
          - name: jwt
            config:
              key_claim_name: kid

  - name: order-service
    url: http://order-service:50052
    routes:
      - name: order-route
        paths:
          - /api/orders
        methods:
          - GET
          - POST
        plugins:
          - name: jwt
          - name: request-transformer
            config:
              add:
                headers:
                  - X-User-ID:$(jwt.sub)

  - name: product-service
    url: http://product-service:50053
    routes:
      - name: product-route
        paths:
          - /api/products
        methods:
          - GET
```

---

### Docker Composeéƒ¨ç½²

```yaml
# docker-compose.yml
version: '3.8'

services:
  # API Gateway
  kong:
    image: kong:latest
    environment:
      KONG_DATABASE: postgres
      KONG_PG_HOST: kong-db
    ports:
      - "8000:8000"
      - "8001:8001"
    depends_on:
      - kong-db

  # ç”¨æˆ·æœåŠ¡
  user-service:
    build: ./services/user
    environment:
      DB_HOST: user-db
      CONSUL_ADDR: consul:8500
    ports:
      - "50051:50051"
    depends_on:
      - user-db
      - consul

  # è®¢å•æœåŠ¡
  order-service:
    build: ./services/order
    environment:
      DB_HOST: order-db
      KAFKA_BROKERS: kafka:9092
    ports:
      - "50052:50052"
    depends_on:
      - order-db
      - kafka

  # äº§å“æœåŠ¡
  product-service:
    build: ./services/product
    environment:
      DB_HOST: product-db
      REDIS_ADDR: redis:6379
    ports:
      - "50053:50053"
    depends_on:
      - product-db
      - redis

  # æ•°æ®åº“
  user-db:
    image: postgres:15
    environment:
      POSTGRES_DB: users
  
  order-db:
    image: postgres:15
    environment:
      POSTGRES_DB: orders
  
  product-db:
    image: postgres:15
    environment:
      POSTGRES_DB: products

  # Redis
  redis:
    image: redis:7-alpine

  # Kafka
  kafka:
    image: confluentinc/cp-kafka:latest
    environment:
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181

  # Consul
  consul:
    image: consul:latest
    ports:
      - "8500:8500"
```

---

### ç›‘æ§å’Œè¿½è¸ª

```go
// internal/middleware/tracing.go
package middleware

import (
    "context"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
    "google.golang.org/grpc"
)

func TracingInterceptor() grpc.UnaryServerInterceptor {
    return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
        tracer := otel.Tracer("ecommerce")
        ctx, span := tracer.Start(ctx, info.FullMethod)
        defer span.End()
        
        // æ·»åŠ å±æ€§
        span.SetAttributes(
            attribute.String("service", "user-service"),
            attribute.String("method", info.FullMethod),
        )
        
        resp, err := handler(ctx, req)
        if err != nil {
            span.RecordError(err)
        }
        
        return resp, err
    }
}
```

---

### æ€§èƒ½ä¼˜åŒ–ç»“æœ

**ä¼˜åŒ–å‰**:
- å“åº”æ—¶é—´: P99 500ms
- TPS: 100
- é”™è¯¯ç‡: 2%
- èµ„æºä½¿ç”¨: 4GBå†…å­˜ï¼Œ60% CPU

**ä¼˜åŒ–å**:
- å“åº”æ—¶é—´: P99 50ms (10xæ”¹å–„)
- TPS: 1000 (10xæå‡)
- é”™è¯¯ç‡: 0.1% (20xå‡å°‘)
- èµ„æºä½¿ç”¨: 2GBå†…å­˜ï¼Œ30% CPU

**ä¼˜åŒ–æªæ–½**:
1. âœ… å¼•å…¥Redisç¼“å­˜ï¼ˆäº§å“æœåŠ¡ï¼‰
2. âœ… ä½¿ç”¨è¿æ¥æ± ï¼ˆæ•°æ®åº“ï¼‰
3. âœ… å®ç°åˆ†å¸ƒå¼é”ï¼ˆåº“å­˜ç®¡ç†ï¼‰
4. âœ… å¼‚æ­¥äº‹ä»¶å¤„ç†ï¼ˆKafkaï¼‰
5. âœ… APIé™æµï¼ˆKongï¼‰
6. âœ… æœåŠ¡ç†”æ–­ï¼ˆè‡ªå®šä¹‰ï¼‰

---

### æ•…éšœå¤„ç†æ¡ˆä¾‹

**æ¡ˆä¾‹1: äº§å“æœåŠ¡æ•…éšœ**

```go
// è®¢å•æœåŠ¡ä¸­çš„ç†”æ–­å™¨
circuitBreaker := gobreaker.NewCircuitBreaker(gobreaker.Settings{
    Name:        "product-service",
    MaxRequests: 3,
    Timeout:     60 * time.Second,
    ReadyToTrip: func(counts gobreaker.Counts) bool {
        return counts.ConsecutiveFailures > 5
    },
})

func (s *OrderService) getProduct(ctx context.Context, productID string) (*productpb.Product, error) {
    result, err := circuitBreaker.Execute(func() (interface{}, error) {
        return s.productClient.GetProduct(ctx, &productpb.GetProductRequest{
            Id: productID,
        })
    })
    
    if err != nil {
        // é™çº§ï¼šè¿”å›åŸºæœ¬ä¿¡æ¯
        return s.getProductFromCache(productID)
    }
    
    return result.(*productpb.Product), nil
}
```

**æ¡ˆä¾‹2: æ•°æ®åº“è¿æ¥æ± è€—å°½**

```go
// ç›‘æ§è¿æ¥æ± çŠ¶æ€
func (s *OrderService) monitorDB() {
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        stats := s.db.Stats()
        
        // è®°å½•æŒ‡æ ‡
        metrics.DBOpenConnections.Set(float64(stats.OpenConnections))
        metrics.DBInUseConnections.Set(float64(stats.InUse))
        
        // å‘Šè­¦
        if stats.InUse > stats.MaxOpenConnections*8/10 {
            log.Warn("Database connection pool nearly exhausted")
        }
    }
}
```

---

## ğŸ”— ç›¸å…³èµ„æº

- [åˆ†å¸ƒå¼ç³»ç»Ÿ](../../advanced/distributed/README.md)
- [æœåŠ¡ç½‘æ ¼](./04-æœåŠ¡ç½‘æ ¼.md)
- [APIç½‘å…³](./05-APIç½‘å…³.md)
- [gRPCå®æˆ˜](./00-gRPCæ·±åº¦å®æˆ˜æŒ‡å—.md)

---

**æœ€åæ›´æ–°**: 2025-10-28  
**Goç‰ˆæœ¬**: 1.25.3  
**æ–°å¢**: å®Œæ•´ç”µå•†å¾®æœåŠ¡å®æˆ˜æ¡ˆä¾‹ âœ¨

