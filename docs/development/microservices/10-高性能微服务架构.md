# 10. ğŸš€ é«˜æ€§èƒ½å¾®æœåŠ¡æ¶æ„

> ğŸ“š **ç®€ä»‹**ï¼šæœ¬æ–‡æ¡£æ·±å…¥æ¢è®¨é«˜æ€§èƒ½å¾®æœåŠ¡æ¶æ„çš„è®¾è®¡ä¸å®ç°ï¼Œæ¶µç›–æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ã€æ¶æ„æ¨¡å¼ã€é€šä¿¡æœºåˆ¶ã€ç¼“å­˜ç­–ç•¥ã€æ•°æ®åº“ä¼˜åŒ–å’Œç›‘æ§å®è·µã€‚é€šè¿‡æœ¬æ–‡ï¼Œè¯»è€…å°†æŒæ¡æ„å»ºå’Œä¼˜åŒ–å¤§è§„æ¨¡ã€é«˜å¹¶å‘å¾®æœåŠ¡ç³»ç»Ÿçš„æ ¸å¿ƒæŠ€æœ¯ä¸æœ€ä½³å®è·µã€‚

## ğŸ“‹ ç›®å½•

- [10. ğŸš€ é«˜æ€§èƒ½å¾®æœåŠ¡æ¶æ„](#10--é«˜æ€§èƒ½å¾®æœåŠ¡æ¶æ„)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [10.1 ğŸ“š æ¶æ„è®¾è®¡åŸåˆ™](#101--æ¶æ„è®¾è®¡åŸåˆ™)
    - [å•ä¸€èŒè´£](#å•ä¸€èŒè´£)
    - [æœåŠ¡è‡ªæ²»](#æœåŠ¡è‡ªæ²»)
    - [å»ä¸­å¿ƒåŒ–](#å»ä¸­å¿ƒåŒ–)
    - [å®¹é”™è®¾è®¡](#å®¹é”™è®¾è®¡)
  - [10.2 ğŸ¯ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#102--æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
    - [æœåŠ¡é€šä¿¡ä¼˜åŒ–](#æœåŠ¡é€šä¿¡ä¼˜åŒ–)
    - [å¹¶å‘å¤„ç†](#å¹¶å‘å¤„ç†)
    - [è¿æ¥æ± ç®¡ç†](#è¿æ¥æ± ç®¡ç†)
    - [æ‰¹é‡å¤„ç†](#æ‰¹é‡å¤„ç†)
  - [10.3 ğŸ’» é€šä¿¡æœºåˆ¶é€‰æ‹©](#103--é€šä¿¡æœºåˆ¶é€‰æ‹©)
    - [åŒæ­¥é€šä¿¡](#åŒæ­¥é€šä¿¡)
    - [å¼‚æ­¥é€šä¿¡](#å¼‚æ­¥é€šä¿¡)
    - [æ··åˆæ¨¡å¼](#æ··åˆæ¨¡å¼)
  - [10.4 ğŸ“Š ç¼“å­˜æ¶æ„](#104--ç¼“å­˜æ¶æ„)
    - [å¤šçº§ç¼“å­˜](#å¤šçº§ç¼“å­˜)
    - [ç¼“å­˜ç­–ç•¥](#ç¼“å­˜ç­–ç•¥)
    - [ç¼“å­˜ä¸€è‡´æ€§](#ç¼“å­˜ä¸€è‡´æ€§)
  - [10.5 ğŸ” æ•°æ®åº“ä¼˜åŒ–](#105--æ•°æ®åº“ä¼˜åŒ–)
    - [è¯»å†™åˆ†ç¦»](#è¯»å†™åˆ†ç¦»)
    - [åˆ†åº“åˆ†è¡¨](#åˆ†åº“åˆ†è¡¨)
    - [è¿æ¥ä¼˜åŒ–](#è¿æ¥ä¼˜åŒ–)
  - [10.6 âš¡ è´Ÿè½½å‡è¡¡](#106--è´Ÿè½½å‡è¡¡)
    - [å®¢æˆ·ç«¯è´Ÿè½½å‡è¡¡](#å®¢æˆ·ç«¯è´Ÿè½½å‡è¡¡)
    - [æœåŠ¡ç«¯è´Ÿè½½å‡è¡¡](#æœåŠ¡ç«¯è´Ÿè½½å‡è¡¡)
  - [10.7 ğŸ›¡ï¸ é™æµä¸ç†”æ–­](#107-ï¸-é™æµä¸ç†”æ–­)
    - [é™æµç­–ç•¥](#é™æµç­–ç•¥)
    - [ç†”æ–­æœºåˆ¶](#ç†”æ–­æœºåˆ¶)
    - [é™çº§æ–¹æ¡ˆ](#é™çº§æ–¹æ¡ˆ)
  - [10.8 ğŸ“ˆ æ€§èƒ½ç›‘æ§](#108--æ€§èƒ½ç›‘æ§)
    - [æŒ‡æ ‡é‡‡é›†](#æŒ‡æ ‡é‡‡é›†)
    - [é“¾è·¯è¿½è¸ª](#é“¾è·¯è¿½è¸ª)
    - [æ€§èƒ½åˆ†æ](#æ€§èƒ½åˆ†æ)
  - [10.9 ğŸ¯ æœ€ä½³å®è·µ](#109--æœ€ä½³å®è·µ)
  - [10.10 âš ï¸ å¸¸è§é—®é¢˜](#1010-ï¸-å¸¸è§é—®é¢˜)
    - [Q1: å¦‚ä½•é€‰æ‹©åŒæ­¥è¿˜æ˜¯å¼‚æ­¥é€šä¿¡ï¼Ÿ](#q1-å¦‚ä½•é€‰æ‹©åŒæ­¥è¿˜æ˜¯å¼‚æ­¥é€šä¿¡)
    - [Q2: ç¼“å­˜å‡»ç©¿å¦‚ä½•é˜²æŠ¤ï¼Ÿ](#q2-ç¼“å­˜å‡»ç©¿å¦‚ä½•é˜²æŠ¤)
    - [Q3: å¦‚ä½•å¤„ç†åˆ†å¸ƒå¼äº‹åŠ¡ï¼Ÿ](#q3-å¦‚ä½•å¤„ç†åˆ†å¸ƒå¼äº‹åŠ¡)
    - [Q4: æœåŠ¡æ‹†åˆ†ç²’åº¦å¦‚ä½•æŠŠæ¡ï¼Ÿ](#q4-æœåŠ¡æ‹†åˆ†ç²’åº¦å¦‚ä½•æŠŠæ¡)
  - [10.11 ğŸ“š æ‰©å±•é˜…è¯»](#1011--æ‰©å±•é˜…è¯»)
    - [å®˜æ–¹æ–‡æ¡£](#å®˜æ–¹æ–‡æ¡£)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)
    - [æ¨èä¹¦ç±](#æ¨èä¹¦ç±)

## 10.1 ğŸ“š æ¶æ„è®¾è®¡åŸåˆ™

### å•ä¸€èŒè´£

æ¯ä¸ªå¾®æœåŠ¡åº”è¯¥åªè´Ÿè´£ä¸€ä¸ªä¸šåŠ¡é¢†åŸŸï¼Œé¿å…åŠŸèƒ½è¿‡åº¦é›†ä¸­ã€‚

**å¥½çš„è®¾è®¡**:

```go
// ç”¨æˆ·æœåŠ¡ - åªå¤„ç†ç”¨æˆ·ç›¸å…³æ“ä½œ
type UserService struct {
    repo UserRepository
}

func (s *UserService) GetUser(ctx context.Context, id string) (*User, error) {
    return s.repo.FindByID(ctx, id)
}

// è®¢å•æœåŠ¡ - åªå¤„ç†è®¢å•ç›¸å…³æ“ä½œ
type OrderService struct {
    repo OrderRepository
    userClient UserClient // é€šè¿‡RPCè°ƒç”¨ç”¨æˆ·æœåŠ¡
}
```

### æœåŠ¡è‡ªæ²»

æœåŠ¡åº”è¯¥ç‹¬ç«‹éƒ¨ç½²ã€ç‹¬ç«‹æ‰©å±•ã€æ‹¥æœ‰ç‹¬ç«‹çš„æ•°æ®å­˜å‚¨ã€‚

**æ¶æ„ç¤ºä¾‹**:

```go
// æ¯ä¸ªæœåŠ¡æœ‰è‡ªå·±çš„æ•°æ®åº“è¿æ¥
type ServiceConfig struct {
    ServiceName string
    DBConfig    DatabaseConfig
    CacheConfig RedisConfig
}

func NewService(cfg ServiceConfig) *Service {
    return &Service{
        name:  cfg.ServiceName,
        db:    connectDB(cfg.DBConfig),
        cache: connectCache(cfg.CacheConfig),
    }
}
```

### å»ä¸­å¿ƒåŒ–

é¿å…å•ç‚¹æ•…éšœï¼Œé‡‡ç”¨åˆ†å¸ƒå¼æ¶æ„ã€‚

**æœåŠ¡å‘ç°**:

```go
import (
    "github.com/hashicorp/consul/api"
)

// ä½¿ç”¨Consulè¿›è¡ŒæœåŠ¡æ³¨å†Œå’Œå‘ç°
func RegisterService(name, address string, port int) error {
    client, _ := api.NewClient(api.DefaultConfig())

    registration := &api.AgentServiceRegistration{
        ID:      fmt.Sprintf("%s-%s", name, uuid.New().String()),
        Name:    name,
        Address: address,
        Port:    port,
        Check: &api.AgentServiceCheck{
            HTTP:                           fmt.Sprintf("http://%s:%d/health", address, port),
            Interval:                       "10s",
            Timeout:                        "3s",
            DeregisterCriticalServiceAfter: "30s",
        },
    }

    return client.Agent().ServiceRegister(registration)
}
```

### å®¹é”™è®¾è®¡

ç³»ç»Ÿåº”è¯¥èƒ½å¤Ÿä¼˜é›…åœ°å¤„ç†æ•…éšœï¼Œä¸å› å•ä¸ªæœåŠ¡å¤±è´¥è€Œå´©æºƒã€‚

**ç†”æ–­å™¨å®ç°**:

```go
import "github.com/sony/gobreaker"

type ServiceClient struct {
    cb *gobreaker.CircuitBreaker
}

func NewServiceClient() *ServiceClient {
    settings := gobreaker.Settings{
        Name:        "ServiceA",
        MaxRequests: 3,
        Interval:    time.Second * 10,
        Timeout:     time.Second * 60,
        ReadyToTrip: func(counts gobreaker.Counts) bool {
            failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)
            return counts.Requests >= 3 && failureRatio >= 0.6
        },
    }

    return &ServiceClient{
        cb: gobreaker.NewCircuitBreaker(settings),
    }
}

func (c *ServiceClient) Call(ctx context.Context, req *Request) (*Response, error) {
    result, err := c.cb.Execute(func() (interface{}, error) {
        return c.doCall(ctx, req)
    })

    if err != nil {
        return nil, err
    }

    return result.(*Response), nil
}
```

## 10.2 ğŸ¯ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### æœåŠ¡é€šä¿¡ä¼˜åŒ–

**ä½¿ç”¨é«˜æ•ˆçš„åºåˆ—åŒ–åè®®**:

```go
// ä½¿ç”¨Protocol Buffersä»£æ›¿JSON
import "google.golang.org/protobuf/proto"

// user.proto
// syntax = "proto3";
// message User {
//     string id = 1;
//     string name = 2;
//     string email = 3;
// }

func SerializeUser(user *User) ([]byte, error) {
    return proto.Marshal(user)
}

func DeserializeUser(data []byte) (*User, error) {
    user := &User{}
    err := proto.Unmarshal(data, user)
    return user, err
}
```

**æ€§èƒ½å¯¹æ¯”**:

| åºåˆ—åŒ–æ–¹å¼ | ç¼–ç é€Ÿåº¦ | è§£ç é€Ÿåº¦ | æ•°æ®å¤§å° |
|------------|----------|----------|----------|
| JSON       | æ…¢       | æ…¢       | å¤§       |
| Protobuf   | å¿«       | å¿«       | å°       |
| MessagePack| ä¸­       | ä¸­       | ä¸­       |

### å¹¶å‘å¤„ç†

**å·¥ä½œæ± æ¨¡å¼**:

```go
type WorkerPool struct {
    workers   int
    taskQueue chan Task
    wg        sync.WaitGroup
}

func NewWorkerPool(workers int, queueSize int) *WorkerPool {
    return &WorkerPool{
        workers:   workers,
        taskQueue: make(chan Task, queueSize),
    }
}

func (p *WorkerPool) Start(ctx context.Context) {
    for i := 0; i < p.workers; i++ {
        p.wg.Add(1)
        go p.worker(ctx)
    }
}

func (p *WorkerPool) worker(ctx context.Context) {
    defer p.wg.Done()

    for {
        select {
        case task := <-p.taskQueue:
            task.Execute()
        case <-ctx.Done():
            return
        }
    }
}

func (p *WorkerPool) Submit(task Task) {
    p.taskQueue <- task
}

func (p *WorkerPool) Stop() {
    close(p.taskQueue)
    p.wg.Wait()
}
```

### è¿æ¥æ± ç®¡ç†

**HTTPè¿æ¥æ± **:

```go
import "net/http"

var httpClient = &http.Client{
    Transport: &http.Transport{
        MaxIdleConns:        100,
        MaxIdleConnsPerHost: 10,
        IdleConnTimeout:     90 * time.Second,
        DisableKeepAlives:   false,
    },
    Timeout: 30 * time.Second,
}

func CallRemoteService(url string) (*Response, error) {
    resp, err := httpClient.Get(url)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    // å¤„ç†å“åº”...
    return parseResponse(resp)
}
```

**æ•°æ®åº“è¿æ¥æ± **:

```go
import "database/sql"

func setupDBPool(db *sql.DB) {
    // æœ€å¤§æ‰“å¼€è¿æ¥æ•°
    db.SetMaxOpenConns(25)

    // æœ€å¤§ç©ºé—²è¿æ¥æ•°
    db.SetMaxIdleConns(5)

    // è¿æ¥æœ€å¤§ç”Ÿå­˜æ—¶é—´
    db.SetConnMaxLifetime(5 * time.Minute)

    // è¿æ¥æœ€å¤§ç©ºé—²æ—¶é—´
    db.SetConnMaxIdleTime(10 * time.Minute)
}
```

### æ‰¹é‡å¤„ç†

**æ‰¹é‡æ•°æ®åº“æ“ä½œ**:

```go
func BatchInsertUsers(users []*User) error {
    const batchSize = 100

    for i := 0; i < len(users); i += batchSize {
        end := i + batchSize
        if end > len(users) {
            end = len(users)
        }

        batch := users[i:end]
        if err := insertBatch(batch); err != nil {
            return err
        }
    }

    return nil
}

func insertBatch(users []*User) error {
    tx, err := db.Begin()
    if err != nil {
        return err
    }
    defer tx.Rollback()

    stmt, err := tx.Prepare("INSERT INTO users (id, name, email) VALUES (?, ?, ?)")
    if err != nil {
        return err
    }
    defer stmt.Close()

    for _, user := range users {
        if _, err := stmt.Exec(user.ID, user.Name, user.Email); err != nil {
            return err
        }
    }

    return tx.Commit()
}
```

## 10.3 ğŸ’» é€šä¿¡æœºåˆ¶é€‰æ‹©

### åŒæ­¥é€šä¿¡

**gRPCå®ç°**:

```go
import (
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
)

// æœåŠ¡ç«¯
type UserServiceServer struct {
    pb.UnimplementedUserServiceServer
}

func (s *UserServiceServer) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.User, error) {
    // å®ç°é€»è¾‘
    return &pb.User{
        Id:    req.Id,
        Name:  "John Doe",
        Email: "john@example.com",
    }, nil
}

// å¯åŠ¨gRPCæœåŠ¡å™¨
func StartGRPCServer(port int) error {
    lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
    if err != nil {
        return err
    }

    grpcServer := grpc.NewServer()
    pb.RegisterUserServiceServer(grpcServer, &UserServiceServer{})

    return grpcServer.Serve(lis)
}

// å®¢æˆ·ç«¯
func CallUserService(addr string, userID string) (*pb.User, error) {
    conn, err := grpc.Dial(addr, grpc.WithTransportCredentials(insecure.NewCredentials()))
    if err != nil {
        return nil, err
    }
    defer conn.Close()

    client := pb.NewUserServiceClient(conn)
    return client.GetUser(context.Background(), &pb.GetUserRequest{Id: userID})
}
```

### å¼‚æ­¥é€šä¿¡

**ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—ï¼ˆRabbitMQï¼‰**:

```go
import "github.com/streadway/amqp"

type MessageQueue struct {
    conn    *amqp.Connection
    channel *amqp.Channel
}

func NewMessageQueue(url string) (*MessageQueue, error) {
    conn, err := amqp.Dial(url)
    if err != nil {
        return nil, err
    }

    ch, err := conn.Channel()
    if err != nil {
        return nil, err
    }

    return &MessageQueue{conn: conn, channel: ch}, nil
}

// å‘å¸ƒæ¶ˆæ¯
func (mq *MessageQueue) Publish(exchange, routingKey string, body []byte) error {
    return mq.channel.Publish(
        exchange,   // exchange
        routingKey, // routing key
        false,      // mandatory
        false,      // immediate
        amqp.Publishing{
            ContentType: "application/json",
            Body:        body,
        },
    )
}

// æ¶ˆè´¹æ¶ˆæ¯
func (mq *MessageQueue) Consume(queue string, handler func([]byte) error) error {
    msgs, err := mq.channel.Consume(
        queue, // queue
        "",    // consumer
        false, // auto-ack
        false, // exclusive
        false, // no-local
        false, // no-wait
        nil,   // args
    )
    if err != nil {
        return err
    }

    for msg := range msgs {
        if err := handler(msg.Body); err != nil {
            msg.Nack(false, true) // é‡æ–°å…¥é˜Ÿ
        } else {
            msg.Ack(false)
        }
    }

    return nil
}
```

### æ··åˆæ¨¡å¼

**äº‹ä»¶é©±åŠ¨æ¶æ„**:

```go
// è®¢å•æœåŠ¡å‘å¸ƒäº‹ä»¶
type OrderCreatedEvent struct {
    OrderID   string
    UserID    string
    Amount    float64
    Timestamp time.Time
}

func (s *OrderService) CreateOrder(ctx context.Context, req *CreateOrderRequest) error {
    // 1. åŒæ­¥åˆ›å»ºè®¢å•
    order, err := s.repo.Create(ctx, req)
    if err != nil {
        return err
    }

    // 2. å¼‚æ­¥å‘å¸ƒäº‹ä»¶
    event := OrderCreatedEvent{
        OrderID:   order.ID,
        UserID:    order.UserID,
        Amount:    order.Amount,
        Timestamp: time.Now(),
    }

    go s.publishEvent("order.created", event)

    return nil
}

// å…¶ä»–æœåŠ¡è®¢é˜…äº‹ä»¶
func (s *InventoryService) HandleOrderCreated(event OrderCreatedEvent) error {
    // å¤„ç†åº“å­˜æ‰£å‡
    return s.DeductStock(event.OrderID, event.Products)
}
```

## 10.4 ğŸ“Š ç¼“å­˜æ¶æ„

### å¤šçº§ç¼“å­˜

```go
type CacheManager struct {
    local  *LocalCache  // L1: æœ¬åœ°ç¼“å­˜
    redis  *RedisCache  // L2: Redisç¼“å­˜
}

func (cm *CacheManager) Get(ctx context.Context, key string) (interface{}, error) {
    // 1. æŸ¥è¯¢æœ¬åœ°ç¼“å­˜
    if val, ok := cm.local.Get(key); ok {
        return val, nil
    }

    // 2. æŸ¥è¯¢Redis
    val, err := cm.redis.Get(ctx, key)
    if err == nil {
        // å›å†™åˆ°æœ¬åœ°ç¼“å­˜
        cm.local.Set(key, val, 5*time.Minute)
        return val, nil
    }

    // 3. æŸ¥è¯¢æ•°æ®åº“
    val, err = cm.loadFromDB(ctx, key)
    if err != nil {
        return nil, err
    }

    // 4. å†™å…¥ç¼“å­˜
    cm.redis.Set(ctx, key, val, 1*time.Hour)
    cm.local.Set(key, val, 5*time.Minute)

    return val, nil
}
```

### ç¼“å­˜ç­–ç•¥

**ç¼“å­˜ç©¿é€é˜²æŠ¤**:

```go
import "github.com/bluele/gcache"

// ä½¿ç”¨å¸ƒéš†è¿‡æ»¤å™¨
type BloomFilter struct {
    filter *bloom.BloomFilter
}

func (bf *BloomFilter) MayExist(key string) bool {
    return bf.filter.Test([]byte(key))
}

func (cm *CacheManager) GetWithBloomFilter(ctx context.Context, key string) (interface{}, error) {
    // å…ˆæ£€æŸ¥å¸ƒéš†è¿‡æ»¤å™¨
    if !cm.bloomFilter.MayExist(key) {
        return nil, ErrNotFound
    }

    return cm.Get(ctx, key)
}
```

**ç¼“å­˜é›ªå´©é˜²æŠ¤**:

```go
// éšæœºè¿‡æœŸæ—¶é—´
func (cm *CacheManager) SetWithRandomExpiry(ctx context.Context, key string, val interface{}) error {
    // åŸºç¡€è¿‡æœŸæ—¶é—´ + éšæœºæ—¶é—´
    baseExpiry := 1 * time.Hour
    randomExpiry := time.Duration(rand.Intn(300)) * time.Second

    return cm.redis.Set(ctx, key, val, baseExpiry+randomExpiry)
}
```

### ç¼“å­˜ä¸€è‡´æ€§

**å‘å¸ƒè®¢é˜…æ¨¡å¼**:

```go
// ä½¿ç”¨Redis Pub/SubåŒæ­¥ç¼“å­˜
func (cm *CacheManager) InvalidateCache(key string) error {
    // 1. åˆ é™¤æœ¬åœ°ç¼“å­˜
    cm.local.Delete(key)

    // 2. å‘å¸ƒå¤±æ•ˆæ¶ˆæ¯
    return cm.redis.Publish("cache:invalidate", key)
}

// è®¢é˜…å¤±æ•ˆæ¶ˆæ¯
func (cm *CacheManager) SubscribeInvalidations() {
    pubsub := cm.redis.Subscribe("cache:invalidate")
    defer pubsub.Close()

    for msg := range pubsub.Channel() {
        key := msg.Payload
        cm.local.Delete(key)
    }
}
```

## 10.5 ğŸ” æ•°æ®åº“ä¼˜åŒ–

### è¯»å†™åˆ†ç¦»

```go
type DBCluster struct {
    master *sql.DB
    slaves []*sql.DB
    idx    int32
}

func (dbc *DBCluster) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
    // è¯»æ“ä½œä½¿ç”¨ä»åº“ï¼ˆè½®è¯¢ï¼‰
    idx := atomic.AddInt32(&dbc.idx, 1)
    slave := dbc.slaves[int(idx)%len(dbc.slaves)]
    return slave.QueryContext(ctx, query, args...)
}

func (dbc *DBCluster) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
    // å†™æ“ä½œä½¿ç”¨ä¸»åº“
    return dbc.master.ExecContext(ctx, query, args...)
}
```

### åˆ†åº“åˆ†è¡¨

```go
// æŒ‰ç”¨æˆ·IDåˆ†è¡¨
func getUserTableName(userID string) string {
    hash := crc32.ChecksumIEEE([]byte(userID))
    tableNum := hash % 10 // 10ä¸ªè¡¨
    return fmt.Sprintf("users_%d", tableNum)
}

func (repo *UserRepository) FindByID(ctx context.Context, userID string) (*User, error) {
    tableName := getUserTableName(userID)
    query := fmt.Sprintf("SELECT * FROM %s WHERE id = ?", tableName)

    var user User
    err := repo.db.QueryRowContext(ctx, query, userID).Scan(&user.ID, &user.Name, &user.Email)
    return &user, err
}
```

### è¿æ¥ä¼˜åŒ–

**é¢„å¤„ç†è¯­å¥**:

```go
type UserRepository struct {
    db           *sql.DB
    insertStmt   *sql.Stmt
    selectStmt   *sql.Stmt
}

func NewUserRepository(db *sql.DB) (*UserRepository, error) {
    insertStmt, err := db.Prepare("INSERT INTO users (id, name, email) VALUES (?, ?, ?)")
    if err != nil {
        return nil, err
    }

    selectStmt, err := db.Prepare("SELECT id, name, email FROM users WHERE id = ?")
    if err != nil {
        return nil, err
    }

    return &UserRepository{
        db:         db,
        insertStmt: insertStmt,
        selectStmt: selectStmt,
    }, nil
}

func (r *UserRepository) Insert(ctx context.Context, user *User) error {
    _, err := r.insertStmt.ExecContext(ctx, user.ID, user.Name, user.Email)
    return err
}
```

## 10.6 âš¡ è´Ÿè½½å‡è¡¡

### å®¢æˆ·ç«¯è´Ÿè½½å‡è¡¡

```go
type LoadBalancer struct {
    servers []string
    idx     int32
}

// è½®è¯¢ç®—æ³•
func (lb *LoadBalancer) RoundRobin() string {
    idx := atomic.AddInt32(&lb.idx, 1)
    return lb.servers[int(idx)%len(lb.servers)]
}

// åŠ æƒè½®è¯¢
type WeightedServer struct {
    Addr   string
    Weight int
}

func (lb *LoadBalancer) WeightedRoundRobin(servers []WeightedServer) string {
    totalWeight := 0
    for _, s := range servers {
        totalWeight += s.Weight
    }

    random := rand.Intn(totalWeight)
    for _, s := range servers {
        random -= s.Weight
        if random < 0 {
            return s.Addr
        }
    }

    return servers[0].Addr
}

// æœ€å°‘è¿æ¥
type ConnectionTracker struct {
    connections map[string]int32
    mu          sync.RWMutex
}

func (ct *ConnectionTracker) LeastConnections(servers []string) string {
    ct.mu.RLock()
    defer ct.mu.RUnlock()

    minConns := int32(math.MaxInt32)
    var selected string

    for _, server := range servers {
        conns := ct.connections[server]
        if conns < minConns {
            minConns = conns
            selected = server
        }
    }

    return selected
}
```

### æœåŠ¡ç«¯è´Ÿè½½å‡è¡¡

ä½¿ç”¨Nginxæˆ–Envoyä½œä¸ºå…¥å£ç½‘å…³è¿›è¡Œè´Ÿè½½å‡è¡¡ã€‚

## 10.7 ğŸ›¡ï¸ é™æµä¸ç†”æ–­

### é™æµç­–ç•¥

**ä»¤ç‰Œæ¡¶ç®—æ³•**:

```go
import "golang.org/x/time/rate"

type RateLimiter struct {
    limiter *rate.Limiter
}

func NewRateLimiter(r rate.Limit, b int) *RateLimiter {
    return &RateLimiter{
        limiter: rate.NewLimiter(r, b),
    }
}

func (rl *RateLimiter) Allow() bool {
    return rl.limiter.Allow()
}

// ä¸­é—´ä»¶
func RateLimitMiddleware(limiter *RateLimiter) gin.HandlerFunc {
    return func(c *gin.Context) {
        if !limiter.Allow() {
            c.JSON(http.StatusTooManyRequests, gin.H{"error": "rate limit exceeded"})
            c.Abort()
            return
        }
        c.Next()
    }
}
```

### ç†”æ–­æœºåˆ¶

å‰é¢å·²ä»‹ç»ï¼Œä½¿ç”¨`gobreaker`åº“å®ç°ã€‚

### é™çº§æ–¹æ¡ˆ

```go
func (s *Service) GetUserWithFallback(ctx context.Context, id string) (*User, error) {
    user, err := s.userClient.GetUser(ctx, id)
    if err != nil {
        // é™çº§ï¼šè¿”å›ç¼“å­˜æ•°æ®
        if cachedUser, ok := s.cache.Get(id); ok {
            return cachedUser.(*User), nil
        }

        // é™çº§ï¼šè¿”å›é»˜è®¤ç”¨æˆ·
        return &User{
            ID:   id,
            Name: "Guest",
        }, nil
    }

    return user, nil
}
```

## 10.8 ğŸ“ˆ æ€§èƒ½ç›‘æ§

### æŒ‡æ ‡é‡‡é›†

**Prometheusé›†æˆ**:

```go
import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
    requestDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_request_duration_seconds",
            Help:    "HTTP request latencies",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method", "endpoint", "status"},
    )

    requestTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total HTTP requests",
        },
        []string{"method", "endpoint", "status"},
    )
)

func init() {
    prometheus.MustRegister(requestDuration)
    prometheus.MustRegister(requestTotal)
}

func MetricsMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        c.Next()
        duration := time.Since(start).Seconds()

        status := strconv.Itoa(c.Writer.Status())
        requestDuration.WithLabelValues(c.Request.Method, c.FullPath(), status).Observe(duration)
        requestTotal.WithLabelValues(c.Request.Method, c.FullPath(), status).Inc()
    }
}
```

### é“¾è·¯è¿½è¸ª

**OpenTelemetryé›†æˆ**:

```go
import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

func TraceableOperation(ctx context.Context, operationName string) error {
    tracer := otel.Tracer("my-service")
    ctx, span := tracer.Start(ctx, operationName)
    defer span.End()

    // ä¸šåŠ¡é€»è¾‘
    if err := doSomething(ctx); err != nil {
        span.RecordError(err)
        return err
    }

    return nil
}
```

### æ€§èƒ½åˆ†æ

**pprofé›†æˆ**:

```go
import _ "net/http/pprof"

func main() {
    // å¯åŠ¨pprofæœåŠ¡
    go func() {
        http.ListenAndServe("localhost:6060", nil)
    }()

    // å¯åŠ¨ä¸»æœåŠ¡
    startMainService()
}

// è®¿é—® http://localhost:6060/debug/pprof/ æŸ¥çœ‹æ€§èƒ½æ•°æ®
```

## 10.9 ğŸ¯ æœ€ä½³å®è·µ

1. **ä½¿ç”¨è¿æ¥æ± **: å¤ç”¨HTTP/DBè¿æ¥ï¼Œé¿å…é¢‘ç¹å»ºç«‹è¿æ¥
2. **å®æ–½ç¼“å­˜ç­–ç•¥**: å¤šçº§ç¼“å­˜ï¼Œå‡å°‘æ•°æ®åº“å‹åŠ›
3. **å¼‚æ­¥å¤„ç†**: éå…³é”®è·¯å¾„ä½¿ç”¨å¼‚æ­¥æ¶ˆæ¯é˜Ÿåˆ—
4. **æ‰¹é‡æ“ä½œ**: åˆå¹¶å°è¯·æ±‚ï¼Œå‡å°‘ç½‘ç»œå¼€é”€
5. **é™æµä¿æŠ¤**: é˜²æ­¢ç³»ç»Ÿè¿‡è½½
6. **ç†”æ–­é™çº§**: å¿«é€Ÿå¤±è´¥ï¼Œä¿æŠ¤ç³»ç»Ÿç¨³å®šæ€§
7. **ç›‘æ§å‘Šè­¦**: å®æ—¶ç›‘æ§å…³é”®æŒ‡æ ‡ï¼ŒåŠæ—¶å‘ç°é—®é¢˜
8. **å®¹é‡è§„åˆ’**: æ ¹æ®è´Ÿè½½é¢„æµ‹ï¼Œæå‰æ‰©å®¹
9. **æ•°æ®åº“ä¼˜åŒ–**: è¯»å†™åˆ†ç¦»ã€åˆ†åº“åˆ†è¡¨ã€ç´¢å¼•ä¼˜åŒ–
10. **ä»£ç ä¼˜åŒ–**: é¿å…N+1æŸ¥è¯¢ã€å‡å°‘é”ç«äº‰

## 10.10 âš ï¸ å¸¸è§é—®é¢˜

### Q1: å¦‚ä½•é€‰æ‹©åŒæ­¥è¿˜æ˜¯å¼‚æ­¥é€šä¿¡ï¼Ÿ

**A**:

- **åŒæ­¥**: éœ€è¦ç«‹å³å“åº”ã€å¼ºä¸€è‡´æ€§è¦æ±‚ï¼ˆå¦‚æ”¯ä»˜ï¼‰
- **å¼‚æ­¥**: å¯å»¶è¿Ÿå¤„ç†ã€æœ€ç»ˆä¸€è‡´æ€§ï¼ˆå¦‚é€šçŸ¥ï¼‰

### Q2: ç¼“å­˜å‡»ç©¿å¦‚ä½•é˜²æŠ¤ï¼Ÿ

**A**:

- ä½¿ç”¨äº’æ–¥é”ï¼ˆsingleflightï¼‰
- è®¾ç½®æ°¸ä¸è¿‡æœŸï¼Œåå°å®šæ—¶æ›´æ–°
- å¸ƒéš†è¿‡æ»¤å™¨é¢„æ£€

### Q3: å¦‚ä½•å¤„ç†åˆ†å¸ƒå¼äº‹åŠ¡ï¼Ÿ

**A**:

- SAGAæ¨¡å¼
- TCCï¼ˆTry-Confirm-Cancelï¼‰
- æœ¬åœ°æ¶ˆæ¯è¡¨
- äº‹ä»¶æº¯æº

### Q4: æœåŠ¡æ‹†åˆ†ç²’åº¦å¦‚ä½•æŠŠæ¡ï¼Ÿ

**A**:

- ä¸šåŠ¡é¢†åŸŸé©±åŠ¨
- å›¢é˜Ÿè§„æ¨¡åŒ¹é…
- é¿å…è¿‡åº¦æ‹†åˆ†
- å¯ç‹¬ç«‹éƒ¨ç½²å’Œæ‰©å±•

## 10.11 ğŸ“š æ‰©å±•é˜…è¯»

### å®˜æ–¹æ–‡æ¡£

- [Goæ ‡å‡†åº“](https://pkg.go.dev/std)
- [gRPC Go](https://grpc.io/docs/languages/go/)
- [Prometheus](https://prometheus.io/docs/introduction/overview/)

### ç›¸å…³æ–‡æ¡£

- [../07-æ€§èƒ½ä¼˜åŒ–/01-æ€§èƒ½åˆ†æä¸pprof.md](../07-æ€§èƒ½ä¼˜åŒ–/01-æ€§èƒ½åˆ†æä¸pprof.md)
- [../08-æ¶æ„è®¾è®¡/README.md](../08-æ¶æ„è®¾è®¡/README.md)
- [11-Kuberneteså¾®æœåŠ¡éƒ¨ç½².md](./11-Kuberneteså¾®æœåŠ¡éƒ¨ç½².md)

### æ¨èä¹¦ç±

- ã€Šå¾®æœåŠ¡æ¶æ„è®¾è®¡æ¨¡å¼ã€‹
- ã€Šé«˜æ€§èƒ½MySQLã€‹
- ã€ŠGoè¯­è¨€é«˜çº§ç¼–ç¨‹ã€‹

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team
**æœ€åæ›´æ–°**: 2025-10-29
**æ–‡æ¡£çŠ¶æ€**: å®Œæˆ
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
