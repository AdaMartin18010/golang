# Goå¾®æœåŠ¡æ¶æ„æ·±åº¦å®æˆ˜æŒ‡å—

**å­—æ•°**: ~22,000å­—  
**ä»£ç ç¤ºä¾‹**: 50+ä¸ªå®Œæ•´ç¤ºä¾‹  
**å®æˆ˜æ¡ˆä¾‹**: 6ä¸ªç«¯åˆ°ç«¯æ¡ˆä¾‹  
**é€‚ç”¨äººç¾¤**: ä¸­é«˜çº§Goå¼€å‘è€…

---

## ğŸ“‹ ç›®å½•


- [ç¬¬ä¸€éƒ¨åˆ†ï¼šå¾®æœåŠ¡ç†è®ºåŸºç¡€](#ç¬¬ä¸€éƒ¨åˆ†å¾®æœåŠ¡ç†è®ºåŸºç¡€)
  - [ä»€ä¹ˆæ˜¯å¾®æœåŠ¡ï¼Ÿ](#ä»€ä¹ˆæ˜¯å¾®æœåŠ¡)
    - [å®šä¹‰](#å®šä¹‰)
    - [å•ä½“ vs å¾®æœåŠ¡å¯¹æ¯”](#å•ä½“-vs-å¾®æœåŠ¡å¯¹æ¯”)
  - [å¾®æœåŠ¡æ ¸å¿ƒç»„ä»¶](#å¾®æœåŠ¡æ ¸å¿ƒç»„ä»¶)
  - [Goå¾®æœåŠ¡ç”Ÿæ€](#goå¾®æœåŠ¡ç”Ÿæ€)
    - [ä¸»æµæ¡†æ¶](#ä¸»æµæ¡†æ¶)
    - [ä¸ºä»€ä¹ˆé€‰æ‹©Goï¼Ÿ](#ä¸ºä»€ä¹ˆé€‰æ‹©go)
- [ç¬¬äºŒéƒ¨åˆ†ï¼šæœåŠ¡æ³¨å†Œä¸å‘ç°](#ç¬¬äºŒéƒ¨åˆ†æœåŠ¡æ³¨å†Œä¸å‘ç°)
  - [ä¸ºä»€ä¹ˆéœ€è¦æœåŠ¡å‘ç°ï¼Ÿ](#ä¸ºä»€ä¹ˆéœ€è¦æœåŠ¡å‘ç°)
  - [å®æˆ˜æ¡ˆä¾‹1ï¼šåŸºäºConsulçš„æœåŠ¡æ³¨å†Œä¸å‘ç°](#å®æˆ˜æ¡ˆä¾‹1åŸºäºconsulçš„æœåŠ¡æ³¨å†Œä¸å‘ç°)
    - [åœºæ™¯](#åœºæ™¯)
    - [å®Œæ•´å®ç°](#å®Œæ•´å®ç°)
    - [ç”¨æˆ·æœåŠ¡ï¼ˆæä¾›è€…ï¼‰](#ç”¨æˆ·æœåŠ¡æä¾›è€…)
    - [è®¢å•æœåŠ¡ï¼ˆæ¶ˆè´¹è€…ï¼‰](#è®¢å•æœåŠ¡æ¶ˆè´¹è€…)
    - [è¾“å‡º](#è¾“å‡º)
- [ç¬¬ä¸‰éƒ¨åˆ†ï¼šAPIç½‘å…³å®æˆ˜](#ç¬¬ä¸‰éƒ¨åˆ†apiç½‘å…³å®æˆ˜)
  - [ä¸ºä»€ä¹ˆéœ€è¦APIç½‘å…³ï¼Ÿ](#ä¸ºä»€ä¹ˆéœ€è¦apiç½‘å…³)
  - [å®æˆ˜æ¡ˆä¾‹2ï¼šè‡ªå»ºAPIç½‘å…³](#å®æˆ˜æ¡ˆä¾‹2è‡ªå»ºapiç½‘å…³)
    - [åœºæ™¯3](#åœºæ™¯3)
    - [å®Œæ•´å®ç°3](#å®Œæ•´å®ç°3)
    - [ä½¿ç”¨ç¤ºä¾‹](#ä½¿ç”¨ç¤ºä¾‹)
- [ç¬¬å››éƒ¨åˆ†ï¼šæœåŠ¡é—´é€šä¿¡](#ç¬¬å››éƒ¨åˆ†æœåŠ¡é—´é€šä¿¡)
  - [gRPC vs HTTP](#grpc-vs-http)
  - [å®æˆ˜æ¡ˆä¾‹3ï¼šgRPCæœåŠ¡é—´é€šä¿¡](#å®æˆ˜æ¡ˆä¾‹3grpcæœåŠ¡é—´é€šä¿¡)
    - [åœºæ™¯4](#åœºæ™¯4)
    - [Protoå®šä¹‰](#protoå®šä¹‰)
    - [æœåŠ¡ç«¯å®ç°](#æœåŠ¡ç«¯å®ç°)
    - [å®¢æˆ·ç«¯å®ç°](#å®¢æˆ·ç«¯å®ç°)
- [ç¬¬äº”éƒ¨åˆ†ï¼šé…ç½®ç®¡ç†](#ç¬¬äº”éƒ¨åˆ†é…ç½®ç®¡ç†)
  - [å®æˆ˜æ¡ˆä¾‹4ï¼šåŸºäºetcdçš„é…ç½®ä¸­å¿ƒ](#å®æˆ˜æ¡ˆä¾‹4åŸºäºetcdçš„é…ç½®ä¸­å¿ƒ)
- [ç¬¬å…­éƒ¨åˆ†ï¼šç†”æ–­ä¸é™æµ](#ç¬¬å…­éƒ¨åˆ†ç†”æ–­ä¸é™æµ)
  - [å®æˆ˜æ¡ˆä¾‹5ï¼šç†”æ–­å™¨å®ç°](#å®æˆ˜æ¡ˆä¾‹5ç†”æ–­å™¨å®ç°)
- [ç¬¬ä¸ƒéƒ¨åˆ†ï¼šåˆ†å¸ƒå¼è¿½è¸ª](#ç¬¬ä¸ƒéƒ¨åˆ†åˆ†å¸ƒå¼è¿½è¸ª)
  - [å®æˆ˜æ¡ˆä¾‹6ï¼šOpenTelemetryè¿½è¸ª](#å®æˆ˜æ¡ˆä¾‹6opentelemetryè¿½è¸ª)
- [ç¬¬å…«éƒ¨åˆ†ï¼šå®Œæ•´ç”µå•†å¾®æœåŠ¡æ¶æ„](#ç¬¬å…«éƒ¨åˆ†å®Œæ•´ç”µå•†å¾®æœåŠ¡æ¶æ„)
  - [æ¶æ„è®¾è®¡](#æ¶æ„è®¾è®¡)
    - [å¾®æœåŠ¡äº¤äº’æ¶æ„å¯è§†åŒ–](#å¾®æœåŠ¡äº¤äº’æ¶æ„å¯è§†åŒ–)
    - [è®¢å•åˆ›å»ºè°ƒç”¨é“¾æ—¶åºå›¾](#è®¢å•åˆ›å»ºè°ƒç”¨é“¾æ—¶åºå›¾)
  - [æ ¸å¿ƒç‰¹æ€§](#æ ¸å¿ƒç‰¹æ€§)
- [ç¬¬ä¹éƒ¨åˆ†ï¼šæœ€ä½³å®è·µ](#ç¬¬ä¹éƒ¨åˆ†æœ€ä½³å®è·µ)
  - [å¾®æœåŠ¡è®¾è®¡åŸåˆ™](#å¾®æœåŠ¡è®¾è®¡åŸåˆ™)
  - [å¸¸è§é™·é˜±](#å¸¸è§é™·é˜±)
    - [é™·é˜±1ï¼šæœåŠ¡æ‹†åˆ†è¿‡ç»†](#é™·é˜±1æœåŠ¡æ‹†åˆ†è¿‡ç»†)
    - [é™·é˜±2ï¼šå…±äº«æ•°æ®åº“](#é™·é˜±2å…±äº«æ•°æ®åº“)
    - [é™·é˜±3ï¼šå¿½ç•¥åˆ†å¸ƒå¼è¿½è¸ª](#é™·é˜±3å¿½ç•¥åˆ†å¸ƒå¼è¿½è¸ª)
- [ğŸ¯ æ€»ç»“](#-æ€»ç»“)
  - [å¾®æœåŠ¡æ ¸å¿ƒè¦ç‚¹](#å¾®æœåŠ¡æ ¸å¿ƒè¦ç‚¹)
  - [æŠ€æœ¯é€‰å‹å»ºè®®](#æŠ€æœ¯é€‰å‹å»ºè®®)

## ç¬¬ä¸€éƒ¨åˆ†ï¼šå¾®æœåŠ¡ç†è®ºåŸºç¡€

### ä»€ä¹ˆæ˜¯å¾®æœåŠ¡ï¼Ÿ

#### å®šä¹‰

**å¾®æœåŠ¡**æ˜¯ä¸€ç§å°†åº”ç”¨ç¨‹åºæ‹†åˆ†ä¸ºä¸€ç»„å°å‹ã€è‡ªæ²»ã€å¯ç‹¬ç«‹éƒ¨ç½²çš„æœåŠ¡çš„æ¶æ„é£æ ¼ã€‚æ¯ä¸ªæœåŠ¡ï¼š

- å›´ç»•ç‰¹å®šä¸šåŠ¡èƒ½åŠ›æ„å»º
- ç‹¬ç«‹å¼€å‘ã€æµ‹è¯•ã€éƒ¨ç½²
- æ‹¥æœ‰è‡ªå·±çš„æ•°æ®å­˜å‚¨
- é€šè¿‡è½»é‡çº§æœºåˆ¶é€šä¿¡

#### å•ä½“ vs å¾®æœåŠ¡å¯¹æ¯”

```text
ã€å•ä½“åº”ç”¨ã€‘
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Monolithic App         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ User  â”‚ Order â”‚Paymentâ”‚ â”‚
â”‚  â”‚Module â”‚Module â”‚Module â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚     â†“      â†“      â†“         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Shared Database     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ä¼˜ç‚¹ï¼šå¼€å‘ç®€å•ã€éƒ¨ç½²å¿«
ç¼ºç‚¹ï¼šæ‰©å±•ç²—ã€å‘å¸ƒè€¦åˆã€æŠ€æœ¯æ ˆå›ºå®š


ã€å¾®æœåŠ¡æ¶æ„ã€‘
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  User    â”‚  â”‚  Order   â”‚  â”‚ Payment  â”‚
â”‚ Service  â”‚  â”‚ Service  â”‚  â”‚ Service  â”‚
â”‚    â†“     â”‚  â”‚    â†“     â”‚  â”‚    â†“     â”‚
â”‚ [User DB]â”‚  â”‚[Order DB]â”‚  â”‚[Pay DB]  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†˜          â†“          â†™
        API Gateway / Service Mesh

ä¼˜ç‚¹ï¼šç‹¬ç«‹éƒ¨ç½²ã€æŠ€æœ¯çµæ´»ã€ç»†ç²’åº¦æ‰©å±•
ç¼ºç‚¹ï¼šè¿ç»´å¤æ‚ã€ç½‘ç»œå¼€é”€ã€æ•°æ®ä¸€è‡´æ€§
```

---

### å¾®æœåŠ¡æ ¸å¿ƒç»„ä»¶

| ç»„ä»¶ | ä½œç”¨ | å¸¸ç”¨æŠ€æœ¯ |
|------|------|---------|
| **æœåŠ¡æ³¨å†Œä¸å‘ç°** | æœåŠ¡ä½ç½®ç®¡ç† | Consul, etcd, Nacos |
| **APIç½‘å…³** | ç»Ÿä¸€å…¥å£ã€è·¯ç”± | Kong, Nginx, Traefik |
| **è´Ÿè½½å‡è¡¡** | æµé‡åˆ†å‘ | Nginx, HAProxy, Envoy |
| **é…ç½®ä¸­å¿ƒ** | é›†ä¸­é…ç½®ç®¡ç† | etcd, Consul, Apollo |
| **æœåŠ¡é—´é€šä¿¡** | RPC/æ¶ˆæ¯é˜Ÿåˆ— | gRPC, HTTP, Kafka, NATS |
| **ç†”æ–­é™æµ** | å®¹é”™ä¿æŠ¤ | Hystrix, Sentinel |
| **åˆ†å¸ƒå¼è¿½è¸ª** | é“¾è·¯è¿½è¸ª | Jaeger, Zipkin, SkyWalking |
| **æœåŠ¡ç½‘æ ¼** | æµé‡æ²»ç† | Istio, Linkerd |

---

### Goå¾®æœåŠ¡ç”Ÿæ€

#### ä¸»æµæ¡†æ¶

1. **go-micro** - å®Œæ•´å¾®æœåŠ¡æ¡†æ¶
2. **Kratos** - Bilibiliå¼€æºï¼Œç”Ÿäº§çº§
3. **go-kit** - å¾®æœåŠ¡å·¥å…·é›†
4. **gRPC-go** - é«˜æ€§èƒ½RPC
5. **Gin + è‡ªå»º** - è½»é‡çº§å®šåˆ¶

#### ä¸ºä»€ä¹ˆé€‰æ‹©Goï¼Ÿ

```text
âœ… é«˜æ€§èƒ½ï¼šå¹¶å‘æ¨¡å‹ä¼˜ç§€ï¼Œé€‚åˆé«˜å¹¶å‘åœºæ™¯
âœ… æ˜“éƒ¨ç½²ï¼šå•ä¸€å¯æ‰§è¡Œæ–‡ä»¶ï¼Œæ— ä¾èµ–
âœ… äº‘åŸç”Ÿï¼šDocker/KubernetesåŸç”Ÿæ”¯æŒ
âœ… ç®€æ´é«˜æ•ˆï¼šå¼€å‘æ•ˆç‡é«˜ï¼Œç»´æŠ¤æˆæœ¬ä½
âœ… ç”Ÿæ€æˆç†Ÿï¼šgRPCã€Consulç­‰ç”Ÿæ€å®Œå–„
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šæœåŠ¡æ³¨å†Œä¸å‘ç°

### ä¸ºä»€ä¹ˆéœ€è¦æœåŠ¡å‘ç°ï¼Ÿ

**é—®é¢˜ç¤ºä¾‹**:

```go
// âŒ ç¡¬ç¼–ç æœåŠ¡åœ°å€çš„é—®é¢˜
func callOrderService() {
    resp, err := http.Get("http://192.168.1.100:8080/orders")
    // é—®é¢˜ï¼š
    // 1. IPå†™æ­»ï¼ŒæœåŠ¡è¿ç§»éœ€è¦ä¿®æ”¹ä»£ç 
    // 2. æ— æ³•è´Ÿè½½å‡è¡¡
    // 3. æ— æ³•æ„ŸçŸ¥æœåŠ¡å¥åº·çŠ¶æ€
    // 4. æ— æ³•åŠ¨æ€æ‰©ç¼©å®¹
}
```

**ä½¿ç”¨æœåŠ¡å‘ç°å**:

```go
// âœ… åŠ¨æ€æœåŠ¡å‘ç°
func callOrderService() {
    // 1. ä»Consulè·å–å¥åº·çš„order-serviceå®ä¾‹
    services, _ := consul.Health().Service("order-service", "", true, nil)
    
    // 2. è´Ÿè½½å‡è¡¡é€‰æ‹©ä¸€ä¸ªå®ä¾‹
    instance := loadBalance(services)
    
    // 3. è°ƒç”¨
    url := fmt.Sprintf("http://%s:%d/orders", instance.Service.Address, instance.Service.Port)
    resp, err := http.Get(url)
}
```

---

### å®æˆ˜æ¡ˆä¾‹1ï¼šåŸºäºConsulçš„æœåŠ¡æ³¨å†Œä¸å‘ç°

#### åœºæ™¯

- ç”¨æˆ·æœåŠ¡ï¼ˆuser-serviceï¼‰æ³¨å†Œåˆ°Consul
- è®¢å•æœåŠ¡ï¼ˆorder-serviceï¼‰å‘ç°å¹¶è°ƒç”¨ç”¨æˆ·æœåŠ¡
- æ”¯æŒå¥åº·æ£€æŸ¥
- æ”¯æŒè´Ÿè½½å‡è¡¡

#### å®Œæ•´å®ç°

```go
package consul

import (
    "fmt"
    "time"
    
    "github.com/hashicorp/consul/api"
)

// ===== æœåŠ¡æ³¨å†Œå™¨ =====
type ServiceRegistry struct {
    client      *api.Client
    serviceID   string
    serviceName string
}

func NewServiceRegistry(consulAddr string) (*ServiceRegistry, error) {
    config := api.DefaultConfig()
    config.Address = consulAddr
    
    client, err := api.NewClient(config)
    if err != nil {
        return nil, err
    }
    
    return &ServiceRegistry{client: client}, nil
}

// Register æ³¨å†ŒæœåŠ¡
func (s *ServiceRegistry) Register(serviceName, serviceAddr string, servicePort int, tags []string) error {
    s.serviceName = serviceName
    s.serviceID = fmt.Sprintf("%s-%d", serviceName, servicePort)
    
    registration := &api.AgentServiceRegistration{
        ID:      s.serviceID,
        Name:    serviceName,
        Address: serviceAddr,
        Port:    servicePort,
        Tags:    tags,
        Check: &api.AgentServiceCheck{
            HTTP:                           fmt.Sprintf("http://%s:%d/health", serviceAddr, servicePort),
            Interval:                       "10s",
            Timeout:                        "3s",
            DeregisterCriticalServiceAfter: "30s",
        },
    }
    
    fmt.Printf("[Consul] Registering service: %s (%s:%d)\n", serviceName, serviceAddr, servicePort)
    
    if err := s.client.Agent().ServiceRegister(registration); err != nil {
        return fmt.Errorf("failed to register service: %w", err)
    }
    
    fmt.Printf("[Consul] Service registered successfully: %s\n", s.serviceID)
    return nil
}

// Deregister æ³¨é”€æœåŠ¡
func (s *ServiceRegistry) Deregister() error {
    fmt.Printf("[Consul] Deregistering service: %s\n", s.serviceID)
    return s.client.Agent().ServiceDeregister(s.serviceID)
}

// ===== æœåŠ¡å‘ç°å™¨ =====
type ServiceDiscovery struct {
    client *api.Client
}

func NewServiceDiscovery(consulAddr string) (*ServiceDiscovery, error) {
    config := api.DefaultConfig()
    config.Address = consulAddr
    
    client, err := api.NewClient(config)
    if err != nil {
        return nil, err
    }
    
    return &ServiceDiscovery{client: client}, nil
}

// ServiceInstance æœåŠ¡å®ä¾‹
type ServiceInstance struct {
    ID      string
    Name    string
    Address string
    Port    int
    Tags    []string
}

// DiscoverService å‘ç°æœåŠ¡ï¼ˆåªè¿”å›å¥åº·çš„å®ä¾‹ï¼‰
func (s *ServiceDiscovery) DiscoverService(serviceName string) ([]*ServiceInstance, error) {
    // passingOnly = true: åªè¿”å›å¥åº·æ£€æŸ¥é€šè¿‡çš„å®ä¾‹
    services, _, err := s.client.Health().Service(serviceName, "", true, nil)
    if err != nil {
        return nil, fmt.Errorf("failed to discover service: %w", err)
    }
    
    if len(services) == 0 {
        return nil, fmt.Errorf("no healthy instances found for service: %s", serviceName)
    }
    
    instances := make([]*ServiceInstance, 0, len(services))
    for _, entry := range services {
        instances = append(instances, &ServiceInstance{
            ID:      entry.Service.ID,
            Name:    entry.Service.Service,
            Address: entry.Service.Address,
            Port:    entry.Service.Port,
            Tags:    entry.Service.Tags,
        })
    }
    
    fmt.Printf("[Consul] Discovered %d instances of %s\n", len(instances), serviceName)
    return instances, nil
}

// ===== è´Ÿè½½å‡è¡¡å™¨ï¼ˆè½®è¯¢ï¼‰=====
type LoadBalancer struct {
    instances []*ServiceInstance
    current   int
}

func NewLoadBalancer(instances []*ServiceInstance) *LoadBalancer {
    return &LoadBalancer{instances: instances}
}

// Next è·å–ä¸‹ä¸€ä¸ªå®ä¾‹ï¼ˆè½®è¯¢ï¼‰
func (lb *LoadBalancer) Next() *ServiceInstance {
    if len(lb.instances) == 0 {
        return nil
    }
    
    instance := lb.instances[lb.current]
    lb.current = (lb.current + 1) % len(lb.instances)
    
    return instance
}
```

#### ç”¨æˆ·æœåŠ¡ï¼ˆæä¾›è€…ï¼‰

```go
package main

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
    
    "github.com/gin-gonic/gin"
)

func main() {
    // 1. åˆ›å»ºæœåŠ¡æ³¨å†Œå™¨
    registry, err := NewServiceRegistry("localhost:8500")
    if err != nil {
        log.Fatal(err)
    }
    
    // 2. æ³¨å†ŒæœåŠ¡
    serviceName := "user-service"
    serviceAddr := "localhost"
    servicePort := 8001
    
    if err := registry.Register(serviceName, serviceAddr, servicePort, []string{"v1"}); err != nil {
        log.Fatal(err)
    }
    
    // 3. å¯åŠ¨HTTPæœåŠ¡
    router := gin.Default()
    
    // å¥åº·æ£€æŸ¥ç«¯ç‚¹
    router.GET("/health", func(c *gin.Context) {
        c.JSON(200, gin.H{"status": "healthy"})
    })
    
    // ä¸šåŠ¡ç«¯ç‚¹
    router.GET("/users/:id", func(c *gin.Context) {
        userID := c.Param("id")
        c.JSON(200, gin.H{
            "id":   userID,
            "name": fmt.Sprintf("User-%s", userID),
            "age":  25,
        })
    })
    
    srv := &http.Server{
        Addr:    fmt.Sprintf(":%d", servicePort),
        Handler: router,
    }
    
    // 4. å¯åŠ¨æœåŠ¡å™¨
    go func() {
        fmt.Printf("[User Service] Starting on port %d...\n", servicePort)
        if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatalf("Server failed: %v", err)
        }
    }()
    
    // 5. ä¼˜é›…å…³é—­
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    fmt.Println("[User Service] Shutting down...")
    
    // æ³¨é”€æœåŠ¡
    registry.Deregister()
    
    // å…³é—­HTTPæœåŠ¡å™¨
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    srv.Shutdown(ctx)
    
    fmt.Println("[User Service] Shutdown complete")
}
```

#### è®¢å•æœåŠ¡ï¼ˆæ¶ˆè´¹è€…ï¼‰

```go
package main

import (
    "encoding/json"
    "fmt"
    "io"
    "log"
    "net/http"
    "time"
)

func main() {
    // 1. åˆ›å»ºæœåŠ¡å‘ç°å™¨
    discovery, err := NewServiceDiscovery("localhost:8500")
    if err != nil {
        log.Fatal(err)
    }
    
    // 2. å‘ç°ç”¨æˆ·æœåŠ¡
    instances, err := discovery.DiscoverService("user-service")
    if err != nil {
        log.Fatal(err)
    }
    
    // 3. åˆ›å»ºè´Ÿè½½å‡è¡¡å™¨
    lb := NewLoadBalancer(instances)
    
    // 4. è°ƒç”¨ç”¨æˆ·æœåŠ¡ï¼ˆ10æ¬¡ï¼Œå±•ç¤ºè´Ÿè½½å‡è¡¡ï¼‰
    for i := 0; i < 10; i++ {
        // é€‰æ‹©ä¸€ä¸ªå®ä¾‹
        instance := lb.Next()
        
        // è°ƒç”¨
        url := fmt.Sprintf("http://%s:%d/users/123", instance.Address, instance.Port)
        resp, err := http.Get(url)
        if err != nil {
            fmt.Printf("[Order Service] Failed to call user service: %v\n", err)
            continue
        }
        
        body, _ := io.ReadAll(resp.Body)
        resp.Body.Close()
        
        var user map[string]interface{}
        json.Unmarshal(body, &user)
        
        fmt.Printf("[Order Service] Called instance %s, got user: %v\n", instance.ID, user)
        
        time.Sleep(500 * time.Millisecond)
    }
}
```

#### è¾“å‡º

```text
[User Service] Starting on port 8001...
[Consul] Registering service: user-service (localhost:8001)
[Consul] Service registered successfully: user-service-8001

[Consul] Discovered 1 instances of user-service
[Order Service] Called instance user-service-8001, got user: map[age:25 id:123 name:User-123]
[Order Service] Called instance user-service-8001, got user: map[age:25 id:123 name:User-123]
...

[User Service] Shutting down...
[Consul] Deregistering service: user-service-8001
[User Service] Shutdown complete
```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šAPIç½‘å…³å®æˆ˜

### ä¸ºä»€ä¹ˆéœ€è¦APIç½‘å…³ï¼Ÿ

**é—®é¢˜**:

- å®¢æˆ·ç«¯éœ€è¦çŸ¥é“æ‰€æœ‰æœåŠ¡åœ°å€
- è®¤è¯/é™æµé€»è¾‘é‡å¤åœ¨æ¯ä¸ªæœåŠ¡
- CORSã€æ—¥å¿—ç­‰æ¨ªåˆ‡å…³æ³¨ç‚¹é‡å¤

**APIç½‘å…³è§£å†³æ–¹æ¡ˆ**:

```text
å®¢æˆ·ç«¯ â†’ APIç½‘å…³ â†’ å¤šä¸ªå¾®æœåŠ¡

APIç½‘å…³èŒè´£ï¼š
1. ç»Ÿä¸€å…¥å£
2. è·¯ç”±è½¬å‘
3. è®¤è¯é‰´æƒ
4. é™æµç†”æ–­
5. æ—¥å¿—ç›‘æ§
6. åè®®è½¬æ¢
```

---

### å®æˆ˜æ¡ˆä¾‹2ï¼šè‡ªå»ºAPIç½‘å…³

#### åœºæ™¯3

- ç»Ÿä¸€å…¥å£
- JWTè®¤è¯
- é™æµ
- è·¯ç”±åˆ°ä¸åŒæœåŠ¡

#### å®Œæ•´å®ç°3

```go
package gateway

import (
    "context"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "strings"
    "sync"
    "time"
    
    "github.com/gin-gonic/gin"
    "github.com/golang-jwt/jwt/v5"
)

// ===== JWTè®¤è¯ä¸­é—´ä»¶ =====
var jwtSecret = []byte("my-secret-key")

type Claims struct {
    UserID string `json:"user_id"`
    jwt.RegisteredClaims
}

// AuthMiddleware JWTè®¤è¯ä¸­é—´ä»¶
func AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. è·å–token
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(401, gin.H{"error": "missing authorization header"})
            c.Abort()
            return
        }
        
        // 2. è§£ætokenï¼ˆæ ¼å¼ï¼šBearer <token>ï¼‰
        parts := strings.Split(authHeader, " ")
        if len(parts) != 2 || parts[0] != "Bearer" {
            c.JSON(401, gin.H{"error": "invalid authorization format"})
            c.Abort()
            return
        }
        
        tokenString := parts[1]
        
        // 3. éªŒè¯token
        token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
            return jwtSecret, nil
        })
        
        if err != nil || !token.Valid {
            c.JSON(401, gin.H{"error": "invalid token"})
            c.Abort()
            return
        }
        
        // 4. æå–claims
        if claims, ok := token.Claims.(*Claims); ok {
            c.Set("user_id", claims.UserID)
            fmt.Printf("[Auth] User %s authenticated\n", claims.UserID)
        }
        
        c.Next()
    }
}

// ===== é™æµä¸­é—´ä»¶ï¼ˆä»¤ç‰Œæ¡¶ï¼‰=====
type RateLimiter struct {
    tokens     int
    maxTokens  int
    refillRate int  // æ¯ç§’refill
    mu         sync.Mutex
    lastRefill time.Time
}

func NewRateLimiter(maxTokens, refillRate int) *RateLimiter {
    return &RateLimiter{
        tokens:     maxTokens,
        maxTokens:  maxTokens,
        refillRate: refillRate,
        lastRefill: time.Now(),
    }
}

func (rl *RateLimiter) Allow() bool {
    rl.mu.Lock()
    defer rl.mu.Unlock()
    
    // è¡¥å……token
    elapsed := time.Since(rl.lastRefill)
    if elapsed > time.Second {
        tokensToAdd := int(elapsed.Seconds()) * rl.refillRate
        rl.tokens = min(rl.maxTokens, rl.tokens+tokensToAdd)
        rl.lastRefill = time.Now()
    }
    
    // æ£€æŸ¥token
    if rl.tokens > 0 {
        rl.tokens--
        return true
    }
    
    return false
}

func RateLimitMiddleware(limiter *RateLimiter) gin.HandlerFunc {
    return func(c *gin.Context) {
        if !limiter.Allow() {
            fmt.Println("[RateLimit] Request rejected - too many requests")
            c.JSON(429, gin.H{"error": "Too Many Requests"})
            c.Abort()
            return
        }
        
        fmt.Printf("[RateLimit] Request allowed, tokens left: %d\n", limiter.tokens)
        c.Next()
    }
}

// ===== æœåŠ¡è·¯ç”±å™¨ =====
type ServiceRouter struct {
    discovery *ServiceDiscovery
    balancers map[string]*LoadBalancer
    mu        sync.RWMutex
}

func NewServiceRouter(discovery *ServiceDiscovery) *ServiceRouter {
    return &ServiceRouter{
        discovery: discovery,
        balancers: make(map[string]*LoadBalancer),
    }
}

// RefreshBalancer åˆ·æ–°è´Ÿè½½å‡è¡¡å™¨
func (sr *ServiceRouter) RefreshBalancer(serviceName string) error {
    instances, err := sr.discovery.DiscoverService(serviceName)
    if err != nil {
        return err
    }
    
    sr.mu.Lock()
    sr.balancers[serviceName] = NewLoadBalancer(instances)
    sr.mu.Unlock()
    
    return nil
}

// ProxyMiddleware ä»£ç†ä¸­é—´ä»¶
func (sr *ServiceRouter) ProxyMiddleware(serviceName string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. è·å–è´Ÿè½½å‡è¡¡å™¨
        sr.mu.RLock()
        lb, exists := sr.balancers[serviceName]
        sr.mu.RUnlock()
        
        if !exists {
            // é¦–æ¬¡è¯·æ±‚ï¼Œåˆ·æ–°è´Ÿè½½å‡è¡¡å™¨
            if err := sr.RefreshBalancer(serviceName); err != nil {
                c.JSON(503, gin.H{"error": fmt.Sprintf("service unavailable: %v", err)})
                return
            }
            
            sr.mu.RLock()
            lb = sr.balancers[serviceName]
            sr.mu.RUnlock()
        }
        
        // 2. é€‰æ‹©å®ä¾‹
        instance := lb.Next()
        if instance == nil {
            c.JSON(503, gin.H{"error": "no available instances"})
            return
        }
        
        // 3. æ„å»ºç›®æ ‡URL
        targetURL := fmt.Sprintf("http://%s:%d%s", instance.Address, instance.Port, c.Request.URL.Path)
        if c.Request.URL.RawQuery != "" {
            targetURL += "?" + c.Request.URL.RawQuery
        }
        
        fmt.Printf("[Gateway] Proxying %s â†’ %s\n", c.Request.URL.Path, targetURL)
        
        // 4. è½¬å‘è¯·æ±‚
        req, err := http.NewRequest(c.Request.Method, targetURL, c.Request.Body)
        if err != nil {
            c.JSON(500, gin.H{"error": "failed to create request"})
            return
        }
        
        // å¤åˆ¶header
        for key, values := range c.Request.Header {
            for _, value := range values {
                req.Header.Add(key, value)
            }
        }
        
        // 5. æ‰§è¡Œè¯·æ±‚
        client := &http.Client{Timeout: 5 * time.Second}
        resp, err := client.Do(req)
        if err != nil {
            c.JSON(502, gin.H{"error": "bad gateway"})
            return
        }
        defer resp.Body.Close()
        
        // 6. è¿”å›å“åº”
        body, _ := io.ReadAll(resp.Body)
        
        // å¤åˆ¶å“åº”header
        for key, values := range resp.Header {
            for _, value := range values {
                c.Writer.Header().Add(key, value)
            }
        }
        
        c.Data(resp.StatusCode, resp.Header.Get("Content-Type"), body)
    }
}

// ===== APIç½‘å…³æœåŠ¡å™¨ =====
func StartGateway() {
    // 1. åˆ›å»ºæœåŠ¡å‘ç°
    discovery, err := NewServiceDiscovery("localhost:8500")
    if err != nil {
        log.Fatal(err)
    }
    
    // 2. åˆ›å»ºè·¯ç”±å™¨
    router := NewServiceRouter(discovery)
    
    // 3. åˆ›å»ºé™æµå™¨ï¼ˆæ¯ç§’10ä¸ªè¯·æ±‚ï¼‰
    limiter := NewRateLimiter(10, 10)
    
    // 4. åˆ›å»ºGinå¼•æ“
    r := gin.Default()
    
    // 5. å…¬å¼€ç«¯ç‚¹ï¼ˆç™»å½•ï¼Œä¸éœ€è¦è®¤è¯ï¼‰
    r.POST("/login", func(c *gin.Context) {
        var req struct {
            Username string `json:"username"`
            Password string `json:"password"`
        }
        
        if err := c.BindJSON(&req); err != nil {
            c.JSON(400, gin.H{"error": "invalid request"})
            return
        }
        
        // ç®€åŒ–ï¼šè·³è¿‡å¯†ç éªŒè¯
        if req.Username == "" {
            c.JSON(400, gin.H{"error": "missing username"})
            return
        }
        
        // ç”ŸæˆJWT
        claims := &Claims{
            UserID: req.Username,
            RegisteredClaims: jwt.RegisteredClaims{
                ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
                IssuedAt:  jwt.NewNumericDate(time.Now()),
            },
        }
        
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, _ := token.SignedString(jwtSecret)
        
        c.JSON(200, gin.H{"token": tokenString})
    })
    
    // 6. å—ä¿æŠ¤çš„ç«¯ç‚¹ï¼ˆéœ€è¦è®¤è¯+é™æµï¼‰
    authorized := r.Group("/api")
    authorized.Use(AuthMiddleware())
    authorized.Use(RateLimitMiddleware(limiter))
    {
        // ç”¨æˆ·æœåŠ¡è·¯ç”±
        authorized.Any("/users/*path", router.ProxyMiddleware("user-service"))
        
        // è®¢å•æœåŠ¡è·¯ç”±
        authorized.Any("/orders/*path", router.ProxyMiddleware("order-service"))
    }
    
    // 7. å¯åŠ¨ç½‘å…³
    fmt.Println("[Gateway] Starting on :8000...")
    r.Run(":8000")
}
```

#### ä½¿ç”¨ç¤ºä¾‹

```bash
# 1. ç™»å½•è·å–token
curl -X POST http://localhost:8000/login \
  -H "Content-Type: application/json" \
  -d '{"username": "alice"}'

# è¾“å‡º: {"token":"eyJhbGciOiJ..."}

# 2. ä½¿ç”¨tokenè®¿é—®ç”¨æˆ·æœåŠ¡
curl http://localhost:8000/api/users/123 \
  -H "Authorization: Bearer eyJhbGciOiJ..."

# è¾“å‡º: {"id":"123","name":"User-123","age":25}

# 3. è¶…è¿‡é™æµ
# å¿«é€Ÿè¯·æ±‚11æ¬¡ï¼Œç¬¬11æ¬¡ä¼šè¢«æ‹’ç»
# è¾“å‡º: {"error":"Too Many Requests"}
```

---

## ç¬¬å››éƒ¨åˆ†ï¼šæœåŠ¡é—´é€šä¿¡

### gRPC vs HTTP

| å¯¹æ¯”é¡¹ | gRPC | HTTP/REST |
|--------|------|-----------|
| **åè®®** | HTTP/2 + Protobuf | HTTP/1.1 + JSON |
| **æ€§èƒ½** | é«˜ï¼ˆäºŒè¿›åˆ¶ï¼‰ | ä¸­ï¼ˆæ–‡æœ¬ï¼‰ |
| **å¥‘çº¦** | å¼ºå¥‘çº¦ï¼ˆ.protoï¼‰ | å¼±å¥‘çº¦ï¼ˆæ–‡æ¡£ï¼‰ |
| **æµå¼** | æ”¯æŒåŒå‘æµ | ä¸æ”¯æŒ |
| **æµè§ˆå™¨** | éœ€è¦gRPC-Web | åŸç”Ÿæ”¯æŒ |
| **é€‚ç”¨åœºæ™¯** | å†…éƒ¨æœåŠ¡é—´ | å¤–éƒ¨API |

---

### å®æˆ˜æ¡ˆä¾‹3ï¼šgRPCæœåŠ¡é—´é€šä¿¡

#### åœºæ™¯4

- è®¢å•æœåŠ¡ï¼ˆgRPCå®¢æˆ·ç«¯ï¼‰è°ƒç”¨ç”¨æˆ·æœåŠ¡ï¼ˆgRPCæœåŠ¡ç«¯ï¼‰
- è·å–ç”¨æˆ·ä¿¡æ¯
- æ”¯æŒè¶…æ—¶å’Œé‡è¯•

#### Protoå®šä¹‰

```protobuf
// user.proto
syntax = "proto3";

package user;
option go_package = "./proto";

service UserService {
  rpc GetUser (GetUserRequest) returns (GetUserResponse) {}
  rpc ListUsers (ListUsersRequest) returns (ListUsersResponse) {}
}

message GetUserRequest {
  string user_id = 1;
}

message GetUserResponse {
  string user_id = 1;
  string name = 2;
  string email = 3;
  int32 age = 4;
}

message ListUsersRequest {
  int32 page = 1;
  int32 page_size = 2;
}

message ListUsersResponse {
  repeated GetUserResponse users = 1;
  int32 total = 2;
}
```

#### æœåŠ¡ç«¯å®ç°

```go
package main

import (
    "context"
    "fmt"
    "log"
    "net"
    
    pb "path/to/proto"
    "google.golang.org/grpc"
)

// ===== gRPCæœåŠ¡å®ç° =====
type UserServiceServer struct {
    pb.UnimplementedUserServiceServer
}

func (s *UserServiceServer) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) {
    fmt.Printf("[gRPC] GetUser called: %s\n", req.UserId)
    
    // æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
    return &pb.GetUserResponse{
        UserId: req.UserId,
        Name:   fmt.Sprintf("User-%s", req.UserId),
        Email:  fmt.Sprintf("user%s@example.com", req.UserId),
        Age:    25,
    }, nil
}

func (s *UserServiceServer) ListUsers(ctx context.Context, req *pb.ListUsersRequest) (*pb.ListUsersResponse, error) {
    fmt.Printf("[gRPC] ListUsers called: page=%d, size=%d\n", req.Page, req.PageSize)
    
    // æ¨¡æ‹Ÿè¿”å›ç”¨æˆ·åˆ—è¡¨
    users := make([]*pb.GetUserResponse, 0, req.PageSize)
    for i := 0; i < int(req.PageSize); i++ {
        users = append(users, &pb.GetUserResponse{
            UserId: fmt.Sprintf("%d", i+1),
            Name:   fmt.Sprintf("User-%d", i+1),
            Email:  fmt.Sprintf("user%d@example.com", i+1),
            Age:    20 + int32(i),
        })
    }
    
    return &pb.ListUsersResponse{
        Users: users,
        Total: 100,
    }, nil
}

func main() {
    // 1. ç›‘å¬ç«¯å£
    lis, err := net.Listen("tcp", ":50051")
    if err != nil {
        log.Fatalf("Failed to listen: %v", err)
    }
    
    // 2. åˆ›å»ºgRPCæœåŠ¡å™¨
    server := grpc.NewServer()
    
    // 3. æ³¨å†ŒæœåŠ¡
    pb.RegisterUserServiceServer(server, &UserServiceServer{})
    
    // 4. å¯åŠ¨æœåŠ¡
    fmt.Println("[gRPC Server] Starting on :50051...")
    if err := server.Serve(lis); err != nil {
        log.Fatalf("Failed to serve: %v", err)
    }
}
```

#### å®¢æˆ·ç«¯å®ç°

```go
package main

import (
    "context"
    "fmt"
    "log"
    "time"
    
    pb "path/to/proto"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
)

func main() {
    // 1. è¿æ¥gRPCæœåŠ¡å™¨
    conn, err := grpc.NewClient(
        "localhost:50051",
        grpc.WithTransportCredentials(insecure.NewCredentials()),
    )
    if err != nil {
        log.Fatalf("Failed to connect: %v", err)
    }
    defer conn.Close()
    
    // 2. åˆ›å»ºå®¢æˆ·ç«¯
    client := pb.NewUserServiceClient(conn)
    
    // 3. è°ƒç”¨GetUserï¼ˆå¸¦è¶…æ—¶ï¼‰
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()
    
    resp, err := client.GetUser(ctx, &pb.GetUserRequest{
        UserId: "123",
    })
    if err != nil {
        log.Fatalf("GetUser failed: %v", err)
    }
    
    fmt.Printf("[gRPC Client] Got user: %+v\n", resp)
    
    // 4. è°ƒç”¨ListUsers
    ctx2, cancel2 := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel2()
    
    listResp, err := client.ListUsers(ctx2, &pb.ListUsersRequest{
        Page:     1,
        PageSize: 5,
    })
    if err != nil {
        log.Fatalf("ListUsers failed: %v", err)
    }
    
    fmt.Printf("[gRPC Client] Got %d users (total: %d)\n", len(listResp.Users), listResp.Total)
    for i, user := range listResp.Users {
        fmt.Printf("  %d. %s (%s)\n", i+1, user.Name, user.Email)
    }
}
```

---

## ç¬¬äº”éƒ¨åˆ†ï¼šé…ç½®ç®¡ç†

### å®æˆ˜æ¡ˆä¾‹4ï¼šåŸºäºetcdçš„é…ç½®ä¸­å¿ƒ

```go
package config

import (
    "context"
    "fmt"
    "time"
    
    clientv3 "go.etcd.io/etcd/client/v3"
)

// ConfigCenter é…ç½®ä¸­å¿ƒ
type ConfigCenter struct {
    client *clientv3.Client
}

func NewConfigCenter(endpoints []string) (*ConfigCenter, error) {
    client, err := clientv3.New(clientv3.Config{
        Endpoints:   endpoints,
        DialTimeout: 5 * time.Second,
    })
    if err != nil {
        return nil, err
    }
    
    return &ConfigCenter{client: client}, nil
}

// GetConfig è·å–é…ç½®
func (cc *ConfigCenter) GetConfig(key string) (string, error) {
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()
    
    resp, err := cc.client.Get(ctx, key)
    if err != nil {
        return "", err
    }
    
    if len(resp.Kvs) == 0 {
        return "", fmt.Errorf("config not found: %s", key)
    }
    
    return string(resp.Kvs[0].Value), nil
}

// SetConfig è®¾ç½®é…ç½®
func (cc *ConfigCenter) SetConfig(key, value string) error {
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()
    
    _, err := cc.client.Put(ctx, key, value)
    return err
}

// WatchConfig ç›‘å¬é…ç½®å˜æ›´
func (cc *ConfigCenter) WatchConfig(key string, callback func(string)) {
    watchChan := cc.client.Watch(context.Background(), key)
    
    for wresp := range watchChan {
        for _, ev := range wresp.Events {
            fmt.Printf("[Config] Config changed: %s â†’ %s\n", ev.Kv.Key, ev.Kv.Value)
            callback(string(ev.Kv.Value))
        }
    }
}
```

---

## ç¬¬å…­éƒ¨åˆ†ï¼šç†”æ–­ä¸é™æµ

### å®æˆ˜æ¡ˆä¾‹5ï¼šç†”æ–­å™¨å®ç°

```go
package circuitbreaker

import (
    "errors"
    "fmt"
    "sync"
    "time"
)

// State ç†”æ–­å™¨çŠ¶æ€
type State int

const (
    StateClosed   State = iota  // å…³é—­ï¼ˆæ­£å¸¸ï¼‰
    StateOpen                    // æ‰“å¼€ï¼ˆç†”æ–­ï¼‰
    StateHalfOpen                // åŠå¼€ï¼ˆè¯•æ¢ï¼‰
)

// CircuitBreaker ç†”æ–­å™¨
type CircuitBreaker struct {
    state            State
    failureCount     int
    successCount     int
    failureThreshold int           // å¤±è´¥é˜ˆå€¼
    successThreshold int           // æˆåŠŸé˜ˆå€¼ï¼ˆåŠå¼€â†’å…³é—­ï¼‰
    timeout          time.Duration // ç†”æ–­æŒç»­æ—¶é—´
    lastFailTime     time.Time
    mu               sync.Mutex
}

func NewCircuitBreaker(failureThreshold, successThreshold int, timeout time.Duration) *CircuitBreaker {
    return &CircuitBreaker{
        state:            StateClosed,
        failureThreshold: failureThreshold,
        successThreshold: successThreshold,
        timeout:          timeout,
    }
}

// Call æ‰§è¡Œè¯·æ±‚ï¼ˆå¸¦ç†”æ–­ä¿æŠ¤ï¼‰
func (cb *CircuitBreaker) Call(fn func() error) error {
    cb.mu.Lock()
    
    // æ£€æŸ¥çŠ¶æ€
    if cb.state == StateOpen {
        // æ£€æŸ¥æ˜¯å¦è¶…æ—¶ï¼Œå¯ä»¥å°è¯•åŠå¼€
        if time.Since(cb.lastFailTime) > cb.timeout {
            fmt.Println("[CircuitBreaker] Timeout elapsed, entering half-open state")
            cb.state = StateHalfOpen
            cb.successCount = 0
        } else {
            cb.mu.Unlock()
            return errors.New("circuit breaker is open")
        }
    }
    
    cb.mu.Unlock()
    
    // æ‰§è¡Œè¯·æ±‚
    err := fn()
    
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    if err != nil {
        // å¤±è´¥
        cb.onFailure()
        return err
    }
    
    // æˆåŠŸ
    cb.onSuccess()
    return nil
}

func (cb *CircuitBreaker) onFailure() {
    cb.failureCount++
    cb.lastFailTime = time.Now()
    
    if cb.state == StateHalfOpen {
        // åŠå¼€æ—¶å¤±è´¥ï¼Œç«‹å³æ‰“å¼€
        fmt.Println("[CircuitBreaker] Half-open failed, opening circuit")
        cb.state = StateOpen
        cb.failureCount = 0
        return
    }
    
    if cb.failureCount >= cb.failureThreshold {
        // å¤±è´¥æ¬¡æ•°è¾¾åˆ°é˜ˆå€¼ï¼Œæ‰“å¼€ç†”æ–­å™¨
        fmt.Printf("[CircuitBreaker] Failure threshold reached (%d), opening circuit\n", cb.failureCount)
        cb.state = StateOpen
        cb.failureCount = 0
    }
}

func (cb *CircuitBreaker) onSuccess() {
    cb.failureCount = 0
    
    if cb.state == StateHalfOpen {
        cb.successCount++
        
        if cb.successCount >= cb.successThreshold {
            // æˆåŠŸæ¬¡æ•°è¾¾åˆ°é˜ˆå€¼ï¼Œå…³é—­ç†”æ–­å™¨
            fmt.Printf("[CircuitBreaker] Success threshold reached (%d), closing circuit\n", cb.successCount)
            cb.state = StateClosed
            cb.successCount = 0
        }
    }
}

func (cb *CircuitBreaker) GetState() State {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    return cb.state
}
```

---

## ç¬¬ä¸ƒéƒ¨åˆ†ï¼šåˆ†å¸ƒå¼è¿½è¸ª

### å®æˆ˜æ¡ˆä¾‹6ï¼šOpenTelemetryè¿½è¸ª

```go
package tracing

import (
    "context"
    "fmt"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/exporters/jaeger"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.17.0"
)

// InitTracer åˆå§‹åŒ–è¿½è¸ªå™¨
func InitTracer(serviceName, jaegerEndpoint string) (*sdktrace.TracerProvider, error) {
    // 1. åˆ›å»ºJaeger exporter
    exporter, err := jaeger.New(jaeger.WithCollectorEndpoint(jaeger.WithEndpoint(jaegerEndpoint)))
    if err != nil {
        return nil, err
    }
    
    // 2. åˆ›å»ºTracerProvider
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter),
        sdktrace.WithResource(resource.NewWithAttributes(
            semconv.SchemaURL,
            semconv.ServiceName(serviceName),
        )),
    )
    
    // 3. è®¾ç½®å…¨å±€TracerProvider
    otel.SetTracerProvider(tp)
    
    return tp, nil
}

// TraceHTTPCall è¿½è¸ªHTTPè°ƒç”¨
func TraceHTTPCall(ctx context.Context, method, url string) context.Context {
    tracer := otel.Tracer("http-client")
    
    ctx, span := tracer.Start(ctx, fmt.Sprintf("%s %s", method, url))
    span.SetAttributes(
        attribute.String("http.method", method),
        attribute.String("http.url", url),
    )
    
    // spanä¼šåœ¨è°ƒç”¨è€…defer span.End()æ—¶ç»“æŸ
    return ctx
}
```

---

## ç¬¬å…«éƒ¨åˆ†ï¼šå®Œæ•´ç”µå•†å¾®æœåŠ¡æ¶æ„

### æ¶æ„è®¾è®¡

```text
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   API Gateway   â”‚
                    â”‚   (Port 8000)   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                  â”‚                  â”‚
    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
    â”‚   User     â”‚    â”‚   Order    â”‚    â”‚  Payment   â”‚
    â”‚  Service   â”‚    â”‚  Service   â”‚    â”‚  Service   â”‚
    â”‚ (Port 8001)â”‚    â”‚ (Port 8002)â”‚    â”‚ (Port 8003)â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                  â”‚                  â”‚
    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
    â”‚  User DB   â”‚    â”‚  Order DB  â”‚    â”‚ Payment DB â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              Consul (æœåŠ¡æ³¨å†Œä¸å‘ç°)             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              Jaeger (åˆ†å¸ƒå¼è¿½è¸ª)                 â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### å¾®æœåŠ¡äº¤äº’æ¶æ„å¯è§†åŒ–

```mermaid
graph TB
    subgraph "å®¢æˆ·ç«¯å±‚"
        Client[ğŸ‘¤ å®¢æˆ·ç«¯åº”ç”¨]
    end
    
    subgraph "æ¥å…¥å±‚"
        Gateway[ğŸŒ API Gateway<br/>JWTè®¤è¯ + é™æµ]
    end
    
    subgraph "æœåŠ¡æ³¨å†Œä¸­å¿ƒ"
        Consul[(ğŸ“‹ Consul<br/>æœåŠ¡å‘ç° + å¥åº·æ£€æŸ¥)]
    end
    
    subgraph "ä¸šåŠ¡æœåŠ¡å±‚"
        UserService[ğŸ‘¥ User Service<br/>:8001]
        OrderService[ğŸ“¦ Order Service<br/>:8002]
        PaymentService[ğŸ’³ Payment Service<br/>:8003]
    end
    
    subgraph "æ•°æ®å±‚"
        UserDB[(ğŸ—„ï¸ User DB<br/>PostgreSQL)]
        OrderDB[(ğŸ—„ï¸ Order DB<br/>PostgreSQL)]
        PaymentDB[(ğŸ—„ï¸ Payment DB<br/>PostgreSQL)]
    end
    
    subgraph "å¯è§‚æµ‹æ€§"
        Jaeger[ğŸ” Jaeger<br/>åˆ†å¸ƒå¼è¿½è¸ª]
    end
    
    Client -->|HTTPS| Gateway
    
    Gateway -.æ³¨å†Œ/å‘ç°.-> Consul
    UserService -.æ³¨å†Œ.-> Consul
    OrderService -.æ³¨å†Œ.-> Consul
    PaymentService -.æ³¨å†Œ.-> Consul
    
    Gateway -->|REST/gRPC| UserService
    Gateway -->|REST/gRPC| OrderService
    Gateway -->|REST/gRPC| PaymentService
    
    OrderService -->|gRPC| UserService
    OrderService -->|gRPC| PaymentService
    
    UserService --> UserDB
    OrderService --> OrderDB
    PaymentService --> PaymentDB
    
    Gateway -.è¿½è¸ª.-> Jaeger
    UserService -.è¿½è¸ª.-> Jaeger
    OrderService -.è¿½è¸ª.-> Jaeger
    PaymentService -.è¿½è¸ª.-> Jaeger
    
    style Client fill:#e1f5ff
    style Gateway fill:#ffe1e1
    style Consul fill:#fff4e1
    style UserService fill:#e1ffe1
    style OrderService fill:#e1ffe1
    style PaymentService fill:#e1ffe1
    style UserDB fill:#f5e1ff
    style OrderDB fill:#f5e1ff
    style PaymentDB fill:#f5e1ff
    style Jaeger fill:#ffe1f5
```

#### è®¢å•åˆ›å»ºè°ƒç”¨é“¾æ—¶åºå›¾

```mermaid
sequenceDiagram
    participant C as å®¢æˆ·ç«¯
    participant G as API Gateway
    participant OS as Order Service
    participant US as User Service
    participant PS as Payment Service
    participant Consul as Consul
    participant Jaeger as Jaeger
    
    Note over C,Jaeger: åˆ›å»ºè®¢å•å®Œæ•´æµç¨‹
    
    C->>G: POST /api/orders<br/>[JWT Token]
    G->>G: â‘  JWTéªŒè¯
    G->>G: â‘¡ é™æµæ£€æŸ¥
    
    G->>Consul: â‘¢ æŸ¥è¯¢ order-service
    Consul-->>G: è¿”å›å¥åº·å®ä¾‹åˆ—è¡¨
    
    G->>OS: â‘£ è½¬å‘è¯·æ±‚
    Note over OS: TraceID: abc123
    OS->>Jaeger: è®°å½•Span: create_order
    
    rect rgb(220, 230, 250)
        Note over OS,US: ç”¨æˆ·éªŒè¯
        OS->>Consul: æŸ¥è¯¢ user-service
        Consul-->>OS: è¿”å›å®ä¾‹
        OS->>US: gRPC: GetUser(userID)
        US->>Jaeger: è®°å½•Span: get_user
        US-->>OS: è¿”å›ç”¨æˆ·ä¿¡æ¯
    end
    
    rect rgb(250, 230, 220)
        Note over OS,PS: æ”¯ä»˜å¤„ç†
        OS->>Consul: æŸ¥è¯¢ payment-service
        Consul-->>OS: è¿”å›å®ä¾‹
        OS->>PS: gRPC: CreatePayment(orderID)
        PS->>Jaeger: è®°å½•Span: create_payment
        PS-->>OS: æ”¯ä»˜æˆåŠŸ
    end
    
    OS->>OS: â‘¤ ä¿å­˜è®¢å•åˆ°æ•°æ®åº“
    OS->>Jaeger: è®°å½•å®Œæ•´é“¾è·¯
    
    OS-->>G: 200 OK (è®¢å•ID)
    G-->>C: è¿”å›è®¢å•ä¿¡æ¯
    
    Note over Jaeger: å®Œæ•´é“¾è·¯å¯è§†åŒ–:<br/>create_order â†’ get_user â†’ create_payment
```

### æ ¸å¿ƒç‰¹æ€§

1. **æœåŠ¡æ³¨å†Œä¸å‘ç°** - Consul
2. **APIç½‘å…³** - ç»Ÿä¸€å…¥å£ã€è®¤è¯ã€é™æµ
3. **gRPCé€šä¿¡** - æœåŠ¡é—´é«˜æ€§èƒ½é€šä¿¡
4. **ç†”æ–­ä¿æŠ¤** - é˜²æ­¢çº§è”æ•…éšœ
5. **åˆ†å¸ƒå¼è¿½è¸ª** - Jaegerå…¨é“¾è·¯è¿½è¸ª
6. **é…ç½®ç®¡ç†** - etcdé›†ä¸­é…ç½®

---

## ç¬¬ä¹éƒ¨åˆ†ï¼šæœ€ä½³å®è·µ

### å¾®æœåŠ¡è®¾è®¡åŸåˆ™

| åŸåˆ™ | è¯´æ˜ | ç¤ºä¾‹ |
|------|------|------|
| **å•ä¸€èŒè´£** | æ¯ä¸ªæœåŠ¡åªè´Ÿè´£ä¸€ä¸ªä¸šåŠ¡èƒ½åŠ› | ç”¨æˆ·æœåŠ¡åªç®¡ç†ç”¨æˆ· |
| **æœåŠ¡è‡ªæ²»** | ç‹¬ç«‹éƒ¨ç½²ã€ç‹¬ç«‹æ•°æ®åº“ | æ¯ä¸ªæœåŠ¡æœ‰ç‹¬ç«‹DB |
| **æ¥å£å¥‘çº¦** | æ˜ç¡®çš„APIå®šä¹‰ | ä½¿ç”¨.protoå®šä¹‰æ¥å£ |
| **å®¹é”™è®¾è®¡** | ç†”æ–­ã€é™çº§ã€é‡è¯• | ç†”æ–­å™¨ä¿æŠ¤ |
| **å¯è§‚æµ‹æ€§** | æ—¥å¿—ã€ç›‘æ§ã€è¿½è¸ª | OpenTelemetry |
| **å®‰å…¨ä¼˜å…ˆ** | è®¤è¯ã€åŠ å¯†ã€æˆæƒ | JWT + mTLS |

### å¸¸è§é™·é˜±

#### é™·é˜±1ï¼šæœåŠ¡æ‹†åˆ†è¿‡ç»†

```go
// âŒ é”™è¯¯ï¼šè¿‡åº¦æ‹†åˆ†
// æ¯ä¸ªå®ä½“ä¸€ä¸ªæœåŠ¡ï¼šUser Service, UserProfile Service, UserSettings Service
// é—®é¢˜ï¼šç½‘ç»œå¼€é”€å¤§ï¼Œç»´æŠ¤æˆæœ¬é«˜

// âœ… æ­£ç¡®ï¼šåˆç†èšåˆ
// ç”¨æˆ·åŸŸæœåŠ¡ï¼šUser Serviceï¼ˆåŒ…å«profileã€settingsï¼‰
```

#### é™·é˜±2ï¼šå…±äº«æ•°æ®åº“

```go
// âŒ é”™è¯¯ï¼šå¤šä¸ªæœåŠ¡å…±äº«æ•°æ®åº“
// User Service å’Œ Order Service éƒ½ç›´æ¥è®¿é—® users è¡¨
// é—®é¢˜ï¼šå¼ºè€¦åˆï¼Œæ— æ³•ç‹¬ç«‹æ‰©å±•

// âœ… æ­£ç¡®ï¼šDatabase per Service
// User Service â†’ User DB
// Order Service â†’ Order DBï¼ˆé€šè¿‡APIè·å–ç”¨æˆ·ä¿¡æ¯ï¼‰
```

#### é™·é˜±3ï¼šå¿½ç•¥åˆ†å¸ƒå¼è¿½è¸ª

```go
// âŒ é”™è¯¯ï¼šæ²¡æœ‰TraceID
// é—®é¢˜ï¼šæ— æ³•è¿½è¸ªè·¨æœåŠ¡è¯·æ±‚é“¾è·¯

// âœ… æ­£ç¡®ï¼šæ³¨å…¥TraceID
ctx = TraceHTTPCall(ctx, "GET", url)
defer span.End()
```

---

## ğŸ¯ æ€»ç»“

### å¾®æœåŠ¡æ ¸å¿ƒè¦ç‚¹

1. **æœåŠ¡æ³¨å†Œä¸å‘ç°** - Consulå®ç°åŠ¨æ€æœåŠ¡ç®¡ç†
2. **APIç½‘å…³** - ç»Ÿä¸€å…¥å£ï¼Œè®¤è¯ã€é™æµã€è·¯ç”±
3. **æœåŠ¡é—´é€šä¿¡** - gRPCé«˜æ€§èƒ½ï¼ŒHTTPæ˜“ç”¨
4. **é…ç½®ç®¡ç†** - etcdé›†ä¸­é…ç½®ï¼Œæ”¯æŒçƒ­æ›´æ–°
5. **ç†”æ–­é™æµ** - ä¿æŠ¤ç³»ç»Ÿç¨³å®šæ€§
6. **åˆ†å¸ƒå¼è¿½è¸ª** - OpenTelemetryå…¨é“¾è·¯å¯è§‚æµ‹

### æŠ€æœ¯é€‰å‹å»ºè®®

| åœºæ™¯ | æ¨èæŠ€æœ¯ | ç†ç”± |
|------|---------|------|
| æœåŠ¡æ³¨å†Œ | Consul | æˆç†Ÿã€æ˜“ç”¨ã€å¥åº·æ£€æŸ¥ |
| æœåŠ¡é—´é€šä¿¡ | gRPC | é«˜æ€§èƒ½ã€å¼ºå¥‘çº¦ |
| APIç½‘å…³ | è‡ªå»º/Kong | çµæ´»å¯æ§ |
| é…ç½®ä¸­å¿ƒ | etcd | ç®€å•å¯é  |
| è¿½è¸ª | Jaeger | äº‘åŸç”Ÿã€è½»é‡ |
| æœåŠ¡ç½‘æ ¼ | Istio | æµé‡æ²»ç†å®Œå–„ |

---

**æ–‡æ¡£ç‰ˆæœ¬**: v5.0  

<div align="center">

Made with â¤ï¸ for Go Microservices

[â¬† å›åˆ°é¡¶éƒ¨](#goå¾®æœåŠ¡æ¶æ„æ·±åº¦å®æˆ˜æŒ‡å—)

</div>

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Go Documentation Team  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ20æ—¥  
**æ–‡æ¡£çŠ¶æ€**: å®Œæˆ  
**é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.3+
