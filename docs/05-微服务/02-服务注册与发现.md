# 服务注册与发现

<!-- TOC START -->
- [13.2 服务注册与发现](#132-服务注册与发现)
  - [13.2.1 📚 理论分析](#1321--理论分析)
    - [13.2.1.1 服务注册与发现原理](#13211-服务注册与发现原理)
    - [13.2.1.2 常见注册中心对比](#13212-常见注册中心对比)
    - [13.2.1.3 Go语言实现方案](#13213-go语言实现方案)
  - [13.2.2 💻 代码示例](#1322--代码示例)
    - [13.2.2.1 Consul服务注册](#13221-consul服务注册)
    - [13.2.2.2 etcd服务发现](#13222-etcd服务发现)
    - [13.2.2.3 健康检查实现](#13223-健康检查实现)
  - [13.2.3 🎯 最佳实践](#1323--最佳实践)
  - [13.2.4 🔍 常见问题](#1324--常见问题)
  - [13.2.5 📚 扩展阅读](#1325--扩展阅读)
  - [13.2.6 ✅ 落地检查清单](#1326--落地检查清单)
  - [13.2.7 🧪 本地快速验证](#1327--本地快速验证)
<!-- TOC END -->

## 📚 理论分析

### 服务注册与发现原理

服务注册与发现是微服务架构中的核心组件，负责：

- **服务注册**: 服务启动时向注册中心注册自己的信息
- **服务发现**: 客户端通过注册中心查找可用的服务实例
- **健康检查**: 定期检查服务实例的健康状态
- **负载均衡**: 在多个服务实例间进行负载分发

### 常见注册中心对比

| 注册中心 | 语言 | 一致性 | 性能 | 易用性 | 社区活跃度 |
|----------|------|--------|------|--------|------------|
| Consul | Go | 强一致性 | 高 | 高 | 活跃 |
| etcd | Go | 强一致性 | 高 | 中 | 活跃 |
| Eureka | Java | 最终一致性 | 中 | 高 | 活跃 |
| Nacos | Java | 强一致性 | 高 | 高 | 活跃 |

### Go语言实现方案

- **Consul**: 官方Go客户端，功能完整
- **etcd**: 官方Go客户端，性能优秀
- **go-micro**: 微服务框架，内置服务发现
- **kratos**: 字节跳动开源框架

## 💻 代码示例

### Consul服务注册

```go
package main

import (
    "fmt"
    "log"
    "net/http"
    "time"

    "github.com/hashicorp/consul/api"
)

type ServiceRegistry struct {
    client *api.Client
}

func NewServiceRegistry() (*ServiceRegistry, error) {
    config := api.DefaultConfig()
    config.Address = "localhost:8500"
    
    client, err := api.NewClient(config)
    if err != nil {
        return nil, err
    }
    
    return &ServiceRegistry{client: client}, nil
}

func (sr *ServiceRegistry) Register(serviceName, serviceID, address string, port int) error {
    registration := &api.AgentServiceRegistration{
        ID:      serviceID,
        Name:    serviceName,
        Address: address,
        Port:    port,
        Check: &api.AgentServiceCheck{
            HTTP:                           fmt.Sprintf("http://%s:%d/health", address, port),
            Timeout:                        "3s",
            Interval:                       "10s",
            DeregisterCriticalServiceAfter: "30s",
        },
    }
    
    return sr.client.Agent().ServiceRegister(registration)
}

func (sr *ServiceRegistry) Deregister(serviceID string) error {
    return sr.client.Agent().ServiceDeregister(serviceID)
}

func (sr *ServiceRegistry) Discover(serviceName string) ([]*api.ServiceEntry, error) {
    services, _, err := sr.client.Health().Service(serviceName, "", true, nil)
    return services, err
}

// 使用示例
func main() {
    registry, err := NewServiceRegistry()
    if err != nil {
        log.Fatal(err)
    }
    
    // 注册服务
    err = registry.Register("user-service", "user-service-1", "localhost", 8080)
    if err != nil {
        log.Fatal(err)
    }
    
    // 健康检查端点
    http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("OK"))
    })
    
    // 启动服务
    go func() {
        log.Println("服务启动在 :8080")
        log.Fatal(http.ListenAndServe(":8080", nil))
    }()
    
    // 服务发现示例
    time.Sleep(5 * time.Second)
    services, err := registry.Discover("user-service")
    if err != nil {
        log.Fatal(err)
    }
    
    for _, service := range services {
        fmt.Printf("发现服务: %s:%d\n", 
            service.Service.Address, service.Service.Port)
    }
    
    // 保持运行
    select {}
}
```

### etcd服务发现

```go
package main

import (
    "context"
    "fmt"
    "log"
    "time"

    "go.etcd.io/etcd/clientv3"
)

type EtcdRegistry struct {
    client *clientv3.Client
}

func NewEtcdRegistry(endpoints []string) (*EtcdRegistry, error) {
    client, err := clientv3.New(clientv3.Config{
        Endpoints:   endpoints,
        DialTimeout: 5 * time.Second,
    })
    if err != nil {
        return nil, err
    }
    
    return &EtcdRegistry{client: client}, nil
}

func (er *EtcdRegistry) Register(serviceName, serviceID, address string, port int, ttl int64) error {
    key := fmt.Sprintf("/services/%s/%s", serviceName, serviceID)
    value := fmt.Sprintf("%s:%d", address, port)
    
    // 创建租约
    lease, err := er.client.Grant(context.Background(), ttl)
    if err != nil {
        return err
    }
    
    // 注册服务
    _, err = er.client.Put(context.Background(), key, value, clientv3.WithLease(lease.ID))
    if err != nil {
        return err
    }
    
    // 续租
    ch, kaerr := er.client.KeepAlive(context.Background(), lease.ID)
    if kaerr != nil {
        return kaerr
    }
    
    // 处理续租响应
    go func() {
        for ka := range ch {
            _ = ka
        }
    }()
    
    return nil
}

func (er *EtcdRegistry) Discover(serviceName string) ([]string, error) {
    key := fmt.Sprintf("/services/%s/", serviceName)
    
    resp, err := er.client.Get(context.Background(), key, clientv3.WithPrefix())
    if err != nil {
        return nil, err
    }
    
    var services []string
    for _, kv := range resp.Kvs {
        services = append(services, string(kv.Value))
    }
    
    return services, nil
}

func (er *EtcdRegistry) Watch(serviceName string) <-chan []string {
    ch := make(chan []string, 1)
    
    go func() {
        key := fmt.Sprintf("/services/%s/", serviceName)
        watchCh := er.client.Watch(context.Background(), key, clientv3.WithPrefix())
        
        for wresp := range watchCh {
            services, _ := er.Discover(serviceName)
            ch <- services
        }
    }()
    
    return ch
}

// 使用示例
func main() {
    registry, err := NewEtcdRegistry([]string{"localhost:2379"})
    if err != nil {
        log.Fatal(err)
    }
    defer registry.client.Close()
    
    // 注册服务
    err = registry.Register("user-service", "user-service-1", "localhost", 8080, 10)
    if err != nil {
        log.Fatal(err)
    }
    
    // 服务发现
    services, err := registry.Discover("user-service")
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("发现服务: %v\n", services)
    
    // 监听服务变化
    watchCh := registry.Watch("user-service")
    for services := range watchCh {
        fmt.Printf("服务列表更新: %v\n", services)
    }
}
```

### 健康检查实现

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "time"
)

type HealthChecker struct {
    checks map[string]func() error
}

func NewHealthChecker() *HealthChecker {
    return &HealthChecker{
        checks: make(map[string]func() error),
    }
}

func (hc *HealthChecker) AddCheck(name string, check func() error) {
    hc.checks[name] = check
}

func (hc *HealthChecker) CheckHealth() map[string]error {
    results := make(map[string]error)
    
    for name, check := range hc.checks {
        results[name] = check()
    }
    
    return results
}

func (hc *HealthChecker) IsHealthy() bool {
    results := hc.CheckHealth()
    for _, err := range results {
        if err != nil {
            return false
        }
    }
    return true
}

// 数据库健康检查
func (hc *HealthChecker) AddDatabaseCheck(db interface{}) {
    hc.AddCheck("database", func() error {
        // 实现数据库连接检查
        // 这里简化处理
        return nil
    })
}

// Redis健康检查
func (hc *HealthChecker) AddRedisCheck(redis interface{}) {
    hc.AddCheck("redis", func() error {
        // 实现Redis连接检查
        return nil
    })
}

// HTTP健康检查端点
func (hc *HealthChecker) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    if hc.IsHealthy() {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("OK"))
    } else {
        w.WriteHeader(http.StatusServiceUnavailable)
        w.Write([]byte("Service Unavailable"))
    }
}

// 使用示例
func main() {
    checker := NewHealthChecker()
    
    // 添加健康检查
    checker.AddCheck("memory", func() error {
        // 检查内存使用情况
        return nil
    })
    
    checker.AddCheck("disk", func() error {
        // 检查磁盘空间
        return nil
    })
    
    // 启动健康检查服务
    http.HandleFunc("/health", checker.ServeHTTP)
    
    go func() {
        log.Println("健康检查服务启动在 :8081")
        log.Fatal(http.ListenAndServe(":8081", nil))
    }()
    
    // 定期健康检查
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        if !checker.IsHealthy() {
            log.Println("健康检查失败")
        }
    }
}
```

## 🎯 最佳实践

1. **服务注册时机**: 服务启动完成后再注册，避免注册了但服务未就绪
2. **健康检查**: 实现有意义的健康检查，避免误判
3. **优雅下线**: 服务停止前先注销注册，避免流量打到已停止的服务
4. **负载均衡**: 结合负载均衡策略，合理分发请求
5. **监控告警**: 监控注册中心状态，及时发现问题

## 🔍 常见问题

1. **脑裂问题**: 网络分区时可能出现多个主节点
2. **服务雪崩**: 大量服务同时下线导致连锁反应
3. **配置管理**: 服务配置变更时的通知机制
4. **版本兼容**: 服务版本升级时的兼容性处理

## 📚 扩展阅读

- [Consul官方文档](https://www.consul.io/docs)
- [etcd官方文档](https://etcd.io/docs/)
- [go-micro框架](https://github.com/asim/go-micro)
- [kratos框架](https://github.com/go-kratos/kratos)

## ✅ 落地检查清单

- 注册方式：主动注册/被动注册（Sidecar采集）是否明确；去注册流程是否可控
- 健康检查：liveness/readiness 区分；检查项覆盖数据库/缓存/下游依赖
- 发现方式：直连注册中心 vs. 网关/Sidecar 代理，是否有缓存与退路
- 负载策略：轮询/加权/最小连接；实例权重、熔断、优雅下线是否生效
- 多环境：命名空间/数据中心隔离；跨AZ/机房容灾切流方案
- 安全：注册中心鉴权、ACL/ACL Token、mTLS 信任链
- 可观测：注册/发现耗时与失败率；实例上下线审计与告警

## 🧪 本地快速验证

1. 启动注册中心：
   - Consul: `consul agent -dev -client=0.0.0.0`
   - etcd: `etcd --listen-client-urls=http://0.0.0.0:2379 --advertise-client-urls=http://127.0.0.1:2379`
2. 运行示例：分别运行“Consul服务注册”和“etcd服务发现”的 `main` 程序。
3. 验证健康：访问 `http://localhost:8500/ui`（Consul Web UI）或用 `etcdctl get --prefix /services/` 查看实例。
4. 断言行为：
   - 停止服务进程，确认实例在超时后自动摘除（Deregister/TTL 续租失效）。
   - 修改权重/实例列表，观察发现端的流量切换与列表变更。

---

**文档维护者**: Go Documentation Team  
**最后更新**: 2025年10月20日  
**文档状态**: 完成  
**适用版本**: Go 1.21+
